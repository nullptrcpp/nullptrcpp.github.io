<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTFwd.h", "content": "//===--- ASTFwd.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===--------------------------------------------------------------===//\n///\n/// \\file\n/// Forward declaration of all AST node types.\n///\n//===-------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTFWD_H\n#define LLVM_CLANG_AST_ASTFWD_H\n\nnamespace clang {\n\nclass Decl;\n#define DECL(DERIVED, BASE) class DERIVED##Decl;\n#include \"clang/AST/DeclNodes.inc\"\nclass Stmt;\n#define STMT(DERIVED, BASE) class DERIVED;\n#include \"clang/AST/StmtNodes.inc\"\nclass Type;\n#define TYPE(DERIVED, BASE) class DERIVED##Type;\n#include \"clang/AST/TypeNodes.inc\"\nclass CXXCtorInitializer;\nclass OMPClause;\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) class Class;\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n\n} // end namespace clang\n\n#endif\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/BodyFarm.h", "content": "//== BodyFarm.h - Factory for conjuring up fake bodies -------------*- C++ -*-//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// BodyFarm is a factory for creating faux implementations for functions/methods\n// for analysis purposes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_ANALYSIS_BODYFARM_H\n#define LLVM_CLANG_LIB_ANALYSIS_BODYFARM_H\n\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Optional.h\"\n\nnamespace clang {\n\nclass ASTContext;\nclass FunctionDecl;\nclass ObjCMethodDecl;\nclass ObjCPropertyDecl;\nclass Stmt;\nclass CodeInjector;\n\nclass BodyFarm {\npublic:\n  BodyFarm(ASTContext &C, CodeInjector *injector) : C(C), Injector(injector) {}\n\n  /// Factory method for creating bodies for ordinary functions.\n  Stmt *getBody(const FunctionDecl *D);\n\n  /// Factory method for creating bodies for Objective-C properties.\n  Stmt *getBody(const ObjCMethodDecl *D);\n\n  /// Remove copy constructor to avoid accidental copying.\n  BodyFarm(const BodyFarm &other) = delete;\n\nprivate:\n  typedef llvm::DenseMap<const Decl *, Optional<Stmt *>> BodyMap;\n\n  ASTContext &C;\n  BodyMap Bodies;\n  CodeInjector *Injector;\n};\n} // namespace clang\n\n#endif\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "content": "//===- PathDiagnostic.h - Path-Specific Diagnostic Handling -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PathDiagnostic-related interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <deque>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass BinaryOperator;\nclass CallEnter;\nclass CallExitEnd;\nclass CallExpr;\nclass ConditionalOperator;\nclass Decl;\nclass Expr;\nclass LocationContext;\nclass MemberExpr;\nclass ProgramPoint;\nclass SourceManager;\n\nnamespace ento {\n\n//===----------------------------------------------------------------------===//\n// High-level interface for handlers of path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnostic;\n\n/// These options tweak the behavior of path diangostic consumers.\n/// Most of these options are currently supported by very few consumers.\nstruct PathDiagnosticConsumerOptions {\n  /// Run-line of the tool that produced the diagnostic.\n  /// It can be included with the diagnostic for debugging purposes.\n  std::string ToolInvocation;\n\n  /// Whether to include additional information about macro expansions\n  /// with the diagnostics, because otherwise they can be hard to obtain\n  /// without re-compiling the program under analysis.\n  bool ShouldDisplayMacroExpansions = false;\n\n  /// Whether to include LLVM statistics of the process in the diagnostic.\n  /// Useful for profiling the tool on large real-world codebases.\n  bool ShouldSerializeStats = false;\n\n  /// If the consumer intends to produce multiple output files, should it\n  /// use randomly generated file names for these files (with the tiny risk of\n  /// having random collisions) or deterministic human-readable file names\n  /// (with a larger risk of deterministic collisions or invalid characters\n  /// in the file name). We should not really give this choice to the users\n  /// because deterministic mode is always superior when done right, but\n  /// for some consumers this mode is experimental and needs to be\n  /// off by default.\n  bool ShouldWriteStableReportFilename = false;\n\n  /// Whether the consumer should treat consumed diagnostics as hard errors.\n  /// Useful for breaking your build when issues are found.\n  bool ShouldDisplayWarningsAsErrors = false;\n\n  /// Whether the consumer should attempt to rewrite the source file\n  /// with fix-it hints attached to the diagnostics it consumes.\n  bool ShouldApplyFixIts = false;\n\n  /// Whether the consumer should present the name of the entity that emitted\n  /// the diagnostic (eg., a checker) so that the user knew how to disable it.\n  bool ShouldDisplayDiagnosticName = false;\n};\n\nclass PathDiagnosticConsumer {\npublic:\n  class PDFileEntry : public llvm::FoldingSetNode {\n  public:\n    PDFileEntry(llvm::FoldingSetNodeID &NodeID) : NodeID(NodeID) {}\n\n    using ConsumerFiles = std::vector<std::pair<StringRef, StringRef>>;\n\n    /// A vector of <consumer,file> pairs.\n    ConsumerFiles files;\n\n    /// A precomputed hash tag used for uniquing PDFileEntry objects.\n    const llvm::FoldingSetNodeID NodeID;\n\n    /// Used for profiling in the FoldingSet.\n    void Profile(llvm::FoldingSetNodeID &ID) { ID = NodeID; }\n  };\n\n  class FilesMade {\n    llvm::BumpPtrAllocator Alloc;\n    llvm::FoldingSet<PDFileEntry> Set;\n\n  public:\n    ~FilesMade();\n\n    bool empty() const { return Set.empty(); }\n\n    void addDiagnostic(const PathDiagnostic &PD,\n                       StringRef ConsumerName,\n                       StringRef fileName);\n\n    PDFileEntry::ConsumerFiles *getFiles(const PathDiagnostic &PD);\n  };\n\nprivate:\n  virtual void anchor();\n\npublic:\n  PathDiagnosticConsumer() = default;\n  virtual ~PathDiagnosticConsumer();\n\n  void FlushDiagnostics(FilesMade *FilesMade);\n\n  virtual void FlushDiagnosticsImpl(std::vector<const PathDiagnostic *> &Diags,\n                                    FilesMade *filesMade) = 0;\n\n  virtual StringRef getName() const = 0;\n\n  void HandlePathDiagnostic(std::unique_ptr<PathDiagnostic> D);\n\n  enum PathGenerationScheme {\n    /// Only runs visitors, no output generated.\n    None,\n\n    /// Used for HTML, SARIF, and text output.\n    Minimal,\n\n    /// Used for plist output, used for \"arrows\" generation.\n    Extensive,\n  };\n\n  virtual PathGenerationScheme getGenerationScheme() const { return Minimal; }\n\n  bool shouldGenerateDiagnostics() const {\n    return getGenerationScheme() != None;\n  }\n\n  bool shouldAddPathEdges() const { return getGenerationScheme() == Extensive; }\n\n  virtual bool supportsLogicalOpControlFlow() const { return false; }\n\n  /// Return true if the PathDiagnosticConsumer supports individual\n  /// PathDiagnostics that span multiple files.\n  virtual bool supportsCrossFileDiagnostics() const { return false; }\n\nprotected:\n  bool flushed = false;\n  llvm::FoldingSet<PathDiagnostic> Diags;\n};\n\n//===----------------------------------------------------------------------===//\n// Path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticRange : public SourceRange {\npublic:\n  bool isPoint = false;\n\n  PathDiagnosticRange(SourceRange R, bool isP = false)\n      : SourceRange(R), isPoint(isP) {}\n  PathDiagnosticRange() = default;\n};\n\nusing LocationOrAnalysisDeclContext =\n    llvm::PointerUnion<const LocationContext *, AnalysisDeclContext *>;\n\nclass PathDiagnosticLocation {\nprivate:\n  enum Kind { RangeK, SingleLocK, StmtK, DeclK } K = SingleLocK;\n\n  const Stmt *S = nullptr;\n  const Decl *D = nullptr;\n  const SourceManager *SM = nullptr;\n  FullSourceLoc Loc;\n  PathDiagnosticRange Range;\n\n  PathDiagnosticLocation(SourceLocation L, const SourceManager &sm, Kind kind)\n      : K(kind), SM(&sm), Loc(genLocation(L)), Range(genRange()) {}\n\n  FullSourceLoc genLocation(\n      SourceLocation L = SourceLocation(),\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\n  PathDiagnosticRange genRange(\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\npublic:\n  /// Create an invalid location.\n  PathDiagnosticLocation() = default;\n\n  /// Create a location corresponding to the given statement.\n  PathDiagnosticLocation(const Stmt *s, const SourceManager &sm,\n                         LocationOrAnalysisDeclContext lac)\n      : K(s->getBeginLoc().isValid() ? StmtK : SingleLocK),\n        S(K == StmtK ? s : nullptr), SM(&sm),\n        Loc(genLocation(SourceLocation(), lac)), Range(genRange(lac)) {\n    assert(K == SingleLocK || S);\n    assert(K == SingleLocK || Loc.isValid());\n    assert(K == SingleLocK || Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  PathDiagnosticLocation(const Decl *d, const SourceManager &sm)\n      : K(DeclK), D(d), SM(&sm), Loc(genLocation()), Range(genRange()) {\n    assert(D);\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location at an explicit offset in the source.\n  ///\n  /// This should only be used if there are no more appropriate constructors.\n  PathDiagnosticLocation(SourceLocation loc, const SourceManager &sm)\n      : SM(&sm), Loc(loc, sm), Range(genRange()) {\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  static PathDiagnosticLocation create(const Decl *D,\n                                       const SourceManager &SM) {\n    return PathDiagnosticLocation(D, SM);\n  }\n\n  /// Create a location for the beginning of the declaration.\n  static PathDiagnosticLocation createBegin(const Decl *D,\n                                            const SourceManager &SM);\n\n  /// Create a location for the beginning of the declaration.\n  /// The third argument is ignored, useful for generic treatment\n  /// of statements and declarations.\n  static PathDiagnosticLocation\n  createBegin(const Decl *D, const SourceManager &SM,\n              const LocationOrAnalysisDeclContext LAC) {\n    return createBegin(D, SM);\n  }\n\n  /// Create a location for the beginning of the statement.\n  static PathDiagnosticLocation createBegin(const Stmt *S,\n                                            const SourceManager &SM,\n                                            const LocationOrAnalysisDeclContext LAC);\n\n  /// Create a location for the end of the statement.\n  ///\n  /// If the statement is a CompoundStatement, the location will point to the\n  /// closing brace instead of following it.\n  static PathDiagnosticLocation createEnd(const Stmt *S,\n                                          const SourceManager &SM,\n                                       const LocationOrAnalysisDeclContext LAC);\n\n  /// Create the location for the operator of the binary expression.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createOperatorLoc(const BinaryOperator *BO,\n                                                  const SourceManager &SM);\n  static PathDiagnosticLocation createConditionalColonLoc(\n                                                  const ConditionalOperator *CO,\n                                                  const SourceManager &SM);\n\n  /// For member expressions, return the location of the '.' or '->'.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createMemberLoc(const MemberExpr *ME,\n                                                const SourceManager &SM);\n\n  /// Create a location for the beginning of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createBeginBrace(const CompoundStmt *CS,\n                                                 const SourceManager &SM);\n\n  /// Create a location for the end of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createEndBrace(const CompoundStmt *CS,\n                                               const SourceManager &SM);\n\n  /// Create a location for the beginning of the enclosing declaration body.\n  /// Defaults to the beginning of the first statement in the declaration body.\n  static PathDiagnosticLocation createDeclBegin(const LocationContext *LC,\n                                                const SourceManager &SM);\n\n  /// Constructs a location for the end of the enclosing declaration body.\n  /// Defaults to the end of brace.\n  static PathDiagnosticLocation createDeclEnd(const LocationContext *LC,\n                                                   const SourceManager &SM);\n\n  /// Create a location corresponding to the given valid ProgramPoint.\n  static PathDiagnosticLocation create(const ProgramPoint &P,\n                                       const SourceManager &SMng);\n\n  /// Convert the given location into a single kind location.\n  static PathDiagnosticLocation createSingleLocation(\n                                             const PathDiagnosticLocation &PDL);\n\n  /// Construct a source location that corresponds to either the beginning\n  /// or the end of the given statement, or a nearby valid source location\n  /// if the statement does not have a valid source location of its own.\n  static SourceLocation\n  getValidSourceLocation(const Stmt *S, LocationOrAnalysisDeclContext LAC,\n                         bool UseEndOfStatement = false);\n\n  bool operator==(const PathDiagnosticLocation &X) const {\n    return K == X.K && Loc == X.Loc && Range == X.Range;\n  }\n\n  bool operator!=(const PathDiagnosticLocation &X) const {\n    return !(*this == X);\n  }\n\n  bool isValid() const {\n    return SM != nullptr;\n  }\n\n  FullSourceLoc asLocation() const {\n    return Loc;\n  }\n\n  PathDiagnosticRange asRange() const {\n    return Range;\n  }\n\n  const Stmt *asStmt() const { assert(isValid()); return S; }\n  const Stmt *getStmtOrNull() const {\n    if (!isValid())\n      return nullptr;\n    return asStmt();\n  }\n\n  const Decl *asDecl() const { assert(isValid()); return D; }\n\n  bool hasRange() const { return K == StmtK || K == RangeK || K == DeclK; }\n\n  bool hasValidLocation() const { return asLocation().isValid(); }\n\n  void invalidate() {\n    *this = PathDiagnosticLocation();\n  }\n\n  void flatten();\n\n  const SourceManager& getManager() const { assert(isValid()); return *SM; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void dump() const;\n};\n\nclass PathDiagnosticLocationPair {\nprivate:\n  PathDiagnosticLocation Start, End;\n\npublic:\n  PathDiagnosticLocationPair(const PathDiagnosticLocation &start,\n                             const PathDiagnosticLocation &end)\n      : Start(start), End(end) {}\n\n  const PathDiagnosticLocation &getStart() const { return Start; }\n  const PathDiagnosticLocation &getEnd() const { return End; }\n\n  void setStart(const PathDiagnosticLocation &L) { Start = L; }\n  void setEnd(const PathDiagnosticLocation &L) { End = L; }\n\n  void flatten() {\n    Start.flatten();\n    End.flatten();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Start.Profile(ID);\n    End.Profile(ID);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Path \"pieces\" for path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticPiece: public llvm::FoldingSetNode {\npublic:\n  enum Kind { ControlFlow, Event, Macro, Call, Note, PopUp };\n  enum DisplayHint { Above, Below };\n\nprivate:\n  const std::string str;\n  const Kind kind;\n  const DisplayHint Hint;\n\n  /// In the containing bug report, this piece is the last piece from\n  /// the main source file.\n  bool LastInMainSourceFile = false;\n\n  /// A constant string that can be used to tag the PathDiagnosticPiece,\n  /// typically with the identification of the creator.  The actual pointer\n  /// value is meant to be an identifier; the string itself is useful for\n  /// debugging.\n  StringRef Tag;\n\n  std::vector<SourceRange> ranges;\n  std::vector<FixItHint> fixits;\n\nprotected:\n  PathDiagnosticPiece(StringRef s, Kind k, DisplayHint hint = Below);\n  PathDiagnosticPiece(Kind k, DisplayHint hint = Below);\n\npublic:\n  PathDiagnosticPiece() = delete;\n  PathDiagnosticPiece(const PathDiagnosticPiece &) = delete;\n  PathDiagnosticPiece &operator=(const PathDiagnosticPiece &) = delete;\n  virtual ~PathDiagnosticPiece();\n\n  StringRef getString() const { return str; }\n\n  /// Tag this PathDiagnosticPiece with the given C-string.\n  void setTag(const char *tag) { Tag = tag; }\n\n  /// Return the opaque tag (if any) on the PathDiagnosticPiece.\n  const void *getTag() const { return Tag.data(); }\n\n  /// Return the string representation of the tag.  This is useful\n  /// for debugging.\n  StringRef getTagStr() const { return Tag; }\n\n  /// getDisplayHint - Return a hint indicating where the diagnostic should\n  ///  be displayed by the PathDiagnosticConsumer.\n  DisplayHint getDisplayHint() const { return Hint; }\n\n  virtual PathDiagnosticLocation getLocation() const = 0;\n  virtual void flattenLocations() = 0;\n\n  Kind getKind() const { return kind; }\n\n  void addRange(SourceRange R) {\n    if (!R.isValid())\n      return;\n    ranges.push_back(R);\n  }\n\n  void addRange(SourceLocation B, SourceLocation E) {\n    if (!B.isValid() || !E.isValid())\n      return;\n    ranges.push_back(SourceRange(B,E));\n  }\n\n  void addFixit(FixItHint F) {\n    fixits.push_back(F);\n  }\n\n  /// Return the SourceRanges associated with this PathDiagnosticPiece.\n  ArrayRef<SourceRange> getRanges() const { return ranges; }\n\n  /// Return the fix-it hints associated with this PathDiagnosticPiece.\n  ArrayRef<FixItHint> getFixits() const { return fixits; }\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void setAsLastInMainSourceFile() {\n    LastInMainSourceFile = true;\n  }\n\n  bool isLastInMainSourceFile() const {\n    return LastInMainSourceFile;\n  }\n\n  virtual void dump() const = 0;\n};\n\nusing PathDiagnosticPieceRef = std::shared_ptr<PathDiagnosticPiece>;\n\nclass PathPieces : public std::list<PathDiagnosticPieceRef> {\n  void flattenTo(PathPieces &Primary, PathPieces &Current,\n                 bool ShouldFlattenMacros) const;\n\npublic:\n  PathPieces flatten(bool ShouldFlattenMacros) const {\n    PathPieces Result;\n    flattenTo(Result, Result, ShouldFlattenMacros);\n    return Result;\n  }\n\n  void dump() const;\n};\n\nclass PathDiagnosticSpotPiece : public PathDiagnosticPiece {\nprivate:\n  PathDiagnosticLocation Pos;\n\npublic:\n  PathDiagnosticSpotPiece(const PathDiagnosticLocation &pos,\n                          StringRef s,\n                          PathDiagnosticPiece::Kind k,\n                          bool addPosRange = true)\n      : PathDiagnosticPiece(s, k), Pos(pos) {\n    assert(Pos.isValid() && Pos.hasValidLocation() &&\n           \"PathDiagnosticSpotPiece's must have a valid location.\");\n    if (addPosRange && Pos.hasRange()) addRange(Pos.asRange());\n  }\n\n  PathDiagnosticLocation getLocation() const override { return Pos; }\n  void flattenLocations() override { Pos.flatten(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event || P->getKind() == Macro ||\n           P->getKind() == Note || P->getKind() == PopUp;\n  }\n};\n\nclass PathDiagnosticEventPiece : public PathDiagnosticSpotPiece {\n  Optional<bool> IsPrunable;\n\npublic:\n  PathDiagnosticEventPiece(const PathDiagnosticLocation &pos,\n                           StringRef s, bool addPosRange = true)\n      : PathDiagnosticSpotPiece(pos, s, Event, addPosRange) {}\n  ~PathDiagnosticEventPiece() override;\n\n  /// Mark the diagnostic piece as being potentially prunable.  This\n  /// flag may have been previously set, at which point it will not\n  /// be reset unless one specifies to do so.\n  void setPrunable(bool isPrunable, bool override = false) {\n    if (IsPrunable.hasValue() && !override)\n     return;\n    IsPrunable = isPrunable;\n  }\n\n  /// Return true if the diagnostic piece is prunable.\n  bool isPrunable() const {\n    return IsPrunable.hasValue() ? IsPrunable.getValue() : false;\n  }\n\n  void dump() const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event;\n  }\n};\n\nclass PathDiagnosticCallPiece : public PathDiagnosticPiece {\n  const Decl *Caller;\n  const Decl *Callee = nullptr;\n\n  // Flag signifying that this diagnostic has only call enter and no matching\n  // call exit.\n  bool NoExit;\n\n  // Flag signifying that the callee function is an Objective-C autosynthesized\n  // property getter or setter.\n  bool IsCalleeAnAutosynthesizedPropertyAccessor = false;\n\n  // The custom string, which should appear after the call Return Diagnostic.\n  // TODO: Should we allow multiple diagnostics?\n  std::string CallStackMessage;\n\n  PathDiagnosticCallPiece(const Decl *callerD,\n                          const PathDiagnosticLocation &callReturnPos)\n      : PathDiagnosticPiece(Call), Caller(callerD), NoExit(false),\n        callReturn(callReturnPos) {}\n  PathDiagnosticCallPiece(PathPieces &oldPath, const Decl *caller)\n      : PathDiagnosticPiece(Call), Caller(caller), NoExit(true),\n        path(oldPath) {}\n\npublic:\n  PathDiagnosticLocation callEnter;\n  PathDiagnosticLocation callEnterWithin;\n  PathDiagnosticLocation callReturn;\n  PathPieces path;\n\n  ~PathDiagnosticCallPiece() override;\n\n  const Decl *getCaller() const { return Caller; }\n\n  const Decl *getCallee() const { return Callee; }\n  void setCallee(const CallEnter &CE, const SourceManager &SM);\n\n  bool hasCallStackMessage() { return !CallStackMessage.empty(); }\n  void setCallStackMessage(StringRef st) { CallStackMessage = std::string(st); }\n\n  PathDiagnosticLocation getLocation() const override { return callEnter; }\n\n  std::shared_ptr<PathDiagnosticEventPiece> getCallEnterEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece>\n  getCallEnterWithinCallerEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece> getCallExitEvent() const;\n\n  void flattenLocations() override {\n    callEnter.flatten();\n    callReturn.flatten();\n    for (const auto &I : path)\n      I->flattenLocations();\n  }\n\n  static std::shared_ptr<PathDiagnosticCallPiece>\n  construct(const CallExitEnd &CE,\n            const SourceManager &SM);\n\n  static PathDiagnosticCallPiece *construct(PathPieces &pieces,\n                                            const Decl *caller);\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Call;\n  }\n};\n\nclass PathDiagnosticControlFlowPiece : public PathDiagnosticPiece {\n  std::vector<PathDiagnosticLocationPair> LPairs;\n\npublic:\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos,\n                                 StringRef s)\n      : PathDiagnosticPiece(s, ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos)\n      : PathDiagnosticPiece(ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  ~PathDiagnosticControlFlowPiece() override;\n\n  PathDiagnosticLocation getStartLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getStart();\n  }\n\n  PathDiagnosticLocation getEndLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getEnd();\n  }\n\n  void setStartLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setStart(L);\n  }\n\n  void setEndLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setEnd(L);\n  }\n\n  void push_back(const PathDiagnosticLocationPair &X) { LPairs.push_back(X); }\n\n  PathDiagnosticLocation getLocation() const override {\n    return getStartLocation();\n  }\n\n  using iterator = std::vector<PathDiagnosticLocationPair>::iterator;\n\n  iterator begin() { return LPairs.begin(); }\n  iterator end() { return LPairs.end(); }\n\n  void flattenLocations() override {\n    for (auto &I : *this)\n      I.flatten();\n  }\n\n  using const_iterator =\n      std::vector<PathDiagnosticLocationPair>::const_iterator;\n\n  const_iterator begin() const { return LPairs.begin(); }\n  const_iterator end() const { return LPairs.end(); }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == ControlFlow;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticMacroPiece : public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticMacroPiece(const PathDiagnosticLocation &pos)\n      : PathDiagnosticSpotPiece(pos, \"\", Macro) {}\n  ~PathDiagnosticMacroPiece() override;\n\n  PathPieces subPieces;\n\n  void flattenLocations() override {\n    PathDiagnosticSpotPiece::flattenLocations();\n    for (const auto &I : subPieces)\n      I->flattenLocations();\n  }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Macro;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticNotePiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticNotePiece(const PathDiagnosticLocation &Pos, StringRef S,\n                          bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, Note, AddPosRange) {}\n  ~PathDiagnosticNotePiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Note;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticPopUpPiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticPopUpPiece(const PathDiagnosticLocation &Pos, StringRef S,\n                           bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, PopUp, AddPosRange) {}\n  ~PathDiagnosticPopUpPiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == PopUp;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\n/// File IDs mapped to sets of line numbers.\nusing FilesToLineNumsMap = std::map<FileID, std::set<unsigned>>;\n\n/// PathDiagnostic - PathDiagnostic objects represent a single path-sensitive\n///  diagnostic.  It represents an ordered-collection of PathDiagnosticPieces,\n///  each which represent the pieces of the path.\nclass PathDiagnostic : public llvm::FoldingSetNode {\n  std::string CheckerName;\n  const Decl *DeclWithIssue;\n  std::string BugType;\n  std::string VerboseDesc;\n  std::string ShortDesc;\n  std::string Category;\n  std::deque<std::string> OtherDesc;\n\n  /// Loc The location of the path diagnostic report.\n  PathDiagnosticLocation Loc;\n\n  PathPieces pathImpl;\n  SmallVector<PathPieces *, 3> pathStack;\n\n  /// Important bug uniqueing location.\n  /// The location info is useful to differentiate between bugs.\n  PathDiagnosticLocation UniqueingLoc;\n  const Decl *UniqueingDecl;\n\n  /// Lines executed in the path.\n  std::unique_ptr<FilesToLineNumsMap> ExecutedLines;\n\npublic:\n  PathDiagnostic() = delete;\n  PathDiagnostic(StringRef CheckerName, const Decl *DeclWithIssue,\n                 StringRef bugtype, StringRef verboseDesc, StringRef shortDesc,\n                 StringRef category, PathDiagnosticLocation LocationToUnique,\n                 const Decl *DeclToUnique,\n                 std::unique_ptr<FilesToLineNumsMap> ExecutedLines);\n  ~PathDiagnostic();\n\n  const PathPieces &path;\n\n  /// Return the path currently used by builders for constructing the\n  /// PathDiagnostic.\n  PathPieces &getActivePath() {\n    if (pathStack.empty())\n      return pathImpl;\n    return *pathStack.back();\n  }\n\n  /// Return a mutable version of 'path'.\n  PathPieces &getMutablePieces() {\n    return pathImpl;\n  }\n\n  /// Return the unrolled size of the path.\n  unsigned full_size();\n\n  void pushActivePath(PathPieces *p) { pathStack.push_back(p); }\n  void popActivePath() { if (!pathStack.empty()) pathStack.pop_back(); }\n\n  bool isWithinCall() const { return !pathStack.empty(); }\n\n  void setEndOfPath(PathDiagnosticPieceRef EndPiece) {\n    assert(!Loc.isValid() && \"End location already set!\");\n    Loc = EndPiece->getLocation();\n    assert(Loc.isValid() && \"Invalid location for end-of-path piece\");\n    getActivePath().push_back(std::move(EndPiece));\n  }\n\n  void appendToDesc(StringRef S) {\n    if (!ShortDesc.empty())\n      ShortDesc += S;\n    VerboseDesc += S;\n  }\n\n  StringRef getVerboseDescription() const { return VerboseDesc; }\n\n  StringRef getShortDescription() const {\n    return ShortDesc.empty() ? VerboseDesc : ShortDesc;\n  }\n\n  StringRef getCheckerName() const { return CheckerName; }\n  StringRef getBugType() const { return BugType; }\n  StringRef getCategory() const { return Category; }\n\n  using meta_iterator = std::deque<std::string>::const_iterator;\n\n  meta_iterator meta_begin() const { return OtherDesc.begin(); }\n  meta_iterator meta_end() const { return OtherDesc.end(); }\n  void addMeta(StringRef s) { OtherDesc.push_back(std::string(s)); }\n\n  const FilesToLineNumsMap &getExecutedLines() const {\n    return *ExecutedLines;\n  }\n\n  FilesToLineNumsMap &getExecutedLines() {\n    return *ExecutedLines;\n  }\n\n  /// Return the semantic context where an issue occurred.  If the\n  /// issue occurs along a path, this represents the \"central\" area\n  /// where the bug manifests.\n  const Decl *getDeclWithIssue() const { return DeclWithIssue; }\n\n  void setDeclWithIssue(const Decl *D) {\n    DeclWithIssue = D;\n  }\n\n  PathDiagnosticLocation getLocation() const {\n    return Loc;\n  }\n\n  void setLocation(PathDiagnosticLocation NewLoc) {\n    Loc = NewLoc;\n  }\n\n  /// Get the location on which the report should be uniqued.\n  PathDiagnosticLocation getUniqueingLoc() const {\n    return UniqueingLoc;\n  }\n\n  /// Get the declaration containing the uniqueing location.\n  const Decl *getUniqueingDecl() const {\n    return UniqueingDecl;\n  }\n\n  void flattenLocations() {\n    Loc.flatten();\n    for (const auto &I : pathImpl)\n      I->flattenLocations();\n  }\n\n  /// Profiles the diagnostic, independent of the path it references.\n  ///\n  /// This can be used to merge diagnostics that refer to the same issue\n  /// along different paths.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  /// Profiles the diagnostic, including its path.\n  ///\n  /// Two diagnostics with the same issue along different paths will generate\n  /// different profiles.\n  void FullProfile(llvm::FoldingSetNodeID &ID) const;\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PCHContainerOperations.h", "content": "//===--- Frontend/PCHContainerOperations.h - PCH Containers -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_PCH_CONTAINER_OPERATIONS_H\n#define LLVM_CLANG_PCH_CONTAINER_OPERATIONS_H\n\n#include \"clang/Serialization/PCHContainerOperations.h\"\n\n#endif\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "content": "//===--- PrecompiledPreamble.h - Build precompiled preambles ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Helper class to build precompiled preamble.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n#define LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cstddef>\n#include <memory>\n#include <system_error>\n#include <type_traits>\n\nnamespace llvm {\nclass MemoryBuffer;\nclass MemoryBufferRef;\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\nclass CompilerInstance;\nclass CompilerInvocation;\nclass Decl;\nclass DeclGroupRef;\nclass PCHContainerOperations;\n\n/// Runs lexer to compute suggested preamble bounds.\nPreambleBounds ComputePreambleBounds(const LangOptions &LangOpts,\n                                     const llvm::MemoryBufferRef &Buffer,\n                                     unsigned MaxLines);\n\nclass PreambleCallbacks;\n\n/// A class holding a PCH and all information to check whether it is valid to\n/// reuse the PCH for the subsequent runs. Use BuildPreamble to create PCH and\n/// CanReusePreamble + AddImplicitPreamble to make use of it.\nclass PrecompiledPreamble {\n  class PCHStorage;\n  struct PreambleFileHash;\n\npublic:\n  /// Try to build PrecompiledPreamble for \\p Invocation. See\n  /// BuildPreambleError for possible error codes.\n  ///\n  /// \\param Invocation Original CompilerInvocation with options to compile the\n  /// file.\n  ///\n  /// \\param MainFileBuffer Buffer with the contents of the main file.\n  ///\n  /// \\param Bounds Bounds of the preamble, result of calling\n  /// ComputePreambleBounds.\n  ///\n  /// \\param Diagnostics Diagnostics engine to be used while building the\n  /// preamble.\n  ///\n  /// \\param VFS An instance of vfs::FileSystem to be used for file\n  /// accesses.\n  ///\n  /// \\param PCHContainerOps An instance of PCHContainerOperations.\n  ///\n  /// \\param StoreInMemory Store PCH in memory. If false, PCH will be stored in\n  /// a temporary file.\n  ///\n  /// \\param Callbacks A set of callbacks to be executed when building\n  /// the preamble.\n  static llvm::ErrorOr<PrecompiledPreamble>\n  Build(const CompilerInvocation &Invocation,\n        const llvm::MemoryBuffer *MainFileBuffer, PreambleBounds Bounds,\n        DiagnosticsEngine &Diagnostics,\n        IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS,\n        std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n        bool StoreInMemory, PreambleCallbacks &Callbacks);\n\n  PrecompiledPreamble(PrecompiledPreamble &&) = default;\n  PrecompiledPreamble &operator=(PrecompiledPreamble &&) = default;\n\n  /// PreambleBounds used to build the preamble.\n  PreambleBounds getBounds() const;\n\n  /// Returns the size, in bytes, that preamble takes on disk or in memory.\n  /// For on-disk preambles returns 0 if filesystem operations fail. Intended to\n  /// be used for logging and debugging purposes only.\n  std::size_t getSize() const;\n\n  /// Returned string is not null-terminated.\n  llvm::StringRef getContents() const {\n    return {PreambleBytes.data(), PreambleBytes.size()};\n  }\n\n  /// Check whether PrecompiledPreamble can be reused for the new contents(\\p\n  /// MainFileBuffer) of the main file.\n  bool CanReuse(const CompilerInvocation &Invocation,\n                const llvm::MemoryBufferRef &MainFileBuffer,\n                PreambleBounds Bounds, llvm::vfs::FileSystem &VFS) const;\n\n  /// Changes options inside \\p CI to use PCH from this preamble. Also remaps\n  /// main file to \\p MainFileBuffer and updates \\p VFS to ensure the preamble\n  /// is accessible.\n  /// Requires that CanReuse() is true.\n  /// For in-memory preambles, PrecompiledPreamble instance continues to own the\n  /// MemoryBuffer with the Preamble after this method returns. The caller is\n  /// responsible for making sure the PrecompiledPreamble instance outlives the\n  /// compiler run and the AST that will be using the PCH.\n  void AddImplicitPreamble(CompilerInvocation &CI,\n                           IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                           llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Configure \\p CI to use this preamble.\n  /// Like AddImplicitPreamble, but doesn't assume CanReuse() is true.\n  /// If this preamble does not match the file, it may parse differently.\n  void OverridePreamble(CompilerInvocation &CI,\n                        IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                        llvm::MemoryBuffer *MainFileBuffer) const;\n\nprivate:\n  PrecompiledPreamble(PCHStorage Storage, std::vector<char> PreambleBytes,\n                      bool PreambleEndsAtStartOfLine,\n                      llvm::StringMap<PreambleFileHash> FilesInPreamble,\n                      llvm::StringSet<> MissingFiles);\n\n  /// A temp file that would be deleted on destructor call. If destructor is not\n  /// called for any reason, the file will be deleted at static objects'\n  /// destruction.\n  /// An assertion will fire if two TempPCHFiles are created with the same name,\n  /// so it's not intended to be used outside preamble-handling.\n  class TempPCHFile {\n  public:\n    // A main method used to construct TempPCHFile.\n    static llvm::ErrorOr<TempPCHFile> CreateNewPreamblePCHFile();\n\n  private:\n    TempPCHFile(std::string FilePath);\n\n  public:\n    TempPCHFile(TempPCHFile &&Other);\n    TempPCHFile &operator=(TempPCHFile &&Other);\n\n    TempPCHFile(const TempPCHFile &) = delete;\n    ~TempPCHFile();\n\n    /// A path where temporary file is stored.\n    llvm::StringRef getFilePath() const;\n\n  private:\n    void RemoveFileIfPresent();\n\n  private:\n    llvm::Optional<std::string> FilePath;\n  };\n\n  class InMemoryPreamble {\n  public:\n    std::string Data;\n  };\n\n  class PCHStorage {\n  public:\n    enum class Kind { Empty, InMemory, TempFile };\n\n    PCHStorage() = default;\n    PCHStorage(TempPCHFile File);\n    PCHStorage(InMemoryPreamble Memory);\n\n    PCHStorage(const PCHStorage &) = delete;\n    PCHStorage &operator=(const PCHStorage &) = delete;\n\n    PCHStorage(PCHStorage &&Other);\n    PCHStorage &operator=(PCHStorage &&Other);\n\n    ~PCHStorage();\n\n    Kind getKind() const;\n\n    TempPCHFile &asFile();\n    const TempPCHFile &asFile() const;\n\n    InMemoryPreamble &asMemory();\n    const InMemoryPreamble &asMemory() const;\n\n  private:\n    void destroy();\n    void setEmpty();\n\n  private:\n    Kind StorageKind = Kind::Empty;\n    llvm::AlignedCharArrayUnion<TempPCHFile, InMemoryPreamble> Storage = {};\n  };\n\n  /// Data used to determine if a file used in the preamble has been changed.\n  struct PreambleFileHash {\n    /// All files have size set.\n    off_t Size = 0;\n\n    /// Modification time is set for files that are on disk.  For memory\n    /// buffers it is zero.\n    time_t ModTime = 0;\n\n    /// Memory buffers have MD5 instead of modification time.  We don't\n    /// compute MD5 for on-disk files because we hope that modification time is\n    /// enough to tell if the file was changed.\n    llvm::MD5::MD5Result MD5 = {};\n\n    static PreambleFileHash createForFile(off_t Size, time_t ModTime);\n    static PreambleFileHash\n    createForMemoryBuffer(const llvm::MemoryBufferRef &Buffer);\n\n    friend bool operator==(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return LHS.Size == RHS.Size && LHS.ModTime == RHS.ModTime &&\n             LHS.MD5 == RHS.MD5;\n    }\n    friend bool operator!=(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return !(LHS == RHS);\n    }\n  };\n\n  /// Helper function to set up PCH for the preamble into \\p CI and \\p VFS to\n  /// with the specified \\p Bounds.\n  void configurePreamble(PreambleBounds Bounds, CompilerInvocation &CI,\n                         IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                         llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Sets up the PreprocessorOptions and changes VFS, so that PCH stored in \\p\n  /// Storage is accessible to clang. This method is an implementation detail of\n  /// AddImplicitPreamble.\n  static void\n  setupPreambleStorage(const PCHStorage &Storage,\n                       PreprocessorOptions &PreprocessorOpts,\n                       IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS);\n\n  /// Manages the memory buffer or temporary file that stores the PCH.\n  PCHStorage Storage;\n  /// Keeps track of the files that were used when computing the\n  /// preamble, with both their buffer size and their modification time.\n  ///\n  /// If any of the files have changed from one compile to the next,\n  /// the preamble must be thrown away.\n  llvm::StringMap<PreambleFileHash> FilesInPreamble;\n  /// Files that were not found during preamble building. If any of these now\n  /// exist then the preamble should not be reused.\n  ///\n  /// Storing *all* the missing files that could invalidate the preamble would\n  /// make it too expensive to revalidate (when the include path has many\n  /// entries, each #include will miss half of them on average).\n  /// Instead, we track only files that could have satisfied an #include that\n  /// was ultimately not found.\n  llvm::StringSet<> MissingFiles;\n  /// The contents of the file that was used to precompile the preamble. Only\n  /// contains first PreambleBounds::Size bytes. Used to compare if the relevant\n  /// part of the file has not changed, so that preamble can be reused.\n  std::vector<char> PreambleBytes;\n  /// See PreambleBounds::PreambleEndsAtStartOfLine\n  bool PreambleEndsAtStartOfLine;\n};\n\n/// A set of callbacks to gather useful information while building a preamble.\nclass PreambleCallbacks {\npublic:\n  virtual ~PreambleCallbacks() = default;\n\n  /// Called before FrontendAction::BeginSourceFile.\n  /// Can be used to store references to various CompilerInstance fields\n  /// (e.g. SourceManager) that may be interesting to the consumers of other\n  /// callbacks.\n  virtual void BeforeExecute(CompilerInstance &CI);\n  /// Called after FrontendAction::Execute(), but before\n  /// FrontendAction::EndSourceFile(). Can be used to transfer ownership of\n  /// various CompilerInstance fields before they are destroyed.\n  virtual void AfterExecute(CompilerInstance &CI);\n  /// Called after PCH has been emitted. \\p Writer may be used to retrieve\n  /// information about AST, serialized in PCH.\n  virtual void AfterPCHEmitted(ASTWriter &Writer);\n  /// Called for each TopLevelDecl.\n  /// NOTE: To allow more flexibility a custom ASTConsumer could probably be\n  /// used instead, but having only this method allows a simpler API.\n  virtual void HandleTopLevelDecl(DeclGroupRef DG);\n  /// Creates wrapper class for PPCallbacks so we can also process information\n  /// about includes that are inside of a preamble\n  virtual std::unique_ptr<PPCallbacks> createPPCallbacks();\n  /// The returned CommentHandler will be added to the preprocessor if not null.\n  virtual CommentHandler *getCommentHandler();\n  /// Determines which function bodies are parsed, by default skips everything.\n  /// Only used if FrontendOpts::SkipFunctionBodies is true.\n  /// See ASTConsumer::shouldSkipFunctionBody.\n  virtual bool shouldSkipFunctionBody(Decl *D) { return true; }\n};\n\nenum class BuildPreambleError {\n  CouldntCreateTempFile = 1,\n  CouldntCreateTargetInfo,\n  BeginSourceFileFailed,\n  CouldntEmitPCH,\n  BadInputs\n};\n\nclass BuildPreambleErrorCategory final : public std::error_category {\npublic:\n  const char *name() const noexcept override;\n  std::string message(int condition) const override;\n};\n\nstd::error_code make_error_code(BuildPreambleError Error);\n} // namespace clang\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<clang::BuildPreambleError> : std::true_type {};\n} // namespace std\n\n#endif\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h", "content": "//===-- ModuleFileExtension.h - Module File Extensions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_MODULEFILEEXTENSION_H\n#define LLVM_CLANG_SERIALIZATION_MODULEFILEEXTENSION_H\n\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/Support/ExtensibleRTTI.h\"\n#include <memory>\n#include <string>\n\nnamespace llvm {\nclass BitstreamCursor;\nclass BitstreamWriter;\nclass hash_code;\nclass raw_ostream;\n}\n\nnamespace clang {\n\nclass ASTReader;\nclass ASTWriter;\nclass Sema;\n\nnamespace serialization {\n  class ModuleFile;\n} // end namespace serialization\n\n/// Metadata for a module file extension.\nstruct ModuleFileExtensionMetadata {\n  /// The name used to identify this particular extension block within\n  /// the resulting module file. It should be unique to the particular\n  /// extension, because this name will be used to match the name of\n  /// an extension block to the appropriate reader.\n  std::string BlockName;\n\n  /// The major version of the extension data.\n  unsigned MajorVersion;\n\n  /// The minor version of the extension data.\n  unsigned MinorVersion;\n\n  /// A string containing additional user information that will be\n  /// stored with the metadata.\n  std::string UserInfo;\n};\n\nclass ModuleFileExtensionReader;\nclass ModuleFileExtensionWriter;\n\n/// An abstract superclass that describes a custom extension to the\n/// module/precompiled header file format.\n///\n/// A module file extension can introduce additional information into\n/// compiled module files (.pcm) and precompiled headers (.pch) via a\n/// custom writer that can then be accessed via a custom reader when\n/// the module file or precompiled header is loaded.\n///\n/// Subclasses must use LLVM RTTI for open class hierarchies.\nclass ModuleFileExtension\n    : public llvm::RTTIExtends<ModuleFileExtension, llvm::RTTIRoot> {\npublic:\n  /// Discriminator for LLVM RTTI.\n  static char ID;\n\n  virtual ~ModuleFileExtension();\n\n  /// Retrieves the metadata for this module file extension.\n  virtual ModuleFileExtensionMetadata getExtensionMetadata() const = 0;\n\n  /// Hash information about the presence of this extension into the\n  /// module hash code.\n  ///\n  /// The module hash code is used to distinguish different variants\n  /// of a module that are incompatible. If the presence, absence, or\n  /// version of the module file extension should force the creation\n  /// of a separate set of module files, override this method to\n  /// combine that distinguishing information into the module hash\n  /// code.\n  ///\n  /// The default implementation of this function simply returns the\n  /// hash code as given, so the presence/absence of this extension\n  /// does not distinguish module files.\n  virtual llvm::hash_code hashExtension(llvm::hash_code c) const;\n\n  /// Create a new module file extension writer, which will be\n  /// responsible for writing the extension contents into a particular\n  /// module file.\n  virtual std::unique_ptr<ModuleFileExtensionWriter>\n  createExtensionWriter(ASTWriter &Writer) = 0;\n\n  /// Create a new module file extension reader, given the\n  /// metadata read from the block and the cursor into the extension\n  /// block.\n  ///\n  /// May return null to indicate that an extension block with the\n  /// given metadata cannot be read.\n  virtual std::unique_ptr<ModuleFileExtensionReader>\n  createExtensionReader(const ModuleFileExtensionMetadata &Metadata,\n                        ASTReader &Reader, serialization::ModuleFile &Mod,\n                        const llvm::BitstreamCursor &Stream) = 0;\n};\n\n/// Abstract base class that writes a module file extension block into\n/// a module file.\nclass ModuleFileExtensionWriter {\n  ModuleFileExtension *Extension;\n\nprotected:\n  ModuleFileExtensionWriter(ModuleFileExtension *Extension)\n    : Extension(Extension) { }\n\npublic:\n  virtual ~ModuleFileExtensionWriter();\n\n  /// Retrieve the module file extension with which this writer is\n  /// associated.\n  ModuleFileExtension *getExtension() const { return Extension; }\n\n  /// Write the contents of the extension block into the given bitstream.\n  ///\n  /// Responsible for writing the contents of the extension into the\n  /// given stream. All of the contents should be written into custom\n  /// records with IDs >= FIRST_EXTENSION_RECORD_ID.\n  virtual void writeExtensionContents(Sema &SemaRef,\n                                      llvm::BitstreamWriter &Stream) = 0;\n};\n\n/// Abstract base class that reads a module file extension block from\n/// a module file.\n///\n/// Subclasses\nclass ModuleFileExtensionReader {\n  ModuleFileExtension *Extension;\n\nprotected:\n  ModuleFileExtensionReader(ModuleFileExtension *Extension)\n    : Extension(Extension) { }\n\npublic:\n  /// Retrieve the module file extension with which this reader is\n  /// associated.\n  ModuleFileExtension *getExtension() const { return Extension; }\n\n  virtual ~ModuleFileExtensionReader();\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_MODULEFILEEXTENSION_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-death-test.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for death tests.  It is\n// #included by gtest.h so a user doesn't need to include this\n// directly.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n\n#include \"gtest/internal/gtest-death-test-internal.h\"\n\nnamespace testing {\n\n// This flag controls the style of death tests.  Valid values are \"threadsafe\",\n// meaning that the death test child process will re-execute the test binary\n// from the start, running only a single death test, or \"fast\",\n// meaning that the child process will execute the test logic immediately\n// after forking.\nGTEST_DECLARE_string_(death_test_style);\n\n#if GTEST_HAS_DEATH_TEST\n\nnamespace internal {\n\n// Returns a Boolean value indicating whether the caller is currently\n// executing in the context of the death test child process.  Tools such as\n// Valgrind heap checkers may need this to modify their behavior in death\n// tests.  IMPORTANT: This is an internal utility.  Using it may break the\n// implementation of death tests.  User code MUST NOT use it.\nGTEST_API_ bool InDeathTestChild();\n\n}  // namespace internal\n\n// The following macros are useful for writing death tests.\n\n// Here's what happens when an ASSERT_DEATH* or EXPECT_DEATH* is\n// executed:\n//\n//   1. It generates a warning if there is more than one active\n//   thread.  This is because it's safe to fork() or clone() only\n//   when there is a single thread.\n//\n//   2. The parent process clone()s a sub-process and runs the death\n//   test in it; the sub-process exits with code 0 at the end of the\n//   death test, if it hasn't exited already.\n//\n//   3. The parent process waits for the sub-process to terminate.\n//\n//   4. The parent process checks the exit code and error message of\n//   the sub-process.\n//\n// Examples:\n//\n//   ASSERT_DEATH(server.SendMessage(56, \"Hello\"), \"Invalid port number\");\n//   for (int i = 0; i < 5; i++) {\n//     EXPECT_DEATH(server.ProcessRequest(i),\n//                  \"Invalid request .* in ProcessRequest()\")\n//                  << \"Failed to die on request \" << i;\n//   }\n//\n//   ASSERT_EXIT(server.ExitNow(), ::testing::ExitedWithCode(0), \"Exiting\");\n//\n//   bool KilledBySIGHUP(int exit_code) {\n//     return WIFSIGNALED(exit_code) && WTERMSIG(exit_code) == SIGHUP;\n//   }\n//\n//   ASSERT_EXIT(client.HangUpServer(), KilledBySIGHUP, \"Hanging up!\");\n//\n// On the regular expressions used in death tests:\n//\n//   On POSIX-compliant systems (*nix), we use the <regex.h> library,\n//   which uses the POSIX extended regex syntax.\n//\n//   On other platforms (e.g. Windows), we only support a simple regex\n//   syntax implemented as part of Google Test.  This limited\n//   implementation should be enough most of the time when writing\n//   death tests; though it lacks many features you can find in PCRE\n//   or POSIX extended regex syntax.  For example, we don't support\n//   union (\"x|y\"), grouping (\"(xy)\"), brackets (\"[xy]\"), and\n//   repetition count (\"x{5,7}\"), among others.\n//\n//   Below is the syntax that we do support.  We chose it to be a\n//   subset of both PCRE and POSIX extended regex, so it's easy to\n//   learn wherever you come from.  In the following: 'A' denotes a\n//   literal character, period (.), or a single \\\\ escape sequence;\n//   'x' and 'y' denote regular expressions; 'm' and 'n' are for\n//   natural numbers.\n//\n//     c     matches any literal character c\n//     \\\\d   matches any decimal digit\n//     \\\\D   matches any character that's not a decimal digit\n//     \\\\f   matches \\f\n//     \\\\n   matches \\n\n//     \\\\r   matches \\r\n//     \\\\s   matches any ASCII whitespace, including \\n\n//     \\\\S   matches any character that's not a whitespace\n//     \\\\t   matches \\t\n//     \\\\v   matches \\v\n//     \\\\w   matches any letter, _, or decimal digit\n//     \\\\W   matches any character that \\\\w doesn't match\n//     \\\\c   matches any literal character c, which must be a punctuation\n//     .     matches any single character except \\n\n//     A?    matches 0 or 1 occurrences of A\n//     A*    matches 0 or many occurrences of A\n//     A+    matches 1 or many occurrences of A\n//     ^     matches the beginning of a string (not that of each line)\n//     $     matches the end of a string (not that of each line)\n//     xy    matches x followed by y\n//\n//   If you accidentally use PCRE or POSIX extended regex features\n//   not implemented by us, you will get a run-time failure.  In that\n//   case, please try to rewrite your regular expression within the\n//   above syntax.\n//\n//   This implementation is *not* meant to be as highly tuned or robust\n//   as a compiled regex library, but should perform well enough for a\n//   death test, which already incurs significant overhead by launching\n//   a child process.\n//\n// Known caveats:\n//\n//   A \"threadsafe\" style death test obtains the path to the test\n//   program from argv[0] and re-executes it in the sub-process.  For\n//   simplicity, the current implementation doesn't search the PATH\n//   when launching the sub-process.  This means that the user must\n//   invoke the test program via a path that contains at least one\n//   path separator (e.g. path/to/foo_test and\n//   /absolute/path/to/bar_test are fine, but foo_test is not).  This\n//   is rarely a problem as people usually don't put the test binary\n//   directory in PATH.\n//\n// TODO(wan@google.com): make thread-safe death tests search the PATH.\n\n// Asserts that a given statement causes the program to exit, with an\n// integer exit status that satisfies predicate, and emitting error output\n// that matches regex.\n# define ASSERT_EXIT(statement, predicate, regex) \\\n    GTEST_DEATH_TEST_(statement, predicate, regex, GTEST_FATAL_FAILURE_)\n\n// Like ASSERT_EXIT, but continues on to successive tests in the\n// test case, if any:\n# define EXPECT_EXIT(statement, predicate, regex) \\\n    GTEST_DEATH_TEST_(statement, predicate, regex, GTEST_NONFATAL_FAILURE_)\n\n// Asserts that a given statement causes the program to exit, either by\n// explicitly exiting with a nonzero exit code or being killed by a\n// signal, and emitting error output that matches regex.\n# define ASSERT_DEATH(statement, regex) \\\n    ASSERT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, regex)\n\n// Like ASSERT_DEATH, but continues on to successive tests in the\n// test case, if any:\n# define EXPECT_DEATH(statement, regex) \\\n    EXPECT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, regex)\n\n// Two predicate classes that can be used in {ASSERT,EXPECT}_EXIT*:\n\n// Tests that an exit code describes a normal exit with a given exit code.\nclass GTEST_API_ ExitedWithCode {\n public:\n  explicit ExitedWithCode(int exit_code);\n  bool operator()(int exit_status) const;\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ExitedWithCode& other);\n\n  const int exit_code_;\n};\n\n# if !GTEST_OS_WINDOWS\n// Tests that an exit code describes an exit due to termination by a\n// given signal.\nclass GTEST_API_ KilledBySignal {\n public:\n  explicit KilledBySignal(int signum);\n  bool operator()(int exit_status) const;\n private:\n  const int signum_;\n};\n# endif  // !GTEST_OS_WINDOWS\n\n// EXPECT_DEBUG_DEATH asserts that the given statements die in debug mode.\n// The death testing framework causes this to have interesting semantics,\n// since the sideeffects of the call are only visible in opt mode, and not\n// in debug mode.\n//\n// In practice, this can be used to test functions that utilize the\n// LOG(DFATAL) macro using the following style:\n//\n// int DieInDebugOr12(int* sideeffect) {\n//   if (sideeffect) {\n//     *sideeffect = 12;\n//   }\n//   LOG(DFATAL) << \"death\";\n//   return 12;\n// }\n//\n// TEST(TestCase, TestDieOr12WorksInDgbAndOpt) {\n//   int sideeffect = 0;\n//   // Only asserts in dbg.\n//   EXPECT_DEBUG_DEATH(DieInDebugOr12(&sideeffect), \"death\");\n//\n// #ifdef NDEBUG\n//   // opt-mode has sideeffect visible.\n//   EXPECT_EQ(12, sideeffect);\n// #else\n//   // dbg-mode no visible sideeffect.\n//   EXPECT_EQ(0, sideeffect);\n// #endif\n// }\n//\n// This will assert that DieInDebugReturn12InOpt() crashes in debug\n// mode, usually due to a DCHECK or LOG(DFATAL), but returns the\n// appropriate fallback value (12 in this case) in opt mode. If you\n// need to test that a function has appropriate side-effects in opt\n// mode, include assertions against the side-effects.  A general\n// pattern for this is:\n//\n// EXPECT_DEBUG_DEATH({\n//   // Side-effects here will have an effect after this statement in\n//   // opt mode, but none in debug mode.\n//   EXPECT_EQ(12, DieInDebugOr12(&sideeffect));\n// }, \"death\");\n//\n# ifdef NDEBUG\n\n#  define EXPECT_DEBUG_DEATH(statement, regex) \\\n  GTEST_EXECUTE_STATEMENT_(statement, regex)\n\n#  define ASSERT_DEBUG_DEATH(statement, regex) \\\n  GTEST_EXECUTE_STATEMENT_(statement, regex)\n\n# else\n\n#  define EXPECT_DEBUG_DEATH(statement, regex) \\\n  EXPECT_DEATH(statement, regex)\n\n#  define ASSERT_DEBUG_DEATH(statement, regex) \\\n  ASSERT_DEATH(statement, regex)\n\n# endif  // NDEBUG for EXPECT_DEBUG_DEATH\n#endif  // GTEST_HAS_DEATH_TEST\n\n// EXPECT_DEATH_IF_SUPPORTED(statement, regex) and\n// ASSERT_DEATH_IF_SUPPORTED(statement, regex) expand to real death tests if\n// death tests are supported; otherwise they just issue a warning.  This is\n// useful when you are combining death test assertions with normal test\n// assertions in one test.\n#if GTEST_HAS_DEATH_TEST\n# define EXPECT_DEATH_IF_SUPPORTED(statement, regex) \\\n    EXPECT_DEATH(statement, regex)\n# define ASSERT_DEATH_IF_SUPPORTED(statement, regex) \\\n    ASSERT_DEATH(statement, regex)\n#else\n# define EXPECT_DEATH_IF_SUPPORTED(statement, regex) \\\n    GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, )\n# define ASSERT_DEATH_IF_SUPPORTED(statement, regex) \\\n    GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, return)\n#endif\n\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-message.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the Message class.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n#define GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n\n#include <limits>\n\n#include \"gtest/internal/gtest-port.h\"\n#include \"gtest/internal/custom/raw-ostream.h\"\n\n// Ensures that there is at least one operator<< in the global namespace.\n// See Message& operator<<(...) below for why.\nvoid operator<<(const testing::internal::Secret&, int);\n\nnamespace testing {\n\n// The Message class works like an ostream repeater.\n//\n// Typical usage:\n//\n//   1. You stream a bunch of values to a Message object.\n//      It will remember the text in a stringstream.\n//   2. Then you stream the Message object to an ostream.\n//      This causes the text in the Message to be streamed\n//      to the ostream.\n//\n// For example;\n//\n//   testing::Message foo;\n//   foo << 1 << \" != \" << 2;\n//   std::cout << foo;\n//\n// will print \"1 != 2\".\n//\n// Message is not intended to be inherited from.  In particular, its\n// destructor is not virtual.\n//\n// Note that stringstream behaves differently in gcc and in MSVC.  You\n// can stream a NULL char pointer to it in the former, but not in the\n// latter (it causes an access violation if you do).  The Message\n// class hides this difference by treating a NULL char pointer as\n// \"(null)\".\nclass GTEST_API_ Message {\n private:\n  // The type of basic IO manipulators (endl, ends, and flush) for\n  // narrow streams.\n  typedef std::ostream& (*BasicNarrowIoManip)(std::ostream&);\n\n public:\n  // Constructs an empty Message.\n  Message();\n\n  // Copy constructor.\n  Message(const Message& msg) : ss_(new ::std::stringstream) {  // NOLINT\n    *ss_ << msg.GetString();\n  }\n\n  // Constructs a Message from a C-string.\n  explicit Message(const char* str) : ss_(new ::std::stringstream) {\n    *ss_ << str;\n  }\n\n#if GTEST_OS_SYMBIAN\n  // Streams a value (either a pointer or not) to this object.\n  template <typename T>\n  inline Message& operator <<(const T& value) {\n    StreamHelper(typename internal::is_pointer<T>::type(), value);\n    return *this;\n  }\n#else\n  // Streams a non-pointer value to this object.\n  template <typename T>\n  inline Message& operator <<(const T& val) {\n    // Some libraries overload << for STL containers.  These\n    // overloads are defined in the global namespace instead of ::std.\n    //\n    // C++'s symbol lookup rule (i.e. Koenig lookup) says that these\n    // overloads are visible in either the std namespace or the global\n    // namespace, but not other namespaces, including the testing\n    // namespace which Google Test's Message class is in.\n    //\n    // To allow STL containers (and other types that has a << operator\n    // defined in the global namespace) to be used in Google Test\n    // assertions, testing::Message must access the custom << operator\n    // from the global namespace.  With this using declaration,\n    // overloads of << defined in the global namespace and those\n    // visible via Koenig lookup are both exposed in this function.\n    using ::operator <<;\n    *ss_ << llvm_gtest::printable(val);\n    return *this;\n  }\n\n  // Streams a pointer value to this object.\n  //\n  // This function is an overload of the previous one.  When you\n  // stream a pointer to a Message, this definition will be used as it\n  // is more specialized.  (The C++ Standard, section\n  // [temp.func.order].)  If you stream a non-pointer, then the\n  // previous definition will be used.\n  //\n  // The reason for this overload is that streaming a NULL pointer to\n  // ostream is undefined behavior.  Depending on the compiler, you\n  // may get \"0\", \"(nil)\", \"(null)\", or an access violation.  To\n  // ensure consistent result across compilers, we always treat NULL\n  // as \"(null)\".\n  template <typename T>\n  inline Message& operator <<(T* const& pointer) {  // NOLINT\n    if (pointer == NULL) {\n      *ss_ << \"(null)\";\n    } else {\n      *ss_ << llvm_gtest::printable(pointer);\n    }\n    return *this;\n  }\n#endif  // GTEST_OS_SYMBIAN\n\n  // Since the basic IO manipulators are overloaded for both narrow\n  // and wide streams, we have to provide this specialized definition\n  // of operator <<, even though its body is the same as the\n  // templatized version above.  Without this definition, streaming\n  // endl or other basic IO manipulators to Message will confuse the\n  // compiler.\n  Message& operator <<(BasicNarrowIoManip val) {\n    *ss_ << val;\n    return *this;\n  }\n\n  // Instead of 1/0, we want to see true/false for bool values.\n  Message& operator <<(bool b) {\n    return *this << (b ? \"true\" : \"false\");\n  }\n\n  // These two overloads allow streaming a wide C string to a Message\n  // using the UTF-8 encoding.\n  Message& operator <<(const wchar_t* wide_c_str);\n  Message& operator <<(wchar_t* wide_c_str);\n\n#if GTEST_HAS_STD_WSTRING\n  // Converts the given wide string to a narrow string using the UTF-8\n  // encoding, and streams the result to this Message object.\n  Message& operator <<(const ::std::wstring& wstr);\n#endif  // GTEST_HAS_STD_WSTRING\n\n#if GTEST_HAS_GLOBAL_WSTRING\n  // Converts the given wide string to a narrow string using the UTF-8\n  // encoding, and streams the result to this Message object.\n  Message& operator <<(const ::wstring& wstr);\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n  // Gets the text streamed to this object so far as an std::string.\n  // Each '\\0' character in the buffer is replaced with \"\\\\0\".\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  std::string GetString() const;\n\n private:\n\n#if GTEST_OS_SYMBIAN\n  // These are needed as the Nokia Symbian Compiler cannot decide between\n  // const T& and const T* in a function template. The Nokia compiler _can_\n  // decide between class template specializations for T and T*, so a\n  // tr1::type_traits-like is_pointer works, and we can overload on that.\n  template <typename T>\n  inline void StreamHelper(internal::true_type /*is_pointer*/, T* pointer) {\n    if (pointer == NULL) {\n      *ss_ << \"(null)\";\n    } else {\n      *ss_ << pointer;\n    }\n  }\n  template <typename T>\n  inline void StreamHelper(internal::false_type /*is_pointer*/,\n                           const T& value) {\n    // See the comments in Message& operator <<(const T&) above for why\n    // we need this using statement.\n    using ::operator <<;\n    *ss_ << value;\n  }\n#endif  // GTEST_OS_SYMBIAN\n\n  // We'll hold the text streamed to this object here.\n  const internal::scoped_ptr< ::std::stringstream> ss_;\n\n  // We declare (but don't implement) this to prevent the compiler\n  // from implementing the assignment operator.\n  void operator=(const Message&);\n};\n\n// Streams a Message to an ostream.\ninline std::ostream& operator <<(std::ostream& os, const Message& sb) {\n  return os << sb.GetString();\n}\n\nnamespace internal {\n\n// Converts a streamable value to an std::string.  A NULL pointer is\n// converted to \"(null)\".  When the input value is a ::string,\n// ::std::string, ::wstring, or ::std::wstring object, each NUL\n// character in it is replaced with \"\\\\0\".\ntemplate <typename T>\nstd::string StreamableToString(const T& streamable) {\n  return (Message() << streamable).GetString();\n}\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-param-test.h", "content": "// This file was GENERATED by command:\n//     pump.py gtest-param-test.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: vladl@google.com (Vlad Losev)\n//\n// Macros and functions for implementing parameterized tests\n// in Google C++ Testing Framework (Google Test)\n//\n// This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\n//\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n\n\n// Value-parameterized tests allow you to test your code with different\n// parameters without writing multiple copies of the same test.\n//\n// Here is how you use value-parameterized tests:\n\n#if 0\n\n// To write value-parameterized tests, first you should define a fixture\n// class. It is usually derived from testing::TestWithParam<T> (see below for\n// another inheritance scheme that's sometimes useful in more complicated\n// class hierarchies), where the type of your parameter values.\n// TestWithParam<T> is itself derived from testing::Test. T can be any\n// copyable type. If it's a raw pointer, you are responsible for managing the\n// lifespan of the pointed values.\n\nclass FooTest : public ::testing::TestWithParam<const char*> {\n  // You can implement all the usual class fixture members here.\n};\n\n// Then, use the TEST_P macro to define as many parameterized tests\n// for this fixture as you want. The _P suffix is for \"parameterized\"\n// or \"pattern\", whichever you prefer to think.\n\nTEST_P(FooTest, DoesBlah) {\n  // Inside a test, access the test parameter with the GetParam() method\n  // of the TestWithParam<T> class:\n  EXPECT_TRUE(foo.Blah(GetParam()));\n  ...\n}\n\nTEST_P(FooTest, HasBlahBlah) {\n  ...\n}\n\n// Finally, you can use INSTANTIATE_TEST_CASE_P to instantiate the test\n// case with any set of parameters you want. Google Test defines a number\n// of functions for generating test parameters. They return what we call\n// (surprise!) parameter generators. Here is a  summary of them, which\n// are all in the testing namespace:\n//\n//\n//  Range(begin, end [, step]) - Yields values {begin, begin+step,\n//                               begin+step+step, ...}. The values do not\n//                               include end. step defaults to 1.\n//  Values(v1, v2, ..., vN)    - Yields values {v1, v2, ..., vN}.\n//  ValuesIn(container)        - Yields values from a C-style array, an STL\n//  ValuesIn(begin,end)          container, or an iterator range [begin, end).\n//  Bool()                     - Yields sequence {false, true}.\n//  Combine(g1, g2, ..., gN)   - Yields all combinations (the Cartesian product\n//                               for the math savvy) of the values generated\n//                               by the N generators.\n//\n// For more details, see comments at the definitions of these functions below\n// in this file.\n//\n// The following statement will instantiate tests from the FooTest test case\n// each with parameter values \"meeny\", \"miny\", and \"moe\".\n\nINSTANTIATE_TEST_CASE_P(InstantiationName,\n                        FooTest,\n                        Values(\"meeny\", \"miny\", \"moe\"));\n\n// To distinguish different instances of the pattern, (yes, you\n// can instantiate it more then once) the first argument to the\n// INSTANTIATE_TEST_CASE_P macro is a prefix that will be added to the\n// actual test case name. Remember to pick unique prefixes for different\n// instantiations. The tests from the instantiation above will have\n// these names:\n//\n//    * InstantiationName/FooTest.DoesBlah/0 for \"meeny\"\n//    * InstantiationName/FooTest.DoesBlah/1 for \"miny\"\n//    * InstantiationName/FooTest.DoesBlah/2 for \"moe\"\n//    * InstantiationName/FooTest.HasBlahBlah/0 for \"meeny\"\n//    * InstantiationName/FooTest.HasBlahBlah/1 for \"miny\"\n//    * InstantiationName/FooTest.HasBlahBlah/2 for \"moe\"\n//\n// You can use these names in --gtest_filter.\n//\n// This statement will instantiate all tests from FooTest again, each\n// with parameter values \"cat\" and \"dog\":\n\nconst char* pets[] = {\"cat\", \"dog\"};\nINSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));\n\n// The tests from the instantiation above will have these names:\n//\n//    * AnotherInstantiationName/FooTest.DoesBlah/0 for \"cat\"\n//    * AnotherInstantiationName/FooTest.DoesBlah/1 for \"dog\"\n//    * AnotherInstantiationName/FooTest.HasBlahBlah/0 for \"cat\"\n//    * AnotherInstantiationName/FooTest.HasBlahBlah/1 for \"dog\"\n//\n// Please note that INSTANTIATE_TEST_CASE_P will instantiate all tests\n// in the given test case, whether their definitions come before or\n// AFTER the INSTANTIATE_TEST_CASE_P statement.\n//\n// Please also note that generator expressions (including parameters to the\n// generators) are evaluated in InitGoogleTest(), after main() has started.\n// This allows the user on one hand, to adjust generator parameters in order\n// to dynamically determine a set of tests to run and on the other hand,\n// give the user a chance to inspect the generated tests with Google Test\n// reflection API before RUN_ALL_TESTS() is executed.\n//\n// You can see samples/sample7_unittest.cc and samples/sample8_unittest.cc\n// for more examples.\n//\n// In the future, we plan to publish the API for defining new parameter\n// generators. But for now this interface remains part of the internal\n// implementation and is subject to change.\n//\n//\n// A parameterized test fixture must be derived from testing::Test and from\n// testing::WithParamInterface<T>, where T is the type of the parameter\n// values. Inheriting from TestWithParam<T> satisfies that requirement because\n// TestWithParam<T> inherits from both Test and WithParamInterface. In more\n// complicated hierarchies, however, it is occasionally useful to inherit\n// separately from Test and WithParamInterface. For example:\n\nclass BaseTest : public ::testing::Test {\n  // You can inherit all the usual members for a non-parameterized test\n  // fixture here.\n};\n\nclass DerivedTest : public BaseTest, public ::testing::WithParamInterface<int> {\n  // The usual test fixture members go here too.\n};\n\nTEST_F(BaseTest, HasFoo) {\n  // This is an ordinary non-parameterized test.\n}\n\nTEST_P(DerivedTest, DoesBlah) {\n  // GetParam works just the same here as if you inherit from TestWithParam.\n  EXPECT_TRUE(foo.Blah(GetParam()));\n}\n\n#endif  // 0\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if !GTEST_OS_SYMBIAN\n# include <utility>\n#endif\n\n// scripts/fuse_gtest.py depends on gtest's own header being #included\n// *unconditionally*.  Therefore these #includes cannot be moved\n// inside #if GTEST_HAS_PARAM_TEST.\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-param-util.h\"\n#include \"gtest/internal/gtest-param-util-generated.h\"\n\n#if GTEST_HAS_PARAM_TEST\n\nnamespace testing {\n\n// Functions producing parameter generators.\n//\n// Google Test uses these generators to produce parameters for value-\n// parameterized tests. When a parameterized test case is instantiated\n// with a particular generator, Google Test creates and runs tests\n// for each element in the sequence produced by the generator.\n//\n// In the following sample, tests from test case FooTest are instantiated\n// each three times with parameter values 3, 5, and 8:\n//\n// class FooTest : public TestWithParam<int> { ... };\n//\n// TEST_P(FooTest, TestThis) {\n// }\n// TEST_P(FooTest, TestThat) {\n// }\n// INSTANTIATE_TEST_CASE_P(TestSequence, FooTest, Values(3, 5, 8));\n//\n\n// Range() returns generators providing sequences of values in a range.\n//\n// Synopsis:\n// Range(start, end)\n//   - returns a generator producing a sequence of values {start, start+1,\n//     start+2, ..., }.\n// Range(start, end, step)\n//   - returns a generator producing a sequence of values {start, start+step,\n//     start+step+step, ..., }.\n// Notes:\n//   * The generated sequences never include end. For example, Range(1, 5)\n//     returns a generator producing a sequence {1, 2, 3, 4}. Range(1, 9, 2)\n//     returns a generator producing {1, 3, 5, 7}.\n//   * start and end must have the same type. That type may be any integral or\n//     floating-point type or a user defined type satisfying these conditions:\n//     * It must be assignable (have operator=() defined).\n//     * It must have operator+() (operator+(int-compatible type) for\n//       two-operand version).\n//     * It must have operator<() defined.\n//     Elements in the resulting sequences will also have that type.\n//   * Condition start < end must be satisfied in order for resulting sequences\n//     to contain any elements.\n//\ntemplate <typename T, typename IncrementT>\ninternal::ParamGenerator<T> Range(T start, T end, IncrementT step) {\n  return internal::ParamGenerator<T>(\n      new internal::RangeGenerator<T, IncrementT>(start, end, step));\n}\n\ntemplate <typename T>\ninternal::ParamGenerator<T> Range(T start, T end) {\n  return Range(start, end, 1);\n}\n\n// ValuesIn() function allows generation of tests with parameters coming from\n// a container.\n//\n// Synopsis:\n// ValuesIn(const T (&array)[N])\n//   - returns a generator producing sequences with elements from\n//     a C-style array.\n// ValuesIn(const Container& container)\n//   - returns a generator producing sequences with elements from\n//     an STL-style container.\n// ValuesIn(Iterator begin, Iterator end)\n//   - returns a generator producing sequences with elements from\n//     a range [begin, end) defined by a pair of STL-style iterators. These\n//     iterators can also be plain C pointers.\n//\n// Please note that ValuesIn copies the values from the containers\n// passed in and keeps them to generate tests in RUN_ALL_TESTS().\n//\n// Examples:\n//\n// This instantiates tests from test case StringTest\n// each with C-string values of \"foo\", \"bar\", and \"baz\":\n//\n// const char* strings[] = {\"foo\", \"bar\", \"baz\"};\n// INSTANTIATE_TEST_CASE_P(StringSequence, SrtingTest, ValuesIn(strings));\n//\n// This instantiates tests from test case StlStringTest\n// each with STL strings with values \"a\" and \"b\":\n//\n// ::std::vector< ::std::string> GetParameterStrings() {\n//   ::std::vector< ::std::string> v;\n//   v.push_back(\"a\");\n//   v.push_back(\"b\");\n//   return v;\n// }\n//\n// INSTANTIATE_TEST_CASE_P(CharSequence,\n//                         StlStringTest,\n//                         ValuesIn(GetParameterStrings()));\n//\n//\n// This will also instantiate tests from CharTest\n// each with parameter values 'a' and 'b':\n//\n// ::std::list<char> GetParameterChars() {\n//   ::std::list<char> list;\n//   list.push_back('a');\n//   list.push_back('b');\n//   return list;\n// }\n// ::std::list<char> l = GetParameterChars();\n// INSTANTIATE_TEST_CASE_P(CharSequence2,\n//                         CharTest,\n//                         ValuesIn(l.begin(), l.end()));\n//\ntemplate <typename ForwardIterator>\ninternal::ParamGenerator<\n  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\nValuesIn(ForwardIterator begin, ForwardIterator end) {\n  typedef typename ::testing::internal::IteratorTraits<ForwardIterator>\n      ::value_type ParamType;\n  return internal::ParamGenerator<ParamType>(\n      new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));\n}\n\ntemplate <typename T, size_t N>\ninternal::ParamGenerator<T> ValuesIn(const T (&array)[N]) {\n  return ValuesIn(array, array + N);\n}\n\ntemplate <class Container>\ninternal::ParamGenerator<typename Container::value_type> ValuesIn(\n    const Container& container) {\n  return ValuesIn(container.begin(), container.end());\n}\n\n// Values() allows generating tests from explicitly specified list of\n// parameters.\n//\n// Synopsis:\n// Values(T v1, T v2, ..., T vN)\n//   - returns a generator producing sequences with elements v1, v2, ..., vN.\n//\n// For example, this instantiates tests from test case BarTest each\n// with values \"one\", \"two\", and \"three\":\n//\n// INSTANTIATE_TEST_CASE_P(NumSequence, BarTest, Values(\"one\", \"two\", \"three\"));\n//\n// This instantiates tests from test case BazTest each with values 1, 2, 3.5.\n// The exact type of values will depend on the type of parameter in BazTest.\n//\n// INSTANTIATE_TEST_CASE_P(FloatingNumbers, BazTest, Values(1, 2, 3.5));\n//\n// Currently, Values() supports from 1 to 50 parameters.\n//\ntemplate <typename T1>\ninternal::ValueArray1<T1> Values(T1 v1) {\n  return internal::ValueArray1<T1>(v1);\n}\n\ntemplate <typename T1, typename T2>\ninternal::ValueArray2<T1, T2> Values(T1 v1, T2 v2) {\n  return internal::ValueArray2<T1, T2>(v1, v2);\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninternal::ValueArray3<T1, T2, T3> Values(T1 v1, T2 v2, T3 v3) {\n  return internal::ValueArray3<T1, T2, T3>(v1, v2, v3);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninternal::ValueArray4<T1, T2, T3, T4> Values(T1 v1, T2 v2, T3 v3, T4 v4) {\n  return internal::ValueArray4<T1, T2, T3, T4>(v1, v2, v3, v4);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninternal::ValueArray5<T1, T2, T3, T4, T5> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5) {\n  return internal::ValueArray5<T1, T2, T3, T4, T5>(v1, v2, v3, v4, v5);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninternal::ValueArray6<T1, T2, T3, T4, T5, T6> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6) {\n  return internal::ValueArray6<T1, T2, T3, T4, T5, T6>(v1, v2, v3, v4, v5, v6);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninternal::ValueArray7<T1, T2, T3, T4, T5, T6, T7> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7) {\n  return internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>(v1, v2, v3, v4, v5,\n      v6, v7);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninternal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8) {\n  return internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>(v1, v2, v3, v4,\n      v5, v6, v7, v8);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninternal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9) {\n  return internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninternal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10) {\n  return internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\ninternal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\n    T11> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11) {\n  return internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\n      T11>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\ninternal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n    T12> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12) {\n  return internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\ninternal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n    T13> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13) {\n  return internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\ninternal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) {\n  return internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\ninternal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) {\n  return internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\ninternal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16) {\n  return internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\ninternal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17) {\n  return internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\ninternal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18) {\n  return internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\ninternal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19) {\n  return internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\ninternal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20) {\n  return internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\ninternal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21) {\n  return internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\ninternal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22) {\n  return internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\ninternal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23) {\n  return internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\ninternal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24) {\n  return internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>(v1, v2,\n      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\n      v19, v20, v21, v22, v23, v24);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\ninternal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\n    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\n    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25) {\n  return internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\n      v18, v19, v20, v21, v22, v23, v24, v25);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\ninternal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n    T26> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26) {\n  return internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\n      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\ninternal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n    T27> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27) {\n  return internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\n      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\ninternal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n    T28> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28) {\n  return internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\n      v28);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\ninternal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29) {\n  return internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\n      v27, v28, v29);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\ninternal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) {\n  return internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n      v26, v27, v28, v29, v30);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\ninternal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) {\n  return internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\n      v25, v26, v27, v28, v29, v30, v31);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\ninternal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32) {\n  return internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\ninternal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33) {\n  return internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\ninternal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\n    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\n    T31 v31, T32 v32, T33 v33, T34 v34) {\n  return internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\ninternal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35) {\n  return internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\ninternal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36) {\n  return internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\ninternal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37) {\n  return internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36, v37);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\ninternal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37, T38 v38) {\n  return internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>(v1, v2,\n      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\n      v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,\n      v33, v34, v35, v36, v37, v38);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\ninternal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37, T38 v38, T39 v39) {\n  return internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\n      v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31,\n      v32, v33, v34, v35, v36, v37, v38, v39);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\ninternal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\n    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\n    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27,\n    T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35,\n    T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) {\n  return internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\n      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29,\n      v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\ninternal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n    T41> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41) {\n  return internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\n      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,\n      v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\ninternal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n    T42> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42) {\n  return internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\n      v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41,\n      v42);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\ninternal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n    T43> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42, T43 v43) {\n  return internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\n      v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40,\n      v41, v42, v43);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\ninternal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42, T43 v43, T44 v44) {\n  return internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n      v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39,\n      v40, v41, v42, v43, v44);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\ninternal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,\n    T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,\n    T41 v41, T42 v42, T43 v43, T44 v44, T45 v45) {\n  return internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\n      v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38,\n      v39, v40, v41, v42, v43, v44, v45);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\ninternal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) {\n  return internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\n      v38, v39, v40, v41, v42, v43, v44, v45, v46);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\ninternal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) {\n  return internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\n      v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\ninternal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47,\n    T48 v48) {\n  return internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36,\n      v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\ninternal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\n    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\n    T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38,\n    T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46,\n    T47 v47, T48 v48, T49 v49) {\n  return internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35,\n      v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\ninternal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49, T50> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37,\n    T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45,\n    T46 v46, T47 v47, T48 v48, T49 v49, T50 v50) {\n  return internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47,\n      v48, v49, v50);\n}\n\n// Bool() allows generating tests with parameters in a set of (false, true).\n//\n// Synopsis:\n// Bool()\n//   - returns a generator producing sequences with elements {false, true}.\n//\n// It is useful when testing code that depends on Boolean flags. Combinations\n// of multiple flags can be tested when several Bool()'s are combined using\n// Combine() function.\n//\n// In the following example all tests in the test case FlagDependentTest\n// will be instantiated twice with parameters false and true.\n//\n// class FlagDependentTest : public testing::TestWithParam<bool> {\n//   virtual void SetUp() {\n//     external_flag = GetParam();\n//   }\n// }\n// INSTANTIATE_TEST_CASE_P(BoolSequence, FlagDependentTest, Bool());\n//\ninline internal::ParamGenerator<bool> Bool() {\n  return Values(false, true);\n}\n\n# if GTEST_HAS_COMBINE\n// Combine() allows the user to combine two or more sequences to produce\n// values of a Cartesian product of those sequences' elements.\n//\n// Synopsis:\n// Combine(gen1, gen2, ..., genN)\n//   - returns a generator producing sequences with elements coming from\n//     the Cartesian product of elements from the sequences generated by\n//     gen1, gen2, ..., genN. The sequence elements will have a type of\n//     tuple<T1, T2, ..., TN> where T1, T2, ..., TN are the types\n//     of elements from sequences produces by gen1, gen2, ..., genN.\n//\n// Combine can have up to 10 arguments. This number is currently limited\n// by the maximum number of elements in the tuple implementation used by Google\n// Test.\n//\n// Example:\n//\n// This will instantiate tests in test case AnimalTest each one with\n// the parameter values tuple(\"cat\", BLACK), tuple(\"cat\", WHITE),\n// tuple(\"dog\", BLACK), and tuple(\"dog\", WHITE):\n//\n// enum Color { BLACK, GRAY, WHITE };\n// class AnimalTest\n//     : public testing::TestWithParam<tuple<const char*, Color> > {...};\n//\n// TEST_P(AnimalTest, AnimalLooksNice) {...}\n//\n// INSTANTIATE_TEST_CASE_P(AnimalVariations, AnimalTest,\n//                         Combine(Values(\"cat\", \"dog\"),\n//                                 Values(BLACK, WHITE)));\n//\n// This will instantiate tests in FlagDependentTest with all variations of two\n// Boolean flags:\n//\n// class FlagDependentTest\n//     : public testing::TestWithParam<tuple<bool, bool> > {\n//   virtual void SetUp() {\n//     // Assigns external_flag_1 and external_flag_2 values from the tuple.\n//     tie(external_flag_1, external_flag_2) = GetParam();\n//   }\n// };\n//\n// TEST_P(FlagDependentTest, TestFeature1) {\n//   // Test your code using external_flag_1 and external_flag_2 here.\n// }\n// INSTANTIATE_TEST_CASE_P(TwoBoolSequence, FlagDependentTest,\n//                         Combine(Bool(), Bool()));\n//\ntemplate <typename Generator1, typename Generator2>\ninternal::CartesianProductHolder2<Generator1, Generator2> Combine(\n    const Generator1& g1, const Generator2& g2) {\n  return internal::CartesianProductHolder2<Generator1, Generator2>(\n      g1, g2);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3>\ninternal::CartesianProductHolder3<Generator1, Generator2, Generator3> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3) {\n  return internal::CartesianProductHolder3<Generator1, Generator2, Generator3>(\n      g1, g2, g3);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4>\ninternal::CartesianProductHolder4<Generator1, Generator2, Generator3,\n    Generator4> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4) {\n  return internal::CartesianProductHolder4<Generator1, Generator2, Generator3,\n      Generator4>(\n      g1, g2, g3, g4);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5>\ninternal::CartesianProductHolder5<Generator1, Generator2, Generator3,\n    Generator4, Generator5> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5) {\n  return internal::CartesianProductHolder5<Generator1, Generator2, Generator3,\n      Generator4, Generator5>(\n      g1, g2, g3, g4, g5);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6>\ninternal::CartesianProductHolder6<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6) {\n  return internal::CartesianProductHolder6<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6>(\n      g1, g2, g3, g4, g5, g6);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7>\ninternal::CartesianProductHolder7<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7) {\n  return internal::CartesianProductHolder7<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7>(\n      g1, g2, g3, g4, g5, g6, g7);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8>\ninternal::CartesianProductHolder8<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8) {\n  return internal::CartesianProductHolder8<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8>(\n      g1, g2, g3, g4, g5, g6, g7, g8);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8, typename Generator9>\ninternal::CartesianProductHolder9<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8,\n    Generator9> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8, const Generator9& g9) {\n  return internal::CartesianProductHolder9<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9>(\n      g1, g2, g3, g4, g5, g6, g7, g8, g9);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8, typename Generator9,\n    typename Generator10>\ninternal::CartesianProductHolder10<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\n    Generator10> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8, const Generator9& g9,\n        const Generator10& g10) {\n  return internal::CartesianProductHolder10<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\n      Generator10>(\n      g1, g2, g3, g4, g5, g6, g7, g8, g9, g10);\n}\n# endif  // GTEST_HAS_COMBINE\n\n\n\n# define TEST_P(test_case_name, test_name) \\\n  class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      : public test_case_name { \\\n   public: \\\n    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {} \\\n    virtual void TestBody(); \\\n   private: \\\n    static int AddToRegistry() { \\\n      ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\\n          GetTestCasePatternHolder<test_case_name>(\\\n              #test_case_name, \\\n              ::testing::internal::CodeLocation(\\\n                  __FILE__, __LINE__))->AddTestPattern(\\\n                      #test_case_name, \\\n                      #test_name, \\\n                      new ::testing::internal::TestMetaFactory< \\\n                          GTEST_TEST_CLASS_NAME_(\\\n                              test_case_name, test_name)>()); \\\n      return 0; \\\n    } \\\n    static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \\\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n        GTEST_TEST_CLASS_NAME_(test_case_name, test_name)); \\\n  }; \\\n  int GTEST_TEST_CLASS_NAME_(test_case_name, \\\n                             test_name)::gtest_registering_dummy_ = \\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::AddToRegistry(); \\\n  void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n// The optional last argument to INSTANTIATE_TEST_CASE_P allows the user\n// to specify a function or functor that generates custom test name suffixes\n// based on the test parameters. The function should accept one argument of\n// type testing::TestParamInfo<class ParamType>, and return std::string.\n//\n// testing::PrintToStringParamName is a builtin test suffix generator that\n// returns the value of testing::PrintToString(GetParam()). It does not work\n// for std::string or C strings.\n//\n// Note: test names must be non-empty, unique, and may only contain ASCII\n// alphanumeric characters or underscore.\n\n# define INSTANTIATE_TEST_CASE_P(prefix, test_case_name, generator, ...) \\\n  ::testing::internal::ParamGenerator<test_case_name::ParamType> \\\n      gtest_##prefix##test_case_name##_EvalGenerator_() { return generator; } \\\n  ::std::string gtest_##prefix##test_case_name##_EvalGenerateName_( \\\n      const ::testing::TestParamInfo<test_case_name::ParamType>& info) { \\\n    return ::testing::internal::GetParamNameGen<test_case_name::ParamType> \\\n        (__VA_ARGS__)(info); \\\n  } \\\n  int gtest_##prefix##test_case_name##_dummy_ GTEST_ATTRIBUTE_UNUSED_ = \\\n      ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\\n          GetTestCasePatternHolder<test_case_name>(\\\n              #test_case_name, \\\n              ::testing::internal::CodeLocation(\\\n                  __FILE__, __LINE__))->AddTestCaseInstantiation(\\\n                      #prefix, \\\n                      &gtest_##prefix##test_case_name##_EvalGenerator_, \\\n                      &gtest_##prefix##test_case_name##_EvalGenerateName_, \\\n                      __FILE__, __LINE__)\n\n}  // namespace testing\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-printers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Test - The Google C++ Testing Framework\n//\n// This file implements a universal value printer that can print a\n// value of any type T:\n//\n//   void ::testing::internal::UniversalPrinter<T>::Print(value, ostream_ptr);\n//\n// A user can teach this function how to print a class type T by\n// defining either operator<<() or PrintTo() in the namespace that\n// defines T.  More specifically, the FIRST defined function in the\n// following list will be used (assuming T is defined in namespace\n// foo):\n//\n//   1. foo::PrintTo(const T&, ostream*)\n//   2. operator<<(ostream&, const T&) defined in either foo or the\n//      global namespace.\n//\n// If none of the above is defined, it will print the debug string of\n// the value if it is a protocol buffer, or print the raw bytes in the\n// value otherwise.\n//\n// To aid debugging: when T is a reference type, the address of the\n// value is also printed; when T is a (const) char pointer, both the\n// pointer value and the NUL-terminated string it points to are\n// printed.\n//\n// We also provide some convenient wrappers:\n//\n//   // Prints a value to a string.  For a (const or not) char\n//   // pointer, the NUL-terminated string (but not the pointer) is\n//   // printed.\n//   std::string ::testing::PrintToString(const T& value);\n//\n//   // Prints a value tersely: for a reference type, the referenced\n//   // value (but not the address) is printed; for a (const or not) char\n//   // pointer, the NUL-terminated string (but not the pointer) is\n//   // printed.\n//   void ::testing::internal::UniversalTersePrint(const T& value, ostream*);\n//\n//   // Prints value using the type inferred by the compiler.  The difference\n//   // from UniversalTersePrint() is that this function prints both the\n//   // pointer and the NUL-terminated string for a (const or not) char pointer.\n//   void ::testing::internal::UniversalPrint(const T& value, ostream*);\n//\n//   // Prints the fields of a tuple tersely to a string vector, one\n//   // element for each field. Tuple support must be enabled in\n//   // gtest-port.h.\n//   std::vector<string> UniversalTersePrintTupleFieldsToStrings(\n//       const Tuple& value);\n//\n// Known limitation:\n//\n// The print primitives print the elements of an STL-style container\n// using the compiler-inferred type of *iter where iter is a\n// const_iterator of the container.  When const_iterator is an input\n// iterator but not a forward iterator, this inferred type may not\n// match value_type, and the print output may be incorrect.  In\n// practice, this is rarely a problem as for most containers\n// const_iterator is a forward iterator.  We'll fix this if there's an\n// actual need for it.  Note that this fix cannot rely on value_type\n// being defined as many user-defined container types don't have\n// value_type.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n\n#include <ostream>  // NOLINT\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n#include \"gtest/internal/gtest-port.h\"\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/custom/raw-ostream.h\"\n\n#if GTEST_HAS_STD_TUPLE_\n# include <tuple>\n#endif\n\nnamespace testing {\n\n// Definitions in the 'internal' and 'internal2' name spaces are\n// subject to change without notice.  DO NOT USE THEM IN USER CODE!\nnamespace internal2 {\n\n// Prints the given number of bytes in the given object to the given\n// ostream.\nGTEST_API_ void PrintBytesInObjectTo(const unsigned char* obj_bytes,\n                                     size_t count,\n                                     ::std::ostream* os);\n\n// For selecting which printer to use when a given type has neither <<\n// nor PrintTo().\nenum TypeKind {\n  kProtobuf,              // a protobuf type\n  kConvertibleToInteger,  // a type implicitly convertible to BiggestInt\n                          // (e.g. a named or unnamed enum type)\n  kOtherType              // anything else\n};\n\n// TypeWithoutFormatter<T, kTypeKind>::PrintValue(value, os) is called\n// by the universal printer to print a value of type T when neither\n// operator<< nor PrintTo() is defined for T, where kTypeKind is the\n// \"kind\" of T as defined by enum TypeKind.\ntemplate <typename T, TypeKind kTypeKind>\nclass TypeWithoutFormatter {\n public:\n  // This default version is called when kTypeKind is kOtherType.\n  static void PrintValue(const T& value, ::std::ostream* os) {\n    PrintBytesInObjectTo(reinterpret_cast<const unsigned char*>(&value),\n                         sizeof(value), os);\n  }\n};\n\n// We print a protobuf using its ShortDebugString() when the string\n// doesn't exceed this many characters; otherwise we print it using\n// DebugString() for better readability.\nconst size_t kProtobufOneLinerMaxLength = 50;\n\ntemplate <typename T>\nclass TypeWithoutFormatter<T, kProtobuf> {\n public:\n  static void PrintValue(const T& value, ::std::ostream* os) {\n    const ::testing::internal::string short_str = value.ShortDebugString();\n    const ::testing::internal::string pretty_str =\n        short_str.length() <= kProtobufOneLinerMaxLength ?\n        short_str : (\"\\n\" + value.DebugString());\n    *os << (\"<\" + pretty_str + \">\");\n  }\n};\n\ntemplate <typename T>\nclass TypeWithoutFormatter<T, kConvertibleToInteger> {\n public:\n  // Since T has no << operator or PrintTo() but can be implicitly\n  // converted to BiggestInt, we print it as a BiggestInt.\n  //\n  // Most likely T is an enum type (either named or unnamed), in which\n  // case printing it as an integer is the desired behavior.  In case\n  // T is not an enum, printing it as an integer is the best we can do\n  // given that it has no user-defined printer.\n  static void PrintValue(const T& value, ::std::ostream* os) {\n    const internal::BiggestInt kBigInt = value;\n    *os << kBigInt;\n  }\n};\n\n// Prints the given value to the given ostream.  If the value is a\n// protocol message, its debug string is printed; if it's an enum or\n// of a type implicitly convertible to BiggestInt, it's printed as an\n// integer; otherwise the bytes in the value are printed.  This is\n// what UniversalPrinter<T>::Print() does when it knows nothing about\n// type T and T has neither << operator nor PrintTo().\n//\n// A user can override this behavior for a class type Foo by defining\n// a << operator in the namespace where Foo is defined.\n//\n// We put this operator in namespace 'internal2' instead of 'internal'\n// to simplify the implementation, as much code in 'internal' needs to\n// use << in STL, which would conflict with our own << were it defined\n// in 'internal'.\n//\n// Note that this operator<< takes a generic std::basic_ostream<Char,\n// CharTraits> type instead of the more restricted std::ostream.  If\n// we define it to take an std::ostream instead, we'll get an\n// \"ambiguous overloads\" compiler error when trying to print a type\n// Foo that supports streaming to std::basic_ostream<Char,\n// CharTraits>, as the compiler cannot tell whether\n// operator<<(std::ostream&, const T&) or\n// operator<<(std::basic_stream<Char, CharTraits>, const Foo&) is more\n// specific.\ntemplate <typename Char, typename CharTraits, typename T>\n::std::basic_ostream<Char, CharTraits>& operator<<(\n    ::std::basic_ostream<Char, CharTraits>& os, const T& x) {\n  TypeWithoutFormatter<T,\n      (internal::IsAProtocolMessage<T>::value ? kProtobuf :\n       internal::ImplicitlyConvertible<const T&, internal::BiggestInt>::value ?\n       kConvertibleToInteger : kOtherType)>::PrintValue(x, &os);\n  return os;\n}\n\n}  // namespace internal2\n}  // namespace testing\n\n// This namespace MUST NOT BE NESTED IN ::testing, or the name look-up\n// magic needed for implementing UniversalPrinter won't work.\nnamespace testing_internal {\n\n// Used to print a value that is not an STL-style container when the\n// user doesn't define PrintTo() for it.\ntemplate <typename T>\nvoid DefaultPrintNonContainerTo(const T& value, ::std::ostream* os) {\n  // With the following statement, during unqualified name lookup,\n  // testing::internal2::operator<< appears as if it was declared in\n  // the nearest enclosing namespace that contains both\n  // ::testing_internal and ::testing::internal2, i.e. the global\n  // namespace.  For more details, refer to the C++ Standard section\n  // 7.3.4-1 [namespace.udir].  This allows us to fall back onto\n  // testing::internal2::operator<< in case T doesn't come with a <<\n  // operator.\n  //\n  // We cannot write 'using ::testing::internal2::operator<<;', which\n  // gcc 3.3 fails to compile due to a compiler bug.\n  using namespace ::testing::internal2;  // NOLINT\n\n  // Assuming T is defined in namespace foo, in the next statement,\n  // the compiler will consider all of:\n  //\n  //   1. foo::operator<< (thanks to Koenig look-up),\n  //   2. ::operator<< (as the current namespace is enclosed in ::),\n  //   3. testing::internal2::operator<< (thanks to the using statement above).\n  //\n  // The operator<< whose type matches T best will be picked.\n  //\n  // We deliberately allow #2 to be a candidate, as sometimes it's\n  // impossible to define #1 (e.g. when foo is ::std, defining\n  // anything in it is undefined behavior unless you are a compiler\n  // vendor.).\n  *os << ::llvm_gtest::printable(value);\n}\n\n}  // namespace testing_internal\n\nnamespace testing {\nnamespace internal {\n\n// FormatForComparison<ToPrint, OtherOperand>::Format(value) formats a\n// value of type ToPrint that is an operand of a comparison assertion\n// (e.g. ASSERT_EQ).  OtherOperand is the type of the other operand in\n// the comparison, and is used to help determine the best way to\n// format the value.  In particular, when the value is a C string\n// (char pointer) and the other operand is an STL string object, we\n// want to format the C string as a string, since we know it is\n// compared by value with the string object.  If the value is a char\n// pointer but the other operand is not an STL string object, we don't\n// know whether the pointer is supposed to point to a NUL-terminated\n// string, and thus want to print it as a pointer to be safe.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// The default case.\ntemplate <typename ToPrint, typename OtherOperand>\nclass FormatForComparison {\n public:\n  static ::std::string Format(const ToPrint& value) {\n    return ::testing::PrintToString(value);\n  }\n};\n\n// Array.\ntemplate <typename ToPrint, size_t N, typename OtherOperand>\nclass FormatForComparison<ToPrint[N], OtherOperand> {\n public:\n  static ::std::string Format(const ToPrint* value) {\n    return FormatForComparison<const ToPrint*, OtherOperand>::Format(value);\n  }\n};\n\n// By default, print C string as pointers to be safe, as we don't know\n// whether they actually point to a NUL-terminated string.\n\n#define GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(CharType)                \\\n  template <typename OtherOperand>                                      \\\n  class FormatForComparison<CharType*, OtherOperand> {                  \\\n   public:                                                              \\\n    static ::std::string Format(CharType* value) {                      \\\n      return ::testing::PrintToString(static_cast<const void*>(value)); \\\n    }                                                                   \\\n  }\n\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(char);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const char);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(wchar_t);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const wchar_t);\n\n#undef GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_\n\n// If a C string is compared with an STL string object, we know it's meant\n// to point to a NUL-terminated string, and thus can print it as a string.\n\n#define GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(CharType, OtherStringType) \\\n  template <>                                                           \\\n  class FormatForComparison<CharType*, OtherStringType> {               \\\n   public:                                                              \\\n    static ::std::string Format(CharType* value) {                      \\\n      return ::testing::PrintToString(value);                           \\\n    }                                                                   \\\n  }\n\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char, ::std::string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char, ::std::string);\n\n#if GTEST_HAS_GLOBAL_STRING\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char, ::string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char, ::string);\n#endif\n\n#if GTEST_HAS_GLOBAL_WSTRING\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(wchar_t, ::wstring);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const wchar_t, ::wstring);\n#endif\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(wchar_t, ::std::wstring);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const wchar_t, ::std::wstring);\n#endif\n\n#undef GTEST_IMPL_FORMAT_C_STRING_AS_STRING_\n\n// Formats a comparison assertion (e.g. ASSERT_EQ, EXPECT_LT, and etc)\n// operand to be used in a failure message.  The type (but not value)\n// of the other operand may affect the format.  This allows us to\n// print a char* as a raw pointer when it is compared against another\n// char* or void*, and print it as a C string when it is compared\n// against an std::string object, for example.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename T1, typename T2>\nstd::string FormatForComparisonFailureMessage(\n    const T1& value, const T2& /* other_operand */) {\n  return FormatForComparison<T1, T2>::Format(value);\n}\n\n// UniversalPrinter<T>::Print(value, ostream_ptr) prints the given\n// value to the given ostream.  The caller must ensure that\n// 'ostream_ptr' is not NULL, or the behavior is undefined.\n//\n// We define UniversalPrinter as a class template (as opposed to a\n// function template), as we need to partially specialize it for\n// reference types, which cannot be done with function templates.\ntemplate <typename T>\nclass UniversalPrinter;\n\ntemplate <typename T>\nvoid UniversalPrint(const T& value, ::std::ostream* os);\n\n// Used to print an STL-style container when the user doesn't define\n// a PrintTo() for it.\ntemplate <typename C>\nvoid DefaultPrintTo(IsContainer /* dummy */,\n                    false_type /* is not a pointer */,\n                    const C& container, ::std::ostream* os) {\n  const size_t kMaxCount = 32;  // The maximum number of elements to print.\n  *os << '{';\n  size_t count = 0;\n  for (typename C::const_iterator it = container.begin();\n       it != container.end(); ++it, ++count) {\n    if (count > 0) {\n      *os << ',';\n      if (count == kMaxCount) {  // Enough has been printed.\n        *os << \" ...\";\n        break;\n      }\n    }\n    *os << ' ';\n    // We cannot call PrintTo(*it, os) here as PrintTo() doesn't\n    // handle *it being a native array.\n    internal::UniversalPrint(*it, os);\n  }\n\n  if (count > 0) {\n    *os << ' ';\n  }\n  *os << '}';\n}\n\n// Used to print a pointer that is neither a char pointer nor a member\n// pointer, when the user doesn't define PrintTo() for it.  (A member\n// variable pointer or member function pointer doesn't really point to\n// a location in the address space.  Their representation is\n// implementation-defined.  Therefore they will be printed as raw\n// bytes.)\ntemplate <typename T>\nvoid DefaultPrintTo(IsNotContainer /* dummy */,\n                    true_type /* is a pointer */,\n                    T* p, ::std::ostream* os) {\n  if (p == NULL) {\n    *os << \"NULL\";\n  } else {\n    // C++ doesn't allow casting from a function pointer to any object\n    // pointer.\n    //\n    // IsTrue() silences warnings: \"Condition is always true\",\n    // \"unreachable code\".\n    if (IsTrue(ImplicitlyConvertible<T*, const void*>::value)) {\n      // T is not a function type.  We just call << to print p,\n      // relying on ADL to pick up user-defined << for their pointer\n      // types, if any.\n      *os << p;\n    } else {\n      // T is a function type, so '*os << p' doesn't do what we want\n      // (it just prints p as bool).  We want to print p as a const\n      // void*.  However, we cannot cast it to const void* directly,\n      // even using reinterpret_cast, as earlier versions of gcc\n      // (e.g. 3.4.5) cannot compile the cast when p is a function\n      // pointer.  Casting to UInt64 first solves the problem.\n      *os << reinterpret_cast<const void*>(\n          reinterpret_cast<internal::UInt64>(p));\n    }\n  }\n}\n\n// Used to print a non-container, non-pointer value when the user\n// doesn't define PrintTo() for it.\ntemplate <typename T>\nvoid DefaultPrintTo(IsNotContainer /* dummy */,\n                    false_type /* is not a pointer */,\n                    const T& value, ::std::ostream* os) {\n  ::testing_internal::DefaultPrintNonContainerTo(value, os);\n}\n\n// Prints the given value using the << operator if it has one;\n// otherwise prints the bytes in it.  This is what\n// UniversalPrinter<T>::Print() does when PrintTo() is not specialized\n// or overloaded for type T.\n//\n// A user can override this behavior for a class type Foo by defining\n// an overload of PrintTo() in the namespace where Foo is defined.  We\n// give the user this option as sometimes defining a << operator for\n// Foo is not desirable (e.g. the coding style may prevent doing it,\n// or there is already a << operator but it doesn't do what the user\n// wants).\ntemplate <typename T>\nvoid PrintTo(const T& value, ::std::ostream* os) {\n  // DefaultPrintTo() is overloaded.  The type of its first two\n  // arguments determine which version will be picked.  If T is an\n  // STL-style container, the version for container will be called; if\n  // T is a pointer, the pointer version will be called; otherwise the\n  // generic version will be called.\n  //\n  // Note that we check for container types here, prior to we check\n  // for protocol message types in our operator<<.  The rationale is:\n  //\n  // For protocol messages, we want to give people a chance to\n  // override Google Mock's format by defining a PrintTo() or\n  // operator<<.  For STL containers, other formats can be\n  // incompatible with Google Mock's format for the container\n  // elements; therefore we check for container types here to ensure\n  // that our format is used.\n  //\n  // The second argument of DefaultPrintTo() is needed to bypass a bug\n  // in Symbian's C++ compiler that prevents it from picking the right\n  // overload between:\n  //\n  //   PrintTo(const T& x, ...);\n  //   PrintTo(T* x, ...);\n  DefaultPrintTo(IsContainerTest<T>(0), is_pointer<T>(), value, os);\n}\n\n// The following list of PrintTo() overloads tells\n// UniversalPrinter<T>::Print() how to print standard types (built-in\n// types, strings, plain arrays, and pointers).\n\n// Overloads for various char types.\nGTEST_API_ void PrintTo(unsigned char c, ::std::ostream* os);\nGTEST_API_ void PrintTo(signed char c, ::std::ostream* os);\ninline void PrintTo(char c, ::std::ostream* os) {\n  // When printing a plain char, we always treat it as unsigned.  This\n  // way, the output won't be affected by whether the compiler thinks\n  // char is signed or not.\n  PrintTo(static_cast<unsigned char>(c), os);\n}\n\n// Overloads for other simple built-in types.\ninline void PrintTo(bool x, ::std::ostream* os) {\n  *os << (x ? \"true\" : \"false\");\n}\n\n// Overload for wchar_t type.\n// Prints a wchar_t as a symbol if it is printable or as its internal\n// code otherwise and also as its decimal code (except for L'\\0').\n// The L'\\0' char is printed as \"L'\\\\0'\". The decimal code is printed\n// as signed integer when wchar_t is implemented by the compiler\n// as a signed type and is printed as an unsigned integer when wchar_t\n// is implemented as an unsigned type.\nGTEST_API_ void PrintTo(wchar_t wc, ::std::ostream* os);\n\n// Overloads for C strings.\nGTEST_API_ void PrintTo(const char* s, ::std::ostream* os);\ninline void PrintTo(char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const char*>(s), os);\n}\n\n// signed/unsigned char is often used for representing binary data, so\n// we print pointers to it as void* to be safe.\ninline void PrintTo(const signed char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const void*>(s), os);\n}\ninline void PrintTo(signed char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const void*>(s), os);\n}\ninline void PrintTo(const unsigned char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const void*>(s), os);\n}\ninline void PrintTo(unsigned char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const void*>(s), os);\n}\n\n// MSVC can be configured to define wchar_t as a typedef of unsigned\n// short.  It defines _NATIVE_WCHAR_T_DEFINED when wchar_t is a native\n// type.  When wchar_t is a typedef, defining an overload for const\n// wchar_t* would cause unsigned short* be printed as a wide string,\n// possibly causing invalid memory accesses.\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n// Overloads for wide C strings\nGTEST_API_ void PrintTo(const wchar_t* s, ::std::ostream* os);\ninline void PrintTo(wchar_t* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const wchar_t*>(s), os);\n}\n#endif\n\n// Overload for C arrays.  Multi-dimensional arrays are printed\n// properly.\n\n// Prints the given number of elements in an array, without printing\n// the curly braces.\ntemplate <typename T>\nvoid PrintRawArrayTo(const T a[], size_t count, ::std::ostream* os) {\n  UniversalPrint(a[0], os);\n  for (size_t i = 1; i != count; i++) {\n    *os << \", \";\n    UniversalPrint(a[i], os);\n  }\n}\n\n// Overloads for ::string and ::std::string.\n#if GTEST_HAS_GLOBAL_STRING\nGTEST_API_ void PrintStringTo(const ::string&s, ::std::ostream* os);\ninline void PrintTo(const ::string& s, ::std::ostream* os) {\n  PrintStringTo(s, os);\n}\n#endif  // GTEST_HAS_GLOBAL_STRING\n\nGTEST_API_ void PrintStringTo(const ::std::string&s, ::std::ostream* os);\ninline void PrintTo(const ::std::string& s, ::std::ostream* os) {\n  PrintStringTo(s, os);\n}\n\n// Overloads for ::wstring and ::std::wstring.\n#if GTEST_HAS_GLOBAL_WSTRING\nGTEST_API_ void PrintWideStringTo(const ::wstring&s, ::std::ostream* os);\ninline void PrintTo(const ::wstring& s, ::std::ostream* os) {\n  PrintWideStringTo(s, os);\n}\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ void PrintWideStringTo(const ::std::wstring&s, ::std::ostream* os);\ninline void PrintTo(const ::std::wstring& s, ::std::ostream* os) {\n  PrintWideStringTo(s, os);\n}\n#endif  // GTEST_HAS_STD_WSTRING\n\n#if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_\n// Helper function for printing a tuple.  T must be instantiated with\n// a tuple type.\ntemplate <typename T>\nvoid PrintTupleTo(const T& t, ::std::ostream* os);\n#endif  // GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_\n\n#if GTEST_HAS_TR1_TUPLE\n// Overload for ::std::tr1::tuple.  Needed for printing function arguments,\n// which are packed as tuples.\n\n// Overloaded PrintTo() for tuples of various arities.  We support\n// tuples of up-to 10 fields.  The following implementation works\n// regardless of whether tr1::tuple is implemented using the\n// non-standard variadic template feature or not.\n\ninline void PrintTo(const ::std::tr1::tuple<>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1>\nvoid PrintTo(const ::std::tr1::tuple<T1>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6, typename T7>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6, typename T7, typename T8>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6, typename T7, typename T8, typename T9>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6, typename T7, typename T8, typename T9, typename T10>\nvoid PrintTo(\n    const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>& t,\n    ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n#endif  // GTEST_HAS_TR1_TUPLE\n\n#if GTEST_HAS_STD_TUPLE_\ntemplate <typename... Types>\nvoid PrintTo(const ::std::tuple<Types...>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n#endif  // GTEST_HAS_STD_TUPLE_\n\n// Overload for std::pair.\ntemplate <typename T1, typename T2>\nvoid PrintTo(const ::std::pair<T1, T2>& value, ::std::ostream* os) {\n  *os << '(';\n  // We cannot use UniversalPrint(value.first, os) here, as T1 may be\n  // a reference type.  The same for printing value.second.\n  UniversalPrinter<T1>::Print(value.first, os);\n  *os << \", \";\n  UniversalPrinter<T2>::Print(value.second, os);\n  *os << ')';\n}\n\n// Implements printing a non-reference type T by letting the compiler\n// pick the right overload of PrintTo() for T.\ntemplate <typename T>\nclass UniversalPrinter {\n public:\n  // MSVC warns about adding const to a function type, so we want to\n  // disable the warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)\n\n  // Note: we deliberately don't call this PrintTo(), as that name\n  // conflicts with ::testing::internal::PrintTo in the body of the\n  // function.\n  static void Print(const T& value, ::std::ostream* os) {\n    // By default, ::testing::internal::PrintTo() is used for printing\n    // the value.\n    //\n    // Thanks to Koenig look-up, if T is a class and has its own\n    // PrintTo() function defined in its namespace, that function will\n    // be visible here.  Since it is more specific than the generic ones\n    // in ::testing::internal, it will be picked by the compiler in the\n    // following statement - exactly what we want.\n    PrintTo(value, os);\n  }\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n};\n\n// UniversalPrintArray(begin, len, os) prints an array of 'len'\n// elements, starting at address 'begin'.\ntemplate <typename T>\nvoid UniversalPrintArray(const T* begin, size_t len, ::std::ostream* os) {\n  if (len == 0) {\n    *os << \"{}\";\n  } else {\n    *os << \"{ \";\n    const size_t kThreshold = 18;\n    const size_t kChunkSize = 8;\n    // If the array has more than kThreshold elements, we'll have to\n    // omit some details by printing only the first and the last\n    // kChunkSize elements.\n    // TODO(wan@google.com): let the user control the threshold using a flag.\n    if (len <= kThreshold) {\n      PrintRawArrayTo(begin, len, os);\n    } else {\n      PrintRawArrayTo(begin, kChunkSize, os);\n      *os << \", ..., \";\n      PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);\n    }\n    *os << \" }\";\n  }\n}\n// This overload prints a (const) char array compactly.\nGTEST_API_ void UniversalPrintArray(\n    const char* begin, size_t len, ::std::ostream* os);\n\n// This overload prints a (const) wchar_t array compactly.\nGTEST_API_ void UniversalPrintArray(\n    const wchar_t* begin, size_t len, ::std::ostream* os);\n\n// Implements printing an array type T[N].\ntemplate <typename T, size_t N>\nclass UniversalPrinter<T[N]> {\n public:\n  // Prints the given array, omitting some elements when there are too\n  // many.\n  static void Print(const T (&a)[N], ::std::ostream* os) {\n    UniversalPrintArray(a, N, os);\n  }\n};\n\n// Implements printing a reference type T&.\ntemplate <typename T>\nclass UniversalPrinter<T&> {\n public:\n  // MSVC warns about adding const to a function type, so we want to\n  // disable the warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)\n\n  static void Print(const T& value, ::std::ostream* os) {\n    // Prints the address of the value.  We use reinterpret_cast here\n    // as static_cast doesn't compile when T is a function type.\n    *os << \"@\" << reinterpret_cast<const void*>(&value) << \" \";\n\n    // Then prints the value itself.\n    UniversalPrint(value, os);\n  }\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n};\n\n// Prints a value tersely: for a reference type, the referenced value\n// (but not the address) is printed; for a (const) char pointer, the\n// NUL-terminated string (but not the pointer) is printed.\n\ntemplate <typename T>\nclass UniversalTersePrinter {\n public:\n  static void Print(const T& value, ::std::ostream* os) {\n    UniversalPrint(value, os);\n  }\n};\ntemplate <typename T>\nclass UniversalTersePrinter<T&> {\n public:\n  static void Print(const T& value, ::std::ostream* os) {\n    UniversalPrint(value, os);\n  }\n};\ntemplate <typename T, size_t N>\nclass UniversalTersePrinter<T[N]> {\n public:\n  static void Print(const T (&value)[N], ::std::ostream* os) {\n    UniversalPrinter<T[N]>::Print(value, os);\n  }\n};\ntemplate <>\nclass UniversalTersePrinter<const char*> {\n public:\n  static void Print(const char* str, ::std::ostream* os) {\n    if (str == NULL) {\n      *os << \"NULL\";\n    } else {\n      UniversalPrint(string(str), os);\n    }\n  }\n};\ntemplate <>\nclass UniversalTersePrinter<char*> {\n public:\n  static void Print(char* str, ::std::ostream* os) {\n    UniversalTersePrinter<const char*>::Print(str, os);\n  }\n};\n\n#if GTEST_HAS_STD_WSTRING\ntemplate <>\nclass UniversalTersePrinter<const wchar_t*> {\n public:\n  static void Print(const wchar_t* str, ::std::ostream* os) {\n    if (str == NULL) {\n      *os << \"NULL\";\n    } else {\n      UniversalPrint(::std::wstring(str), os);\n    }\n  }\n};\n#endif\n\ntemplate <>\nclass UniversalTersePrinter<wchar_t*> {\n public:\n  static void Print(wchar_t* str, ::std::ostream* os) {\n    UniversalTersePrinter<const wchar_t*>::Print(str, os);\n  }\n};\n\ntemplate <typename T>\nvoid UniversalTersePrint(const T& value, ::std::ostream* os) {\n  UniversalTersePrinter<T>::Print(value, os);\n}\n\n// Prints a value using the type inferred by the compiler.  The\n// difference between this and UniversalTersePrint() is that for a\n// (const) char pointer, this prints both the pointer and the\n// NUL-terminated string.\ntemplate <typename T>\nvoid UniversalPrint(const T& value, ::std::ostream* os) {\n  // A workarond for the bug in VC++ 7.1 that prevents us from instantiating\n  // UniversalPrinter with T directly.\n  typedef T T1;\n  UniversalPrinter<T1>::Print(value, os);\n}\n\ntypedef ::std::vector<string> Strings;\n\n// TuplePolicy<TupleT> must provide:\n// - tuple_size\n//     size of tuple TupleT.\n// - get<size_t I>(const TupleT& t)\n//     static function extracting element I of tuple TupleT.\n// - tuple_element<size_t I>::type\n//     type of element I of tuple TupleT.\ntemplate <typename TupleT>\nstruct TuplePolicy;\n\n#if GTEST_HAS_TR1_TUPLE\ntemplate <typename TupleT>\nstruct TuplePolicy {\n  typedef TupleT Tuple;\n  static const size_t tuple_size = ::std::tr1::tuple_size<Tuple>::value;\n\n  template <size_t I>\n  struct tuple_element : ::std::tr1::tuple_element<I, Tuple> {};\n\n  template <size_t I>\n  static typename AddReference<\n      const typename ::std::tr1::tuple_element<I, Tuple>::type>::type get(\n      const Tuple& tuple) {\n    return ::std::tr1::get<I>(tuple);\n  }\n};\ntemplate <typename TupleT>\nconst size_t TuplePolicy<TupleT>::tuple_size;\n#endif  // GTEST_HAS_TR1_TUPLE\n\n#if GTEST_HAS_STD_TUPLE_\ntemplate <typename... Types>\nstruct TuplePolicy< ::std::tuple<Types...> > {\n  typedef ::std::tuple<Types...> Tuple;\n  static const size_t tuple_size = ::std::tuple_size<Tuple>::value;\n\n  template <size_t I>\n  struct tuple_element : ::std::tuple_element<I, Tuple> {};\n\n  template <size_t I>\n  static const typename ::std::tuple_element<I, Tuple>::type& get(\n      const Tuple& tuple) {\n    return ::std::get<I>(tuple);\n  }\n};\ntemplate <typename... Types>\nconst size_t TuplePolicy< ::std::tuple<Types...> >::tuple_size;\n#endif  // GTEST_HAS_STD_TUPLE_\n\n#if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_\n// This helper template allows PrintTo() for tuples and\n// UniversalTersePrintTupleFieldsToStrings() to be defined by\n// induction on the number of tuple fields.  The idea is that\n// TuplePrefixPrinter<N>::PrintPrefixTo(t, os) prints the first N\n// fields in tuple t, and can be defined in terms of\n// TuplePrefixPrinter<N - 1>.\n//\n// The inductive case.\ntemplate <size_t N>\nstruct TuplePrefixPrinter {\n  // Prints the first N fields of a tuple.\n  template <typename Tuple>\n  static void PrintPrefixTo(const Tuple& t, ::std::ostream* os) {\n    TuplePrefixPrinter<N - 1>::PrintPrefixTo(t, os);\n    GTEST_INTENTIONAL_CONST_COND_PUSH_()\n    if (N > 1) {\n    GTEST_INTENTIONAL_CONST_COND_POP_()\n      *os << \", \";\n    }\n    UniversalPrinter<\n        typename TuplePolicy<Tuple>::template tuple_element<N - 1>::type>\n        ::Print(TuplePolicy<Tuple>::template get<N - 1>(t), os);\n  }\n\n  // Tersely prints the first N fields of a tuple to a string vector,\n  // one element for each field.\n  template <typename Tuple>\n  static void TersePrintPrefixToStrings(const Tuple& t, Strings* strings) {\n    TuplePrefixPrinter<N - 1>::TersePrintPrefixToStrings(t, strings);\n    ::std::stringstream ss;\n    UniversalTersePrint(TuplePolicy<Tuple>::template get<N - 1>(t), &ss);\n    strings->push_back(ss.str());\n  }\n};\n\n// Base case.\ntemplate <>\nstruct TuplePrefixPrinter<0> {\n  template <typename Tuple>\n  static void PrintPrefixTo(const Tuple&, ::std::ostream*) {}\n\n  template <typename Tuple>\n  static void TersePrintPrefixToStrings(const Tuple&, Strings*) {}\n};\n\n// Helper function for printing a tuple.\n// Tuple must be either std::tr1::tuple or std::tuple type.\ntemplate <typename Tuple>\nvoid PrintTupleTo(const Tuple& t, ::std::ostream* os) {\n  *os << \"(\";\n  TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::PrintPrefixTo(t, os);\n  *os << \")\";\n}\n\n// Prints the fields of a tuple tersely to a string vector, one\n// element for each field.  See the comment before\n// UniversalTersePrint() for how we define \"tersely\".\ntemplate <typename Tuple>\nStrings UniversalTersePrintTupleFieldsToStrings(const Tuple& value) {\n  Strings result;\n  TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::\n      TersePrintPrefixToStrings(value, &result);\n  return result;\n}\n#endif  // GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_\n\n}  // namespace internal\n\ntemplate <typename T>\n::std::string PrintToString(const T& value) {\n  ::std::stringstream ss;\n  internal::UniversalTersePrinter<T>::Print(value, &ss);\n  return ss.str();\n}\n\n}  // namespace testing\n\n// Include any custom printer added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gtest/internal/custom/gtest-printers.h\"\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-test-part.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: mheule@google.com (Markus Heule)\n//\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n#define GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n\n#include <iosfwd>\n#include <vector>\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n\nnamespace testing {\n\n// A copyable object representing the result of a test part (i.e. an\n// assertion or an explicit FAIL(), ADD_FAILURE(), or SUCCESS()).\n//\n// Don't inherit from TestPartResult as its destructor is not virtual.\nclass GTEST_API_ TestPartResult {\n public:\n  // The possible outcomes of a test part (i.e. an assertion or an\n  // explicit SUCCEED(), FAIL(), or ADD_FAILURE()).\n  enum Type {\n    kSuccess,          // Succeeded.\n    kNonFatalFailure,  // Failed but the test can continue.\n    kFatalFailure      // Failed and the test should be terminated.\n  };\n\n  // C'tor.  TestPartResult does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestPartResult object.\n  TestPartResult(Type a_type,\n                 const char* a_file_name,\n                 int a_line_number,\n                 const char* a_message)\n      : type_(a_type),\n        file_name_(a_file_name == NULL ? \"\" : a_file_name),\n        line_number_(a_line_number),\n        summary_(ExtractSummary(a_message)),\n        message_(a_message) {\n  }\n\n  // Gets the outcome of the test part.\n  Type type() const { return type_; }\n\n  // Gets the name of the source file where the test part took place, or\n  // NULL if it's unknown.\n  const char* file_name() const {\n    return file_name_.empty() ? NULL : file_name_.c_str();\n  }\n\n  // Gets the line in the source file where the test part took place,\n  // or -1 if it's unknown.\n  int line_number() const { return line_number_; }\n\n  // Gets the summary of the failure message.\n  const char* summary() const { return summary_.c_str(); }\n\n  // Gets the message associated with the test part.\n  const char* message() const { return message_.c_str(); }\n\n  // Returns true iff the test part passed.\n  bool passed() const { return type_ == kSuccess; }\n\n  // Returns true iff the test part failed.\n  bool failed() const { return type_ != kSuccess; }\n\n  // Returns true iff the test part non-fatally failed.\n  bool nonfatally_failed() const { return type_ == kNonFatalFailure; }\n\n  // Returns true iff the test part fatally failed.\n  bool fatally_failed() const { return type_ == kFatalFailure; }\n\n private:\n  Type type_;\n\n  // Gets the summary of the failure message by omitting the stack\n  // trace in it.\n  static std::string ExtractSummary(const char* message);\n\n  // The name of the source file where the test part took place, or\n  // \"\" if the source file is unknown.\n  std::string file_name_;\n  // The line in the source file where the test part took place, or -1\n  // if the line number is unknown.\n  int line_number_;\n  std::string summary_;  // The test failure summary.\n  std::string message_;  // The test failure message.\n};\n\n// Prints a TestPartResult object.\nstd::ostream& operator<<(std::ostream& os, const TestPartResult& result);\n\n// An array of TestPartResult objects.\n//\n// Don't inherit from TestPartResultArray as its destructor is not\n// virtual.\nclass GTEST_API_ TestPartResultArray {\n public:\n  TestPartResultArray() {}\n\n  // Appends the given TestPartResult to the array.\n  void Append(const TestPartResult& result);\n\n  // Returns the TestPartResult at the given index (0-based).\n  const TestPartResult& GetTestPartResult(int index) const;\n\n  // Returns the number of TestPartResult objects in the array.\n  int size() const;\n\n private:\n  std::vector<TestPartResult> array_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestPartResultArray);\n};\n\n// This interface knows how to report a test part result.\nclass TestPartResultReporterInterface {\n public:\n  virtual ~TestPartResultReporterInterface() {}\n\n  virtual void ReportTestPartResult(const TestPartResult& result) = 0;\n};\n\nnamespace internal {\n\n// This helper class is used by {ASSERT|EXPECT}_NO_FATAL_FAILURE to check if a\n// statement generates new fatal failures. To do so it registers itself as the\n// current test part result reporter. Besides checking if fatal failures were\n// reported, it only delegates the reporting to the former result reporter.\n// The original result reporter is restored in the destructor.\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nclass GTEST_API_ HasNewFatalFailureHelper\n    : public TestPartResultReporterInterface {\n public:\n  HasNewFatalFailureHelper();\n  virtual ~HasNewFatalFailureHelper();\n  virtual void ReportTestPartResult(const TestPartResult& result);\n  bool has_new_fatal_failure() const { return has_new_fatal_failure_; }\n private:\n  bool has_new_fatal_failure_;\n  TestPartResultReporterInterface* original_reporter_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(HasNewFatalFailureHelper);\n};\n\n}  // namespace internal\n\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-typed-test.h", "content": "// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_\n\n// This header implements typed tests and type-parameterized tests.\n\n// Typed (aka type-driven) tests repeat the same test for types in a\n// list.  You must know which types you want to test with when writing\n// typed tests. Here's how you do it:\n\n#if 0\n\n// First, define a fixture class template.  It should be parameterized\n// by a type.  Remember to derive it from testing::Test.\ntemplate <typename T>\nclass FooTest : public testing::Test {\n public:\n  ...\n  typedef std::list<T> List;\n  static T shared_;\n  T value_;\n};\n\n// Next, associate a list of types with the test case, which will be\n// repeated for each type in the list.  The typedef is necessary for\n// the macro to parse correctly.\ntypedef testing::Types<char, int, unsigned int> MyTypes;\nTYPED_TEST_CASE(FooTest, MyTypes);\n\n// If the type list contains only one type, you can write that type\n// directly without Types<...>:\n//   TYPED_TEST_CASE(FooTest, int);\n\n// Then, use TYPED_TEST() instead of TEST_F() to define as many typed\n// tests for this test case as you want.\nTYPED_TEST(FooTest, DoesBlah) {\n  // Inside a test, refer to TypeParam to get the type parameter.\n  // Since we are inside a derived class template, C++ requires use to\n  // visit the members of FooTest via 'this'.\n  TypeParam n = this->value_;\n\n  // To visit static members of the fixture, add the TestFixture::\n  // prefix.\n  n += TestFixture::shared_;\n\n  // To refer to typedefs in the fixture, add the \"typename\n  // TestFixture::\" prefix.\n  typename TestFixture::List values;\n  values.push_back(n);\n  ...\n}\n\nTYPED_TEST(FooTest, HasPropertyA) { ... }\n\n#endif  // 0\n\n// Type-parameterized tests are abstract test patterns parameterized\n// by a type.  Compared with typed tests, type-parameterized tests\n// allow you to define the test pattern without knowing what the type\n// parameters are.  The defined pattern can be instantiated with\n// different types any number of times, in any number of translation\n// units.\n//\n// If you are designing an interface or concept, you can define a\n// suite of type-parameterized tests to verify properties that any\n// valid implementation of the interface/concept should have.  Then,\n// each implementation can easily instantiate the test suite to verify\n// that it conforms to the requirements, without having to write\n// similar tests repeatedly.  Here's an example:\n\n#if 0\n\n// First, define a fixture class template.  It should be parameterized\n// by a type.  Remember to derive it from testing::Test.\ntemplate <typename T>\nclass FooTest : public testing::Test {\n  ...\n};\n\n// Next, declare that you will define a type-parameterized test case\n// (the _P suffix is for \"parameterized\" or \"pattern\", whichever you\n// prefer):\nTYPED_TEST_CASE_P(FooTest);\n\n// Then, use TYPED_TEST_P() to define as many type-parameterized tests\n// for this type-parameterized test case as you want.\nTYPED_TEST_P(FooTest, DoesBlah) {\n  // Inside a test, refer to TypeParam to get the type parameter.\n  TypeParam n = 0;\n  ...\n}\n\nTYPED_TEST_P(FooTest, HasPropertyA) { ... }\n\n// Now the tricky part: you need to register all test patterns before\n// you can instantiate them.  The first argument of the macro is the\n// test case name; the rest are the names of the tests in this test\n// case.\nREGISTER_TYPED_TEST_CASE_P(FooTest,\n                           DoesBlah, HasPropertyA);\n\n// Finally, you are free to instantiate the pattern with the types you\n// want.  If you put the above code in a header file, you can #include\n// it in multiple C++ source files and instantiate it multiple times.\n//\n// To distinguish different instances of the pattern, the first\n// argument to the INSTANTIATE_* macro is a prefix that will be added\n// to the actual test case name.  Remember to pick unique prefixes for\n// different instances.\ntypedef testing::Types<char, int, unsigned int> MyTypes;\nINSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);\n\n// If the type list contains only one type, you can write that type\n// directly without Types<...>:\n//   INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, int);\n\n#endif  // 0\n\n#include \"gtest/internal/gtest-port.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Implements typed tests.\n\n#if GTEST_HAS_TYPED_TEST\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Expands to the name of the typedef for the type parameters of the\n// given test case.\n# define GTEST_TYPE_PARAMS_(TestCaseName) gtest_type_params_##TestCaseName##_\n\n// The 'Types' template argument below must have spaces around it\n// since some compilers may choke on '>>' when passing a template\n// instance (e.g. Types<int>)\n# define TYPED_TEST_CASE(CaseName, Types) \\\n  typedef ::testing::internal::TypeList< Types >::type \\\n      GTEST_TYPE_PARAMS_(CaseName)\n\n# define TYPED_TEST(CaseName, TestName) \\\n  template <typename gtest_TypeParam_> \\\n  class GTEST_TEST_CLASS_NAME_(CaseName, TestName) \\\n      : public CaseName<gtest_TypeParam_> { \\\n   private: \\\n    typedef CaseName<gtest_TypeParam_> TestFixture; \\\n    typedef gtest_TypeParam_ TypeParam; \\\n    virtual void TestBody(); \\\n  }; \\\n  bool gtest_##CaseName##_##TestName##_registered_ GTEST_ATTRIBUTE_UNUSED_ = \\\n      ::testing::internal::TypeParameterizedTest< \\\n          CaseName, \\\n          ::testing::internal::TemplateSel< \\\n              GTEST_TEST_CLASS_NAME_(CaseName, TestName)>, \\\n          GTEST_TYPE_PARAMS_(CaseName)>::Register(\\\n              \"\", ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n              #CaseName, #TestName, 0); \\\n  template <typename gtest_TypeParam_> \\\n  void GTEST_TEST_CLASS_NAME_(CaseName, TestName)<gtest_TypeParam_>::TestBody()\n\n#endif  // GTEST_HAS_TYPED_TEST\n\n// Implements type-parameterized tests.\n\n#if GTEST_HAS_TYPED_TEST_P\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Expands to the namespace name that the type-parameterized tests for\n// the given type-parameterized test case are defined in.  The exact\n// name of the namespace is subject to change without notice.\n# define GTEST_CASE_NAMESPACE_(TestCaseName) \\\n  gtest_case_##TestCaseName##_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Expands to the name of the variable used to remember the names of\n// the defined tests in the given test case.\n# define GTEST_TYPED_TEST_CASE_P_STATE_(TestCaseName) \\\n  gtest_typed_test_case_p_state_##TestCaseName##_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE DIRECTLY.\n//\n// Expands to the name of the variable used to remember the names of\n// the registered tests in the given test case.\n# define GTEST_REGISTERED_TEST_NAMES_(TestCaseName) \\\n  gtest_registered_test_names_##TestCaseName##_\n\n// The variables defined in the type-parameterized test macros are\n// static as typically these macros are used in a .h file that can be\n// #included in multiple translation units linked together.\n# define TYPED_TEST_CASE_P(CaseName) \\\n  static ::testing::internal::TypedTestCasePState \\\n      GTEST_TYPED_TEST_CASE_P_STATE_(CaseName)\n\n# define TYPED_TEST_P(CaseName, TestName) \\\n  namespace GTEST_CASE_NAMESPACE_(CaseName) { \\\n  template <typename gtest_TypeParam_> \\\n  class TestName : public CaseName<gtest_TypeParam_> { \\\n   private: \\\n    typedef CaseName<gtest_TypeParam_> TestFixture; \\\n    typedef gtest_TypeParam_ TypeParam; \\\n    virtual void TestBody(); \\\n  }; \\\n  static bool gtest_##TestName##_defined_ GTEST_ATTRIBUTE_UNUSED_ = \\\n      GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).AddTestName(\\\n          __FILE__, __LINE__, #CaseName, #TestName); \\\n  } \\\n  template <typename gtest_TypeParam_> \\\n  void GTEST_CASE_NAMESPACE_(CaseName)::TestName<gtest_TypeParam_>::TestBody()\n\n# define REGISTER_TYPED_TEST_CASE_P(CaseName, ...) \\\n  namespace GTEST_CASE_NAMESPACE_(CaseName) { \\\n  typedef ::testing::internal::Templates<__VA_ARGS__>::type gtest_AllTests_; \\\n  } \\\n  static const char* const GTEST_REGISTERED_TEST_NAMES_(CaseName) = \\\n      GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).VerifyRegisteredTestNames(\\\n          __FILE__, __LINE__, #__VA_ARGS__)\n\n// The 'Types' template argument below must have spaces around it\n// since some compilers may choke on '>>' when passing a template\n// instance (e.g. Types<int>)\n# define INSTANTIATE_TYPED_TEST_CASE_P(Prefix, CaseName, Types) \\\n  bool gtest_##Prefix##_##CaseName GTEST_ATTRIBUTE_UNUSED_ = \\\n      ::testing::internal::TypeParameterizedTestCase<CaseName, \\\n          GTEST_CASE_NAMESPACE_(CaseName)::gtest_AllTests_, \\\n          ::testing::internal::TypeList< Types >::type>::Register(\\\n              #Prefix, \\\n              ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n              &GTEST_TYPED_TEST_CASE_P_STATE_(CaseName), \\\n              #CaseName, GTEST_REGISTERED_TEST_NAMES_(CaseName))\n\n#endif  // GTEST_HAS_TYPED_TEST_P\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais' (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_H_\n\n#include <limits>\n#include <ostream>\n#include <vector>\n\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/gtest-death-test.h\"\n#include \"gtest/gtest-message.h\"\n#include \"gtest/gtest-param-test.h\"\n#include \"gtest/gtest-printers.h\"\n#include \"gtest/gtest_prod.h\"\n#include \"gtest/gtest-test-part.h\"\n#include \"gtest/gtest-typed-test.h\"\n\n// Depending on the platform, different string classes are available.\n// On Linux, in addition to ::std::string, Google also makes use of\n// class ::string, which has the same interface as ::std::string, but\n// has a different implementation.\n//\n// You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that\n// ::string is available AND is a distinct type to ::std::string, or\n// define it to 0 to indicate otherwise.\n//\n// If ::std::string and ::string are the same class on your platform\n// due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.\n//\n// If you do not define GTEST_HAS_GLOBAL_STRING, it is defined\n// heuristically.\n\nnamespace testing {\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// \"yes\" to enable colors, \"no\" (disable colors), or \"auto\" (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests' order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a \"host:port\" string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string& message);\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don't forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestCase;\nclass TestInfo;\nclass UnitTest;\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn't successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() << n << \" is even\";\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         << \"Expected: \" << expr << \" is even\\n  Actual: it's \" << n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it's 5\n//\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult& other);\n\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult's copy constructor to be used.\n  template <typename T>\n  explicit AssertionResult(\n      const T& success,\n      typename internal::EnableIf<\n          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*\n          /*enabler*/ = NULL)\n      : success_(success) {}\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  // Assignment operator.\n  AssertionResult& operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true iff the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate's outcome doesn't match the\n  // assertion's expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_.get() != NULL ?  message_->c_str() : \"\";\n  }\n  // TODO(vladl@google.com): Remove this after making sure no clients use it.\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template <typename T> AssertionResult& operator<<(const T& value) {\n    AppendMessage(Message() << value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult& operator<<(\n      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {\n    AppendMessage(Message() << basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message& a_message) {\n    if (message_.get() == NULL)\n      message_.reset(new ::std::string);\n    message_->append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult& other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate's outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  internal::scoped_ptr< ::std::string> message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() << msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message& msg);\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestCases, and\n// each TestCase contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don't need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // Defines types for pointers to functions that set up and tear down\n  // a test case.\n  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;\n  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;\n\n  // The d'tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::SetUpTestCase() before running the first\n  // test in test case Foo.  Hence a sub-class can define its own\n  // SetUpTestCase() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestCase() {}\n\n  // Tears down the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::TearDownTestCase() after running the last\n  // test in test case Foo.  Hence a sub-class can define its own\n  // TearDownTestCase() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestCase() {}\n\n  // Returns true iff the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true iff the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true iff the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test case, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test case.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the <testcase> element.  Properties recorded from fixture's\n  // SetUpTestCase or TearDownTestCase are logged as attributes of the\n  // corresponding <testsuite> element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the <testsuites> element.\n  static void RecordProperty(const std::string& key, const std::string& value);\n  static void RecordProperty(const std::string& key, int value);\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true iff the current test has the same fixture class as\n  // the first test in the current test case.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user's\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user's test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n\n  // We disallow copying Tests.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Test);\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don't inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C'tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string& a_key, const std::string& a_value) :\n    key_(a_key), value_(a_value) {\n  }\n\n  // Gets the user supplied key.\n  const char* key() const {\n    return key_.c_str();\n  }\n\n  // Gets the user supplied value.\n  const char* value() const {\n    return value_.c_str();\n  }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string& new_value) {\n    value_ = new_value;\n  }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D'tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true iff the test passed (i.e. no test part failed).\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test failed.\n  bool Failed() const;\n\n  // Returns true iff the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true iff the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test part result among all the results. i can range\n  // from 0 to test_property_count() - 1. If i is not in that range, aborts\n  // the program.\n  const TestPartResult& GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty& GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestCase;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector<TestPartResult>& test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector<TestProperty>& test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string& xml_element,\n                      const TestProperty& test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testcase tags.  Returns true if the property is valid.\n  // TODO(russr): Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string& xml_element,\n                                   const TestProperty& test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult& test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properites_mutex_;\n\n  // The vector of TestPartResults\n  std::vector<TestPartResult> test_part_results_;\n  // The vector of TestProperties\n  std::vector<TestProperty> test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult);\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test case name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don't inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test case name.\n  const char* test_case_name() const { return test_case_name_.c_str(); }\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_.get() != NULL)\n      return value_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test case Foo is defined as\n  // \"Foo.Bar\".  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a '-' and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character 'A' or starts with \"Foo.\".\n  bool should_run() const { return should_run_; }\n\n  // Returns true iff this test will appear in the XML report.\n  bool is_reportable() const {\n    // For now, the XML report includes all tests matching the filter.\n    // In the future, we may trim tests that are excluded because of\n    // sharding.\n    return matches_filter_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &result_; }\n\n private:\n#if GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestCase;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      const char* test_case_name,\n      const char* name,\n      const char* type_param,\n      const char* value_param,\n      internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id,\n      Test::SetUpTestCaseFunc set_up_tc,\n      Test::TearDownTestCaseFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(const std::string& test_case_name,\n           const std::string& name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info->result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_case_name_;     // Test case name\n  const std::string name_;               // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const internal::scoped_ptr<const ::std::string> value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;   // ID of the test fixture class\n  bool should_run_;                 // True iff this test should run\n  bool is_disabled_;                // True iff this test is disabled\n  bool matches_filter_;             // True if this test matches the\n                                    // user-specified filter.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo);\n};\n\n// A test case, which consists of a vector of TestInfos.\n//\n// TestCase is not copyable.\nclass GTEST_API_ TestCase {\n public:\n  // Creates a TestCase with the given name.\n  //\n  // TestCase does NOT have a default constructor.  Always use this\n  // constructor to create a TestCase object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test case\n  //   a_type_param: the name of the test's type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test case\n  //   tear_down_tc: pointer to the function that tears down the test case\n  TestCase(const char* name, const char* a_type_param,\n           Test::SetUpTestCaseFunc set_up_tc,\n           Test::TearDownTestCaseFunc tear_down_tc);\n\n  // Destructor of TestCase.\n  virtual ~TestCase();\n\n  // Gets the name of the TestCase.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test case.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns true if any test in this test case should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test case.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests in this test case.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test case.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test case that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test case.\n  int total_test_count() const;\n\n  // Returns true iff the test case passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test case failed.\n  bool Failed() const { return failed_test_count() > 0; }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestCase and TearDownTestCase.\n  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestCase.\n  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestCase.\n  const std::vector<TestInfo*>& test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test case.  Will delete the TestInfo upon\n  // destruction of the TestCase object.\n  void AddTestInfo(TestInfo * test_info);\n\n  // Clears the results of all tests in this test case.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test case.\n  static void ClearTestCaseResult(TestCase* test_case) {\n    test_case->ClearResult();\n  }\n\n  // Runs every test in this TestCase.\n  void Run();\n\n  // Runs SetUpTestCase() for this TestCase.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestCase().\n  void RunSetUpTestCase() { (*set_up_tc_)(); }\n\n  // Runs TearDownTestCase() for this TestCase.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestCase().\n  void RunTearDownTestCase() { (*tear_down_tc_)(); }\n\n  // Returns true iff test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Passed();\n  }\n\n  // Returns true iff test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Failed();\n  }\n\n  // Returns true iff the test is disabled and will be reported in the XML\n  // report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info->is_reportable() && test_info->is_disabled_;\n  }\n\n  // Returns true iff test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info->is_disabled_;\n  }\n\n  // Returns true iff this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info->is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info->should_run();\n  }\n\n  // Shuffles the tests in this test case.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test case.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector<TestInfo*> test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector<int> test_indices_;\n  // Pointer to the function that sets up the test case.\n  Test::SetUpTestCaseFunc set_up_tc_;\n  // Pointer to the function that tears down the test case.\n  Test::TearDownTestCaseFunc tear_down_tc_;\n  // True iff any test in this test case should run.\n  bool should_run_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestCase and\n  // TearDownTestCase.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestCases.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase);\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d'tor is virtual as we need to subclass Environment.\n  virtual ~Environment() {}\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n};\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() {}\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest& unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;\n\n  // Fired before the test case starts.\n  virtual void OnTestCaseStart(const TestCase& test_case) = 0;\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo& test_info) = 0;\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo& test_info) = 0;\n\n  // Fired after the test case ends.\n  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest& unit_test,\n                                  int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  virtual void OnTestProgramStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationStart(const UnitTest& /*unit_test*/,\n                                    int /*iteration*/) {}\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestCaseStart(const TestCase& /*test_case*/) {}\n  virtual void OnTestStart(const TestInfo& /*test_info*/) {}\n  virtual void OnTestPartResult(const TestPartResult& /*test_part_result*/) {}\n  virtual void OnTestEnd(const TestInfo& /*test_info*/) {}\n  virtual void OnTestCaseEnd(const TestCase& /*test_case*/) {}\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationEnd(const UnitTest& /*unit_test*/,\n                                  int /*iteration*/) {}\n  virtual void OnTestProgramEnd(const UnitTest& /*unit_test*/) {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller's responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n private:\n  friend class TestCase;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n  void SuppressEventForwarding();\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners);\n};\n\n// A UnitTest consists of a vector of TestCases.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestCase object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestCase* current_test_case() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the TestInfo object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n#if GTEST_HAS_PARAM_TEST\n  // Returns the ParameterizedTestCaseRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n#endif  // GTEST_HAS_PARAM_TEST\n\n  // Gets the number of successful test cases.\n  int successful_test_case_count() const;\n\n  // Gets the number of failed test cases.\n  int failed_test_case_count() const;\n\n  // Gets the number of all test cases.\n  int total_test_case_count() const;\n\n  // Gets the number of all test cases that contain at least one test\n  // that should run.\n  int test_case_to_run_count() const;\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true iff the unit test passed (i.e. all test cases passed).\n  bool Passed() const;\n\n  // Returns true iff the unit test failed (i.e. some test case failed\n  // or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  const TestCase* GetTestCase(int i) const;\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test cases.\n  const TestResult& ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners& listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name,\n                         int line_number,\n                         const std::string& message,\n                         const std::string& os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestCase's ad_hoc_test_result_ when invoked\n  // from SetUpTestCase or TearDownTestCase, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string& key, const std::string& value);\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  TestCase* GetMutableTestCase(int i);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and funcions are friends as they need to access private\n  // members of UnitTest.\n  friend class Test;\n  friend class internal::AssertHelper;\n  friend class internal::ScopedTrace;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type,\n      const std::string& message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D'tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo& trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don't mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest);\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn't guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()->AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression,\n                                   const T1& lhs, const T2& rhs) {\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs),\n                   false);\n}\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression,\n                            const T1& lhs,\n                            const T2& rhs) {\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 /* signed/unsigned mismatch */)\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\n// With this overloaded version, we allow anonymous enums to be used\n// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums\n// can be implicitly cast to BiggestInt.\nGTEST_API_ AssertionResult CmpHelperEQ(const char* lhs_expression,\n                                       const char* rhs_expression,\n                                       BiggestInt lhs,\n                                       BiggestInt rhs);\n\n// The helper class for {ASSERT|EXPECT}_EQ.  The template argument\n// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()\n// is a null pointer literal.  The following default implementation is\n// for lhs_is_null_literal being false.\ntemplate <bool lhs_is_null_literal>\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template <typename T1, typename T2>\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 const T1& lhs,\n                                 const T2& rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n};\n\n// This specialization is used when the first argument to ASSERT_EQ()\n// is a null pointer literal, like NULL, false, or 0.\ntemplate <>\nclass EqHelper<true> {\n public:\n  // We define two overloaded versions of Compare().  The first\n  // version will be picked when the second argument to ASSERT_EQ() is\n  // NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or\n  // EXPECT_EQ(false, a_bool).\n  template <typename T1, typename T2>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      const T1& lhs,\n      const T2& rhs,\n      // The following line prevents this overload from being considered if T2\n      // is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)\n      // expands to Compare(\"\", \"\", NULL, my_ptr), which requires a conversion\n      // to match the Secret* in the other overload, which would otherwise make\n      // this template match better.\n      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // This version will be picked when the second argument to ASSERT_EQ() is a\n  // pointer, e.g. ASSERT_EQ(NULL, a_pointer).\n  template <typename T>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      // We used to have a second template parameter instead of Secret*.  That\n      // template parameter would deduce to 'long', making this a better match\n      // than the first overload even without the first overload's EnableIf.\n      // Unfortunately, gcc with -Wconversion-null warns when \"passing NULL to\n      // non-pointer argument\" (even a deduced integral argument), so the old\n      // implementation caused warnings in user code.\n      Secret* /* lhs (NULL) */,\n      T* rhs) {\n    // We already know that 'lhs' is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression,\n                       static_cast<T*>(NULL), rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1& val1, const T2& val2,\n                                   const char* op) {\n  return AssertionFailure()\n         << \"Expected: (\" << expr1 << \") \" << op << \" (\" << expr2\n         << \"), actual: \" << FormatForComparisonFailureMessage(val1, val2)\n         << \" vs \" << FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// For each templatized helper function, we also define an overloaded\n// version for BiggestInt in order to reduce code bloat and allow\n// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled\n// with gcc 4.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)\\\ntemplate <typename T1, typename T2>\\\nAssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                   const T1& val1, const T2& val2) {\\\n  if (val1 op val2) {\\\n    return AssertionSuccess();\\\n  } else {\\\n    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\\n  }\\\n}\\\nGTEST_API_ AssertionResult CmpHelper##op_name(\\\n    const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=);\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, <=);\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, <);\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, >=);\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, >);\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename RawType>\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value,\n                                         RawType rhs_value) {\n  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << rhs_value;\n\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   StringStreamToString(&lhs_ss),\n                   StringStreamToString(&rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1,\n                                                double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type,\n               const char* file,\n               int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message& message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t,\n                     const char* srcfile,\n                     int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) { }\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData);\n  };\n\n  AssertHelperData* const data_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);\n};\n\n}  // namespace internal\n\n#if GTEST_HAS_PARAM_TEST\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), and Combine().\n//\n// class FooTest : public ::testing::TestWithParam<int> {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual ~FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void SetUp() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void TearDown {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate <typename T>\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() {}\n\n  // The current parameter value. Is also available in the test fixture's\n  // constructor. This member function is non-static, even though it only\n  // references static data, to reduce the opportunity for incorrect uses\n  // like writing 'WithParamInterface<bool>::GetParam()' for a test that\n  // uses a fixture whose parameter type is int.\n  const ParamType& GetParam() const {\n    GTEST_CHECK_(parameter_ != NULL)\n        << \"GetParam() can only be called inside a value-parameterized test \"\n        << \"-- did you intend to write TEST_P instead of TEST_F?\";\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) {\n    parameter_ = parameter;\n  }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface<T> and Test.\n  template <class TestClass> friend class internal::ParameterizedTestFactory;\n};\n\ntemplate <typename T>\nconst T* WithParamInterface<T>::parameter_ = NULL;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate <typename T>\nclass TestWithParam : public Test, public WithParamInterface<T> {\n};\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n// Macros for indicating success/failure in test code.\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn't automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(\"Failed\")\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line) \\\n  GTEST_MESSAGE_AT_(file, line, \"Failed\", \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(\"Failed\")\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_FAIL\n# define FAIL() GTEST_FAIL()\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(\"Succeeded\")\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_SUCCEED\n# define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn't throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define EXPECT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define EXPECT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_FATAL_FAILURE_)\n#define ASSERT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Includes the auto-generated header that implements a family of\n// generic predicate assertion macros.\n#include \"gtest/gtest_pred_impl.h\"\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 < v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 <= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 > v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 >= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By \"compatible\" we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(5, Foo());\n//   EXPECT_EQ(NULL, a_pointer);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) << \"There is no record left.\";\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users' own code.\n\n#if !GTEST_DONT_DEFINE_ASSERT_EQ\n# define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_NE\n# define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LE\n# define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LT\n# define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GE\n# define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GT\n# define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don't depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)\\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)\\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n\n#if GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n# define EXPECT_HRESULT_SUCCEEDED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define ASSERT_HRESULT_SUCCEEDED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define EXPECT_HRESULT_FAILED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n# define ASSERT_HRESULT_FAILED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn't generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) << \"Process() failed\";\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n#define SCOPED_TRACE(message) \\\n  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\\n    __FILE__, __LINE__, ::testing::Message() << (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are\n// the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq<T1, T2> by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq<T1, T2>() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template <typename T> class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq<int, T>(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo<bool> foo; }\n//\n// will NOT generate a compiler error, as Foo<bool>::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo<bool> foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate <typename T1, typename T2>\nbool StaticAssertTypeEq() {\n  (void)internal::StaticAssertTypeEqHelper<T1, T2>();\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test case, and the second\n// parameter is the name of the test within the test case.\n//\n// The convention is to end the test case name with \"Test\".  For\n// example, a test case for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId<\n// ::testing::Test>() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId<\n// ::testing::Test>() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId<>() from the Google Test\n// framework.\n#define GTEST_TEST(test_case_name, test_name)\\\n  GTEST_TEST_(test_case_name, test_name, \\\n              ::testing::Test, ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_TEST\n# define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test case name.  The second parameter is the\n// name of the test within the test case.\n//\n// A test fixture class must be declared earlier.  The user should put\n// his test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     virtual void SetUp() { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(0, a_.size());\n//     EXPECT_EQ(1, b_.size());\n//   }\n\n#define TEST_F(test_fixture, test_name)\\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId<test_fixture>())\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest().\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() {\n  return ::testing::UnitTest::GetInstance()->Run();\n}\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_pred_impl.h", "content": "// Copyright 2006, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// This file is AUTOMATICALLY GENERATED on 10/31/2011 by command\n// 'gen_gtest_pred_impl.py 5'.  DO NOT EDIT BY HAND!\n//\n// Implements a family of generic predicate assertion macros.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n\n// Makes sure this header is not included before gtest.h.\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n# error Do not include gtest_pred_impl.h directly.  Include gtest.h instead.\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n\n// This header implements a family of generic predicate assertion\n// macros:\n//\n//   ASSERT_PRED_FORMAT1(pred_format, v1)\n//   ASSERT_PRED_FORMAT2(pred_format, v1, v2)\n//   ...\n//\n// where pred_format is a function or functor that takes n (in the\n// case of ASSERT_PRED_FORMATn) values and their source expression\n// text, and returns a testing::AssertionResult.  See the definition\n// of ASSERT_EQ in gtest.h for an example.\n//\n// If you don't care about formatting, you can use the more\n// restrictive version:\n//\n//   ASSERT_PRED1(pred, v1)\n//   ASSERT_PRED2(pred, v1, v2)\n//   ...\n//\n// where pred is an n-ary function or functor that returns bool,\n// and the values v1, v2, ..., must support the << operator for\n// streaming to std::ostream.\n//\n// We also define the EXPECT_* variations.\n//\n// For now we only support predicates whose arity is at most 5.\n// Please email googletestframework@googlegroups.com if you need\n// support for higher arities.\n\n// GTEST_ASSERT_ is the basic statement to which all of the assertions\n// in this file reduce.  Don't use this in your code.\n\n#define GTEST_ASSERT_(expression, on_failure) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar = (expression)) \\\n    ; \\\n  else \\\n    on_failure(gtest_ar.failure_message())\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED1.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1>\nAssertionResult AssertPred1Helper(const char* pred_text,\n                                  const char* e1,\n                                  Pred pred,\n                                  const T1& v1) {\n  if (pred(v1)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT1.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT1_(pred_format, v1, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, v1), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED1.  Don't use\n// this in your code.\n#define GTEST_PRED1_(pred, v1, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred1Helper(#pred, \\\n                                             #v1, \\\n                                             pred, \\\n                                             v1), on_failure)\n\n// Unary predicate assertion macros.\n#define EXPECT_PRED_FORMAT1(pred_format, v1) \\\n  GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED1(pred, v1) \\\n  GTEST_PRED1_(pred, v1, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT1(pred_format, v1) \\\n  GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED1(pred, v1) \\\n  GTEST_PRED1_(pred, v1, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED2.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2>\nAssertionResult AssertPred2Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2) {\n  if (pred(v1, v2)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT2.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT2_(pred_format, v1, v2, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED2.  Don't use\n// this in your code.\n#define GTEST_PRED2_(pred, v1, v2, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred2Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2), on_failure)\n\n// Binary predicate assertion macros.\n#define EXPECT_PRED_FORMAT2(pred_format, v1, v2) \\\n  GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED2(pred, v1, v2) \\\n  GTEST_PRED2_(pred, v1, v2, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT2(pred_format, v1, v2) \\\n  GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED2(pred, v1, v2) \\\n  GTEST_PRED2_(pred, v1, v2, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED3.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3>\nAssertionResult AssertPred3Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3) {\n  if (pred(v1, v2, v3)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT3.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED3.  Don't use\n// this in your code.\n#define GTEST_PRED3_(pred, v1, v2, v3, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred3Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3), on_failure)\n\n// Ternary predicate assertion macros.\n#define EXPECT_PRED_FORMAT3(pred_format, v1, v2, v3) \\\n  GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED3(pred, v1, v2, v3) \\\n  GTEST_PRED3_(pred, v1, v2, v3, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT3(pred_format, v1, v2, v3) \\\n  GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED3(pred, v1, v2, v3) \\\n  GTEST_PRED3_(pred, v1, v2, v3, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED4.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4>\nAssertionResult AssertPred4Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4) {\n  if (pred(v1, v2, v3, v4)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT4.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, v1, v2, v3, v4), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED4.  Don't use\n// this in your code.\n#define GTEST_PRED4_(pred, v1, v2, v3, v4, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred4Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             #v4, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3, \\\n                                             v4), on_failure)\n\n// 4-ary predicate assertion macros.\n#define EXPECT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\\n  GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED4(pred, v1, v2, v3, v4) \\\n  GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\\n  GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED4(pred, v1, v2, v3, v4) \\\n  GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED5.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4,\n          typename T5>\nAssertionResult AssertPred5Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  const char* e5,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4,\n                                  const T5& v5) {\n  if (pred(v1, v2, v3, v4, v5)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \", \"\n                            << e5 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4\n                            << \"\\n\" << e5 << \" evaluates to \" << v5;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT5.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, #v5, v1, v2, v3, v4, v5), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED5.  Don't use\n// this in your code.\n#define GTEST_PRED5_(pred, v1, v2, v3, v4, v5, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred5Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             #v4, \\\n                                             #v5, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3, \\\n                                             v4, \\\n                                             v5), on_failure)\n\n// 5-ary predicate assertion macros.\n#define EXPECT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\\n  GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED5(pred, v1, v2, v3, v4, v5) \\\n  GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\\n  GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED5(pred, v1, v2, v3, v4, v5) \\\n  GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)\n\n\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_prod.h", "content": "// Copyright 2006, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// Google C++ Testing Framework definitions useful in production code.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PROD_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PROD_H_\n\n// When you need to test the private or protected members of a class,\n// use the FRIEND_TEST macro to declare your tests as friends of the\n// class.  For example:\n//\n// class MyClass {\n//  private:\n//   void MyMethod();\n//   FRIEND_TEST(MyClassTest, MyMethod);\n// };\n//\n// class MyClassTest : public testing::Test {\n//   // ...\n// };\n//\n// TEST_F(MyClassTest, MyMethod) {\n//   // Can call MyClass::MyMethod() here.\n// }\n\n#define FRIEND_TEST(test_case_name, test_name)\\\nfriend class test_case_name##_##test_name##_Test\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PROD_H_\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/gtest-port.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Injection point for custom user configurations.\n// The following macros can be defined:\n//\n//   Flag related macros:\n//     GTEST_FLAG(flag_name)\n//     GTEST_USE_OWN_FLAGFILE_FLAG_  - Define to 0 when the system provides its\n//                                     own flagfile flag parsing.\n//     GTEST_DECLARE_bool_(name)\n//     GTEST_DECLARE_int32_(name)\n//     GTEST_DECLARE_string_(name)\n//     GTEST_DEFINE_bool_(name, default_val, doc)\n//     GTEST_DEFINE_int32_(name, default_val, doc)\n//     GTEST_DEFINE_string_(name, default_val, doc)\n//\n//   Test filtering:\n//     GTEST_TEST_FILTER_ENV_VAR_ - The name of an environment variable that\n//                                  will be used if --GTEST_FLAG(test_filter)\n//                                  is not provided.\n//\n//   Logging:\n//     GTEST_LOG_(severity)\n//     GTEST_CHECK_(condition)\n//     Functions LogToStderr() and FlushInfoLog() have to be provided too.\n//\n//   Threading:\n//     GTEST_HAS_NOTIFICATION_ - Enabled if Notification is already provided.\n//     GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ - Enabled if Mutex and ThreadLocal are\n//                                         already provided.\n//     Must also provide GTEST_DECLARE_STATIC_MUTEX_(mutex) and\n//     GTEST_DEFINE_STATIC_MUTEX_(mutex)\n//\n//     GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n//     GTEST_LOCK_EXCLUDED_(locks)\n//\n// ** Custom implementation starts here **\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/gtest-printers.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// This file provides an injection point for custom printers in a local\n// installation of gTest.\n// It will be included from gtest-printers.h and the overrides in this file\n// will be visible to everyone.\n// See documentation at gtest/gtest-printers.h for details on how to define a\n// custom printer.\n//\n// ** Custom implementation starts here **\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_\n\n#if !GTEST_NO_LLVM_SUPPORT\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <ostream>\n// Printing of llvm String types.\n// gtest sees these as containers of char (they have nested iterator types),\n// so their operator<< is never considered unless we provide PrintTo().\n// PrintStringTo provides quotes and escaping, at the cost of a copy.\nnamespace llvm {\ninline void PrintTo(llvm::StringRef S, std::ostream *OS) {\n  *OS << ::testing::PrintToString(S.str());\n}\n// We need both SmallString<N> and SmallVectorImpl<char> overloads:\n//  - the SmallString<N> template is needed as overload resolution will\n//    instantiate generic PrintTo<T> rather than do derived-to-base conversion\n//  - but SmallVectorImpl<char> is sometimes the actual static type, in code\n//    that erases the small size\ntemplate <unsigned N>\ninline void PrintTo(const SmallString<N> &S, std::ostream *OS) {\n  *OS << ::testing::PrintToString(std::string(S.data(), S.size()));\n}\ninline void PrintTo(const SmallVectorImpl<char> &S, std::ostream *OS) {\n  *OS << ::testing::PrintToString(std::string(S.data(), S.size()));\n}\n} // namespace llvm\n#endif // !GTEST_NO_LLVM_SUPPORT\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/raw-ostream.h", "content": "//===-- raw-ostream.h - Support for printing using raw_ostream --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// This file is not part of gtest, but extends it to support LLVM libraries.\n// This is not a public API for testing - it's a detail of LLVM's gtest.\n//\n// gtest allows providing printers for custom types by defining operator<<.\n// In LLVM, operator<< usually takes llvm:raw_ostream& instead of std::ostream&.\n//\n// This file defines a template printable(V), which returns a version of V that\n// can be streamed into a std::ostream.\n//\n// This interface is chosen so that in the default case (printable(V) is V),\n// the main gtest code calls operator<<(OS, V) itself. gtest-printers carefully\n// controls the lookup to enable fallback printing (see testing::internal2).\n//===----------------------------------------------------------------------===//\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n\nnamespace llvm_gtest {\n// StreamSwitch is a trait that tells us how to stream a T into a std::ostream.\n// By default, we just stream the T directly. We'll specialize this later.\ntemplate <typename T, typename Enable = void> struct StreamSwitch {\n  static const T& printable(const T& V) { return V; }\n};\n\n// printable() returns a version of its argument that can be streamed into a\n// std::ostream. This may be the argument itself, or some other representation.\ntemplate <typename T> decltype(auto) printable(const T &V) {\n  // We delegate to the trait, to allow partial specialization.\n  return StreamSwitch<T>::printable(V);\n}\n} // namespace llvm_gtest\n\n// If raw_ostream support is enabled, we specialize for types with operator<<\n// that takes a raw_ostream.\n#if !GTEST_NO_LLVM_SUPPORT\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/raw_os_ostream.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <ostream>\nnamespace llvm_gtest {\n\n// The printable() of a raw_ostream-enabled type T is a RawStreamProxy<T>.\n// It uses raw_os_ostream to write the wrapped value to a std::ostream.\ntemplate <typename T>\nstruct RawStreamProxy {\n  const T& V;\n  friend std::ostream &operator<<(std::ostream &S, const RawStreamProxy<T> &V) {\n    llvm::raw_os_ostream OS(S);\n    OS << V.V;\n    return S;\n  }\n};\n\n// We enable raw_ostream treatment if `(raw_ostream&) << (const T&)` is valid.\n// We don't want implicit conversions on the RHS (e.g. to bool!), so \"consume\"\n// the possible conversion by passing something convertible to const T& instead.\ntemplate <typename T> struct ConvertibleTo { operator T(); };\ntemplate <typename T>\nstruct StreamSwitch<T, decltype((void)(std::declval<llvm::raw_ostream &>()\n                                       << ConvertibleTo<const T &>()))> {\n  static const RawStreamProxy<T> printable(const T &V) { return {V}; }\n};\n\n// llvm::Optional has a template operator<<, which means it will not accept any\n// implicit conversions, so we need to special-case it here.\ntemplate <typename T>\nstruct StreamSwitch<llvm::Optional<T>,\n                    decltype((void)(std::declval<llvm::raw_ostream &>()\n                                    << std::declval<llvm::Optional<T>>()))> {\n  static const RawStreamProxy<llvm::Optional<T>>\n  printable(const llvm::Optional<T> &V) {\n    return {V};\n  }\n};\n} // namespace llvm_gtest\n#endif  // !GTEST_NO_LLVM_SUPPORT\n\n#endif // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-death-test-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines internal utilities needed for implementing\n// death tests.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-internal.h\"\n\n#include <stdio.h>\n\nnamespace testing {\nnamespace internal {\n\nGTEST_DECLARE_string_(internal_run_death_test);\n\n// Names of the flags (needed for parsing Google Test flags).\nconst char kDeathTestStyleFlag[] = \"death_test_style\";\nconst char kDeathTestUseFork[] = \"death_test_use_fork\";\nconst char kInternalRunDeathTestFlag[] = \"internal_run_death_test\";\n\n#if GTEST_HAS_DEATH_TEST\n\n// DeathTest is a class that hides much of the complexity of the\n// GTEST_DEATH_TEST_ macro.  It is abstract; its static Create method\n// returns a concrete class that depends on the prevailing death test\n// style, as defined by the --gtest_death_test_style and/or\n// --gtest_internal_run_death_test flags.\n\n// In describing the results of death tests, these terms are used with\n// the corresponding definitions:\n//\n// exit status:  The integer exit information in the format specified\n//               by wait(2)\n// exit code:    The integer code passed to exit(3), _exit(2), or\n//               returned from main()\nclass GTEST_API_ DeathTest {\n public:\n  // Create returns false if there was an error determining the\n  // appropriate action to take for the current death test; for example,\n  // if the gtest_death_test_style flag is set to an invalid value.\n  // The LastMessage method will return a more detailed message in that\n  // case.  Otherwise, the DeathTest pointer pointed to by the \"test\"\n  // argument is set.  If the death test should be skipped, the pointer\n  // is set to NULL; otherwise, it is set to the address of a new concrete\n  // DeathTest object that controls the execution of the current test.\n  static bool Create(const char* statement, const RE* regex,\n                     const char* file, int line, DeathTest** test);\n  DeathTest();\n  virtual ~DeathTest() { }\n\n  // A helper class that aborts a death test when it's deleted.\n  class ReturnSentinel {\n   public:\n    explicit ReturnSentinel(DeathTest* test) : test_(test) { }\n    ~ReturnSentinel() { test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }\n   private:\n    DeathTest* const test_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ReturnSentinel);\n  } GTEST_ATTRIBUTE_UNUSED_;\n\n  // An enumeration of possible roles that may be taken when a death\n  // test is encountered.  EXECUTE means that the death test logic should\n  // be executed immediately.  OVERSEE means that the program should prepare\n  // the appropriate environment for a child process to execute the death\n  // test, then wait for it to complete.\n  enum TestRole { OVERSEE_TEST, EXECUTE_TEST };\n\n  // An enumeration of the three reasons that a test might be aborted.\n  enum AbortReason {\n    TEST_ENCOUNTERED_RETURN_STATEMENT,\n    TEST_THREW_EXCEPTION,\n    TEST_DID_NOT_DIE\n  };\n\n  // Assumes one of the above roles.\n  virtual TestRole AssumeRole() = 0;\n\n  // Waits for the death test to finish and returns its status.\n  virtual int Wait() = 0;\n\n  // Returns true if the death test passed; that is, the test process\n  // exited during the test, its exit status matches a user-supplied\n  // predicate, and its stderr output matches a user-supplied regular\n  // expression.\n  // The user-supplied predicate may be a macro expression rather\n  // than a function pointer or functor, or else Wait and Passed could\n  // be combined.\n  virtual bool Passed(bool exit_status_ok) = 0;\n\n  // Signals that the death test did not die as expected.\n  virtual void Abort(AbortReason reason) = 0;\n\n  // Returns a human-readable outcome message regarding the outcome of\n  // the last death test.\n  static const char* LastMessage();\n\n  static void set_last_death_test_message(const std::string& message);\n\n private:\n  // A string containing a description of the outcome of the last death test.\n  static std::string last_death_test_message_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DeathTest);\n};\n\n// Factory interface for death tests.  May be mocked out for testing.\nclass DeathTestFactory {\n public:\n  virtual ~DeathTestFactory() { }\n  virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test) = 0;\n};\n\n// A concrete DeathTestFactory implementation for normal use.\nclass DefaultDeathTestFactory : public DeathTestFactory {\n public:\n  virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test);\n};\n\n// Returns true if exit_status describes a process that was terminated\n// by a signal, or exited normally with a nonzero exit code.\nGTEST_API_ bool ExitedUnsuccessfully(int exit_status);\n\n// Traps C++ exceptions escaping statement and reports them as test\n// failures. Note that trapping SEH exceptions is not implemented here.\n# if GTEST_HAS_EXCEPTIONS\n#  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\\n  try { \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n  } catch (const ::std::exception& gtest_exception) { \\\n    fprintf(\\\n        stderr, \\\n        \"\\n%s: Caught std::exception-derived exception escaping the \" \\\n        \"death test statement. Exception message: %s\\n\", \\\n        ::testing::internal::FormatFileLocation(__FILE__, __LINE__).c_str(), \\\n        gtest_exception.what()); \\\n    fflush(stderr); \\\n    death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\n  } catch (...) { \\\n    death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\n  }\n\n# else\n#  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\\n  GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)\n\n# endif\n\n// This macro is for implementing ASSERT_DEATH*, EXPECT_DEATH*,\n// ASSERT_EXIT*, and EXPECT_EXIT*.\n# define GTEST_DEATH_TEST_(statement, predicate, regex, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    const ::testing::internal::RE& gtest_regex = (regex); \\\n    ::testing::internal::DeathTest* gtest_dt; \\\n    if (!::testing::internal::DeathTest::Create(#statement, &gtest_regex, \\\n        __FILE__, __LINE__, &gtest_dt)) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \\\n    } \\\n    if (gtest_dt != NULL) { \\\n      ::testing::internal::scoped_ptr< ::testing::internal::DeathTest> \\\n          gtest_dt_ptr(gtest_dt); \\\n      switch (gtest_dt->AssumeRole()) { \\\n        case ::testing::internal::DeathTest::OVERSEE_TEST: \\\n          if (!gtest_dt->Passed(predicate(gtest_dt->Wait()))) { \\\n            goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \\\n          } \\\n          break; \\\n        case ::testing::internal::DeathTest::EXECUTE_TEST: { \\\n          ::testing::internal::DeathTest::ReturnSentinel \\\n              gtest_sentinel(gtest_dt); \\\n          GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, gtest_dt); \\\n          gtest_dt->Abort(::testing::internal::DeathTest::TEST_DID_NOT_DIE); \\\n          break; \\\n        } \\\n      } \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__): \\\n      fail(::testing::internal::DeathTest::LastMessage())\n// The symbol \"fail\" here expands to something into which a message\n// can be streamed.\n\n// This macro is for implementing ASSERT/EXPECT_DEBUG_DEATH when compiled in\n// NDEBUG mode. In this case we need the statements to be executed, the regex is\n// ignored, and the macro must accept a streamed message even though the message\n// is never printed.\n# define GTEST_EXECUTE_STATEMENT_(statement, regex) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n  } else \\\n    ::testing::Message()\n\n// A class representing the parsed contents of the\n// --gtest_internal_run_death_test flag, as it existed when\n// RUN_ALL_TESTS was called.\nclass InternalRunDeathTestFlag {\n public:\n  InternalRunDeathTestFlag(const std::string& a_file,\n                           int a_line,\n                           int an_index,\n                           int a_write_fd)\n      : file_(a_file), line_(a_line), index_(an_index),\n        write_fd_(a_write_fd) {}\n\n  ~InternalRunDeathTestFlag() {\n    if (write_fd_ >= 0)\n      posix::Close(write_fd_);\n  }\n\n  const std::string& file() const { return file_; }\n  int line() const { return line_; }\n  int index() const { return index_; }\n  int write_fd() const { return write_fd_; }\n\n private:\n  std::string file_;\n  int line_;\n  int index_;\n  int write_fd_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(InternalRunDeathTestFlag);\n};\n\n// Returns a newly created InternalRunDeathTestFlag object with fields\n// initialized from the GTEST_FLAG(internal_run_death_test) flag if\n// the flag is specified; otherwise returns NULL.\nInternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();\n\n#else  // GTEST_HAS_DEATH_TEST\n\n// This macro is used for implementing macros such as\n// EXPECT_DEATH_IF_SUPPORTED and ASSERT_DEATH_IF_SUPPORTED on systems where\n// death tests are not supported. Those macros must compile on such systems\n// iff EXPECT_DEATH and ASSERT_DEATH compile with the same parameters on\n// systems that support death tests. This allows one to write such a macro\n// on a system that does not support death tests and be sure that it will\n// compile on a death-test supporting system.\n//\n// Parameters:\n//   statement -  A statement that a macro such as EXPECT_DEATH would test\n//                for program termination. This macro has to make sure this\n//                statement is compiled but not executed, to ensure that\n//                EXPECT_DEATH_IF_SUPPORTED compiles with a certain\n//                parameter iff EXPECT_DEATH compiles with it.\n//   regex     -  A regex that a macro such as EXPECT_DEATH would use to test\n//                the output of statement.  This parameter has to be\n//                compiled but not evaluated by this macro, to ensure that\n//                this macro only accepts expressions that a macro such as\n//                EXPECT_DEATH would accept.\n//   terminator - Must be an empty statement for EXPECT_DEATH_IF_SUPPORTED\n//                and a return statement for ASSERT_DEATH_IF_SUPPORTED.\n//                This ensures that ASSERT_DEATH_IF_SUPPORTED will not\n//                compile inside functions where ASSERT_DEATH doesn't\n//                compile.\n//\n//  The branch that has an always false condition is used to ensure that\n//  statement and regex are compiled (and thus syntactically correct) but\n//  never executed. The unreachable code macro protects the terminator\n//  statement from generating an 'unreachable code' warning in case\n//  statement unconditionally returns or throws. The Message constructor at\n//  the end allows the syntax of streaming additional messages into the\n//  macro, for compilational compatibility with EXPECT_DEATH/ASSERT_DEATH.\n# define GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, terminator) \\\n    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n    if (::testing::internal::AlwaysTrue()) { \\\n      GTEST_LOG_(WARNING) \\\n          << \"Death tests are not supported on this platform.\\n\" \\\n          << \"Statement '\" #statement \"' cannot be verified.\"; \\\n    } else if (::testing::internal::AlwaysFalse()) { \\\n      ::testing::internal::RE::PartialMatch(\".*\", (regex)); \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n      terminator; \\\n    } else \\\n      ::testing::Message()\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-filepath.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: keith.ray@gmail.com (Keith Ray)\n//\n// Google Test filepath utilities\n//\n// This header file declares classes and functions used internally by\n// Google Test.  They are subject to change without notice.\n//\n// This file is #included in <gtest/internal/gtest-internal.h>.\n// Do not include this header file separately!\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n\n#include \"gtest/internal/gtest-string.h\"\n\nnamespace testing {\nnamespace internal {\n\n// FilePath - a class for file and directory pathname manipulation which\n// handles platform-specific conventions (like the pathname separator).\n// Used for helper functions for naming files in a directory for xml output.\n// Except for Set methods, all methods are const or static, which provides an\n// \"immutable value object\" -- useful for peace of mind.\n// A FilePath with a value ending in a path separator (\"like/this/\") represents\n// a directory, otherwise it is assumed to represent a file. In either case,\n// it may or may not represent an actual file or directory in the file system.\n// Names are NOT checked for syntax correctness -- no checking for illegal\n// characters, malformed paths, etc.\n\nclass GTEST_API_ FilePath {\n public:\n  FilePath() : pathname_(\"\") { }\n  FilePath(const FilePath& rhs) : pathname_(rhs.pathname_) { }\n\n  explicit FilePath(const std::string& pathname) : pathname_(pathname) {\n    Normalize();\n  }\n\n  FilePath& operator=(const FilePath& rhs) {\n    Set(rhs);\n    return *this;\n  }\n\n  void Set(const FilePath& rhs) {\n    pathname_ = rhs.pathname_;\n  }\n\n  const std::string& string() const { return pathname_; }\n  const char* c_str() const { return pathname_.c_str(); }\n\n  // Returns the current working directory, or \"\" if unsuccessful.\n  static FilePath GetCurrentDir();\n\n  // Given directory = \"dir\", base_name = \"test\", number = 0,\n  // extension = \"xml\", returns \"dir/test.xml\". If number is greater\n  // than zero (e.g., 12), returns \"dir/test_12.xml\".\n  // On Windows platform, uses \\ as the separator rather than /.\n  static FilePath MakeFileName(const FilePath& directory,\n                               const FilePath& base_name,\n                               int number,\n                               const char* extension);\n\n  // Given directory = \"dir\", relative_path = \"test.xml\",\n  // returns \"dir/test.xml\".\n  // On Windows, uses \\ as the separator rather than /.\n  static FilePath ConcatPaths(const FilePath& directory,\n                              const FilePath& relative_path);\n\n  // Returns a pathname for a file that does not currently exist. The pathname\n  // will be directory/base_name.extension or\n  // directory/base_name_<number>.extension if directory/base_name.extension\n  // already exists. The number will be incremented until a pathname is found\n  // that does not already exist.\n  // Examples: 'dir/foo_test.xml' or 'dir/foo_test_1.xml'.\n  // There could be a race condition if two or more processes are calling this\n  // function at the same time -- they could both pick the same filename.\n  static FilePath GenerateUniqueFileName(const FilePath& directory,\n                                         const FilePath& base_name,\n                                         const char* extension);\n\n  // Returns true iff the path is \"\".\n  bool IsEmpty() const { return pathname_.empty(); }\n\n  // If input name has a trailing separator character, removes it and returns\n  // the name, otherwise return the name string unmodified.\n  // On Windows platform, uses \\ as the separator, other platforms use /.\n  FilePath RemoveTrailingPathSeparator() const;\n\n  // Returns a copy of the FilePath with the directory part removed.\n  // Example: FilePath(\"path/to/file\").RemoveDirectoryName() returns\n  // FilePath(\"file\"). If there is no directory part (\"just_a_file\"), it returns\n  // the FilePath unmodified. If there is no file part (\"just_a_dir/\") it\n  // returns an empty FilePath (\"\").\n  // On Windows platform, '\\' is the path separator, otherwise it is '/'.\n  FilePath RemoveDirectoryName() const;\n\n  // RemoveFileName returns the directory path with the filename removed.\n  // Example: FilePath(\"path/to/file\").RemoveFileName() returns \"path/to/\".\n  // If the FilePath is \"a_file\" or \"/a_file\", RemoveFileName returns\n  // FilePath(\"./\") or, on Windows, FilePath(\".\\\\\"). If the filepath does\n  // not have a file, like \"just/a/dir/\", it returns the FilePath unmodified.\n  // On Windows platform, '\\' is the path separator, otherwise it is '/'.\n  FilePath RemoveFileName() const;\n\n  // Returns a copy of the FilePath with the case-insensitive extension removed.\n  // Example: FilePath(\"dir/file.exe\").RemoveExtension(\"EXE\") returns\n  // FilePath(\"dir/file\"). If a case-insensitive extension is not\n  // found, returns a copy of the original FilePath.\n  FilePath RemoveExtension(const char* extension) const;\n\n  // Creates directories so that path exists. Returns true if successful or if\n  // the directories already exist; returns false if unable to create\n  // directories for any reason. Will also return false if the FilePath does\n  // not represent a directory (that is, it doesn't end with a path separator).\n  bool CreateDirectoriesRecursively() const;\n\n  // Create the directory so that path exists. Returns true if successful or\n  // if the directory already exists; returns false if unable to create the\n  // directory for any reason, including if the parent directory does not\n  // exist. Not named \"CreateDirectory\" because that's a macro on Windows.\n  bool CreateFolder() const;\n\n  // Returns true if FilePath describes something in the file-system,\n  // either a file, directory, or whatever, and that something exists.\n  bool FileOrDirectoryExists() const;\n\n  // Returns true if pathname describes a directory in the file-system\n  // that exists.\n  bool DirectoryExists() const;\n\n  // Returns true if FilePath ends with a path separator, which indicates that\n  // it is intended to represent a directory. Returns false otherwise.\n  // This does NOT check that a directory (or file) actually exists.\n  bool IsDirectory() const;\n\n  // Returns true if pathname describes a root directory. (Windows has one\n  // root directory per disk drive.)\n  bool IsRootDirectory() const;\n\n  // Returns true if pathname describes an absolute path.\n  bool IsAbsolutePath() const;\n\n private:\n  // Replaces multiple consecutive separators with a single separator.\n  // For example, \"bar///foo\" becomes \"bar/foo\". Does not eliminate other\n  // redundancies that might be in a pathname involving \".\" or \"..\".\n  //\n  // A pathname with multiple consecutive separators may occur either through\n  // user error or as a result of some scripts or APIs that generate a pathname\n  // with a trailing separator. On other platforms the same API or script\n  // may NOT generate a pathname with a trailing \"/\". Then elsewhere that\n  // pathname may have another \"/\" and pathname components added to it,\n  // without checking for the separator already being there.\n  // The script language and operating system may allow paths like \"foo//bar\"\n  // but some of the functions in FilePath will not handle that correctly. In\n  // particular, RemoveTrailingPathSeparator() only removes one separator, and\n  // it is called in CreateDirectoriesRecursively() assuming that it will change\n  // a pathname from directory syntax (trailing separator) to filename syntax.\n  //\n  // On Windows this method also replaces the alternate path separator '/' with\n  // the primary path separator '\\\\', so that for example \"bar\\\\/\\\\foo\" becomes\n  // \"bar\\\\foo\".\n\n  void Normalize();\n\n  // Returns a pointer to the last occurrence of a valid path separator in\n  // the FilePath. On Windows, for example, both '/' and '\\' are valid path\n  // separators. Returns NULL if no path separator was found.\n  const char* FindLastPathSeparator() const;\n\n  std::string pathname_;\n};  // class FilePath\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-linked_ptr.h", "content": "// Copyright 2003 Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: Dan Egnor (egnor@google.com)\n//\n// A \"smart\" pointer type with reference tracking.  Every pointer to a\n// particular object is kept on a circular linked list.  When the last pointer\n// to an object is destroyed or reassigned, the object is deleted.\n//\n// Used properly, this deletes the object when the last reference goes away.\n// There are several caveats:\n// - Like all reference counting schemes, cycles lead to leaks.\n// - Each smart pointer is actually two pointers (8 bytes instead of 4).\n// - Every time a pointer is assigned, the entire list of pointers to that\n//   object is traversed.  This class is therefore NOT SUITABLE when there\n//   will often be more than two or three pointers to a particular object.\n// - References are only tracked as long as linked_ptr<> objects are copied.\n//   If a linked_ptr<> is converted to a raw pointer and back, BAD THINGS\n//   will happen (double deletion).\n//\n// A good use of this class is storing object references in STL containers.\n// You can safely put linked_ptr<> in a vector<>.\n// Other uses may not be as good.\n//\n// Note: If you use an incomplete type with linked_ptr<>, the class\n// *containing* linked_ptr<> must have a constructor and destructor (even\n// if they do nothing!).\n//\n// Bill Gibbons suggested we use something like this.\n//\n// Thread Safety:\n//   Unlike other linked_ptr implementations, in this implementation\n//   a linked_ptr object is thread-safe in the sense that:\n//     - it's safe to copy linked_ptr objects concurrently,\n//     - it's safe to copy *from* a linked_ptr and read its underlying\n//       raw pointer (e.g. via get()) concurrently, and\n//     - it's safe to write to two linked_ptrs that point to the same\n//       shared object concurrently.\n// TODO(wan@google.com): rename this to safe_linked_ptr to avoid\n// confusion with normal linked_ptr.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"gtest/internal/gtest-port.h\"\n\nnamespace testing {\nnamespace internal {\n\n// Protects copying of all linked_ptr objects.\nGTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_linked_ptr_mutex);\n\n// This is used internally by all instances of linked_ptr<>.  It needs to be\n// a non-template class because different types of linked_ptr<> can refer to\n// the same object (linked_ptr<Superclass>(obj) vs linked_ptr<Subclass>(obj)).\n// So, it needs to be possible for different types of linked_ptr to participate\n// in the same circular linked list, so we need a single class type here.\n//\n// DO NOT USE THIS CLASS DIRECTLY YOURSELF.  Use linked_ptr<T>.\nclass linked_ptr_internal {\n public:\n  // Create a new circle that includes only this instance.\n  void join_new() {\n    next_ = this;\n  }\n\n  // Many linked_ptr operations may change p.link_ for some linked_ptr\n  // variable p in the same circle as this object.  Therefore we need\n  // to prevent two such operations from occurring concurrently.\n  //\n  // Note that different types of linked_ptr objects can coexist in a\n  // circle (e.g. linked_ptr<Base>, linked_ptr<Derived1>, and\n  // linked_ptr<Derived2>).  Therefore we must use a single mutex to\n  // protect all linked_ptr objects.  This can create serious\n  // contention in production code, but is acceptable in a testing\n  // framework.\n\n  // Join an existing circle.\n  void join(linked_ptr_internal const* ptr)\n      GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {\n    MutexLock lock(&g_linked_ptr_mutex);\n\n    linked_ptr_internal const* p = ptr;\n    while (p->next_ != ptr) {\n      assert(p->next_ != this &&\n             \"Trying to join() a linked ring we are already in. \"\n             \"Is GMock thread safety enabled?\");\n      p = p->next_;\n    }\n    p->next_ = this;\n    next_ = ptr;\n  }\n\n  // Leave whatever circle we're part of.  Returns true if we were the\n  // last member of the circle.  Once this is done, you can join() another.\n  bool depart()\n      GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {\n    MutexLock lock(&g_linked_ptr_mutex);\n\n    if (next_ == this) return true;\n    linked_ptr_internal const* p = next_;\n    while (p->next_ != this) {\n      assert(p->next_ != next_ &&\n             \"Trying to depart() a linked ring we are not in. \"\n             \"Is GMock thread safety enabled?\");\n      p = p->next_;\n    }\n    p->next_ = next_;\n    return false;\n  }\n\n private:\n  mutable linked_ptr_internal const* next_;\n};\n\ntemplate <typename T>\nclass linked_ptr {\n public:\n  typedef T element_type;\n\n  // Take over ownership of a raw pointer.  This should happen as soon as\n  // possible after the object is created.\n  explicit linked_ptr(T* ptr = NULL) { capture(ptr); }\n  ~linked_ptr() { depart(); }\n\n  // Copy an existing linked_ptr<>, adding ourselves to the list of references.\n  template <typename U> linked_ptr(linked_ptr<U> const& ptr) { copy(&ptr); }\n  linked_ptr(linked_ptr const& ptr) {  // NOLINT\n    assert(&ptr != this);\n    copy(&ptr);\n  }\n\n  // Assignment releases the old value and acquires the new.\n  template <typename U> linked_ptr& operator=(linked_ptr<U> const& ptr) {\n    depart();\n    copy(&ptr);\n    return *this;\n  }\n\n  linked_ptr& operator=(linked_ptr const& ptr) {\n    if (&ptr != this) {\n      depart();\n      copy(&ptr);\n    }\n    return *this;\n  }\n\n  // Smart pointer members.\n  void reset(T* ptr = NULL) {\n    depart();\n    capture(ptr);\n  }\n  T* get() const { return value_; }\n  T* operator->() const { return value_; }\n  T& operator*() const { return *value_; }\n\n  bool operator==(T* p) const { return value_ == p; }\n  bool operator!=(T* p) const { return value_ != p; }\n  template <typename U>\n  bool operator==(linked_ptr<U> const& ptr) const {\n    return value_ == ptr.get();\n  }\n  template <typename U>\n  bool operator!=(linked_ptr<U> const& ptr) const {\n    return value_ != ptr.get();\n  }\n\n private:\n  template <typename U>\n  friend class linked_ptr;\n\n  T* value_;\n  linked_ptr_internal link_;\n\n  void depart() {\n    if (link_.depart()) delete value_;\n  }\n\n  void capture(T* ptr) {\n    value_ = ptr;\n    link_.join_new();\n  }\n\n  template <typename U> void copy(linked_ptr<U> const* ptr) {\n    value_ = ptr->get();\n    if (value_)\n      link_.join(&ptr->link_);\n    else\n      link_.join_new();\n  }\n};\n\ntemplate<typename T> inline\nbool operator==(T* ptr, const linked_ptr<T>& x) {\n  return ptr == x.get();\n}\n\ntemplate<typename T> inline\nbool operator!=(T* ptr, const linked_ptr<T>& x) {\n  return ptr != x.get();\n}\n\n// A function to convert T* into linked_ptr<T>\n// Doing e.g. make_linked_ptr(new FooBarBaz<type>(arg)) is a shorter notation\n// for linked_ptr<FooBarBaz<type> >(new FooBarBaz<type>(arg))\ntemplate <typename T>\nlinked_ptr<T> make_linked_ptr(T* ptr) {\n  return linked_ptr<T>(ptr);\n}\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-param-util-generated.h", "content": "// This file was GENERATED by command:\n//     pump.py gtest-param-util-generated.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: vladl@google.com (Vlad Losev)\n\n// Type and function utilities for implementing parameterized tests.\n// This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\n//\n// Currently Google Test supports at most 50 arguments in Values,\n// and at most 10 arguments in Combine. Please contact\n// googletestframework@googlegroups.com if you need more.\n// Please note that the number of arguments to Combine is limited\n// by the maximum arity of the implementation of tuple which is\n// currently set at 10.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\n\n// scripts/fuse_gtest.py depends on gtest's own header being #included\n// *unconditionally*.  Therefore these #includes cannot be moved\n// inside #if GTEST_HAS_PARAM_TEST.\n#include \"gtest/internal/gtest-param-util.h\"\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_HAS_PARAM_TEST\n\n#ifdef __clang__\n#if __has_warning(\"-Wdeprecated-copy\")\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-copy\"\n#endif\n#endif\n\nnamespace testing {\n\n// Forward declarations of ValuesIn(), which is implemented in\n// include/gtest/gtest-param-test.h.\ntemplate <typename ForwardIterator>\ninternal::ParamGenerator<\n  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\nValuesIn(ForwardIterator begin, ForwardIterator end);\n\ntemplate <typename T, size_t N>\ninternal::ParamGenerator<T> ValuesIn(const T (&array)[N]);\n\ntemplate <class Container>\ninternal::ParamGenerator<typename Container::value_type> ValuesIn(\n    const Container& container);\n\nnamespace internal {\n\n// Used in the Values() function to provide polymorphic capabilities.\ntemplate <typename T1>\nclass ValueArray1 {\n public:\n  explicit ValueArray1(T1 v1) : v1_(v1) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray1& other) = delete;\n\n  const T1 v1_;\n};\n\ntemplate <typename T1, typename T2>\nclass ValueArray2 {\n public:\n  ValueArray2(T1 v1, T2 v2) : v1_(v1), v2_(v2) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray2& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n};\n\ntemplate <typename T1, typename T2, typename T3>\nclass ValueArray3 {\n public:\n  ValueArray3(T1 v1, T2 v2, T3 v3) : v1_(v1), v2_(v2), v3_(v3) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray3& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nclass ValueArray4 {\n public:\n  ValueArray4(T1 v1, T2 v2, T3 v3, T4 v4) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray4& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nclass ValueArray5 {\n public:\n  ValueArray5(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray5& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\nclass ValueArray6 {\n public:\n  ValueArray6(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray6& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\nclass ValueArray7 {\n public:\n  ValueArray7(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray7& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\nclass ValueArray8 {\n public:\n  ValueArray8(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n      T8 v8) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray8& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\nclass ValueArray9 {\n public:\n  ValueArray9(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n      T9 v9) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray9& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\nclass ValueArray10 {\n public:\n  ValueArray10(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray10& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\nclass ValueArray11 {\n public:\n  ValueArray11(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray11& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\nclass ValueArray12 {\n public:\n  ValueArray12(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray12& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\nclass ValueArray13 {\n public:\n  ValueArray13(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray13& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\nclass ValueArray14 {\n public:\n  ValueArray14(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray14& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\nclass ValueArray15 {\n public:\n  ValueArray15(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray15& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\nclass ValueArray16 {\n public:\n  ValueArray16(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray16& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\nclass ValueArray17 {\n public:\n  ValueArray17(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n      T17 v17) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray17& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\nclass ValueArray18 {\n public:\n  ValueArray18(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray18& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\nclass ValueArray19 {\n public:\n  ValueArray19(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\n      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray19& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\nclass ValueArray20 {\n public:\n  ValueArray20(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\n      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\n      v19_(v19), v20_(v20) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray20& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\nclass ValueArray21 {\n public:\n  ValueArray21(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\n      v18_(v18), v19_(v19), v20_(v20), v21_(v21) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray21& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\nclass ValueArray22 {\n public:\n  ValueArray22(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray22& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\nclass ValueArray23 {\n public:\n  ValueArray23(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray23& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\nclass ValueArray24 {\n public:\n  ValueArray24(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\n      v22_(v22), v23_(v23), v24_(v24) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray24& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\nclass ValueArray25 {\n public:\n  ValueArray25(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n      T25 v25) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray25& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\nclass ValueArray26 {\n public:\n  ValueArray26(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray26& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\nclass ValueArray27 {\n public:\n  ValueArray27(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\n      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\n      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\n      v26_(v26), v27_(v27) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray27& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\nclass ValueArray28 {\n public:\n  ValueArray28(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\n      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\n      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\n      v25_(v25), v26_(v26), v27_(v27), v28_(v28) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray28& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\nclass ValueArray29 {\n public:\n  ValueArray29(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\n      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\n      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray29& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\nclass ValueArray30 {\n public:\n  ValueArray30(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray30& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\nclass ValueArray31 {\n public:\n  ValueArray31(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray31& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\nclass ValueArray32 {\n public:\n  ValueArray32(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\n      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\n      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray32& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\nclass ValueArray33 {\n public:\n  ValueArray33(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,\n      T33 v33) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray33& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\nclass ValueArray34 {\n public:\n  ValueArray34(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray34& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\nclass ValueArray35 {\n public:\n  ValueArray35(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\n      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\n      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\n      v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),\n      v32_(v32), v33_(v33), v34_(v34), v35_(v35) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray35& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\nclass ValueArray36 {\n public:\n  ValueArray36(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\n      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\n      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\n      v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),\n      v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray36& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\nclass ValueArray37 {\n public:\n  ValueArray37(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\n      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\n      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),\n      v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),\n      v36_(v36), v37_(v37) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray37& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\nclass ValueArray38 {\n public:\n  ValueArray38(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\n      v35_(v35), v36_(v36), v37_(v37), v38_(v38) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray38& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\nclass ValueArray39 {\n public:\n  ValueArray39(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\n      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray39& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\nclass ValueArray40 {\n public:\n  ValueArray40(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\n      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\n      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),\n      v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),\n      v40_(v40) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray40& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\nclass ValueArray41 {\n public:\n  ValueArray41(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,\n      T41 v41) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\n      v39_(v39), v40_(v40), v41_(v41) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray41& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\nclass ValueArray42 {\n public:\n  ValueArray42(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\n      v39_(v39), v40_(v40), v41_(v41), v42_(v42) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray42& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\nclass ValueArray43 {\n public:\n  ValueArray43(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\n      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\n      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\n      v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),\n      v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37),\n      v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray43& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\nclass ValueArray44 {\n public:\n  ValueArray44(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\n      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\n      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\n      v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),\n      v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36),\n      v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42),\n      v43_(v43), v44_(v44) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray44& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\nclass ValueArray45 {\n public:\n  ValueArray45(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\n      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\n      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),\n      v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),\n      v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41),\n      v42_(v42), v43_(v43), v44_(v44), v45_(v45) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray45& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\nclass ValueArray46 {\n public:\n  ValueArray46(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\n      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),\n      v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray46& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\nclass ValueArray47 {\n public:\n  ValueArray47(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\n      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),\n      v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46),\n      v47_(v47) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray47& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n  const T47 v47_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\nclass ValueArray48 {\n public:\n  ValueArray48(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\n      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\n      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),\n      v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),\n      v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45),\n      v46_(v46), v47_(v47), v48_(v48) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),\n        static_cast<T>(v48_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray48& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n  const T47 v47_;\n  const T48 v48_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\nclass ValueArray49 {\n public:\n  ValueArray49(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48,\n      T49 v49) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\n      v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),\n      v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),\n        static_cast<T>(v48_), static_cast<T>(v49_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray49& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n  const T47 v47_;\n  const T48 v48_;\n  const T49 v49_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\nclass ValueArray50 {\n public:\n  ValueArray50(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48, T49 v49,\n      T50 v50) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\n      v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),\n      v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49), v50_(v50) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),\n        static_cast<T>(v48_), static_cast<T>(v49_), static_cast<T>(v50_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray50& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n  const T47 v47_;\n  const T48 v48_;\n  const T49 v49_;\n  const T50 v50_;\n};\n\n# if GTEST_HAS_COMBINE\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Generates values from the Cartesian product of values produced\n// by the argument generators.\n//\ntemplate <typename T1, typename T2>\nclass CartesianProductGenerator2\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2> > {\n public:\n  typedef ::testing::tuple<T1, T2> ParamType;\n\n  CartesianProductGenerator2(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2)\n      : g1_(g1), g2_(g2) {}\n  virtual ~CartesianProductGenerator2() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current2_;\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator2::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator2& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n};  // class CartesianProductGenerator2\n\n\ntemplate <typename T1, typename T2, typename T3>\nclass CartesianProductGenerator3\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3> ParamType;\n\n  CartesianProductGenerator3(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3)\n      : g1_(g1), g2_(g2), g3_(g3) {}\n  virtual ~CartesianProductGenerator3() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current3_;\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator3::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator3& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n};  // class CartesianProductGenerator3\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nclass CartesianProductGenerator4\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4> ParamType;\n\n  CartesianProductGenerator4(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4) {}\n  virtual ~CartesianProductGenerator4() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current4_;\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator4::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator4& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n};  // class CartesianProductGenerator4\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nclass CartesianProductGenerator5\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5> ParamType;\n\n  CartesianProductGenerator5(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) {}\n  virtual ~CartesianProductGenerator5() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current5_;\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator5::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator5& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n};  // class CartesianProductGenerator5\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\nclass CartesianProductGenerator6\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5,\n        T6> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6> ParamType;\n\n  CartesianProductGenerator6(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) {}\n  virtual ~CartesianProductGenerator6() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current6_;\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator6::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator6& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n};  // class CartesianProductGenerator6\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\nclass CartesianProductGenerator7\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n        T7> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> ParamType;\n\n  CartesianProductGenerator7(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) {}\n  virtual ~CartesianProductGenerator7() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\n        g7_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6,\n      const ParamGenerator<T7>& g7,\n      const typename ParamGenerator<T7>::iterator& current7)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\n          begin7_(g7.begin()), end7_(g7.end()), current7_(current7)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current7_;\n      if (current7_ == end7_) {\n        current7_ = begin7_;\n        ++current6_;\n      }\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_ &&\n          current7_ == typed_other->current7_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_),\n        begin7_(other.begin7_),\n        end7_(other.end7_),\n        current7_(other.current7_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_, *current7_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_ ||\n          current7_ == end7_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    const typename ParamGenerator<T7>::iterator begin7_;\n    const typename ParamGenerator<T7>::iterator end7_;\n    typename ParamGenerator<T7>::iterator current7_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator7::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator7& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n  const ParamGenerator<T7> g7_;\n};  // class CartesianProductGenerator7\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\nclass CartesianProductGenerator8\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n        T7, T8> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> ParamType;\n\n  CartesianProductGenerator8(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,\n      const ParamGenerator<T8>& g8)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),\n          g8_(g8) {}\n  virtual ~CartesianProductGenerator8() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\n        g7_.begin(), g8_, g8_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\n        g8_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6,\n      const ParamGenerator<T7>& g7,\n      const typename ParamGenerator<T7>::iterator& current7,\n      const ParamGenerator<T8>& g8,\n      const typename ParamGenerator<T8>::iterator& current8)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\n          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\n          begin8_(g8.begin()), end8_(g8.end()), current8_(current8)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current8_;\n      if (current8_ == end8_) {\n        current8_ = begin8_;\n        ++current7_;\n      }\n      if (current7_ == end7_) {\n        current7_ = begin7_;\n        ++current6_;\n      }\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_ &&\n          current7_ == typed_other->current7_ &&\n          current8_ == typed_other->current8_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_),\n        begin7_(other.begin7_),\n        end7_(other.end7_),\n        current7_(other.current7_),\n        begin8_(other.begin8_),\n        end8_(other.end8_),\n        current8_(other.current8_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_, *current7_, *current8_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_ ||\n          current7_ == end7_ ||\n          current8_ == end8_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    const typename ParamGenerator<T7>::iterator begin7_;\n    const typename ParamGenerator<T7>::iterator end7_;\n    typename ParamGenerator<T7>::iterator current7_;\n    const typename ParamGenerator<T8>::iterator begin8_;\n    const typename ParamGenerator<T8>::iterator end8_;\n    typename ParamGenerator<T8>::iterator current8_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator8::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator8& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n  const ParamGenerator<T7> g7_;\n  const ParamGenerator<T8> g8_;\n};  // class CartesianProductGenerator8\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\nclass CartesianProductGenerator9\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n        T7, T8, T9> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9> ParamType;\n\n  CartesianProductGenerator9(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,\n      const ParamGenerator<T8>& g8, const ParamGenerator<T9>& g9)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\n          g9_(g9) {}\n  virtual ~CartesianProductGenerator9() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\n        g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\n        g8_.end(), g9_, g9_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6,\n      const ParamGenerator<T7>& g7,\n      const typename ParamGenerator<T7>::iterator& current7,\n      const ParamGenerator<T8>& g8,\n      const typename ParamGenerator<T8>::iterator& current8,\n      const ParamGenerator<T9>& g9,\n      const typename ParamGenerator<T9>::iterator& current9)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\n          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\n          begin8_(g8.begin()), end8_(g8.end()), current8_(current8),\n          begin9_(g9.begin()), end9_(g9.end()), current9_(current9)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current9_;\n      if (current9_ == end9_) {\n        current9_ = begin9_;\n        ++current8_;\n      }\n      if (current8_ == end8_) {\n        current8_ = begin8_;\n        ++current7_;\n      }\n      if (current7_ == end7_) {\n        current7_ = begin7_;\n        ++current6_;\n      }\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_ &&\n          current7_ == typed_other->current7_ &&\n          current8_ == typed_other->current8_ &&\n          current9_ == typed_other->current9_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_),\n        begin7_(other.begin7_),\n        end7_(other.end7_),\n        current7_(other.current7_),\n        begin8_(other.begin8_),\n        end8_(other.end8_),\n        current8_(other.current8_),\n        begin9_(other.begin9_),\n        end9_(other.end9_),\n        current9_(other.current9_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_, *current7_, *current8_,\n            *current9_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_ ||\n          current7_ == end7_ ||\n          current8_ == end8_ ||\n          current9_ == end9_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    const typename ParamGenerator<T7>::iterator begin7_;\n    const typename ParamGenerator<T7>::iterator end7_;\n    typename ParamGenerator<T7>::iterator current7_;\n    const typename ParamGenerator<T8>::iterator begin8_;\n    const typename ParamGenerator<T8>::iterator end8_;\n    typename ParamGenerator<T8>::iterator current8_;\n    const typename ParamGenerator<T9>::iterator begin9_;\n    const typename ParamGenerator<T9>::iterator end9_;\n    typename ParamGenerator<T9>::iterator current9_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator9::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator9& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n  const ParamGenerator<T7> g7_;\n  const ParamGenerator<T8> g8_;\n  const ParamGenerator<T9> g9_;\n};  // class CartesianProductGenerator9\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\nclass CartesianProductGenerator10\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n        T7, T8, T9, T10> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ParamType;\n\n  CartesianProductGenerator10(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,\n      const ParamGenerator<T8>& g8, const ParamGenerator<T9>& g9,\n      const ParamGenerator<T10>& g10)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\n          g9_(g9), g10_(g10) {}\n  virtual ~CartesianProductGenerator10() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\n        g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin(), g10_, g10_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\n        g8_.end(), g9_, g9_.end(), g10_, g10_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6,\n      const ParamGenerator<T7>& g7,\n      const typename ParamGenerator<T7>::iterator& current7,\n      const ParamGenerator<T8>& g8,\n      const typename ParamGenerator<T8>::iterator& current8,\n      const ParamGenerator<T9>& g9,\n      const typename ParamGenerator<T9>::iterator& current9,\n      const ParamGenerator<T10>& g10,\n      const typename ParamGenerator<T10>::iterator& current10)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\n          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\n          begin8_(g8.begin()), end8_(g8.end()), current8_(current8),\n          begin9_(g9.begin()), end9_(g9.end()), current9_(current9),\n          begin10_(g10.begin()), end10_(g10.end()), current10_(current10)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current10_;\n      if (current10_ == end10_) {\n        current10_ = begin10_;\n        ++current9_;\n      }\n      if (current9_ == end9_) {\n        current9_ = begin9_;\n        ++current8_;\n      }\n      if (current8_ == end8_) {\n        current8_ = begin8_;\n        ++current7_;\n      }\n      if (current7_ == end7_) {\n        current7_ = begin7_;\n        ++current6_;\n      }\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_ &&\n          current7_ == typed_other->current7_ &&\n          current8_ == typed_other->current8_ &&\n          current9_ == typed_other->current9_ &&\n          current10_ == typed_other->current10_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_),\n        begin7_(other.begin7_),\n        end7_(other.end7_),\n        current7_(other.current7_),\n        begin8_(other.begin8_),\n        end8_(other.end8_),\n        current8_(other.current8_),\n        begin9_(other.begin9_),\n        end9_(other.end9_),\n        current9_(other.current9_),\n        begin10_(other.begin10_),\n        end10_(other.end10_),\n        current10_(other.current10_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_, *current7_, *current8_,\n            *current9_, *current10_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_ ||\n          current7_ == end7_ ||\n          current8_ == end8_ ||\n          current9_ == end9_ ||\n          current10_ == end10_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    const typename ParamGenerator<T7>::iterator begin7_;\n    const typename ParamGenerator<T7>::iterator end7_;\n    typename ParamGenerator<T7>::iterator current7_;\n    const typename ParamGenerator<T8>::iterator begin8_;\n    const typename ParamGenerator<T8>::iterator end8_;\n    typename ParamGenerator<T8>::iterator current8_;\n    const typename ParamGenerator<T9>::iterator begin9_;\n    const typename ParamGenerator<T9>::iterator end9_;\n    typename ParamGenerator<T9>::iterator current9_;\n    const typename ParamGenerator<T10>::iterator begin10_;\n    const typename ParamGenerator<T10>::iterator end10_;\n    typename ParamGenerator<T10>::iterator current10_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator10::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator10& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n  const ParamGenerator<T7> g7_;\n  const ParamGenerator<T8> g8_;\n  const ParamGenerator<T9> g9_;\n  const ParamGenerator<T10> g10_;\n};  // class CartesianProductGenerator10\n\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Helper classes providing Combine() with polymorphic features. They allow\n// casting CartesianProductGeneratorN<T> to ParamGenerator<U> if T is\n// convertible to U.\n//\ntemplate <class Generator1, class Generator2>\nclass CartesianProductHolder2 {\n public:\nCartesianProductHolder2(const Generator1& g1, const Generator2& g2)\n      : g1_(g1), g2_(g2) {}\n  template <typename T1, typename T2>\n  operator ParamGenerator< ::testing::tuple<T1, T2> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2> >(\n        new CartesianProductGenerator2<T1, T2>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder2& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n};  // class CartesianProductHolder2\n\ntemplate <class Generator1, class Generator2, class Generator3>\nclass CartesianProductHolder3 {\n public:\nCartesianProductHolder3(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3)\n      : g1_(g1), g2_(g2), g3_(g3) {}\n  template <typename T1, typename T2, typename T3>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3> >(\n        new CartesianProductGenerator3<T1, T2, T3>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder3& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n};  // class CartesianProductHolder3\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4>\nclass CartesianProductHolder4 {\n public:\nCartesianProductHolder4(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4) {}\n  template <typename T1, typename T2, typename T3, typename T4>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >(\n        new CartesianProductGenerator4<T1, T2, T3, T4>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder4& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n};  // class CartesianProductHolder4\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5>\nclass CartesianProductHolder5 {\n public:\nCartesianProductHolder5(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >(\n        new CartesianProductGenerator5<T1, T2, T3, T4, T5>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder5& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n};  // class CartesianProductHolder5\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6>\nclass CartesianProductHolder6 {\n public:\nCartesianProductHolder6(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >(\n        new CartesianProductGenerator6<T1, T2, T3, T4, T5, T6>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder6& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n};  // class CartesianProductHolder6\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6, class Generator7>\nclass CartesianProductHolder7 {\n public:\nCartesianProductHolder7(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6, const Generator7& g7)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6, typename T7>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n      T7> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> >(\n        new CartesianProductGenerator7<T1, T2, T3, T4, T5, T6, T7>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_),\n        static_cast<ParamGenerator<T7> >(g7_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder7& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n  const Generator7 g7_;\n};  // class CartesianProductHolder7\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6, class Generator7,\n    class Generator8>\nclass CartesianProductHolder8 {\n public:\nCartesianProductHolder8(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6, const Generator7& g7, const Generator8& g8)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),\n          g8_(g8) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6, typename T7, typename T8>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7,\n      T8> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> >(\n        new CartesianProductGenerator8<T1, T2, T3, T4, T5, T6, T7, T8>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_),\n        static_cast<ParamGenerator<T7> >(g7_),\n        static_cast<ParamGenerator<T8> >(g8_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder8& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n  const Generator7 g7_;\n  const Generator8 g8_;\n};  // class CartesianProductHolder8\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6, class Generator7,\n    class Generator8, class Generator9>\nclass CartesianProductHolder9 {\n public:\nCartesianProductHolder9(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6, const Generator7& g7, const Generator8& g8,\n    const Generator9& g9)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\n          g9_(g9) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6, typename T7, typename T8, typename T9>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,\n      T9> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,\n        T9> >(\n        new CartesianProductGenerator9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_),\n        static_cast<ParamGenerator<T7> >(g7_),\n        static_cast<ParamGenerator<T8> >(g8_),\n        static_cast<ParamGenerator<T9> >(g9_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder9& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n  const Generator7 g7_;\n  const Generator8 g8_;\n  const Generator9 g9_;\n};  // class CartesianProductHolder9\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6, class Generator7,\n    class Generator8, class Generator9, class Generator10>\nclass CartesianProductHolder10 {\n public:\nCartesianProductHolder10(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6, const Generator7& g7, const Generator8& g8,\n    const Generator9& g9, const Generator10& g10)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\n          g9_(g9), g10_(g10) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6, typename T7, typename T8, typename T9, typename T10>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,\n      T10> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,\n        T10> >(\n        new CartesianProductGenerator10<T1, T2, T3, T4, T5, T6, T7, T8, T9,\n            T10>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_),\n        static_cast<ParamGenerator<T7> >(g7_),\n        static_cast<ParamGenerator<T8> >(g8_),\n        static_cast<ParamGenerator<T9> >(g9_),\n        static_cast<ParamGenerator<T10> >(g10_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder10& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n  const Generator7 g7_;\n  const Generator8 g8_;\n  const Generator9 g9_;\n  const Generator10 g10_;\n};  // class CartesianProductHolder10\n\n# endif  // GTEST_HAS_COMBINE\n\n}  // namespace internal\n}  // namespace testing\n\n#ifdef __clang__\n#if __has_warning(\"-Wdeprecated-copy\")\n#pragma clang diagnostic pop\n#endif\n#endif\n\n#endif  //  GTEST_HAS_PARAM_TEST\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-param-util.h", "content": "// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: vladl@google.com (Vlad Losev)\n\n// Type and function utilities for implementing parameterized tests.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n\n#include <ctype.h>\n\n#include <iterator>\n#include <set>\n#include <utility>\n#include <vector>\n\n// scripts/fuse_gtest.py depends on gtest's own header being #included\n// *unconditionally*.  Therefore these #includes cannot be moved\n// inside #if GTEST_HAS_PARAM_TEST.\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-linked_ptr.h\"\n#include \"gtest/internal/gtest-port.h\"\n#include \"gtest/gtest-printers.h\"\n\n#if GTEST_HAS_PARAM_TEST\n\nnamespace testing {\n\n// Input to a parameterized test name generator, describing a test parameter.\n// Consists of the parameter value and the integer parameter index.\ntemplate <class ParamType>\nstruct TestParamInfo {\n  TestParamInfo(const ParamType& a_param, size_t an_index) :\n    param(a_param),\n    index(an_index) {}\n  ParamType param;\n  size_t index;\n};\n\n// A builtin parameterized test name generator which returns the result of\n// testing::PrintToString.\nstruct PrintToStringParamName {\n  template <class ParamType>\n  std::string operator()(const TestParamInfo<ParamType>& info) const {\n    return PrintToString(info.param);\n  }\n};\n\nnamespace internal {\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Outputs a message explaining invalid registration of different\n// fixture class for the same test case. This may happen when\n// TEST_P macro is used to define two tests with the same name\n// but in different namespaces.\nGTEST_API_ void ReportInvalidTestCaseType(const char* test_case_name,\n                                          CodeLocation code_location);\n\ntemplate <typename> class ParamGeneratorInterface;\ntemplate <typename> class ParamGenerator;\n\n// Interface for iterating over elements provided by an implementation\n// of ParamGeneratorInterface<T>.\ntemplate <typename T>\nclass ParamIteratorInterface {\n public:\n  virtual ~ParamIteratorInterface() {}\n  // A pointer to the base generator instance.\n  // Used only for the purposes of iterator comparison\n  // to make sure that two iterators belong to the same generator.\n  virtual const ParamGeneratorInterface<T>* BaseGenerator() const = 0;\n  // Advances iterator to point to the next element\n  // provided by the generator. The caller is responsible\n  // for not calling Advance() on an iterator equal to\n  // BaseGenerator()->End().\n  virtual void Advance() = 0;\n  // Clones the iterator object. Used for implementing copy semantics\n  // of ParamIterator<T>.\n  virtual ParamIteratorInterface* Clone() const = 0;\n  // Dereferences the current iterator and provides (read-only) access\n  // to the pointed value. It is the caller's responsibility not to call\n  // Current() on an iterator equal to BaseGenerator()->End().\n  // Used for implementing ParamGenerator<T>::operator*().\n  virtual const T* Current() const = 0;\n  // Determines whether the given iterator and other point to the same\n  // element in the sequence generated by the generator.\n  // Used for implementing ParamGenerator<T>::operator==().\n  virtual bool Equals(const ParamIteratorInterface& other) const = 0;\n};\n\n// Class iterating over elements provided by an implementation of\n// ParamGeneratorInterface<T>. It wraps ParamIteratorInterface<T>\n// and implements the const forward iterator concept.\ntemplate <typename T>\nclass ParamIterator {\n public:\n  typedef T value_type;\n  typedef const T& reference;\n  typedef ptrdiff_t difference_type;\n\n  // ParamIterator assumes ownership of the impl_ pointer.\n  ParamIterator(const ParamIterator& other) : impl_(other.impl_->Clone()) {}\n  ParamIterator& operator=(const ParamIterator& other) {\n    if (this != &other)\n      impl_.reset(other.impl_->Clone());\n    return *this;\n  }\n\n  const T& operator*() const { return *impl_->Current(); }\n  const T* operator->() const { return impl_->Current(); }\n  // Prefix version of operator++.\n  ParamIterator& operator++() {\n    impl_->Advance();\n    return *this;\n  }\n  // Postfix version of operator++.\n  ParamIterator operator++(int /*unused*/) {\n    ParamIteratorInterface<T>* clone = impl_->Clone();\n    impl_->Advance();\n    return ParamIterator(clone);\n  }\n  bool operator==(const ParamIterator& other) const {\n    return impl_.get() == other.impl_.get() || impl_->Equals(*other.impl_);\n  }\n  bool operator!=(const ParamIterator& other) const {\n    return !(*this == other);\n  }\n\n private:\n  friend class ParamGenerator<T>;\n  explicit ParamIterator(ParamIteratorInterface<T>* impl) : impl_(impl) {}\n  scoped_ptr<ParamIteratorInterface<T> > impl_;\n};\n\n// ParamGeneratorInterface<T> is the binary interface to access generators\n// defined in other translation units.\ntemplate <typename T>\nclass ParamGeneratorInterface {\n public:\n  typedef T ParamType;\n\n  virtual ~ParamGeneratorInterface() {}\n\n  // Generator interface definition\n  virtual ParamIteratorInterface<T>* Begin() const = 0;\n  virtual ParamIteratorInterface<T>* End() const = 0;\n};\n\n// Wraps ParamGeneratorInterface<T> and provides general generator syntax\n// compatible with the STL Container concept.\n// This class implements copy initialization semantics and the contained\n// ParamGeneratorInterface<T> instance is shared among all copies\n// of the original object. This is possible because that instance is immutable.\ntemplate<typename T>\nclass ParamGenerator {\n public:\n  typedef ParamIterator<T> iterator;\n\n  explicit ParamGenerator(ParamGeneratorInterface<T>* impl) : impl_(impl) {}\n  ParamGenerator(const ParamGenerator& other) : impl_(other.impl_) {}\n\n  ParamGenerator& operator=(const ParamGenerator& other) {\n    impl_ = other.impl_;\n    return *this;\n  }\n\n  iterator begin() const { return iterator(impl_->Begin()); }\n  iterator end() const { return iterator(impl_->End()); }\n\n private:\n  linked_ptr<const ParamGeneratorInterface<T> > impl_;\n};\n\n// Generates values from a range of two comparable values. Can be used to\n// generate sequences of user-defined types that implement operator+() and\n// operator<().\n// This class is used in the Range() function.\ntemplate <typename T, typename IncrementT>\nclass RangeGenerator : public ParamGeneratorInterface<T> {\n public:\n  RangeGenerator(T begin, T end, IncrementT step)\n      : begin_(begin), end_(end),\n        step_(step), end_index_(CalculateEndIndex(begin, end, step)) {}\n  virtual ~RangeGenerator() {}\n\n  virtual ParamIteratorInterface<T>* Begin() const {\n    return new Iterator(this, begin_, 0, step_);\n  }\n  virtual ParamIteratorInterface<T>* End() const {\n    return new Iterator(this, end_, end_index_, step_);\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<T> {\n   public:\n    Iterator(const ParamGeneratorInterface<T>* base, T value, int index,\n             IncrementT step)\n        : base_(base), value_(value), index_(index), step_(step) {}\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<T>* BaseGenerator() const {\n      return base_;\n    }\n    virtual void Advance() {\n      value_ = static_cast<T>(value_ + step_);\n      index_++;\n    }\n    virtual ParamIteratorInterface<T>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const T* Current() const { return &value_; }\n    virtual bool Equals(const ParamIteratorInterface<T>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const int other_index =\n          CheckedDowncastToActualType<const Iterator>(&other)->index_;\n      return index_ == other_index;\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : ParamIteratorInterface<T>(),\n          base_(other.base_), value_(other.value_), index_(other.index_),\n          step_(other.step_) {}\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other);\n\n    const ParamGeneratorInterface<T>* const base_;\n    T value_;\n    int index_;\n    const IncrementT step_;\n  };  // class RangeGenerator::Iterator\n\n  static int CalculateEndIndex(const T& begin,\n                               const T& end,\n                               const IncrementT& step) {\n    int end_index = 0;\n    for (T i = begin; i < end; i = static_cast<T>(i + step))\n      end_index++;\n    return end_index;\n  }\n\n  // No implementation - assignment is unsupported.\n  void operator=(const RangeGenerator& other);\n\n  const T begin_;\n  const T end_;\n  const IncrementT step_;\n  // The index for the end() iterator. All the elements in the generated\n  // sequence are indexed (0-based) to aid iterator comparison.\n  const int end_index_;\n};  // class RangeGenerator\n\n\n// Generates values from a pair of STL-style iterators. Used in the\n// ValuesIn() function. The elements are copied from the source range\n// since the source can be located on the stack, and the generator\n// is likely to persist beyond that stack frame.\ntemplate <typename T>\nclass ValuesInIteratorRangeGenerator : public ParamGeneratorInterface<T> {\n public:\n  template <typename ForwardIterator>\n  ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end)\n      : container_(begin, end) {}\n  virtual ~ValuesInIteratorRangeGenerator() {}\n\n  virtual ParamIteratorInterface<T>* Begin() const {\n    return new Iterator(this, container_.begin());\n  }\n  virtual ParamIteratorInterface<T>* End() const {\n    return new Iterator(this, container_.end());\n  }\n\n private:\n  typedef typename ::std::vector<T> ContainerType;\n\n  class Iterator : public ParamIteratorInterface<T> {\n   public:\n    Iterator(const ParamGeneratorInterface<T>* base,\n             typename ContainerType::const_iterator iterator)\n        : base_(base), iterator_(iterator) {}\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<T>* BaseGenerator() const {\n      return base_;\n    }\n    virtual void Advance() {\n      ++iterator_;\n      value_.reset();\n    }\n    virtual ParamIteratorInterface<T>* Clone() const {\n      return new Iterator(*this);\n    }\n    // We need to use cached value referenced by iterator_ because *iterator_\n    // can return a temporary object (and of type other then T), so just\n    // having \"return &*iterator_;\" doesn't work.\n    // value_ is updated here and not in Advance() because Advance()\n    // can advance iterator_ beyond the end of the range, and we cannot\n    // detect that fact. The client code, on the other hand, is\n    // responsible for not calling Current() on an out-of-range iterator.\n    virtual const T* Current() const {\n      if (value_.get() == NULL)\n        value_.reset(new T(*iterator_));\n      return value_.get();\n    }\n    virtual bool Equals(const ParamIteratorInterface<T>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      return iterator_ ==\n          CheckedDowncastToActualType<const Iterator>(&other)->iterator_;\n    }\n\n   private:\n    Iterator(const Iterator& other)\n          // The explicit constructor call suppresses a false warning\n          // emitted by gcc when supplied with the -Wextra option.\n        : ParamIteratorInterface<T>(),\n          base_(other.base_),\n          iterator_(other.iterator_) {}\n\n    const ParamGeneratorInterface<T>* const base_;\n    typename ContainerType::const_iterator iterator_;\n    // A cached value of *iterator_. We keep it here to allow access by\n    // pointer in the wrapping iterator's operator->().\n    // value_ needs to be mutable to be accessed in Current().\n    // Use of scoped_ptr helps manage cached value's lifetime,\n    // which is bound by the lifespan of the iterator itself.\n    mutable scoped_ptr<const T> value_;\n  };  // class ValuesInIteratorRangeGenerator::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const ValuesInIteratorRangeGenerator& other);\n\n  const ContainerType container_;\n};  // class ValuesInIteratorRangeGenerator\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Default parameterized test name generator, returns a string containing the\n// integer test parameter index.\ntemplate <class ParamType>\nstd::string DefaultParamName(const TestParamInfo<ParamType>& info) {\n  Message name_stream;\n  name_stream << info.index;\n  return name_stream.GetString();\n}\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Parameterized test name overload helpers, which help the\n// INSTANTIATE_TEST_CASE_P macro choose between the default parameterized\n// test name generator and user param name generator.\ntemplate <class ParamType, class ParamNameGenFunctor>\nParamNameGenFunctor GetParamNameGen(ParamNameGenFunctor func) {\n  return func;\n}\n\ntemplate <class ParamType>\nstruct ParamNameGenFunc {\n  typedef std::string Type(const TestParamInfo<ParamType>&);\n};\n\ntemplate <class ParamType>\ntypename ParamNameGenFunc<ParamType>::Type *GetParamNameGen() {\n  return DefaultParamName;\n}\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Stores a parameter value and later creates tests parameterized with that\n// value.\ntemplate <class TestClass>\nclass ParameterizedTestFactory : public TestFactoryBase {\n public:\n  typedef typename TestClass::ParamType ParamType;\n  explicit ParameterizedTestFactory(ParamType parameter) :\n      parameter_(parameter) {}\n  virtual Test* CreateTest() {\n    TestClass::SetParam(&parameter_);\n    return new TestClass();\n  }\n\n private:\n  const ParamType parameter_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestFactory);\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// TestMetaFactoryBase is a base class for meta-factories that create\n// test factories for passing into MakeAndRegisterTestInfo function.\ntemplate <class ParamType>\nclass TestMetaFactoryBase {\n public:\n  virtual ~TestMetaFactoryBase() {}\n\n  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) = 0;\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// TestMetaFactory creates test factories for passing into\n// MakeAndRegisterTestInfo function. Since MakeAndRegisterTestInfo receives\n// ownership of test factory pointer, same factory object cannot be passed\n// into that method twice. But ParameterizedTestCaseInfo is going to call\n// it for each Test/Parameter value combination. Thus it needs meta factory\n// creator class.\ntemplate <class TestCase>\nclass TestMetaFactory\n    : public TestMetaFactoryBase<typename TestCase::ParamType> {\n public:\n  typedef typename TestCase::ParamType ParamType;\n\n  TestMetaFactory() {}\n\n  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) {\n    return new ParameterizedTestFactory<TestCase>(parameter);\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestMetaFactory);\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestCaseInfoBase is a generic interface\n// to ParameterizedTestCaseInfo classes. ParameterizedTestCaseInfoBase\n// accumulates test information provided by TEST_P macro invocations\n// and generators provided by INSTANTIATE_TEST_CASE_P macro invocations\n// and uses that information to register all resulting test instances\n// in RegisterTests method. The ParameterizeTestCaseRegistry class holds\n// a collection of pointers to the ParameterizedTestCaseInfo objects\n// and calls RegisterTests() on each of them when asked.\nclass ParameterizedTestCaseInfoBase {\n public:\n  virtual ~ParameterizedTestCaseInfoBase() {}\n\n  // Base part of test case name for display purposes.\n  virtual const string& GetTestCaseName() const = 0;\n  // Test case id to verify identity.\n  virtual TypeId GetTestCaseTypeId() const = 0;\n  // UnitTest class invokes this method to register tests in this\n  // test case right before running them in RUN_ALL_TESTS macro.\n  // This method should not be called more then once on any single\n  // instance of a ParameterizedTestCaseInfoBase derived class.\n  virtual void RegisterTests() = 0;\n\n protected:\n  ParameterizedTestCaseInfoBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfoBase);\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestCaseInfo accumulates tests obtained from TEST_P\n// macro invocations for a particular test case and generators\n// obtained from INSTANTIATE_TEST_CASE_P macro invocations for that\n// test case. It registers tests with all values generated by all\n// generators when asked.\ntemplate <class TestCase>\nclass ParameterizedTestCaseInfo : public ParameterizedTestCaseInfoBase {\n public:\n  // ParamType and GeneratorCreationFunc are private types but are required\n  // for declarations of public methods AddTestPattern() and\n  // AddTestCaseInstantiation().\n  typedef typename TestCase::ParamType ParamType;\n  // A function that returns an instance of appropriate generator type.\n  typedef ParamGenerator<ParamType>(GeneratorCreationFunc)();\n  typedef typename ParamNameGenFunc<ParamType>::Type ParamNameGeneratorFunc;\n\n  explicit ParameterizedTestCaseInfo(\n      const char* name, CodeLocation code_location)\n      : test_case_name_(name), code_location_(code_location) {}\n\n  // Test case base name for display purposes.\n  virtual const string& GetTestCaseName() const { return test_case_name_; }\n  // Test case id to verify identity.\n  virtual TypeId GetTestCaseTypeId() const { return GetTypeId<TestCase>(); }\n  // TEST_P macro uses AddTestPattern() to record information\n  // about a single test in a LocalTestInfo structure.\n  // test_case_name is the base name of the test case (without invocation\n  // prefix). test_base_name is the name of an individual test without\n  // parameter index. For the test SequenceA/FooTest.DoBar/1 FooTest is\n  // test case base name and DoBar is test base name.\n  void AddTestPattern(const char* test_case_name,\n                      const char* test_base_name,\n                      TestMetaFactoryBase<ParamType>* meta_factory) {\n    tests_.push_back(linked_ptr<TestInfo>(new TestInfo(test_case_name,\n                                                       test_base_name,\n                                                       meta_factory)));\n  }\n  // INSTANTIATE_TEST_CASE_P macro uses AddGenerator() to record information\n  // about a generator.\n  int AddTestCaseInstantiation(const string& instantiation_name,\n                               GeneratorCreationFunc* func,\n                               ParamNameGeneratorFunc* name_func,\n                               const char* file,\n                               int line) {\n    instantiations_.push_back(\n        InstantiationInfo(instantiation_name, func, name_func, file, line));\n    return 0;  // Return value used only to run this method in namespace scope.\n  }\n  // UnitTest class invokes this method to register tests in this test case\n  // test cases right before running tests in RUN_ALL_TESTS macro.\n  // This method should not be called more then once on any single\n  // instance of a ParameterizedTestCaseInfoBase derived class.\n  // UnitTest has a guard to prevent from calling this method more then once.\n  virtual void RegisterTests() {\n    for (typename TestInfoContainer::iterator test_it = tests_.begin();\n         test_it != tests_.end(); ++test_it) {\n      linked_ptr<TestInfo> test_info = *test_it;\n      for (typename InstantiationContainer::iterator gen_it =\n               instantiations_.begin(); gen_it != instantiations_.end();\n               ++gen_it) {\n        const string& instantiation_name = gen_it->name;\n        ParamGenerator<ParamType> generator((*gen_it->generator)());\n        ParamNameGeneratorFunc* name_func = gen_it->name_func;\n        const char* file = gen_it->file;\n        int line = gen_it->line;\n\n        string test_case_name;\n        if ( !instantiation_name.empty() )\n          test_case_name = instantiation_name + \"/\";\n        test_case_name += test_info->test_case_base_name;\n\n        size_t i = 0;\n        std::set<std::string> test_param_names;\n        for (typename ParamGenerator<ParamType>::iterator param_it =\n                 generator.begin();\n             param_it != generator.end(); ++param_it, ++i) {\n          Message test_name_stream;\n\n          std::string param_name = name_func(\n              TestParamInfo<ParamType>(*param_it, i));\n\n          GTEST_CHECK_(IsValidParamName(param_name))\n              << \"Parameterized test name '\" << param_name\n              << \"' is invalid, in \" << file\n              << \" line \" << line << std::endl;\n\n          GTEST_CHECK_(test_param_names.count(param_name) == 0)\n              << \"Duplicate parameterized test name '\" << param_name\n              << \"', in \" << file << \" line \" << line << std::endl;\n\n          test_param_names.insert(param_name);\n\n          test_name_stream << test_info->test_base_name << \"/\" << param_name;\n          MakeAndRegisterTestInfo(\n              test_case_name.c_str(),\n              test_name_stream.GetString().c_str(),\n              NULL,  // No type parameter.\n              PrintToString(*param_it).c_str(),\n              code_location_,\n              GetTestCaseTypeId(),\n              TestCase::SetUpTestCase,\n              TestCase::TearDownTestCase,\n              test_info->test_meta_factory->CreateTestFactory(*param_it));\n        }  // for param_it\n      }  // for gen_it\n    }  // for test_it\n  }  // RegisterTests\n\n private:\n  // LocalTestInfo structure keeps information about a single test registered\n  // with TEST_P macro.\n  struct TestInfo {\n    TestInfo(const char* a_test_case_base_name,\n             const char* a_test_base_name,\n             TestMetaFactoryBase<ParamType>* a_test_meta_factory) :\n        test_case_base_name(a_test_case_base_name),\n        test_base_name(a_test_base_name),\n        test_meta_factory(a_test_meta_factory) {}\n\n    const string test_case_base_name;\n    const string test_base_name;\n    const scoped_ptr<TestMetaFactoryBase<ParamType> > test_meta_factory;\n  };\n  typedef ::std::vector<linked_ptr<TestInfo> > TestInfoContainer;\n  // Records data received from INSTANTIATE_TEST_CASE_P macros:\n  //  <Instantiation name, Sequence generator creation function,\n  //     Name generator function, Source file, Source line>\n  struct InstantiationInfo {\n      InstantiationInfo(const std::string &name_in,\n                        GeneratorCreationFunc* generator_in,\n                        ParamNameGeneratorFunc* name_func_in,\n                        const char* file_in,\n                        int line_in)\n          : name(name_in),\n            generator(generator_in),\n            name_func(name_func_in),\n            file(file_in),\n            line(line_in) {}\n\n      std::string name;\n      GeneratorCreationFunc* generator;\n      ParamNameGeneratorFunc* name_func;\n      const char* file;\n      int line;\n  };\n  typedef ::std::vector<InstantiationInfo> InstantiationContainer;\n\n  static bool IsValidParamName(const std::string& name) {\n    // Check for empty string\n    if (name.empty())\n      return false;\n\n    // Check for invalid characters\n    for (std::string::size_type index = 0; index < name.size(); ++index) {\n      if (!isalnum(name[index]) && name[index] != '_')\n        return false;\n    }\n\n    return true;\n  }\n\n  const string test_case_name_;\n  CodeLocation code_location_;\n  TestInfoContainer tests_;\n  InstantiationContainer instantiations_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfo);\n};  // class ParameterizedTestCaseInfo\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestCaseRegistry contains a map of ParameterizedTestCaseInfoBase\n// classes accessed by test case names. TEST_P and INSTANTIATE_TEST_CASE_P\n// macros use it to locate their corresponding ParameterizedTestCaseInfo\n// descriptors.\nclass ParameterizedTestCaseRegistry {\n public:\n  ParameterizedTestCaseRegistry() {}\n  ~ParameterizedTestCaseRegistry() {\n    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\n         it != test_case_infos_.end(); ++it) {\n      delete *it;\n    }\n  }\n\n  // Looks up or creates and returns a structure containing information about\n  // tests and instantiations of a particular test case.\n  template <class TestCase>\n  ParameterizedTestCaseInfo<TestCase>* GetTestCasePatternHolder(\n      const char* test_case_name,\n      CodeLocation code_location) {\n    ParameterizedTestCaseInfo<TestCase>* typed_test_info = NULL;\n    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\n         it != test_case_infos_.end(); ++it) {\n      if ((*it)->GetTestCaseName() == test_case_name) {\n        if ((*it)->GetTestCaseTypeId() != GetTypeId<TestCase>()) {\n          // Complain about incorrect usage of Google Test facilities\n          // and terminate the program since we cannot guaranty correct\n          // test case setup and tear-down in this case.\n          ReportInvalidTestCaseType(test_case_name, code_location);\n          posix::Abort();\n        } else {\n          // At this point we are sure that the object we found is of the same\n          // type we are looking for, so we downcast it to that type\n          // without further checks.\n          typed_test_info = CheckedDowncastToActualType<\n              ParameterizedTestCaseInfo<TestCase> >(*it);\n        }\n        break;\n      }\n    }\n    if (typed_test_info == NULL) {\n      typed_test_info = new ParameterizedTestCaseInfo<TestCase>(\n          test_case_name, code_location);\n      test_case_infos_.push_back(typed_test_info);\n    }\n    return typed_test_info;\n  }\n  void RegisterTests() {\n    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\n         it != test_case_infos_.end(); ++it) {\n      (*it)->RegisterTests();\n    }\n  }\n\n private:\n  typedef ::std::vector<ParameterizedTestCaseInfoBase*> TestCaseInfoContainer;\n\n  TestCaseInfoContainer test_case_infos_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseRegistry);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  //  GTEST_HAS_PARAM_TEST\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port-arch.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the GTEST_OS_* macro.\n// It is separate from gtest-port.h so that custom/gtest-port.h can include it.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_\n\n// Determines the platform on which Google Test is compiled.\n#ifdef __CYGWIN__\n# define GTEST_OS_CYGWIN 1\n#elif defined __SYMBIAN32__\n# define GTEST_OS_SYMBIAN 1\n#elif defined _WIN32\n# define GTEST_OS_WINDOWS 1\n# ifdef _WIN32_WCE\n#  define GTEST_OS_WINDOWS_MOBILE 1\n# elif defined(__MINGW__) || defined(__MINGW32__)\n#  define GTEST_OS_WINDOWS_MINGW 1\n# elif defined(WINAPI_FAMILY)\n#  include <winapifamily.h>\n#  if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)\n#   define GTEST_OS_WINDOWS_DESKTOP 1\n#  elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PHONE_APP)\n#   define GTEST_OS_WINDOWS_PHONE 1\n#  elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)\n#   define GTEST_OS_WINDOWS_RT 1\n#  else\n    // WINAPI_FAMILY defined but no known partition matched.\n    // Default to desktop.\n#   define GTEST_OS_WINDOWS_DESKTOP 1\n#  endif\n# else\n#  define GTEST_OS_WINDOWS_DESKTOP 1\n# endif  // _WIN32_WCE\n#elif defined __APPLE__\n# define GTEST_OS_MAC 1\n# if TARGET_OS_IPHONE\n#  define GTEST_OS_IOS 1\n# endif\n#elif defined __FreeBSD__\n# define GTEST_OS_FREEBSD 1\n#elif defined __linux__\n# define GTEST_OS_LINUX 1\n# if defined __ANDROID__\n#  define GTEST_OS_LINUX_ANDROID 1\n# endif\n#elif defined __MVS__\n# define GTEST_OS_ZOS 1\n#elif defined(__sun) && defined(__SVR4)\n# define GTEST_OS_SOLARIS 1\n#elif defined(_AIX)\n# define GTEST_OS_AIX 1\n#elif defined(__hpux)\n# define GTEST_OS_HPUX 1\n#elif defined __native_client__\n# define GTEST_OS_NACL 1\n#elif defined __NetBSD__\n# define GTEST_OS_NETBSD 1\n#elif defined __OpenBSD__\n# define GTEST_OS_OPENBSD 1\n#elif defined __QNX__\n# define GTEST_OS_QNX 1\n#elif defined(__HAIKU__)\n# define GTEST_OS_HAIKU 1\n#elif defined(_MINIX)\n# define GTEST_OS_MINIX 1\n#endif  // __CYGWIN__\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan)\n//\n// Low-level types and utilities for porting Google Test to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don't\n// end with _ are part of Google Test's public API and can be used by\n// code outside Google Test.\n//\n// This file is fundamental to Google Test.  All other Google Test source\n// files are expected to #include this.  Therefore, it cannot #include\n// any other Google Test header.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n\n// Environment-describing macros\n// -----------------------------\n//\n// Google Test can be used in many different environments.  Macros in\n// this section tell Google Test what kind of environment it is being\n// used in, such that Google Test can provide environment-specific\n// features and implementations.\n//\n// Google Test tries to automatically detect the properties of its\n// environment, so users usually don't need to worry about these\n// macros.  However, the automatic detection is not perfect.\n// Sometimes it's necessary for a user to define some of the following\n// macros in the build script to override Google Test's decisions.\n//\n// If the user doesn't define a macro in the list, Google Test will\n// provide a default definition.  After this header is #included, all\n// macros in this list will be defined to either 1 or 0.\n//\n// Notes to maintainers:\n//   - Each macro here is a user-tweakable knob; do not grow the list\n//     lightly.\n//   - Use #if to key off these macros.  Don't use #ifdef or \"#if\n//     defined(...)\", which will not work as these macros are ALWAYS\n//     defined.\n//\n//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)\n//                              is/isn't available.\n//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions\n//                              are enabled.\n//   GTEST_HAS_GLOBAL_STRING  - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::string, which is different to std::string).\n//   GTEST_HAS_GLOBAL_WSTRING - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::wstring, which is different to std::wstring).\n//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular\n//                              expressions are/aren't available.\n//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that <pthread.h>\n//                              is/isn't available.\n//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn't\n//                              enabled.\n//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that\n//                              std::wstring does/doesn't work (Google Test can\n//                              be used where std::wstring is unavailable).\n//   GTEST_HAS_TR1_TUPLE      - Define it to 1/0 to indicate tr1::tuple\n//                              is/isn't available.\n//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the\n//                              compiler supports Microsoft's \"Structured\n//                              Exception Handling\".\n//   GTEST_HAS_STREAM_REDIRECTION\n//                            - Define it to 1/0 to indicate whether the\n//                              platform supports I/O stream redirection using\n//                              dup() and dup2().\n//   GTEST_USE_OWN_TR1_TUPLE  - Define it to 1/0 to indicate whether Google\n//                              Test's own tr1 tuple implementation should be\n//                              used.  Unused when the user sets\n//                              GTEST_HAS_TR1_TUPLE to 0.\n//   GTEST_LANG_CXX11         - Define it to 1/0 to indicate that Google Test\n//                              is building in C++11/C++98 mode.\n//   GTEST_LINKED_AS_SHARED_LIBRARY\n//                            - Define to 1 when compiling tests that use\n//                              Google Test as a shared library (known as\n//                              DLL on Windows).\n//   GTEST_CREATE_SHARED_LIBRARY\n//                            - Define to 1 when compiling Google Test itself\n//                              as a shared library.\n\n// Platform-indicating macros\n// --------------------------\n//\n// Macros indicating the platform on which Google Test is being used\n// (a macro is defined to 1 if compiled on the given platform;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n//   GTEST_OS_AIX      - IBM AIX\n//   GTEST_OS_CYGWIN   - Cygwin\n//   GTEST_OS_FREEBSD  - FreeBSD\n//   GTEST_OS_HAIKU    - Haiku\n//   GTEST_OS_HPUX     - HP-UX\n//   GTEST_OS_LINUX    - Linux\n//     GTEST_OS_LINUX_ANDROID - Google Android\n//   GTEST_OS_MAC      - Mac OS X\n//     GTEST_OS_IOS    - iOS\n//   GTEST_OS_MINIX    - Minix\n//   GTEST_OS_NACL     - Google Native Client (NaCl)\n//   GTEST_OS_OPENBSD  - OpenBSD\n//   GTEST_OS_QNX      - QNX\n//   GTEST_OS_SOLARIS  - Sun Solaris\n//   GTEST_OS_SYMBIAN  - Symbian\n//   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)\n//     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop\n//     GTEST_OS_WINDOWS_MINGW    - MinGW\n//     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile\n//     GTEST_OS_WINDOWS_PHONE    - Windows Phone\n//     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT\n//   GTEST_OS_ZOS      - z/OS\n//\n// Among the platforms, Cygwin, Linux, Max OS X, and Windows have the\n// most stable support.  Since core members of the Google Test project\n// don't have access to other platforms, support for them may be less\n// stable.  If you notice any problems on your platform, please notify\n// googletestframework@googlegroups.com (patches for fixing them are\n// even more welcome!).\n//\n// It is possible that none of the GTEST_OS_* macros are defined.\n\n// Feature-indicating macros\n// -------------------------\n//\n// Macros indicating which Google Test features are available (a macro\n// is defined to 1 if the corresponding feature is supported;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n// These macros are public so that portable tests can be written.\n// Such tests typically surround code using a feature with an #if\n// which controls that code.  For example:\n//\n// #if GTEST_HAS_DEATH_TEST\n//   EXPECT_DEATH(DoSomethingDeadly());\n// #endif\n//\n//   GTEST_HAS_COMBINE      - the Combine() function (for value-parameterized\n//                            tests)\n//   GTEST_HAS_DEATH_TEST   - death tests\n//   GTEST_HAS_PARAM_TEST   - value-parameterized tests\n//   GTEST_HAS_TYPED_TEST   - typed tests\n//   GTEST_HAS_TYPED_TEST_P - type-parameterized tests\n//   GTEST_IS_THREADSAFE    - Google Test is thread-safe.\n//   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with\n//                            GTEST_HAS_POSIX_RE (see above) which users can\n//                            define themselves.\n//   GTEST_USES_SIMPLE_RE   - our own simple regex is used;\n//                            the above two are mutually exclusive.\n//   GTEST_CAN_COMPARE_NULL - accepts untyped NULL in EXPECT_EQ().\n\n// Misc public macros\n// ------------------\n//\n//   GTEST_FLAG(flag_name)  - references the variable corresponding to\n//                            the given Google Test flag.\n\n// Internal utilities\n// ------------------\n//\n// The following macros and utilities are for Google Test's INTERNAL\n// use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.\n//\n// Macros for basic C++ coding:\n//   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.\n//   GTEST_ATTRIBUTE_UNUSED_  - declares that a class' instances or a\n//                              variable don't have to be used.\n//   GTEST_DISALLOW_ASSIGN_   - disables operator=.\n//   GTEST_DISALLOW_COPY_AND_ASSIGN_ - disables copy ctor and operator=.\n//   GTEST_MUST_USE_RESULT_   - declares that a function's result must be used.\n//   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is\n//                                        suppressed (constant conditional).\n//   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127\n//                                        is suppressed.\n//\n// C++11 feature wrappers:\n//\n//   testing::internal::move  - portability wrapper for std::move.\n//\n// Synchronization:\n//   Mutex, MutexLock, ThreadLocal, GetThreadCount()\n//                            - synchronization primitives.\n//\n// Template meta programming:\n//   is_pointer     - as in TR1; needed on Symbian and IBM XL C/C++ only.\n//   IteratorTraits - partial implementation of std::iterator_traits, which\n//                    is not available in libCstd when compiled with Sun C++.\n//\n// Smart pointers:\n//   scoped_ptr     - as in TR2.\n//\n// Regular expressions:\n//   RE             - a simple regular expression class using the POSIX\n//                    Extended Regular Expression syntax on UNIX-like\n//                    platforms, or a reduced regular exception syntax on\n//                    other platforms, including Windows.\n//\n// Logging:\n//   GTEST_LOG_()   - logs messages at the specified severity level.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n//\n// Stdout and stderr capturing:\n//   CaptureStdout()     - starts capturing stdout.\n//   GetCapturedStdout() - stops capturing stdout and returns the captured\n//                         string.\n//   CaptureStderr()     - starts capturing stderr.\n//   GetCapturedStderr() - stops capturing stderr and returns the captured\n//                         string.\n//\n// Integer types:\n//   TypeWithSize   - maps an integer to a int type.\n//   Int32, UInt32, Int64, UInt64, TimeInMillis\n//                  - integers of known sizes.\n//   BiggestInt     - the biggest signed integer type.\n//\n// Command-line utilities:\n//   GTEST_DECLARE_*()  - declares a flag.\n//   GTEST_DEFINE_*()   - defines a flag.\n//   GetInjectableArgvs() - returns the command line as a vector of strings.\n//\n// Environment variable utilities:\n//   GetEnv()             - gets the value of an environment variable.\n//   BoolFromGTestEnv()   - parses a bool environment variable.\n//   Int32FromGTestEnv()  - parses an Int32 environment variable.\n//   StringFromGTestEnv() - parses a string environment variable.\n\n#include <ctype.h>   // for isspace, etc\n#include <stddef.h>  // for ptrdiff_t\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#ifndef _WIN32_WCE\n# include <sys/types.h>\n# include <sys/stat.h>\n#endif  // !_WIN32_WCE\n\n#if defined __APPLE__\n# include <AvailabilityMacros.h>\n# include <TargetConditionals.h>\n#endif\n\n#include <algorithm>  // NOLINT\n#include <iostream>  // NOLINT\n#include <sstream>  // NOLINT\n#include <string>  // NOLINT\n#include <utility>\n#include <vector>  // NOLINT\n\n#include \"gtest/internal/gtest-port-arch.h\"\n#include \"gtest/internal/custom/gtest-port.h\"\n\n#if !defined(GTEST_DEV_EMAIL_)\n# define GTEST_DEV_EMAIL_ \"googletestframework@@googlegroups.com\"\n# define GTEST_FLAG_PREFIX_ \"gtest_\"\n# define GTEST_FLAG_PREFIX_DASH_ \"gtest-\"\n# define GTEST_FLAG_PREFIX_UPPER_ \"GTEST_\"\n# define GTEST_NAME_ \"Google Test\"\n# define GTEST_PROJECT_URL_ \"https://github.com/google/googletest/\"\n#endif  // !defined(GTEST_DEV_EMAIL_)\n\n#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n# define GTEST_INIT_GOOGLE_TEST_NAME_ \"testing::InitGoogleTest\"\n#endif  // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n\n// Determines the version of gcc that is used to compile this.\n#ifdef __GNUC__\n// 40302 means version 4.3.2.\n# define GTEST_GCC_VER_ \\\n    (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__)\n#endif  // __GNUC__\n\n// Macros for disabling Microsoft Visual C++ warnings.\n//\n//   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)\n//   /* code that triggers warnings C4800 and C4385 */\n//   GTEST_DISABLE_MSC_WARNINGS_POP_()\n#if _MSC_VER >= 1500\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\\n    __pragma(warning(push))                        \\\n    __pragma(warning(disable: warnings))\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()          \\\n    __pragma(warning(pop))\n#else\n// Older versions of MSVC don't have __pragma.\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n#ifndef GTEST_LANG_CXX11\n// gcc and clang define __GXX_EXPERIMENTAL_CXX0X__ when\n// -std={c,gnu}++{0x,11} is passed.  The C++11 standard specifies a\n// value for __cplusplus, and recent versions of clang, gcc, and\n// probably other compilers set that too in C++11 mode.\n# if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus >= 201103L\n// Compiling in at least C++11 mode.\n#  define GTEST_LANG_CXX11 1\n# else\n#  define GTEST_LANG_CXX11 0\n# endif\n#endif\n\n// Distinct from C++11 language support, some environments don't provide\n// proper C++11 library support. Notably, it's possible to build in\n// C++11 mode when targeting Mac OS X 10.6, which has an old libstdc++\n// with no C++11 support.\n//\n// libstdc++ has sufficient C++11 support as of GCC 4.6.0, __GLIBCXX__\n// 20110325, but maintenance releases in the 4.4 and 4.5 series followed\n// this date, so check for those versions by their date stamps.\n// https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html#abi.versioning\n#if GTEST_LANG_CXX11 && \\\n    (!defined(__GLIBCXX__) || ( \\\n        __GLIBCXX__ >= 20110325ul &&  /* GCC >= 4.6.0 */ \\\n        /* Exclude patch releases of older branches: */ \\\n        __GLIBCXX__ != 20110416ul &&  /* GCC 4.4.6 */ \\\n        __GLIBCXX__ != 20120313ul &&  /* GCC 4.4.7 */ \\\n        __GLIBCXX__ != 20110428ul &&  /* GCC 4.5.3 */ \\\n        __GLIBCXX__ != 20120702ul))   /* GCC 4.5.4 */\n# define GTEST_STDLIB_CXX11 1\n#endif\n\n// Only use C++11 library features if the library provides them.\n#if GTEST_STDLIB_CXX11\n# define GTEST_HAS_STD_BEGIN_AND_END_ 1\n# define GTEST_HAS_STD_FORWARD_LIST_ 1\n# define GTEST_HAS_STD_FUNCTION_ 1\n# define GTEST_HAS_STD_INITIALIZER_LIST_ 1\n# define GTEST_HAS_STD_MOVE_ 1\n# define GTEST_HAS_STD_SHARED_PTR_ 1\n# define GTEST_HAS_STD_TYPE_TRAITS_ 1\n# define GTEST_HAS_STD_UNIQUE_PTR_ 1\n#endif\n\n// C++11 specifies that <tuple> provides std::tuple.\n// Some platforms still might not have it, however.\n#if GTEST_LANG_CXX11\n# define GTEST_HAS_STD_TUPLE_ 1\n# if defined(__clang__)\n// Inspired by http://clang.llvm.org/docs/LanguageExtensions.html#__has_include\n#  if defined(__has_include) && !__has_include(<tuple>)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(_MSC_VER)\n// Inspired by boost/config/stdlib/dinkumware.hpp\n#  if defined(_CPPLIB_VER) && _CPPLIB_VER < 520\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(__GLIBCXX__)\n// Inspired by boost/config/stdlib/libstdcpp3.hpp,\n// http://gcc.gnu.org/gcc-4.2/changes.html and\n// http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01.html#manual.intro.status.standard.200x\n#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# endif\n#endif\n\n// Brings in definitions for functions used in the testing::internal::posix\n// namespace (read, write, close, chdir, isatty, stat). We do not currently\n// use them on Windows Mobile.\n#if GTEST_OS_WINDOWS\n# if !GTEST_OS_WINDOWS_MOBILE\n#  include <direct.h>\n#  include <io.h>\n# endif\n// In order to avoid having to include <windows.h>, use forward declaration\n// assuming CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.\n// This assumption is verified by\n// WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.\nstruct _RTL_CRITICAL_SECTION;\n#else\n// This assumes that non-Windows OSes provide unistd.h. For OSes where this\n// is not the case, we need to include headers that provide the functions\n// mentioned above.\n# include <unistd.h>\n# include <strings.h>\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_LINUX_ANDROID\n// Used to define __ANDROID_API__ matching the target NDK API level.\n#  include <android/api-level.h>  // NOLINT\n#endif\n\n// Defines this to true iff Google Test can use POSIX regular expressions.\n#ifndef GTEST_HAS_POSIX_RE\n# if GTEST_OS_LINUX_ANDROID\n// On Android, <regex.h> is only available starting with Gingerbread.\n#  define GTEST_HAS_POSIX_RE (__ANDROID_API__ >= 9)\n# else\n#  define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS)\n# endif\n#endif\n\n#if GTEST_USES_PCRE\n// The appropriate headers have already been included.\n\n#elif GTEST_HAS_POSIX_RE\n\n// On some platforms, <regex.h> needs someone to define size_t, and\n// won't compile otherwise.  We can #include it here as we already\n// included <stdlib.h>, which is guaranteed to define size_t through\n// <stddef.h>.\n# include <regex.h>  // NOLINT\n\n# define GTEST_USES_POSIX_RE 1\n\n#elif GTEST_OS_WINDOWS\n\n// <regex.h> is not available on Windows.  Use our own simple regex\n// implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#else\n\n// <regex.h> may not be available on this platform.  Use our own\n// simple regex implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#endif  // GTEST_USES_PCRE\n\n#ifndef GTEST_HAS_EXCEPTIONS\n// The user didn't tell us whether exceptions are enabled, so we need\n// to figure it out.\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// MSVC's and C++Builder's implementations of the STL use the _HAS_EXCEPTIONS\n// macro to enable exceptions, so we'll do the same.\n// Assumes that exceptions are enabled by default.\n#  ifndef _HAS_EXCEPTIONS\n#   define _HAS_EXCEPTIONS 1\n#  endif  // _HAS_EXCEPTIONS\n#  define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS\n# elif defined(__clang__)\n// clang defines __EXCEPTIONS iff exceptions are enabled before clang 220714,\n// but iff cleanups are enabled after that. In Obj-C++ files, there can be\n// cleanups for ObjC exceptions which also need cleanups, even if C++ exceptions\n// are disabled. clang has __has_feature(cxx_exceptions) which checks for C++\n// exceptions starting at clang r206352, but which checked for cleanups prior to\n// that. To reliably check for C++ exception availability with clang, check for\n// __EXCEPTIONS && __has_feature(cxx_exceptions).\n#  define GTEST_HAS_EXCEPTIONS (__EXCEPTIONS && __has_feature(cxx_exceptions))\n# elif defined(__GNUC__) && __EXCEPTIONS\n// gcc defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__SUNPRO_CC)\n// Sun Pro CC supports exceptions.  However, there is no compile-time way of\n// detecting whether they are enabled or not.  Therefore, we assume that\n// they are enabled unless the user tells us otherwise.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__IBMCPP__) && __EXCEPTIONS\n// xlC defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__HP_aCC)\n// Exception handling is in effect by default in HP aCC compiler. It has to\n// be turned of by +noeh compiler option if desired.\n#  define GTEST_HAS_EXCEPTIONS 1\n# else\n// For other compilers, we assume exceptions are disabled to be\n// conservative.\n#  define GTEST_HAS_EXCEPTIONS 0\n# endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#if !defined(GTEST_HAS_STD_STRING)\n// Even though we don't use this macro any longer, we keep it in case\n// some clients still depend on it.\n# define GTEST_HAS_STD_STRING 1\n#elif !GTEST_HAS_STD_STRING\n// The user told us that ::std::string isn't available.\n# error \"Google Test cannot be used where ::std::string isn't available.\"\n#endif  // !defined(GTEST_HAS_STD_STRING)\n\n#ifndef GTEST_HAS_GLOBAL_STRING\n// The user didn't tell us whether ::string is available, so we need\n// to figure it out.\n\n# define GTEST_HAS_GLOBAL_STRING 0\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#ifndef GTEST_HAS_STD_WSTRING\n// The user didn't tell us whether ::std::wstring is available, so we need\n// to figure it out.\n// TODO(wan@google.com): uses autoconf to detect whether ::std::wstring\n//   is available.\n\n// Cygwin 1.7 and below doesn't support ::std::wstring.\n// Solaris' libc++ doesn't support it either.  Android has\n// no support for it at least as recent as Froyo (2.2).\n// Minix currently doesn't support it either.\n# define GTEST_HAS_STD_WSTRING \\\n    (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || GTEST_OS_HAIKU || GTEST_OS_MINIX))\n\n#endif  // GTEST_HAS_STD_WSTRING\n\n#ifndef GTEST_HAS_GLOBAL_WSTRING\n// The user didn't tell us whether ::wstring is available, so we need\n// to figure it out.\n# define GTEST_HAS_GLOBAL_WSTRING \\\n    (GTEST_HAS_STD_WSTRING && GTEST_HAS_GLOBAL_STRING)\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// Determines whether RTTI is available.\n#ifndef GTEST_HAS_RTTI\n// The user didn't tell us whether RTTI is enabled, so we need to\n// figure it out.\n\n# ifdef _MSC_VER\n\n#  ifdef _CPPRTTI  // MSVC defines this macro iff RTTI is enabled.\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n// Starting with version 4.3.2, gcc defines __GXX_RTTI iff RTTI is enabled.\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40302)\n\n#  ifdef __GXX_RTTI\n// When building against STLport with the Android NDK and with\n// -frtti -fno-exceptions, the build fails at link time with undefined\n// references to __cxa_bad_typeid. Note sure if STL or toolchain bug,\n// so disable RTTI when detected.\n#   if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR) && \\\n       !defined(__EXCEPTIONS)\n#    define GTEST_HAS_RTTI 0\n#   else\n#    define GTEST_HAS_RTTI 1\n#   endif  // GTEST_OS_LINUX_ANDROID && __STLPORT_MAJOR && !__EXCEPTIONS\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif  // __GXX_RTTI\n\n// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends\n// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the\n// first version with C++ support.\n# elif defined(__clang__)\n\n#  define GTEST_HAS_RTTI __has_feature(cxx_rtti)\n\n// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if\n// both the typeid and dynamic_cast features are present.\n# elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)\n\n#  ifdef __RTTI_ALL__\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n# else\n\n// For all other compilers, we assume RTTI is enabled.\n#  define GTEST_HAS_RTTI 1\n\n# endif  // _MSC_VER\n\n#endif  // GTEST_HAS_RTTI\n\n// It's this header's responsibility to #include <typeinfo> when RTTI\n// is enabled.\n#if GTEST_HAS_RTTI\n# include <typeinfo>\n#endif\n\n// Determines whether Google Test can use the pthreads library.\n#ifndef GTEST_HAS_PTHREAD\n// The user didn't tell us explicitly, so we make reasonable assumptions about\n// which platforms have pthreads support.\n//\n// To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0\n// to your compiler flags.\n# define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \\\n    || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL)\n#endif  // GTEST_HAS_PTHREAD\n\n#if GTEST_HAS_PTHREAD\n// gtest-port.h guarantees to #include <pthread.h> when GTEST_HAS_PTHREAD is\n// true.\n# include <pthread.h>  // NOLINT\n\n// For timespec and nanosleep, used below.\n# include <time.h>  // NOLINT\n#endif\n\n// Determines if hash_map/hash_set are available.\n// Only used for testing against those containers.\n#if !defined(GTEST_HAS_HASH_MAP_)\n# if _MSC_VER\n#  define GTEST_HAS_HASH_MAP_ 1  // Indicates that hash_map is available.\n#  define GTEST_HAS_HASH_SET_ 1  // Indicates that hash_set is available.\n# endif  // _MSC_VER\n#endif  // !defined(GTEST_HAS_HASH_MAP_)\n\n// Determines whether Google Test can use tr1/tuple.  You can define\n// this macro to 0 to prevent Google Test from using tuple (any\n// feature depending on tuple with be disabled in this mode).\n#ifndef GTEST_HAS_TR1_TUPLE\n# if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)\n// STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.\n#  define GTEST_HAS_TR1_TUPLE 0\n# else\n// The user didn't tell us not to do it, so we assume it's OK.\n#  define GTEST_HAS_TR1_TUPLE 1\n# endif\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether Google Test's own tr1 tuple implementation\n// should be used.\n#ifndef GTEST_USE_OWN_TR1_TUPLE\n// The user didn't tell us, so we need to figure it out.\n\n// We use our own TR1 tuple if we aren't sure the user has an\n// implementation of it already.  At this time, libstdc++ 4.0.0+ and\n// MSVC 2010 are the only mainstream standard libraries that come\n// with a TR1 tuple implementation.  NVIDIA's CUDA NVCC compiler\n// pretends to be GCC by defining __GNUC__ and friends, but cannot\n// compile GCC's tuple implementation.  MSVC 2008 (9.0) provides TR1\n// tuple in a 323 MB Feature Pack download, which we cannot assume the\n// user has.  QNX's QCC compiler is a modified GCC but it doesn't\n// support TR1 tuple.  libc++ only provides std::tuple, in C++11 mode,\n// and it can be used with some compilers that define __GNUC__.\n# if (defined(__GNUC__) && !defined(__CUDACC__) && (GTEST_GCC_VER_ >= 40000) \\\n      && !GTEST_OS_QNX && !defined(_LIBCPP_VERSION)) || _MSC_VER >= 1600\n#  define GTEST_ENV_HAS_TR1_TUPLE_ 1\n# endif\n\n// C++11 specifies that <tuple> provides std::tuple. Use that if gtest is used\n// in C++11 mode and libstdc++ isn't very old (binaries targeting OS X 10.6\n// can build with clang but need to use gcc4.2's libstdc++).\n# if GTEST_LANG_CXX11 && (!defined(__GLIBCXX__) || __GLIBCXX__ > 20110325)\n#  define GTEST_ENV_HAS_STD_TUPLE_ 1\n# endif\n\n# if GTEST_ENV_HAS_TR1_TUPLE_ || GTEST_ENV_HAS_STD_TUPLE_\n#  define GTEST_USE_OWN_TR1_TUPLE 0\n# else\n#  define GTEST_USE_OWN_TR1_TUPLE 1\n# endif\n\n#endif  // GTEST_USE_OWN_TR1_TUPLE\n\n// To avoid conditional compilation everywhere, we make it\n// gtest-port.h's responsibility to #include the header implementing\n// tuple.\n#if GTEST_HAS_STD_TUPLE_\n# include <tuple>  // IWYU pragma: export\n# define GTEST_TUPLE_NAMESPACE_ ::std\n#endif  // GTEST_HAS_STD_TUPLE_\n\n// We include tr1::tuple even if std::tuple is available to define printers for\n// them.\n#if GTEST_HAS_TR1_TUPLE\n# ifndef GTEST_TUPLE_NAMESPACE_\n#  define GTEST_TUPLE_NAMESPACE_ ::std::tr1\n# endif  // GTEST_TUPLE_NAMESPACE_\n\n# if GTEST_USE_OWN_TR1_TUPLE\n#  include \"gtest/internal/gtest-tuple.h\"  // IWYU pragma: export  // NOLINT\n# elif GTEST_ENV_HAS_STD_TUPLE_\n#  include <tuple>\n// C++11 puts its tuple into the ::std namespace rather than\n// ::std::tr1.  gtest expects tuple to live in ::std::tr1, so put it there.\n// This causes undefined behavior, but supported compilers react in\n// the way we intend.\nnamespace std {\nnamespace tr1 {\nusing ::std::get;\nusing ::std::make_tuple;\nusing ::std::tuple;\nusing ::std::tuple_element;\nusing ::std::tuple_size;\n}\n}\n\n# elif GTEST_OS_SYMBIAN\n\n// On Symbian, BOOST_HAS_TR1_TUPLE causes Boost's TR1 tuple library to\n// use STLport's tuple implementation, which unfortunately doesn't\n// work as the copy of STLport distributed with Symbian is incomplete.\n// By making sure BOOST_HAS_TR1_TUPLE is undefined, we force Boost to\n// use its own tuple implementation.\n#  ifdef BOOST_HAS_TR1_TUPLE\n#   undef BOOST_HAS_TR1_TUPLE\n#  endif  // BOOST_HAS_TR1_TUPLE\n\n// This prevents <boost/tr1/detail/config.hpp>, which defines\n// BOOST_HAS_TR1_TUPLE, from being #included by Boost's <tuple>.\n#  define BOOST_TR1_DETAIL_CONFIG_HPP_INCLUDED\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)\n// GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header.  This does\n// not conform to the TR1 spec, which requires the header to be <tuple>.\n\n#  if !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n// Until version 4.3.2, gcc has a bug that causes <tr1/functional>,\n// which is #included by <tr1/tuple>, to not compile when RTTI is\n// disabled.  _TR1_FUNCTIONAL is the header guard for\n// <tr1/functional>.  Hence the following #define is a hack to prevent\n// <tr1/functional> from being included.\n#   define _TR1_FUNCTIONAL 1\n#   include <tr1/tuple>\n#   undef _TR1_FUNCTIONAL  // Allows the user to #include\n                        // <tr1/functional> if he chooses to.\n#  else\n#   include <tr1/tuple>  // NOLINT\n#  endif  // !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n\n# else\n// If the compiler is not GCC 4.0+, we assume the user is using a\n// spec-conforming TR1 implementation.\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n# endif  // GTEST_USE_OWN_TR1_TUPLE\n\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether clone(2) is supported.\n// Usually it will only be available on Linux, excluding\n// Linux on the Itanium architecture.\n// Also see http://linux.die.net/man/2/clone.\n#ifndef GTEST_HAS_CLONE\n// The user didn't tell us, so we need to figure it out.\n\n# if GTEST_OS_LINUX && !defined(__ia64__)\n#  if GTEST_OS_LINUX_ANDROID\n// On Android, clone() is only available on ARM starting with Gingerbread.\n#    if defined(__arm__) && __ANDROID_API__ >= 9\n#     define GTEST_HAS_CLONE 1\n#    else\n#     define GTEST_HAS_CLONE 0\n#    endif\n#  else\n#   define GTEST_HAS_CLONE 1\n#  endif\n# else\n#  define GTEST_HAS_CLONE 0\n# endif  // GTEST_OS_LINUX && !defined(__ia64__)\n\n#endif  // GTEST_HAS_CLONE\n\n// Determines whether to support stream redirection. This is used to test\n// output correctness and to implement death tests.\n#ifndef GTEST_HAS_STREAM_REDIRECTION\n// By default, we assume that stream redirection is supported on all\n// platforms except known mobile ones.\n# if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || \\\n    GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT\n#  define GTEST_HAS_STREAM_REDIRECTION 0\n# else\n#  define GTEST_HAS_STREAM_REDIRECTION 1\n# endif  // !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_SYMBIAN\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Determines whether to support death tests.\n// Google Test does not support death tests for VC 7.1 and earlier as\n// abort() in a VC 7.1 application compiled as GUI in debug config\n// pops up a dialog window that cannot be suppressed programmatically.\n#if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\\n     (GTEST_OS_MAC && !GTEST_OS_IOS) || \\\n     (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \\\n     GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \\\n     GTEST_OS_OPENBSD || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NETBSD)\n# define GTEST_HAS_DEATH_TEST 1\n#endif\n\n// We don't support MSVC 7.1 with exceptions disabled now.  Therefore\n// all the compilers we care about are adequate for supporting\n// value-parameterized tests.\n#define GTEST_HAS_PARAM_TEST 1\n\n// Determines whether to support type-driven tests.\n\n// Typed tests need <typeinfo> and variadic macros, which GCC, VC++ 8.0,\n// Sun Pro CC, IBM Visual Age, and HP aCC support.\n#if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__SUNPRO_CC) || \\\n    defined(__IBMCPP__) || defined(__HP_aCC)\n# define GTEST_HAS_TYPED_TEST 1\n# define GTEST_HAS_TYPED_TEST_P 1\n#endif\n\n// Determines whether to support Combine(). This only makes sense when\n// value-parameterized tests are enabled.  The implementation doesn't\n// work on Sun Studio since it doesn't understand templated conversion\n// operators.\n#if GTEST_HAS_PARAM_TEST && GTEST_HAS_TR1_TUPLE && !defined(__SUNPRO_CC)\n# define GTEST_HAS_COMBINE 1\n#endif\n\n// Determines whether the system compiler uses UTF-16 for encoding wide strings.\n#define GTEST_WIDE_STRING_USES_UTF16_ \\\n    (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)\n\n// Determines whether test results can be streamed to a socket.\n#if GTEST_OS_LINUX\n# define GTEST_CAN_STREAM_RESULTS_ 1\n#endif\n\n// Defines some utility macros.\n\n// The GNU compiler emits a warning if nested \"if\" statements are followed by\n// an \"else\" statement and braces are not used to explicitly disambiguate the\n// \"else\" binding.  This leads to problems with code like:\n//\n//   if (gate)\n//     ASSERT_*(condition) << \"Some message\";\n//\n// The \"switch (0) case 0:\" idiom is used to suppress this.\n#ifdef __INTEL_COMPILER\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_\n#else\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_ switch (0) case 0: default:  // NOLINT\n#endif\n\n// Use this annotation at the end of a struct/class definition to\n// prevent the compiler from optimizing away instances that are never\n// used.  This is useful when all interesting logic happens inside the\n// c'tor and / or d'tor.  Example:\n//\n//   struct Foo {\n//     Foo() { ... }\n//   } GTEST_ATTRIBUTE_UNUSED_;\n//\n// Also use it after a variable or parameter declaration to tell the\n// compiler the variable/parameter does not have to be used.\n#if defined(__GNUC__) && !defined(COMPILER_ICC)\n# define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n#elif defined(__clang__)\n# if __has_attribute(unused)\n#  define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n# endif\n#endif\n#ifndef GTEST_ATTRIBUTE_UNUSED_\n# define GTEST_ATTRIBUTE_UNUSED_\n#endif\n\n// A macro to disallow operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_ASSIGN_(type)\\\n  void operator=(type const &) = delete\n\n// A macro to disallow copy constructor and operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_COPY_AND_ASSIGN_(type)\\\n  type(type const &) = delete;\\\n  GTEST_DISALLOW_ASSIGN_(type)\n\n// Tell the compiler to warn about unused return values for functions declared\n// with this macro.  The macro should be used on function declarations\n// following the argument list:\n//\n//   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;\n#if defined(__GNUC__) && (GTEST_GCC_VER_ >= 30400) && !defined(COMPILER_ICC)\n# define GTEST_MUST_USE_RESULT_ __attribute__ ((warn_unused_result))\n#else\n# define GTEST_MUST_USE_RESULT_\n#endif  // __GNUC__ && (GTEST_GCC_VER_ >= 30400) && !COMPILER_ICC\n\n// MS C++ compiler emits warning when a conditional expression is compile time\n// constant. In some contexts this warning is false positive and needs to be\n// suppressed. Use the following two macros in such cases:\n//\n// GTEST_INTENTIONAL_CONST_COND_PUSH_()\n// while (true) {\n// GTEST_INTENTIONAL_CONST_COND_POP_()\n// }\n# define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\\n    GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)\n# define GTEST_INTENTIONAL_CONST_COND_POP_() \\\n    GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n// Determine whether the compiler supports Microsoft's Structured Exception\n// Handling.  This is supported by several Windows compilers but generally\n// does not exist on any other system.\n#ifndef GTEST_HAS_SEH\n// The user didn't tell us, so we need to figure it out.\n\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// These two compilers are known to support SEH.\n#  define GTEST_HAS_SEH 1\n# else\n// Assume no SEH.\n#  define GTEST_HAS_SEH 0\n# endif\n\n#endif  // GTEST_HAS_SEH\n\n#define GTEST_IS_THREADSAFE \\\n    (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \\\n     || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \\\n     || GTEST_HAS_PTHREAD)\n\n#ifdef _MSC_VER\n# if GTEST_LINKED_AS_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllimport)\n# elif GTEST_CREATE_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllexport)\n# endif\n#elif __GNUC__ >= 4 || defined(__clang__)\n# define GTEST_API_ __attribute__((visibility (\"default\")))\n#endif // _MSC_VER\n\n#ifndef GTEST_API_\n# define GTEST_API_\n#endif\n\n#ifdef __GNUC__\n// Ask the compiler to never inline a given function.\n# define GTEST_NO_INLINE_ __attribute__((noinline))\n#else\n# define GTEST_NO_INLINE_\n#endif\n\n// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.\n#if defined(__has_include)\n# if __has_include(<cxxabi.h>)\n#  define GTEST_HAS_CXXABI_H_ 1\n# else\n#  define GTEST_HAS_CXXABI_H_ 0\n# endif\n#elif defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)\n# define GTEST_HAS_CXXABI_H_ 1\n#else\n# define GTEST_HAS_CXXABI_H_ 0\n#endif\n\n// A function level attribute to disable checking for use of uninitialized\n// memory when built with MemorySanitizer.\n#if defined(__clang__)\n# if __has_feature(memory_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ \\\n       __attribute__((no_sanitize_memory))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n# endif  // __has_feature(memory_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif  // __clang__\n\n// A function level attribute to disable AddressSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(address_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\\n       __attribute__((no_sanitize_address))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n# endif  // __has_feature(address_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif  // __clang__\n\n// A function level attribute to disable ThreadSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(thread_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ \\\n       __attribute__((no_sanitize_thread))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n# endif  // __has_feature(thread_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif  // __clang__\n\nnamespace testing {\n\nclass Message;\n\n#if defined(GTEST_TUPLE_NAMESPACE_)\n// Import tuple and friends into the ::testing namespace.\n// It is part of our interface, having them in ::testing allows us to change\n// their types as needed.\nusing GTEST_TUPLE_NAMESPACE_::get;\nusing GTEST_TUPLE_NAMESPACE_::make_tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple_size;\nusing GTEST_TUPLE_NAMESPACE_::tuple_element;\n#endif  // defined(GTEST_TUPLE_NAMESPACE_)\n\nnamespace internal {\n\n// A secret type that Google Test users don't know about.  It has no\n// definition on purpose.  Therefore it's impossible to create a\n// Secret object, which is what we want.\nclass Secret;\n\n// The GTEST_COMPILE_ASSERT_ macro can be used to verify that a compile time\n// expression is true. For example, you could use it to verify the\n// size of a static array:\n//\n//   GTEST_COMPILE_ASSERT_(GTEST_ARRAY_SIZE_(names) == NUM_NAMES,\n//                         names_incorrect_size);\n//\n// or to make sure a struct is smaller than a certain size:\n//\n//   GTEST_COMPILE_ASSERT_(sizeof(foo) < 128, foo_too_large);\n//\n// The second argument to the macro is the name of the variable. If\n// the expression is false, most compilers will issue a warning/error\n// containing the name of the variable.\n\n#if GTEST_LANG_CXX11\n# define GTEST_COMPILE_ASSERT_(expr, msg) static_assert(expr, #msg)\n#else  // !GTEST_LANG_CXX11\ntemplate <bool>\n  struct CompileAssert {\n};\n\n# define GTEST_COMPILE_ASSERT_(expr, msg) \\\n  typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \\\n      msg[static_cast<bool>(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_\n#endif  // !GTEST_LANG_CXX11\n\n// Implementation details of GTEST_COMPILE_ASSERT_:\n//\n// (In C++11, we simply use static_assert instead of the following)\n//\n// - GTEST_COMPILE_ASSERT_ works by defining an array type that has -1\n//   elements (and thus is invalid) when the expression is false.\n//\n// - The simpler definition\n//\n//    #define GTEST_COMPILE_ASSERT_(expr, msg) typedef char msg[(expr) ? 1 : -1]\n//\n//   does not work, as gcc supports variable-length arrays whose sizes\n//   are determined at run-time (this is gcc's extension and not part\n//   of the C++ standard).  As a result, gcc fails to reject the\n//   following code with the simple definition:\n//\n//     int foo;\n//     GTEST_COMPILE_ASSERT_(foo, msg); // not supposed to compile as foo is\n//                                      // not a compile-time constant.\n//\n// - By using the type CompileAssert<(bool(expr))>, we ensures that\n//   expr is a compile-time constant.  (Template arguments must be\n//   determined at compile-time.)\n//\n// - The outter parentheses in CompileAssert<(bool(expr))> are necessary\n//   to work around a bug in gcc 3.4.4 and 4.0.1.  If we had written\n//\n//     CompileAssert<bool(expr)>\n//\n//   instead, these compilers will refuse to compile\n//\n//     GTEST_COMPILE_ASSERT_(5 > 0, some_message);\n//\n//   (They seem to think the \">\" in \"5 > 0\" marks the end of the\n//   template argument list.)\n//\n// - The array size is (bool(expr) ? 1 : -1), instead of simply\n//\n//     ((expr) ? 1 : -1).\n//\n//   This is to avoid running into a bug in MS VC 7.1, which\n//   causes ((0.0) ? 1 : -1) to incorrectly evaluate to 1.\n\n// StaticAssertTypeEqHelper is used by StaticAssertTypeEq defined in gtest.h.\n//\n// This template is declared, but intentionally undefined.\ntemplate <typename T1, typename T2>\nstruct StaticAssertTypeEqHelper;\n\ntemplate <typename T>\nstruct StaticAssertTypeEqHelper<T, T> {\n  enum { value = true };\n};\n\n// Evaluates to the number of elements in 'array'.\n#define GTEST_ARRAY_SIZE_(array) (sizeof(array) / sizeof(array[0]))\n\n#if GTEST_HAS_GLOBAL_STRING\ntypedef ::string string;\n#else\ntypedef ::std::string string;\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#if GTEST_HAS_GLOBAL_WSTRING\ntypedef ::wstring wstring;\n#elif GTEST_HAS_STD_WSTRING\ntypedef ::std::wstring wstring;\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// A helper for suppressing warnings on constant condition.  It just\n// returns 'condition'.\nGTEST_API_ bool IsTrue(bool condition);\n\n// Defines scoped_ptr.\n\n// This implementation of scoped_ptr is PARTIAL - it only contains\n// enough stuff to satisfy Google Test's need.\ntemplate <typename T>\nclass scoped_ptr {\n public:\n  typedef T element_type;\n\n  explicit scoped_ptr(T* p = NULL) : ptr_(p) {}\n  ~scoped_ptr() { reset(); }\n\n  T& operator*() const { return *ptr_; }\n  T* operator->() const { return ptr_; }\n  T* get() const { return ptr_; }\n\n  T* release() {\n    T* const ptr = ptr_;\n    ptr_ = NULL;\n    return ptr;\n  }\n\n  void reset(T* p = NULL) {\n    if (p != ptr_) {\n      if (IsTrue(sizeof(T) > 0)) {  // Makes sure T is a complete type.\n        delete ptr_;\n      }\n      ptr_ = p;\n    }\n  }\n\n  friend void swap(scoped_ptr& a, scoped_ptr& b) {\n    using std::swap;\n    swap(a.ptr_, b.ptr_);\n  }\n\n private:\n  T* ptr_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(scoped_ptr);\n};\n\n// Defines RE.\n\n// A simple C++ wrapper for <regex.h>.  It uses the POSIX Extended\n// Regular Expression syntax.\nclass GTEST_API_ RE {\n public:\n  // A copy constructor is required by the Standard to initialize object\n  // references from r-values.\n  RE(const RE& other) { Init(other.pattern()); }\n\n  // Constructs an RE from a string.\n  RE(const ::std::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  RE(const ::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  RE(const char* regex) { Init(regex); }  // NOLINT\n  ~RE();\n\n  // Returns the string representation of the regex.\n  const char* pattern() const { return pattern_; }\n\n  // FullMatch(str, re) returns true iff regular expression re matches\n  // the entire str.\n  // PartialMatch(str, re) returns true iff regular expression re\n  // matches a substring of str (including str itself).\n  //\n  // TODO(wan@google.com): make FullMatch() and PartialMatch() work\n  // when str contains NUL characters.\n  static bool FullMatch(const ::std::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::std::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const ::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const char* str, const RE& re);\n  static bool PartialMatch(const char* str, const RE& re);\n\n private:\n  void Init(const char* regex);\n\n  // We use a const char* instead of an std::string, as Google Test used to be\n  // used where std::string is not available.  TODO(wan@google.com): change to\n  // std::string.\n  const char* pattern_;\n  bool is_valid_;\n\n#if GTEST_USES_POSIX_RE\n\n  regex_t full_regex_;     // For FullMatch().\n  regex_t partial_regex_;  // For PartialMatch().\n\n#else  // GTEST_USES_SIMPLE_RE\n\n  const char* full_pattern_;  // For FullMatch();\n\n#endif\n\n  GTEST_DISALLOW_ASSIGN_(RE);\n};\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line);\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line);\n\n// Defines logging utilities:\n//   GTEST_LOG_(severity) - logs messages at the specified severity level. The\n//                          message itself is streamed into the macro.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n\nenum GTestLogSeverity {\n  GTEST_INFO,\n  GTEST_WARNING,\n  GTEST_ERROR,\n  GTEST_FATAL\n};\n\n// Formats log entry severity, provides a stream object for streaming the\n// log message, and terminates the message with a newline when going out of\n// scope.\nclass GTEST_API_ GTestLog {\n public:\n  GTestLog(GTestLogSeverity severity, const char* file, int line);\n\n  // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\n  ~GTestLog();\n\n  ::std::ostream& GetStream() { return ::std::cerr; }\n\n private:\n  const GTestLogSeverity severity_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog);\n};\n\n#if !defined(GTEST_LOG_)\n\n# define GTEST_LOG_(severity) \\\n    ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\n                                  __FILE__, __LINE__).GetStream()\n\ninline void LogToStderr() {}\ninline void FlushInfoLog() { fflush(NULL); }\n\n#endif  // !defined(GTEST_LOG_)\n\n#if !defined(GTEST_CHECK_)\n// INTERNAL IMPLEMENTATION - DO NOT USE.\n//\n// GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition\n// is not satisfied.\n//  Synopsys:\n//    GTEST_CHECK_(boolean_condition);\n//     or\n//    GTEST_CHECK_(boolean_condition) << \"Additional message\";\n//\n//    This checks the condition and if the condition is not satisfied\n//    it prints message about the condition violation, including the\n//    condition itself, plus additional message streamed into it, if any,\n//    and then it aborts the program. It aborts the program irrespective of\n//    whether it is built in the debug mode or not.\n# define GTEST_CHECK_(condition) \\\n    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n    if (::testing::internal::IsTrue(condition)) \\\n      ; \\\n    else \\\n      GTEST_LOG_(FATAL) << \"Condition \" #condition \" failed. \"\n#endif  // !defined(GTEST_CHECK_)\n\n// An all-mode assert to verify that the given POSIX-style function\n// call returns 0 (indicating success).  Known limitation: this\n// doesn't expand to a balanced 'if' statement, so enclose the macro\n// in {} if you need to use it as the only statement in an 'if'\n// branch.\n#define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\\n  if (const int gtest_error = (posix_call)) \\\n    GTEST_LOG_(FATAL) << #posix_call << \"failed with error \" \\\n                      << gtest_error\n\n#if GTEST_HAS_STD_MOVE_\nusing std::move;\n#else  // GTEST_HAS_STD_MOVE_\ntemplate <typename T>\nconst T& move(const T& t) {\n  return t;\n}\n#endif  // GTEST_HAS_STD_MOVE_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Use ImplicitCast_ as a safe version of static_cast for upcasting in\n// the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a\n// const Foo*).  When you use ImplicitCast_, the compiler checks that\n// the cast is safe.  Such explicit ImplicitCast_s are necessary in\n// surprisingly many situations where C++ demands an exact type match\n// instead of an argument type convertable to a target type.\n//\n// The syntax for using ImplicitCast_ is the same as for static_cast:\n//\n//   ImplicitCast_<ToType>(expr)\n//\n// ImplicitCast_ would have been part of the C++ standard library,\n// but the proposal was submitted too late.  It will probably make\n// its way into the language in the future.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., implicit_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To>\ninline To ImplicitCast_(To x) { return x; }\n\n// When you upcast (that is, cast a pointer from type Foo to type\n// SuperclassOfFoo), it's fine to use ImplicitCast_<>, since upcasts\n// always succeed.  When you downcast (that is, cast a pointer from\n// type Foo to type SubclassOfFoo), static_cast<> isn't safe, because\n// how do you know the pointer is really of type SubclassOfFoo?  It\n// could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,\n// when you downcast, you should use this macro.  In debug mode, we\n// use dynamic_cast<> to double-check the downcast is legal (we die\n// if it's not).  In normal mode, we do the efficient static_cast<>\n// instead.  Thus, it's important to test in debug mode to make sure\n// the cast is legal!\n//    This is the only place in the code we should use dynamic_cast<>.\n// In particular, you SHOULDN'T be using dynamic_cast<> in order to\n// do RTTI (eg code like this:\n//    if (dynamic_cast<Subclass1>(foo)) HandleASubclass1Object(foo);\n//    if (dynamic_cast<Subclass2>(foo)) HandleASubclass2Object(foo);\n// You should design the code some other way not to need this.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., down_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To, typename From>  // use like this: DownCast_<T*>(foo);\ninline To DownCast_(From* f) {  // so we only accept pointers\n  // Ensures that To is a sub-type of From *.  This test is here only\n  // for compile-time type checking, and has no overhead in an\n  // optimized build at run-time, as it will be optimized away\n  // completely.\n  GTEST_INTENTIONAL_CONST_COND_PUSH_()\n  if (false) {\n  GTEST_INTENTIONAL_CONST_COND_POP_()\n    const To to = NULL;\n    ::testing::internal::ImplicitCast_<From*>(to);\n  }\n\n#if GTEST_HAS_RTTI\n  // RTTI: debug mode only!\n  GTEST_CHECK_(f == NULL || dynamic_cast<To>(f) != NULL);\n#endif\n  return static_cast<To>(f);\n}\n\n// Downcasts the pointer of type Base to Derived.\n// Derived must be a subclass of Base. The parameter MUST\n// point to a class of type Derived, not any subclass of it.\n// When RTTI is available, the function performs a runtime\n// check to enforce this.\ntemplate <class Derived, class Base>\nDerived* CheckedDowncastToActualType(Base* base) {\n#if GTEST_HAS_RTTI\n  GTEST_CHECK_(typeid(*base) == typeid(Derived));\n#endif\n\n#if GTEST_HAS_DOWNCAST_\n  return ::down_cast<Derived*>(base);\n#elif GTEST_HAS_RTTI\n  return dynamic_cast<Derived*>(base);  // NOLINT\n#else\n  return static_cast<Derived*>(base);  // Poor man's downcast.\n#endif\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Defines the stderr capturer:\n//   CaptureStdout     - starts capturing stdout.\n//   GetCapturedStdout - stops capturing stdout and returns the captured string.\n//   CaptureStderr     - starts capturing stderr.\n//   GetCapturedStderr - stops capturing stderr and returns the captured string.\n//\nGTEST_API_ void CaptureStdout();\nGTEST_API_ std::string GetCapturedStdout();\nGTEST_API_ void CaptureStderr();\nGTEST_API_ std::string GetCapturedStderr();\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Returns a path to temporary directory.\nGTEST_API_ std::string TempDir();\n\n// Returns the size (in bytes) of a file.\nGTEST_API_ size_t GetFileSize(FILE* file);\n\n// Reads the entire content of a file as a string.\nGTEST_API_ std::string ReadEntireFile(FILE* file);\n\n// All command line arguments.\nGTEST_API_ const ::std::vector<testing::internal::string>& GetArgvs();\n\n#if GTEST_HAS_DEATH_TEST\n\nconst ::std::vector<testing::internal::string>& GetInjectableArgvs();\nvoid SetInjectableArgvs(const ::std::vector<testing::internal::string>*\n                             new_argvs);\n\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Defines synchronization primitives.\n#if GTEST_IS_THREADSAFE\n# if GTEST_HAS_PTHREAD\n// Sleeps for (roughly) n milliseconds.  This function is only for testing\n// Google Test's own constructs.  Don't use it in user tests, either\n// directly or indirectly.\ninline void SleepMilliseconds(int n) {\n  const timespec time = {\n    0,                  // 0 seconds.\n    n * 1000L * 1000L,  // And n ms.\n  };\n  nanosleep(&time, NULL);\n}\n# endif  // GTEST_HAS_PTHREAD\n\n# if GTEST_HAS_NOTIFICATION_\n// Notification has already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_HAS_PTHREAD\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass Notification {\n public:\n  Notification() : notified_(false) {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n  }\n  ~Notification() {\n    pthread_mutex_destroy(&mutex_);\n  }\n\n  // Notifies all threads created with this notification to start. Must\n  // be called from the controller thread.\n  void Notify() {\n    pthread_mutex_lock(&mutex_);\n    notified_ = true;\n    pthread_mutex_unlock(&mutex_);\n  }\n\n  // Blocks until the controller thread notifies. Must be called from a test\n  // thread.\n  void WaitForNotification() {\n    for (;;) {\n      pthread_mutex_lock(&mutex_);\n      const bool notified = notified_;\n      pthread_mutex_unlock(&mutex_);\n      if (notified)\n        break;\n      SleepMilliseconds(10);\n    }\n  }\n\n private:\n  pthread_mutex_t mutex_;\n  bool notified_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\nGTEST_API_ void SleepMilliseconds(int n);\n\n// Provides leak-safe Windows kernel handle ownership.\n// Used in death tests and in threading support.\nclass GTEST_API_ AutoHandle {\n public:\n  // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to\n  // avoid including <windows.h> in this header file. Including <windows.h> is\n  // undesirable because it defines a lot of symbols and macros that tend to\n  // conflict with client code. This assumption is verified by\n  // WindowsTypesTest.HANDLEIsVoidStar.\n  typedef void* Handle;\n  AutoHandle();\n  explicit AutoHandle(Handle handle);\n\n  ~AutoHandle();\n\n  Handle Get() const;\n  void Reset();\n  void Reset(Handle handle);\n\n private:\n  // Returns true iff the handle is a valid handle object that can be closed.\n  bool IsCloseable() const;\n\n  Handle handle_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);\n};\n\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass GTEST_API_ Notification {\n public:\n  Notification();\n  void Notify();\n  void WaitForNotification();\n\n private:\n  AutoHandle event_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n# endif  // GTEST_HAS_NOTIFICATION_\n\n// On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD\n// defined, but we don't want to use MinGW's pthreads implementation, which\n// has conformance problems with some versions of the POSIX standard.\n# if GTEST_HAS_PTHREAD && !GTEST_OS_WINDOWS_MINGW\n\n// As a C-function, ThreadFuncWithCLinkage cannot be templated itself.\n// Consequently, it cannot select a correct instantiation of ThreadWithParam\n// in order to call its Run(). Introducing ThreadWithParamBase as a\n// non-templated base class for ThreadWithParam allows us to bypass this\n// problem.\nclass ThreadWithParamBase {\n public:\n  virtual ~ThreadWithParamBase() {}\n  virtual void Run() = 0;\n};\n\n// pthread_create() accepts a pointer to a function type with the C linkage.\n// According to the Standard (7.5/1), function types with different linkages\n// are different even if they are otherwise identical.  Some compilers (for\n// example, SunStudio) treat them as different types.  Since class methods\n// cannot be defined with C-linkage we need to define a free C-function to\n// pass into pthread_create().\nextern \"C\" inline void* ThreadFuncWithCLinkage(void* thread) {\n  static_cast<ThreadWithParamBase*>(thread)->Run();\n  return NULL;\n}\n\n// Helper class for testing Google Test's multi-threading constructs.\n// To use it, write:\n//\n//   void ThreadFunc(int param) { /* Do things with param */ }\n//   Notification thread_can_start;\n//   ...\n//   // The thread_can_start parameter is optional; you can supply NULL.\n//   ThreadWithParam<int> thread(&ThreadFunc, 5, &thread_can_start);\n//   thread_can_start.Notify();\n//\n// These classes are only for testing Google Test's own constructs. Do\n// not use them in user tests, either directly or indirectly.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : func_(func),\n        param_(param),\n        thread_can_start_(thread_can_start),\n        finished_(false) {\n    ThreadWithParamBase* const base = this;\n    // The thread can be created only after all fields except thread_\n    // have been initialized.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_create(&thread_, 0, &ThreadFuncWithCLinkage, base));\n  }\n  ~ThreadWithParam() { Join(); }\n\n  void Join() {\n    if (!finished_) {\n      GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, 0));\n      finished_ = true;\n    }\n  }\n\n  virtual void Run() {\n    if (thread_can_start_ != NULL)\n      thread_can_start_->WaitForNotification();\n    func_(param_);\n  }\n\n private:\n  UserThreadFunc* const func_;  // User-supplied thread function.\n  const T param_;  // User-supplied parameter to the thread function.\n  // When non-NULL, used to block execution until the controller thread\n  // notifies.\n  Notification* const thread_can_start_;\n  bool finished_;  // true iff we know that the thread function has finished.\n  pthread_t thread_;  // The native thread object.\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n# endif  // !GTEST_OS_WINDOWS && GTEST_HAS_PTHREAD ||\n         // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n# if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n// Mutex and ThreadLocal have already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\n// Mutex implements mutex on Windows platforms.  It is used in conjunction\n// with class MutexLock:\n//\n//   Mutex mutex;\n//   ...\n//   MutexLock lock(&mutex);  // Acquires the mutex and releases it at the\n//                            // end of the current scope.\n//\n// A static Mutex *must* be defined or declared using one of the following\n// macros:\n//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);\n//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);\n//\n// (A non-static Mutex is defined/declared in the usual way).\nclass GTEST_API_ Mutex {\n public:\n  enum MutexType { kStatic = 0, kDynamic = 1 };\n  // We rely on kStaticMutex being 0 as it is to what the linker initializes\n  // type_ in static mutexes.  critical_section_ will be initialized lazily\n  // in ThreadSafeLazyInit().\n  enum StaticConstructorSelector { kStaticMutex = 0 };\n\n  // This constructor intentionally does nothing.  It relies on type_ being\n  // statically initialized to 0 (effectively setting it to kStatic) and on\n  // ThreadSafeLazyInit() to lazily initialize the rest of the members.\n  explicit Mutex(StaticConstructorSelector /*dummy*/) {}\n\n  Mutex();\n  ~Mutex();\n\n  void Lock();\n\n  void Unlock();\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld();\n\n private:\n  // Initializes owner_thread_id_ and critical_section_ in static mutexes.\n  void ThreadSafeLazyInit();\n\n  // Per http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx,\n  // we assume that 0 is an invalid value for thread IDs.\n  unsigned int owner_thread_id_;\n\n  // For static mutexes, we rely on these members being initialized to zeros\n  // by the linker.\n  MutexType type_;\n  long critical_section_init_phase_;  // NOLINT\n  _RTL_CRITICAL_SECTION* critical_section_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n    extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n    ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  Mutex* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Base class for ValueHolder<T>.  Allows a caller to hold and delete a value\n// without knowing its type.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Provides a way for a thread to send notifications to a ThreadLocal\n// regardless of its parameter type.\nclass ThreadLocalBase {\n public:\n  // Creates a new ValueHolder<T> object holding a default value passed to\n  // this ThreadLocal<T>'s constructor and returns it.  It is the caller's\n  // responsibility not to call this when the ThreadLocal<T> instance already\n  // has a value on the current thread.\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;\n\n protected:\n  ThreadLocalBase() {}\n  virtual ~ThreadLocalBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocalBase);\n};\n\n// Maps a thread to a set of ThreadLocals that have values instantiated on that\n// thread and notifies them when the thread exits.  A ThreadLocal instance is\n// expected to persist until all threads it has values on have terminated.\nclass GTEST_API_ ThreadLocalRegistry {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance);\n\n  // Invoked when a ThreadLocal instance is destroyed.\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance);\n};\n\nclass GTEST_API_ ThreadWithParamBase {\n public:\n  void Join();\n\n protected:\n  class Runnable {\n   public:\n    virtual ~Runnable() {}\n    virtual void Run() = 0;\n  };\n\n  ThreadWithParamBase(Runnable *runnable, Notification* thread_can_start);\n  virtual ~ThreadWithParamBase();\n\n private:\n  AutoHandle thread_;\n};\n\n// Helper class for testing Google Test's multi-threading constructs.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {\n  }\n  virtual ~ThreadWithParam() {}\n\n private:\n  class RunnableImpl : public Runnable {\n   public:\n    RunnableImpl(UserThreadFunc* func, T param)\n        : func_(func),\n          param_(param) {\n    }\n    virtual ~RunnableImpl() {}\n    virtual void Run() {\n      func_(param_);\n    }\n\n   private:\n    UserThreadFunc* const func_;\n    const T param_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(RunnableImpl);\n  };\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n\n// Implements thread-local storage on Windows systems.\n//\n//   // Thread 1\n//   ThreadLocal<int> tl(100);  // 100 is the default value for each thread.\n//\n//   // Thread 2\n//   tl.set(150);  // Changes the value for thread 2 only.\n//   EXPECT_EQ(150, tl.get());\n//\n//   // Thread 1\n//   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.\n//   tl.set(200);\n//   EXPECT_EQ(200, tl.get());\n//\n// The template type argument T must have a public copy constructor.\n// In addition, the default ThreadLocal constructor requires T to have\n// a public default constructor.\n//\n// The users of a TheadLocal instance have to make sure that all but one\n// threads (including the main one) using that instance have exited before\n// destroying it. Otherwise, the per-thread objects managed for them by the\n// ThreadLocal instance are not guaranteed to be destroyed on all platforms.\n//\n// Google Test only uses global ThreadLocal objects.  That means they\n// will die after main() has returned.  Therefore, no per-thread\n// object managed by Google Test will be leaked as long as all threads\n// using Google Test have exited when main() returns.\ntemplate <typename T>\nclass ThreadLocal : public ThreadLocalBase {\n public:\n  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of T.  Can be deleted via its base class without the caller\n  // knowing the type of T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n\n  T* GetOrCreateValue() const {\n    return static_cast<ValueHolder*>(\n        ThreadLocalRegistry::GetValueOnCurrentThread(this))->pointer();\n  }\n\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const {\n    return default_factory_->MakeNewHolder();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# elif GTEST_HAS_PTHREAD\n\n// MutexBase and Mutex implement mutex on pthreads-based platforms.\nclass MutexBase {\n public:\n  // Acquires this mutex.\n  void Lock() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_));\n    owner_ = pthread_self();\n    has_owner_ = true;\n  }\n\n  // Releases this mutex.\n  void Unlock() {\n    // Since the lock is being released the owner_ field should no longer be\n    // considered valid. We don't protect writing to has_owner_ here, as it's\n    // the caller's responsibility to ensure that the current thread holds the\n    // mutex when this is called.\n    has_owner_ = false;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&mutex_));\n  }\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld() const {\n    GTEST_CHECK_(has_owner_ && pthread_equal(owner_, pthread_self()))\n        << \"The current thread is not holding the mutex @\" << this;\n  }\n\n  // A static mutex may be used before main() is entered.  It may even\n  // be used before the dynamic initialization stage.  Therefore we\n  // must be able to initialize a static mutex object at link time.\n  // This means MutexBase has to be a POD and its member variables\n  // have to be public.\n public:\n  pthread_mutex_t mutex_;  // The underlying pthread mutex.\n  // has_owner_ indicates whether the owner_ field below contains a valid thread\n  // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All\n  // accesses to the owner_ field should be protected by a check of this field.\n  // An alternative might be to memset() owner_ to all zeros, but there's no\n  // guarantee that a zero'd pthread_t is necessarily invalid or even different\n  // from pthread_self().\n  bool has_owner_;\n  pthread_t owner_;  // The thread holding the mutex.\n};\n\n// Forward-declares a static mutex.\n#  define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n     extern ::testing::internal::MutexBase mutex\n\n// Defines and statically (i.e. at link time) initializes a static mutex.\n#  define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n     ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, pthread_t() }\n\n// The Mutex class can only be used for mutexes created at runtime. It\n// shares its API with MutexBase otherwise.\nclass Mutex : public MutexBase {\n public:\n  Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n    has_owner_ = false;\n  }\n  ~Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(MutexBase* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  MutexBase* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Helpers for ThreadLocal.\n\n// pthread_key_create() requires DeleteThreadLocalValue() to have\n// C-linkage.  Therefore it cannot be templatized to access\n// ThreadLocal<T>.  Hence the need for class\n// ThreadLocalValueHolderBase.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Called by pthread to delete thread-local data stored by\n// pthread_setspecific().\nextern \"C\" inline void DeleteThreadLocalValue(void* value_holder) {\n  delete static_cast<ThreadLocalValueHolderBase*>(value_holder);\n}\n\n// Implements thread-local storage on pthreads-based systems.\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal()\n      : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : key_(CreateKey()),\n        default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() {\n    // Destroys the managed object for the current thread, if any.\n    DeleteThreadLocalValue(pthread_getspecific(key_));\n\n    // Releases resources associated with the key.  This will *not*\n    // delete managed objects for other threads.\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\n  }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of type T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n  static pthread_key_t CreateKey() {\n    pthread_key_t key;\n    // When a thread exits, DeleteThreadLocalValue() will be called on\n    // the object managed for that thread.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_key_create(&key, &DeleteThreadLocalValue));\n    return key;\n  }\n\n  T* GetOrCreateValue() const {\n    ThreadLocalValueHolderBase* const holder =\n        static_cast<ThreadLocalValueHolderBase*>(pthread_getspecific(key_));\n    if (holder != NULL) {\n      return CheckedDowncastToActualType<ValueHolder>(holder)->pointer();\n    }\n\n    ValueHolder* const new_holder = default_factory_->MakeNewHolder();\n    ThreadLocalValueHolderBase* const holder_base = new_holder;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\n    return new_holder->pointer();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  // A key pthreads uses for looking up per-thread values.\n  const pthread_key_t key_;\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# endif  // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#else  // GTEST_IS_THREADSAFE\n\n// A dummy implementation of synchronization primitives (mutex, lock,\n// and thread-local variable).  Necessary for compiling Google Test where\n// mutex is not supported - using Google Test in multiple threads is not\n// supported on such platforms.\n\nclass Mutex {\n public:\n  Mutex() {}\n  void Lock() {}\n  void Unlock() {}\n  void AssertHeld() const {}\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex*) {}  // NOLINT\n};\n\ntypedef GTestMutexLock MutexLock;\n\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal() : value_() {}\n  explicit ThreadLocal(const T& value) : value_(value) {}\n  T* pointer() { return &value_; }\n  const T* pointer() const { return &value_; }\n  const T& get() const { return value_; }\n  void set(const T& value) { value_ = value; }\n private:\n  T value_;\n};\n\n#endif  // GTEST_IS_THREADSAFE\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nGTEST_API_ size_t GetThreadCount();\n\n// Passing non-POD classes through ellipsis (...) crashes the ARM\n// compiler and generates a warning in Sun Studio.  The Nokia Symbian\n// and the IBM XL C/C++ compiler try to instantiate a copy constructor\n// for objects passed through ellipsis (...), failing for uncopyable\n// objects.  We define this to ensure that only POD is passed through\n// ellipsis on these systems.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_ELLIPSIS_NEEDS_POD_ 1\n#else\n# define GTEST_CAN_COMPARE_NULL 1\n#endif\n\n// The Nokia Symbian and IBM XL C/C++ compilers cannot decide between\n// const T& and const T* in a function template.  These compilers\n// _can_ decide between class template specializations for T and T*,\n// so a tr1::type_traits-like is_pointer works.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__)\n# define GTEST_NEEDS_IS_POINTER_ 1\n#endif\n\ntemplate <bool bool_value>\nstruct bool_constant {\n  typedef bool_constant<bool_value> type;\n  static const bool value = bool_value;\n};\ntemplate <bool bool_value> const bool bool_constant<bool_value>::value;\n\ntypedef bool_constant<false> false_type;\ntypedef bool_constant<true> true_type;\n\ntemplate <typename T>\nstruct is_pointer : public false_type {};\n\ntemplate <typename T>\nstruct is_pointer<T*> : public true_type {};\n\ntemplate <typename Iterator>\nstruct IteratorTraits {\n  typedef typename Iterator::value_type value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<T*> {\n  typedef T value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<const T*> {\n  typedef T value_type;\n};\n\n#if GTEST_OS_WINDOWS\n# define GTEST_PATH_SEP_ \"\\\\\"\n# define GTEST_HAS_ALT_PATH_SEP_ 1\n// The biggest signed integer type the compiler supports.\ntypedef __int64 BiggestInt;\n#else\n# define GTEST_PATH_SEP_ \"/\"\n# define GTEST_HAS_ALT_PATH_SEP_ 0\ntypedef long long BiggestInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n\n// Utilities for char.\n\n// isspace(int ch) and friends accept an unsigned char or EOF.  char\n// may be signed, depending on the compiler (or compiler flags).\n// Therefore we need to cast a char to unsigned char before calling\n// isspace(), etc.\n\ninline bool IsAlpha(char ch) {\n  return isalpha(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsAlNum(char ch) {\n  return isalnum(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsDigit(char ch) {\n  return isdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsLower(char ch) {\n  return islower(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsSpace(char ch) {\n  return isspace(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsUpper(char ch) {\n  return isupper(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(char ch) {\n  return isxdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(wchar_t ch) {\n  const unsigned char low_byte = static_cast<unsigned char>(ch);\n  return ch == low_byte && isxdigit(low_byte) != 0;\n}\n\ninline char ToLower(char ch) {\n  return static_cast<char>(tolower(static_cast<unsigned char>(ch)));\n}\ninline char ToUpper(char ch) {\n  return static_cast<char>(toupper(static_cast<unsigned char>(ch)));\n}\n\ninline std::string StripTrailingSpaces(std::string str) {\n  std::string::iterator it = str.end();\n  while (it != str.begin() && IsSpace(*--it))\n    it = str.erase(it);\n  return str;\n}\n\n// The testing::internal::posix namespace holds wrappers for common\n// POSIX functions.  These wrappers hide the differences between\n// Windows/MSVC and POSIX systems.  Since some compilers define these\n// standard functions as macros, the wrapper cannot have the same name\n// as the wrapped function.\n\nnamespace posix {\n\n// Functions with a different name on Windows.\n\n#if GTEST_OS_WINDOWS\n\ntypedef struct _stat StatStruct;\n\n# ifdef __BORLANDC__\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\n# else  // !__BORLANDC__\n#  if GTEST_OS_WINDOWS_MOBILE\ninline int IsATTY(int /* fd */) { return 0; }\n#  else\ninline int IsATTY(int fd) { return _isatty(fd); }\n#  endif  // GTEST_OS_WINDOWS_MOBILE\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return _stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return _strdup(src); }\n# endif  // __BORLANDC__\n\n# if GTEST_OS_WINDOWS_MOBILE\ninline int FileNo(FILE* file) { return reinterpret_cast<int>(_fileno(file)); }\n// Stat(), RmDir(), and IsDir() are not needed on Windows CE at this\n// time and thus not defined there.\n# else\ninline int FileNo(FILE* file) { return _fileno(file); }\ninline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }\ninline int RmDir(const char* dir) { return _rmdir(dir); }\ninline bool IsDir(const StatStruct& st) {\n  return (_S_IFDIR & st.st_mode) != 0;\n}\n# endif  // GTEST_OS_WINDOWS_MOBILE\n\n#else\n\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct& st) { return S_ISDIR(st.st_mode); }\n\n#endif  // GTEST_OS_WINDOWS\n\n// Functions deprecated by MSVC 8.0.\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4996 /* deprecated function */)\n\ninline const char* StrNCpy(char* dest, const char* src, size_t n) {\n  return strncpy(dest, src, n);\n}\n\n// ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and\n// StrError() aren't needed on Windows CE at this time and thus not\n// defined there.\n\n#if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\ninline int ChDir(const char* dir) { return chdir(dir); }\n#endif\ninline FILE* FOpen(const char* path, const char* mode) {\n  return fopen(path, mode);\n}\n#if !GTEST_OS_WINDOWS_MOBILE\ninline FILE *FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}\ninline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n#endif\ninline int FClose(FILE* fp) { return fclose(fp); }\n#if !GTEST_OS_WINDOWS_MOBILE\ninline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast<int>(read(fd, buf, count));\n}\ninline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast<int>(write(fd, buf, count));\n}\ninline int Close(int fd) { return close(fd); }\ninline const char* StrError(int errnum) { return strerror(errnum); }\n#endif\ninline const char* GetEnv(const char* name) {\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT\n  // We are on Windows CE, which has no environment variables.\n  static_cast<void>(name);  // To prevent 'unused argument' warning.\n  return NULL;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  // Environment variables which we programmatically clear will be set to the\n  // empty string rather than unset (NULL).  Handle that case.\n  const char* const env = getenv(name);\n  return (env != NULL && env[0] != '\\0') ? env : NULL;\n#else\n  return getenv(name);\n#endif\n}\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n#if GTEST_OS_WINDOWS_MOBILE\n// Windows CE has no C library. The abort() function is used in\n// several places in Google Test. This implementation provides a reasonable\n// imitation of standard behaviour.\nvoid Abort();\n#else\ninline void Abort() { abort(); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n}  // namespace posix\n\n// MSVC \"deprecates\" snprintf and issues warnings wherever it is used.  In\n// order to avoid these warnings, we need to use _snprintf or _snprintf_s on\n// MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate\n// function in order to achieve that.  We use macro definition here because\n// snprintf is a variadic function.\n#if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE\n// MSVC 2005 and above support variadic macros.\n# define GTEST_SNPRINTF_(buffer, size, format, ...) \\\n     _snprintf_s(buffer, size, size, format, __VA_ARGS__)\n#elif defined(_MSC_VER)\n// Windows CE does not define _snprintf_s and MSVC prior to 2005 doesn't\n// complain about _snprintf.\n# define GTEST_SNPRINTF_ _snprintf\n#else\n# define GTEST_SNPRINTF_ snprintf\n#endif\n\n// The maximum number a BiggestInt can represent.  This definition\n// works no matter BiggestInt is represented in one's complement or\n// two's complement.\n//\n// We cannot rely on numeric_limits in STL, as __int64 and long long\n// are not part of standard C++ and numeric_limits doesn't need to be\n// defined for them.\nconst BiggestInt kMaxBiggestInt =\n    ~(static_cast<BiggestInt>(1) << (8*sizeof(BiggestInt) - 1));\n\n// This template class serves as a compile-time function from size to\n// type.  It maps a size in bytes to a primitive type with that\n// size. e.g.\n//\n//   TypeWithSize<4>::UInt\n//\n// is typedef-ed to be unsigned int (unsigned integer made up of 4\n// bytes).\n//\n// Such functionality should belong to STL, but I cannot find it\n// there.\n//\n// Google Test uses this class in the implementation of floating-point\n// comparison.\n//\n// For now it only handles UInt (unsigned int) as that's all Google Test\n// needs.  Other types can be easily added in the future if need\n// arises.\ntemplate <size_t size>\nclass TypeWithSize {\n public:\n  // This prevents the user from using TypeWithSize<N> with incorrect\n  // values of N.\n  typedef void UInt;\n};\n\n// The specialization for size 4.\ntemplate <>\nclass TypeWithSize<4> {\n public:\n  // unsigned int has size 4 in both gcc and MSVC.\n  //\n  // As base/basictypes.h doesn't compile on Windows, we cannot use\n  // uint32, uint64, and etc here.\n  typedef int Int;\n  typedef unsigned int UInt;\n};\n\n// The specialization for size 8.\ntemplate <>\nclass TypeWithSize<8> {\n public:\n#if GTEST_OS_WINDOWS\n  typedef __int64 Int;\n  typedef unsigned __int64 UInt;\n#else\n  typedef long long Int;  // NOLINT\n  typedef unsigned long long UInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n};\n\n// Integer types of known sizes.\ntypedef TypeWithSize<4>::Int Int32;\ntypedef TypeWithSize<4>::UInt UInt32;\ntypedef TypeWithSize<8>::Int Int64;\ntypedef TypeWithSize<8>::UInt UInt64;\ntypedef TypeWithSize<8>::Int TimeInMillis;  // Represents time in milliseconds.\n\n// Utilities for command line flags and environment variables.\n\n// Macro for referencing flags.\n#if !defined(GTEST_FLAG)\n# define GTEST_FLAG(name) FLAGS_gtest_##name\n#endif  // !defined(GTEST_FLAG)\n\n#if !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n# define GTEST_USE_OWN_FLAGFILE_FLAG_ 1\n#endif  // !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n\n#if !defined(GTEST_DECLARE_bool_)\n# define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver\n\n// Macros for declaring flags.\n# define GTEST_DECLARE_bool_(name) GTEST_API_ extern bool GTEST_FLAG(name)\n# define GTEST_DECLARE_int32_(name) \\\n    GTEST_API_ extern ::testing::internal::Int32 GTEST_FLAG(name)\n#define GTEST_DECLARE_string_(name) \\\n    GTEST_API_ extern ::std::string GTEST_FLAG(name)\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc) \\\n    GTEST_API_ bool GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_int32_(name, default_val, doc) \\\n    GTEST_API_ ::testing::internal::Int32 GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_string_(name, default_val, doc) \\\n    GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val)\n\n#endif  // !defined(GTEST_DECLARE_bool_)\n\n// Thread annotations\n#if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n# define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n# define GTEST_LOCK_EXCLUDED_(locks)\n#endif  // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n\n// Parses 'str' for a 32-bit signed integer.  If successful, writes the result\n// to *value and returns true; otherwise leaves *value unchanged and returns\n// false.\n// TODO(chandlerc): Find a better way to refactor flag and environment parsing\n// out of both gtest-port.cc and gtest.cc to avoid exporting this utility\n// function.\nbool ParseInt32(const Message& src_text, const char* str, Int32* value);\n\n// Parses a bool/Int32/string from the environment variable\n// corresponding to the given Google Test flag.\nbool BoolFromGTestEnv(const char* flag, bool default_val);\nGTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);\nstd::string StringFromGTestEnv(const char* flag, const char* default_val);\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-string.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares the String class and functions used internally by\n// Google Test.  They are subject to change without notice. They should not used\n// by code external to Google Test.\n//\n// This header file is #included by <gtest/internal/gtest-internal.h>.\n// It should not be #included by other files.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_\n\n#ifdef __BORLANDC__\n// string.h is not guaranteed to provide strcpy on C++ Builder.\n# include <mem.h>\n#endif\n\n#include <string.h>\n#include <string>\n\n#include \"gtest/internal/gtest-port.h\"\n\nnamespace testing {\nnamespace internal {\n\n// String - an abstract class holding static string utilities.\nclass GTEST_API_ String {\n public:\n  // Static utility methods\n\n  // Clones a 0-terminated C string, allocating memory using new.  The\n  // caller is responsible for deleting the return value using\n  // delete[].  Returns the cloned string, or NULL if the input is\n  // NULL.\n  //\n  // This is different from strdup() in string.h, which allocates\n  // memory using malloc().\n  static const char* CloneCString(const char* c_str);\n\n#if GTEST_OS_WINDOWS_MOBILE\n  // Windows CE does not have the 'ANSI' versions of Win32 APIs. To be\n  // able to pass strings to Win32 APIs on CE we need to convert them\n  // to 'Unicode', UTF-16.\n\n  // Creates a UTF-16 wide string from the given ANSI string, allocating\n  // memory using new. The caller is responsible for deleting the return\n  // value using delete[]. Returns the wide string, or NULL if the\n  // input is NULL.\n  //\n  // The wide string is created using the ANSI codepage (CP_ACP) to\n  // match the behaviour of the ANSI versions of Win32 calls and the\n  // C runtime.\n  static LPCWSTR AnsiToUtf16(const char* c_str);\n\n  // Creates an ANSI string from the given wide string, allocating\n  // memory using new. The caller is responsible for deleting the return\n  // value using delete[]. Returns the ANSI string, or NULL if the\n  // input is NULL.\n  //\n  // The returned string is created using the ANSI codepage (CP_ACP) to\n  // match the behaviour of the ANSI versions of Win32 calls and the\n  // C runtime.\n  static const char* Utf16ToAnsi(LPCWSTR utf16_str);\n#endif\n\n  // Compares two C strings.  Returns true iff they have the same content.\n  //\n  // Unlike strcmp(), this function can handle NULL argument(s).  A\n  // NULL C string is considered different to any non-NULL C string,\n  // including the empty string.\n  static bool CStringEquals(const char* lhs, const char* rhs);\n\n  // Converts a wide C string to a String using the UTF-8 encoding.\n  // NULL will be converted to \"(null)\".  If an error occurred during\n  // the conversion, \"(failed to convert from wide string)\" is\n  // returned.\n  static std::string ShowWideCString(const wchar_t* wide_c_str);\n\n  // Compares two wide C strings.  Returns true iff they have the same\n  // content.\n  //\n  // Unlike wcscmp(), this function can handle NULL argument(s).  A\n  // NULL C string is considered different to any non-NULL C string,\n  // including the empty string.\n  static bool WideCStringEquals(const wchar_t* lhs, const wchar_t* rhs);\n\n  // Compares two C strings, ignoring case.  Returns true iff they\n  // have the same content.\n  //\n  // Unlike strcasecmp(), this function can handle NULL argument(s).\n  // A NULL C string is considered different to any non-NULL C string,\n  // including the empty string.\n  static bool CaseInsensitiveCStringEquals(const char* lhs,\n                                           const char* rhs);\n\n  // Compares two wide C strings, ignoring case.  Returns true iff they\n  // have the same content.\n  //\n  // Unlike wcscasecmp(), this function can handle NULL argument(s).\n  // A NULL C string is considered different to any non-NULL wide C string,\n  // including the empty string.\n  // NB: The implementations on different platforms slightly differ.\n  // On windows, this method uses _wcsicmp which compares according to LC_CTYPE\n  // environment variable. On GNU platform this method uses wcscasecmp\n  // which compares according to LC_CTYPE category of the current locale.\n  // On MacOS X, it uses towlower, which also uses LC_CTYPE category of the\n  // current locale.\n  static bool CaseInsensitiveWideCStringEquals(const wchar_t* lhs,\n                                               const wchar_t* rhs);\n\n  // Returns true iff the given string ends with the given suffix, ignoring\n  // case. Any string is considered to end with an empty suffix.\n  static bool EndsWithCaseInsensitive(\n      const std::string& str, const std::string& suffix);\n\n  // Formats an int value as \"%02d\".\n  static std::string FormatIntWidth2(int value);  // \"%02d\" for width == 2\n\n  // Formats an int value as \"%X\".\n  static std::string FormatHexInt(int value);\n\n  // Formats a byte as \"%02X\".\n  static std::string FormatByte(unsigned char value);\n\n private:\n  String();  // Not meant to be instantiated.\n};  // class String\n\n// Gets the content of the stringstream's buffer as an std::string.  Each '\\0'\n// character in the buffer is replaced with \"\\\\0\".\nGTEST_API_ std::string StringStreamToString(::std::stringstream* stream);\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-type-util.h", "content": "// This file was GENERATED by command:\n//     pump.py gtest-type-util.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Type utilities needed for implementing typed and type-parameterized\n// tests.  This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\n//\n// Currently we support at most 50 types in a list, and at most 50\n// type-parameterized tests in one type-parameterized test case.\n// Please contact googletestframework@googlegroups.com if you need\n// more.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n// #ifdef __GNUC__ is too general here.  It is possible to use gcc without using\n// libstdc++ (which is where cxxabi.h comes from).\n# if GTEST_HAS_CXXABI_H_\n#  include <cxxabi.h>\n# elif defined(__HP_aCC)\n#  include <acxx_demangle.h>\n# endif  // GTEST_HASH_CXXABI_H_\n\nnamespace testing {\nnamespace internal {\n\n// GetTypeName<T>() returns a human-readable name of type T.\n// NB: This function is also used in Google Mock, so don't move it inside of\n// the typed-test-only section below.\ntemplate <typename T>\nstd::string GetTypeName() {\n# if GTEST_HAS_RTTI\n\n  const char* const name = typeid(T).name();\n#  if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)\n  int status = 0;\n  // gcc's implementation of typeid(T).name() mangles the type name,\n  // so we have to demangle it.\n#   if GTEST_HAS_CXXABI_H_\n  using abi::__cxa_demangle;\n#   endif  // GTEST_HAS_CXXABI_H_\n  char* const readable_name = __cxa_demangle(name, 0, 0, &status);\n  const std::string name_str(status == 0 ? readable_name : name);\n  free(readable_name);\n  return name_str;\n#  else\n  return name;\n#  endif  // GTEST_HAS_CXXABI_H_ || __HP_aCC\n\n# else\n\n  return \"<type>\";\n\n# endif  // GTEST_HAS_RTTI\n}\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// AssertyTypeEq<T1, T2>::type is defined iff T1 and T2 are the same\n// type.  This can be used as a compile-time assertion to ensure that\n// two types are equal.\n\ntemplate <typename T1, typename T2>\nstruct AssertTypeEq;\n\ntemplate <typename T>\nstruct AssertTypeEq<T, T> {\n  typedef bool type;\n};\n\n// A unique type used as the default value for the arguments of class\n// template Types.  This allows us to simulate variadic templates\n// (e.g. Types<int>, Type<int, double>, and etc), which C++ doesn't\n// support directly.\nstruct None {};\n\n// The following family of struct and struct templates are used to\n// represent type lists.  In particular, TypesN<T1, T2, ..., TN>\n// represents a type list with N types (T1, T2, ..., and TN) in it.\n// Except for Types0, every struct in the family has two member types:\n// Head for the first type in the list, and Tail for the rest of the\n// list.\n\n// The empty type list.\nstruct Types0 {};\n\n// Type lists of length 1, 2, 3, and so on.\n\ntemplate <typename T1>\nstruct Types1 {\n  typedef T1 Head;\n  typedef Types0 Tail;\n};\ntemplate <typename T1, typename T2>\nstruct Types2 {\n  typedef T1 Head;\n  typedef Types1<T2> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3>\nstruct Types3 {\n  typedef T1 Head;\n  typedef Types2<T2, T3> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nstruct Types4 {\n  typedef T1 Head;\n  typedef Types3<T2, T3, T4> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nstruct Types5 {\n  typedef T1 Head;\n  typedef Types4<T2, T3, T4, T5> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\nstruct Types6 {\n  typedef T1 Head;\n  typedef Types5<T2, T3, T4, T5, T6> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\nstruct Types7 {\n  typedef T1 Head;\n  typedef Types6<T2, T3, T4, T5, T6, T7> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\nstruct Types8 {\n  typedef T1 Head;\n  typedef Types7<T2, T3, T4, T5, T6, T7, T8> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\nstruct Types9 {\n  typedef T1 Head;\n  typedef Types8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\nstruct Types10 {\n  typedef T1 Head;\n  typedef Types9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\nstruct Types11 {\n  typedef T1 Head;\n  typedef Types10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\nstruct Types12 {\n  typedef T1 Head;\n  typedef Types11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\nstruct Types13 {\n  typedef T1 Head;\n  typedef Types12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\nstruct Types14 {\n  typedef T1 Head;\n  typedef Types13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\nstruct Types15 {\n  typedef T1 Head;\n  typedef Types14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\nstruct Types16 {\n  typedef T1 Head;\n  typedef Types15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\nstruct Types17 {\n  typedef T1 Head;\n  typedef Types16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\nstruct Types18 {\n  typedef T1 Head;\n  typedef Types17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\nstruct Types19 {\n  typedef T1 Head;\n  typedef Types18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\nstruct Types20 {\n  typedef T1 Head;\n  typedef Types19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\nstruct Types21 {\n  typedef T1 Head;\n  typedef Types20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\nstruct Types22 {\n  typedef T1 Head;\n  typedef Types21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\nstruct Types23 {\n  typedef T1 Head;\n  typedef Types22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\nstruct Types24 {\n  typedef T1 Head;\n  typedef Types23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\nstruct Types25 {\n  typedef T1 Head;\n  typedef Types24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\nstruct Types26 {\n  typedef T1 Head;\n  typedef Types25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\nstruct Types27 {\n  typedef T1 Head;\n  typedef Types26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\nstruct Types28 {\n  typedef T1 Head;\n  typedef Types27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\nstruct Types29 {\n  typedef T1 Head;\n  typedef Types28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\nstruct Types30 {\n  typedef T1 Head;\n  typedef Types29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\nstruct Types31 {\n  typedef T1 Head;\n  typedef Types30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\nstruct Types32 {\n  typedef T1 Head;\n  typedef Types31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\nstruct Types33 {\n  typedef T1 Head;\n  typedef Types32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\nstruct Types34 {\n  typedef T1 Head;\n  typedef Types33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\nstruct Types35 {\n  typedef T1 Head;\n  typedef Types34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\nstruct Types36 {\n  typedef T1 Head;\n  typedef Types35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\nstruct Types37 {\n  typedef T1 Head;\n  typedef Types36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\nstruct Types38 {\n  typedef T1 Head;\n  typedef Types37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\nstruct Types39 {\n  typedef T1 Head;\n  typedef Types38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\nstruct Types40 {\n  typedef T1 Head;\n  typedef Types39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\nstruct Types41 {\n  typedef T1 Head;\n  typedef Types40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\nstruct Types42 {\n  typedef T1 Head;\n  typedef Types41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\nstruct Types43 {\n  typedef T1 Head;\n  typedef Types42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\nstruct Types44 {\n  typedef T1 Head;\n  typedef Types43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\nstruct Types45 {\n  typedef T1 Head;\n  typedef Types44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\nstruct Types46 {\n  typedef T1 Head;\n  typedef Types45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\nstruct Types47 {\n  typedef T1 Head;\n  typedef Types46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46, T47> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\nstruct Types48 {\n  typedef T1 Head;\n  typedef Types47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46, T47, T48> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\nstruct Types49 {\n  typedef T1 Head;\n  typedef Types48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46, T47, T48, T49> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\nstruct Types50 {\n  typedef T1 Head;\n  typedef Types49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46, T47, T48, T49, T50> Tail;\n};\n\n\n}  // namespace internal\n\n// We don't want to require the users to write TypesN<...> directly,\n// as that would require them to count the length.  Types<...> is much\n// easier to write, but generates horrible messages when there is a\n// compiler error, as gcc insists on printing out each template\n// argument, even if it has the default value (this means Types<int>\n// will appear as Types<int, None, None, ..., None> in the compiler\n// errors).\n//\n// Our solution is to combine the best part of the two approaches: a\n// user would write Types<T1, ..., TN>, and Google Test will translate\n// that to TypesN<T1, ..., TN> internally to make error messages\n// readable.  The translation is done by the 'type' member of the\n// Types template.\ntemplate <typename T1 = internal::None, typename T2 = internal::None,\n    typename T3 = internal::None, typename T4 = internal::None,\n    typename T5 = internal::None, typename T6 = internal::None,\n    typename T7 = internal::None, typename T8 = internal::None,\n    typename T9 = internal::None, typename T10 = internal::None,\n    typename T11 = internal::None, typename T12 = internal::None,\n    typename T13 = internal::None, typename T14 = internal::None,\n    typename T15 = internal::None, typename T16 = internal::None,\n    typename T17 = internal::None, typename T18 = internal::None,\n    typename T19 = internal::None, typename T20 = internal::None,\n    typename T21 = internal::None, typename T22 = internal::None,\n    typename T23 = internal::None, typename T24 = internal::None,\n    typename T25 = internal::None, typename T26 = internal::None,\n    typename T27 = internal::None, typename T28 = internal::None,\n    typename T29 = internal::None, typename T30 = internal::None,\n    typename T31 = internal::None, typename T32 = internal::None,\n    typename T33 = internal::None, typename T34 = internal::None,\n    typename T35 = internal::None, typename T36 = internal::None,\n    typename T37 = internal::None, typename T38 = internal::None,\n    typename T39 = internal::None, typename T40 = internal::None,\n    typename T41 = internal::None, typename T42 = internal::None,\n    typename T43 = internal::None, typename T44 = internal::None,\n    typename T45 = internal::None, typename T46 = internal::None,\n    typename T47 = internal::None, typename T48 = internal::None,\n    typename T49 = internal::None, typename T50 = internal::None>\nstruct Types {\n  typedef internal::Types50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47, T48, T49, T50> type;\n};\n\ntemplate <>\nstruct Types<internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types0 type;\n};\ntemplate <typename T1>\nstruct Types<T1, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types1<T1> type;\n};\ntemplate <typename T1, typename T2>\nstruct Types<T1, T2, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types2<T1, T2> type;\n};\ntemplate <typename T1, typename T2, typename T3>\nstruct Types<T1, T2, T3, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types3<T1, T2, T3> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4>\nstruct Types<T1, T2, T3, T4, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types4<T1, T2, T3, T4> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nstruct Types<T1, T2, T3, T4, T5, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types5<T1, T2, T3, T4, T5> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\nstruct Types<T1, T2, T3, T4, T5, T6, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types6<T1, T2, T3, T4, T5, T6> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types7<T1, T2, T3, T4, T5, T6, T7> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types8<T1, T2, T3, T4, T5, T6, T7, T8> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    T46, internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    T46, T47, internal::None, internal::None, internal::None> {\n  typedef internal::Types47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    T46, T47, T48, internal::None, internal::None> {\n  typedef internal::Types48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47, T48> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    T46, T47, T48, T49, internal::None> {\n  typedef internal::Types49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47, T48, T49> type;\n};\n\nnamespace internal {\n\n# define GTEST_TEMPLATE_ template <typename T> class\n\n// The template \"selector\" struct TemplateSel<Tmpl> is used to\n// represent Tmpl, which must be a class template with one type\n// parameter, as a type.  TemplateSel<Tmpl>::Bind<T>::type is defined\n// as the type Tmpl<T>.  This allows us to actually instantiate the\n// template \"selected\" by TemplateSel<Tmpl>.\n//\n// This trick is necessary for simulating typedef for class templates,\n// which C++ doesn't support directly.\ntemplate <GTEST_TEMPLATE_ Tmpl>\nstruct TemplateSel {\n  template <typename T>\n  struct Bind {\n    typedef Tmpl<T> type;\n  };\n};\n\n# define GTEST_BIND_(TmplSel, T) \\\n  TmplSel::template Bind<T>::type\n\n// A unique struct template used as the default value for the\n// arguments of class template Templates.  This allows us to simulate\n// variadic templates (e.g. Templates<int>, Templates<int, double>,\n// and etc), which C++ doesn't support directly.\ntemplate <typename T>\nstruct NoneT {};\n\n// The following family of struct and struct templates are used to\n// represent template lists.  In particular, TemplatesN<T1, T2, ...,\n// TN> represents a list of N templates (T1, T2, ..., and TN).  Except\n// for Templates0, every struct in the family has two member types:\n// Head for the selector of the first template in the list, and Tail\n// for the rest of the list.\n\n// The empty template list.\nstruct Templates0 {};\n\n// Template lists of length 1, 2, 3, and so on.\n\ntemplate <GTEST_TEMPLATE_ T1>\nstruct Templates1 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates0 Tail;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2>\nstruct Templates2 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates1<T2> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3>\nstruct Templates3 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates2<T2, T3> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4>\nstruct Templates4 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates3<T2, T3, T4> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5>\nstruct Templates5 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates4<T2, T3, T4, T5> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6>\nstruct Templates6 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates5<T2, T3, T4, T5, T6> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7>\nstruct Templates7 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates6<T2, T3, T4, T5, T6, T7> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8>\nstruct Templates8 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates7<T2, T3, T4, T5, T6, T7, T8> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9>\nstruct Templates9 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10>\nstruct Templates10 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11>\nstruct Templates11 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12>\nstruct Templates12 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13>\nstruct Templates13 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14>\nstruct Templates14 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15>\nstruct Templates15 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16>\nstruct Templates16 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17>\nstruct Templates17 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18>\nstruct Templates18 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19>\nstruct Templates19 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20>\nstruct Templates20 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21>\nstruct Templates21 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22>\nstruct Templates22 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23>\nstruct Templates23 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24>\nstruct Templates24 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25>\nstruct Templates25 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26>\nstruct Templates26 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27>\nstruct Templates27 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28>\nstruct Templates28 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29>\nstruct Templates29 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30>\nstruct Templates30 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31>\nstruct Templates31 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32>\nstruct Templates32 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33>\nstruct Templates33 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34>\nstruct Templates34 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35>\nstruct Templates35 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36>\nstruct Templates36 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37>\nstruct Templates37 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38>\nstruct Templates38 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39>\nstruct Templates39 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40>\nstruct Templates40 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41>\nstruct Templates41 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42>\nstruct Templates42 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43>\nstruct Templates43 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44>\nstruct Templates44 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45>\nstruct Templates45 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46>\nstruct Templates46 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47>\nstruct Templates47 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46, T47> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48>\nstruct Templates48 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46, T47, T48> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\n    GTEST_TEMPLATE_ T49>\nstruct Templates49 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46, T47, T48, T49> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\n    GTEST_TEMPLATE_ T49, GTEST_TEMPLATE_ T50>\nstruct Templates50 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46, T47, T48, T49, T50> Tail;\n};\n\n\n// We don't want to require the users to write TemplatesN<...> directly,\n// as that would require them to count the length.  Templates<...> is much\n// easier to write, but generates horrible messages when there is a\n// compiler error, as gcc insists on printing out each template\n// argument, even if it has the default value (this means Templates<list>\n// will appear as Templates<list, NoneT, NoneT, ..., NoneT> in the compiler\n// errors).\n//\n// Our solution is to combine the best part of the two approaches: a\n// user would write Templates<T1, ..., TN>, and Google Test will translate\n// that to TemplatesN<T1, ..., TN> internally to make error messages\n// readable.  The translation is done by the 'type' member of the\n// Templates template.\ntemplate <GTEST_TEMPLATE_ T1 = NoneT, GTEST_TEMPLATE_ T2 = NoneT,\n    GTEST_TEMPLATE_ T3 = NoneT, GTEST_TEMPLATE_ T4 = NoneT,\n    GTEST_TEMPLATE_ T5 = NoneT, GTEST_TEMPLATE_ T6 = NoneT,\n    GTEST_TEMPLATE_ T7 = NoneT, GTEST_TEMPLATE_ T8 = NoneT,\n    GTEST_TEMPLATE_ T9 = NoneT, GTEST_TEMPLATE_ T10 = NoneT,\n    GTEST_TEMPLATE_ T11 = NoneT, GTEST_TEMPLATE_ T12 = NoneT,\n    GTEST_TEMPLATE_ T13 = NoneT, GTEST_TEMPLATE_ T14 = NoneT,\n    GTEST_TEMPLATE_ T15 = NoneT, GTEST_TEMPLATE_ T16 = NoneT,\n    GTEST_TEMPLATE_ T17 = NoneT, GTEST_TEMPLATE_ T18 = NoneT,\n    GTEST_TEMPLATE_ T19 = NoneT, GTEST_TEMPLATE_ T20 = NoneT,\n    GTEST_TEMPLATE_ T21 = NoneT, GTEST_TEMPLATE_ T22 = NoneT,\n    GTEST_TEMPLATE_ T23 = NoneT, GTEST_TEMPLATE_ T24 = NoneT,\n    GTEST_TEMPLATE_ T25 = NoneT, GTEST_TEMPLATE_ T26 = NoneT,\n    GTEST_TEMPLATE_ T27 = NoneT, GTEST_TEMPLATE_ T28 = NoneT,\n    GTEST_TEMPLATE_ T29 = NoneT, GTEST_TEMPLATE_ T30 = NoneT,\n    GTEST_TEMPLATE_ T31 = NoneT, GTEST_TEMPLATE_ T32 = NoneT,\n    GTEST_TEMPLATE_ T33 = NoneT, GTEST_TEMPLATE_ T34 = NoneT,\n    GTEST_TEMPLATE_ T35 = NoneT, GTEST_TEMPLATE_ T36 = NoneT,\n    GTEST_TEMPLATE_ T37 = NoneT, GTEST_TEMPLATE_ T38 = NoneT,\n    GTEST_TEMPLATE_ T39 = NoneT, GTEST_TEMPLATE_ T40 = NoneT,\n    GTEST_TEMPLATE_ T41 = NoneT, GTEST_TEMPLATE_ T42 = NoneT,\n    GTEST_TEMPLATE_ T43 = NoneT, GTEST_TEMPLATE_ T44 = NoneT,\n    GTEST_TEMPLATE_ T45 = NoneT, GTEST_TEMPLATE_ T46 = NoneT,\n    GTEST_TEMPLATE_ T47 = NoneT, GTEST_TEMPLATE_ T48 = NoneT,\n    GTEST_TEMPLATE_ T49 = NoneT, GTEST_TEMPLATE_ T50 = NoneT>\nstruct Templates {\n  typedef Templates50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46, T47, T48, T49, T50> type;\n};\n\ntemplate <>\nstruct Templates<NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT> {\n  typedef Templates0 type;\n};\ntemplate <GTEST_TEMPLATE_ T1>\nstruct Templates<T1, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT> {\n  typedef Templates1<T1> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2>\nstruct Templates<T1, T2, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT> {\n  typedef Templates2<T1, T2> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3>\nstruct Templates<T1, T2, T3, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates3<T1, T2, T3> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4>\nstruct Templates<T1, T2, T3, T4, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates4<T1, T2, T3, T4> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5>\nstruct Templates<T1, T2, T3, T4, T5, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates5<T1, T2, T3, T4, T5> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6>\nstruct Templates<T1, T2, T3, T4, T5, T6, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates6<T1, T2, T3, T4, T5, T6> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates7<T1, T2, T3, T4, T5, T6, T7> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates8<T1, T2, T3, T4, T5, T6, T7, T8> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT> {\n  typedef Templates22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT> {\n  typedef Templates23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT> {\n  typedef Templates24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT> {\n  typedef Templates25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT> {\n  typedef Templates26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT> {\n  typedef Templates27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT> {\n  typedef Templates28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT> {\n  typedef Templates29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, T46, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, T46, T47, NoneT, NoneT, NoneT> {\n  typedef Templates47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46, T47> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, T46, T47, T48, NoneT, NoneT> {\n  typedef Templates48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46, T47, T48> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\n    GTEST_TEMPLATE_ T49>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, T46, T47, T48, T49, NoneT> {\n  typedef Templates49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46, T47, T48, T49> type;\n};\n\n// The TypeList template makes it possible to use either a single type\n// or a Types<...> list in TYPED_TEST_CASE() and\n// INSTANTIATE_TYPED_TEST_CASE_P().\n\ntemplate <typename T>\nstruct TypeList {\n  typedef Types1<T> type;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\nstruct TypeList<Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49, T50> > {\n  typedef typename Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::type type;\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 4, "line": 21}, "message": "'clang/AST/DeclNodes.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTFwd.h", "reportHash": "33a05be8d240acdf8a352c94adf7b2fd", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 9, "file": 7, "line": 14}, "message": "LLVM_CLANG_ANALYSIS_BODYFARM_H (fixit)"}, {"location": {"col": 9, "file": 7, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/BodyFarm.h", "reportHash": "38d1915f79e10c948cf593a7e70b34fd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 13}, "message": "LLVM_CLANG_ANALYSIS_PATHDIAGNOSTIC_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "252165277339c0d2700b8ecb3d6cd4c9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 12, "line": 9}, "message": "LLVM_CLANG_FRONTEND_PCHCONTAINEROPERATIONS_H (fixit)"}, {"location": {"col": 9, "file": 12, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PCHContainerOperations.h", "reportHash": "f0e52a1348c3a1d65c64a1e1f75b2e72", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 13}, "message": "LLVM_CLANG_FRONTEND_PRECOMPILEDPREAMBLE_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "0c5e562717fef483e859d1cdf83773b9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 2, "file": 16, "line": 155}, "message": "endif // LLVM_CLANG_SERIALIZATION_MODULEFILEEXTENSION_H (fixit)"}, {"location": {"col": 2, "file": 16, "line": 155}, "message": "#endif for a header guard should reference the guard macro in a comment"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h", "reportHash": "442d3a9b661653b63f00e66d09682050", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 17, "line": 38}, "message": "GTEST_GTEST_DEATH_TEST_H (fixit)"}, {"location": {"col": 9, "file": 17, "line": 38}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-death-test.h", "reportHash": "0f9c8fef16fd26978d8461339aafb709", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 18, "line": 46}, "message": "GTEST_GTEST_MESSAGE_H (fixit)"}, {"location": {"col": 9, "file": 18, "line": 46}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-message.h", "reportHash": "22ff5011ed1b84cff7b34299096cd9bc", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 41}, "message": "GTEST_GTEST_PARAM_TEST_H (fixit)"}, {"location": {"col": 9, "file": 19, "line": 41}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-param-test.h", "reportHash": "5708912d5f0135a86e364ddbef1d5182", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 20, "line": 95}, "message": "GTEST_GTEST_PRINTERS_H (fixit)"}, {"location": {"col": 9, "file": 20, "line": 95}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-printers.h", "reportHash": "81e8bac70d7630d861551e9f2ebe82c2", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 21, "line": 33}, "message": "GTEST_GTEST_TEST_PART_H (fixit)"}, {"location": {"col": 9, "file": 21, "line": 33}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-test-part.h", "reportHash": "e8afeb0b70a4464b8efecf7375972d1e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 22, "line": 32}, "message": "GTEST_GTEST_TYPED_TEST_H (fixit)"}, {"location": {"col": 9, "file": 22, "line": 32}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-typed-test.h", "reportHash": "166970ab85742833822957013de61bfa", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 23, "line": 51}, "message": "GTEST_GTEST_H (fixit)"}, {"location": {"col": 9, "file": 23, "line": 51}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "reportHash": "299868b061d8cfa1aa5f548263d243a5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 24, "line": 35}, "message": "GTEST_GTEST_PRED_IMPL_H (fixit)"}, {"location": {"col": 9, "file": 24, "line": 35}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_pred_impl.h", "reportHash": "c2044d357748af8686991a7c2af71183", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 25, "line": 34}, "message": "GTEST_GTEST_PROD_H (fixit)"}, {"location": {"col": 9, "file": 25, "line": 34}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_prod.h", "reportHash": "f4c6dba233ddd0a5ac5717511d062351", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 26, "line": 66}, "message": "GTEST_INTERNAL_CUSTOM_GTEST_PORT_H (fixit)"}, {"location": {"col": 9, "file": 26, "line": 66}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/gtest-port.h", "reportHash": "a5a0aa944e677addf3c0d81fc492e6a1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 39}, "message": "GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H (fixit)"}, {"location": {"col": 9, "file": 27, "line": 39}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/gtest-printers.h", "reportHash": "608191229ff6290e963a244f7ff2c115", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 28, "line": 22}, "message": "GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H (fixit)"}, {"location": {"col": 9, "file": 28, "line": 22}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/raw-ostream.h", "reportHash": "0d32f0413d9e8d41a5d1014dfd435c2f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 29, "line": 37}, "message": "GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H (fixit)"}, {"location": {"col": 9, "file": 29, "line": 37}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-death-test-internal.h", "reportHash": "0a2f2a83f2165ab67b3751bab3b043f5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 30, "line": 40}, "message": "GTEST_INTERNAL_GTEST_FILEPATH_H (fixit)"}, {"location": {"col": 9, "file": 30, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-filepath.h", "reportHash": "047f91a0b9435e12b0a8e6614143d05b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 31, "line": 37}, "message": "GTEST_INTERNAL_GTEST_INTERNAL_H (fixit)"}, {"location": {"col": 9, "file": 31, "line": 37}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "7ea79cd4129edb8574d251ddddaaf548", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 32, "line": 68}, "message": "GTEST_INTERNAL_GTEST_LINKED_PTR_H (fixit)"}, {"location": {"col": 9, "file": 32, "line": 68}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-linked_ptr.h", "reportHash": "ef6eb26fa783c73c00b31b58f6767165", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 33, "line": 46}, "message": "GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H (fixit)"}, {"location": {"col": 9, "file": 33, "line": 46}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-param-util-generated.h", "reportHash": "412c0e17fa03a230a3a8fbc8f2bded23", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 34, "line": 34}, "message": "GTEST_INTERNAL_GTEST_PARAM_UTIL_H (fixit)"}, {"location": {"col": 9, "file": 34, "line": 34}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "7b733f5fa62cf074a277d1a828582abd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 35, "line": 35}, "message": "GTEST_INTERNAL_GTEST_PORT_ARCH_H (fixit)"}, {"location": {"col": 9, "file": 35, "line": 35}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port-arch.h", "reportHash": "826520d67760ee4eb212377f2ec5e0f3", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 36, "line": 43}, "message": "GTEST_INTERNAL_GTEST_PORT_H (fixit)"}, {"location": {"col": 9, "file": 36, "line": 43}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "7583ff9565b7178acd246bfe7cf23401", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 37, "line": 41}, "message": "GTEST_INTERNAL_GTEST_STRING_H (fixit)"}, {"location": {"col": 9, "file": 37, "line": 41}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-string.h", "reportHash": "46d88a3a98b4b07b676c0aa20b2c7dea", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 38, "line": 44}, "message": "GTEST_INTERNAL_GTEST_TYPE_UTIL_H (fixit)"}, {"location": {"col": 9, "file": 38, "line": 44}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-type-util.h", "reportHash": "658954e9e2a2953373515d7e6970101a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
