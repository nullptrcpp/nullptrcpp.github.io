<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "content": "/*\n * Copyright 2011      INRIA Saclay\n * Copyright 2011      Sven Verdoolaege\n * Copyright 2012-2014 Ecole Normale Superieure\n * Copyright 2014      INRIA Rocquencourt\n * Copyright 2016      Sven Verdoolaege\n * Copyright 2018,2020 Cerebras Systems\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,\n * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,\n * 91893 Orsay, France\n * and Ecole Normale Superieure, 45 rue d\u2019Ulm, 75230 Paris, France\n * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,\n * B.P. 105 - 78153 Le Chesnay, France\n * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA\n */\n\n#include <isl_ctx_private.h>\n#include <isl_map_private.h>\n#include <isl_union_map_private.h>\n#include <isl_aff_private.h>\n#include <isl_space_private.h>\n#include <isl_local_space_private.h>\n#include <isl_vec_private.h>\n#include <isl_mat_private.h>\n#include <isl_id_private.h>\n#include <isl/constraint.h>\n#include <isl_seq.h>\n#include <isl/set.h>\n#include <isl_val_private.h>\n#include <isl_point_private.h>\n#include <isl_config.h>\n\n#undef EL_BASE\n#define EL_BASE aff\n\n#include <isl_list_templ.c>\n\n#undef EL_BASE\n#define EL_BASE pw_aff\n\n#include <isl_list_templ.c>\n\n#undef EL_BASE\n#define EL_BASE pw_multi_aff\n\n#include <isl_list_templ.c>\n\n#undef EL_BASE\n#define EL_BASE union_pw_aff\n\n#include <isl_list_templ.c>\n\n#undef EL_BASE\n#define EL_BASE union_pw_multi_aff\n\n#include <isl_list_templ.c>\n\n__isl_give isl_aff *isl_aff_alloc_vec(__isl_take isl_local_space *ls,\n\t__isl_take isl_vec *v)\n{\n\tisl_aff *aff;\n\n\tif (!ls || !v)\n\t\tgoto error;\n\n\taff = isl_calloc_type(v->ctx, struct isl_aff);\n\tif (!aff)\n\t\tgoto error;\n\n\taff->ref = 1;\n\taff->ls = ls;\n\taff->v = v;\n\n\treturn aff;\nerror:\n\tisl_local_space_free(ls);\n\tisl_vec_free(v);\n\treturn NULL;\n}\n\n__isl_give isl_aff *isl_aff_alloc(__isl_take isl_local_space *ls)\n{\n\tisl_ctx *ctx;\n\tisl_vec *v;\n\tisl_size total;\n\n\tif (!ls)\n\t\treturn NULL;\n\n\tctx = isl_local_space_get_ctx(ls);\n\tif (!isl_local_space_divs_known(ls))\n\t\tisl_die(ctx, isl_error_invalid, \"local space has unknown divs\",\n\t\t\tgoto error);\n\tif (!isl_local_space_is_set(ls))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"domain of affine expression should be a set\",\n\t\t\tgoto error);\n\n\ttotal = isl_local_space_dim(ls, isl_dim_all);\n\tif (total < 0)\n\t\tgoto error;\n\tv = isl_vec_alloc(ctx, 1 + 1 + total);\n\treturn isl_aff_alloc_vec(ls, v);\nerror:\n\tisl_local_space_free(ls);\n\treturn NULL;\n}\n\n__isl_give isl_aff *isl_aff_copy(__isl_keep isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->ref++;\n\treturn aff;\n}\n\n__isl_give isl_aff *isl_aff_dup(__isl_keep isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\treturn isl_aff_alloc_vec(isl_local_space_copy(aff->ls),\n\t\t\t\t isl_vec_copy(aff->v));\n}\n\n__isl_give isl_aff *isl_aff_cow(__isl_take isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\tif (aff->ref == 1)\n\t\treturn aff;\n\taff->ref--;\n\treturn isl_aff_dup(aff);\n}\n\n__isl_give isl_aff *isl_aff_zero_on_domain(__isl_take isl_local_space *ls)\n{\n\tisl_aff *aff;\n\n\taff = isl_aff_alloc(ls);\n\tif (!aff)\n\t\treturn NULL;\n\n\tisl_int_set_si(aff->v->el[0], 1);\n\tisl_seq_clr(aff->v->el + 1, aff->v->size - 1);\n\n\treturn aff;\n}\n\n/* Return an affine expression that is equal to zero on domain space \"space\".\n */\n__isl_give isl_aff *isl_aff_zero_on_domain_space(__isl_take isl_space *space)\n{\n\treturn isl_aff_zero_on_domain(isl_local_space_from_space(space));\n}\n\n/* Return a piecewise affine expression defined on the specified domain\n * that is equal to zero.\n */\n__isl_give isl_pw_aff *isl_pw_aff_zero_on_domain(__isl_take isl_local_space *ls)\n{\n\treturn isl_pw_aff_from_aff(isl_aff_zero_on_domain(ls));\n}\n\n/* Change \"aff\" into a NaN.\n *\n * Note that this function gets called from isl_aff_nan_on_domain,\n * so \"aff\" may not have been initialized yet.\n */\nstatic __isl_give isl_aff *isl_aff_set_nan(__isl_take isl_aff *aff)\n{\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_clr(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\n}\n\n/* Return an affine expression defined on the specified domain\n * that represents NaN.\n */\n__isl_give isl_aff *isl_aff_nan_on_domain(__isl_take isl_local_space *ls)\n{\n\tisl_aff *aff;\n\n\taff = isl_aff_alloc(ls);\n\treturn isl_aff_set_nan(aff);\n}\n\n/* Return an affine expression defined on the specified domain space\n * that represents NaN.\n */\n__isl_give isl_aff *isl_aff_nan_on_domain_space(__isl_take isl_space *space)\n{\n\treturn isl_aff_nan_on_domain(isl_local_space_from_space(space));\n}\n\n/* Return a piecewise affine expression defined on the specified domain space\n * that represents NaN.\n */\n__isl_give isl_pw_aff *isl_pw_aff_nan_on_domain_space(\n\t__isl_take isl_space *space)\n{\n\treturn isl_pw_aff_from_aff(isl_aff_nan_on_domain_space(space));\n}\n\n/* Return a piecewise affine expression defined on the specified domain\n * that represents NaN.\n */\n__isl_give isl_pw_aff *isl_pw_aff_nan_on_domain(__isl_take isl_local_space *ls)\n{\n\treturn isl_pw_aff_from_aff(isl_aff_nan_on_domain(ls));\n}\n\n/* Return an affine expression that is equal to \"val\" on\n * domain local space \"ls\".\n */\n__isl_give isl_aff *isl_aff_val_on_domain(__isl_take isl_local_space *ls,\n\t__isl_take isl_val *val)\n{\n\tisl_aff *aff;\n\n\tif (!ls || !val)\n\t\tgoto error;\n\tif (!isl_val_is_rat(val))\n\t\tisl_die(isl_val_get_ctx(val), isl_error_invalid,\n\t\t\t\"expecting rational value\", goto error);\n\n\taff = isl_aff_alloc(isl_local_space_copy(ls));\n\tif (!aff)\n\t\tgoto error;\n\n\tisl_seq_clr(aff->v->el + 2, aff->v->size - 2);\n\tisl_int_set(aff->v->el[1], val->n);\n\tisl_int_set(aff->v->el[0], val->d);\n\n\tisl_local_space_free(ls);\n\tisl_val_free(val);\n\treturn aff;\nerror:\n\tisl_local_space_free(ls);\n\tisl_val_free(val);\n\treturn NULL;\n}\n\n/* Return an affine expression that is equal to \"val\" on domain space \"space\".\n */\n__isl_give isl_aff *isl_aff_val_on_domain_space(__isl_take isl_space *space,\n\t__isl_take isl_val *val)\n{\n\treturn isl_aff_val_on_domain(isl_local_space_from_space(space), val);\n}\n\n/* Return an affine expression that is equal to the specified dimension\n * in \"ls\".\n */\n__isl_give isl_aff *isl_aff_var_on_domain(__isl_take isl_local_space *ls,\n\tenum isl_dim_type type, unsigned pos)\n{\n\tisl_space *space;\n\tisl_aff *aff;\n\n\tif (!ls)\n\t\treturn NULL;\n\n\tspace = isl_local_space_get_space(ls);\n\tif (!space)\n\t\tgoto error;\n\tif (isl_space_is_map(space))\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"expecting (parameter) set space\", goto error);\n\tif (isl_local_space_check_range(ls, type, pos, 1) < 0)\n\t\tgoto error;\n\n\tisl_space_free(space);\n\taff = isl_aff_alloc(ls);\n\tif (!aff)\n\t\treturn NULL;\n\n\tpos += isl_local_space_offset(aff->ls, type);\n\n\tisl_int_set_si(aff->v->el[0], 1);\n\tisl_seq_clr(aff->v->el + 1, aff->v->size - 1);\n\tisl_int_set_si(aff->v->el[1 + pos], 1);\n\n\treturn aff;\nerror:\n\tisl_local_space_free(ls);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Return a piecewise affine expression that is equal to\n * the specified dimension in \"ls\".\n */\n__isl_give isl_pw_aff *isl_pw_aff_var_on_domain(__isl_take isl_local_space *ls,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn isl_pw_aff_from_aff(isl_aff_var_on_domain(ls, type, pos));\n}\n\n/* Return an affine expression that is equal to the parameter\n * in the domain space \"space\" with identifier \"id\".\n */\n__isl_give isl_aff *isl_aff_param_on_domain_space_id(\n\t__isl_take isl_space *space, __isl_take isl_id *id)\n{\n\tint pos;\n\tisl_local_space *ls;\n\n\tif (!space || !id)\n\t\tgoto error;\n\tpos = isl_space_find_dim_by_id(space, isl_dim_param, id);\n\tif (pos < 0)\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"parameter not found in space\", goto error);\n\tisl_id_free(id);\n\tls = isl_local_space_from_space(space);\n\treturn isl_aff_var_on_domain(ls, isl_dim_param, pos);\nerror:\n\tisl_space_free(space);\n\tisl_id_free(id);\n\treturn NULL;\n}\n\n__isl_null isl_aff *isl_aff_free(__isl_take isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\tif (--aff->ref > 0)\n\t\treturn NULL;\n\n\tisl_local_space_free(aff->ls);\n\tisl_vec_free(aff->v);\n\n\tfree(aff);\n\n\treturn NULL;\n}\n\nisl_ctx *isl_aff_get_ctx(__isl_keep isl_aff *aff)\n{\n\treturn aff ? isl_local_space_get_ctx(aff->ls) : NULL;\n}\n\n/* Return a hash value that digests \"aff\".\n */\nuint32_t isl_aff_get_hash(__isl_keep isl_aff *aff)\n{\n\tuint32_t hash, ls_hash, v_hash;\n\n\tif (!aff)\n\t\treturn 0;\n\n\thash = isl_hash_init();\n\tls_hash = isl_local_space_get_hash(aff->ls);\n\tisl_hash_hash(hash, ls_hash);\n\tv_hash = isl_vec_get_hash(aff->v);\n\tisl_hash_hash(hash, v_hash);\n\n\treturn hash;\n}\n\n/* Return the domain local space of \"aff\".\n */\nstatic __isl_keep isl_local_space *isl_aff_peek_domain_local_space(\n\t__isl_keep isl_aff *aff)\n{\n\treturn aff ? aff->ls : NULL;\n}\n\n/* Return the number of variables of the given type in the domain of \"aff\".\n */\nisl_size isl_aff_domain_dim(__isl_keep isl_aff *aff, enum isl_dim_type type)\n{\n\tisl_local_space *ls;\n\n\tls = isl_aff_peek_domain_local_space(aff);\n\treturn isl_local_space_dim(ls, type);\n}\n\n/* Externally, an isl_aff has a map space, but internally, the\n * ls field corresponds to the domain of that space.\n */\nisl_size isl_aff_dim(__isl_keep isl_aff *aff, enum isl_dim_type type)\n{\n\tif (!aff)\n\t\treturn isl_size_error;\n\tif (type == isl_dim_out)\n\t\treturn 1;\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\treturn isl_aff_domain_dim(aff, type);\n}\n\n/* Return the offset of the first coefficient of type \"type\" in\n * the domain of \"aff\".\n */\nisl_size isl_aff_domain_offset(__isl_keep isl_aff *aff, enum isl_dim_type type)\n{\n\tisl_local_space *ls;\n\n\tls = isl_aff_peek_domain_local_space(aff);\n\treturn isl_local_space_offset(ls, type);\n}\n\n/* Return the position of the dimension of the given type and name\n * in \"aff\".\n * Return -1 if no such dimension can be found.\n */\nint isl_aff_find_dim_by_name(__isl_keep isl_aff *aff, enum isl_dim_type type,\n\tconst char *name)\n{\n\tif (!aff)\n\t\treturn -1;\n\tif (type == isl_dim_out)\n\t\treturn -1;\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\treturn isl_local_space_find_dim_by_name(aff->ls, type, name);\n}\n\n/* Return the domain space of \"aff\".\n */\nstatic __isl_keep isl_space *isl_aff_peek_domain_space(__isl_keep isl_aff *aff)\n{\n\treturn aff ? isl_local_space_peek_space(aff->ls) : NULL;\n}\n\n__isl_give isl_space *isl_aff_get_domain_space(__isl_keep isl_aff *aff)\n{\n\treturn isl_space_copy(isl_aff_peek_domain_space(aff));\n}\n\n__isl_give isl_space *isl_aff_get_space(__isl_keep isl_aff *aff)\n{\n\tisl_space *space;\n\tif (!aff)\n\t\treturn NULL;\n\tspace = isl_local_space_get_space(aff->ls);\n\tspace = isl_space_from_domain(space);\n\tspace = isl_space_add_dims(space, isl_dim_out, 1);\n\treturn space;\n}\n\n/* Return a copy of the domain space of \"aff\".\n */\n__isl_give isl_local_space *isl_aff_get_domain_local_space(\n\t__isl_keep isl_aff *aff)\n{\n\treturn isl_local_space_copy(isl_aff_peek_domain_local_space(aff));\n}\n\n__isl_give isl_local_space *isl_aff_get_local_space(__isl_keep isl_aff *aff)\n{\n\tisl_local_space *ls;\n\tif (!aff)\n\t\treturn NULL;\n\tls = isl_local_space_copy(aff->ls);\n\tls = isl_local_space_from_domain(ls);\n\tls = isl_local_space_add_dims(ls, isl_dim_out, 1);\n\treturn ls;\n}\n\n/* Return the local space of the domain of \"aff\".\n * This may be either a copy or the local space itself\n * if there is only one reference to \"aff\".\n * This allows the local space to be modified inplace\n * if both the expression and its local space have only a single reference.\n * The caller is not allowed to modify \"aff\" between this call and\n * a subsequent call to isl_aff_restore_domain_local_space.\n * The only exception is that isl_aff_free can be called instead.\n */\n__isl_give isl_local_space *isl_aff_take_domain_local_space(\n\t__isl_keep isl_aff *aff)\n{\n\tisl_local_space *ls;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (aff->ref != 1)\n\t\treturn isl_aff_get_domain_local_space(aff);\n\tls = aff->ls;\n\taff->ls = NULL;\n\treturn ls;\n}\n\n/* Set the local space of the domain of \"aff\" to \"ls\",\n * where the local space of \"aff\" may be missing\n * due to a preceding call to isl_aff_take_domain_local_space.\n * However, in this case, \"aff\" only has a single reference and\n * then the call to isl_aff_cow has no effect.\n */\n__isl_give isl_aff *isl_aff_restore_domain_local_space(\n\t__isl_keep isl_aff *aff, __isl_take isl_local_space *ls)\n{\n\tif (!aff || !ls)\n\t\tgoto error;\n\n\tif (aff->ls == ls) {\n\t\tisl_local_space_free(ls);\n\t\treturn aff;\n\t}\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\tisl_local_space_free(aff->ls);\n\taff->ls = ls;\n\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_local_space_free(ls);\n\treturn NULL;\n}\n\n/* Externally, an isl_aff has a map space, but internally, the\n * ls field corresponds to the domain of that space.\n */\nconst char *isl_aff_get_dim_name(__isl_keep isl_aff *aff,\n\tenum isl_dim_type type, unsigned pos)\n{\n\tif (!aff)\n\t\treturn NULL;\n\tif (type == isl_dim_out)\n\t\treturn NULL;\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\treturn isl_local_space_get_dim_name(aff->ls, type, pos);\n}\n\n__isl_give isl_aff *isl_aff_reset_domain_space(__isl_take isl_aff *aff,\n\t__isl_take isl_space *space)\n{\n\taff = isl_aff_cow(aff);\n\tif (!aff || !space)\n\t\tgoto error;\n\n\taff->ls = isl_local_space_reset_space(aff->ls, space);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Reset the space of \"aff\".  This function is called from isl_pw_templ.c\n * and doesn't know if the space of an element object is represented\n * directly or through its domain.  It therefore passes along both.\n */\n__isl_give isl_aff *isl_aff_reset_space_and_domain(__isl_take isl_aff *aff,\n\t__isl_take isl_space *space, __isl_take isl_space *domain)\n{\n\tisl_space_free(space);\n\treturn isl_aff_reset_domain_space(aff, domain);\n}\n\n/* Reorder the coefficients of the affine expression based\n * on the given reordering.\n * The reordering r is assumed to have been extended with the local\n * variables.\n */\nstatic __isl_give isl_vec *vec_reorder(__isl_take isl_vec *vec,\n\t__isl_take isl_reordering *r, int n_div)\n{\n\tisl_space *space;\n\tisl_vec *res;\n\tisl_size dim;\n\tint i;\n\n\tif (!vec || !r)\n\t\tgoto error;\n\n\tspace = isl_reordering_peek_space(r);\n\tdim = isl_space_dim(space, isl_dim_all);\n\tif (dim < 0)\n\t\tgoto error;\n\tres = isl_vec_alloc(vec->ctx, 2 + dim + n_div);\n\tif (!res)\n\t\tgoto error;\n\tisl_seq_cpy(res->el, vec->el, 2);\n\tisl_seq_clr(res->el + 2, res->size - 2);\n\tfor (i = 0; i < r->len; ++i)\n\t\tisl_int_set(res->el[2 + r->pos[i]], vec->el[2 + i]);\n\n\tisl_reordering_free(r);\n\tisl_vec_free(vec);\n\treturn res;\nerror:\n\tisl_vec_free(vec);\n\tisl_reordering_free(r);\n\treturn NULL;\n}\n\n/* Reorder the dimensions of the domain of \"aff\" according\n * to the given reordering.\n */\n__isl_give isl_aff *isl_aff_realign_domain(__isl_take isl_aff *aff,\n\t__isl_take isl_reordering *r)\n{\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\n\tr = isl_reordering_extend(r, aff->ls->div->n_row);\n\taff->v = vec_reorder(aff->v, isl_reordering_copy(r),\n\t\t\t\taff->ls->div->n_row);\n\taff->ls = isl_local_space_realign(aff->ls, r);\n\n\tif (!aff->v || !aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_reordering_free(r);\n\treturn NULL;\n}\n\n__isl_give isl_aff *isl_aff_align_params(__isl_take isl_aff *aff,\n\t__isl_take isl_space *model)\n{\n\tisl_bool equal_params;\n\n\tif (!aff || !model)\n\t\tgoto error;\n\n\tequal_params = isl_space_has_equal_params(aff->ls->dim, model);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (!equal_params) {\n\t\tisl_reordering *exp;\n\n\t\texp = isl_parameter_alignment_reordering(aff->ls->dim, model);\n\t\texp = isl_reordering_extend_space(exp,\n\t\t\t\t\tisl_aff_get_domain_space(aff));\n\t\taff = isl_aff_realign_domain(aff, exp);\n\t}\n\n\tisl_space_free(model);\n\treturn aff;\nerror:\n\tisl_space_free(model);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n#undef TYPE\n#define TYPE isl_aff\n#include \"isl_unbind_params_templ.c\"\n\n/* Is \"aff\" obviously equal to zero?\n *\n * If the denominator is zero, then \"aff\" is not equal to zero.\n */\nisl_bool isl_aff_plain_is_zero(__isl_keep isl_aff *aff)\n{\n\tint pos;\n\n\tif (!aff)\n\t\treturn isl_bool_error;\n\n\tif (isl_int_is_zero(aff->v->el[0]))\n\t\treturn isl_bool_false;\n\tpos = isl_seq_first_non_zero(aff->v->el + 1, aff->v->size - 1);\n\treturn isl_bool_ok(pos < 0);\n}\n\n/* Does \"aff\" represent NaN?\n */\nisl_bool isl_aff_is_nan(__isl_keep isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn isl_bool_error;\n\n\treturn isl_bool_ok(isl_seq_first_non_zero(aff->v->el, 2) < 0);\n}\n\n/* Are \"aff1\" and \"aff2\" obviously equal?\n *\n * NaN is not equal to anything, not even to another NaN.\n */\nisl_bool isl_aff_plain_is_equal(__isl_keep isl_aff *aff1,\n\t__isl_keep isl_aff *aff2)\n{\n\tisl_bool equal;\n\n\tif (!aff1 || !aff2)\n\t\treturn isl_bool_error;\n\n\tif (isl_aff_is_nan(aff1) || isl_aff_is_nan(aff2))\n\t\treturn isl_bool_false;\n\n\tequal = isl_local_space_is_equal(aff1->ls, aff2->ls);\n\tif (equal < 0 || !equal)\n\t\treturn equal;\n\n\treturn isl_vec_is_equal(aff1->v, aff2->v);\n}\n\n/* Return the common denominator of \"aff\" in \"v\".\n *\n * We cannot return anything meaningful in case of a NaN.\n */\nisl_stat isl_aff_get_denominator(__isl_keep isl_aff *aff, isl_int *v)\n{\n\tif (!aff)\n\t\treturn isl_stat_error;\n\tif (isl_aff_is_nan(aff))\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"cannot get denominator of NaN\", return isl_stat_error);\n\tisl_int_set(*v, aff->v->el[0]);\n\treturn isl_stat_ok;\n}\n\n/* Return the common denominator of \"aff\".\n */\n__isl_give isl_val *isl_aff_get_denominator_val(__isl_keep isl_aff *aff)\n{\n\tisl_ctx *ctx;\n\n\tif (!aff)\n\t\treturn NULL;\n\n\tctx = isl_aff_get_ctx(aff);\n\tif (isl_aff_is_nan(aff))\n\t\treturn isl_val_nan(ctx);\n\treturn isl_val_int_from_isl_int(ctx, aff->v->el[0]);\n}\n\n/* Return the constant term of \"aff\".\n */\n__isl_give isl_val *isl_aff_get_constant_val(__isl_keep isl_aff *aff)\n{\n\tisl_ctx *ctx;\n\tisl_val *v;\n\n\tif (!aff)\n\t\treturn NULL;\n\n\tctx = isl_aff_get_ctx(aff);\n\tif (isl_aff_is_nan(aff))\n\t\treturn isl_val_nan(ctx);\n\tv = isl_val_rat_from_isl_int(ctx, aff->v->el[1], aff->v->el[0]);\n\treturn isl_val_normalize(v);\n}\n\n/* Return the coefficient of the variable of type \"type\" at position \"pos\"\n * of \"aff\".\n */\n__isl_give isl_val *isl_aff_get_coefficient_val(__isl_keep isl_aff *aff,\n\tenum isl_dim_type type, int pos)\n{\n\tisl_ctx *ctx;\n\tisl_val *v;\n\n\tif (!aff)\n\t\treturn NULL;\n\n\tctx = isl_aff_get_ctx(aff);\n\tif (type == isl_dim_out)\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"output/set dimension does not have a coefficient\",\n\t\t\treturn NULL);\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tif (isl_local_space_check_range(aff->ls, type, pos, 1) < 0)\n\t\treturn NULL;\n\n\tif (isl_aff_is_nan(aff))\n\t\treturn isl_val_nan(ctx);\n\tpos += isl_local_space_offset(aff->ls, type);\n\tv = isl_val_rat_from_isl_int(ctx, aff->v->el[1 + pos], aff->v->el[0]);\n\treturn isl_val_normalize(v);\n}\n\n/* Return the sign of the coefficient of the variable of type \"type\"\n * at position \"pos\" of \"aff\".\n */\nint isl_aff_coefficient_sgn(__isl_keep isl_aff *aff, enum isl_dim_type type,\n\tint pos)\n{\n\tisl_ctx *ctx;\n\n\tif (!aff)\n\t\treturn 0;\n\n\tctx = isl_aff_get_ctx(aff);\n\tif (type == isl_dim_out)\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"output/set dimension does not have a coefficient\",\n\t\t\treturn 0);\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tif (isl_local_space_check_range(aff->ls, type, pos, 1) < 0)\n\t\treturn 0;\n\n\tpos += isl_local_space_offset(aff->ls, type);\n\treturn isl_int_sgn(aff->v->el[1 + pos]);\n}\n\n/* Replace the numerator of the constant term of \"aff\" by \"v\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_set_constant(__isl_take isl_aff *aff, isl_int v)\n{\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_int_set(aff->v->el[1], v);\n\n\treturn aff;\n}\n\n/* Replace the constant term of \"aff\" by \"v\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_set_constant_val(__isl_take isl_aff *aff,\n\t__isl_take isl_val *v)\n{\n\tif (!aff || !v)\n\t\tgoto error;\n\n\tif (isl_aff_is_nan(aff)) {\n\t\tisl_val_free(v);\n\t\treturn aff;\n\t}\n\n\tif (!isl_val_is_rat(v))\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"expecting rational value\", goto error);\n\n\tif (isl_int_eq(aff->v->el[1], v->n) &&\n\t    isl_int_eq(aff->v->el[0], v->d)) {\n\t\tisl_val_free(v);\n\t\treturn aff;\n\t}\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\tgoto error;\n\n\tif (isl_int_eq(aff->v->el[0], v->d)) {\n\t\tisl_int_set(aff->v->el[1], v->n);\n\t} else if (isl_int_is_one(v->d)) {\n\t\tisl_int_mul(aff->v->el[1], aff->v->el[0], v->n);\n\t} else {\n\t\tisl_seq_scale(aff->v->el + 1,\n\t\t\t\taff->v->el + 1, v->d, aff->v->size - 1);\n\t\tisl_int_mul(aff->v->el[1], aff->v->el[0], v->n);\n\t\tisl_int_mul(aff->v->el[0], aff->v->el[0], v->d);\n\t\taff->v = isl_vec_normalize(aff->v);\n\t\tif (!aff->v)\n\t\t\tgoto error;\n\t}\n\n\tisl_val_free(v);\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n/* Add \"v\" to the constant term of \"aff\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_add_constant(__isl_take isl_aff *aff, isl_int v)\n{\n\tif (isl_int_is_zero(v))\n\t\treturn aff;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_int_addmul(aff->v->el[1], aff->v->el[0], v);\n\n\treturn aff;\n}\n\n/* Add \"v\" to the constant term of \"aff\",\n * in case \"aff\" is a rational expression.\n */\nstatic __isl_give isl_aff *isl_aff_add_rat_constant_val(__isl_take isl_aff *aff,\n\t__isl_take isl_val *v)\n{\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\tgoto error;\n\n\tif (isl_int_is_one(v->d)) {\n\t\tisl_int_addmul(aff->v->el[1], aff->v->el[0], v->n);\n\t} else if (isl_int_eq(aff->v->el[0], v->d)) {\n\t\tisl_int_add(aff->v->el[1], aff->v->el[1], v->n);\n\t\taff->v = isl_vec_normalize(aff->v);\n\t\tif (!aff->v)\n\t\t\tgoto error;\n\t} else {\n\t\tisl_seq_scale(aff->v->el + 1,\n\t\t\t\taff->v->el + 1, v->d, aff->v->size - 1);\n\t\tisl_int_addmul(aff->v->el[1], aff->v->el[0], v->n);\n\t\tisl_int_mul(aff->v->el[0], aff->v->el[0], v->d);\n\t\taff->v = isl_vec_normalize(aff->v);\n\t\tif (!aff->v)\n\t\t\tgoto error;\n\t}\n\n\tisl_val_free(v);\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n/* Return the first argument and free the second.\n */\nstatic __isl_give isl_aff *pick_free(__isl_take isl_aff *aff,\n\t__isl_take isl_val *v)\n{\n\tisl_val_free(v);\n\treturn aff;\n}\n\n/* Replace the first argument by NaN and free the second argument.\n */\nstatic __isl_give isl_aff *set_nan_free_val(__isl_take isl_aff *aff,\n\t__isl_take isl_val *v)\n{\n\tisl_val_free(v);\n\treturn isl_aff_set_nan(aff);\n}\n\n/* Add \"v\" to the constant term of \"aff\".\n *\n * A NaN is unaffected by this operation.\n * Conversely, adding a NaN turns \"aff\" into a NaN.\n */\n__isl_give isl_aff *isl_aff_add_constant_val(__isl_take isl_aff *aff,\n\t__isl_take isl_val *v)\n{\n\tisl_bool is_nan, is_zero, is_rat;\n\n\tis_nan = isl_aff_is_nan(aff);\n\tis_zero = isl_val_is_zero(v);\n\tif (is_nan < 0 || is_zero < 0)\n\t\tgoto error;\n\tif (is_nan || is_zero)\n\t\treturn pick_free(aff, v);\n\n\tis_nan = isl_val_is_nan(v);\n\tis_rat = isl_val_is_rat(v);\n\tif (is_nan < 0 || is_rat < 0)\n\t\tgoto error;\n\tif (is_nan)\n\t\treturn set_nan_free_val(aff, v);\n\tif (!is_rat)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"expecting rational value or NaN\", goto error);\n\n\treturn isl_aff_add_rat_constant_val(aff, v);\nerror:\n\tisl_aff_free(aff);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n__isl_give isl_aff *isl_aff_add_constant_si(__isl_take isl_aff *aff, int v)\n{\n\tisl_int t;\n\n\tisl_int_init(t);\n\tisl_int_set_si(t, v);\n\taff = isl_aff_add_constant(aff, t);\n\tisl_int_clear(t);\n\n\treturn aff;\n}\n\n/* Add \"v\" to the numerator of the constant term of \"aff\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_add_constant_num(__isl_take isl_aff *aff, isl_int v)\n{\n\tif (isl_int_is_zero(v))\n\t\treturn aff;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_int_add(aff->v->el[1], aff->v->el[1], v);\n\n\treturn aff;\n}\n\n/* Add \"v\" to the numerator of the constant term of \"aff\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_add_constant_num_si(__isl_take isl_aff *aff, int v)\n{\n\tisl_int t;\n\n\tif (v == 0)\n\t\treturn aff;\n\n\tisl_int_init(t);\n\tisl_int_set_si(t, v);\n\taff = isl_aff_add_constant_num(aff, t);\n\tisl_int_clear(t);\n\n\treturn aff;\n}\n\n/* Replace the numerator of the constant term of \"aff\" by \"v\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_set_constant_si(__isl_take isl_aff *aff, int v)\n{\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_int_set_si(aff->v->el[1], v);\n\n\treturn aff;\n}\n\n/* Replace the numerator of the coefficient of the variable of type \"type\"\n * at position \"pos\" of \"aff\" by \"v\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_set_coefficient(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, int pos, isl_int v)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"output/set dimension does not have a coefficient\",\n\t\t\treturn isl_aff_free(aff));\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tif (isl_local_space_check_range(aff->ls, type, pos, 1) < 0)\n\t\treturn isl_aff_free(aff);\n\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tpos += isl_local_space_offset(aff->ls, type);\n\tisl_int_set(aff->v->el[1 + pos], v);\n\n\treturn aff;\n}\n\n/* Replace the numerator of the coefficient of the variable of type \"type\"\n * at position \"pos\" of \"aff\" by \"v\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_set_coefficient_si(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, int pos, int v)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"output/set dimension does not have a coefficient\",\n\t\t\treturn isl_aff_free(aff));\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tif (isl_local_space_check_range(aff->ls, type, pos, 1) < 0)\n\t\treturn isl_aff_free(aff);\n\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\tpos += isl_local_space_offset(aff->ls, type);\n\tif (isl_int_cmp_si(aff->v->el[1 + pos], v) == 0)\n\t\treturn aff;\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_int_set_si(aff->v->el[1 + pos], v);\n\n\treturn aff;\n}\n\n/* Replace the coefficient of the variable of type \"type\" at position \"pos\"\n * of \"aff\" by \"v\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_set_coefficient_val(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, int pos, __isl_take isl_val *v)\n{\n\tif (!aff || !v)\n\t\tgoto error;\n\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"output/set dimension does not have a coefficient\",\n\t\t\tgoto error);\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tif (isl_local_space_check_range(aff->ls, type, pos, 1) < 0)\n\t\treturn isl_aff_free(aff);\n\n\tif (isl_aff_is_nan(aff)) {\n\t\tisl_val_free(v);\n\t\treturn aff;\n\t}\n\tif (!isl_val_is_rat(v))\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"expecting rational value\", goto error);\n\n\tpos += isl_local_space_offset(aff->ls, type);\n\tif (isl_int_eq(aff->v->el[1 + pos], v->n) &&\n\t    isl_int_eq(aff->v->el[0], v->d)) {\n\t\tisl_val_free(v);\n\t\treturn aff;\n\t}\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\tgoto error;\n\n\tif (isl_int_eq(aff->v->el[0], v->d)) {\n\t\tisl_int_set(aff->v->el[1 + pos], v->n);\n\t} else if (isl_int_is_one(v->d)) {\n\t\tisl_int_mul(aff->v->el[1 + pos], aff->v->el[0], v->n);\n\t} else {\n\t\tisl_seq_scale(aff->v->el + 1,\n\t\t\t\taff->v->el + 1, v->d, aff->v->size - 1);\n\t\tisl_int_mul(aff->v->el[1 + pos], aff->v->el[0], v->n);\n\t\tisl_int_mul(aff->v->el[0], aff->v->el[0], v->d);\n\t\taff->v = isl_vec_normalize(aff->v);\n\t\tif (!aff->v)\n\t\t\tgoto error;\n\t}\n\n\tisl_val_free(v);\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n/* Add \"v\" to the coefficient of the variable of type \"type\"\n * at position \"pos\" of \"aff\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_add_coefficient(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, int pos, isl_int v)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"output/set dimension does not have a coefficient\",\n\t\t\treturn isl_aff_free(aff));\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tif (isl_local_space_check_range(aff->ls, type, pos, 1) < 0)\n\t\treturn isl_aff_free(aff);\n\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tpos += isl_local_space_offset(aff->ls, type);\n\tisl_int_addmul(aff->v->el[1 + pos], aff->v->el[0], v);\n\n\treturn aff;\n}\n\n/* Add \"v\" to the coefficient of the variable of type \"type\"\n * at position \"pos\" of \"aff\".\n *\n * A NaN is unaffected by this operation.\n */\n__isl_give isl_aff *isl_aff_add_coefficient_val(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, int pos, __isl_take isl_val *v)\n{\n\tif (!aff || !v)\n\t\tgoto error;\n\n\tif (isl_val_is_zero(v)) {\n\t\tisl_val_free(v);\n\t\treturn aff;\n\t}\n\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"output/set dimension does not have a coefficient\",\n\t\t\tgoto error);\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tif (isl_local_space_check_range(aff->ls, type, pos, 1) < 0)\n\t\tgoto error;\n\n\tif (isl_aff_is_nan(aff)) {\n\t\tisl_val_free(v);\n\t\treturn aff;\n\t}\n\tif (!isl_val_is_rat(v))\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"expecting rational value\", goto error);\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\tgoto error;\n\n\tpos += isl_local_space_offset(aff->ls, type);\n\tif (isl_int_is_one(v->d)) {\n\t\tisl_int_addmul(aff->v->el[1 + pos], aff->v->el[0], v->n);\n\t} else if (isl_int_eq(aff->v->el[0], v->d)) {\n\t\tisl_int_add(aff->v->el[1 + pos], aff->v->el[1 + pos], v->n);\n\t\taff->v = isl_vec_normalize(aff->v);\n\t\tif (!aff->v)\n\t\t\tgoto error;\n\t} else {\n\t\tisl_seq_scale(aff->v->el + 1,\n\t\t\t\taff->v->el + 1, v->d, aff->v->size - 1);\n\t\tisl_int_addmul(aff->v->el[1 + pos], aff->v->el[0], v->n);\n\t\tisl_int_mul(aff->v->el[0], aff->v->el[0], v->d);\n\t\taff->v = isl_vec_normalize(aff->v);\n\t\tif (!aff->v)\n\t\t\tgoto error;\n\t}\n\n\tisl_val_free(v);\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n__isl_give isl_aff *isl_aff_add_coefficient_si(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, int pos, int v)\n{\n\tisl_int t;\n\n\tisl_int_init(t);\n\tisl_int_set_si(t, v);\n\taff = isl_aff_add_coefficient(aff, type, pos, t);\n\tisl_int_clear(t);\n\n\treturn aff;\n}\n\n__isl_give isl_aff *isl_aff_get_div(__isl_keep isl_aff *aff, int pos)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\treturn isl_local_space_get_div(aff->ls, pos);\n}\n\n/* Return the negation of \"aff\".\n *\n * As a special case, -NaN = NaN.\n */\n__isl_give isl_aff *isl_aff_neg(__isl_take isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_seq_neg(aff->v->el + 1, aff->v->el + 1, aff->v->size - 1);\n\n\treturn aff;\n}\n\n/* Remove divs from the local space that do not appear in the affine\n * expression.\n * We currently only remove divs at the end.\n * Some intermediate divs may also not appear directly in the affine\n * expression, but we would also need to check that no other divs are\n * defined in terms of them.\n */\n__isl_give isl_aff *isl_aff_remove_unused_divs(__isl_take isl_aff *aff)\n{\n\tint pos;\n\tisl_size off;\n\tisl_size n;\n\n\tn = isl_aff_domain_dim(aff, isl_dim_div);\n\toff = isl_aff_domain_offset(aff, isl_dim_div);\n\tif (n < 0 || off < 0)\n\t\treturn isl_aff_free(aff);\n\n\tpos = isl_seq_last_non_zero(aff->v->el + 1 + off, n) + 1;\n\tif (pos == n)\n\t\treturn aff;\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->ls = isl_local_space_drop_dims(aff->ls, isl_dim_div, pos, n - pos);\n\taff->v = isl_vec_drop_els(aff->v, 1 + off + pos, n - pos);\n\tif (!aff->ls || !aff->v)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\n}\n\n/* Look for any divs in the aff->ls with a denominator equal to one\n * and plug them into the affine expression and any subsequent divs\n * that may reference the div.\n */\nstatic __isl_give isl_aff *plug_in_integral_divs(__isl_take isl_aff *aff)\n{\n\tint i;\n\tisl_size n;\n\tint len;\n\tisl_int v;\n\tisl_vec *vec;\n\tisl_local_space *ls;\n\tisl_size off;\n\n\tn = isl_aff_domain_dim(aff, isl_dim_div);\n\toff = isl_aff_domain_offset(aff, isl_dim_div);\n\tif (n < 0 || off < 0)\n\t\treturn isl_aff_free(aff);\n\tlen = aff->v->size;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (!isl_int_is_one(aff->ls->div->row[i][0]))\n\t\t\tcontinue;\n\t\tls = isl_local_space_copy(aff->ls);\n\t\tls = isl_local_space_substitute_seq(ls, isl_dim_div, i,\n\t\t\t\taff->ls->div->row[i], len, i + 1, n - (i + 1));\n\t\tvec = isl_vec_copy(aff->v);\n\t\tvec = isl_vec_cow(vec);\n\t\tif (!ls || !vec)\n\t\t\tgoto error;\n\n\t\tisl_int_init(v);\n\n\t\tisl_seq_substitute(vec->el, off + i, aff->ls->div->row[i],\n\t\t\t\t\tlen, len, v);\n\n\t\tisl_int_clear(v);\n\n\t\tisl_vec_free(aff->v);\n\t\taff->v = vec;\n\t\tisl_local_space_free(aff->ls);\n\t\taff->ls = ls;\n\t}\n\n\treturn aff;\nerror:\n\tisl_vec_free(vec);\n\tisl_local_space_free(ls);\n\treturn isl_aff_free(aff);\n}\n\n/* Look for any divs j that appear with a unit coefficient inside\n * the definitions of other divs i and plug them into the definitions\n * of the divs i.\n *\n * In particular, an expression of the form\n *\n *\tfloor((f(..) + floor(g(..)/n))/m)\n *\n * is simplified to\n *\n *\tfloor((n * f(..) + g(..))/(n * m))\n *\n * This simplification is correct because we can move the expression\n * f(..) into the inner floor in the original expression to obtain\n *\n *\tfloor(floor((n * f(..) + g(..))/n)/m)\n *\n * from which we can derive the simplified expression.\n */\nstatic __isl_give isl_aff *plug_in_unit_divs(__isl_take isl_aff *aff)\n{\n\tint i, j;\n\tisl_size n;\n\tisl_size off;\n\n\tn = isl_aff_domain_dim(aff, isl_dim_div);\n\toff = isl_aff_domain_offset(aff, isl_dim_div);\n\tif (n < 0 || off < 0)\n\t\treturn isl_aff_free(aff);\n\tfor (i = 1; i < n; ++i) {\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\tif (!isl_int_is_one(aff->ls->div->row[i][1 + off + j]))\n\t\t\t\tcontinue;\n\t\t\taff->ls = isl_local_space_substitute_seq(aff->ls,\n\t\t\t\tisl_dim_div, j, aff->ls->div->row[j],\n\t\t\t\taff->v->size, i, 1);\n\t\t\tif (!aff->ls)\n\t\t\t\treturn isl_aff_free(aff);\n\t\t}\n\t}\n\n\treturn aff;\n}\n\n/* Swap divs \"a\" and \"b\" in \"aff\", which is assumed to be non-NULL.\n *\n * Even though this function is only called on isl_affs with a single\n * reference, we are careful to only change aff->v and aff->ls together.\n */\nstatic __isl_give isl_aff *swap_div(__isl_take isl_aff *aff, int a, int b)\n{\n\tisl_size off = isl_aff_domain_offset(aff, isl_dim_div);\n\tisl_local_space *ls;\n\tisl_vec *v;\n\n\tif (off < 0)\n\t\treturn isl_aff_free(aff);\n\n\tls = isl_local_space_copy(aff->ls);\n\tls = isl_local_space_swap_div(ls, a, b);\n\tv = isl_vec_copy(aff->v);\n\tv = isl_vec_cow(v);\n\tif (!ls || !v)\n\t\tgoto error;\n\n\tisl_int_swap(v->el[1 + off + a], v->el[1 + off + b]);\n\tisl_vec_free(aff->v);\n\taff->v = v;\n\tisl_local_space_free(aff->ls);\n\taff->ls = ls;\n\n\treturn aff;\nerror:\n\tisl_vec_free(v);\n\tisl_local_space_free(ls);\n\treturn isl_aff_free(aff);\n}\n\n/* Merge divs \"a\" and \"b\" in \"aff\", which is assumed to be non-NULL.\n *\n * We currently do not actually remove div \"b\", but simply add its\n * coefficient to that of \"a\" and then zero it out.\n */\nstatic __isl_give isl_aff *merge_divs(__isl_take isl_aff *aff, int a, int b)\n{\n\tisl_size off = isl_aff_domain_offset(aff, isl_dim_div);\n\n\tif (off < 0)\n\t\treturn isl_aff_free(aff);\n\n\tif (isl_int_is_zero(aff->v->el[1 + off + b]))\n\t\treturn aff;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_int_add(aff->v->el[1 + off + a],\n\t\t    aff->v->el[1 + off + a], aff->v->el[1 + off + b]);\n\tisl_int_set_si(aff->v->el[1 + off + b], 0);\n\n\treturn aff;\n}\n\n/* Sort the divs in the local space of \"aff\" according to\n * the comparison function \"cmp_row\" in isl_local_space.c,\n * combining the coefficients of identical divs.\n *\n * Reordering divs does not change the semantics of \"aff\",\n * so there is no need to call isl_aff_cow.\n * Moreover, this function is currently only called on isl_affs\n * with a single reference.\n */\nstatic __isl_give isl_aff *sort_divs(__isl_take isl_aff *aff)\n{\n\tisl_size n;\n\tint i, j;\n\n\tn = isl_aff_dim(aff, isl_dim_div);\n\tif (n < 0)\n\t\treturn isl_aff_free(aff);\n\tfor (i = 1; i < n; ++i) {\n\t\tfor (j = i - 1; j >= 0; --j) {\n\t\t\tint cmp = isl_mat_cmp_div(aff->ls->div, j, j + 1);\n\t\t\tif (cmp < 0)\n\t\t\t\tbreak;\n\t\t\tif (cmp == 0)\n\t\t\t\taff = merge_divs(aff, j, j + 1);\n\t\t\telse\n\t\t\t\taff = swap_div(aff, j, j + 1);\n\t\t\tif (!aff)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn aff;\n}\n\n/* Normalize the representation of \"aff\".\n *\n * This function should only be called on \"new\" isl_affs, i.e.,\n * with only a single reference.  We therefore do not need to\n * worry about affecting other instances.\n */\n__isl_give isl_aff *isl_aff_normalize(__isl_take isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn NULL;\n\taff->v = isl_vec_normalize(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\taff = plug_in_integral_divs(aff);\n\taff = plug_in_unit_divs(aff);\n\taff = sort_divs(aff);\n\taff = isl_aff_remove_unused_divs(aff);\n\treturn aff;\n}\n\n/* Given f, return floor(f).\n * If f is an integer expression, then just return f.\n * If f is a constant, then return the constant floor(f).\n * Otherwise, if f = g/m, write g = q m + r,\n * create a new div d = [r/m] and return the expression q + d.\n * The coefficients in r are taken to lie between -m/2 and m/2.\n *\n * reduce_div_coefficients performs the same normalization.\n *\n * As a special case, floor(NaN) = NaN.\n */\n__isl_give isl_aff *isl_aff_floor(__isl_take isl_aff *aff)\n{\n\tint i;\n\tint size;\n\tisl_ctx *ctx;\n\tisl_vec *div;\n\n\tif (!aff)\n\t\treturn NULL;\n\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\tif (isl_int_is_one(aff->v->el[0]))\n\t\treturn aff;\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tif (isl_aff_is_cst(aff)) {\n\t\tisl_int_fdiv_q(aff->v->el[1], aff->v->el[1], aff->v->el[0]);\n\t\tisl_int_set_si(aff->v->el[0], 1);\n\t\treturn aff;\n\t}\n\n\tdiv = isl_vec_copy(aff->v);\n\tdiv = isl_vec_cow(div);\n\tif (!div)\n\t\treturn isl_aff_free(aff);\n\n\tctx = isl_aff_get_ctx(aff);\n\tisl_int_fdiv_q(aff->v->el[0], aff->v->el[0], ctx->two);\n\tfor (i = 1; i < aff->v->size; ++i) {\n\t\tisl_int_fdiv_r(div->el[i], div->el[i], div->el[0]);\n\t\tisl_int_fdiv_q(aff->v->el[i], aff->v->el[i], div->el[0]);\n\t\tif (isl_int_gt(div->el[i], aff->v->el[0])) {\n\t\t\tisl_int_sub(div->el[i], div->el[i], div->el[0]);\n\t\t\tisl_int_add_ui(aff->v->el[i], aff->v->el[i], 1);\n\t\t}\n\t}\n\n\taff->ls = isl_local_space_add_div(aff->ls, div);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\tsize = aff->v->size;\n\taff->v = isl_vec_extend(aff->v, size + 1);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\tisl_int_set_si(aff->v->el[0], 1);\n\tisl_int_set_si(aff->v->el[size], 1);\n\n\taff = isl_aff_normalize(aff);\n\n\treturn aff;\n}\n\n/* Compute\n *\n *\taff mod m = aff - m * floor(aff/m)\n *\n * with m an integer value.\n */\n__isl_give isl_aff *isl_aff_mod_val(__isl_take isl_aff *aff,\n\t__isl_take isl_val *m)\n{\n\tisl_aff *res;\n\n\tif (!aff || !m)\n\t\tgoto error;\n\n\tif (!isl_val_is_int(m))\n\t\tisl_die(isl_val_get_ctx(m), isl_error_invalid,\n\t\t\t\"expecting integer modulo\", goto error);\n\n\tres = isl_aff_copy(aff);\n\taff = isl_aff_scale_down_val(aff, isl_val_copy(m));\n\taff = isl_aff_floor(aff);\n\taff = isl_aff_scale_val(aff, m);\n\tres = isl_aff_sub(res, aff);\n\n\treturn res;\nerror:\n\tisl_aff_free(aff);\n\tisl_val_free(m);\n\treturn NULL;\n}\n\n/* Compute\n *\n *\tpwaff mod m = pwaff - m * floor(pwaff/m)\n */\n__isl_give isl_pw_aff *isl_pw_aff_mod(__isl_take isl_pw_aff *pwaff, isl_int m)\n{\n\tisl_pw_aff *res;\n\n\tres = isl_pw_aff_copy(pwaff);\n\tpwaff = isl_pw_aff_scale_down(pwaff, m);\n\tpwaff = isl_pw_aff_floor(pwaff);\n\tpwaff = isl_pw_aff_scale(pwaff, m);\n\tres = isl_pw_aff_sub(res, pwaff);\n\n\treturn res;\n}\n\n/* Compute\n *\n *\tpa mod m = pa - m * floor(pa/m)\n *\n * with m an integer value.\n */\n__isl_give isl_pw_aff *isl_pw_aff_mod_val(__isl_take isl_pw_aff *pa,\n\t__isl_take isl_val *m)\n{\n\tif (!pa || !m)\n\t\tgoto error;\n\tif (!isl_val_is_int(m))\n\t\tisl_die(isl_pw_aff_get_ctx(pa), isl_error_invalid,\n\t\t\t\"expecting integer modulo\", goto error);\n\tpa = isl_pw_aff_mod(pa, m->n);\n\tisl_val_free(m);\n\treturn pa;\nerror:\n\tisl_pw_aff_free(pa);\n\tisl_val_free(m);\n\treturn NULL;\n}\n\n/* Given f, return ceil(f).\n * If f is an integer expression, then just return f.\n * Otherwise, let f be the expression\n *\n *\te/m\n *\n * then return\n *\n *\tfloor((e + m - 1)/m)\n *\n * As a special case, ceil(NaN) = NaN.\n */\n__isl_give isl_aff *isl_aff_ceil(__isl_take isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn NULL;\n\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\tif (isl_int_is_one(aff->v->el[0]))\n\t\treturn aff;\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_int_add(aff->v->el[1], aff->v->el[1], aff->v->el[0]);\n\tisl_int_sub_ui(aff->v->el[1], aff->v->el[1], 1);\n\taff = isl_aff_floor(aff);\n\n\treturn aff;\n}\n\n/* Apply the expansion computed by isl_merge_divs.\n * The expansion itself is given by \"exp\" while the resulting\n * list of divs is given by \"div\".\n */\n__isl_give isl_aff *isl_aff_expand_divs(__isl_take isl_aff *aff,\n\t__isl_take isl_mat *div, int *exp)\n{\n\tisl_size old_n_div;\n\tisl_size new_n_div;\n\tisl_size offset;\n\n\taff = isl_aff_cow(aff);\n\n\toffset = isl_aff_domain_offset(aff, isl_dim_div);\n\told_n_div = isl_aff_domain_dim(aff, isl_dim_div);\n\tnew_n_div = isl_mat_rows(div);\n\tif (offset < 0 || old_n_div < 0 || new_n_div < 0)\n\t\tgoto error;\n\n\taff->v = isl_vec_expand(aff->v, 1 + offset, old_n_div, exp, new_n_div);\n\taff->ls = isl_local_space_replace_divs(aff->ls, div);\n\tif (!aff->v || !aff->ls)\n\t\treturn isl_aff_free(aff);\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_mat_free(div);\n\treturn NULL;\n}\n\n/* Add two affine expressions that live in the same local space.\n */\nstatic __isl_give isl_aff *add_expanded(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\tisl_int gcd, f;\n\n\taff1 = isl_aff_cow(aff1);\n\tif (!aff1 || !aff2)\n\t\tgoto error;\n\n\taff1->v = isl_vec_cow(aff1->v);\n\tif (!aff1->v)\n\t\tgoto error;\n\n\tisl_int_init(gcd);\n\tisl_int_init(f);\n\tisl_int_gcd(gcd, aff1->v->el[0], aff2->v->el[0]);\n\tisl_int_divexact(f, aff2->v->el[0], gcd);\n\tisl_seq_scale(aff1->v->el + 1, aff1->v->el + 1, f, aff1->v->size - 1);\n\tisl_int_divexact(f, aff1->v->el[0], gcd);\n\tisl_seq_addmul(aff1->v->el + 1, f, aff2->v->el + 1, aff1->v->size - 1);\n\tisl_int_divexact(f, aff2->v->el[0], gcd);\n\tisl_int_mul(aff1->v->el[0], aff1->v->el[0], f);\n\tisl_int_clear(f);\n\tisl_int_clear(gcd);\n\n\tisl_aff_free(aff2);\n\taff1 = isl_aff_normalize(aff1);\n\treturn aff1;\nerror:\n\tisl_aff_free(aff1);\n\tisl_aff_free(aff2);\n\treturn NULL;\n}\n\n/* Replace one of the arguments by a NaN and free the other one.\n */\nstatic __isl_give isl_aff *set_nan_free(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\tisl_aff_free(aff2);\n\treturn isl_aff_set_nan(aff1);\n}\n\n/* Return the sum of \"aff1\" and \"aff2\".\n *\n * If either of the two is NaN, then the result is NaN.\n */\n__isl_give isl_aff *isl_aff_add(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\tisl_ctx *ctx;\n\tint *exp1 = NULL;\n\tint *exp2 = NULL;\n\tisl_mat *div;\n\tisl_size n_div1, n_div2;\n\n\tif (!aff1 || !aff2)\n\t\tgoto error;\n\n\tctx = isl_aff_get_ctx(aff1);\n\tif (!isl_space_is_equal(aff1->ls->dim, aff2->ls->dim))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\n\tif (isl_aff_is_nan(aff1)) {\n\t\tisl_aff_free(aff2);\n\t\treturn aff1;\n\t}\n\tif (isl_aff_is_nan(aff2)) {\n\t\tisl_aff_free(aff1);\n\t\treturn aff2;\n\t}\n\n\tn_div1 = isl_aff_dim(aff1, isl_dim_div);\n\tn_div2 = isl_aff_dim(aff2, isl_dim_div);\n\tif (n_div1 < 0 || n_div2 < 0)\n\t\tgoto error;\n\tif (n_div1 == 0 && n_div2 == 0)\n\t\treturn add_expanded(aff1, aff2);\n\n\texp1 = isl_alloc_array(ctx, int, n_div1);\n\texp2 = isl_alloc_array(ctx, int, n_div2);\n\tif ((n_div1 && !exp1) || (n_div2 && !exp2))\n\t\tgoto error;\n\n\tdiv = isl_merge_divs(aff1->ls->div, aff2->ls->div, exp1, exp2);\n\taff1 = isl_aff_expand_divs(aff1, isl_mat_copy(div), exp1);\n\taff2 = isl_aff_expand_divs(aff2, div, exp2);\n\tfree(exp1);\n\tfree(exp2);\n\n\treturn add_expanded(aff1, aff2);\nerror:\n\tfree(exp1);\n\tfree(exp2);\n\tisl_aff_free(aff1);\n\tisl_aff_free(aff2);\n\treturn NULL;\n}\n\n__isl_give isl_aff *isl_aff_sub(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\treturn isl_aff_add(aff1, isl_aff_neg(aff2));\n}\n\n/* Return the result of scaling \"aff\" by a factor of \"f\".\n *\n * As a special case, f * NaN = NaN.\n */\n__isl_give isl_aff *isl_aff_scale(__isl_take isl_aff *aff, isl_int f)\n{\n\tisl_int gcd;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\n\tif (isl_int_is_one(f))\n\t\treturn aff;\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tif (isl_int_is_pos(f) && isl_int_is_divisible_by(aff->v->el[0], f)) {\n\t\tisl_int_divexact(aff->v->el[0], aff->v->el[0], f);\n\t\treturn aff;\n\t}\n\n\tisl_int_init(gcd);\n\tisl_int_gcd(gcd, aff->v->el[0], f);\n\tisl_int_divexact(aff->v->el[0], aff->v->el[0], gcd);\n\tisl_int_divexact(gcd, f, gcd);\n\tisl_seq_scale(aff->v->el + 1, aff->v->el + 1, gcd, aff->v->size - 1);\n\tisl_int_clear(gcd);\n\n\treturn aff;\n}\n\n/* Multiple \"aff\" by \"v\".\n */\n__isl_give isl_aff *isl_aff_scale_val(__isl_take isl_aff *aff,\n\t__isl_take isl_val *v)\n{\n\tif (!aff || !v)\n\t\tgoto error;\n\n\tif (isl_val_is_one(v)) {\n\t\tisl_val_free(v);\n\t\treturn aff;\n\t}\n\n\tif (!isl_val_is_rat(v))\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"expecting rational factor\", goto error);\n\n\taff = isl_aff_scale(aff, v->n);\n\taff = isl_aff_scale_down(aff, v->d);\n\n\tisl_val_free(v);\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n/* Return the result of scaling \"aff\" down by a factor of \"f\".\n *\n * As a special case, NaN/f = NaN.\n */\n__isl_give isl_aff *isl_aff_scale_down(__isl_take isl_aff *aff, isl_int f)\n{\n\tisl_int gcd;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff))\n\t\treturn aff;\n\n\tif (isl_int_is_one(f))\n\t\treturn aff;\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\tif (isl_int_is_zero(f))\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"cannot scale down by zero\", return isl_aff_free(aff));\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tisl_int_init(gcd);\n\tisl_seq_gcd(aff->v->el + 1, aff->v->size - 1, &gcd);\n\tisl_int_gcd(gcd, gcd, f);\n\tisl_seq_scale_down(aff->v->el + 1, aff->v->el + 1, gcd, aff->v->size - 1);\n\tisl_int_divexact(gcd, f, gcd);\n\tisl_int_mul(aff->v->el[0], aff->v->el[0], gcd);\n\tisl_int_clear(gcd);\n\n\treturn aff;\n}\n\n/* Divide \"aff\" by \"v\".\n */\n__isl_give isl_aff *isl_aff_scale_down_val(__isl_take isl_aff *aff,\n\t__isl_take isl_val *v)\n{\n\tif (!aff || !v)\n\t\tgoto error;\n\n\tif (isl_val_is_one(v)) {\n\t\tisl_val_free(v);\n\t\treturn aff;\n\t}\n\n\tif (!isl_val_is_rat(v))\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"expecting rational factor\", goto error);\n\tif (!isl_val_is_pos(v))\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"factor needs to be positive\", goto error);\n\n\taff = isl_aff_scale(aff, v->d);\n\taff = isl_aff_scale_down(aff, v->n);\n\n\tisl_val_free(v);\n\treturn aff;\nerror:\n\tisl_aff_free(aff);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n__isl_give isl_aff *isl_aff_scale_down_ui(__isl_take isl_aff *aff, unsigned f)\n{\n\tisl_int v;\n\n\tif (f == 1)\n\t\treturn aff;\n\n\tisl_int_init(v);\n\tisl_int_set_ui(v, f);\n\taff = isl_aff_scale_down(aff, v);\n\tisl_int_clear(v);\n\n\treturn aff;\n}\n\n__isl_give isl_aff *isl_aff_set_dim_name(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, unsigned pos, const char *s)\n{\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"cannot set name of output/set dimension\",\n\t\t\treturn isl_aff_free(aff));\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\taff->ls = isl_local_space_set_dim_name(aff->ls, type, pos, s);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\n}\n\n__isl_give isl_aff *isl_aff_set_dim_id(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_id *id)\n{\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"cannot set name of output/set dimension\",\n\t\t\tgoto error);\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\taff->ls = isl_local_space_set_dim_id(aff->ls, type, pos, id);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\nerror:\n\tisl_id_free(id);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Replace the identifier of the input tuple of \"aff\" by \"id\".\n * type is currently required to be equal to isl_dim_in\n */\n__isl_give isl_aff *isl_aff_set_tuple_id(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, __isl_take isl_id *id)\n{\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\tif (type != isl_dim_in)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"cannot only set id of input tuple\", goto error);\n\taff->ls = isl_local_space_set_tuple_id(aff->ls, isl_dim_set, id);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\nerror:\n\tisl_id_free(id);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Exploit the equalities in \"eq\" to simplify the affine expression\n * and the expressions of the integer divisions in the local space.\n * The integer divisions in this local space are assumed to appear\n * as regular dimensions in \"eq\".\n */\nstatic __isl_give isl_aff *isl_aff_substitute_equalities_lifted(\n\t__isl_take isl_aff *aff, __isl_take isl_basic_set *eq)\n{\n\tint i, j;\n\tunsigned o_div;\n\tunsigned n_div;\n\n\tif (!eq)\n\t\tgoto error;\n\tif (eq->n_eq == 0) {\n\t\tisl_basic_set_free(eq);\n\t\treturn aff;\n\t}\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\tgoto error;\n\n\taff->ls = isl_local_space_substitute_equalities(aff->ls,\n\t\t\t\t\t\t\tisl_basic_set_copy(eq));\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->ls || !aff->v)\n\t\tgoto error;\n\n\to_div = isl_basic_set_offset(eq, isl_dim_div);\n\tn_div = eq->n_div;\n\tfor (i = 0; i < eq->n_eq; ++i) {\n\t\tj = isl_seq_last_non_zero(eq->eq[i], o_div + n_div);\n\t\tif (j < 0 || j == 0 || j >= o_div)\n\t\t\tcontinue;\n\n\t\tisl_seq_elim(aff->v->el + 1, eq->eq[i], j, o_div,\n\t\t\t\t&aff->v->el[0]);\n\t}\n\n\tisl_basic_set_free(eq);\n\taff = isl_aff_normalize(aff);\n\treturn aff;\nerror:\n\tisl_basic_set_free(eq);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Exploit the equalities in \"eq\" to simplify the affine expression\n * and the expressions of the integer divisions in the local space.\n */\n__isl_give isl_aff *isl_aff_substitute_equalities(__isl_take isl_aff *aff,\n\t__isl_take isl_basic_set *eq)\n{\n\tisl_size n_div;\n\n\tn_div = isl_aff_domain_dim(aff, isl_dim_div);\n\tif (n_div < 0)\n\t\tgoto error;\n\tif (n_div > 0)\n\t\teq = isl_basic_set_add_dims(eq, isl_dim_set, n_div);\n\treturn isl_aff_substitute_equalities_lifted(aff, eq);\nerror:\n\tisl_basic_set_free(eq);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Look for equalities among the variables shared by context and aff\n * and the integer divisions of aff, if any.\n * The equalities are then used to eliminate coefficients and/or integer\n * divisions from aff.\n */\n__isl_give isl_aff *isl_aff_gist(__isl_take isl_aff *aff,\n\t__isl_take isl_set *context)\n{\n\tisl_local_space *ls;\n\tisl_basic_set *hull;\n\n\tls = isl_aff_get_domain_local_space(aff);\n\tcontext = isl_local_space_lift_set(ls, context);\n\n\thull = isl_set_affine_hull(context);\n\treturn isl_aff_substitute_equalities_lifted(aff, hull);\n}\n\n__isl_give isl_aff *isl_aff_gist_params(__isl_take isl_aff *aff,\n\t__isl_take isl_set *context)\n{\n\tisl_set *dom_context = isl_set_universe(isl_aff_get_domain_space(aff));\n\tdom_context = isl_set_intersect_params(dom_context, context);\n\treturn isl_aff_gist(aff, dom_context);\n}\n\n/* Return a basic set containing those elements in the space\n * of aff where it is positive.  \"rational\" should not be set.\n *\n * If \"aff\" is NaN, then it is not positive.\n */\nstatic __isl_give isl_basic_set *aff_pos_basic_set(__isl_take isl_aff *aff,\n\tint rational, void *user)\n{\n\tisl_constraint *ineq;\n\tisl_basic_set *bset;\n\tisl_val *c;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff)) {\n\t\tisl_space *space = isl_aff_get_domain_space(aff);\n\t\tisl_aff_free(aff);\n\t\treturn isl_basic_set_empty(space);\n\t}\n\tif (rational)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_unsupported,\n\t\t\t\"rational sets not supported\", goto error);\n\n\tineq = isl_inequality_from_aff(aff);\n\tc = isl_constraint_get_constant_val(ineq);\n\tc = isl_val_sub_ui(c, 1);\n\tineq = isl_constraint_set_constant_val(ineq, c);\n\n\tbset = isl_basic_set_from_constraint(ineq);\n\tbset = isl_basic_set_simplify(bset);\n\treturn bset;\nerror:\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Return a basic set containing those elements in the space\n * of aff where it is non-negative.\n * If \"rational\" is set, then return a rational basic set.\n *\n * If \"aff\" is NaN, then it is not non-negative (it's not negative either).\n */\nstatic __isl_give isl_basic_set *aff_nonneg_basic_set(\n\t__isl_take isl_aff *aff, int rational, void *user)\n{\n\tisl_constraint *ineq;\n\tisl_basic_set *bset;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff)) {\n\t\tisl_space *space = isl_aff_get_domain_space(aff);\n\t\tisl_aff_free(aff);\n\t\treturn isl_basic_set_empty(space);\n\t}\n\n\tineq = isl_inequality_from_aff(aff);\n\n\tbset = isl_basic_set_from_constraint(ineq);\n\tif (rational)\n\t\tbset = isl_basic_set_set_rational(bset);\n\tbset = isl_basic_set_simplify(bset);\n\treturn bset;\n}\n\n/* Return a basic set containing those elements in the space\n * of aff where it is non-negative.\n */\n__isl_give isl_basic_set *isl_aff_nonneg_basic_set(__isl_take isl_aff *aff)\n{\n\treturn aff_nonneg_basic_set(aff, 0, NULL);\n}\n\n/* Return a basic set containing those elements in the domain space\n * of \"aff\" where it is positive.\n */\n__isl_give isl_basic_set *isl_aff_pos_basic_set(__isl_take isl_aff *aff)\n{\n\taff = isl_aff_add_constant_num_si(aff, -1);\n\treturn isl_aff_nonneg_basic_set(aff);\n}\n\n/* Return a basic set containing those elements in the domain space\n * of aff where it is negative.\n */\n__isl_give isl_basic_set *isl_aff_neg_basic_set(__isl_take isl_aff *aff)\n{\n\taff = isl_aff_neg(aff);\n\treturn isl_aff_pos_basic_set(aff);\n}\n\n/* Return a basic set containing those elements in the space\n * of aff where it is zero.\n * If \"rational\" is set, then return a rational basic set.\n *\n * If \"aff\" is NaN, then it is not zero.\n */\nstatic __isl_give isl_basic_set *aff_zero_basic_set(__isl_take isl_aff *aff,\n\tint rational, void *user)\n{\n\tisl_constraint *ineq;\n\tisl_basic_set *bset;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (isl_aff_is_nan(aff)) {\n\t\tisl_space *space = isl_aff_get_domain_space(aff);\n\t\tisl_aff_free(aff);\n\t\treturn isl_basic_set_empty(space);\n\t}\n\n\tineq = isl_equality_from_aff(aff);\n\n\tbset = isl_basic_set_from_constraint(ineq);\n\tif (rational)\n\t\tbset = isl_basic_set_set_rational(bset);\n\tbset = isl_basic_set_simplify(bset);\n\treturn bset;\n}\n\n/* Return a basic set containing those elements in the space\n * of aff where it is zero.\n */\n__isl_give isl_basic_set *isl_aff_zero_basic_set(__isl_take isl_aff *aff)\n{\n\treturn aff_zero_basic_set(aff, 0, NULL);\n}\n\n/* Return a basic set containing those elements in the shared space\n * of aff1 and aff2 where aff1 is greater than or equal to aff2.\n */\n__isl_give isl_basic_set *isl_aff_ge_basic_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\taff1 = isl_aff_sub(aff1, aff2);\n\n\treturn isl_aff_nonneg_basic_set(aff1);\n}\n\n/* Return a basic set containing those elements in the shared domain space\n * of \"aff1\" and \"aff2\" where \"aff1\" is greater than \"aff2\".\n */\n__isl_give isl_basic_set *isl_aff_gt_basic_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\taff1 = isl_aff_sub(aff1, aff2);\n\n\treturn isl_aff_pos_basic_set(aff1);\n}\n\n/* Return a set containing those elements in the shared space\n * of aff1 and aff2 where aff1 is greater than or equal to aff2.\n */\n__isl_give isl_set *isl_aff_ge_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\treturn isl_set_from_basic_set(isl_aff_ge_basic_set(aff1, aff2));\n}\n\n/* Return a set containing those elements in the shared domain space\n * of aff1 and aff2 where aff1 is greater than aff2.\n *\n * If either of the two inputs is NaN, then the result is empty,\n * as comparisons with NaN always return false.\n */\n__isl_give isl_set *isl_aff_gt_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\treturn isl_set_from_basic_set(isl_aff_gt_basic_set(aff1, aff2));\n}\n\n/* Return a basic set containing those elements in the shared space\n * of aff1 and aff2 where aff1 is smaller than or equal to aff2.\n */\n__isl_give isl_basic_set *isl_aff_le_basic_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\treturn isl_aff_ge_basic_set(aff2, aff1);\n}\n\n/* Return a basic set containing those elements in the shared domain space\n * of \"aff1\" and \"aff2\" where \"aff1\" is smaller than \"aff2\".\n */\n__isl_give isl_basic_set *isl_aff_lt_basic_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\treturn isl_aff_gt_basic_set(aff2, aff1);\n}\n\n/* Return a set containing those elements in the shared space\n * of aff1 and aff2 where aff1 is smaller than or equal to aff2.\n */\n__isl_give isl_set *isl_aff_le_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\treturn isl_aff_ge_set(aff2, aff1);\n}\n\n/* Return a set containing those elements in the shared domain space\n * of \"aff1\" and \"aff2\" where \"aff1\" is smaller than \"aff2\".\n */\n__isl_give isl_set *isl_aff_lt_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\treturn isl_set_from_basic_set(isl_aff_lt_basic_set(aff1, aff2));\n}\n\n/* Return a basic set containing those elements in the shared space\n * of aff1 and aff2 where aff1 and aff2 are equal.\n */\n__isl_give isl_basic_set *isl_aff_eq_basic_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\taff1 = isl_aff_sub(aff1, aff2);\n\n\treturn isl_aff_zero_basic_set(aff1);\n}\n\n/* Return a set containing those elements in the shared space\n * of aff1 and aff2 where aff1 and aff2 are equal.\n */\n__isl_give isl_set *isl_aff_eq_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\treturn isl_set_from_basic_set(isl_aff_eq_basic_set(aff1, aff2));\n}\n\n/* Return a set containing those elements in the shared domain space\n * of aff1 and aff2 where aff1 and aff2 are not equal.\n *\n * If either of the two inputs is NaN, then the result is empty,\n * as comparisons with NaN always return false.\n */\n__isl_give isl_set *isl_aff_ne_set(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\tisl_set *set_lt, *set_gt;\n\n\tset_lt = isl_aff_lt_set(isl_aff_copy(aff1),\n\t\t\t\tisl_aff_copy(aff2));\n\tset_gt = isl_aff_gt_set(aff1, aff2);\n\treturn isl_set_union_disjoint(set_lt, set_gt);\n}\n\n__isl_give isl_aff *isl_aff_add_on_domain(__isl_keep isl_set *dom,\n\t__isl_take isl_aff *aff1, __isl_take isl_aff *aff2)\n{\n\taff1 = isl_aff_add(aff1, aff2);\n\taff1 = isl_aff_gist(aff1, isl_set_copy(dom));\n\treturn aff1;\n}\n\nisl_bool isl_aff_is_empty(__isl_keep isl_aff *aff)\n{\n\tif (!aff)\n\t\treturn isl_bool_error;\n\n\treturn isl_bool_false;\n}\n\n#undef TYPE\n#define TYPE\tisl_aff\nstatic\n#include \"check_type_range_templ.c\"\n\n/* Check whether the given affine expression has non-zero coefficient\n * for any dimension in the given range or if any of these dimensions\n * appear with non-zero coefficients in any of the integer divisions\n * involved in the affine expression.\n */\nisl_bool isl_aff_involves_dims(__isl_keep isl_aff *aff,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\tint *active = NULL;\n\tisl_bool involves = isl_bool_false;\n\n\tif (!aff)\n\t\treturn isl_bool_error;\n\tif (n == 0)\n\t\treturn isl_bool_false;\n\tif (isl_aff_check_range(aff, type, first, n) < 0)\n\t\treturn isl_bool_error;\n\n\tactive = isl_local_space_get_active(aff->ls, aff->v->el + 2);\n\tif (!active)\n\t\tgoto error;\n\n\tfirst += isl_local_space_offset(aff->ls, type) - 1;\n\tfor (i = 0; i < n; ++i)\n\t\tif (active[first + i]) {\n\t\t\tinvolves = isl_bool_true;\n\t\t\tbreak;\n\t\t}\n\n\tfree(active);\n\n\treturn involves;\nerror:\n\tfree(active);\n\treturn isl_bool_error;\n}\n\n/* Does \"aff\" involve any local variables, i.e., integer divisions?\n */\nisl_bool isl_aff_involves_locals(__isl_keep isl_aff *aff)\n{\n\tisl_size n;\n\n\tn = isl_aff_dim(aff, isl_dim_div);\n\tif (n < 0)\n\t\treturn isl_bool_error;\n\treturn isl_bool_ok(n > 0);\n}\n\n__isl_give isl_aff *isl_aff_drop_dims(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tisl_ctx *ctx;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"cannot drop output/set dimension\",\n\t\t\treturn isl_aff_free(aff));\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\tif (n == 0 && !isl_local_space_is_named_or_nested(aff->ls, type))\n\t\treturn aff;\n\n\tctx = isl_aff_get_ctx(aff);\n\tif (isl_local_space_check_range(aff->ls, type, first, n) < 0)\n\t\treturn isl_aff_free(aff);\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->ls = isl_local_space_drop_dims(aff->ls, type, first, n);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\tfirst += 1 + isl_local_space_offset(aff->ls, type);\n\taff->v = isl_vec_drop_els(aff->v, first, n);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\n}\n\n/* Is the domain of \"aff\" a product?\n */\nstatic isl_bool isl_aff_domain_is_product(__isl_keep isl_aff *aff)\n{\n\treturn isl_space_is_product(isl_aff_peek_domain_space(aff));\n}\n\n#undef TYPE\n#define TYPE\tisl_aff\n#include <isl_domain_factor_templ.c>\n\n/* Project the domain of the affine expression onto its parameter space.\n * The affine expression may not involve any of the domain dimensions.\n */\n__isl_give isl_aff *isl_aff_project_domain_on_params(__isl_take isl_aff *aff)\n{\n\tisl_space *space;\n\tisl_size n;\n\n\tn = isl_aff_dim(aff, isl_dim_in);\n\tif (n < 0)\n\t\treturn isl_aff_free(aff);\n\taff = isl_aff_drop_domain(aff, 0, n);\n\tspace = isl_aff_get_domain_space(aff);\n\tspace = isl_space_params(space);\n\taff = isl_aff_reset_domain_space(aff, space);\n\treturn aff;\n}\n\n/* Convert an affine expression defined over a parameter domain\n * into one that is defined over a zero-dimensional set.\n */\n__isl_give isl_aff *isl_aff_from_range(__isl_take isl_aff *aff)\n{\n\tisl_local_space *ls;\n\n\tls = isl_aff_take_domain_local_space(aff);\n\tls = isl_local_space_set_from_params(ls);\n\taff = isl_aff_restore_domain_local_space(aff, ls);\n\n\treturn aff;\n}\n\n__isl_give isl_aff *isl_aff_insert_dims(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tisl_ctx *ctx;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (type == isl_dim_out)\n\t\tisl_die(aff->v->ctx, isl_error_invalid,\n\t\t\t\"cannot insert output/set dimensions\",\n\t\t\treturn isl_aff_free(aff));\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\tif (n == 0 && !isl_local_space_is_named_or_nested(aff->ls, type))\n\t\treturn aff;\n\n\tctx = isl_aff_get_ctx(aff);\n\tif (isl_local_space_check_range(aff->ls, type, first, 0) < 0)\n\t\treturn isl_aff_free(aff);\n\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->ls = isl_local_space_insert_dims(aff->ls, type, first, n);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\tfirst += 1 + isl_local_space_offset(aff->ls, type);\n\taff->v = isl_vec_insert_zero_els(aff->v, first, n);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\n}\n\n__isl_give isl_aff *isl_aff_add_dims(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, unsigned n)\n{\n\tisl_size pos;\n\n\tpos = isl_aff_dim(aff, type);\n\tif (pos < 0)\n\t\treturn isl_aff_free(aff);\n\n\treturn isl_aff_insert_dims(aff, type, pos, n);\n}\n\n/* Move the \"n\" dimensions of \"src_type\" starting at \"src_pos\" of \"aff\"\n * to dimensions of \"dst_type\" at \"dst_pos\".\n *\n * We only support moving input dimensions to parameters and vice versa.\n */\n__isl_give isl_aff *isl_aff_move_dims(__isl_take isl_aff *aff,\n\tenum isl_dim_type dst_type, unsigned dst_pos,\n\tenum isl_dim_type src_type, unsigned src_pos, unsigned n)\n{\n\tunsigned g_dst_pos;\n\tunsigned g_src_pos;\n\tisl_size src_off, dst_off;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (n == 0 &&\n\t    !isl_local_space_is_named_or_nested(aff->ls, src_type) &&\n\t    !isl_local_space_is_named_or_nested(aff->ls, dst_type))\n\t\treturn aff;\n\n\tif (dst_type == isl_dim_out || src_type == isl_dim_out)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"cannot move output/set dimension\",\n\t\t\treturn isl_aff_free(aff));\n\tif (dst_type == isl_dim_div || src_type == isl_dim_div)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"cannot move divs\", return isl_aff_free(aff));\n\tif (dst_type == isl_dim_in)\n\t\tdst_type = isl_dim_set;\n\tif (src_type == isl_dim_in)\n\t\tsrc_type = isl_dim_set;\n\n\tif (isl_local_space_check_range(aff->ls, src_type, src_pos, n) < 0)\n\t\treturn isl_aff_free(aff);\n\tif (dst_type == src_type)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_unsupported,\n\t\t\t\"moving dims within the same type not supported\",\n\t\t\treturn isl_aff_free(aff));\n\n\taff = isl_aff_cow(aff);\n\tsrc_off = isl_aff_domain_offset(aff, src_type);\n\tdst_off = isl_aff_domain_offset(aff, dst_type);\n\tif (src_off < 0 || dst_off < 0)\n\t\treturn isl_aff_free(aff);\n\n\tg_src_pos = 1 + src_off + src_pos;\n\tg_dst_pos = 1 + dst_off + dst_pos;\n\tif (dst_type > src_type)\n\t\tg_dst_pos -= n;\n\n\taff->v = isl_vec_move_els(aff->v, g_dst_pos, g_src_pos, n);\n\taff->ls = isl_local_space_move_dims(aff->ls, dst_type, dst_pos,\n\t\t\t\t\t\tsrc_type, src_pos, n);\n\tif (!aff->v || !aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\taff = sort_divs(aff);\n\n\treturn aff;\n}\n\n/* Return a zero isl_aff in the given space.\n *\n * This is a helper function for isl_pw_*_as_* that ensures a uniform\n * interface over all piecewise types.\n */\nstatic __isl_give isl_aff *isl_aff_zero_in_space(__isl_take isl_space *space)\n{\n\tisl_local_space *ls;\n\n\tls = isl_local_space_from_space(isl_space_domain(space));\n\treturn isl_aff_zero_on_domain(ls);\n}\n\n#define isl_aff_involves_nan isl_aff_is_nan\n\n#undef PW\n#define PW isl_pw_aff\n#undef BASE\n#define BASE aff\n#undef EL_IS_ZERO\n#define EL_IS_ZERO is_empty\n#undef ZERO\n#define ZERO empty\n#undef IS_ZERO\n#define IS_ZERO is_empty\n#undef FIELD\n#define FIELD aff\n#undef DEFAULT_IS_ZERO\n#define DEFAULT_IS_ZERO 0\n\n#include <isl_pw_templ.c>\n#include <isl_pw_add_constant_val_templ.c>\n#include <isl_pw_bind_domain_templ.c>\n#include <isl_pw_eval.c>\n#include <isl_pw_hash.c>\n#include <isl_pw_insert_dims_templ.c>\n#include <isl_pw_insert_domain_templ.c>\n#include <isl_pw_move_dims_templ.c>\n#include <isl_pw_neg_templ.c>\n#include <isl_pw_pullback_templ.c>\n#include <isl_pw_sub_templ.c>\n#include <isl_pw_union_opt.c>\n\n#undef BASE\n#define BASE pw_aff\n\n#include <isl_union_single.c>\n#include <isl_union_neg.c>\n\n#undef BASE\n#define BASE aff\n\n#include <isl_union_pw_templ.c>\n\n/* Compute a piecewise quasi-affine expression with a domain that\n * is the union of those of pwaff1 and pwaff2 and such that on each\n * cell, the quasi-affine expression is the maximum of those of pwaff1\n * and pwaff2.  If only one of pwaff1 or pwaff2 is defined on a given\n * cell, then the associated expression is the defined one.\n */\n__isl_give isl_pw_aff *isl_pw_aff_union_max(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_pw_aff_align_params_bin(&pwaff1, &pwaff2);\n\treturn isl_pw_aff_union_opt_cmp(pwaff1, pwaff2, &isl_aff_ge_set);\n}\n\n/* Compute a piecewise quasi-affine expression with a domain that\n * is the union of those of pwaff1 and pwaff2 and such that on each\n * cell, the quasi-affine expression is the minimum of those of pwaff1\n * and pwaff2.  If only one of pwaff1 or pwaff2 is defined on a given\n * cell, then the associated expression is the defined one.\n */\n__isl_give isl_pw_aff *isl_pw_aff_union_min(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_pw_aff_align_params_bin(&pwaff1, &pwaff2);\n\treturn isl_pw_aff_union_opt_cmp(pwaff1, pwaff2, &isl_aff_le_set);\n}\n\n__isl_give isl_pw_aff *isl_pw_aff_union_opt(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2, int max)\n{\n\tif (max)\n\t\treturn isl_pw_aff_union_max(pwaff1, pwaff2);\n\telse\n\t\treturn isl_pw_aff_union_min(pwaff1, pwaff2);\n}\n\n/* Is the domain of \"pa\" a product?\n */\nstatic isl_bool isl_pw_aff_domain_is_product(__isl_keep isl_pw_aff *pa)\n{\n\treturn isl_space_domain_is_wrapping(isl_pw_aff_peek_space(pa));\n}\n\n#undef TYPE\n#define TYPE\tisl_pw_aff\n#include <isl_domain_factor_templ.c>\n\n/* Return a set containing those elements in the domain\n * of \"pwaff\" where it satisfies \"fn\" (if complement is 0) or\n * does not satisfy \"fn\" (if complement is 1).\n *\n * The pieces with a NaN never belong to the result since\n * NaN does not satisfy any property.\n */\nstatic __isl_give isl_set *pw_aff_locus(__isl_take isl_pw_aff *pwaff,\n\t__isl_give isl_basic_set *(*fn)(__isl_take isl_aff *aff, int rational,\n\t\tvoid *user),\n\tint complement, void *user)\n{\n\tint i;\n\tisl_set *set;\n\n\tif (!pwaff)\n\t\treturn NULL;\n\n\tset = isl_set_empty(isl_pw_aff_get_domain_space(pwaff));\n\n\tfor (i = 0; i < pwaff->n; ++i) {\n\t\tisl_basic_set *bset;\n\t\tisl_set *set_i, *locus;\n\t\tisl_bool rational;\n\n\t\tif (isl_aff_is_nan(pwaff->p[i].aff))\n\t\t\tcontinue;\n\n\t\trational = isl_set_has_rational(pwaff->p[i].set);\n\t\tbset = fn(isl_aff_copy(pwaff->p[i].aff), rational, user);\n\t\tlocus = isl_set_from_basic_set(bset);\n\t\tset_i = isl_set_copy(pwaff->p[i].set);\n\t\tif (complement)\n\t\t\tset_i = isl_set_subtract(set_i, locus);\n\t\telse\n\t\t\tset_i = isl_set_intersect(set_i, locus);\n\t\tset = isl_set_union_disjoint(set, set_i);\n\t}\n\n\tisl_pw_aff_free(pwaff);\n\n\treturn set;\n}\n\n/* Return a set containing those elements in the domain\n * of \"pa\" where it is positive.\n */\n__isl_give isl_set *isl_pw_aff_pos_set(__isl_take isl_pw_aff *pa)\n{\n\treturn pw_aff_locus(pa, &aff_pos_basic_set, 0, NULL);\n}\n\n/* Return a set containing those elements in the domain\n * of pwaff where it is non-negative.\n */\n__isl_give isl_set *isl_pw_aff_nonneg_set(__isl_take isl_pw_aff *pwaff)\n{\n\treturn pw_aff_locus(pwaff, &aff_nonneg_basic_set, 0, NULL);\n}\n\n/* Return a set containing those elements in the domain\n * of pwaff where it is zero.\n */\n__isl_give isl_set *isl_pw_aff_zero_set(__isl_take isl_pw_aff *pwaff)\n{\n\treturn pw_aff_locus(pwaff, &aff_zero_basic_set, 0, NULL);\n}\n\n/* Return a set containing those elements in the domain\n * of pwaff where it is not zero.\n */\n__isl_give isl_set *isl_pw_aff_non_zero_set(__isl_take isl_pw_aff *pwaff)\n{\n\treturn pw_aff_locus(pwaff, &aff_zero_basic_set, 1, NULL);\n}\n\n/* Bind the affine function \"aff\" to the parameter \"id\",\n * returning the elements in the domain where the affine expression\n * is equal to the parameter.\n */\n__isl_give isl_basic_set *isl_aff_bind_id(__isl_take isl_aff *aff,\n\t__isl_take isl_id *id)\n{\n\tisl_space *space;\n\tisl_aff *aff_id;\n\n\tspace = isl_aff_get_domain_space(aff);\n\tspace = isl_space_add_param_id(space, isl_id_copy(id));\n\n\taff = isl_aff_align_params(aff, isl_space_copy(space));\n\taff_id = isl_aff_param_on_domain_space_id(space, id);\n\n\treturn isl_aff_eq_basic_set(aff, aff_id);\n}\n\n/* Wrapper around isl_aff_bind_id for use as pw_aff_locus callback.\n * \"rational\" should not be set.\n */\nstatic __isl_give isl_basic_set *aff_bind_id(__isl_take isl_aff *aff,\n\tint rational, void *user)\n{\n\tisl_id *id = user;\n\n\tif (!aff)\n\t\treturn NULL;\n\tif (rational)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_unsupported,\n\t\t\t\"rational binding not supported\", goto error);\n\treturn isl_aff_bind_id(aff, isl_id_copy(id));\nerror:\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Bind the piecewise affine function \"pa\" to the parameter \"id\",\n * returning the elements in the domain where the expression\n * is equal to the parameter.\n */\n__isl_give isl_set *isl_pw_aff_bind_id(__isl_take isl_pw_aff *pa,\n\t__isl_take isl_id *id)\n{\n\tisl_set *bound;\n\n\tbound = pw_aff_locus(pa, &aff_bind_id, 0, id);\n\tisl_id_free(id);\n\n\treturn bound;\n}\n\n/* Return a set containing those elements in the shared domain\n * of pwaff1 and pwaff2 where pwaff1 is greater than (or equal) to pwaff2.\n *\n * We compute the difference on the shared domain and then construct\n * the set of values where this difference is non-negative.\n * If strict is set, we first subtract 1 from the difference.\n * If equal is set, we only return the elements where pwaff1 and pwaff2\n * are equal.\n */\nstatic __isl_give isl_set *pw_aff_gte_set(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2, int strict, int equal)\n{\n\tisl_set *set1, *set2;\n\n\tset1 = isl_pw_aff_domain(isl_pw_aff_copy(pwaff1));\n\tset2 = isl_pw_aff_domain(isl_pw_aff_copy(pwaff2));\n\tset1 = isl_set_intersect(set1, set2);\n\tpwaff1 = isl_pw_aff_intersect_domain(pwaff1, isl_set_copy(set1));\n\tpwaff2 = isl_pw_aff_intersect_domain(pwaff2, isl_set_copy(set1));\n\tpwaff1 = isl_pw_aff_add(pwaff1, isl_pw_aff_neg(pwaff2));\n\n\tif (strict) {\n\t\tisl_space *space = isl_set_get_space(set1);\n\t\tisl_aff *aff;\n\t\taff = isl_aff_zero_on_domain(isl_local_space_from_space(space));\n\t\taff = isl_aff_add_constant_si(aff, -1);\n\t\tpwaff1 = isl_pw_aff_add(pwaff1, isl_pw_aff_alloc(set1, aff));\n\t} else\n\t\tisl_set_free(set1);\n\n\tif (equal)\n\t\treturn isl_pw_aff_zero_set(pwaff1);\n\treturn isl_pw_aff_nonneg_set(pwaff1);\n}\n\n/* Return a set containing those elements in the shared domain\n * of pwaff1 and pwaff2 where pwaff1 is equal to pwaff2.\n */\n__isl_give isl_set *isl_pw_aff_eq_set(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_pw_aff_align_params_bin(&pwaff1, &pwaff2);\n\treturn pw_aff_gte_set(pwaff1, pwaff2, 0, 1);\n}\n\n/* Return a set containing those elements in the shared domain\n * of pwaff1 and pwaff2 where pwaff1 is greater than or equal to pwaff2.\n */\n__isl_give isl_set *isl_pw_aff_ge_set(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_pw_aff_align_params_bin(&pwaff1, &pwaff2);\n\treturn pw_aff_gte_set(pwaff1, pwaff2, 0, 0);\n}\n\n/* Return a set containing those elements in the shared domain\n * of pwaff1 and pwaff2 where pwaff1 is strictly greater than pwaff2.\n */\n__isl_give isl_set *isl_pw_aff_gt_set(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_pw_aff_align_params_bin(&pwaff1, &pwaff2);\n\treturn pw_aff_gte_set(pwaff1, pwaff2, 1, 0);\n}\n\n__isl_give isl_set *isl_pw_aff_le_set(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\treturn isl_pw_aff_ge_set(pwaff2, pwaff1);\n}\n\n__isl_give isl_set *isl_pw_aff_lt_set(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\treturn isl_pw_aff_gt_set(pwaff2, pwaff1);\n}\n\n/* Return a map containing pairs of elements in the domains of \"pa1\" and \"pa2\"\n * where the function values are ordered in the same way as \"order\",\n * which returns a set in the shared domain of its two arguments.\n *\n * Let \"pa1\" and \"pa2\" be defined on domains A and B respectively.\n * We first pull back the two functions such that they are defined on\n * the domain [A -> B].  Then we apply \"order\", resulting in a set\n * in the space [A -> B].  Finally, we unwrap this set to obtain\n * a map in the space A -> B.\n */\nstatic __isl_give isl_map *isl_pw_aff_order_map(\n\t__isl_take isl_pw_aff *pa1, __isl_take isl_pw_aff *pa2,\n\t__isl_give isl_set *(*order)(__isl_take isl_pw_aff *pa1,\n\t\t__isl_take isl_pw_aff *pa2))\n{\n\tisl_space *space1, *space2;\n\tisl_multi_aff *ma;\n\tisl_set *set;\n\n\tisl_pw_aff_align_params_bin(&pa1, &pa2);\n\tspace1 = isl_space_domain(isl_pw_aff_get_space(pa1));\n\tspace2 = isl_space_domain(isl_pw_aff_get_space(pa2));\n\tspace1 = isl_space_map_from_domain_and_range(space1, space2);\n\tma = isl_multi_aff_domain_map(isl_space_copy(space1));\n\tpa1 = isl_pw_aff_pullback_multi_aff(pa1, ma);\n\tma = isl_multi_aff_range_map(space1);\n\tpa2 = isl_pw_aff_pullback_multi_aff(pa2, ma);\n\tset = order(pa1, pa2);\n\n\treturn isl_set_unwrap(set);\n}\n\n/* Return a map containing pairs of elements in the domains of \"pa1\" and \"pa2\"\n * where the function values are equal.\n */\n__isl_give isl_map *isl_pw_aff_eq_map(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\treturn isl_pw_aff_order_map(pa1, pa2, &isl_pw_aff_eq_set);\n}\n\n/* Return a map containing pairs of elements in the domains of \"pa1\" and \"pa2\"\n * where the function value of \"pa1\" is less than or equal to\n * the function value of \"pa2\".\n */\n__isl_give isl_map *isl_pw_aff_le_map(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\treturn isl_pw_aff_order_map(pa1, pa2, &isl_pw_aff_le_set);\n}\n\n/* Return a map containing pairs of elements in the domains of \"pa1\" and \"pa2\"\n * where the function value of \"pa1\" is less than the function value of \"pa2\".\n */\n__isl_give isl_map *isl_pw_aff_lt_map(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\treturn isl_pw_aff_order_map(pa1, pa2, &isl_pw_aff_lt_set);\n}\n\n/* Return a map containing pairs of elements in the domains of \"pa1\" and \"pa2\"\n * where the function value of \"pa1\" is greater than or equal to\n * the function value of \"pa2\".\n */\n__isl_give isl_map *isl_pw_aff_ge_map(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\treturn isl_pw_aff_order_map(pa1, pa2, &isl_pw_aff_ge_set);\n}\n\n/* Return a map containing pairs of elements in the domains of \"pa1\" and \"pa2\"\n * where the function value of \"pa1\" is greater than the function value\n * of \"pa2\".\n */\n__isl_give isl_map *isl_pw_aff_gt_map(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\treturn isl_pw_aff_order_map(pa1, pa2, &isl_pw_aff_gt_set);\n}\n\n/* Return a set containing those elements in the shared domain\n * of the elements of list1 and list2 where each element in list1\n * has the relation specified by \"fn\" with each element in list2.\n */\nstatic __isl_give isl_set *pw_aff_list_set(__isl_take isl_pw_aff_list *list1,\n\t__isl_take isl_pw_aff_list *list2,\n\t__isl_give isl_set *(*fn)(__isl_take isl_pw_aff *pwaff1,\n\t\t\t\t    __isl_take isl_pw_aff *pwaff2))\n{\n\tint i, j;\n\tisl_ctx *ctx;\n\tisl_set *set;\n\n\tif (!list1 || !list2)\n\t\tgoto error;\n\n\tctx = isl_pw_aff_list_get_ctx(list1);\n\tif (list1->n < 1 || list2->n < 1)\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"list should contain at least one element\", goto error);\n\n\tset = isl_set_universe(isl_pw_aff_get_domain_space(list1->p[0]));\n\tfor (i = 0; i < list1->n; ++i)\n\t\tfor (j = 0; j < list2->n; ++j) {\n\t\t\tisl_set *set_ij;\n\n\t\t\tset_ij = fn(isl_pw_aff_copy(list1->p[i]),\n\t\t\t\t    isl_pw_aff_copy(list2->p[j]));\n\t\t\tset = isl_set_intersect(set, set_ij);\n\t\t}\n\n\tisl_pw_aff_list_free(list1);\n\tisl_pw_aff_list_free(list2);\n\treturn set;\nerror:\n\tisl_pw_aff_list_free(list1);\n\tisl_pw_aff_list_free(list2);\n\treturn NULL;\n}\n\n/* Return a set containing those elements in the shared domain\n * of the elements of list1 and list2 where each element in list1\n * is equal to each element in list2.\n */\n__isl_give isl_set *isl_pw_aff_list_eq_set(__isl_take isl_pw_aff_list *list1,\n\t__isl_take isl_pw_aff_list *list2)\n{\n\treturn pw_aff_list_set(list1, list2, &isl_pw_aff_eq_set);\n}\n\n__isl_give isl_set *isl_pw_aff_list_ne_set(__isl_take isl_pw_aff_list *list1,\n\t__isl_take isl_pw_aff_list *list2)\n{\n\treturn pw_aff_list_set(list1, list2, &isl_pw_aff_ne_set);\n}\n\n/* Return a set containing those elements in the shared domain\n * of the elements of list1 and list2 where each element in list1\n * is less than or equal to each element in list2.\n */\n__isl_give isl_set *isl_pw_aff_list_le_set(__isl_take isl_pw_aff_list *list1,\n\t__isl_take isl_pw_aff_list *list2)\n{\n\treturn pw_aff_list_set(list1, list2, &isl_pw_aff_le_set);\n}\n\n__isl_give isl_set *isl_pw_aff_list_lt_set(__isl_take isl_pw_aff_list *list1,\n\t__isl_take isl_pw_aff_list *list2)\n{\n\treturn pw_aff_list_set(list1, list2, &isl_pw_aff_lt_set);\n}\n\n__isl_give isl_set *isl_pw_aff_list_ge_set(__isl_take isl_pw_aff_list *list1,\n\t__isl_take isl_pw_aff_list *list2)\n{\n\treturn pw_aff_list_set(list1, list2, &isl_pw_aff_ge_set);\n}\n\n__isl_give isl_set *isl_pw_aff_list_gt_set(__isl_take isl_pw_aff_list *list1,\n\t__isl_take isl_pw_aff_list *list2)\n{\n\treturn pw_aff_list_set(list1, list2, &isl_pw_aff_gt_set);\n}\n\n\n/* Return a set containing those elements in the shared domain\n * of pwaff1 and pwaff2 where pwaff1 is not equal to pwaff2.\n */\n__isl_give isl_set *isl_pw_aff_ne_set(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_set *set_lt, *set_gt;\n\n\tisl_pw_aff_align_params_bin(&pwaff1, &pwaff2);\n\tset_lt = isl_pw_aff_lt_set(isl_pw_aff_copy(pwaff1),\n\t\t\t\t   isl_pw_aff_copy(pwaff2));\n\tset_gt = isl_pw_aff_gt_set(pwaff1, pwaff2);\n\treturn isl_set_union_disjoint(set_lt, set_gt);\n}\n\n__isl_give isl_pw_aff *isl_pw_aff_scale_down(__isl_take isl_pw_aff *pwaff,\n\tisl_int v)\n{\n\tint i;\n\n\tif (isl_int_is_one(v))\n\t\treturn pwaff;\n\tif (!isl_int_is_pos(v))\n\t\tisl_die(isl_pw_aff_get_ctx(pwaff), isl_error_invalid,\n\t\t\t\"factor needs to be positive\",\n\t\t\treturn isl_pw_aff_free(pwaff));\n\tpwaff = isl_pw_aff_cow(pwaff);\n\tif (!pwaff)\n\t\treturn NULL;\n\tif (pwaff->n == 0)\n\t\treturn pwaff;\n\n\tfor (i = 0; i < pwaff->n; ++i) {\n\t\tpwaff->p[i].aff = isl_aff_scale_down(pwaff->p[i].aff, v);\n\t\tif (!pwaff->p[i].aff)\n\t\t\treturn isl_pw_aff_free(pwaff);\n\t}\n\n\treturn pwaff;\n}\n\n__isl_give isl_pw_aff *isl_pw_aff_floor(__isl_take isl_pw_aff *pwaff)\n{\n\tint i;\n\n\tpwaff = isl_pw_aff_cow(pwaff);\n\tif (!pwaff)\n\t\treturn NULL;\n\tif (pwaff->n == 0)\n\t\treturn pwaff;\n\n\tfor (i = 0; i < pwaff->n; ++i) {\n\t\tpwaff->p[i].aff = isl_aff_floor(pwaff->p[i].aff);\n\t\tif (!pwaff->p[i].aff)\n\t\t\treturn isl_pw_aff_free(pwaff);\n\t}\n\n\treturn pwaff;\n}\n\n__isl_give isl_pw_aff *isl_pw_aff_ceil(__isl_take isl_pw_aff *pwaff)\n{\n\tint i;\n\n\tpwaff = isl_pw_aff_cow(pwaff);\n\tif (!pwaff)\n\t\treturn NULL;\n\tif (pwaff->n == 0)\n\t\treturn pwaff;\n\n\tfor (i = 0; i < pwaff->n; ++i) {\n\t\tpwaff->p[i].aff = isl_aff_ceil(pwaff->p[i].aff);\n\t\tif (!pwaff->p[i].aff)\n\t\t\treturn isl_pw_aff_free(pwaff);\n\t}\n\n\treturn pwaff;\n}\n\n/* Assuming that \"cond1\" and \"cond2\" are disjoint,\n * return an affine expression that is equal to pwaff1 on cond1\n * and to pwaff2 on cond2.\n */\nstatic __isl_give isl_pw_aff *isl_pw_aff_select(\n\t__isl_take isl_set *cond1, __isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_set *cond2, __isl_take isl_pw_aff *pwaff2)\n{\n\tpwaff1 = isl_pw_aff_intersect_domain(pwaff1, cond1);\n\tpwaff2 = isl_pw_aff_intersect_domain(pwaff2, cond2);\n\n\treturn isl_pw_aff_add_disjoint(pwaff1, pwaff2);\n}\n\n/* Return an affine expression that is equal to pwaff_true for elements\n * where \"cond\" is non-zero and to pwaff_false for elements where \"cond\"\n * is zero.\n * That is, return cond ? pwaff_true : pwaff_false;\n *\n * If \"cond\" involves and NaN, then we conservatively return a NaN\n * on its entire domain.  In principle, we could consider the pieces\n * where it is NaN separately from those where it is not.\n *\n * If \"pwaff_true\" and \"pwaff_false\" are obviously equal to each other,\n * then only use the domain of \"cond\" to restrict the domain.\n */\n__isl_give isl_pw_aff *isl_pw_aff_cond(__isl_take isl_pw_aff *cond,\n\t__isl_take isl_pw_aff *pwaff_true, __isl_take isl_pw_aff *pwaff_false)\n{\n\tisl_set *cond_true, *cond_false;\n\tisl_bool equal;\n\n\tif (!cond)\n\t\tgoto error;\n\tif (isl_pw_aff_involves_nan(cond)) {\n\t\tisl_space *space = isl_pw_aff_get_domain_space(cond);\n\t\tisl_local_space *ls = isl_local_space_from_space(space);\n\t\tisl_pw_aff_free(cond);\n\t\tisl_pw_aff_free(pwaff_true);\n\t\tisl_pw_aff_free(pwaff_false);\n\t\treturn isl_pw_aff_nan_on_domain(ls);\n\t}\n\n\tpwaff_true = isl_pw_aff_align_params(pwaff_true,\n\t\t\t\t\t    isl_pw_aff_get_space(pwaff_false));\n\tpwaff_false = isl_pw_aff_align_params(pwaff_false,\n\t\t\t\t\t    isl_pw_aff_get_space(pwaff_true));\n\tequal = isl_pw_aff_plain_is_equal(pwaff_true, pwaff_false);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (equal) {\n\t\tisl_set *dom;\n\n\t\tdom = isl_set_coalesce(isl_pw_aff_domain(cond));\n\t\tisl_pw_aff_free(pwaff_false);\n\t\treturn isl_pw_aff_intersect_domain(pwaff_true, dom);\n\t}\n\n\tcond_true = isl_pw_aff_non_zero_set(isl_pw_aff_copy(cond));\n\tcond_false = isl_pw_aff_zero_set(cond);\n\treturn isl_pw_aff_select(cond_true, pwaff_true,\n\t\t\t\t cond_false, pwaff_false);\nerror:\n\tisl_pw_aff_free(cond);\n\tisl_pw_aff_free(pwaff_true);\n\tisl_pw_aff_free(pwaff_false);\n\treturn NULL;\n}\n\nisl_bool isl_aff_is_cst(__isl_keep isl_aff *aff)\n{\n\tint pos;\n\n\tif (!aff)\n\t\treturn isl_bool_error;\n\n\tpos = isl_seq_first_non_zero(aff->v->el + 2, aff->v->size - 2);\n\treturn isl_bool_ok(pos == -1);\n}\n\n/* Check whether pwaff is a piecewise constant.\n */\nisl_bool isl_pw_aff_is_cst(__isl_keep isl_pw_aff *pwaff)\n{\n\tint i;\n\n\tif (!pwaff)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < pwaff->n; ++i) {\n\t\tisl_bool is_cst = isl_aff_is_cst(pwaff->p[i].aff);\n\t\tif (is_cst < 0 || !is_cst)\n\t\t\treturn is_cst;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Return the product of \"aff1\" and \"aff2\".\n *\n * If either of the two is NaN, then the result is NaN.\n *\n * Otherwise, at least one of \"aff1\" or \"aff2\" needs to be a constant.\n */\n__isl_give isl_aff *isl_aff_mul(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\tif (!aff1 || !aff2)\n\t\tgoto error;\n\n\tif (isl_aff_is_nan(aff1)) {\n\t\tisl_aff_free(aff2);\n\t\treturn aff1;\n\t}\n\tif (isl_aff_is_nan(aff2)) {\n\t\tisl_aff_free(aff1);\n\t\treturn aff2;\n\t}\n\n\tif (!isl_aff_is_cst(aff2) && isl_aff_is_cst(aff1))\n\t\treturn isl_aff_mul(aff2, aff1);\n\n\tif (!isl_aff_is_cst(aff2))\n\t\tisl_die(isl_aff_get_ctx(aff1), isl_error_invalid,\n\t\t\t\"at least one affine expression should be constant\",\n\t\t\tgoto error);\n\n\taff1 = isl_aff_cow(aff1);\n\tif (!aff1 || !aff2)\n\t\tgoto error;\n\n\taff1 = isl_aff_scale(aff1, aff2->v->el[1]);\n\taff1 = isl_aff_scale_down(aff1, aff2->v->el[0]);\n\n\tisl_aff_free(aff2);\n\treturn aff1;\nerror:\n\tisl_aff_free(aff1);\n\tisl_aff_free(aff2);\n\treturn NULL;\n}\n\n/* Divide \"aff1\" by \"aff2\", assuming \"aff2\" is a constant.\n *\n * If either of the two is NaN, then the result is NaN.\n * A division by zero also results in NaN.\n */\n__isl_give isl_aff *isl_aff_div(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\tisl_bool is_cst, is_zero;\n\tint neg;\n\n\tif (!aff1 || !aff2)\n\t\tgoto error;\n\n\tif (isl_aff_is_nan(aff1)) {\n\t\tisl_aff_free(aff2);\n\t\treturn aff1;\n\t}\n\tif (isl_aff_is_nan(aff2)) {\n\t\tisl_aff_free(aff1);\n\t\treturn aff2;\n\t}\n\n\tis_cst = isl_aff_is_cst(aff2);\n\tif (is_cst < 0)\n\t\tgoto error;\n\tif (!is_cst)\n\t\tisl_die(isl_aff_get_ctx(aff2), isl_error_invalid,\n\t\t\t\"second argument should be a constant\", goto error);\n\tis_zero = isl_aff_plain_is_zero(aff2);\n\tif (is_zero < 0)\n\t\tgoto error;\n\tif (is_zero)\n\t\treturn set_nan_free(aff1, aff2);\n\n\tneg = isl_int_is_neg(aff2->v->el[1]);\n\tif (neg) {\n\t\tisl_int_neg(aff2->v->el[0], aff2->v->el[0]);\n\t\tisl_int_neg(aff2->v->el[1], aff2->v->el[1]);\n\t}\n\n\taff1 = isl_aff_scale(aff1, aff2->v->el[0]);\n\taff1 = isl_aff_scale_down(aff1, aff2->v->el[1]);\n\n\tif (neg) {\n\t\tisl_int_neg(aff2->v->el[0], aff2->v->el[0]);\n\t\tisl_int_neg(aff2->v->el[1], aff2->v->el[1]);\n\t}\n\n\tisl_aff_free(aff2);\n\treturn aff1;\nerror:\n\tisl_aff_free(aff1);\n\tisl_aff_free(aff2);\n\treturn NULL;\n}\n\n__isl_give isl_pw_aff *isl_pw_aff_add(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_pw_aff_align_params_bin(&pwaff1, &pwaff2);\n\treturn isl_pw_aff_on_shared_domain(pwaff1, pwaff2, &isl_aff_add);\n}\n\n__isl_give isl_pw_aff *isl_pw_aff_union_add(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\treturn isl_pw_aff_union_add_(pwaff1, pwaff2);\n}\n\n__isl_give isl_pw_aff *isl_pw_aff_mul(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_pw_aff_align_params_bin(&pwaff1, &pwaff2);\n\treturn isl_pw_aff_on_shared_domain(pwaff1, pwaff2, &isl_aff_mul);\n}\n\n/* Divide \"pa1\" by \"pa2\", assuming \"pa2\" is a piecewise constant.\n */\n__isl_give isl_pw_aff *isl_pw_aff_div(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\tint is_cst;\n\n\tis_cst = isl_pw_aff_is_cst(pa2);\n\tif (is_cst < 0)\n\t\tgoto error;\n\tif (!is_cst)\n\t\tisl_die(isl_pw_aff_get_ctx(pa2), isl_error_invalid,\n\t\t\t\"second argument should be a piecewise constant\",\n\t\t\tgoto error);\n\tisl_pw_aff_align_params_bin(&pa1, &pa2);\n\treturn isl_pw_aff_on_shared_domain(pa1, pa2, &isl_aff_div);\nerror:\n\tisl_pw_aff_free(pa1);\n\tisl_pw_aff_free(pa2);\n\treturn NULL;\n}\n\n/* Compute the quotient of the integer division of \"pa1\" by \"pa2\"\n * with rounding towards zero.\n * \"pa2\" is assumed to be a piecewise constant.\n *\n * In particular, return\n *\n *\tpa1 >= 0 ? floor(pa1/pa2) : ceil(pa1/pa2)\n *\n */\n__isl_give isl_pw_aff *isl_pw_aff_tdiv_q(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\tint is_cst;\n\tisl_set *cond;\n\tisl_pw_aff *f, *c;\n\n\tis_cst = isl_pw_aff_is_cst(pa2);\n\tif (is_cst < 0)\n\t\tgoto error;\n\tif (!is_cst)\n\t\tisl_die(isl_pw_aff_get_ctx(pa2), isl_error_invalid,\n\t\t\t\"second argument should be a piecewise constant\",\n\t\t\tgoto error);\n\n\tpa1 = isl_pw_aff_div(pa1, pa2);\n\n\tcond = isl_pw_aff_nonneg_set(isl_pw_aff_copy(pa1));\n\tf = isl_pw_aff_floor(isl_pw_aff_copy(pa1));\n\tc = isl_pw_aff_ceil(pa1);\n\treturn isl_pw_aff_cond(isl_set_indicator_function(cond), f, c);\nerror:\n\tisl_pw_aff_free(pa1);\n\tisl_pw_aff_free(pa2);\n\treturn NULL;\n}\n\n/* Compute the remainder of the integer division of \"pa1\" by \"pa2\"\n * with rounding towards zero.\n * \"pa2\" is assumed to be a piecewise constant.\n *\n * In particular, return\n *\n *\tpa1 - pa2 * (pa1 >= 0 ? floor(pa1/pa2) : ceil(pa1/pa2))\n *\n */\n__isl_give isl_pw_aff *isl_pw_aff_tdiv_r(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\tint is_cst;\n\tisl_pw_aff *res;\n\n\tis_cst = isl_pw_aff_is_cst(pa2);\n\tif (is_cst < 0)\n\t\tgoto error;\n\tif (!is_cst)\n\t\tisl_die(isl_pw_aff_get_ctx(pa2), isl_error_invalid,\n\t\t\t\"second argument should be a piecewise constant\",\n\t\t\tgoto error);\n\tres = isl_pw_aff_tdiv_q(isl_pw_aff_copy(pa1), isl_pw_aff_copy(pa2));\n\tres = isl_pw_aff_mul(pa2, res);\n\tres = isl_pw_aff_sub(pa1, res);\n\treturn res;\nerror:\n\tisl_pw_aff_free(pa1);\n\tisl_pw_aff_free(pa2);\n\treturn NULL;\n}\n\n/* Does either of \"pa1\" or \"pa2\" involve any NaN2?\n */\nstatic isl_bool either_involves_nan(__isl_keep isl_pw_aff *pa1,\n\t__isl_keep isl_pw_aff *pa2)\n{\n\tisl_bool has_nan;\n\n\thas_nan = isl_pw_aff_involves_nan(pa1);\n\tif (has_nan < 0 || has_nan)\n\t\treturn has_nan;\n\treturn isl_pw_aff_involves_nan(pa2);\n}\n\n/* Replace \"pa1\" and \"pa2\" (at least one of which involves a NaN)\n * by a NaN on their shared domain.\n *\n * In principle, the result could be refined to only being NaN\n * on the parts of this domain where at least one of \"pa1\" or \"pa2\" is NaN.\n */\nstatic __isl_give isl_pw_aff *replace_by_nan(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2)\n{\n\tisl_local_space *ls;\n\tisl_set *dom;\n\tisl_pw_aff *pa;\n\n\tdom = isl_set_intersect(isl_pw_aff_domain(pa1), isl_pw_aff_domain(pa2));\n\tls = isl_local_space_from_space(isl_set_get_space(dom));\n\tpa = isl_pw_aff_nan_on_domain(ls);\n\tpa = isl_pw_aff_intersect_domain(pa, dom);\n\n\treturn pa;\n}\n\nstatic __isl_give isl_pw_aff *pw_aff_min(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_set *le;\n\tisl_set *dom;\n\n\tdom = isl_set_intersect(isl_pw_aff_domain(isl_pw_aff_copy(pwaff1)),\n\t\t\t\tisl_pw_aff_domain(isl_pw_aff_copy(pwaff2)));\n\tle = isl_pw_aff_le_set(isl_pw_aff_copy(pwaff1),\n\t\t\t\tisl_pw_aff_copy(pwaff2));\n\tdom = isl_set_subtract(dom, isl_set_copy(le));\n\treturn isl_pw_aff_select(le, pwaff1, dom, pwaff2);\n}\n\nstatic __isl_give isl_pw_aff *pw_aff_max(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\tisl_set *ge;\n\tisl_set *dom;\n\n\tdom = isl_set_intersect(isl_pw_aff_domain(isl_pw_aff_copy(pwaff1)),\n\t\t\t\tisl_pw_aff_domain(isl_pw_aff_copy(pwaff2)));\n\tge = isl_pw_aff_ge_set(isl_pw_aff_copy(pwaff1),\n\t\t\t\tisl_pw_aff_copy(pwaff2));\n\tdom = isl_set_subtract(dom, isl_set_copy(ge));\n\treturn isl_pw_aff_select(ge, pwaff1, dom, pwaff2);\n}\n\n/* Return an expression for the minimum (if \"max\" is not set) or\n * the maximum (if \"max\" is set) of \"pa1\" and \"pa2\".\n * If either expression involves any NaN, then return a NaN\n * on the shared domain as result.\n */\nstatic __isl_give isl_pw_aff *pw_aff_min_max(__isl_take isl_pw_aff *pa1,\n\t__isl_take isl_pw_aff *pa2, int max)\n{\n\tisl_bool has_nan;\n\n\thas_nan = either_involves_nan(pa1, pa2);\n\tif (has_nan < 0)\n\t\tpa1 = isl_pw_aff_free(pa1);\n\telse if (has_nan)\n\t\treturn replace_by_nan(pa1, pa2);\n\n\tisl_pw_aff_align_params_bin(&pa1, &pa2);\n\tif (max)\n\t\treturn pw_aff_max(pa1, pa2);\n\telse\n\t\treturn pw_aff_min(pa1, pa2);\n}\n\n/* Return an expression for the minimum of \"pwaff1\" and \"pwaff2\".\n */\n__isl_give isl_pw_aff *isl_pw_aff_min(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\treturn pw_aff_min_max(pwaff1, pwaff2, 0);\n}\n\n/* Return an expression for the maximum of \"pwaff1\" and \"pwaff2\".\n */\n__isl_give isl_pw_aff *isl_pw_aff_max(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2)\n{\n\treturn pw_aff_min_max(pwaff1, pwaff2, 1);\n}\n\nstatic __isl_give isl_pw_aff *pw_aff_list_reduce(\n\t__isl_take isl_pw_aff_list *list,\n\t__isl_give isl_pw_aff *(*fn)(__isl_take isl_pw_aff *pwaff1,\n\t\t\t\t\t__isl_take isl_pw_aff *pwaff2))\n{\n\tint i;\n\tisl_ctx *ctx;\n\tisl_pw_aff *res;\n\n\tif (!list)\n\t\treturn NULL;\n\n\tctx = isl_pw_aff_list_get_ctx(list);\n\tif (list->n < 1)\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"list should contain at least one element\", goto error);\n\n\tres = isl_pw_aff_copy(list->p[0]);\n\tfor (i = 1; i < list->n; ++i)\n\t\tres = fn(res, isl_pw_aff_copy(list->p[i]));\n\n\tisl_pw_aff_list_free(list);\n\treturn res;\nerror:\n\tisl_pw_aff_list_free(list);\n\treturn NULL;\n}\n\n/* Return an isl_pw_aff that maps each element in the intersection of the\n * domains of the elements of list to the minimal corresponding affine\n * expression.\n */\n__isl_give isl_pw_aff *isl_pw_aff_list_min(__isl_take isl_pw_aff_list *list)\n{\n\treturn pw_aff_list_reduce(list, &isl_pw_aff_min);\n}\n\n/* Return an isl_pw_aff that maps each element in the intersection of the\n * domains of the elements of list to the maximal corresponding affine\n * expression.\n */\n__isl_give isl_pw_aff *isl_pw_aff_list_max(__isl_take isl_pw_aff_list *list)\n{\n\treturn pw_aff_list_reduce(list, &isl_pw_aff_max);\n}\n\n/* Mark the domains of \"pwaff\" as rational.\n */\n__isl_give isl_pw_aff *isl_pw_aff_set_rational(__isl_take isl_pw_aff *pwaff)\n{\n\tint i;\n\n\tpwaff = isl_pw_aff_cow(pwaff);\n\tif (!pwaff)\n\t\treturn NULL;\n\tif (pwaff->n == 0)\n\t\treturn pwaff;\n\n\tfor (i = 0; i < pwaff->n; ++i) {\n\t\tpwaff->p[i].set = isl_set_set_rational(pwaff->p[i].set);\n\t\tif (!pwaff->p[i].set)\n\t\t\treturn isl_pw_aff_free(pwaff);\n\t}\n\n\treturn pwaff;\n}\n\n/* Mark the domains of the elements of \"list\" as rational.\n */\n__isl_give isl_pw_aff_list *isl_pw_aff_list_set_rational(\n\t__isl_take isl_pw_aff_list *list)\n{\n\tint i, n;\n\n\tif (!list)\n\t\treturn NULL;\n\tif (list->n == 0)\n\t\treturn list;\n\n\tn = list->n;\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\n\t\tpa = isl_pw_aff_list_get_pw_aff(list, i);\n\t\tpa = isl_pw_aff_set_rational(pa);\n\t\tlist = isl_pw_aff_list_set_pw_aff(list, i, pa);\n\t}\n\n\treturn list;\n}\n\n/* Do the parameters of \"aff\" match those of \"space\"?\n */\nisl_bool isl_aff_matching_params(__isl_keep isl_aff *aff,\n\t__isl_keep isl_space *space)\n{\n\tisl_space *aff_space;\n\tisl_bool match;\n\n\tif (!aff || !space)\n\t\treturn isl_bool_error;\n\n\taff_space = isl_aff_get_domain_space(aff);\n\n\tmatch = isl_space_has_equal_params(space, aff_space);\n\n\tisl_space_free(aff_space);\n\treturn match;\n}\n\n/* Check that the domain space of \"aff\" matches \"space\".\n */\nisl_stat isl_aff_check_match_domain_space(__isl_keep isl_aff *aff,\n\t__isl_keep isl_space *space)\n{\n\tisl_space *aff_space;\n\tisl_bool match;\n\n\tif (!aff || !space)\n\t\treturn isl_stat_error;\n\n\taff_space = isl_aff_get_domain_space(aff);\n\n\tmatch = isl_space_has_equal_params(space, aff_space);\n\tif (match < 0)\n\t\tgoto error;\n\tif (!match)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"parameters don't match\", goto error);\n\tmatch = isl_space_tuple_is_equal(space, isl_dim_in,\n\t\t\t\t\taff_space, isl_dim_set);\n\tif (match < 0)\n\t\tgoto error;\n\tif (!match)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"domains don't match\", goto error);\n\tisl_space_free(aff_space);\n\treturn isl_stat_ok;\nerror:\n\tisl_space_free(aff_space);\n\treturn isl_stat_error;\n}\n\n/* Return the shared (universe) domain of the elements of \"ma\".\n *\n * Since an isl_multi_aff (and an isl_aff) is always total,\n * the domain is always the universe set in its domain space.\n * This is a helper function for use in the generic isl_multi_*_bind.\n */\nstatic __isl_give isl_basic_set *isl_multi_aff_domain(\n\t__isl_take isl_multi_aff *ma)\n{\n\tisl_space *space;\n\n\tspace = isl_multi_aff_get_space(ma);\n\tisl_multi_aff_free(ma);\n\n\treturn isl_basic_set_universe(isl_space_domain(space));\n}\n\n#undef BASE\n#define BASE aff\n\n#include <isl_multi_no_explicit_domain.c>\n#include <isl_multi_templ.c>\n#include <isl_multi_add_constant_templ.c>\n#include <isl_multi_apply_set.c>\n#include <isl_multi_arith_templ.c>\n#include <isl_multi_bind_domain_templ.c>\n#include <isl_multi_cmp.c>\n#include <isl_multi_dim_id_templ.c>\n#include <isl_multi_dims.c>\n#include <isl_multi_floor.c>\n#include <isl_multi_from_base_templ.c>\n#include <isl_multi_identity_templ.c>\n#include <isl_multi_insert_domain_templ.c>\n#include <isl_multi_locals_templ.c>\n#include <isl_multi_move_dims_templ.c>\n#include <isl_multi_nan_templ.c>\n#include <isl_multi_product_templ.c>\n#include <isl_multi_splice_templ.c>\n#include <isl_multi_tuple_id_templ.c>\n#include <isl_multi_unbind_params_templ.c>\n#include <isl_multi_zero_templ.c>\n\n#undef DOMBASE\n#define DOMBASE set\n#include <isl_multi_gist.c>\n\n#undef DOMBASE\n#define DOMBASE basic_set\n#include <isl_multi_bind_templ.c>\n\n/* Construct an isl_multi_aff living in \"space\" that corresponds\n * to the affine transformation matrix \"mat\".\n */\n__isl_give isl_multi_aff *isl_multi_aff_from_aff_mat(\n\t__isl_take isl_space *space, __isl_take isl_mat *mat)\n{\n\tisl_ctx *ctx;\n\tisl_local_space *ls = NULL;\n\tisl_multi_aff *ma = NULL;\n\tisl_size n_row, n_col, n_out, total;\n\tint i;\n\n\tif (!space || !mat)\n\t\tgoto error;\n\n\tctx = isl_mat_get_ctx(mat);\n\n\tn_row = isl_mat_rows(mat);\n\tn_col = isl_mat_cols(mat);\n\tn_out = isl_space_dim(space, isl_dim_out);\n\ttotal = isl_space_dim(space, isl_dim_all);\n\tif (n_row < 0 || n_col < 0 || n_out < 0 || total < 0)\n\t\tgoto error;\n\tif (n_row < 1)\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"insufficient number of rows\", goto error);\n\tif (n_col < 1)\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"insufficient number of columns\", goto error);\n\tif (1 + n_out != n_row || 2 + total != n_row + n_col)\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"dimension mismatch\", goto error);\n\n\tma = isl_multi_aff_zero(isl_space_copy(space));\n\tspace = isl_space_domain(space);\n\tls = isl_local_space_from_space(isl_space_copy(space));\n\n\tfor (i = 0; i < n_row - 1; ++i) {\n\t\tisl_vec *v;\n\t\tisl_aff *aff;\n\n\t\tv = isl_vec_alloc(ctx, 1 + n_col);\n\t\tif (!v)\n\t\t\tgoto error;\n\t\tisl_int_set(v->el[0], mat->row[0][0]);\n\t\tisl_seq_cpy(v->el + 1, mat->row[1 + i], n_col);\n\t\tv = isl_vec_normalize(v);\n\t\taff = isl_aff_alloc_vec(isl_local_space_copy(ls), v);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\n\tisl_space_free(space);\n\tisl_local_space_free(ls);\n\tisl_mat_free(mat);\n\treturn ma;\nerror:\n\tisl_space_free(space);\n\tisl_local_space_free(ls);\n\tisl_mat_free(mat);\n\tisl_multi_aff_free(ma);\n\treturn NULL;\n}\n\n/* Return the constant terms of the affine expressions of \"ma\".\n */\n__isl_give isl_multi_val *isl_multi_aff_get_constant_multi_val(\n\t__isl_keep isl_multi_aff *ma)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_multi_val *mv;\n\n\tn = isl_multi_aff_size(ma);\n\tif (n < 0)\n\t\treturn NULL;\n\tspace = isl_space_range(isl_multi_aff_get_space(ma));\n\tspace = isl_space_drop_all_params(space);\n\tmv = isl_multi_val_zero(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_aff *aff;\n\t\tisl_val *val;\n\n\t\taff = isl_multi_aff_get_at(ma, i);\n\t\tval = isl_aff_get_constant_val(aff);\n\t\tisl_aff_free(aff);\n\t\tmv = isl_multi_val_set_at(mv, i, val);\n\t}\n\n\treturn mv;\n}\n\n/* Remove any internal structure of the domain of \"ma\".\n * If there is any such internal structure in the input,\n * then the name of the corresponding space is also removed.\n */\n__isl_give isl_multi_aff *isl_multi_aff_flatten_domain(\n\t__isl_take isl_multi_aff *ma)\n{\n\tisl_space *space;\n\n\tif (!ma)\n\t\treturn NULL;\n\n\tif (!ma->space->nested[0])\n\t\treturn ma;\n\n\tspace = isl_multi_aff_get_space(ma);\n\tspace = isl_space_flatten_domain(space);\n\tma = isl_multi_aff_reset_space(ma, space);\n\n\treturn ma;\n}\n\n/* Given a map space, return an isl_multi_aff that maps a wrapped copy\n * of the space to its domain.\n */\n__isl_give isl_multi_aff *isl_multi_aff_domain_map(__isl_take isl_space *space)\n{\n\tint i;\n\tisl_size n_in;\n\tisl_local_space *ls;\n\tisl_multi_aff *ma;\n\n\tif (!space)\n\t\treturn NULL;\n\tif (!isl_space_is_map(space))\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"not a map space\", goto error);\n\n\tn_in = isl_space_dim(space, isl_dim_in);\n\tif (n_in < 0)\n\t\tgoto error;\n\tspace = isl_space_domain_map(space);\n\n\tma = isl_multi_aff_alloc(isl_space_copy(space));\n\tif (n_in == 0) {\n\t\tisl_space_free(space);\n\t\treturn ma;\n\t}\n\n\tspace = isl_space_domain(space);\n\tls = isl_local_space_from_space(space);\n\tfor (i = 0; i < n_in; ++i) {\n\t\tisl_aff *aff;\n\n\t\taff = isl_aff_var_on_domain(isl_local_space_copy(ls),\n\t\t\t\t\t\tisl_dim_set, i);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\tisl_local_space_free(ls);\n\treturn ma;\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Given a map space, return an isl_multi_aff that maps a wrapped copy\n * of the space to its range.\n */\n__isl_give isl_multi_aff *isl_multi_aff_range_map(__isl_take isl_space *space)\n{\n\tint i;\n\tisl_size n_in, n_out;\n\tisl_local_space *ls;\n\tisl_multi_aff *ma;\n\n\tif (!space)\n\t\treturn NULL;\n\tif (!isl_space_is_map(space))\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"not a map space\", goto error);\n\n\tn_in = isl_space_dim(space, isl_dim_in);\n\tn_out = isl_space_dim(space, isl_dim_out);\n\tif (n_in < 0 || n_out < 0)\n\t\tgoto error;\n\tspace = isl_space_range_map(space);\n\n\tma = isl_multi_aff_alloc(isl_space_copy(space));\n\tif (n_out == 0) {\n\t\tisl_space_free(space);\n\t\treturn ma;\n\t}\n\n\tspace = isl_space_domain(space);\n\tls = isl_local_space_from_space(space);\n\tfor (i = 0; i < n_out; ++i) {\n\t\tisl_aff *aff;\n\n\t\taff = isl_aff_var_on_domain(isl_local_space_copy(ls),\n\t\t\t\t\t\tisl_dim_set, n_in + i);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\tisl_local_space_free(ls);\n\treturn ma;\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Given a map space, return an isl_pw_multi_aff that maps a wrapped copy\n * of the space to its domain.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_domain_map(\n\t__isl_take isl_space *space)\n{\n\treturn isl_pw_multi_aff_from_multi_aff(isl_multi_aff_domain_map(space));\n}\n\n/* Given a map space, return an isl_pw_multi_aff that maps a wrapped copy\n * of the space to its range.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_range_map(\n\t__isl_take isl_space *space)\n{\n\treturn isl_pw_multi_aff_from_multi_aff(isl_multi_aff_range_map(space));\n}\n\n/* Given the space of a set and a range of set dimensions,\n * construct an isl_multi_aff that projects out those dimensions.\n */\n__isl_give isl_multi_aff *isl_multi_aff_project_out_map(\n\t__isl_take isl_space *space, enum isl_dim_type type,\n\tunsigned first, unsigned n)\n{\n\tint i;\n\tisl_size dim;\n\tisl_local_space *ls;\n\tisl_multi_aff *ma;\n\n\tif (!space)\n\t\treturn NULL;\n\tif (!isl_space_is_set(space))\n\t\tisl_die(isl_space_get_ctx(space), isl_error_unsupported,\n\t\t\t\"expecting set space\", goto error);\n\tif (type != isl_dim_set)\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"only set dimensions can be projected out\", goto error);\n\tif (isl_space_check_range(space, type, first, n) < 0)\n\t\tgoto error;\n\n\tdim = isl_space_dim(space, isl_dim_set);\n\tif (dim < 0)\n\t\tgoto error;\n\n\tspace = isl_space_from_domain(space);\n\tspace = isl_space_add_dims(space, isl_dim_out, dim - n);\n\n\tif (dim == n)\n\t\treturn isl_multi_aff_alloc(space);\n\n\tma = isl_multi_aff_alloc(isl_space_copy(space));\n\tspace = isl_space_domain(space);\n\tls = isl_local_space_from_space(space);\n\n\tfor (i = 0; i < first; ++i) {\n\t\tisl_aff *aff;\n\n\t\taff = isl_aff_var_on_domain(isl_local_space_copy(ls),\n\t\t\t\t\t\tisl_dim_set, i);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\n\tfor (i = 0; i < dim - (first + n); ++i) {\n\t\tisl_aff *aff;\n\n\t\taff = isl_aff_var_on_domain(isl_local_space_copy(ls),\n\t\t\t\t\t\tisl_dim_set, first + n + i);\n\t\tma = isl_multi_aff_set_aff(ma, first + i, aff);\n\t}\n\n\tisl_local_space_free(ls);\n\treturn ma;\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Given the space of a set and a range of set dimensions,\n * construct an isl_pw_multi_aff that projects out those dimensions.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_project_out_map(\n\t__isl_take isl_space *space, enum isl_dim_type type,\n\tunsigned first, unsigned n)\n{\n\tisl_multi_aff *ma;\n\n\tma = isl_multi_aff_project_out_map(space, type, first, n);\n\treturn isl_pw_multi_aff_from_multi_aff(ma);\n}\n\n/* Create a piecewise multi-affine expression in the given space that maps each\n * input dimension to the corresponding output dimension.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_identity(\n\t__isl_take isl_space *space)\n{\n\treturn isl_pw_multi_aff_from_multi_aff(isl_multi_aff_identity(space));\n}\n\n/* Create a piecewise multi expression that maps elements in the given space\n * to themselves.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_identity_on_domain_space(\n\t__isl_take isl_space *space)\n{\n\tisl_multi_aff *ma;\n\n\tma = isl_multi_aff_identity_on_domain_space(space);\n\treturn isl_pw_multi_aff_from_multi_aff(ma);\n}\n\n/* Exploit the equalities in \"eq\" to simplify the affine expressions.\n */\nstatic __isl_give isl_multi_aff *isl_multi_aff_substitute_equalities(\n\t__isl_take isl_multi_aff *maff, __isl_take isl_basic_set *eq)\n{\n\tint i;\n\n\tmaff = isl_multi_aff_cow(maff);\n\tif (!maff || !eq)\n\t\tgoto error;\n\n\tfor (i = 0; i < maff->n; ++i) {\n\t\tmaff->u.p[i] = isl_aff_substitute_equalities(maff->u.p[i],\n\t\t\t\t\t\t    isl_basic_set_copy(eq));\n\t\tif (!maff->u.p[i])\n\t\t\tgoto error;\n\t}\n\n\tisl_basic_set_free(eq);\n\treturn maff;\nerror:\n\tisl_basic_set_free(eq);\n\tisl_multi_aff_free(maff);\n\treturn NULL;\n}\n\n__isl_give isl_multi_aff *isl_multi_aff_scale(__isl_take isl_multi_aff *maff,\n\tisl_int f)\n{\n\tint i;\n\n\tmaff = isl_multi_aff_cow(maff);\n\tif (!maff)\n\t\treturn NULL;\n\n\tfor (i = 0; i < maff->n; ++i) {\n\t\tmaff->u.p[i] = isl_aff_scale(maff->u.p[i], f);\n\t\tif (!maff->u.p[i])\n\t\t\treturn isl_multi_aff_free(maff);\n\t}\n\n\treturn maff;\n}\n\n__isl_give isl_multi_aff *isl_multi_aff_add_on_domain(__isl_keep isl_set *dom,\n\t__isl_take isl_multi_aff *maff1, __isl_take isl_multi_aff *maff2)\n{\n\tmaff1 = isl_multi_aff_add(maff1, maff2);\n\tmaff1 = isl_multi_aff_gist(maff1, isl_set_copy(dom));\n\treturn maff1;\n}\n\nisl_bool isl_multi_aff_is_empty(__isl_keep isl_multi_aff *maff)\n{\n\tif (!maff)\n\t\treturn isl_bool_error;\n\n\treturn isl_bool_false;\n}\n\n/* Return the set of domain elements where \"ma1\" is lexicographically\n * smaller than or equal to \"ma2\".\n */\n__isl_give isl_set *isl_multi_aff_lex_le_set(__isl_take isl_multi_aff *ma1,\n\t__isl_take isl_multi_aff *ma2)\n{\n\treturn isl_multi_aff_lex_ge_set(ma2, ma1);\n}\n\n/* Return the set of domain elements where \"ma1\" is lexicographically\n * smaller than \"ma2\".\n */\n__isl_give isl_set *isl_multi_aff_lex_lt_set(__isl_take isl_multi_aff *ma1,\n\t__isl_take isl_multi_aff *ma2)\n{\n\treturn isl_multi_aff_lex_gt_set(ma2, ma1);\n}\n\n/* Return the set of domain elements where \"ma1\" is lexicographically\n * greater than to \"ma2\".  If \"equal\" is set, then include the domain\n * elements where they are equal.\n * Do this for the case where there are no entries.\n * In this case, \"ma1\" cannot be greater than \"ma2\",\n * but it is (greater than or) equal to \"ma2\".\n */\nstatic __isl_give isl_set *isl_multi_aff_lex_gte_set_0d(\n\t__isl_take isl_multi_aff *ma1, __isl_take isl_multi_aff *ma2, int equal)\n{\n\tisl_space *space;\n\n\tspace = isl_multi_aff_get_domain_space(ma1);\n\n\tisl_multi_aff_free(ma1);\n\tisl_multi_aff_free(ma2);\n\n\tif (equal)\n\t\treturn isl_set_universe(space);\n\telse\n\t\treturn isl_set_empty(space);\n}\n\n/* Return the set where entry \"i\" of \"ma1\" and \"ma2\"\n * satisfy the relation prescribed by \"cmp\".\n */\nstatic __isl_give isl_set *isl_multi_aff_order_at(__isl_keep isl_multi_aff *ma1,\n\t__isl_keep isl_multi_aff *ma2, int i,\n\t__isl_give isl_set *(*cmp)(__isl_take isl_aff *aff1,\n\t\t__isl_take isl_aff *aff2))\n{\n\tisl_aff *aff1, *aff2;\n\n\taff1 = isl_multi_aff_get_at(ma1, i);\n\taff2 = isl_multi_aff_get_at(ma2, i);\n\treturn cmp(aff1, aff2);\n}\n\n/* Return the set of domain elements where \"ma1\" is lexicographically\n * greater than to \"ma2\".  If \"equal\" is set, then include the domain\n * elements where they are equal.\n *\n * In particular, for all but the final entry,\n * include the set of elements where this entry is strictly greater in \"ma1\"\n * and all previous entries are equal.\n * The final entry is also allowed to be equal in the two functions\n * if \"equal\" is set.\n *\n * The case where there are no entries is handled separately.\n */\nstatic __isl_give isl_set *isl_multi_aff_lex_gte_set(\n\t__isl_take isl_multi_aff *ma1, __isl_take isl_multi_aff *ma2, int equal)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_set *res;\n\tisl_set *equal_set;\n\tisl_set *gte;\n\n\tif (isl_multi_aff_check_equal_space(ma1, ma2) < 0)\n\t\tgoto error;\n\tn = isl_multi_aff_size(ma1);\n\tif (n < 0)\n\t\tgoto error;\n\tif (n == 0)\n\t\treturn isl_multi_aff_lex_gte_set_0d(ma1, ma2, equal);\n\n\tspace = isl_multi_aff_get_domain_space(ma1);\n\tres = isl_set_empty(isl_space_copy(space));\n\tequal_set = isl_set_universe(space);\n\n\tfor (i = 0; i + 1 < n; ++i) {\n\t\tisl_bool empty;\n\t\tisl_set *gt, *eq;\n\n\t\tgt = isl_multi_aff_order_at(ma1, ma2, i, &isl_aff_gt_set);\n\t\tgt = isl_set_intersect(gt, isl_set_copy(equal_set));\n\t\tres = isl_set_union(res, gt);\n\t\teq = isl_multi_aff_order_at(ma1, ma2, i, &isl_aff_eq_set);\n\t\tequal_set = isl_set_intersect(equal_set, eq);\n\n\t\tempty = isl_set_is_empty(equal_set);\n\t\tif (empty >= 0 && empty)\n\t\t\tbreak;\n\t}\n\n\tif (equal)\n\t\tgte = isl_multi_aff_order_at(ma1, ma2, n - 1, &isl_aff_ge_set);\n\telse\n\t\tgte = isl_multi_aff_order_at(ma1, ma2, n - 1, &isl_aff_gt_set);\n\tisl_multi_aff_free(ma1);\n\tisl_multi_aff_free(ma2);\n\n\tgte = isl_set_intersect(gte, equal_set);\n\treturn isl_set_union(res, gte);\nerror:\n\tisl_multi_aff_free(ma1);\n\tisl_multi_aff_free(ma2);\n\treturn NULL;\n}\n\n/* Return the set of domain elements where \"ma1\" is lexicographically\n * greater than or equal to \"ma2\".\n */\n__isl_give isl_set *isl_multi_aff_lex_ge_set(__isl_take isl_multi_aff *ma1,\n\t__isl_take isl_multi_aff *ma2)\n{\n\treturn isl_multi_aff_lex_gte_set(ma1, ma2, 1);\n}\n\n/* Return the set of domain elements where \"ma1\" is lexicographically\n * greater than \"ma2\".\n */\n__isl_give isl_set *isl_multi_aff_lex_gt_set(__isl_take isl_multi_aff *ma1,\n\t__isl_take isl_multi_aff *ma2)\n{\n\treturn isl_multi_aff_lex_gte_set(ma1, ma2, 0);\n}\n\n#define isl_multi_aff_zero_in_space\tisl_multi_aff_zero\n\n#undef PW\n#define PW isl_pw_multi_aff\n#undef BASE\n#define BASE multi_aff\n#undef EL_IS_ZERO\n#define EL_IS_ZERO is_empty\n#undef ZERO\n#define ZERO empty\n#undef IS_ZERO\n#define IS_ZERO is_empty\n#undef FIELD\n#define FIELD maff\n#undef DEFAULT_IS_ZERO\n#define DEFAULT_IS_ZERO 0\n\n#include <isl_pw_templ.c>\n#include <isl_pw_add_constant_multi_val_templ.c>\n#include <isl_pw_add_constant_val_templ.c>\n#include <isl_pw_bind_domain_templ.c>\n#include <isl_pw_insert_dims_templ.c>\n#include <isl_pw_insert_domain_templ.c>\n#include <isl_pw_locals_templ.c>\n#include <isl_pw_move_dims_templ.c>\n#include <isl_pw_neg_templ.c>\n#include <isl_pw_pullback_templ.c>\n#include <isl_pw_union_opt.c>\n\n#undef BASE\n#define BASE pw_multi_aff\n\n#include <isl_union_multi.c>\n#include \"isl_union_locals_templ.c\"\n#include <isl_union_neg.c>\n\n#undef BASE\n#define BASE multi_aff\n\n#include <isl_union_pw_templ.c>\n\n/* Generic function for extracting a factor from a product \"pma\".\n * \"check_space\" checks that the space is that of the right kind of product.\n * \"space_factor\" extracts the factor from the space.\n * \"multi_aff_factor\" extracts the factor from the constituent functions.\n */\nstatic __isl_give isl_pw_multi_aff *pw_multi_aff_factor(\n\t__isl_take isl_pw_multi_aff *pma,\n\tisl_stat (*check_space)(__isl_keep isl_pw_multi_aff *pma),\n\t__isl_give isl_space *(*space_factor)(__isl_take isl_space *space),\n\t__isl_give isl_multi_aff *(*multi_aff_factor)(\n\t\t__isl_take isl_multi_aff *ma))\n{\n\tint i;\n\tisl_space *space;\n\n\tif (check_space(pma) < 0)\n\t\treturn isl_pw_multi_aff_free(pma);\n\n\tspace = isl_pw_multi_aff_take_space(pma);\n\tspace = space_factor(space);\n\n\tfor (i = 0; pma && i < pma->n; ++i) {\n\t\tisl_multi_aff *ma;\n\n\t\tma = isl_pw_multi_aff_take_base_at(pma, i);\n\t\tma = multi_aff_factor(ma);\n\t\tpma = isl_pw_multi_aff_restore_base_at(pma, i, ma);\n\t}\n\n\tpma = isl_pw_multi_aff_restore_space(pma, space);\n\n\treturn pma;\n}\n\n/* Is the range of \"pma\" a wrapped relation?\n */\nstatic isl_bool isl_pw_multi_aff_range_is_wrapping(\n\t__isl_keep isl_pw_multi_aff *pma)\n{\n\treturn isl_space_range_is_wrapping(isl_pw_multi_aff_peek_space(pma));\n}\n\n/* Check that the range of \"pma\" is a product.\n */\nstatic isl_stat pw_multi_aff_check_range_product(\n\t__isl_keep isl_pw_multi_aff *pma)\n{\n\tisl_bool wraps;\n\n\twraps = isl_pw_multi_aff_range_is_wrapping(pma);\n\tif (wraps < 0)\n\t\treturn isl_stat_error;\n\tif (!wraps)\n\t\tisl_die(isl_pw_multi_aff_get_ctx(pma), isl_error_invalid,\n\t\t\t\"range is not a product\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Given a function A -> [B -> C], extract the function A -> B.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_range_factor_domain(\n\t__isl_take isl_pw_multi_aff *pma)\n{\n\treturn pw_multi_aff_factor(pma, &pw_multi_aff_check_range_product,\n\t\t\t\t&isl_space_range_factor_domain,\n\t\t\t\t&isl_multi_aff_range_factor_domain);\n}\n\n/* Given a function A -> [B -> C], extract the function A -> C.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_range_factor_range(\n\t__isl_take isl_pw_multi_aff *pma)\n{\n\treturn pw_multi_aff_factor(pma, &pw_multi_aff_check_range_product,\n\t\t\t\t&isl_space_range_factor_range,\n\t\t\t\t&isl_multi_aff_range_factor_range);\n}\n\n/* Given two piecewise multi affine expressions, return a piecewise\n * multi-affine expression defined on the union of the definition domains\n * of the inputs that is equal to the lexicographic maximum of the two\n * inputs on each cell.  If only one of the two inputs is defined on\n * a given cell, then it is considered to be the maximum.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_union_lexmax(\n\t__isl_take isl_pw_multi_aff *pma1,\n\t__isl_take isl_pw_multi_aff *pma2)\n{\n\tisl_pw_multi_aff_align_params_bin(&pma1, &pma2);\n\treturn isl_pw_multi_aff_union_opt_cmp(pma1, pma2,\n\t\t\t\t\t    &isl_multi_aff_lex_ge_set);\n}\n\n/* Given two piecewise multi affine expressions, return a piecewise\n * multi-affine expression defined on the union of the definition domains\n * of the inputs that is equal to the lexicographic minimum of the two\n * inputs on each cell.  If only one of the two inputs is defined on\n * a given cell, then it is considered to be the minimum.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_union_lexmin(\n\t__isl_take isl_pw_multi_aff *pma1,\n\t__isl_take isl_pw_multi_aff *pma2)\n{\n\tisl_pw_multi_aff_align_params_bin(&pma1, &pma2);\n\treturn isl_pw_multi_aff_union_opt_cmp(pma1, pma2,\n\t\t\t\t\t    &isl_multi_aff_lex_le_set);\n}\n\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_add(\n\t__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2)\n{\n\tisl_pw_multi_aff_align_params_bin(&pma1, &pma2);\n\treturn isl_pw_multi_aff_on_shared_domain(pma1, pma2,\n\t\t\t\t\t\t&isl_multi_aff_add);\n}\n\n/* Subtract \"pma2\" from \"pma1\" and return the result.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_sub(\n\t__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2)\n{\n\tisl_pw_multi_aff_align_params_bin(&pma1, &pma2);\n\treturn isl_pw_multi_aff_on_shared_domain(pma1, pma2,\n\t\t\t\t\t\t&isl_multi_aff_sub);\n}\n\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_union_add(\n\t__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2)\n{\n\treturn isl_pw_multi_aff_union_add_(pma1, pma2);\n}\n\n/* Compute the sum of \"upa1\" and \"upa2\" on the union of their domains,\n * with the actual sum on the shared domain and\n * the defined expression on the symmetric difference of the domains.\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_union_add(\n\t__isl_take isl_union_pw_aff *upa1, __isl_take isl_union_pw_aff *upa2)\n{\n\treturn isl_union_pw_aff_union_add_(upa1, upa2);\n}\n\n/* Compute the sum of \"upma1\" and \"upma2\" on the union of their domains,\n * with the actual sum on the shared domain and\n * the defined expression on the symmetric difference of the domains.\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_union_add(\n\t__isl_take isl_union_pw_multi_aff *upma1,\n\t__isl_take isl_union_pw_multi_aff *upma2)\n{\n\treturn isl_union_pw_multi_aff_union_add_(upma1, upma2);\n}\n\n/* Given two piecewise multi-affine expressions A -> B and C -> D,\n * construct a piecewise multi-affine expression [A -> C] -> [B -> D].\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_product(\n\t__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2)\n{\n\tint i, j, n;\n\tisl_space *space;\n\tisl_pw_multi_aff *res;\n\n\tif (isl_pw_multi_aff_align_params_bin(&pma1, &pma2) < 0)\n\t\tgoto error;\n\n\tn = pma1->n * pma2->n;\n\tspace = isl_space_product(isl_space_copy(pma1->dim),\n\t\t\t\t  isl_space_copy(pma2->dim));\n\tres = isl_pw_multi_aff_alloc_size(space, n);\n\n\tfor (i = 0; i < pma1->n; ++i) {\n\t\tfor (j = 0; j < pma2->n; ++j) {\n\t\t\tisl_set *domain;\n\t\t\tisl_multi_aff *ma;\n\n\t\t\tdomain = isl_set_product(isl_set_copy(pma1->p[i].set),\n\t\t\t\t\t\t isl_set_copy(pma2->p[j].set));\n\t\t\tma = isl_multi_aff_product(\n\t\t\t\t\tisl_multi_aff_copy(pma1->p[i].maff),\n\t\t\t\t\tisl_multi_aff_copy(pma2->p[j].maff));\n\t\t\tres = isl_pw_multi_aff_add_piece(res, domain, ma);\n\t\t}\n\t}\n\n\tisl_pw_multi_aff_free(pma1);\n\tisl_pw_multi_aff_free(pma2);\n\treturn res;\nerror:\n\tisl_pw_multi_aff_free(pma1);\n\tisl_pw_multi_aff_free(pma2);\n\treturn NULL;\n}\n\n/* Subtract the initial \"n\" elements in \"ma\" with coefficients in \"c\" and\n * denominator \"denom\".\n * \"denom\" is allowed to be negative, in which case the actual denominator\n * is -denom and the expressions are added instead.\n */\nstatic __isl_give isl_aff *subtract_initial(__isl_take isl_aff *aff,\n\t__isl_keep isl_multi_aff *ma, int n, isl_int *c, isl_int denom)\n{\n\tint i, first;\n\tint sign;\n\tisl_int d;\n\n\tfirst = isl_seq_first_non_zero(c, n);\n\tif (first == -1)\n\t\treturn aff;\n\n\tsign = isl_int_sgn(denom);\n\tisl_int_init(d);\n\tisl_int_abs(d, denom);\n\tfor (i = first; i < n; ++i) {\n\t\tisl_aff *aff_i;\n\n\t\tif (isl_int_is_zero(c[i]))\n\t\t\tcontinue;\n\t\taff_i = isl_multi_aff_get_aff(ma, i);\n\t\taff_i = isl_aff_scale(aff_i, c[i]);\n\t\taff_i = isl_aff_scale_down(aff_i, d);\n\t\tif (sign >= 0)\n\t\t\taff = isl_aff_sub(aff, aff_i);\n\t\telse\n\t\t\taff = isl_aff_add(aff, aff_i);\n\t}\n\tisl_int_clear(d);\n\n\treturn aff;\n}\n\n/* Extract an affine expression that expresses the output dimension \"pos\"\n * of \"bmap\" in terms of the parameters and input dimensions from\n * equality \"eq\".\n * Note that this expression may involve integer divisions defined\n * in terms of parameters and input dimensions.\n * The equality may also involve references to earlier (but not later)\n * output dimensions.  These are replaced by the corresponding elements\n * in \"ma\".\n *\n * If the equality is of the form\n *\n *\tf(i) + h(j) + a x + g(i) = 0,\n *\n * with f(i) a linear combinations of the parameters and input dimensions,\n * g(i) a linear combination of integer divisions defined in terms of the same\n * and h(j) a linear combinations of earlier output dimensions,\n * then the affine expression is\n *\n *\t(-f(i) - g(i))/a - h(j)/a\n *\n * If the equality is of the form\n *\n *\tf(i) + h(j) - a x + g(i) = 0,\n *\n * then the affine expression is\n *\n *\t(f(i) + g(i))/a - h(j)/(-a)\n *\n *\n * If \"div\" refers to an integer division (i.e., it is smaller than\n * the number of integer divisions), then the equality constraint\n * does involve an integer division (the one at position \"div\") that\n * is defined in terms of output dimensions.  However, this integer\n * division can be eliminated by exploiting a pair of constraints\n * x >= l and x <= l + n, with n smaller than the coefficient of \"div\"\n * in the equality constraint.  \"ineq\" refers to inequality x >= l, i.e.,\n * -l + x >= 0.\n * In particular, let\n *\n *\tx = e(i) + m floor(...)\n *\n * with e(i) the expression derived above and floor(...) the integer\n * division involving output dimensions.\n * From\n *\n *\tl <= x <= l + n,\n *\n * we have\n *\n *\t0 <= x - l <= n\n *\n * This means\n *\n *\te(i) + m floor(...) - l = (e(i) + m floor(...) - l) mod m\n *\t                        = (e(i) - l) mod m\n *\n * Therefore,\n *\n *\tx - l = (e(i) - l) mod m\n *\n * or\n *\n *\tx = ((e(i) - l) mod m) + l\n *\n * The variable \"shift\" below contains the expression -l, which may\n * also involve a linear combination of earlier output dimensions.\n */\nstatic __isl_give isl_aff *extract_aff_from_equality(\n\t__isl_keep isl_basic_map *bmap, int pos, int eq, int div, int ineq,\n\t__isl_keep isl_multi_aff *ma)\n{\n\tunsigned o_out;\n\tisl_size n_div, n_out;\n\tisl_ctx *ctx;\n\tisl_local_space *ls;\n\tisl_aff *aff, *shift;\n\tisl_val *mod;\n\n\tctx = isl_basic_map_get_ctx(bmap);\n\tls = isl_basic_map_get_local_space(bmap);\n\tls = isl_local_space_domain(ls);\n\taff = isl_aff_alloc(isl_local_space_copy(ls));\n\tif (!aff)\n\t\tgoto error;\n\to_out = isl_basic_map_offset(bmap, isl_dim_out);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (n_out < 0 || n_div < 0)\n\t\tgoto error;\n\tif (isl_int_is_neg(bmap->eq[eq][o_out + pos])) {\n\t\tisl_seq_cpy(aff->v->el + 1, bmap->eq[eq], o_out);\n\t\tisl_seq_cpy(aff->v->el + 1 + o_out,\n\t\t\t    bmap->eq[eq] + o_out + n_out, n_div);\n\t} else {\n\t\tisl_seq_neg(aff->v->el + 1, bmap->eq[eq], o_out);\n\t\tisl_seq_neg(aff->v->el + 1 + o_out,\n\t\t\t    bmap->eq[eq] + o_out + n_out, n_div);\n\t}\n\tif (div < n_div)\n\t\tisl_int_set_si(aff->v->el[1 + o_out + div], 0);\n\tisl_int_abs(aff->v->el[0], bmap->eq[eq][o_out + pos]);\n\taff = subtract_initial(aff, ma, pos, bmap->eq[eq] + o_out,\n\t\t\t    bmap->eq[eq][o_out + pos]);\n\tif (div < n_div) {\n\t\tshift = isl_aff_alloc(isl_local_space_copy(ls));\n\t\tif (!shift)\n\t\t\tgoto error;\n\t\tisl_seq_cpy(shift->v->el + 1, bmap->ineq[ineq], o_out);\n\t\tisl_seq_cpy(shift->v->el + 1 + o_out,\n\t\t\t    bmap->ineq[ineq] + o_out + n_out, n_div);\n\t\tisl_int_set_si(shift->v->el[0], 1);\n\t\tshift = subtract_initial(shift, ma, pos,\n\t\t\t\t\tbmap->ineq[ineq] + o_out, ctx->negone);\n\t\taff = isl_aff_add(aff, isl_aff_copy(shift));\n\t\tmod = isl_val_int_from_isl_int(ctx,\n\t\t\t\t\t    bmap->eq[eq][o_out + n_out + div]);\n\t\tmod = isl_val_abs(mod);\n\t\taff = isl_aff_mod_val(aff, mod);\n\t\taff = isl_aff_sub(aff, shift);\n\t}\n\n\tisl_local_space_free(ls);\n\treturn aff;\nerror:\n\tisl_local_space_free(ls);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Given a basic map with output dimensions defined\n * in terms of the parameters input dimensions and earlier\n * output dimensions using an equality (and possibly a pair on inequalities),\n * extract an isl_aff that expresses output dimension \"pos\" in terms\n * of the parameters and input dimensions.\n * Note that this expression may involve integer divisions defined\n * in terms of parameters and input dimensions.\n * \"ma\" contains the expressions corresponding to earlier output dimensions.\n *\n * This function shares some similarities with\n * isl_basic_map_has_defining_equality and isl_constraint_get_bound.\n */\nstatic __isl_give isl_aff *extract_isl_aff_from_basic_map(\n\t__isl_keep isl_basic_map *bmap, int pos, __isl_keep isl_multi_aff *ma)\n{\n\tint eq, div, ineq;\n\tisl_aff *aff;\n\n\tif (!bmap)\n\t\treturn NULL;\n\teq = isl_basic_map_output_defining_equality(bmap, pos, &div, &ineq);\n\tif (eq >= bmap->n_eq)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"unable to find suitable equality\", return NULL);\n\taff = extract_aff_from_equality(bmap, pos, eq, div, ineq, ma);\n\n\taff = isl_aff_remove_unused_divs(aff);\n\treturn aff;\n}\n\n/* Given a basic map where each output dimension is defined\n * in terms of the parameters and input dimensions using an equality,\n * extract an isl_multi_aff that expresses the output dimensions in terms\n * of the parameters and input dimensions.\n */\nstatic __isl_give isl_multi_aff *extract_isl_multi_aff_from_basic_map(\n\t__isl_take isl_basic_map *bmap)\n{\n\tint i;\n\tisl_size n_out;\n\tisl_multi_aff *ma;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tma = isl_multi_aff_alloc(isl_basic_map_get_space(bmap));\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (n_out < 0)\n\t\tma = isl_multi_aff_free(ma);\n\n\tfor (i = 0; i < n_out; ++i) {\n\t\tisl_aff *aff;\n\n\t\taff = extract_isl_aff_from_basic_map(bmap, i, ma);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\n\tisl_basic_map_free(bmap);\n\n\treturn ma;\n}\n\n/* Given a basic set where each set dimension is defined\n * in terms of the parameters using an equality,\n * extract an isl_multi_aff that expresses the set dimensions in terms\n * of the parameters.\n */\n__isl_give isl_multi_aff *isl_multi_aff_from_basic_set_equalities(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn extract_isl_multi_aff_from_basic_map(bset);\n}\n\n/* Create an isl_pw_multi_aff that is equivalent to\n * isl_map_intersect_domain(isl_map_from_basic_map(bmap), domain).\n * The given basic map is such that each output dimension is defined\n * in terms of the parameters and input dimensions using an equality.\n *\n * Since some applications expect the result of isl_pw_multi_aff_from_map\n * to only contain integer affine expressions, we compute the floor\n * of the expression before returning.\n *\n * Remove all constraints involving local variables without\n * an explicit representation (resulting in the removal of those\n * local variables) prior to the actual extraction to ensure\n * that the local spaces in which the resulting affine expressions\n * are created do not contain any unknown local variables.\n * Removing such constraints is safe because constraints involving\n * unknown local variables are not used to determine whether\n * a basic map is obviously single-valued.\n */\nstatic __isl_give isl_pw_multi_aff *plain_pw_multi_aff_from_map(\n\t__isl_take isl_set *domain, __isl_take isl_basic_map *bmap)\n{\n\tisl_multi_aff *ma;\n\n\tbmap = isl_basic_map_drop_constraints_involving_unknown_divs(bmap);\n\tma = extract_isl_multi_aff_from_basic_map(bmap);\n\tma = isl_multi_aff_floor(ma);\n\treturn isl_pw_multi_aff_alloc(domain, ma);\n}\n\n/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.\n * This obviously only works if the input \"map\" is single-valued.\n * If so, we compute the lexicographic minimum of the image in the form\n * of an isl_pw_multi_aff.  Since the image is unique, it is equal\n * to its lexicographic minimum.\n * If the input is not single-valued, we produce an error.\n */\nstatic __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_base(\n\t__isl_take isl_map *map)\n{\n\tint i;\n\tint sv;\n\tisl_pw_multi_aff *pma;\n\n\tsv = isl_map_is_single_valued(map);\n\tif (sv < 0)\n\t\tgoto error;\n\tif (!sv)\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"map is not single-valued\", goto error);\n\tmap = isl_map_make_disjoint(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tpma = isl_pw_multi_aff_empty(isl_map_get_space(map));\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tisl_pw_multi_aff *pma_i;\n\t\tisl_basic_map *bmap;\n\t\tbmap = isl_basic_map_copy(map->p[i]);\n\t\tpma_i = isl_basic_map_lexmin_pw_multi_aff(bmap);\n\t\tpma = isl_pw_multi_aff_add_disjoint(pma, pma_i);\n\t}\n\n\tisl_map_free(map);\n\treturn pma;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map,\n * taking into account that the output dimension at position \"d\"\n * can be represented as\n *\n *\tx = floor((e(...) + c1) / m)\n *\n * given that constraint \"i\" is of the form\n *\n *\te(...) + c1 - m x >= 0\n *\n *\n * Let \"map\" be of the form\n *\n *\tA -> B\n *\n * We construct a mapping\n *\n *\tA -> [A -> x = floor(...)]\n *\n * apply that to the map, obtaining\n *\n *\t[A -> x = floor(...)] -> B\n *\n * and equate dimension \"d\" to x.\n * We then compute a isl_pw_multi_aff representation of the resulting map\n * and plug in the mapping above.\n */\nstatic __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_div(\n\t__isl_take isl_map *map, __isl_take isl_basic_map *hull, int d, int i)\n{\n\tisl_ctx *ctx;\n\tisl_space *space = NULL;\n\tisl_local_space *ls;\n\tisl_multi_aff *ma;\n\tisl_aff *aff;\n\tisl_vec *v;\n\tisl_map *insert;\n\tint offset;\n\tisl_size n;\n\tisl_size n_in;\n\tisl_pw_multi_aff *pma;\n\tisl_bool is_set;\n\n\tis_set = isl_map_is_set(map);\n\tif (is_set < 0)\n\t\tgoto error;\n\n\toffset = isl_basic_map_offset(hull, isl_dim_out);\n\tctx = isl_map_get_ctx(map);\n\tspace = isl_space_domain(isl_map_get_space(map));\n\tn_in = isl_space_dim(space, isl_dim_set);\n\tn = isl_space_dim(space, isl_dim_all);\n\tif (n_in < 0 || n < 0)\n\t\tgoto error;\n\n\tv = isl_vec_alloc(ctx, 1 + 1 + n);\n\tif (v) {\n\t\tisl_int_neg(v->el[0], hull->ineq[i][offset + d]);\n\t\tisl_seq_cpy(v->el + 1, hull->ineq[i], 1 + n);\n\t}\n\tisl_basic_map_free(hull);\n\n\tls = isl_local_space_from_space(isl_space_copy(space));\n\taff = isl_aff_alloc_vec(ls, v);\n\taff = isl_aff_floor(aff);\n\tif (is_set) {\n\t\tisl_space_free(space);\n\t\tma = isl_multi_aff_from_aff(aff);\n\t} else {\n\t\tma = isl_multi_aff_identity(isl_space_map_from_set(space));\n\t\tma = isl_multi_aff_range_product(ma,\n\t\t\t\t\t\tisl_multi_aff_from_aff(aff));\n\t}\n\n\tinsert = isl_map_from_multi_aff_internal(isl_multi_aff_copy(ma));\n\tmap = isl_map_apply_domain(map, insert);\n\tmap = isl_map_equate(map, isl_dim_in, n_in, isl_dim_out, d);\n\tpma = isl_pw_multi_aff_from_map(map);\n\tpma = isl_pw_multi_aff_pullback_multi_aff(pma, ma);\n\n\treturn pma;\nerror:\n\tisl_space_free(space);\n\tisl_map_free(map);\n\tisl_basic_map_free(hull);\n\treturn NULL;\n}\n\n/* Is constraint \"c\" of the form\n *\n *\te(...) + c1 - m x >= 0\n *\n * or\n *\n *\t-e(...) + c2 + m x >= 0\n *\n * where m > 1 and e only depends on parameters and input dimemnsions?\n *\n * \"offset\" is the offset of the output dimensions\n * \"pos\" is the position of output dimension x.\n */\nstatic int is_potential_div_constraint(isl_int *c, int offset, int d, int total)\n{\n\tif (isl_int_is_zero(c[offset + d]))\n\t\treturn 0;\n\tif (isl_int_is_one(c[offset + d]))\n\t\treturn 0;\n\tif (isl_int_is_negone(c[offset + d]))\n\t\treturn 0;\n\tif (isl_seq_first_non_zero(c + offset, d) != -1)\n\t\treturn 0;\n\tif (isl_seq_first_non_zero(c + offset + d + 1,\n\t\t\t\t    total - (offset + d + 1)) != -1)\n\t\treturn 0;\n\treturn 1;\n}\n\n/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.\n *\n * As a special case, we first check if there is any pair of constraints,\n * shared by all the basic maps in \"map\" that force a given dimension\n * to be equal to the floor of some affine combination of the input dimensions.\n *\n * In particular, if we can find two constraints\n *\n *\te(...) + c1 - m x >= 0\t\ti.e.,\t\tm x <= e(...) + c1\n *\n * and\n *\n *\t-e(...) + c2 + m x >= 0\t\ti.e.,\t\tm x >= e(...) - c2\n *\n * where m > 1 and e only depends on parameters and input dimemnsions,\n * and such that\n *\n *\tc1 + c2 < m\t\t\ti.e.,\t\t-c2 >= c1 - (m - 1)\n *\n * then we know that we can take\n *\n *\tx = floor((e(...) + c1) / m)\n *\n * without having to perform any computation.\n *\n * Note that we know that\n *\n *\tc1 + c2 >= 1\n *\n * If c1 + c2 were 0, then we would have detected an equality during\n * simplification.  If c1 + c2 were negative, then we would have detected\n * a contradiction.\n */\nstatic __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_check_div(\n\t__isl_take isl_map *map)\n{\n\tint d;\n\tisl_size dim;\n\tint i, j, n;\n\tint offset;\n\tisl_size total;\n\tisl_int sum;\n\tisl_basic_map *hull;\n\n\thull = isl_map_unshifted_simple_hull(isl_map_copy(map));\n\tdim = isl_map_dim(map, isl_dim_out);\n\ttotal = isl_basic_map_dim(hull, isl_dim_all);\n\tif (dim < 0 || total < 0)\n\t\tgoto error;\n\n\tisl_int_init(sum);\n\toffset = isl_basic_map_offset(hull, isl_dim_out);\n\tn = hull->n_ineq;\n\tfor (d = 0; d < dim; ++d) {\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tif (!is_potential_div_constraint(hull->ineq[i],\n\t\t\t\t\t\t\toffset, d, 1 + total))\n\t\t\t\tcontinue;\n\t\t\tfor (j = i + 1; j < n; ++j) {\n\t\t\t\tif (!isl_seq_is_neg(hull->ineq[i] + 1,\n\t\t\t\t\t\thull->ineq[j] + 1, total))\n\t\t\t\t\tcontinue;\n\t\t\t\tisl_int_add(sum, hull->ineq[i][0],\n\t\t\t\t\t\thull->ineq[j][0]);\n\t\t\t\tif (isl_int_abs_lt(sum,\n\t\t\t\t\t\t    hull->ineq[i][offset + d]))\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tif (j >= n)\n\t\t\t\tcontinue;\n\t\t\tisl_int_clear(sum);\n\t\t\tif (isl_int_is_pos(hull->ineq[j][offset + d]))\n\t\t\t\tj = i;\n\t\t\treturn pw_multi_aff_from_map_div(map, hull, d, j);\n\t\t}\n\t}\n\tisl_int_clear(sum);\n\tisl_basic_map_free(hull);\n\treturn pw_multi_aff_from_map_base(map);\nerror:\n\tisl_map_free(map);\n\tisl_basic_map_free(hull);\n\treturn NULL;\n}\n\n/* Given an affine expression\n *\n *\t[A -> B] -> f(A,B)\n *\n * construct an isl_multi_aff\n *\n *\t[A -> B] -> B'\n *\n * such that dimension \"d\" in B' is set to \"aff\" and the remaining\n * dimensions are set equal to the corresponding dimensions in B.\n * \"n_in\" is the dimension of the space A.\n * \"n_out\" is the dimension of the space B.\n *\n * If \"is_set\" is set, then the affine expression is of the form\n *\n *\t[B] -> f(B)\n *\n * and we construct an isl_multi_aff\n *\n *\tB -> B'\n */\nstatic __isl_give isl_multi_aff *range_map(__isl_take isl_aff *aff, int d,\n\tunsigned n_in, unsigned n_out, int is_set)\n{\n\tint i;\n\tisl_multi_aff *ma;\n\tisl_space *space, *space2;\n\tisl_local_space *ls;\n\n\tspace = isl_aff_get_domain_space(aff);\n\tls = isl_local_space_from_space(isl_space_copy(space));\n\tspace2 = isl_space_copy(space);\n\tif (!is_set)\n\t\tspace2 = isl_space_range(isl_space_unwrap(space2));\n\tspace = isl_space_map_from_domain_and_range(space, space2);\n\tma = isl_multi_aff_alloc(space);\n\tma = isl_multi_aff_set_aff(ma, d, aff);\n\n\tfor (i = 0; i < n_out; ++i) {\n\t\tif (i == d)\n\t\t\tcontinue;\n\t\taff = isl_aff_var_on_domain(isl_local_space_copy(ls),\n\t\t\t\t\t\tisl_dim_set, n_in + i);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\n\tisl_local_space_free(ls);\n\n\treturn ma;\n}\n\n/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map,\n * taking into account that the dimension at position \"d\" can be written as\n *\n *\tx = m a + f(..)\t\t\t\t\t\t(1)\n *\n * where m is equal to \"gcd\".\n * \"i\" is the index of the equality in \"hull\" that defines f(..).\n * In particular, the equality is of the form\n *\n *\tf(..) - x + m g(existentials) = 0\n *\n * or\n *\n *\t-f(..) + x + m g(existentials) = 0\n *\n * We basically plug (1) into \"map\", resulting in a map with \"a\"\n * in the range instead of \"x\".  The corresponding isl_pw_multi_aff\n * defining \"a\" is then plugged back into (1) to obtain a definition for \"x\".\n *\n * Specifically, given the input map\n *\n *\tA -> B\n *\n * We first wrap it into a set\n *\n *\t[A -> B]\n *\n * and define (1) on top of the corresponding space, resulting in \"aff\".\n * We use this to create an isl_multi_aff that maps the output position \"d\"\n * from \"a\" to \"x\", leaving all other (intput and output) dimensions unchanged.\n * We plug this into the wrapped map, unwrap the result and compute the\n * corresponding isl_pw_multi_aff.\n * The result is an expression\n *\n *\tA -> T(A)\n *\n * We adjust that to\n *\n *\tA -> [A -> T(A)]\n *\n * so that we can plug that into \"aff\", after extending the latter to\n * a mapping\n *\n *\t[A -> B] -> B'\n *\n *\n * If \"map\" is actually a set, then there is no \"A\" space, meaning\n * that we do not need to perform any wrapping, and that the result\n * of the recursive call is of the form\n *\n *\t[T]\n *\n * which is plugged into a mapping of the form\n *\n *\tB -> B'\n */\nstatic __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_stride(\n\t__isl_take isl_map *map, __isl_take isl_basic_map *hull, int d, int i,\n\tisl_int gcd)\n{\n\tisl_set *set;\n\tisl_space *space;\n\tisl_local_space *ls;\n\tisl_aff *aff;\n\tisl_multi_aff *ma;\n\tisl_pw_multi_aff *pma, *id;\n\tisl_size n_in;\n\tunsigned o_out;\n\tisl_size n_out;\n\tisl_bool is_set;\n\n\tis_set = isl_map_is_set(map);\n\tif (is_set < 0)\n\t\tgoto error;\n\n\tn_in = isl_basic_map_dim(hull, isl_dim_in);\n\tn_out = isl_basic_map_dim(hull, isl_dim_out);\n\tif (n_in < 0 || n_out < 0)\n\t\tgoto error;\n\to_out = isl_basic_map_offset(hull, isl_dim_out);\n\n\tif (is_set)\n\t\tset = map;\n\telse\n\t\tset = isl_map_wrap(map);\n\tspace = isl_space_map_from_set(isl_set_get_space(set));\n\tma = isl_multi_aff_identity(space);\n\tls = isl_local_space_from_space(isl_set_get_space(set));\n\taff = isl_aff_alloc(ls);\n\tif (aff) {\n\t\tisl_int_set_si(aff->v->el[0], 1);\n\t\tif (isl_int_is_one(hull->eq[i][o_out + d]))\n\t\t\tisl_seq_neg(aff->v->el + 1, hull->eq[i],\n\t\t\t\t    aff->v->size - 1);\n\t\telse\n\t\t\tisl_seq_cpy(aff->v->el + 1, hull->eq[i],\n\t\t\t\t    aff->v->size - 1);\n\t\tisl_int_set(aff->v->el[1 + o_out + d], gcd);\n\t}\n\tma = isl_multi_aff_set_aff(ma, n_in + d, isl_aff_copy(aff));\n\tset = isl_set_preimage_multi_aff(set, ma);\n\n\tma = range_map(aff, d, n_in, n_out, is_set);\n\n\tif (is_set)\n\t\tmap = set;\n\telse\n\t\tmap = isl_set_unwrap(set);\n\tpma = isl_pw_multi_aff_from_map(map);\n\n\tif (!is_set) {\n\t\tspace = isl_pw_multi_aff_get_domain_space(pma);\n\t\tspace = isl_space_map_from_set(space);\n\t\tid = isl_pw_multi_aff_identity(space);\n\t\tpma = isl_pw_multi_aff_range_product(id, pma);\n\t}\n\tid = isl_pw_multi_aff_from_multi_aff(ma);\n\tpma = isl_pw_multi_aff_pullback_pw_multi_aff(id, pma);\n\n\tisl_basic_map_free(hull);\n\treturn pma;\nerror:\n\tisl_map_free(map);\n\tisl_basic_map_free(hull);\n\treturn NULL;\n}\n\n/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.\n * \"hull\" contains the equalities valid for \"map\".\n *\n * Check if any of the output dimensions is \"strided\".\n * That is, we check if it can be written as\n *\n *\tx = m a + f(..)\n *\n * with m greater than 1, a some combination of existentially quantified\n * variables and f an expression in the parameters and input dimensions.\n * If so, we remove the stride in pw_multi_aff_from_map_stride.\n *\n * Otherwise, we continue with pw_multi_aff_from_map_check_div for a further\n * special case.\n */\nstatic __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_check_strides(\n\t__isl_take isl_map *map, __isl_take isl_basic_map *hull)\n{\n\tint i, j;\n\tisl_size n_out;\n\tunsigned o_out;\n\tisl_size n_div;\n\tunsigned o_div;\n\tisl_int gcd;\n\n\tn_div = isl_basic_map_dim(hull, isl_dim_div);\n\tn_out = isl_basic_map_dim(hull, isl_dim_out);\n\tif (n_div < 0 || n_out < 0)\n\t\tgoto error;\n\n\tif (n_div == 0) {\n\t\tisl_basic_map_free(hull);\n\t\treturn pw_multi_aff_from_map_check_div(map);\n\t}\n\n\tisl_int_init(gcd);\n\n\to_div = isl_basic_map_offset(hull, isl_dim_div);\n\to_out = isl_basic_map_offset(hull, isl_dim_out);\n\n\tfor (i = 0; i < n_out; ++i) {\n\t\tfor (j = 0; j < hull->n_eq; ++j) {\n\t\t\tisl_int *eq = hull->eq[j];\n\t\t\tisl_pw_multi_aff *res;\n\n\t\t\tif (!isl_int_is_one(eq[o_out + i]) &&\n\t\t\t    !isl_int_is_negone(eq[o_out + i]))\n\t\t\t\tcontinue;\n\t\t\tif (isl_seq_first_non_zero(eq + o_out, i) != -1)\n\t\t\t\tcontinue;\n\t\t\tif (isl_seq_first_non_zero(eq + o_out + i + 1,\n\t\t\t\t\t\t    n_out - (i + 1)) != -1)\n\t\t\t\tcontinue;\n\t\t\tisl_seq_gcd(eq + o_div, n_div, &gcd);\n\t\t\tif (isl_int_is_zero(gcd))\n\t\t\t\tcontinue;\n\t\t\tif (isl_int_is_one(gcd))\n\t\t\t\tcontinue;\n\n\t\t\tres = pw_multi_aff_from_map_stride(map, hull,\n\t\t\t\t\t\t\t\ti, j, gcd);\n\t\t\tisl_int_clear(gcd);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tisl_int_clear(gcd);\n\tisl_basic_map_free(hull);\n\treturn pw_multi_aff_from_map_check_div(map);\nerror:\n\tisl_map_free(map);\n\tisl_basic_map_free(hull);\n\treturn NULL;\n}\n\n/* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.\n *\n * As a special case, we first check if all output dimensions are uniquely\n * defined in terms of the parameters and input dimensions over the entire\n * domain.  If so, we extract the desired isl_pw_multi_aff directly\n * from the affine hull of \"map\" and its domain.\n *\n * Otherwise, continue with pw_multi_aff_from_map_check_strides for more\n * special cases.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_map(__isl_take isl_map *map)\n{\n\tisl_bool sv;\n\tisl_size n;\n\tisl_basic_map *hull;\n\n\tn = isl_map_n_basic_map(map);\n\tif (n < 0)\n\t\tgoto error;\n\n\tif (n == 1) {\n\t\thull = isl_map_unshifted_simple_hull(isl_map_copy(map));\n\t\thull = isl_basic_map_plain_affine_hull(hull);\n\t\tsv = isl_basic_map_plain_is_single_valued(hull);\n\t\tif (sv >= 0 && sv)\n\t\t\treturn plain_pw_multi_aff_from_map(isl_map_domain(map),\n\t\t\t\t\t\t\t    hull);\n\t\tisl_basic_map_free(hull);\n\t}\n\tmap = isl_map_detect_equalities(map);\n\thull = isl_map_unshifted_simple_hull(isl_map_copy(map));\n\tsv = isl_basic_map_plain_is_single_valued(hull);\n\tif (sv >= 0 && sv)\n\t\treturn plain_pw_multi_aff_from_map(isl_map_domain(map), hull);\n\tif (sv >= 0)\n\t\treturn pw_multi_aff_from_map_check_strides(map, hull);\n\tisl_basic_map_free(hull);\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_set(__isl_take isl_set *set)\n{\n\treturn isl_pw_multi_aff_from_map(set);\n}\n\n/* Convert \"map\" into an isl_pw_multi_aff (if possible) and\n * add it to *user.\n */\nstatic isl_stat pw_multi_aff_from_map(__isl_take isl_map *map, void *user)\n{\n\tisl_union_pw_multi_aff **upma = user;\n\tisl_pw_multi_aff *pma;\n\n\tpma = isl_pw_multi_aff_from_map(map);\n\t*upma = isl_union_pw_multi_aff_add_pw_multi_aff(*upma, pma);\n\n\treturn *upma ? isl_stat_ok : isl_stat_error;\n}\n\n/* Create an isl_union_pw_multi_aff with the given isl_aff on a universe\n * domain.\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_from_aff(\n\t__isl_take isl_aff *aff)\n{\n\tisl_multi_aff *ma;\n\tisl_pw_multi_aff *pma;\n\n\tma = isl_multi_aff_from_aff(aff);\n\tpma = isl_pw_multi_aff_from_multi_aff(ma);\n\treturn isl_union_pw_multi_aff_from_pw_multi_aff(pma);\n}\n\n/* Try and create an isl_union_pw_multi_aff that is equivalent\n * to the given isl_union_map.\n * The isl_union_map is required to be single-valued in each space.\n * Otherwise, an error is produced.\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_from_union_map(\n\t__isl_take isl_union_map *umap)\n{\n\tisl_space *space;\n\tisl_union_pw_multi_aff *upma;\n\n\tspace = isl_union_map_get_space(umap);\n\tupma = isl_union_pw_multi_aff_empty(space);\n\tif (isl_union_map_foreach_map(umap, &pw_multi_aff_from_map, &upma) < 0)\n\t\tupma = isl_union_pw_multi_aff_free(upma);\n\tisl_union_map_free(umap);\n\n\treturn upma;\n}\n\n/* Try and create an isl_union_pw_multi_aff that is equivalent\n * to the given isl_union_set.\n * The isl_union_set is required to be a singleton in each space.\n * Otherwise, an error is produced.\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_from_union_set(\n\t__isl_take isl_union_set *uset)\n{\n\treturn isl_union_pw_multi_aff_from_union_map(uset);\n}\n\n/* Return the piecewise affine expression \"set ? 1 : 0\".\n */\n__isl_give isl_pw_aff *isl_set_indicator_function(__isl_take isl_set *set)\n{\n\tisl_pw_aff *pa;\n\tisl_space *space = isl_set_get_space(set);\n\tisl_local_space *ls = isl_local_space_from_space(space);\n\tisl_aff *zero = isl_aff_zero_on_domain(isl_local_space_copy(ls));\n\tisl_aff *one = isl_aff_zero_on_domain(ls);\n\n\tone = isl_aff_add_constant_si(one, 1);\n\tpa = isl_pw_aff_alloc(isl_set_copy(set), one);\n\tset = isl_set_complement(set);\n\tpa = isl_pw_aff_add_disjoint(pa, isl_pw_aff_alloc(set, zero));\n\n\treturn pa;\n}\n\n/* Plug in \"subs\" for dimension \"type\", \"pos\" of \"aff\".\n *\n * Let i be the dimension to replace and let \"subs\" be of the form\n *\n *\tf/d\n *\n * and \"aff\" of the form\n *\n *\t(a i + g)/m\n *\n * The result is\n *\n *\t(a f + d g')/(m d)\n *\n * where g' is the result of plugging in \"subs\" in each of the integer\n * divisions in g.\n */\n__isl_give isl_aff *isl_aff_substitute(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, unsigned pos, __isl_keep isl_aff *subs)\n{\n\tisl_ctx *ctx;\n\tisl_int v;\n\tisl_size n_div;\n\n\taff = isl_aff_cow(aff);\n\tif (!aff || !subs)\n\t\treturn isl_aff_free(aff);\n\n\tctx = isl_aff_get_ctx(aff);\n\tif (!isl_space_is_equal(aff->ls->dim, subs->ls->dim))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"spaces don't match\", return isl_aff_free(aff));\n\tn_div = isl_aff_domain_dim(subs, isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_aff_free(aff);\n\tif (n_div != 0)\n\t\tisl_die(ctx, isl_error_unsupported,\n\t\t\t\"cannot handle divs yet\", return isl_aff_free(aff));\n\n\taff->ls = isl_local_space_substitute(aff->ls, type, pos, subs);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\taff->v = isl_vec_cow(aff->v);\n\tif (!aff->v)\n\t\treturn isl_aff_free(aff);\n\n\tpos += isl_local_space_offset(aff->ls, type);\n\n\tisl_int_init(v);\n\tisl_seq_substitute(aff->v->el, pos, subs->v->el,\n\t\t\t    aff->v->size, subs->v->size, v);\n\tisl_int_clear(v);\n\n\treturn aff;\n}\n\n/* Plug in \"subs\" for dimension \"type\", \"pos\" in each of the affine\n * expressions in \"maff\".\n */\n__isl_give isl_multi_aff *isl_multi_aff_substitute(\n\t__isl_take isl_multi_aff *maff, enum isl_dim_type type, unsigned pos,\n\t__isl_keep isl_aff *subs)\n{\n\tint i;\n\n\tmaff = isl_multi_aff_cow(maff);\n\tif (!maff || !subs)\n\t\treturn isl_multi_aff_free(maff);\n\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tfor (i = 0; i < maff->n; ++i) {\n\t\tmaff->u.p[i] = isl_aff_substitute(maff->u.p[i],\n\t\t\t\t\t\ttype, pos, subs);\n\t\tif (!maff->u.p[i])\n\t\t\treturn isl_multi_aff_free(maff);\n\t}\n\n\treturn maff;\n}\n\n/* Plug in \"subs\" for dimension \"type\", \"pos\" of \"pma\".\n *\n * pma is of the form\n *\n *\tA_i(v) -> M_i(v)\n *\n * while subs is of the form\n *\n *\tv' = B_j(v) -> S_j\n *\n * Each pair i,j such that C_ij = A_i \\cap B_i is non-empty\n * has a contribution in the result, in particular\n *\n *\tC_ij(S_j) -> M_i(S_j)\n *\n * Note that plugging in S_j in C_ij may also result in an empty set\n * and this contribution should simply be discarded.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_substitute(\n\t__isl_take isl_pw_multi_aff *pma, enum isl_dim_type type, unsigned pos,\n\t__isl_keep isl_pw_aff *subs)\n{\n\tint i, j, n;\n\tisl_pw_multi_aff *res;\n\n\tif (!pma || !subs)\n\t\treturn isl_pw_multi_aff_free(pma);\n\n\tn = pma->n * subs->n;\n\tres = isl_pw_multi_aff_alloc_size(isl_space_copy(pma->dim), n);\n\n\tfor (i = 0; i < pma->n; ++i) {\n\t\tfor (j = 0; j < subs->n; ++j) {\n\t\t\tisl_set *common;\n\t\t\tisl_multi_aff *res_ij;\n\t\t\tint empty;\n\n\t\t\tcommon = isl_set_intersect(\n\t\t\t\t\tisl_set_copy(pma->p[i].set),\n\t\t\t\t\tisl_set_copy(subs->p[j].set));\n\t\t\tcommon = isl_set_substitute(common,\n\t\t\t\t\ttype, pos, subs->p[j].aff);\n\t\t\tempty = isl_set_plain_is_empty(common);\n\t\t\tif (empty < 0 || empty) {\n\t\t\t\tisl_set_free(common);\n\t\t\t\tif (empty < 0)\n\t\t\t\t\tgoto error;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres_ij = isl_multi_aff_substitute(\n\t\t\t\t\tisl_multi_aff_copy(pma->p[i].maff),\n\t\t\t\t\ttype, pos, subs->p[j].aff);\n\n\t\t\tres = isl_pw_multi_aff_add_piece(res, common, res_ij);\n\t\t}\n\t}\n\n\tisl_pw_multi_aff_free(pma);\n\treturn res;\nerror:\n\tisl_pw_multi_aff_free(pma);\n\tisl_pw_multi_aff_free(res);\n\treturn NULL;\n}\n\n/* Compute the preimage of a range of dimensions in the affine expression \"src\"\n * under \"ma\" and put the result in \"dst\".  The number of dimensions in \"src\"\n * that precede the range is given by \"n_before\".  The number of dimensions\n * in the range is given by the number of output dimensions of \"ma\".\n * The number of dimensions that follow the range is given by \"n_after\".\n * If \"has_denom\" is set (to one),\n * then \"src\" and \"dst\" have an extra initial denominator.\n * \"n_div_ma\" is the number of existentials in \"ma\"\n * \"n_div_bset\" is the number of existentials in \"src\"\n * The resulting \"dst\" (which is assumed to have been allocated by\n * the caller) contains coefficients for both sets of existentials,\n * first those in \"ma\" and then those in \"src\".\n * f, c1, c2 and g are temporary objects that have been initialized\n * by the caller.\n *\n * Let src represent the expression\n *\n *\t(a(p) + f_u u + b v + f_w w + c(divs))/d\n *\n * and let ma represent the expressions\n *\n *\tv_i = (r_i(p) + s_i(y) + t_i(divs'))/m_i\n *\n * We start out with the following expression for dst:\n *\n *\t(a(p) + f_u u + 0 y + f_w w + 0 divs' + c(divs) + f \\sum_i b_i v_i)/d\n *\n * with the multiplication factor f initially equal to 1\n * and f \\sum_i b_i v_i kept separately.\n * For each x_i that we substitute, we multiply the numerator\n * (and denominator) of dst by c_1 = m_i and add the numerator\n * of the x_i expression multiplied by c_2 = f b_i,\n * after removing the common factors of c_1 and c_2.\n * The multiplication factor f also needs to be multiplied by c_1\n * for the next x_j, j > i.\n */\nisl_stat isl_seq_preimage(isl_int *dst, isl_int *src,\n\t__isl_keep isl_multi_aff *ma, int n_before, int n_after,\n\tint n_div_ma, int n_div_bmap,\n\tisl_int f, isl_int c1, isl_int c2, isl_int g, int has_denom)\n{\n\tint i;\n\tisl_size n_param, n_in, n_out;\n\tint o_dst, o_src;\n\n\tn_param = isl_multi_aff_dim(ma, isl_dim_param);\n\tn_in = isl_multi_aff_dim(ma, isl_dim_in);\n\tn_out = isl_multi_aff_dim(ma, isl_dim_out);\n\tif (n_param < 0 || n_in < 0 || n_out < 0)\n\t\treturn isl_stat_error;\n\n\tisl_seq_cpy(dst, src, has_denom + 1 + n_param + n_before);\n\to_dst = o_src = has_denom + 1 + n_param + n_before;\n\tisl_seq_clr(dst + o_dst, n_in);\n\to_dst += n_in;\n\to_src += n_out;\n\tisl_seq_cpy(dst + o_dst, src + o_src, n_after);\n\to_dst += n_after;\n\to_src += n_after;\n\tisl_seq_clr(dst + o_dst, n_div_ma);\n\to_dst += n_div_ma;\n\tisl_seq_cpy(dst + o_dst, src + o_src, n_div_bmap);\n\n\tisl_int_set_si(f, 1);\n\n\tfor (i = 0; i < n_out; ++i) {\n\t\tint offset = has_denom + 1 + n_param + n_before + i;\n\n\t\tif (isl_int_is_zero(src[offset]))\n\t\t\tcontinue;\n\t\tisl_int_set(c1, ma->u.p[i]->v->el[0]);\n\t\tisl_int_mul(c2, f, src[offset]);\n\t\tisl_int_gcd(g, c1, c2);\n\t\tisl_int_divexact(c1, c1, g);\n\t\tisl_int_divexact(c2, c2, g);\n\n\t\tisl_int_mul(f, f, c1);\n\t\to_dst = has_denom;\n\t\to_src = 1;\n\t\tisl_seq_combine(dst + o_dst, c1, dst + o_dst,\n\t\t\t\tc2, ma->u.p[i]->v->el + o_src, 1 + n_param);\n\t\to_dst += 1 + n_param;\n\t\to_src += 1 + n_param;\n\t\tisl_seq_scale(dst + o_dst, dst + o_dst, c1, n_before);\n\t\to_dst += n_before;\n\t\tisl_seq_combine(dst + o_dst, c1, dst + o_dst,\n\t\t\t\tc2, ma->u.p[i]->v->el + o_src, n_in);\n\t\to_dst += n_in;\n\t\to_src += n_in;\n\t\tisl_seq_scale(dst + o_dst, dst + o_dst, c1, n_after);\n\t\to_dst += n_after;\n\t\tisl_seq_combine(dst + o_dst, c1, dst + o_dst,\n\t\t\t\tc2, ma->u.p[i]->v->el + o_src, n_div_ma);\n\t\to_dst += n_div_ma;\n\t\to_src += n_div_ma;\n\t\tisl_seq_scale(dst + o_dst, dst + o_dst, c1, n_div_bmap);\n\t\tif (has_denom)\n\t\t\tisl_int_mul(dst[0], dst[0], c1);\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Compute the pullback of \"aff\" by the function represented by \"ma\".\n * In other words, plug in \"ma\" in \"aff\".  The result is an affine expression\n * defined over the domain space of \"ma\".\n *\n * If \"aff\" is represented by\n *\n *\t(a(p) + b x + c(divs))/d\n *\n * and ma is represented by\n *\n *\tx = D(p) + F(y) + G(divs')\n *\n * then the result is\n *\n *\t(a(p) + b D(p) + b F(y) + b G(divs') + c(divs))/d\n *\n * The divs in the local space of the input are similarly adjusted\n * through a call to isl_local_space_preimage_multi_aff.\n */\n__isl_give isl_aff *isl_aff_pullback_multi_aff(__isl_take isl_aff *aff,\n\t__isl_take isl_multi_aff *ma)\n{\n\tisl_aff *res = NULL;\n\tisl_local_space *ls;\n\tisl_size n_div_aff, n_div_ma;\n\tisl_int f, c1, c2, g;\n\n\tma = isl_multi_aff_align_divs(ma);\n\tif (!aff || !ma)\n\t\tgoto error;\n\n\tn_div_aff = isl_aff_dim(aff, isl_dim_div);\n\tn_div_ma = ma->n ? isl_aff_dim(ma->u.p[0], isl_dim_div) : 0;\n\tif (n_div_aff < 0 || n_div_ma < 0)\n\t\tgoto error;\n\n\tls = isl_aff_get_domain_local_space(aff);\n\tls = isl_local_space_preimage_multi_aff(ls, isl_multi_aff_copy(ma));\n\tres = isl_aff_alloc(ls);\n\tif (!res)\n\t\tgoto error;\n\n\tisl_int_init(f);\n\tisl_int_init(c1);\n\tisl_int_init(c2);\n\tisl_int_init(g);\n\n\tif (isl_seq_preimage(res->v->el, aff->v->el, ma, 0, 0,\n\t\t\t    n_div_ma, n_div_aff, f, c1, c2, g, 1) < 0)\n\t\tres = isl_aff_free(res);\n\n\tisl_int_clear(f);\n\tisl_int_clear(c1);\n\tisl_int_clear(c2);\n\tisl_int_clear(g);\n\n\tisl_aff_free(aff);\n\tisl_multi_aff_free(ma);\n\tres = isl_aff_normalize(res);\n\treturn res;\nerror:\n\tisl_aff_free(aff);\n\tisl_multi_aff_free(ma);\n\tisl_aff_free(res);\n\treturn NULL;\n}\n\n/* Compute the pullback of \"aff1\" by the function represented by \"aff2\".\n * In other words, plug in \"aff2\" in \"aff1\".  The result is an affine expression\n * defined over the domain space of \"aff1\".\n *\n * The domain of \"aff1\" should match the range of \"aff2\", which means\n * that it should be single-dimensional.\n */\n__isl_give isl_aff *isl_aff_pullback_aff(__isl_take isl_aff *aff1,\n\t__isl_take isl_aff *aff2)\n{\n\tisl_multi_aff *ma;\n\n\tma = isl_multi_aff_from_aff(aff2);\n\treturn isl_aff_pullback_multi_aff(aff1, ma);\n}\n\n/* Compute the pullback of \"ma1\" by the function represented by \"ma2\".\n * In other words, plug in \"ma2\" in \"ma1\".\n */\n__isl_give isl_multi_aff *isl_multi_aff_pullback_multi_aff(\n\t__isl_take isl_multi_aff *ma1, __isl_take isl_multi_aff *ma2)\n{\n\tint i;\n\tisl_space *space = NULL;\n\n\tisl_multi_aff_align_params_bin(&ma1, &ma2);\n\tma2 = isl_multi_aff_align_divs(ma2);\n\tma1 = isl_multi_aff_cow(ma1);\n\tif (!ma1 || !ma2)\n\t\tgoto error;\n\n\tspace = isl_space_join(isl_multi_aff_get_space(ma2),\n\t\t\t\tisl_multi_aff_get_space(ma1));\n\n\tfor (i = 0; i < ma1->n; ++i) {\n\t\tma1->u.p[i] = isl_aff_pullback_multi_aff(ma1->u.p[i],\n\t\t\t\t\t\t    isl_multi_aff_copy(ma2));\n\t\tif (!ma1->u.p[i])\n\t\t\tgoto error;\n\t}\n\n\tma1 = isl_multi_aff_reset_space(ma1, space);\n\tisl_multi_aff_free(ma2);\n\treturn ma1;\nerror:\n\tisl_space_free(space);\n\tisl_multi_aff_free(ma2);\n\tisl_multi_aff_free(ma1);\n\treturn NULL;\n}\n\n/* Extend the local space of \"dst\" to include the divs\n * in the local space of \"src\".\n *\n * If \"src\" does not have any divs or if the local spaces of \"dst\" and\n * \"src\" are the same, then no extension is required.\n */\n__isl_give isl_aff *isl_aff_align_divs(__isl_take isl_aff *dst,\n\t__isl_keep isl_aff *src)\n{\n\tisl_ctx *ctx;\n\tisl_size src_n_div, dst_n_div;\n\tint *exp1 = NULL;\n\tint *exp2 = NULL;\n\tisl_bool equal;\n\tisl_mat *div;\n\n\tif (!src || !dst)\n\t\treturn isl_aff_free(dst);\n\n\tctx = isl_aff_get_ctx(src);\n\tequal = isl_local_space_has_equal_space(src->ls, dst->ls);\n\tif (equal < 0)\n\t\treturn isl_aff_free(dst);\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\n\tsrc_n_div = isl_aff_domain_dim(src, isl_dim_div);\n\tdst_n_div = isl_aff_domain_dim(dst, isl_dim_div);\n\tif (src_n_div == 0)\n\t\treturn dst;\n\tequal = isl_local_space_is_equal(src->ls, dst->ls);\n\tif (equal < 0 || src_n_div < 0 || dst_n_div < 0)\n\t\treturn isl_aff_free(dst);\n\tif (equal)\n\t\treturn dst;\n\n\texp1 = isl_alloc_array(ctx, int, src_n_div);\n\texp2 = isl_alloc_array(ctx, int, dst_n_div);\n\tif (!exp1 || (dst_n_div && !exp2))\n\t\tgoto error;\n\n\tdiv = isl_merge_divs(src->ls->div, dst->ls->div, exp1, exp2);\n\tdst = isl_aff_expand_divs(dst, div, exp2);\n\tfree(exp1);\n\tfree(exp2);\n\n\treturn dst;\nerror:\n\tfree(exp1);\n\tfree(exp2);\n\treturn isl_aff_free(dst);\n}\n\n/* Adjust the local spaces of the affine expressions in \"maff\"\n * such that they all have the save divs.\n */\n__isl_give isl_multi_aff *isl_multi_aff_align_divs(\n\t__isl_take isl_multi_aff *maff)\n{\n\tint i;\n\n\tif (!maff)\n\t\treturn NULL;\n\tif (maff->n == 0)\n\t\treturn maff;\n\tmaff = isl_multi_aff_cow(maff);\n\tif (!maff)\n\t\treturn NULL;\n\n\tfor (i = 1; i < maff->n; ++i)\n\t\tmaff->u.p[0] = isl_aff_align_divs(maff->u.p[0], maff->u.p[i]);\n\tfor (i = 1; i < maff->n; ++i) {\n\t\tmaff->u.p[i] = isl_aff_align_divs(maff->u.p[i], maff->u.p[0]);\n\t\tif (!maff->u.p[i])\n\t\t\treturn isl_multi_aff_free(maff);\n\t}\n\n\treturn maff;\n}\n\n__isl_give isl_aff *isl_aff_lift(__isl_take isl_aff *aff)\n{\n\taff = isl_aff_cow(aff);\n\tif (!aff)\n\t\treturn NULL;\n\n\taff->ls = isl_local_space_lift(aff->ls);\n\tif (!aff->ls)\n\t\treturn isl_aff_free(aff);\n\n\treturn aff;\n}\n\n/* Lift \"maff\" to a space with extra dimensions such that the result\n * has no more existentially quantified variables.\n * If \"ls\" is not NULL, then *ls is assigned the local space that lies\n * at the basis of the lifting applied to \"maff\".\n */\n__isl_give isl_multi_aff *isl_multi_aff_lift(__isl_take isl_multi_aff *maff,\n\t__isl_give isl_local_space **ls)\n{\n\tint i;\n\tisl_space *space;\n\tisl_size n_div;\n\n\tif (ls)\n\t\t*ls = NULL;\n\n\tif (!maff)\n\t\treturn NULL;\n\n\tif (maff->n == 0) {\n\t\tif (ls) {\n\t\t\tisl_space *space = isl_multi_aff_get_domain_space(maff);\n\t\t\t*ls = isl_local_space_from_space(space);\n\t\t\tif (!*ls)\n\t\t\t\treturn isl_multi_aff_free(maff);\n\t\t}\n\t\treturn maff;\n\t}\n\n\tmaff = isl_multi_aff_cow(maff);\n\tmaff = isl_multi_aff_align_divs(maff);\n\tif (!maff)\n\t\treturn NULL;\n\n\tn_div = isl_aff_dim(maff->u.p[0], isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_multi_aff_free(maff);\n\tspace = isl_multi_aff_get_space(maff);\n\tspace = isl_space_lift(isl_space_domain(space), n_div);\n\tspace = isl_space_extend_domain_with_range(space,\n\t\t\t\t\t\tisl_multi_aff_get_space(maff));\n\tif (!space)\n\t\treturn isl_multi_aff_free(maff);\n\tisl_space_free(maff->space);\n\tmaff->space = space;\n\n\tif (ls) {\n\t\t*ls = isl_aff_get_domain_local_space(maff->u.p[0]);\n\t\tif (!*ls)\n\t\t\treturn isl_multi_aff_free(maff);\n\t}\n\n\tfor (i = 0; i < maff->n; ++i) {\n\t\tmaff->u.p[i] = isl_aff_lift(maff->u.p[i]);\n\t\tif (!maff->u.p[i])\n\t\t\tgoto error;\n\t}\n\n\treturn maff;\nerror:\n\tif (ls)\n\t\tisl_local_space_free(*ls);\n\treturn isl_multi_aff_free(maff);\n}\n\n#undef TYPE\n#define TYPE\tisl_pw_multi_aff\nstatic\n#include \"check_type_range_templ.c\"\n\n/* Extract an isl_pw_aff corresponding to output dimension \"pos\" of \"pma\".\n */\n__isl_give isl_pw_aff *isl_pw_multi_aff_get_pw_aff(\n\t__isl_keep isl_pw_multi_aff *pma, int pos)\n{\n\tint i;\n\tisl_size n_out;\n\tisl_space *space;\n\tisl_pw_aff *pa;\n\n\tif (isl_pw_multi_aff_check_range(pma, isl_dim_out, pos, 1) < 0)\n\t\treturn NULL;\n\n\tn_out = isl_pw_multi_aff_dim(pma, isl_dim_out);\n\tif (n_out < 0)\n\t\treturn NULL;\n\n\tspace = isl_pw_multi_aff_get_space(pma);\n\tspace = isl_space_drop_dims(space, isl_dim_out,\n\t\t\t\t    pos + 1, n_out - pos - 1);\n\tspace = isl_space_drop_dims(space, isl_dim_out, 0, pos);\n\n\tpa = isl_pw_aff_alloc_size(space, pma->n);\n\tfor (i = 0; i < pma->n; ++i) {\n\t\tisl_aff *aff;\n\t\taff = isl_multi_aff_get_aff(pma->p[i].maff, pos);\n\t\tpa = isl_pw_aff_add_piece(pa, isl_set_copy(pma->p[i].set), aff);\n\t}\n\n\treturn pa;\n}\n\n/* Return an isl_pw_multi_aff with the given \"set\" as domain and\n * an unnamed zero-dimensional range.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_domain(\n\t__isl_take isl_set *set)\n{\n\tisl_multi_aff *ma;\n\tisl_space *space;\n\n\tspace = isl_set_get_space(set);\n\tspace = isl_space_from_domain(space);\n\tma = isl_multi_aff_zero(space);\n\treturn isl_pw_multi_aff_alloc(set, ma);\n}\n\n/* Add an isl_pw_multi_aff with the given \"set\" as domain and\n * an unnamed zero-dimensional range to *user.\n */\nstatic isl_stat add_pw_multi_aff_from_domain(__isl_take isl_set *set,\n\tvoid *user)\n{\n\tisl_union_pw_multi_aff **upma = user;\n\tisl_pw_multi_aff *pma;\n\n\tpma = isl_pw_multi_aff_from_domain(set);\n\t*upma = isl_union_pw_multi_aff_add_pw_multi_aff(*upma, pma);\n\n\treturn isl_stat_ok;\n}\n\n/* Return an isl_union_pw_multi_aff with the given \"uset\" as domain and\n * an unnamed zero-dimensional range.\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_from_domain(\n\t__isl_take isl_union_set *uset)\n{\n\tisl_space *space;\n\tisl_union_pw_multi_aff *upma;\n\n\tif (!uset)\n\t\treturn NULL;\n\n\tspace = isl_union_set_get_space(uset);\n\tupma = isl_union_pw_multi_aff_empty(space);\n\n\tif (isl_union_set_foreach_set(uset,\n\t\t\t\t    &add_pw_multi_aff_from_domain, &upma) < 0)\n\t\tgoto error;\n\n\tisl_union_set_free(uset);\n\treturn upma;\nerror:\n\tisl_union_set_free(uset);\n\tisl_union_pw_multi_aff_free(upma);\n\treturn NULL;\n}\n\n/* Local data for bin_entry and the callback \"fn\".\n */\nstruct isl_union_pw_multi_aff_bin_data {\n\tisl_union_pw_multi_aff *upma2;\n\tisl_union_pw_multi_aff *res;\n\tisl_pw_multi_aff *pma;\n\tisl_stat (*fn)(__isl_take isl_pw_multi_aff *pma, void *user);\n};\n\n/* Given an isl_pw_multi_aff from upma1, store it in data->pma\n * and call data->fn for each isl_pw_multi_aff in data->upma2.\n */\nstatic isl_stat bin_entry(__isl_take isl_pw_multi_aff *pma, void *user)\n{\n\tstruct isl_union_pw_multi_aff_bin_data *data = user;\n\tisl_stat r;\n\n\tdata->pma = pma;\n\tr = isl_union_pw_multi_aff_foreach_pw_multi_aff(data->upma2,\n\t\t\t\t   data->fn, data);\n\tisl_pw_multi_aff_free(pma);\n\n\treturn r;\n}\n\n/* Call \"fn\" on each pair of isl_pw_multi_affs in \"upma1\" and \"upma2\".\n * The isl_pw_multi_aff from upma1 is stored in data->pma (where data is\n * passed as user field) and the isl_pw_multi_aff from upma2 is available\n * as *entry.  The callback should adjust data->res if desired.\n */\nstatic __isl_give isl_union_pw_multi_aff *bin_op(\n\t__isl_take isl_union_pw_multi_aff *upma1,\n\t__isl_take isl_union_pw_multi_aff *upma2,\n\tisl_stat (*fn)(__isl_take isl_pw_multi_aff *pma, void *user))\n{\n\tisl_space *space;\n\tstruct isl_union_pw_multi_aff_bin_data data = { NULL, NULL, NULL, fn };\n\n\tspace = isl_union_pw_multi_aff_get_space(upma2);\n\tupma1 = isl_union_pw_multi_aff_align_params(upma1, space);\n\tspace = isl_union_pw_multi_aff_get_space(upma1);\n\tupma2 = isl_union_pw_multi_aff_align_params(upma2, space);\n\n\tif (!upma1 || !upma2)\n\t\tgoto error;\n\n\tdata.upma2 = upma2;\n\tdata.res = isl_union_pw_multi_aff_alloc_same_size(upma1);\n\tif (isl_union_pw_multi_aff_foreach_pw_multi_aff(upma1,\n\t\t\t\t   &bin_entry, &data) < 0)\n\t\tgoto error;\n\n\tisl_union_pw_multi_aff_free(upma1);\n\tisl_union_pw_multi_aff_free(upma2);\n\treturn data.res;\nerror:\n\tisl_union_pw_multi_aff_free(upma1);\n\tisl_union_pw_multi_aff_free(upma2);\n\tisl_union_pw_multi_aff_free(data.res);\n\treturn NULL;\n}\n\n/* Given two isl_pw_multi_affs A -> B and C -> D,\n * construct an isl_pw_multi_aff (A * C) -> [B -> D].\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_range_product(\n\t__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2)\n{\n\tisl_space *space;\n\n\tisl_pw_multi_aff_align_params_bin(&pma1, &pma2);\n\tspace = isl_space_range_product(isl_pw_multi_aff_get_space(pma1),\n\t\t\t\t\tisl_pw_multi_aff_get_space(pma2));\n\treturn isl_pw_multi_aff_on_shared_domain_in(pma1, pma2, space,\n\t\t\t\t\t    &isl_multi_aff_range_product);\n}\n\n/* Given two isl_pw_multi_affs A -> B and C -> D,\n * construct an isl_pw_multi_aff (A * C) -> (B, D).\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_flat_range_product(\n\t__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2)\n{\n\tisl_space *space;\n\n\tisl_pw_multi_aff_align_params_bin(&pma1, &pma2);\n\tspace = isl_space_range_product(isl_pw_multi_aff_get_space(pma1),\n\t\t\t\t\tisl_pw_multi_aff_get_space(pma2));\n\tspace = isl_space_flatten_range(space);\n\treturn isl_pw_multi_aff_on_shared_domain_in(pma1, pma2, space,\n\t\t\t\t\t    &isl_multi_aff_flat_range_product);\n}\n\n/* If data->pma and \"pma2\" have the same domain space, then use \"range_product\"\n * to compute some form of range product and add the result to data->res.\n */\nstatic isl_stat gen_range_product_entry(__isl_take isl_pw_multi_aff *pma2,\n\t__isl_give isl_pw_multi_aff *(*range_product)(\n\t\t__isl_take isl_pw_multi_aff *pma1,\n\t\t__isl_take isl_pw_multi_aff *pma2),\n\tvoid *user)\n{\n\tstruct isl_union_pw_multi_aff_bin_data *data = user;\n\tisl_bool match;\n\tisl_space *space1, *space2;\n\n\tspace1 = isl_pw_multi_aff_peek_space(data->pma);\n\tspace2 = isl_pw_multi_aff_peek_space(pma2);\n\tmatch = isl_space_tuple_is_equal(space1, isl_dim_in,\n\t\t\t\t\tspace2, isl_dim_in);\n\tif (match < 0 || !match) {\n\t\tisl_pw_multi_aff_free(pma2);\n\t\treturn match < 0 ? isl_stat_error : isl_stat_ok;\n\t}\n\n\tpma2 = range_product(isl_pw_multi_aff_copy(data->pma), pma2);\n\n\tdata->res = isl_union_pw_multi_aff_add_pw_multi_aff(data->res, pma2);\n\n\treturn isl_stat_ok;\n}\n\n/* If data->pma and \"pma2\" have the same domain space, then compute\n * their flat range product and add the result to data->res.\n */\nstatic isl_stat flat_range_product_entry(__isl_take isl_pw_multi_aff *pma2,\n\tvoid *user)\n{\n\treturn gen_range_product_entry(pma2,\n\t\t\t\t&isl_pw_multi_aff_flat_range_product, user);\n}\n\n/* Given two isl_union_pw_multi_affs A -> B and C -> D,\n * construct an isl_union_pw_multi_aff (A * C) -> (B, D).\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_flat_range_product(\n\t__isl_take isl_union_pw_multi_aff *upma1,\n\t__isl_take isl_union_pw_multi_aff *upma2)\n{\n\treturn bin_op(upma1, upma2, &flat_range_product_entry);\n}\n\n/* If data->pma and \"pma2\" have the same domain space, then compute\n * their range product and add the result to data->res.\n */\nstatic isl_stat range_product_entry(__isl_take isl_pw_multi_aff *pma2,\n\tvoid *user)\n{\n\treturn gen_range_product_entry(pma2,\n\t\t\t\t&isl_pw_multi_aff_range_product, user);\n}\n\n/* Given two isl_union_pw_multi_affs A -> B and C -> D,\n * construct an isl_union_pw_multi_aff (A * C) -> [B -> D].\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_range_product(\n\t__isl_take isl_union_pw_multi_aff *upma1,\n\t__isl_take isl_union_pw_multi_aff *upma2)\n{\n\treturn bin_op(upma1, upma2, &range_product_entry);\n}\n\n/* Replace the affine expressions at position \"pos\" in \"pma\" by \"pa\".\n * The parameters are assumed to have been aligned.\n *\n * The implementation essentially performs an isl_pw_*_on_shared_domain,\n * except that it works on two different isl_pw_* types.\n */\nstatic __isl_give isl_pw_multi_aff *pw_multi_aff_set_pw_aff(\n\t__isl_take isl_pw_multi_aff *pma, unsigned pos,\n\t__isl_take isl_pw_aff *pa)\n{\n\tint i, j, n;\n\tisl_pw_multi_aff *res = NULL;\n\n\tif (!pma || !pa)\n\t\tgoto error;\n\n\tif (!isl_space_tuple_is_equal(pma->dim, isl_dim_in,\n\t\t\t\t\tpa->dim, isl_dim_in))\n\t\tisl_die(isl_pw_multi_aff_get_ctx(pma), isl_error_invalid,\n\t\t\t\"domains don't match\", goto error);\n\tif (isl_pw_multi_aff_check_range(pma, isl_dim_out, pos, 1) < 0)\n\t\tgoto error;\n\n\tn = pma->n * pa->n;\n\tres = isl_pw_multi_aff_alloc_size(isl_pw_multi_aff_get_space(pma), n);\n\n\tfor (i = 0; i < pma->n; ++i) {\n\t\tfor (j = 0; j < pa->n; ++j) {\n\t\t\tisl_set *common;\n\t\t\tisl_multi_aff *res_ij;\n\t\t\tint empty;\n\n\t\t\tcommon = isl_set_intersect(isl_set_copy(pma->p[i].set),\n\t\t\t\t\t\t   isl_set_copy(pa->p[j].set));\n\t\t\tempty = isl_set_plain_is_empty(common);\n\t\t\tif (empty < 0 || empty) {\n\t\t\t\tisl_set_free(common);\n\t\t\t\tif (empty < 0)\n\t\t\t\t\tgoto error;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres_ij = isl_multi_aff_set_aff(\n\t\t\t\t\tisl_multi_aff_copy(pma->p[i].maff), pos,\n\t\t\t\t\tisl_aff_copy(pa->p[j].aff));\n\t\t\tres_ij = isl_multi_aff_gist(res_ij,\n\t\t\t\t\tisl_set_copy(common));\n\n\t\t\tres = isl_pw_multi_aff_add_piece(res, common, res_ij);\n\t\t}\n\t}\n\n\tisl_pw_multi_aff_free(pma);\n\tisl_pw_aff_free(pa);\n\treturn res;\nerror:\n\tisl_pw_multi_aff_free(pma);\n\tisl_pw_aff_free(pa);\n\treturn isl_pw_multi_aff_free(res);\n}\n\n/* Replace the affine expressions at position \"pos\" in \"pma\" by \"pa\".\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_set_pw_aff(\n\t__isl_take isl_pw_multi_aff *pma, unsigned pos,\n\t__isl_take isl_pw_aff *pa)\n{\n\tisl_bool equal_params;\n\n\tif (!pma || !pa)\n\t\tgoto error;\n\tequal_params = isl_space_has_equal_params(pma->dim, pa->dim);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (equal_params)\n\t\treturn pw_multi_aff_set_pw_aff(pma, pos, pa);\n\tif (isl_pw_multi_aff_check_named_params(pma) < 0 ||\n\t    isl_pw_aff_check_named_params(pa) < 0)\n\t\tgoto error;\n\tpma = isl_pw_multi_aff_align_params(pma, isl_pw_aff_get_space(pa));\n\tpa = isl_pw_aff_align_params(pa, isl_pw_multi_aff_get_space(pma));\n\treturn pw_multi_aff_set_pw_aff(pma, pos, pa);\nerror:\n\tisl_pw_multi_aff_free(pma);\n\tisl_pw_aff_free(pa);\n\treturn NULL;\n}\n\n/* Do the parameters of \"pa\" match those of \"space\"?\n */\nisl_bool isl_pw_aff_matching_params(__isl_keep isl_pw_aff *pa,\n\t__isl_keep isl_space *space)\n{\n\tisl_space *pa_space;\n\tisl_bool match;\n\n\tif (!pa || !space)\n\t\treturn isl_bool_error;\n\n\tpa_space = isl_pw_aff_get_space(pa);\n\n\tmatch = isl_space_has_equal_params(space, pa_space);\n\n\tisl_space_free(pa_space);\n\treturn match;\n}\n\n/* Check that the domain space of \"pa\" matches \"space\".\n */\nisl_stat isl_pw_aff_check_match_domain_space(__isl_keep isl_pw_aff *pa,\n\t__isl_keep isl_space *space)\n{\n\tisl_space *pa_space;\n\tisl_bool match;\n\n\tif (!pa || !space)\n\t\treturn isl_stat_error;\n\n\tpa_space = isl_pw_aff_get_space(pa);\n\n\tmatch = isl_space_has_equal_params(space, pa_space);\n\tif (match < 0)\n\t\tgoto error;\n\tif (!match)\n\t\tisl_die(isl_pw_aff_get_ctx(pa), isl_error_invalid,\n\t\t\t\"parameters don't match\", goto error);\n\tmatch = isl_space_tuple_is_equal(space, isl_dim_in,\n\t\t\t\t\tpa_space, isl_dim_in);\n\tif (match < 0)\n\t\tgoto error;\n\tif (!match)\n\t\tisl_die(isl_pw_aff_get_ctx(pa), isl_error_invalid,\n\t\t\t\"domains don't match\", goto error);\n\tisl_space_free(pa_space);\n\treturn isl_stat_ok;\nerror:\n\tisl_space_free(pa_space);\n\treturn isl_stat_error;\n}\n\n#undef BASE\n#define BASE pw_aff\n#undef DOMBASE\n#define DOMBASE set\n\n#include <isl_multi_explicit_domain.c>\n#include <isl_multi_pw_aff_explicit_domain.c>\n#include <isl_multi_templ.c>\n#include <isl_multi_add_constant_templ.c>\n#include <isl_multi_apply_set.c>\n#include <isl_multi_arith_templ.c>\n#include <isl_multi_bind_templ.c>\n#include <isl_multi_bind_domain_templ.c>\n#include <isl_multi_coalesce.c>\n#include <isl_multi_domain_templ.c>\n#include <isl_multi_dim_id_templ.c>\n#include <isl_multi_dims.c>\n#include <isl_multi_from_base_templ.c>\n#include <isl_multi_gist.c>\n#include <isl_multi_hash.c>\n#include <isl_multi_identity_templ.c>\n#include <isl_multi_align_set.c>\n#include <isl_multi_insert_domain_templ.c>\n#include <isl_multi_intersect.c>\n#include <isl_multi_min_max_templ.c>\n#include <isl_multi_move_dims_templ.c>\n#include <isl_multi_nan_templ.c>\n#include <isl_multi_param_templ.c>\n#include <isl_multi_product_templ.c>\n#include <isl_multi_splice_templ.c>\n#include <isl_multi_tuple_id_templ.c>\n#include <isl_multi_union_add_templ.c>\n#include <isl_multi_zero_templ.c>\n#include <isl_multi_unbind_params_templ.c>\n\n/* If \"mpa\" has an explicit domain, then intersect the domain of \"map\"\n * with this explicit domain.\n */\n__isl_give isl_map *isl_map_intersect_multi_pw_aff_explicit_domain(\n\t__isl_take isl_map *map, __isl_keep isl_multi_pw_aff *mpa)\n{\n\tisl_set *dom;\n\n\tif (!isl_multi_pw_aff_has_explicit_domain(mpa))\n\t\treturn map;\n\n\tdom = isl_multi_pw_aff_domain(isl_multi_pw_aff_copy(mpa));\n\tmap = isl_map_intersect_domain(map, dom);\n\n\treturn map;\n}\n\n/* Are all elements of \"mpa\" piecewise constants?\n */\nisl_bool isl_multi_pw_aff_is_cst(__isl_keep isl_multi_pw_aff *mpa)\n{\n\treturn isl_multi_pw_aff_every(mpa, &isl_pw_aff_is_cst);\n}\n\n/* Does \"mpa\" have a non-trivial explicit domain?\n *\n * The explicit domain, if present, is trivial if it represents\n * an (obviously) universe set.\n */\nisl_bool isl_multi_pw_aff_has_non_trivial_domain(\n\t__isl_keep isl_multi_pw_aff *mpa)\n{\n\tif (!mpa)\n\t\treturn isl_bool_error;\n\tif (!isl_multi_pw_aff_has_explicit_domain(mpa))\n\t\treturn isl_bool_false;\n\treturn isl_bool_not(isl_set_plain_is_universe(mpa->u.dom));\n}\n\n#undef BASE\n#define BASE\tset\n\n#include \"isl_opt_mpa_templ.c\"\n\n/* Compute the minima of the set dimensions as a function of the\n * parameters, but independently of the other set dimensions.\n */\n__isl_give isl_multi_pw_aff *isl_set_min_multi_pw_aff(__isl_take isl_set *set)\n{\n\treturn set_opt_mpa(set, &isl_set_dim_min);\n}\n\n/* Compute the maxima of the set dimensions as a function of the\n * parameters, but independently of the other set dimensions.\n */\n__isl_give isl_multi_pw_aff *isl_set_max_multi_pw_aff(__isl_take isl_set *set)\n{\n\treturn set_opt_mpa(set, &isl_set_dim_max);\n}\n\n#undef BASE\n#define BASE\tmap\n\n#include \"isl_opt_mpa_templ.c\"\n\n/* Compute the minima of the output dimensions as a function of the\n * parameters and input dimensions, but independently of\n * the other output dimensions.\n */\n__isl_give isl_multi_pw_aff *isl_map_min_multi_pw_aff(__isl_take isl_map *map)\n{\n\treturn map_opt_mpa(map, &isl_map_dim_min);\n}\n\n/* Compute the maxima of the output dimensions as a function of the\n * parameters and input dimensions, but independently of\n * the other output dimensions.\n */\n__isl_give isl_multi_pw_aff *isl_map_max_multi_pw_aff(__isl_take isl_map *map)\n{\n\treturn map_opt_mpa(map, &isl_map_dim_max);\n}\n\n/* Scale the elements of \"pma\" by the corresponding elements of \"mv\".\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_scale_multi_val(\n\t__isl_take isl_pw_multi_aff *pma, __isl_take isl_multi_val *mv)\n{\n\tint i;\n\tisl_bool equal_params;\n\n\tpma = isl_pw_multi_aff_cow(pma);\n\tif (!pma || !mv)\n\t\tgoto error;\n\tif (!isl_space_tuple_is_equal(pma->dim, isl_dim_out,\n\t\t\t\t\tmv->space, isl_dim_set))\n\t\tisl_die(isl_pw_multi_aff_get_ctx(pma), isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\tequal_params = isl_space_has_equal_params(pma->dim, mv->space);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (!equal_params) {\n\t\tpma = isl_pw_multi_aff_align_params(pma,\n\t\t\t\t\t    isl_multi_val_get_space(mv));\n\t\tmv = isl_multi_val_align_params(mv,\n\t\t\t\t\t    isl_pw_multi_aff_get_space(pma));\n\t\tif (!pma || !mv)\n\t\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < pma->n; ++i) {\n\t\tpma->p[i].maff = isl_multi_aff_scale_multi_val(pma->p[i].maff,\n\t\t\t\t\t\t\tisl_multi_val_copy(mv));\n\t\tif (!pma->p[i].maff)\n\t\t\tgoto error;\n\t}\n\n\tisl_multi_val_free(mv);\n\treturn pma;\nerror:\n\tisl_multi_val_free(mv);\n\tisl_pw_multi_aff_free(pma);\n\treturn NULL;\n}\n\n/* This function is called for each entry of an isl_union_pw_multi_aff.\n * If the space of the entry matches that of data->mv,\n * then apply isl_pw_multi_aff_scale_multi_val and return the result.\n * Otherwise, return an empty isl_pw_multi_aff.\n */\nstatic __isl_give isl_pw_multi_aff *union_pw_multi_aff_scale_multi_val_entry(\n\t__isl_take isl_pw_multi_aff *pma, void *user)\n{\n\tisl_multi_val *mv = user;\n\n\tif (!pma)\n\t\treturn NULL;\n\tif (!isl_space_tuple_is_equal(pma->dim, isl_dim_out,\n\t\t\t\t    mv->space, isl_dim_set)) {\n\t\tisl_space *space = isl_pw_multi_aff_get_space(pma);\n\t\tisl_pw_multi_aff_free(pma);\n\t\treturn isl_pw_multi_aff_empty(space);\n\t}\n\n\treturn isl_pw_multi_aff_scale_multi_val(pma, isl_multi_val_copy(mv));\n}\n\n/* Scale the elements of \"upma\" by the corresponding elements of \"mv\",\n * for those entries that match the space of \"mv\".\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_scale_multi_val(\n\t__isl_take isl_union_pw_multi_aff *upma, __isl_take isl_multi_val *mv)\n{\n\tstruct isl_union_pw_multi_aff_transform_control control = {\n\t\t.fn = &union_pw_multi_aff_scale_multi_val_entry,\n\t\t.fn_user = mv,\n\t};\n\n\tupma = isl_union_pw_multi_aff_align_params(upma,\n\t\t\t\t\t\tisl_multi_val_get_space(mv));\n\tmv = isl_multi_val_align_params(mv,\n\t\t\t\t\tisl_union_pw_multi_aff_get_space(upma));\n\tif (!upma || !mv)\n\t\tgoto error;\n\n\treturn isl_union_pw_multi_aff_transform(upma, &control);\n\n\tisl_multi_val_free(mv);\n\treturn upma;\nerror:\n\tisl_multi_val_free(mv);\n\tisl_union_pw_multi_aff_free(upma);\n\treturn NULL;\n}\n\n/* Construct and return a piecewise multi affine expression\n * in the given space with value zero in each of the output dimensions and\n * a universe domain.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_zero(__isl_take isl_space *space)\n{\n\treturn isl_pw_multi_aff_from_multi_aff(isl_multi_aff_zero(space));\n}\n\n/* Construct and return a piecewise multi affine expression\n * that is equal to the given piecewise affine expression.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_pw_aff(\n\t__isl_take isl_pw_aff *pa)\n{\n\tint i;\n\tisl_space *space;\n\tisl_pw_multi_aff *pma;\n\n\tif (!pa)\n\t\treturn NULL;\n\n\tspace = isl_pw_aff_get_space(pa);\n\tpma = isl_pw_multi_aff_alloc_size(space, pa->n);\n\n\tfor (i = 0; i < pa->n; ++i) {\n\t\tisl_set *set;\n\t\tisl_multi_aff *ma;\n\n\t\tset = isl_set_copy(pa->p[i].set);\n\t\tma = isl_multi_aff_from_aff(isl_aff_copy(pa->p[i].aff));\n\t\tpma = isl_pw_multi_aff_add_piece(pma, set, ma);\n\t}\n\n\tisl_pw_aff_free(pa);\n\treturn pma;\n}\n\n/* Construct and return a piecewise multi affine expression\n * that is equal to the given multi piecewise affine expression\n * on the shared domain of the piecewise affine expressions,\n * in the special case of a 0D multi piecewise affine expression.\n *\n * Create a piecewise multi affine expression with the explicit domain of\n * the 0D multi piecewise affine expression as domain.\n */\nstatic __isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_multi_pw_aff_0D(\n\t__isl_take isl_multi_pw_aff *mpa)\n{\n\tisl_space *space;\n\tisl_set *dom;\n\tisl_multi_aff *ma;\n\n\tspace = isl_multi_pw_aff_get_space(mpa);\n\tdom = isl_multi_pw_aff_get_explicit_domain(mpa);\n\tisl_multi_pw_aff_free(mpa);\n\n\tma = isl_multi_aff_zero(space);\n\treturn isl_pw_multi_aff_alloc(dom, ma);\n}\n\n/* Construct and return a piecewise multi affine expression\n * that is equal to the given multi piecewise affine expression\n * on the shared domain of the piecewise affine expressions.\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_multi_pw_aff(\n\t__isl_take isl_multi_pw_aff *mpa)\n{\n\tint i;\n\tisl_space *space;\n\tisl_pw_aff *pa;\n\tisl_pw_multi_aff *pma;\n\n\tif (!mpa)\n\t\treturn NULL;\n\n\tif (mpa->n == 0)\n\t\treturn isl_pw_multi_aff_from_multi_pw_aff_0D(mpa);\n\n\tspace = isl_multi_pw_aff_get_space(mpa);\n\tpa = isl_multi_pw_aff_get_pw_aff(mpa, 0);\n\tpma = isl_pw_multi_aff_from_pw_aff(pa);\n\n\tfor (i = 1; i < mpa->n; ++i) {\n\t\tisl_pw_multi_aff *pma_i;\n\n\t\tpa = isl_multi_pw_aff_get_pw_aff(mpa, i);\n\t\tpma_i = isl_pw_multi_aff_from_pw_aff(pa);\n\t\tpma = isl_pw_multi_aff_range_product(pma, pma_i);\n\t}\n\n\tpma = isl_pw_multi_aff_reset_space(pma, space);\n\n\tisl_multi_pw_aff_free(mpa);\n\treturn pma;\n}\n\n/* Convenience function that constructs an isl_multi_pw_aff\n * directly from an isl_aff.\n */\n__isl_give isl_multi_pw_aff *isl_multi_pw_aff_from_aff(__isl_take isl_aff *aff)\n{\n\treturn isl_multi_pw_aff_from_pw_aff(isl_pw_aff_from_aff(aff));\n}\n\n/* Construct and return a multi piecewise affine expression\n * that is equal to the given multi affine expression.\n */\n__isl_give isl_multi_pw_aff *isl_multi_pw_aff_from_multi_aff(\n\t__isl_take isl_multi_aff *ma)\n{\n\tint i;\n\tisl_size n;\n\tisl_multi_pw_aff *mpa;\n\n\tn = isl_multi_aff_dim(ma, isl_dim_out);\n\tif (n < 0)\n\t\tma = isl_multi_aff_free(ma);\n\tif (!ma)\n\t\treturn NULL;\n\n\tmpa = isl_multi_pw_aff_alloc(isl_multi_aff_get_space(ma));\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\n\t\tpa = isl_pw_aff_from_aff(isl_multi_aff_get_aff(ma, i));\n\t\tmpa = isl_multi_pw_aff_set_pw_aff(mpa, i, pa);\n\t}\n\n\tisl_multi_aff_free(ma);\n\treturn mpa;\n}\n\n/* Construct and return a multi piecewise affine expression\n * that is equal to the given piecewise multi affine expression.\n *\n * If the resulting multi piecewise affine expression has\n * an explicit domain, then assign it the domain of the input.\n * In other cases, the domain is stored in the individual elements.\n */\n__isl_give isl_multi_pw_aff *isl_multi_pw_aff_from_pw_multi_aff(\n\t__isl_take isl_pw_multi_aff *pma)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_multi_pw_aff *mpa;\n\n\tn = isl_pw_multi_aff_dim(pma, isl_dim_out);\n\tif (n < 0)\n\t\tpma = isl_pw_multi_aff_free(pma);\n\tspace = isl_pw_multi_aff_get_space(pma);\n\tmpa = isl_multi_pw_aff_alloc(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\n\t\tpa = isl_pw_multi_aff_get_pw_aff(pma, i);\n\t\tmpa = isl_multi_pw_aff_set_pw_aff(mpa, i, pa);\n\t}\n\tif (isl_multi_pw_aff_has_explicit_domain(mpa)) {\n\t\tisl_set *dom;\n\n\t\tdom = isl_pw_multi_aff_domain(isl_pw_multi_aff_copy(pma));\n\t\tmpa = isl_multi_pw_aff_intersect_domain(mpa, dom);\n\t}\n\n\tisl_pw_multi_aff_free(pma);\n\treturn mpa;\n}\n\n/* Do \"pa1\" and \"pa2\" represent the same function?\n *\n * We first check if they are obviously equal.\n * If not, we convert them to maps and check if those are equal.\n *\n * If \"pa1\" or \"pa2\" contain any NaNs, then they are considered\n * not to be the same.  A NaN is not equal to anything, not even\n * to another NaN.\n */\nisl_bool isl_pw_aff_is_equal(__isl_keep isl_pw_aff *pa1,\n\t__isl_keep isl_pw_aff *pa2)\n{\n\tisl_bool equal;\n\tisl_bool has_nan;\n\tisl_map *map1, *map2;\n\n\tif (!pa1 || !pa2)\n\t\treturn isl_bool_error;\n\n\tequal = isl_pw_aff_plain_is_equal(pa1, pa2);\n\tif (equal < 0 || equal)\n\t\treturn equal;\n\thas_nan = either_involves_nan(pa1, pa2);\n\tif (has_nan < 0)\n\t\treturn isl_bool_error;\n\tif (has_nan)\n\t\treturn isl_bool_false;\n\n\tmap1 = isl_map_from_pw_aff_internal(isl_pw_aff_copy(pa1));\n\tmap2 = isl_map_from_pw_aff_internal(isl_pw_aff_copy(pa2));\n\tequal = isl_map_is_equal(map1, map2);\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\n\treturn equal;\n}\n\n/* Do \"mpa1\" and \"mpa2\" represent the same function?\n *\n * Note that we cannot convert the entire isl_multi_pw_aff\n * to a map because the domains of the piecewise affine expressions\n * may not be the same.\n */\nisl_bool isl_multi_pw_aff_is_equal(__isl_keep isl_multi_pw_aff *mpa1,\n\t__isl_keep isl_multi_pw_aff *mpa2)\n{\n\tint i;\n\tisl_bool equal, equal_params;\n\n\tif (!mpa1 || !mpa2)\n\t\treturn isl_bool_error;\n\n\tequal_params = isl_space_has_equal_params(mpa1->space, mpa2->space);\n\tif (equal_params < 0)\n\t\treturn isl_bool_error;\n\tif (!equal_params) {\n\t\tif (!isl_space_has_named_params(mpa1->space))\n\t\t\treturn isl_bool_false;\n\t\tif (!isl_space_has_named_params(mpa2->space))\n\t\t\treturn isl_bool_false;\n\t\tmpa1 = isl_multi_pw_aff_copy(mpa1);\n\t\tmpa2 = isl_multi_pw_aff_copy(mpa2);\n\t\tmpa1 = isl_multi_pw_aff_align_params(mpa1,\n\t\t\t\t\t    isl_multi_pw_aff_get_space(mpa2));\n\t\tmpa2 = isl_multi_pw_aff_align_params(mpa2,\n\t\t\t\t\t    isl_multi_pw_aff_get_space(mpa1));\n\t\tequal = isl_multi_pw_aff_is_equal(mpa1, mpa2);\n\t\tisl_multi_pw_aff_free(mpa1);\n\t\tisl_multi_pw_aff_free(mpa2);\n\t\treturn equal;\n\t}\n\n\tequal = isl_space_is_equal(mpa1->space, mpa2->space);\n\tif (equal < 0 || !equal)\n\t\treturn equal;\n\n\tfor (i = 0; i < mpa1->n; ++i) {\n\t\tequal = isl_pw_aff_is_equal(mpa1->u.p[i], mpa2->u.p[i]);\n\t\tif (equal < 0 || !equal)\n\t\t\treturn equal;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Do \"pma1\" and \"pma2\" represent the same function?\n *\n * First check if they are obviously equal.\n * If not, then convert them to maps and check if those are equal.\n *\n * If \"pa1\" or \"pa2\" contain any NaNs, then they are considered\n * not to be the same.  A NaN is not equal to anything, not even\n * to another NaN.\n */\nisl_bool isl_pw_multi_aff_is_equal(__isl_keep isl_pw_multi_aff *pma1,\n\t__isl_keep isl_pw_multi_aff *pma2)\n{\n\tisl_bool equal;\n\tisl_bool has_nan;\n\tisl_map *map1, *map2;\n\n\tif (!pma1 || !pma2)\n\t\treturn isl_bool_error;\n\n\tequal = isl_pw_multi_aff_plain_is_equal(pma1, pma2);\n\tif (equal < 0 || equal)\n\t\treturn equal;\n\thas_nan = isl_pw_multi_aff_involves_nan(pma1);\n\tif (has_nan >= 0 && !has_nan)\n\t\thas_nan = isl_pw_multi_aff_involves_nan(pma2);\n\tif (has_nan < 0 || has_nan)\n\t\treturn isl_bool_not(has_nan);\n\n\tmap1 = isl_map_from_pw_multi_aff_internal(isl_pw_multi_aff_copy(pma1));\n\tmap2 = isl_map_from_pw_multi_aff_internal(isl_pw_multi_aff_copy(pma2));\n\tequal = isl_map_is_equal(map1, map2);\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\n\treturn equal;\n}\n\n/* Compute the pullback of \"mpa\" by the function represented by \"ma\".\n * In other words, plug in \"ma\" in \"mpa\".\n *\n * The parameters of \"mpa\" and \"ma\" are assumed to have been aligned.\n *\n * If \"mpa\" has an explicit domain, then it is this domain\n * that needs to undergo a pullback, i.e., a preimage.\n */\nstatic __isl_give isl_multi_pw_aff *isl_multi_pw_aff_pullback_multi_aff_aligned(\n\t__isl_take isl_multi_pw_aff *mpa, __isl_take isl_multi_aff *ma)\n{\n\tint i;\n\tisl_space *space = NULL;\n\n\tmpa = isl_multi_pw_aff_cow(mpa);\n\tif (!mpa || !ma)\n\t\tgoto error;\n\n\tspace = isl_space_join(isl_multi_aff_get_space(ma),\n\t\t\t\tisl_multi_pw_aff_get_space(mpa));\n\tif (!space)\n\t\tgoto error;\n\n\tfor (i = 0; i < mpa->n; ++i) {\n\t\tmpa->u.p[i] = isl_pw_aff_pullback_multi_aff(mpa->u.p[i],\n\t\t\t\t\t\t    isl_multi_aff_copy(ma));\n\t\tif (!mpa->u.p[i])\n\t\t\tgoto error;\n\t}\n\tif (isl_multi_pw_aff_has_explicit_domain(mpa)) {\n\t\tmpa->u.dom = isl_set_preimage_multi_aff(mpa->u.dom,\n\t\t\t\t\t\t\tisl_multi_aff_copy(ma));\n\t\tif (!mpa->u.dom)\n\t\t\tgoto error;\n\t}\n\n\tisl_multi_aff_free(ma);\n\tisl_space_free(mpa->space);\n\tmpa->space = space;\n\treturn mpa;\nerror:\n\tisl_space_free(space);\n\tisl_multi_pw_aff_free(mpa);\n\tisl_multi_aff_free(ma);\n\treturn NULL;\n}\n\n/* Compute the pullback of \"mpa\" by the function represented by \"ma\".\n * In other words, plug in \"ma\" in \"mpa\".\n */\n__isl_give isl_multi_pw_aff *isl_multi_pw_aff_pullback_multi_aff(\n\t__isl_take isl_multi_pw_aff *mpa, __isl_take isl_multi_aff *ma)\n{\n\tisl_bool equal_params;\n\n\tif (!mpa || !ma)\n\t\tgoto error;\n\tequal_params = isl_space_has_equal_params(mpa->space, ma->space);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (equal_params)\n\t\treturn isl_multi_pw_aff_pullback_multi_aff_aligned(mpa, ma);\n\tmpa = isl_multi_pw_aff_align_params(mpa, isl_multi_aff_get_space(ma));\n\tma = isl_multi_aff_align_params(ma, isl_multi_pw_aff_get_space(mpa));\n\treturn isl_multi_pw_aff_pullback_multi_aff_aligned(mpa, ma);\nerror:\n\tisl_multi_pw_aff_free(mpa);\n\tisl_multi_aff_free(ma);\n\treturn NULL;\n}\n\n/* Compute the pullback of \"mpa\" by the function represented by \"pma\".\n * In other words, plug in \"pma\" in \"mpa\".\n *\n * The parameters of \"mpa\" and \"mpa\" are assumed to have been aligned.\n *\n * If \"mpa\" has an explicit domain, then it is this domain\n * that needs to undergo a pullback, i.e., a preimage.\n */\nstatic __isl_give isl_multi_pw_aff *\nisl_multi_pw_aff_pullback_pw_multi_aff_aligned(\n\t__isl_take isl_multi_pw_aff *mpa, __isl_take isl_pw_multi_aff *pma)\n{\n\tint i;\n\tisl_space *space = NULL;\n\n\tmpa = isl_multi_pw_aff_cow(mpa);\n\tif (!mpa || !pma)\n\t\tgoto error;\n\n\tspace = isl_space_join(isl_pw_multi_aff_get_space(pma),\n\t\t\t\tisl_multi_pw_aff_get_space(mpa));\n\n\tfor (i = 0; i < mpa->n; ++i) {\n\t\tmpa->u.p[i] = isl_pw_aff_pullback_pw_multi_aff_aligned(\n\t\t\t\t    mpa->u.p[i], isl_pw_multi_aff_copy(pma));\n\t\tif (!mpa->u.p[i])\n\t\t\tgoto error;\n\t}\n\tif (isl_multi_pw_aff_has_explicit_domain(mpa)) {\n\t\tmpa->u.dom = isl_set_preimage_pw_multi_aff(mpa->u.dom,\n\t\t\t\t\t\t    isl_pw_multi_aff_copy(pma));\n\t\tif (!mpa->u.dom)\n\t\t\tgoto error;\n\t}\n\n\tisl_pw_multi_aff_free(pma);\n\tisl_space_free(mpa->space);\n\tmpa->space = space;\n\treturn mpa;\nerror:\n\tisl_space_free(space);\n\tisl_multi_pw_aff_free(mpa);\n\tisl_pw_multi_aff_free(pma);\n\treturn NULL;\n}\n\n/* Compute the pullback of \"mpa\" by the function represented by \"pma\".\n * In other words, plug in \"pma\" in \"mpa\".\n */\n__isl_give isl_multi_pw_aff *isl_multi_pw_aff_pullback_pw_multi_aff(\n\t__isl_take isl_multi_pw_aff *mpa, __isl_take isl_pw_multi_aff *pma)\n{\n\tisl_bool equal_params;\n\n\tif (!mpa || !pma)\n\t\tgoto error;\n\tequal_params = isl_space_has_equal_params(mpa->space, pma->dim);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (equal_params)\n\t\treturn isl_multi_pw_aff_pullback_pw_multi_aff_aligned(mpa, pma);\n\tmpa = isl_multi_pw_aff_align_params(mpa,\n\t\t\t\t\t    isl_pw_multi_aff_get_space(pma));\n\tpma = isl_pw_multi_aff_align_params(pma,\n\t\t\t\t\t    isl_multi_pw_aff_get_space(mpa));\n\treturn isl_multi_pw_aff_pullback_pw_multi_aff_aligned(mpa, pma);\nerror:\n\tisl_multi_pw_aff_free(mpa);\n\tisl_pw_multi_aff_free(pma);\n\treturn NULL;\n}\n\n/* Apply \"aff\" to \"mpa\".  The range of \"mpa\" needs to be compatible\n * with the domain of \"aff\".  The domain of the result is the same\n * as that of \"mpa\".\n * \"mpa\" and \"aff\" are assumed to have been aligned.\n *\n * We first extract the parametric constant from \"aff\", defined\n * over the correct domain.\n * Then we add the appropriate combinations of the members of \"mpa\".\n * Finally, we add the integer divisions through recursive calls.\n */\nstatic __isl_give isl_pw_aff *isl_multi_pw_aff_apply_aff_aligned(\n\t__isl_take isl_multi_pw_aff *mpa, __isl_take isl_aff *aff)\n{\n\tint i;\n\tisl_size n_in, n_div, n_mpa_in;\n\tisl_space *space;\n\tisl_val *v;\n\tisl_pw_aff *pa;\n\tisl_aff *tmp;\n\n\tn_in = isl_aff_dim(aff, isl_dim_in);\n\tn_div = isl_aff_dim(aff, isl_dim_div);\n\tn_mpa_in = isl_multi_pw_aff_dim(mpa, isl_dim_in);\n\tif (n_in < 0 || n_div < 0 || n_mpa_in < 0)\n\t\tgoto error;\n\n\tspace = isl_space_domain(isl_multi_pw_aff_get_space(mpa));\n\ttmp = isl_aff_copy(aff);\n\ttmp = isl_aff_drop_dims(tmp, isl_dim_div, 0, n_div);\n\ttmp = isl_aff_drop_dims(tmp, isl_dim_in, 0, n_in);\n\ttmp = isl_aff_add_dims(tmp, isl_dim_in, n_mpa_in);\n\ttmp = isl_aff_reset_domain_space(tmp, space);\n\tpa = isl_pw_aff_from_aff(tmp);\n\n\tfor (i = 0; i < n_in; ++i) {\n\t\tisl_pw_aff *pa_i;\n\n\t\tif (!isl_aff_involves_dims(aff, isl_dim_in, i, 1))\n\t\t\tcontinue;\n\t\tv = isl_aff_get_coefficient_val(aff, isl_dim_in, i);\n\t\tpa_i = isl_multi_pw_aff_get_pw_aff(mpa, i);\n\t\tpa_i = isl_pw_aff_scale_val(pa_i, v);\n\t\tpa = isl_pw_aff_add(pa, pa_i);\n\t}\n\n\tfor (i = 0; i < n_div; ++i) {\n\t\tisl_aff *div;\n\t\tisl_pw_aff *pa_i;\n\n\t\tif (!isl_aff_involves_dims(aff, isl_dim_div, i, 1))\n\t\t\tcontinue;\n\t\tdiv = isl_aff_get_div(aff, i);\n\t\tpa_i = isl_multi_pw_aff_apply_aff_aligned(\n\t\t\t\t\t    isl_multi_pw_aff_copy(mpa), div);\n\t\tpa_i = isl_pw_aff_floor(pa_i);\n\t\tv = isl_aff_get_coefficient_val(aff, isl_dim_div, i);\n\t\tpa_i = isl_pw_aff_scale_val(pa_i, v);\n\t\tpa = isl_pw_aff_add(pa, pa_i);\n\t}\n\n\tisl_multi_pw_aff_free(mpa);\n\tisl_aff_free(aff);\n\n\treturn pa;\nerror:\n\tisl_multi_pw_aff_free(mpa);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Apply \"aff\" to \"mpa\".  The range of \"mpa\" needs to be compatible\n * with the domain of \"aff\".  The domain of the result is the same\n * as that of \"mpa\".\n */\n__isl_give isl_pw_aff *isl_multi_pw_aff_apply_aff(\n\t__isl_take isl_multi_pw_aff *mpa, __isl_take isl_aff *aff)\n{\n\tisl_bool equal_params;\n\n\tif (!aff || !mpa)\n\t\tgoto error;\n\tequal_params = isl_space_has_equal_params(aff->ls->dim, mpa->space);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (equal_params)\n\t\treturn isl_multi_pw_aff_apply_aff_aligned(mpa, aff);\n\n\taff = isl_aff_align_params(aff, isl_multi_pw_aff_get_space(mpa));\n\tmpa = isl_multi_pw_aff_align_params(mpa, isl_aff_get_space(aff));\n\n\treturn isl_multi_pw_aff_apply_aff_aligned(mpa, aff);\nerror:\n\tisl_aff_free(aff);\n\tisl_multi_pw_aff_free(mpa);\n\treturn NULL;\n}\n\n/* Apply \"pa\" to \"mpa\".  The range of \"mpa\" needs to be compatible\n * with the domain of \"pa\".  The domain of the result is the same\n * as that of \"mpa\".\n * \"mpa\" and \"pa\" are assumed to have been aligned.\n *\n * We consider each piece in turn.  Note that the domains of the\n * pieces are assumed to be disjoint and they remain disjoint\n * after taking the preimage (over the same function).\n */\nstatic __isl_give isl_pw_aff *isl_multi_pw_aff_apply_pw_aff_aligned(\n\t__isl_take isl_multi_pw_aff *mpa, __isl_take isl_pw_aff *pa)\n{\n\tisl_space *space;\n\tisl_pw_aff *res;\n\tint i;\n\n\tif (!mpa || !pa)\n\t\tgoto error;\n\n\tspace = isl_space_join(isl_multi_pw_aff_get_space(mpa),\n\t\t\t\tisl_pw_aff_get_space(pa));\n\tres = isl_pw_aff_empty(space);\n\n\tfor (i = 0; i < pa->n; ++i) {\n\t\tisl_pw_aff *pa_i;\n\t\tisl_set *domain;\n\n\t\tpa_i = isl_multi_pw_aff_apply_aff_aligned(\n\t\t\t\t\tisl_multi_pw_aff_copy(mpa),\n\t\t\t\t\tisl_aff_copy(pa->p[i].aff));\n\t\tdomain = isl_set_copy(pa->p[i].set);\n\t\tdomain = isl_set_preimage_multi_pw_aff(domain,\n\t\t\t\t\tisl_multi_pw_aff_copy(mpa));\n\t\tpa_i = isl_pw_aff_intersect_domain(pa_i, domain);\n\t\tres = isl_pw_aff_add_disjoint(res, pa_i);\n\t}\n\n\tisl_pw_aff_free(pa);\n\tisl_multi_pw_aff_free(mpa);\n\treturn res;\nerror:\n\tisl_pw_aff_free(pa);\n\tisl_multi_pw_aff_free(mpa);\n\treturn NULL;\n}\n\n/* Apply \"pa\" to \"mpa\".  The range of \"mpa\" needs to be compatible\n * with the domain of \"pa\".  The domain of the result is the same\n * as that of \"mpa\".\n */\n__isl_give isl_pw_aff *isl_multi_pw_aff_apply_pw_aff(\n\t__isl_take isl_multi_pw_aff *mpa, __isl_take isl_pw_aff *pa)\n{\n\tisl_bool equal_params;\n\n\tif (!pa || !mpa)\n\t\tgoto error;\n\tequal_params = isl_space_has_equal_params(pa->dim, mpa->space);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (equal_params)\n\t\treturn isl_multi_pw_aff_apply_pw_aff_aligned(mpa, pa);\n\n\tpa = isl_pw_aff_align_params(pa, isl_multi_pw_aff_get_space(mpa));\n\tmpa = isl_multi_pw_aff_align_params(mpa, isl_pw_aff_get_space(pa));\n\n\treturn isl_multi_pw_aff_apply_pw_aff_aligned(mpa, pa);\nerror:\n\tisl_pw_aff_free(pa);\n\tisl_multi_pw_aff_free(mpa);\n\treturn NULL;\n}\n\n/* Compute the pullback of \"pa\" by the function represented by \"mpa\".\n * In other words, plug in \"mpa\" in \"pa\".\n * \"pa\" and \"mpa\" are assumed to have been aligned.\n *\n * The pullback is computed by applying \"pa\" to \"mpa\".\n */\nstatic __isl_give isl_pw_aff *isl_pw_aff_pullback_multi_pw_aff_aligned(\n\t__isl_take isl_pw_aff *pa, __isl_take isl_multi_pw_aff *mpa)\n{\n\treturn isl_multi_pw_aff_apply_pw_aff_aligned(mpa, pa);\n}\n\n/* Compute the pullback of \"pa\" by the function represented by \"mpa\".\n * In other words, plug in \"mpa\" in \"pa\".\n *\n * The pullback is computed by applying \"pa\" to \"mpa\".\n */\n__isl_give isl_pw_aff *isl_pw_aff_pullback_multi_pw_aff(\n\t__isl_take isl_pw_aff *pa, __isl_take isl_multi_pw_aff *mpa)\n{\n\treturn isl_multi_pw_aff_apply_pw_aff(mpa, pa);\n}\n\n/* Compute the pullback of \"mpa1\" by the function represented by \"mpa2\".\n * In other words, plug in \"mpa2\" in \"mpa1\".\n *\n * We pullback each member of \"mpa1\" in turn.\n *\n * If \"mpa1\" has an explicit domain, then it is this domain\n * that needs to undergo a pullback instead, i.e., a preimage.\n */\n__isl_give isl_multi_pw_aff *isl_multi_pw_aff_pullback_multi_pw_aff(\n\t__isl_take isl_multi_pw_aff *mpa1, __isl_take isl_multi_pw_aff *mpa2)\n{\n\tint i;\n\tisl_space *space = NULL;\n\n\tisl_multi_pw_aff_align_params_bin(&mpa1, &mpa2);\n\tmpa1 = isl_multi_pw_aff_cow(mpa1);\n\tif (!mpa1 || !mpa2)\n\t\tgoto error;\n\n\tspace = isl_space_join(isl_multi_pw_aff_get_space(mpa2),\n\t\t\t\tisl_multi_pw_aff_get_space(mpa1));\n\n\tfor (i = 0; i < mpa1->n; ++i) {\n\t\tmpa1->u.p[i] = isl_pw_aff_pullback_multi_pw_aff_aligned(\n\t\t\t\tmpa1->u.p[i], isl_multi_pw_aff_copy(mpa2));\n\t\tif (!mpa1->u.p[i])\n\t\t\tgoto error;\n\t}\n\n\tif (isl_multi_pw_aff_has_explicit_domain(mpa1)) {\n\t\tmpa1->u.dom = isl_set_preimage_multi_pw_aff(mpa1->u.dom,\n\t\t\t\t\t\tisl_multi_pw_aff_copy(mpa2));\n\t\tif (!mpa1->u.dom)\n\t\t\tgoto error;\n\t}\n\tmpa1 = isl_multi_pw_aff_reset_space(mpa1, space);\n\n\tisl_multi_pw_aff_free(mpa2);\n\treturn mpa1;\nerror:\n\tisl_space_free(space);\n\tisl_multi_pw_aff_free(mpa1);\n\tisl_multi_pw_aff_free(mpa2);\n\treturn NULL;\n}\n\n/* Align the parameters of \"mpa1\" and \"mpa2\", check that the ranges\n * of \"mpa1\" and \"mpa2\" live in the same space, construct map space\n * between the domain spaces of \"mpa1\" and \"mpa2\" and call \"order\"\n * with this map space as extract argument.\n */\nstatic __isl_give isl_map *isl_multi_pw_aff_order_map(\n\t__isl_take isl_multi_pw_aff *mpa1, __isl_take isl_multi_pw_aff *mpa2,\n\t__isl_give isl_map *(*order)(__isl_keep isl_multi_pw_aff *mpa1,\n\t\t__isl_keep isl_multi_pw_aff *mpa2, __isl_take isl_space *space))\n{\n\tint match;\n\tisl_space *space1, *space2;\n\tisl_map *res;\n\n\tmpa1 = isl_multi_pw_aff_align_params(mpa1,\n\t\t\t\t\t    isl_multi_pw_aff_get_space(mpa2));\n\tmpa2 = isl_multi_pw_aff_align_params(mpa2,\n\t\t\t\t\t    isl_multi_pw_aff_get_space(mpa1));\n\tif (!mpa1 || !mpa2)\n\t\tgoto error;\n\tmatch = isl_space_tuple_is_equal(mpa1->space, isl_dim_out,\n\t\t\t\t\tmpa2->space, isl_dim_out);\n\tif (match < 0)\n\t\tgoto error;\n\tif (!match)\n\t\tisl_die(isl_multi_pw_aff_get_ctx(mpa1), isl_error_invalid,\n\t\t\t\"range spaces don't match\", goto error);\n\tspace1 = isl_space_domain(isl_multi_pw_aff_get_space(mpa1));\n\tspace2 = isl_space_domain(isl_multi_pw_aff_get_space(mpa2));\n\tspace1 = isl_space_map_from_domain_and_range(space1, space2);\n\n\tres = order(mpa1, mpa2, space1);\n\tisl_multi_pw_aff_free(mpa1);\n\tisl_multi_pw_aff_free(mpa2);\n\treturn res;\nerror:\n\tisl_multi_pw_aff_free(mpa1);\n\tisl_multi_pw_aff_free(mpa2);\n\treturn NULL;\n}\n\n/* Return a map containing pairs of elements in the domains of \"mpa1\" and \"mpa2\"\n * where the function values are equal.  \"space\" is the space of the result.\n * The parameters of \"mpa1\" and \"mpa2\" are assumed to have been aligned.\n *\n * \"mpa1\" and \"mpa2\" are equal when each of the pairs of elements\n * in the sequences are equal.\n */\nstatic __isl_give isl_map *isl_multi_pw_aff_eq_map_on_space(\n\t__isl_keep isl_multi_pw_aff *mpa1, __isl_keep isl_multi_pw_aff *mpa2,\n\t__isl_take isl_space *space)\n{\n\tint i;\n\tisl_size n;\n\tisl_map *res;\n\n\tn = isl_multi_pw_aff_dim(mpa1, isl_dim_out);\n\tif (n < 0)\n\t\tspace = isl_space_free(space);\n\tres = isl_map_universe(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa1, *pa2;\n\t\tisl_map *map;\n\n\t\tpa1 = isl_multi_pw_aff_get_pw_aff(mpa1, i);\n\t\tpa2 = isl_multi_pw_aff_get_pw_aff(mpa2, i);\n\t\tmap = isl_pw_aff_eq_map(pa1, pa2);\n\t\tres = isl_map_intersect(res, map);\n\t}\n\n\treturn res;\n}\n\n/* Return a map containing pairs of elements in the domains of \"mpa1\" and \"mpa2\"\n * where the function values are equal.\n */\n__isl_give isl_map *isl_multi_pw_aff_eq_map(__isl_take isl_multi_pw_aff *mpa1,\n\t__isl_take isl_multi_pw_aff *mpa2)\n{\n\treturn isl_multi_pw_aff_order_map(mpa1, mpa2,\n\t\t\t\t\t    &isl_multi_pw_aff_eq_map_on_space);\n}\n\n/* Intersect \"map\" with the result of applying \"order\"\n * on two copies of \"mpa\".\n */\nstatic __isl_give isl_map *isl_map_order_at_multi_pw_aff(\n\t__isl_take isl_map *map, __isl_take isl_multi_pw_aff *mpa,\n\t__isl_give isl_map *(*order)(__isl_take isl_multi_pw_aff *mpa1,\n\t\t__isl_take isl_multi_pw_aff *mpa2))\n{\n\treturn isl_map_intersect(map, order(mpa, isl_multi_pw_aff_copy(mpa)));\n}\n\n/* Return the subset of \"map\" where the domain and the range\n * have equal \"mpa\" values.\n */\n__isl_give isl_map *isl_map_eq_at_multi_pw_aff(__isl_take isl_map *map,\n\t__isl_take isl_multi_pw_aff *mpa)\n{\n\treturn isl_map_order_at_multi_pw_aff(map, mpa,\n\t\t\t\t\t\t&isl_multi_pw_aff_eq_map);\n}\n\n/* Return a map containing pairs of elements in the domains of \"mpa1\" and \"mpa2\"\n * where the function values of \"mpa1\" lexicographically satisfies\n * \"strict_base\"/\"base\" compared to that of \"mpa2\".\n * \"space\" is the space of the result.\n * The parameters of \"mpa1\" and \"mpa2\" are assumed to have been aligned.\n *\n * \"mpa1\" lexicographically satisfies \"strict_base\"/\"base\" compared to \"mpa2\"\n * if, for some i, the i-th element of \"mpa1\" satisfies \"strict_base\"/\"base\"\n * when compared to the i-th element of \"mpa2\" while all previous elements are\n * pairwise equal.\n * In particular, if i corresponds to the final elements\n * then they need to satisfy \"base\", while \"strict_base\" needs to be satisfied\n * for other values of i.\n * If \"base\" is a strict order, then \"base\" and \"strict_base\" are the same.\n */\nstatic __isl_give isl_map *isl_multi_pw_aff_lex_map_on_space(\n\t__isl_keep isl_multi_pw_aff *mpa1, __isl_keep isl_multi_pw_aff *mpa2,\n\t__isl_give isl_map *(*strict_base)(__isl_take isl_pw_aff *pa1,\n\t\t__isl_take isl_pw_aff *pa2),\n\t__isl_give isl_map *(*base)(__isl_take isl_pw_aff *pa1,\n\t\t__isl_take isl_pw_aff *pa2),\n\t__isl_take isl_space *space)\n{\n\tint i;\n\tisl_size n;\n\tisl_map *res, *rest;\n\n\tn = isl_multi_pw_aff_dim(mpa1, isl_dim_out);\n\tif (n < 0)\n\t\tspace = isl_space_free(space);\n\tres = isl_map_empty(isl_space_copy(space));\n\trest = isl_map_universe(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tint last;\n\t\tisl_pw_aff *pa1, *pa2;\n\t\tisl_map *map;\n\n\t\tlast = i == n - 1;\n\n\t\tpa1 = isl_multi_pw_aff_get_pw_aff(mpa1, i);\n\t\tpa2 = isl_multi_pw_aff_get_pw_aff(mpa2, i);\n\t\tmap = last ? base(pa1, pa2) : strict_base(pa1, pa2);\n\t\tmap = isl_map_intersect(map, isl_map_copy(rest));\n\t\tres = isl_map_union(res, map);\n\n\t\tif (last)\n\t\t\tcontinue;\n\n\t\tpa1 = isl_multi_pw_aff_get_pw_aff(mpa1, i);\n\t\tpa2 = isl_multi_pw_aff_get_pw_aff(mpa2, i);\n\t\tmap = isl_pw_aff_eq_map(pa1, pa2);\n\t\trest = isl_map_intersect(rest, map);\n\t}\n\n\tisl_map_free(rest);\n\treturn res;\n}\n\n#undef ORDER\n#define ORDER\t\tle\n#undef STRICT_ORDER\n#define STRICT_ORDER\tlt\n#include \"isl_aff_lex_templ.c\"\n\n#undef ORDER\n#define ORDER\t\tlt\n#undef STRICT_ORDER\n#define STRICT_ORDER\tlt\n#include \"isl_aff_lex_templ.c\"\n\n#undef ORDER\n#define ORDER\t\tge\n#undef STRICT_ORDER\n#define STRICT_ORDER\tgt\n#include \"isl_aff_lex_templ.c\"\n\n#undef ORDER\n#define ORDER\t\tgt\n#undef STRICT_ORDER\n#define STRICT_ORDER\tgt\n#include \"isl_aff_lex_templ.c\"\n\n/* Compare two isl_affs.\n *\n * Return -1 if \"aff1\" is \"smaller\" than \"aff2\", 1 if \"aff1\" is \"greater\"\n * than \"aff2\" and 0 if they are equal.\n *\n * The order is fairly arbitrary.  We do consider expressions that only involve\n * earlier dimensions as \"smaller\".\n */\nint isl_aff_plain_cmp(__isl_keep isl_aff *aff1, __isl_keep isl_aff *aff2)\n{\n\tint cmp;\n\tint last1, last2;\n\n\tif (aff1 == aff2)\n\t\treturn 0;\n\n\tif (!aff1)\n\t\treturn -1;\n\tif (!aff2)\n\t\treturn 1;\n\n\tcmp = isl_local_space_cmp(aff1->ls, aff2->ls);\n\tif (cmp != 0)\n\t\treturn cmp;\n\n\tlast1 = isl_seq_last_non_zero(aff1->v->el + 1, aff1->v->size - 1);\n\tlast2 = isl_seq_last_non_zero(aff2->v->el + 1, aff1->v->size - 1);\n\tif (last1 != last2)\n\t\treturn last1 - last2;\n\n\treturn isl_seq_cmp(aff1->v->el, aff2->v->el, aff1->v->size);\n}\n\n/* Compare two isl_pw_affs.\n *\n * Return -1 if \"pa1\" is \"smaller\" than \"pa2\", 1 if \"pa1\" is \"greater\"\n * than \"pa2\" and 0 if they are equal.\n *\n * The order is fairly arbitrary.  We do consider expressions that only involve\n * earlier dimensions as \"smaller\".\n */\nint isl_pw_aff_plain_cmp(__isl_keep isl_pw_aff *pa1,\n\t__isl_keep isl_pw_aff *pa2)\n{\n\tint i;\n\tint cmp;\n\n\tif (pa1 == pa2)\n\t\treturn 0;\n\n\tif (!pa1)\n\t\treturn -1;\n\tif (!pa2)\n\t\treturn 1;\n\n\tcmp = isl_space_cmp(pa1->dim, pa2->dim);\n\tif (cmp != 0)\n\t\treturn cmp;\n\n\tif (pa1->n != pa2->n)\n\t\treturn pa1->n - pa2->n;\n\n\tfor (i = 0; i < pa1->n; ++i) {\n\t\tcmp = isl_set_plain_cmp(pa1->p[i].set, pa2->p[i].set);\n\t\tif (cmp != 0)\n\t\t\treturn cmp;\n\t\tcmp = isl_aff_plain_cmp(pa1->p[i].aff, pa2->p[i].aff);\n\t\tif (cmp != 0)\n\t\t\treturn cmp;\n\t}\n\n\treturn 0;\n}\n\n/* Return a piecewise affine expression that is equal to \"v\" on \"domain\".\n */\n__isl_give isl_pw_aff *isl_pw_aff_val_on_domain(__isl_take isl_set *domain,\n\t__isl_take isl_val *v)\n{\n\tisl_space *space;\n\tisl_local_space *ls;\n\tisl_aff *aff;\n\n\tspace = isl_set_get_space(domain);\n\tls = isl_local_space_from_space(space);\n\taff = isl_aff_val_on_domain(ls, v);\n\n\treturn isl_pw_aff_alloc(domain, aff);\n}\n\n/* Return a piecewise affine expression that is equal to the parameter\n * with identifier \"id\" on \"domain\".\n */\n__isl_give isl_pw_aff *isl_pw_aff_param_on_domain_id(\n\t__isl_take isl_set *domain, __isl_take isl_id *id)\n{\n\tisl_space *space;\n\tisl_aff *aff;\n\n\tspace = isl_set_get_space(domain);\n\tspace = isl_space_add_param_id(space, isl_id_copy(id));\n\tdomain = isl_set_align_params(domain, isl_space_copy(space));\n\taff = isl_aff_param_on_domain_space_id(space, id);\n\n\treturn isl_pw_aff_alloc(domain, aff);\n}\n\n/* Return a multi affine expression that is equal to \"mv\" on domain\n * space \"space\".\n */\n__isl_give isl_multi_aff *isl_multi_aff_multi_val_on_space(\n\t__isl_take isl_space *space, __isl_take isl_multi_val *mv)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space2;\n\tisl_local_space *ls;\n\tisl_multi_aff *ma;\n\n\tn = isl_multi_val_dim(mv, isl_dim_set);\n\tif (!space || n < 0)\n\t\tgoto error;\n\n\tspace2 = isl_multi_val_get_space(mv);\n\tspace2 = isl_space_align_params(space2, isl_space_copy(space));\n\tspace = isl_space_align_params(space, isl_space_copy(space2));\n\tspace = isl_space_map_from_domain_and_range(space, space2);\n\tma = isl_multi_aff_alloc(isl_space_copy(space));\n\tls = isl_local_space_from_space(isl_space_domain(space));\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_val *v;\n\t\tisl_aff *aff;\n\n\t\tv = isl_multi_val_get_val(mv, i);\n\t\taff = isl_aff_val_on_domain(isl_local_space_copy(ls), v);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\tisl_local_space_free(ls);\n\n\tisl_multi_val_free(mv);\n\treturn ma;\nerror:\n\tisl_space_free(space);\n\tisl_multi_val_free(mv);\n\treturn NULL;\n}\n\n/* Return a piecewise multi-affine expression\n * that is equal to \"mv\" on \"domain\".\n */\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_multi_val_on_domain(\n\t__isl_take isl_set *domain, __isl_take isl_multi_val *mv)\n{\n\tisl_space *space;\n\tisl_multi_aff *ma;\n\n\tspace = isl_set_get_space(domain);\n\tma = isl_multi_aff_multi_val_on_space(space, mv);\n\n\treturn isl_pw_multi_aff_alloc(domain, ma);\n}\n\n/* Internal data structure for isl_union_pw_multi_aff_multi_val_on_domain.\n * mv is the value that should be attained on each domain set\n * res collects the results\n */\nstruct isl_union_pw_multi_aff_multi_val_on_domain_data {\n\tisl_multi_val *mv;\n\tisl_union_pw_multi_aff *res;\n};\n\n/* Create an isl_pw_multi_aff equal to data->mv on \"domain\"\n * and add it to data->res.\n */\nstatic isl_stat pw_multi_aff_multi_val_on_domain(__isl_take isl_set *domain,\n\tvoid *user)\n{\n\tstruct isl_union_pw_multi_aff_multi_val_on_domain_data *data = user;\n\tisl_pw_multi_aff *pma;\n\tisl_multi_val *mv;\n\n\tmv = isl_multi_val_copy(data->mv);\n\tpma = isl_pw_multi_aff_multi_val_on_domain(domain, mv);\n\tdata->res = isl_union_pw_multi_aff_add_pw_multi_aff(data->res, pma);\n\n\treturn data->res ? isl_stat_ok : isl_stat_error;\n}\n\n/* Return a union piecewise multi-affine expression\n * that is equal to \"mv\" on \"domain\".\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_multi_val_on_domain(\n\t__isl_take isl_union_set *domain, __isl_take isl_multi_val *mv)\n{\n\tstruct isl_union_pw_multi_aff_multi_val_on_domain_data data;\n\tisl_space *space;\n\n\tspace = isl_union_set_get_space(domain);\n\tdata.res = isl_union_pw_multi_aff_empty(space);\n\tdata.mv = mv;\n\tif (isl_union_set_foreach_set(domain,\n\t\t\t&pw_multi_aff_multi_val_on_domain, &data) < 0)\n\t\tdata.res = isl_union_pw_multi_aff_free(data.res);\n\tisl_union_set_free(domain);\n\tisl_multi_val_free(mv);\n\treturn data.res;\n}\n\n/* Compute the pullback of data->pma by the function represented by \"pma2\",\n * provided the spaces match, and add the results to data->res.\n */\nstatic isl_stat pullback_entry(__isl_take isl_pw_multi_aff *pma2, void *user)\n{\n\tstruct isl_union_pw_multi_aff_bin_data *data = user;\n\n\tif (!isl_space_tuple_is_equal(data->pma->dim, isl_dim_in,\n\t\t\t\t pma2->dim, isl_dim_out)) {\n\t\tisl_pw_multi_aff_free(pma2);\n\t\treturn isl_stat_ok;\n\t}\n\n\tpma2 = isl_pw_multi_aff_pullback_pw_multi_aff(\n\t\t\t\t\tisl_pw_multi_aff_copy(data->pma), pma2);\n\n\tdata->res = isl_union_pw_multi_aff_add_pw_multi_aff(data->res, pma2);\n\tif (!data->res)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Compute the pullback of \"upma1\" by the function represented by \"upma2\".\n */\n__isl_give isl_union_pw_multi_aff *\nisl_union_pw_multi_aff_pullback_union_pw_multi_aff(\n\t__isl_take isl_union_pw_multi_aff *upma1,\n\t__isl_take isl_union_pw_multi_aff *upma2)\n{\n\treturn bin_op(upma1, upma2, &pullback_entry);\n}\n\n/* Apply \"upma2\" to \"upma1\".\n *\n * That is, compute the pullback of \"upma2\" by \"upma1\".\n */\n__isl_give isl_union_pw_multi_aff *\nisl_union_pw_multi_aff_apply_union_pw_multi_aff(\n\t__isl_take isl_union_pw_multi_aff *upma1,\n\t__isl_take isl_union_pw_multi_aff *upma2)\n{\n\treturn isl_union_pw_multi_aff_pullback_union_pw_multi_aff(upma2, upma1);\n}\n\n#undef TYPE\n#define TYPE isl_pw_multi_aff\nstatic\n#include \"isl_copy_tuple_id_templ.c\"\n\n/* Given a function \"pma1\" of the form A[B -> C] -> D and\n * a function \"pma2\" of the form E -> B,\n * replace the domain of the wrapped relation inside the domain of \"pma1\"\n * by the preimage with respect to \"pma2\".\n * In other words, plug in \"pma2\" in this nested domain.\n * The result is of the form A[E -> C] -> D.\n *\n * In particular, extend E -> B to A[E -> C] -> A[B -> C] and\n * plug that into \"pma1\".\n */\n__isl_give isl_pw_multi_aff *\nisl_pw_multi_aff_preimage_domain_wrapped_domain_pw_multi_aff(\n\t__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2)\n{\n\tisl_space *pma1_space, *pma2_space;\n\tisl_space *space;\n\tisl_pw_multi_aff *id;\n\n\tpma1_space = isl_pw_multi_aff_peek_space(pma1);\n\tpma2_space = isl_pw_multi_aff_peek_space(pma2);\n\n\tif (isl_space_check_domain_is_wrapping(pma1_space) < 0)\n\t\tgoto error;\n\tif (isl_space_check_wrapped_tuple_is_equal(pma1_space,\n\t\t\tisl_dim_in, isl_dim_in, pma2_space, isl_dim_out) < 0)\n\t\tgoto error;\n\n\tspace = isl_space_domain(isl_space_copy(pma1_space));\n\tspace = isl_space_range(isl_space_unwrap(space));\n\tid = isl_pw_multi_aff_identity_on_domain_space(space);\n\tpma2 = isl_pw_multi_aff_product(pma2, id);\n\n\tpma2 = isl_pw_multi_aff_copy_tuple_id(pma2, isl_dim_in,\n\t\t\t\t\t\tpma1_space, isl_dim_in);\n\tpma2 = isl_pw_multi_aff_copy_tuple_id(pma2, isl_dim_out,\n\t\t\t\t\t\tpma1_space, isl_dim_in);\n\n\treturn isl_pw_multi_aff_pullback_pw_multi_aff(pma1, pma2);\nerror:\n\tisl_pw_multi_aff_free(pma1);\n\tisl_pw_multi_aff_free(pma2);\n\treturn NULL;\n}\n\n/* If data->pma and \"pma2\" are such that\n * data->pma is of the form A[B -> C] -> D and\n * \"pma2\" is of the form E -> B,\n * then replace the domain of the wrapped relation\n * inside the domain of data->pma by the preimage with respect to \"pma2\" and\n * add the result to data->res.\n */\nstatic isl_stat preimage_domain_wrapped_domain_entry(\n\t__isl_take isl_pw_multi_aff *pma2, void *user)\n{\n\tstruct isl_union_pw_multi_aff_bin_data *data = user;\n\tisl_space *pma1_space, *pma2_space;\n\tisl_bool match;\n\n\tpma1_space = isl_pw_multi_aff_peek_space(data->pma);\n\tpma2_space = isl_pw_multi_aff_peek_space(pma2);\n\n\tmatch = isl_space_domain_is_wrapping(pma1_space);\n\tif (match >= 0 && match)\n\t\tmatch = isl_space_wrapped_tuple_is_equal(pma1_space, isl_dim_in,\n\t\t\t\t\tisl_dim_in, pma2_space, isl_dim_out);\n\tif (match < 0 || !match) {\n\t\tisl_pw_multi_aff_free(pma2);\n\t\treturn match < 0 ? isl_stat_error : isl_stat_ok;\n\t}\n\n\tpma2 = isl_pw_multi_aff_preimage_domain_wrapped_domain_pw_multi_aff(\n\t\tisl_pw_multi_aff_copy(data->pma), pma2);\n\n\tdata->res = isl_union_pw_multi_aff_add_pw_multi_aff(data->res, pma2);\n\n\treturn isl_stat_non_null(data->res);\n}\n\n/* For each pair of functions A[B -> C] -> D in \"upma1\" and\n * E -> B in \"upma2\",\n * replace the domain of the wrapped relation inside the domain of the first\n * by the preimage with respect to the second and collect the results.\n * In other words, plug in the second function in this nested domain.\n * The results are of the form A[E -> C] -> D.\n */\n__isl_give isl_union_pw_multi_aff *\nisl_union_pw_multi_aff_preimage_domain_wrapped_domain_union_pw_multi_aff(\n\t__isl_take isl_union_pw_multi_aff *upma1,\n\t__isl_take isl_union_pw_multi_aff *upma2)\n{\n\treturn bin_op(upma1, upma2, &preimage_domain_wrapped_domain_entry);\n}\n\n/* Check that the domain space of \"upa\" matches \"space\".\n *\n * This function is called from isl_multi_union_pw_aff_set_union_pw_aff and\n * can in principle never fail since the space \"space\" is that\n * of the isl_multi_union_pw_aff and is a set space such that\n * there is no domain space to match.\n *\n * We check the parameters and double-check that \"space\" is\n * indeed that of a set.\n */\nstatic isl_stat isl_union_pw_aff_check_match_domain_space(\n\t__isl_keep isl_union_pw_aff *upa, __isl_keep isl_space *space)\n{\n\tisl_space *upa_space;\n\tisl_bool match;\n\n\tif (!upa || !space)\n\t\treturn isl_stat_error;\n\n\tmatch = isl_space_is_set(space);\n\tif (match < 0)\n\t\treturn isl_stat_error;\n\tif (!match)\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"expecting set space\", return isl_stat_error);\n\n\tupa_space = isl_union_pw_aff_get_space(upa);\n\tmatch = isl_space_has_equal_params(space, upa_space);\n\tif (match < 0)\n\t\tgoto error;\n\tif (!match)\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"parameters don't match\", goto error);\n\n\tisl_space_free(upa_space);\n\treturn isl_stat_ok;\nerror:\n\tisl_space_free(upa_space);\n\treturn isl_stat_error;\n}\n\n/* Do the parameters of \"upa\" match those of \"space\"?\n */\nstatic isl_bool isl_union_pw_aff_matching_params(\n\t__isl_keep isl_union_pw_aff *upa, __isl_keep isl_space *space)\n{\n\tisl_space *upa_space;\n\tisl_bool match;\n\n\tif (!upa || !space)\n\t\treturn isl_bool_error;\n\n\tupa_space = isl_union_pw_aff_get_space(upa);\n\n\tmatch = isl_space_has_equal_params(space, upa_space);\n\n\tisl_space_free(upa_space);\n\treturn match;\n}\n\n/* Internal data structure for isl_union_pw_aff_reset_domain_space.\n * space represents the new parameters.\n * res collects the results.\n */\nstruct isl_union_pw_aff_reset_params_data {\n\tisl_space *space;\n\tisl_union_pw_aff *res;\n};\n\n/* Replace the parameters of \"pa\" by data->space and\n * add the result to data->res.\n */\nstatic isl_stat reset_params(__isl_take isl_pw_aff *pa, void *user)\n{\n\tstruct isl_union_pw_aff_reset_params_data *data = user;\n\tisl_space *space;\n\n\tspace = isl_pw_aff_get_space(pa);\n\tspace = isl_space_replace_params(space, data->space);\n\tpa = isl_pw_aff_reset_space(pa, space);\n\tdata->res = isl_union_pw_aff_add_pw_aff(data->res, pa);\n\n\treturn data->res ? isl_stat_ok : isl_stat_error;\n}\n\n/* Replace the domain space of \"upa\" by \"space\".\n * Since a union expression does not have a (single) domain space,\n * \"space\" is necessarily a parameter space.\n *\n * Since the order and the names of the parameters determine\n * the hash value, we need to create a new hash table.\n */\nstatic __isl_give isl_union_pw_aff *isl_union_pw_aff_reset_domain_space(\n\t__isl_take isl_union_pw_aff *upa, __isl_take isl_space *space)\n{\n\tstruct isl_union_pw_aff_reset_params_data data = { space };\n\tisl_bool match;\n\n\tmatch = isl_union_pw_aff_matching_params(upa, space);\n\tif (match < 0)\n\t\tupa = isl_union_pw_aff_free(upa);\n\telse if (match) {\n\t\tisl_space_free(space);\n\t\treturn upa;\n\t}\n\n\tdata.res = isl_union_pw_aff_empty(isl_space_copy(space));\n\tif (isl_union_pw_aff_foreach_pw_aff(upa, &reset_params, &data) < 0)\n\t\tdata.res = isl_union_pw_aff_free(data.res);\n\n\tisl_union_pw_aff_free(upa);\n\tisl_space_free(space);\n\treturn data.res;\n}\n\n/* Return the floor of \"pa\".\n */\nstatic __isl_give isl_pw_aff *floor_entry(__isl_take isl_pw_aff *pa, void *user)\n{\n\treturn isl_pw_aff_floor(pa);\n}\n\n/* Given f, return floor(f).\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_floor(\n\t__isl_take isl_union_pw_aff *upa)\n{\n\treturn isl_union_pw_aff_transform_inplace(upa, &floor_entry, NULL);\n}\n\n/* Compute\n *\n *\tupa mod m = upa - m * floor(upa/m)\n *\n * with m an integer value.\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_mod_val(\n\t__isl_take isl_union_pw_aff *upa, __isl_take isl_val *m)\n{\n\tisl_union_pw_aff *res;\n\n\tif (!upa || !m)\n\t\tgoto error;\n\n\tif (!isl_val_is_int(m))\n\t\tisl_die(isl_val_get_ctx(m), isl_error_invalid,\n\t\t\t\"expecting integer modulo\", goto error);\n\tif (!isl_val_is_pos(m))\n\t\tisl_die(isl_val_get_ctx(m), isl_error_invalid,\n\t\t\t\"expecting positive modulo\", goto error);\n\n\tres = isl_union_pw_aff_copy(upa);\n\tupa = isl_union_pw_aff_scale_down_val(upa, isl_val_copy(m));\n\tupa = isl_union_pw_aff_floor(upa);\n\tupa = isl_union_pw_aff_scale_val(upa, m);\n\tres = isl_union_pw_aff_sub(res, upa);\n\n\treturn res;\nerror:\n\tisl_val_free(m);\n\tisl_union_pw_aff_free(upa);\n\treturn NULL;\n}\n\n/* Internal data structure for isl_union_pw_multi_aff_get_union_pw_aff.\n * pos is the output position that needs to be extracted.\n * res collects the results.\n */\nstruct isl_union_pw_multi_aff_get_union_pw_aff_data {\n\tint pos;\n\tisl_union_pw_aff *res;\n};\n\n/* Extract an isl_pw_aff corresponding to output dimension \"pos\" of \"pma\"\n * (assuming it has such a dimension) and add it to data->res.\n */\nstatic isl_stat get_union_pw_aff(__isl_take isl_pw_multi_aff *pma, void *user)\n{\n\tstruct isl_union_pw_multi_aff_get_union_pw_aff_data *data = user;\n\tisl_size n_out;\n\tisl_pw_aff *pa;\n\n\tn_out = isl_pw_multi_aff_dim(pma, isl_dim_out);\n\tif (n_out < 0)\n\t\treturn isl_stat_error;\n\tif (data->pos >= n_out) {\n\t\tisl_pw_multi_aff_free(pma);\n\t\treturn isl_stat_ok;\n\t}\n\n\tpa = isl_pw_multi_aff_get_pw_aff(pma, data->pos);\n\tisl_pw_multi_aff_free(pma);\n\n\tdata->res = isl_union_pw_aff_add_pw_aff(data->res, pa);\n\n\treturn data->res ? isl_stat_ok : isl_stat_error;\n}\n\n/* Extract an isl_union_pw_aff corresponding to\n * output dimension \"pos\" of \"upma\".\n */\n__isl_give isl_union_pw_aff *isl_union_pw_multi_aff_get_union_pw_aff(\n\t__isl_keep isl_union_pw_multi_aff *upma, int pos)\n{\n\tstruct isl_union_pw_multi_aff_get_union_pw_aff_data data;\n\tisl_space *space;\n\n\tif (!upma)\n\t\treturn NULL;\n\n\tif (pos < 0)\n\t\tisl_die(isl_union_pw_multi_aff_get_ctx(upma), isl_error_invalid,\n\t\t\t\"cannot extract at negative position\", return NULL);\n\n\tspace = isl_union_pw_multi_aff_get_space(upma);\n\tdata.res = isl_union_pw_aff_empty(space);\n\tdata.pos = pos;\n\tif (isl_union_pw_multi_aff_foreach_pw_multi_aff(upma,\n\t\t\t\t\t\t&get_union_pw_aff, &data) < 0)\n\t\tdata.res = isl_union_pw_aff_free(data.res);\n\n\treturn data.res;\n}\n\n/* Return a union piecewise affine expression\n * that is equal to \"aff\" on \"domain\".\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_aff_on_domain(\n\t__isl_take isl_union_set *domain, __isl_take isl_aff *aff)\n{\n\tisl_pw_aff *pa;\n\n\tpa = isl_pw_aff_from_aff(aff);\n\treturn isl_union_pw_aff_pw_aff_on_domain(domain, pa);\n}\n\n/* Return a union piecewise affine expression\n * that is equal to the parameter identified by \"id\" on \"domain\".\n *\n * Make sure the parameter appears in the space passed to\n * isl_aff_param_on_domain_space_id.\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_param_on_domain_id(\n\t__isl_take isl_union_set *domain, __isl_take isl_id *id)\n{\n\tisl_space *space;\n\tisl_aff *aff;\n\n\tspace = isl_union_set_get_space(domain);\n\tspace = isl_space_add_param_id(space, isl_id_copy(id));\n\taff = isl_aff_param_on_domain_space_id(space, id);\n\treturn isl_union_pw_aff_aff_on_domain(domain, aff);\n}\n\n/* Internal data structure for isl_union_pw_aff_pw_aff_on_domain.\n * \"pa\" is the piecewise symbolic value that the resulting isl_union_pw_aff\n * needs to attain.\n * \"res\" collects the results.\n */\nstruct isl_union_pw_aff_pw_aff_on_domain_data {\n\tisl_pw_aff *pa;\n\tisl_union_pw_aff *res;\n};\n\n/* Construct a piecewise affine expression that is equal to data->pa\n * on \"domain\" and add the result to data->res.\n */\nstatic isl_stat pw_aff_on_domain(__isl_take isl_set *domain, void *user)\n{\n\tstruct isl_union_pw_aff_pw_aff_on_domain_data *data = user;\n\tisl_pw_aff *pa;\n\tisl_size dim;\n\n\tpa = isl_pw_aff_copy(data->pa);\n\tdim = isl_set_dim(domain, isl_dim_set);\n\tif (dim < 0)\n\t\tpa = isl_pw_aff_free(pa);\n\tpa = isl_pw_aff_from_range(pa);\n\tpa = isl_pw_aff_add_dims(pa, isl_dim_in, dim);\n\tpa = isl_pw_aff_reset_domain_space(pa, isl_set_get_space(domain));\n\tpa = isl_pw_aff_intersect_domain(pa, domain);\n\tdata->res = isl_union_pw_aff_add_pw_aff(data->res, pa);\n\n\treturn data->res ? isl_stat_ok : isl_stat_error;\n}\n\n/* Return a union piecewise affine expression\n * that is equal to \"pa\" on \"domain\", assuming \"domain\" and \"pa\"\n * have been aligned.\n *\n * Construct an isl_pw_aff on each of the sets in \"domain\" and\n * collect the results.\n */\nstatic __isl_give isl_union_pw_aff *isl_union_pw_aff_pw_aff_on_domain_aligned(\n\t__isl_take isl_union_set *domain, __isl_take isl_pw_aff *pa)\n{\n\tstruct isl_union_pw_aff_pw_aff_on_domain_data data;\n\tisl_space *space;\n\n\tspace = isl_union_set_get_space(domain);\n\tdata.res = isl_union_pw_aff_empty(space);\n\tdata.pa = pa;\n\tif (isl_union_set_foreach_set(domain, &pw_aff_on_domain, &data) < 0)\n\t\tdata.res = isl_union_pw_aff_free(data.res);\n\tisl_union_set_free(domain);\n\tisl_pw_aff_free(pa);\n\treturn data.res;\n}\n\n/* Return a union piecewise affine expression\n * that is equal to \"pa\" on \"domain\".\n *\n * Check that \"pa\" is a parametric expression,\n * align the parameters if needed and call\n * isl_union_pw_aff_pw_aff_on_domain_aligned.\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_pw_aff_on_domain(\n\t__isl_take isl_union_set *domain, __isl_take isl_pw_aff *pa)\n{\n\tisl_bool is_set;\n\tisl_bool equal_params;\n\tisl_space *domain_space, *pa_space;\n\n\tpa_space = isl_pw_aff_peek_space(pa);\n\tis_set = isl_space_is_set(pa_space);\n\tif (is_set < 0)\n\t\tgoto error;\n\tif (!is_set)\n\t\tisl_die(isl_pw_aff_get_ctx(pa), isl_error_invalid,\n\t\t\t\"expecting parametric expression\", goto error);\n\n\tdomain_space = isl_union_set_get_space(domain);\n\tpa_space = isl_pw_aff_get_space(pa);\n\tequal_params = isl_space_has_equal_params(domain_space, pa_space);\n\tif (equal_params >= 0 && !equal_params) {\n\t\tisl_space *space;\n\n\t\tspace = isl_space_align_params(domain_space, pa_space);\n\t\tpa = isl_pw_aff_align_params(pa, isl_space_copy(space));\n\t\tdomain = isl_union_set_align_params(domain, space);\n\t} else {\n\t\tisl_space_free(domain_space);\n\t\tisl_space_free(pa_space);\n\t}\n\n\tif (equal_params < 0)\n\t\tgoto error;\n\treturn isl_union_pw_aff_pw_aff_on_domain_aligned(domain, pa);\nerror:\n\tisl_union_set_free(domain);\n\tisl_pw_aff_free(pa);\n\treturn NULL;\n}\n\n/* Internal data structure for isl_union_pw_aff_val_on_domain.\n * \"v\" is the value that the resulting isl_union_pw_aff needs to attain.\n * \"res\" collects the results.\n */\nstruct isl_union_pw_aff_val_on_domain_data {\n\tisl_val *v;\n\tisl_union_pw_aff *res;\n};\n\n/* Construct a piecewise affine expression that is equal to data->v\n * on \"domain\" and add the result to data->res.\n */\nstatic isl_stat pw_aff_val_on_domain(__isl_take isl_set *domain, void *user)\n{\n\tstruct isl_union_pw_aff_val_on_domain_data *data = user;\n\tisl_pw_aff *pa;\n\tisl_val *v;\n\n\tv = isl_val_copy(data->v);\n\tpa = isl_pw_aff_val_on_domain(domain, v);\n\tdata->res = isl_union_pw_aff_add_pw_aff(data->res, pa);\n\n\treturn data->res ? isl_stat_ok : isl_stat_error;\n}\n\n/* Return a union piecewise affine expression\n * that is equal to \"v\" on \"domain\".\n *\n * Construct an isl_pw_aff on each of the sets in \"domain\" and\n * collect the results.\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_val_on_domain(\n\t__isl_take isl_union_set *domain, __isl_take isl_val *v)\n{\n\tstruct isl_union_pw_aff_val_on_domain_data data;\n\tisl_space *space;\n\n\tspace = isl_union_set_get_space(domain);\n\tdata.res = isl_union_pw_aff_empty(space);\n\tdata.v = v;\n\tif (isl_union_set_foreach_set(domain, &pw_aff_val_on_domain, &data) < 0)\n\t\tdata.res = isl_union_pw_aff_free(data.res);\n\tisl_union_set_free(domain);\n\tisl_val_free(v);\n\treturn data.res;\n}\n\n/* Construct a piecewise multi affine expression\n * that is equal to \"pa\" and add it to upma.\n */\nstatic isl_stat pw_multi_aff_from_pw_aff_entry(__isl_take isl_pw_aff *pa,\n\tvoid *user)\n{\n\tisl_union_pw_multi_aff **upma = user;\n\tisl_pw_multi_aff *pma;\n\n\tpma = isl_pw_multi_aff_from_pw_aff(pa);\n\t*upma = isl_union_pw_multi_aff_add_pw_multi_aff(*upma, pma);\n\n\treturn *upma ? isl_stat_ok : isl_stat_error;\n}\n\n/* Construct and return a union piecewise multi affine expression\n * that is equal to the given union piecewise affine expression.\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_from_union_pw_aff(\n\t__isl_take isl_union_pw_aff *upa)\n{\n\tisl_space *space;\n\tisl_union_pw_multi_aff *upma;\n\n\tif (!upa)\n\t\treturn NULL;\n\n\tspace = isl_union_pw_aff_get_space(upa);\n\tupma = isl_union_pw_multi_aff_empty(space);\n\n\tif (isl_union_pw_aff_foreach_pw_aff(upa,\n\t\t\t\t&pw_multi_aff_from_pw_aff_entry, &upma) < 0)\n\t\tupma = isl_union_pw_multi_aff_free(upma);\n\n\tisl_union_pw_aff_free(upa);\n\treturn upma;\n}\n\n/* Compute the set of elements in the domain of \"pa\" where it is zero and\n * add this set to \"uset\".\n */\nstatic isl_stat zero_union_set(__isl_take isl_pw_aff *pa, void *user)\n{\n\tisl_union_set **uset = (isl_union_set **)user;\n\n\t*uset = isl_union_set_add_set(*uset, isl_pw_aff_zero_set(pa));\n\n\treturn *uset ? isl_stat_ok : isl_stat_error;\n}\n\n/* Return a union set containing those elements in the domain\n * of \"upa\" where it is zero.\n */\n__isl_give isl_union_set *isl_union_pw_aff_zero_union_set(\n\t__isl_take isl_union_pw_aff *upa)\n{\n\tisl_union_set *zero;\n\n\tzero = isl_union_set_empty(isl_union_pw_aff_get_space(upa));\n\tif (isl_union_pw_aff_foreach_pw_aff(upa, &zero_union_set, &zero) < 0)\n\t\tzero = isl_union_set_free(zero);\n\n\tisl_union_pw_aff_free(upa);\n\treturn zero;\n}\n\n/* Internal data structure for isl_union_pw_aff_bind_id,\n * storing the parameter that needs to be bound and\n * the accumulated results.\n */\nstruct isl_bind_id_data {\n\tisl_id *id;\n\tisl_union_set *bound;\n};\n\n/* Bind the piecewise affine function \"pa\" to the parameter data->id,\n * adding the resulting elements in the domain where the expression\n * is equal to the parameter to data->bound.\n */\nstatic isl_stat bind_id(__isl_take isl_pw_aff *pa, void *user)\n{\n\tstruct isl_bind_id_data *data = user;\n\tisl_set *bound;\n\n\tbound = isl_pw_aff_bind_id(pa, isl_id_copy(data->id));\n\tdata->bound = isl_union_set_add_set(data->bound, bound);\n\n\treturn data->bound ? isl_stat_ok : isl_stat_error;\n}\n\n/* Bind the union piecewise affine function \"upa\" to the parameter \"id\",\n * returning the elements in the domain where the expression\n * is equal to the parameter.\n */\n__isl_give isl_union_set *isl_union_pw_aff_bind_id(\n\t__isl_take isl_union_pw_aff *upa, __isl_take isl_id *id)\n{\n\tstruct isl_bind_id_data data = { id };\n\n\tdata.bound = isl_union_set_empty(isl_union_pw_aff_get_space(upa));\n\tif (isl_union_pw_aff_foreach_pw_aff(upa, &bind_id, &data) < 0)\n\t\tdata.bound = isl_union_set_free(data.bound);\n\n\tisl_union_pw_aff_free(upa);\n\tisl_id_free(id);\n\treturn data.bound;\n}\n\n/* Internal data structure for isl_union_pw_aff_pullback_union_pw_multi_aff.\n * upma is the function that is plugged in.\n * pa is the current part of the function in which upma is plugged in.\n * res collects the results.\n */\nstruct isl_union_pw_aff_pullback_upma_data {\n\tisl_union_pw_multi_aff *upma;\n\tisl_pw_aff *pa;\n\tisl_union_pw_aff *res;\n};\n\n/* Check if \"pma\" can be plugged into data->pa.\n * If so, perform the pullback and add the result to data->res.\n */\nstatic isl_stat pa_pb_pma(__isl_take isl_pw_multi_aff *pma, void *user)\n{\n\tstruct isl_union_pw_aff_pullback_upma_data *data = user;\n\tisl_pw_aff *pa;\n\n\tif (!isl_space_tuple_is_equal(data->pa->dim, isl_dim_in,\n\t\t\t\t pma->dim, isl_dim_out)) {\n\t\tisl_pw_multi_aff_free(pma);\n\t\treturn isl_stat_ok;\n\t}\n\n\tpa = isl_pw_aff_copy(data->pa);\n\tpa = isl_pw_aff_pullback_pw_multi_aff(pa, pma);\n\n\tdata->res = isl_union_pw_aff_add_pw_aff(data->res, pa);\n\n\treturn data->res ? isl_stat_ok : isl_stat_error;\n}\n\n/* Check if any of the elements of data->upma can be plugged into pa,\n * add if so add the result to data->res.\n */\nstatic isl_stat upa_pb_upma(__isl_take isl_pw_aff *pa, void *user)\n{\n\tstruct isl_union_pw_aff_pullback_upma_data *data = user;\n\tisl_stat r;\n\n\tdata->pa = pa;\n\tr = isl_union_pw_multi_aff_foreach_pw_multi_aff(data->upma,\n\t\t\t\t   &pa_pb_pma, data);\n\tisl_pw_aff_free(pa);\n\n\treturn r;\n}\n\n/* Compute the pullback of \"upa\" by the function represented by \"upma\".\n * In other words, plug in \"upma\" in \"upa\".  The result contains\n * expressions defined over the domain space of \"upma\".\n *\n * Run over all pairs of elements in \"upa\" and \"upma\", perform\n * the pullback when appropriate and collect the results.\n * If the hash value were based on the domain space rather than\n * the function space, then we could run through all elements\n * of \"upma\" and directly pick out the corresponding element of \"upa\".\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_pullback_union_pw_multi_aff(\n\t__isl_take isl_union_pw_aff *upa,\n\t__isl_take isl_union_pw_multi_aff *upma)\n{\n\tstruct isl_union_pw_aff_pullback_upma_data data = { NULL, NULL };\n\tisl_space *space;\n\n\tspace = isl_union_pw_multi_aff_get_space(upma);\n\tupa = isl_union_pw_aff_align_params(upa, space);\n\tspace = isl_union_pw_aff_get_space(upa);\n\tupma = isl_union_pw_multi_aff_align_params(upma, space);\n\n\tif (!upa || !upma)\n\t\tgoto error;\n\n\tdata.upma = upma;\n\tdata.res = isl_union_pw_aff_alloc_same_size(upa);\n\tif (isl_union_pw_aff_foreach_pw_aff(upa, &upa_pb_upma, &data) < 0)\n\t\tdata.res = isl_union_pw_aff_free(data.res);\n\n\tisl_union_pw_aff_free(upa);\n\tisl_union_pw_multi_aff_free(upma);\n\treturn data.res;\nerror:\n\tisl_union_pw_aff_free(upa);\n\tisl_union_pw_multi_aff_free(upma);\n\treturn NULL;\n}\n\n#undef BASE\n#define BASE union_pw_aff\n#undef DOMBASE\n#define DOMBASE union_set\n\n#include <isl_multi_explicit_domain.c>\n#include <isl_multi_union_pw_aff_explicit_domain.c>\n#include <isl_multi_templ.c>\n#include <isl_multi_apply_set.c>\n#include <isl_multi_apply_union_set.c>\n#include <isl_multi_arith_templ.c>\n#include <isl_multi_bind_templ.c>\n#include <isl_multi_coalesce.c>\n#include <isl_multi_dim_id_templ.c>\n#include <isl_multi_floor.c>\n#include <isl_multi_from_base_templ.c>\n#include <isl_multi_gist.c>\n#include <isl_multi_align_set.c>\n#include <isl_multi_align_union_set.c>\n#include <isl_multi_intersect.c>\n#include <isl_multi_nan_templ.c>\n#include <isl_multi_tuple_id_templ.c>\n#include <isl_multi_union_add_templ.c>\n\n/* Does \"mupa\" have a non-trivial explicit domain?\n *\n * The explicit domain, if present, is trivial if it represents\n * an (obviously) universe parameter set.\n */\nisl_bool isl_multi_union_pw_aff_has_non_trivial_domain(\n\t__isl_keep isl_multi_union_pw_aff *mupa)\n{\n\tisl_bool is_params, trivial;\n\tisl_set *set;\n\n\tif (!mupa)\n\t\treturn isl_bool_error;\n\tif (!isl_multi_union_pw_aff_has_explicit_domain(mupa))\n\t\treturn isl_bool_false;\n\tis_params = isl_union_set_is_params(mupa->u.dom);\n\tif (is_params < 0 || !is_params)\n\t\treturn isl_bool_not(is_params);\n\tset = isl_set_from_union_set(isl_union_set_copy(mupa->u.dom));\n\ttrivial = isl_set_plain_is_universe(set);\n\tisl_set_free(set);\n\treturn isl_bool_not(trivial);\n}\n\n/* Construct a multiple union piecewise affine expression\n * in the given space with value zero in each of the output dimensions.\n *\n * Since there is no canonical zero value for\n * a union piecewise affine expression, we can only construct\n * a zero-dimensional \"zero\" value.\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_zero(\n\t__isl_take isl_space *space)\n{\n\tisl_bool params;\n\tisl_size dim;\n\n\tif (!space)\n\t\treturn NULL;\n\n\tparams = isl_space_is_params(space);\n\tif (params < 0)\n\t\tgoto error;\n\tif (params)\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"expecting proper set space\", goto error);\n\tif (!isl_space_is_set(space))\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"expecting set space\", goto error);\n\tdim = isl_space_dim(space, isl_dim_out);\n\tif (dim < 0)\n\t\tgoto error;\n\tif (dim != 0)\n\t\tisl_die(isl_space_get_ctx(space), isl_error_invalid,\n\t\t\t\"expecting 0D space\", goto error);\n\n\treturn isl_multi_union_pw_aff_alloc(space);\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Construct and return a multi union piecewise affine expression\n * that is equal to the given multi affine expression.\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_from_multi_aff(\n\t__isl_take isl_multi_aff *ma)\n{\n\tisl_multi_pw_aff *mpa;\n\n\tmpa = isl_multi_pw_aff_from_multi_aff(ma);\n\treturn isl_multi_union_pw_aff_from_multi_pw_aff(mpa);\n}\n\n/* Construct and return a multi union piecewise affine expression\n * that is equal to the given multi piecewise affine expression.\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_from_multi_pw_aff(\n\t__isl_take isl_multi_pw_aff *mpa)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_multi_union_pw_aff *mupa;\n\n\tn = isl_multi_pw_aff_dim(mpa, isl_dim_out);\n\tif (n < 0)\n\t\tmpa = isl_multi_pw_aff_free(mpa);\n\tif (!mpa)\n\t\treturn NULL;\n\n\tspace = isl_multi_pw_aff_get_space(mpa);\n\tspace = isl_space_range(space);\n\tmupa = isl_multi_union_pw_aff_alloc(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\t\tisl_union_pw_aff *upa;\n\n\t\tpa = isl_multi_pw_aff_get_pw_aff(mpa, i);\n\t\tupa = isl_union_pw_aff_from_pw_aff(pa);\n\t\tmupa = isl_multi_union_pw_aff_restore_check_space(mupa, i, upa);\n\t}\n\n\tisl_multi_pw_aff_free(mpa);\n\n\treturn mupa;\n}\n\n/* Extract the range space of \"pma\" and assign it to *space.\n * If *space has already been set (through a previous call to this function),\n * then check that the range space is the same.\n */\nstatic isl_stat extract_space(__isl_take isl_pw_multi_aff *pma, void *user)\n{\n\tisl_space **space = user;\n\tisl_space *pma_space;\n\tisl_bool equal;\n\n\tpma_space = isl_space_range(isl_pw_multi_aff_get_space(pma));\n\tisl_pw_multi_aff_free(pma);\n\n\tif (!pma_space)\n\t\treturn isl_stat_error;\n\tif (!*space) {\n\t\t*space = pma_space;\n\t\treturn isl_stat_ok;\n\t}\n\n\tequal = isl_space_is_equal(pma_space, *space);\n\tisl_space_free(pma_space);\n\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(isl_space_get_ctx(*space), isl_error_invalid,\n\t\t\t\"range spaces not the same\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Construct and return a multi union piecewise affine expression\n * that is equal to the given union piecewise multi affine expression.\n *\n * In order to be able to perform the conversion, the input\n * needs to be non-empty and may only involve a single range space.\n *\n * If the resulting multi union piecewise affine expression has\n * an explicit domain, then assign it the domain of the input.\n * In other cases, the domain is stored in the individual elements.\n */\n__isl_give isl_multi_union_pw_aff *\nisl_multi_union_pw_aff_from_union_pw_multi_aff(\n\t__isl_take isl_union_pw_multi_aff *upma)\n{\n\tisl_space *space = NULL;\n\tisl_multi_union_pw_aff *mupa;\n\tint i;\n\tisl_size n;\n\n\tn = isl_union_pw_multi_aff_n_pw_multi_aff(upma);\n\tif (n < 0)\n\t\tgoto error;\n\tif (n == 0)\n\t\tisl_die(isl_union_pw_multi_aff_get_ctx(upma), isl_error_invalid,\n\t\t\t\"cannot extract range space from empty input\",\n\t\t\tgoto error);\n\tif (isl_union_pw_multi_aff_foreach_pw_multi_aff(upma, &extract_space,\n\t\t\t\t\t\t\t&space) < 0)\n\t\tgoto error;\n\n\tif (!space)\n\t\tgoto error;\n\n\tn = isl_space_dim(space, isl_dim_set);\n\tif (n < 0)\n\t\tspace = isl_space_free(space);\n\tmupa = isl_multi_union_pw_aff_alloc(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_union_pw_aff *upa;\n\n\t\tupa = isl_union_pw_multi_aff_get_union_pw_aff(upma, i);\n\t\tmupa = isl_multi_union_pw_aff_set_union_pw_aff(mupa, i, upa);\n\t}\n\tif (isl_multi_union_pw_aff_has_explicit_domain(mupa)) {\n\t\tisl_union_set *dom;\n\t\tisl_union_pw_multi_aff *copy;\n\n\t\tcopy = isl_union_pw_multi_aff_copy(upma);\n\t\tdom = isl_union_pw_multi_aff_domain(copy);\n\t\tmupa = isl_multi_union_pw_aff_intersect_domain(mupa, dom);\n\t}\n\n\tisl_union_pw_multi_aff_free(upma);\n\treturn mupa;\nerror:\n\tisl_space_free(space);\n\tisl_union_pw_multi_aff_free(upma);\n\treturn NULL;\n}\n\n/* Try and create an isl_multi_union_pw_aff that is equivalent\n * to the given isl_union_map.\n * The isl_union_map is required to be single-valued in each space.\n * Moreover, it cannot be empty and all range spaces need to be the same.\n * Otherwise, an error is produced.\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_from_union_map(\n\t__isl_take isl_union_map *umap)\n{\n\tisl_union_pw_multi_aff *upma;\n\n\tupma = isl_union_pw_multi_aff_from_union_map(umap);\n\treturn isl_multi_union_pw_aff_from_union_pw_multi_aff(upma);\n}\n\n/* Return a multiple union piecewise affine expression\n * that is equal to \"mv\" on \"domain\", assuming \"domain\" and \"mv\"\n * have been aligned.\n *\n * If the resulting multi union piecewise affine expression has\n * an explicit domain, then assign it the input domain.\n * In other cases, the domain is stored in the individual elements.\n */\nstatic __isl_give isl_multi_union_pw_aff *\nisl_multi_union_pw_aff_multi_val_on_domain_aligned(\n\t__isl_take isl_union_set *domain, __isl_take isl_multi_val *mv)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_multi_union_pw_aff *mupa;\n\n\tn = isl_multi_val_dim(mv, isl_dim_set);\n\tif (!domain || n < 0)\n\t\tgoto error;\n\n\tspace = isl_multi_val_get_space(mv);\n\tmupa = isl_multi_union_pw_aff_alloc(space);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_val *v;\n\t\tisl_union_pw_aff *upa;\n\n\t\tv = isl_multi_val_get_val(mv, i);\n\t\tupa = isl_union_pw_aff_val_on_domain(isl_union_set_copy(domain),\n\t\t\t\t\t\t\tv);\n\t\tmupa = isl_multi_union_pw_aff_set_union_pw_aff(mupa, i, upa);\n\t}\n\tif (isl_multi_union_pw_aff_has_explicit_domain(mupa))\n\t\tmupa = isl_multi_union_pw_aff_intersect_domain(mupa,\n\t\t\t\t\t\t    isl_union_set_copy(domain));\n\n\tisl_union_set_free(domain);\n\tisl_multi_val_free(mv);\n\treturn mupa;\nerror:\n\tisl_union_set_free(domain);\n\tisl_multi_val_free(mv);\n\treturn NULL;\n}\n\n/* Return a multiple union piecewise affine expression\n * that is equal to \"mv\" on \"domain\".\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_multi_val_on_domain(\n\t__isl_take isl_union_set *domain, __isl_take isl_multi_val *mv)\n{\n\tisl_bool equal_params;\n\n\tif (!domain || !mv)\n\t\tgoto error;\n\tequal_params = isl_space_has_equal_params(domain->dim, mv->space);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (equal_params)\n\t\treturn isl_multi_union_pw_aff_multi_val_on_domain_aligned(\n\t\t\t\t\t\t\t\t    domain, mv);\n\tdomain = isl_union_set_align_params(domain,\n\t\t\t\t\t\tisl_multi_val_get_space(mv));\n\tmv = isl_multi_val_align_params(mv, isl_union_set_get_space(domain));\n\treturn isl_multi_union_pw_aff_multi_val_on_domain_aligned(domain, mv);\nerror:\n\tisl_union_set_free(domain);\n\tisl_multi_val_free(mv);\n\treturn NULL;\n}\n\n/* Return a multiple union piecewise affine expression\n * that is equal to \"ma\" on \"domain\".\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_multi_aff_on_domain(\n\t__isl_take isl_union_set *domain, __isl_take isl_multi_aff *ma)\n{\n\tisl_pw_multi_aff *pma;\n\n\tpma = isl_pw_multi_aff_from_multi_aff(ma);\n\treturn isl_multi_union_pw_aff_pw_multi_aff_on_domain(domain, pma);\n}\n\n/* Return a multiple union piecewise affine expression\n * that is equal to \"pma\" on \"domain\", assuming \"domain\" and \"pma\"\n * have been aligned.\n *\n * If the resulting multi union piecewise affine expression has\n * an explicit domain, then assign it the input domain.\n * In other cases, the domain is stored in the individual elements.\n */\nstatic __isl_give isl_multi_union_pw_aff *\nisl_multi_union_pw_aff_pw_multi_aff_on_domain_aligned(\n\t__isl_take isl_union_set *domain, __isl_take isl_pw_multi_aff *pma)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_multi_union_pw_aff *mupa;\n\n\tn = isl_pw_multi_aff_dim(pma, isl_dim_set);\n\tif (!domain || n < 0)\n\t\tgoto error;\n\tspace = isl_pw_multi_aff_get_space(pma);\n\tmupa = isl_multi_union_pw_aff_alloc(space);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\t\tisl_union_pw_aff *upa;\n\n\t\tpa = isl_pw_multi_aff_get_pw_aff(pma, i);\n\t\tupa = isl_union_pw_aff_pw_aff_on_domain(\n\t\t\t\t\t    isl_union_set_copy(domain), pa);\n\t\tmupa = isl_multi_union_pw_aff_set_union_pw_aff(mupa, i, upa);\n\t}\n\tif (isl_multi_union_pw_aff_has_explicit_domain(mupa))\n\t\tmupa = isl_multi_union_pw_aff_intersect_domain(mupa,\n\t\t\t\t\t\t    isl_union_set_copy(domain));\n\n\tisl_union_set_free(domain);\n\tisl_pw_multi_aff_free(pma);\n\treturn mupa;\nerror:\n\tisl_union_set_free(domain);\n\tisl_pw_multi_aff_free(pma);\n\treturn NULL;\n}\n\n/* Return a multiple union piecewise affine expression\n * that is equal to \"pma\" on \"domain\".\n */\n__isl_give isl_multi_union_pw_aff *\nisl_multi_union_pw_aff_pw_multi_aff_on_domain(__isl_take isl_union_set *domain,\n\t__isl_take isl_pw_multi_aff *pma)\n{\n\tisl_bool equal_params;\n\tisl_space *space;\n\n\tspace = isl_pw_multi_aff_peek_space(pma);\n\tequal_params = isl_union_set_space_has_equal_params(domain, space);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (equal_params)\n\t\treturn isl_multi_union_pw_aff_pw_multi_aff_on_domain_aligned(\n\t\t\t\t\t\t\t\tdomain, pma);\n\tdomain = isl_union_set_align_params(domain,\n\t\t\t\t\t    isl_pw_multi_aff_get_space(pma));\n\tpma = isl_pw_multi_aff_align_params(pma,\n\t\t\t\t\t    isl_union_set_get_space(domain));\n\treturn isl_multi_union_pw_aff_pw_multi_aff_on_domain_aligned(domain,\n\t\t\t\t\t\t\t\t\tpma);\nerror:\n\tisl_union_set_free(domain);\n\tisl_pw_multi_aff_free(pma);\n\treturn NULL;\n}\n\n/* Return a union set containing those elements in the domains\n * of the elements of \"mupa\" where they are all zero.\n *\n * If there are no elements, then simply return the entire domain.\n */\n__isl_give isl_union_set *isl_multi_union_pw_aff_zero_union_set(\n\t__isl_take isl_multi_union_pw_aff *mupa)\n{\n\tint i;\n\tisl_size n;\n\tisl_union_pw_aff *upa;\n\tisl_union_set *zero;\n\n\tn = isl_multi_union_pw_aff_dim(mupa, isl_dim_set);\n\tif (n < 0)\n\t\tmupa = isl_multi_union_pw_aff_free(mupa);\n\tif (!mupa)\n\t\treturn NULL;\n\n\tif (n == 0)\n\t\treturn isl_multi_union_pw_aff_domain(mupa);\n\n\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, 0);\n\tzero = isl_union_pw_aff_zero_union_set(upa);\n\n\tfor (i = 1; i < n; ++i) {\n\t\tisl_union_set *zero_i;\n\n\t\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, i);\n\t\tzero_i = isl_union_pw_aff_zero_union_set(upa);\n\n\t\tzero = isl_union_set_intersect(zero, zero_i);\n\t}\n\n\tisl_multi_union_pw_aff_free(mupa);\n\treturn zero;\n}\n\n/* Construct a union map mapping the shared domain\n * of the union piecewise affine expressions to the range of \"mupa\"\n * in the special case of a 0D multi union piecewise affine expression.\n *\n * Construct a map between the explicit domain of \"mupa\" and\n * the range space.\n * Note that this assumes that the domain consists of explicit elements.\n */\nstatic __isl_give isl_union_map *isl_union_map_from_multi_union_pw_aff_0D(\n\t__isl_take isl_multi_union_pw_aff *mupa)\n{\n\tisl_bool is_params;\n\tisl_space *space;\n\tisl_union_set *dom, *ran;\n\n\tspace = isl_multi_union_pw_aff_get_space(mupa);\n\tdom = isl_multi_union_pw_aff_domain(mupa);\n\tran = isl_union_set_from_set(isl_set_universe(space));\n\n\tis_params = isl_union_set_is_params(dom);\n\tif (is_params < 0)\n\t\tdom = isl_union_set_free(dom);\n\telse if (is_params)\n\t\tisl_die(isl_union_set_get_ctx(dom), isl_error_invalid,\n\t\t\t\"cannot create union map from expression without \"\n\t\t\t\"explicit domain elements\",\n\t\t\tdom = isl_union_set_free(dom));\n\n\treturn isl_union_map_from_domain_and_range(dom, ran);\n}\n\n/* Construct a union map mapping the shared domain\n * of the union piecewise affine expressions to the range of \"mupa\"\n * with each dimension in the range equated to the\n * corresponding union piecewise affine expression.\n *\n * If the input is zero-dimensional, then construct a mapping\n * from its explicit domain.\n */\n__isl_give isl_union_map *isl_union_map_from_multi_union_pw_aff(\n\t__isl_take isl_multi_union_pw_aff *mupa)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_union_map *umap;\n\tisl_union_pw_aff *upa;\n\n\tn = isl_multi_union_pw_aff_dim(mupa, isl_dim_set);\n\tif (n < 0)\n\t\tmupa = isl_multi_union_pw_aff_free(mupa);\n\tif (!mupa)\n\t\treturn NULL;\n\n\tif (n == 0)\n\t\treturn isl_union_map_from_multi_union_pw_aff_0D(mupa);\n\n\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, 0);\n\tumap = isl_union_map_from_union_pw_aff(upa);\n\n\tfor (i = 1; i < n; ++i) {\n\t\tisl_union_map *umap_i;\n\n\t\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, i);\n\t\tumap_i = isl_union_map_from_union_pw_aff(upa);\n\t\tumap = isl_union_map_flat_range_product(umap, umap_i);\n\t}\n\n\tspace = isl_multi_union_pw_aff_get_space(mupa);\n\tumap = isl_union_map_reset_range_space(umap, space);\n\n\tisl_multi_union_pw_aff_free(mupa);\n\treturn umap;\n}\n\n/* Internal data structure for isl_union_pw_multi_aff_reset_range_space.\n * \"range\" is the space from which to set the range space.\n * \"res\" collects the results.\n */\nstruct isl_union_pw_multi_aff_reset_range_space_data {\n\tisl_space *range;\n\tisl_union_pw_multi_aff *res;\n};\n\n/* Replace the range space of \"pma\" by the range space of data->range and\n * add the result to data->res.\n */\nstatic isl_stat reset_range_space(__isl_take isl_pw_multi_aff *pma, void *user)\n{\n\tstruct isl_union_pw_multi_aff_reset_range_space_data *data = user;\n\tisl_space *space;\n\n\tspace = isl_pw_multi_aff_get_space(pma);\n\tspace = isl_space_domain(space);\n\tspace = isl_space_extend_domain_with_range(space,\n\t\t\t\t\t\tisl_space_copy(data->range));\n\tpma = isl_pw_multi_aff_reset_space(pma, space);\n\tdata->res = isl_union_pw_multi_aff_add_pw_multi_aff(data->res, pma);\n\n\treturn data->res ? isl_stat_ok : isl_stat_error;\n}\n\n/* Replace the range space of all the piecewise affine expressions in \"upma\" by\n * the range space of \"space\".\n *\n * This assumes that all these expressions have the same output dimension.\n *\n * Since the spaces of the expressions change, so do their hash values.\n * We therefore need to create a new isl_union_pw_multi_aff.\n * Note that the hash value is currently computed based on the entire\n * space even though there can only be a single expression with a given\n * domain space.\n */\nstatic __isl_give isl_union_pw_multi_aff *\nisl_union_pw_multi_aff_reset_range_space(\n\t__isl_take isl_union_pw_multi_aff *upma, __isl_take isl_space *space)\n{\n\tstruct isl_union_pw_multi_aff_reset_range_space_data data = { space };\n\tisl_space *space_upma;\n\n\tspace_upma = isl_union_pw_multi_aff_get_space(upma);\n\tdata.res = isl_union_pw_multi_aff_empty(space_upma);\n\tif (isl_union_pw_multi_aff_foreach_pw_multi_aff(upma,\n\t\t\t\t\t&reset_range_space, &data) < 0)\n\t\tdata.res = isl_union_pw_multi_aff_free(data.res);\n\n\tisl_space_free(space);\n\tisl_union_pw_multi_aff_free(upma);\n\treturn data.res;\n}\n\n/* Construct and return a union piecewise multi affine expression\n * that is equal to the given multi union piecewise affine expression,\n * in the special case of a 0D multi union piecewise affine expression.\n *\n * Construct a union piecewise multi affine expression\n * on top of the explicit domain of the input.\n */\n__isl_give isl_union_pw_multi_aff *\nisl_union_pw_multi_aff_from_multi_union_pw_aff_0D(\n\t__isl_take isl_multi_union_pw_aff *mupa)\n{\n\tisl_space *space;\n\tisl_multi_val *mv;\n\tisl_union_set *domain;\n\n\tspace = isl_multi_union_pw_aff_get_space(mupa);\n\tmv = isl_multi_val_zero(space);\n\tdomain = isl_multi_union_pw_aff_domain(mupa);\n\treturn isl_union_pw_multi_aff_multi_val_on_domain(domain, mv);\n}\n\n/* Construct and return a union piecewise multi affine expression\n * that is equal to the given multi union piecewise affine expression.\n *\n * If the input is zero-dimensional, then\n * construct a union piecewise multi affine expression\n * on top of the explicit domain of the input.\n */\n__isl_give isl_union_pw_multi_aff *\nisl_union_pw_multi_aff_from_multi_union_pw_aff(\n\t__isl_take isl_multi_union_pw_aff *mupa)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_union_pw_multi_aff *upma;\n\tisl_union_pw_aff *upa;\n\n\tn = isl_multi_union_pw_aff_dim(mupa, isl_dim_set);\n\tif (n < 0)\n\t\tmupa = isl_multi_union_pw_aff_free(mupa);\n\tif (!mupa)\n\t\treturn NULL;\n\n\tif (n == 0)\n\t\treturn isl_union_pw_multi_aff_from_multi_union_pw_aff_0D(mupa);\n\n\tspace = isl_multi_union_pw_aff_get_space(mupa);\n\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, 0);\n\tupma = isl_union_pw_multi_aff_from_union_pw_aff(upa);\n\n\tfor (i = 1; i < n; ++i) {\n\t\tisl_union_pw_multi_aff *upma_i;\n\n\t\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, i);\n\t\tupma_i = isl_union_pw_multi_aff_from_union_pw_aff(upa);\n\t\tupma = isl_union_pw_multi_aff_flat_range_product(upma, upma_i);\n\t}\n\n\tupma = isl_union_pw_multi_aff_reset_range_space(upma, space);\n\n\tisl_multi_union_pw_aff_free(mupa);\n\treturn upma;\n}\n\n/* Intersect the range of \"mupa\" with \"range\",\n * in the special case where \"mupa\" is 0D.\n *\n * Intersect the domain of \"mupa\" with the constraints on the parameters\n * of \"range\".\n */\nstatic __isl_give isl_multi_union_pw_aff *mupa_intersect_range_0D(\n\t__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_set *range)\n{\n\trange = isl_set_params(range);\n\tmupa = isl_multi_union_pw_aff_intersect_params(mupa, range);\n\treturn mupa;\n}\n\n/* Intersect the range of \"mupa\" with \"range\".\n * That is, keep only those domain elements that have a function value\n * in \"range\".\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_intersect_range(\n\t__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_set *range)\n{\n\tisl_union_pw_multi_aff *upma;\n\tisl_union_set *domain;\n\tisl_space *space;\n\tisl_size n;\n\tint match;\n\n\tn = isl_multi_union_pw_aff_dim(mupa, isl_dim_set);\n\tif (n < 0 || !range)\n\t\tgoto error;\n\n\tspace = isl_set_get_space(range);\n\tmatch = isl_space_tuple_is_equal(mupa->space, isl_dim_set,\n\t\t\t\t\tspace, isl_dim_set);\n\tisl_space_free(space);\n\tif (match < 0)\n\t\tgoto error;\n\tif (!match)\n\t\tisl_die(isl_multi_union_pw_aff_get_ctx(mupa), isl_error_invalid,\n\t\t\t\"space don't match\", goto error);\n\tif (n == 0)\n\t\treturn mupa_intersect_range_0D(mupa, range);\n\n\tupma = isl_union_pw_multi_aff_from_multi_union_pw_aff(\n\t\t\t\t\tisl_multi_union_pw_aff_copy(mupa));\n\tdomain = isl_union_set_from_set(range);\n\tdomain = isl_union_set_preimage_union_pw_multi_aff(domain, upma);\n\tmupa = isl_multi_union_pw_aff_intersect_domain(mupa, domain);\n\n\treturn mupa;\nerror:\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_set_free(range);\n\treturn NULL;\n}\n\n/* Return the shared domain of the elements of \"mupa\",\n * in the special case where \"mupa\" is zero-dimensional.\n *\n * Return the explicit domain of \"mupa\".\n * Note that this domain may be a parameter set, either\n * because \"mupa\" is meant to live in a set space or\n * because no explicit domain has been set.\n */\n__isl_give isl_union_set *isl_multi_union_pw_aff_domain_0D(\n\t__isl_take isl_multi_union_pw_aff *mupa)\n{\n\tisl_union_set *dom;\n\n\tdom = isl_multi_union_pw_aff_get_explicit_domain(mupa);\n\tisl_multi_union_pw_aff_free(mupa);\n\n\treturn dom;\n}\n\n/* Return the shared domain of the elements of \"mupa\".\n *\n * If \"mupa\" is zero-dimensional, then return its explicit domain.\n */\n__isl_give isl_union_set *isl_multi_union_pw_aff_domain(\n\t__isl_take isl_multi_union_pw_aff *mupa)\n{\n\tint i;\n\tisl_size n;\n\tisl_union_pw_aff *upa;\n\tisl_union_set *dom;\n\n\tn = isl_multi_union_pw_aff_dim(mupa, isl_dim_set);\n\tif (n < 0)\n\t\tmupa = isl_multi_union_pw_aff_free(mupa);\n\tif (!mupa)\n\t\treturn NULL;\n\n\tif (n == 0)\n\t\treturn isl_multi_union_pw_aff_domain_0D(mupa);\n\n\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, 0);\n\tdom = isl_union_pw_aff_domain(upa);\n\tfor (i = 1; i < n; ++i) {\n\t\tisl_union_set *dom_i;\n\n\t\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, i);\n\t\tdom_i = isl_union_pw_aff_domain(upa);\n\t\tdom = isl_union_set_intersect(dom, dom_i);\n\t}\n\n\tisl_multi_union_pw_aff_free(mupa);\n\treturn dom;\n}\n\n/* Apply \"aff\" to \"mupa\".  The space of \"mupa\" is equal to the domain of \"aff\".\n * In particular, the spaces have been aligned.\n * The result is defined over the shared domain of the elements of \"mupa\"\n *\n * We first extract the parametric constant part of \"aff\" and\n * define that over the shared domain.\n * Then we iterate over all input dimensions of \"aff\" and add the corresponding\n * multiples of the elements of \"mupa\".\n * Finally, we consider the integer divisions, calling the function\n * recursively to obtain an isl_union_pw_aff corresponding to the\n * integer division argument.\n */\nstatic __isl_give isl_union_pw_aff *multi_union_pw_aff_apply_aff(\n\t__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_aff *aff)\n{\n\tint i;\n\tisl_size n_in, n_div;\n\tisl_union_pw_aff *upa;\n\tisl_union_set *uset;\n\tisl_val *v;\n\tisl_aff *cst;\n\n\tn_in = isl_aff_dim(aff, isl_dim_in);\n\tn_div = isl_aff_dim(aff, isl_dim_div);\n\tif (n_in < 0 || n_div < 0)\n\t\tgoto error;\n\n\tuset = isl_multi_union_pw_aff_domain(isl_multi_union_pw_aff_copy(mupa));\n\tcst = isl_aff_copy(aff);\n\tcst = isl_aff_drop_dims(cst, isl_dim_div, 0, n_div);\n\tcst = isl_aff_drop_dims(cst, isl_dim_in, 0, n_in);\n\tcst = isl_aff_project_domain_on_params(cst);\n\tupa = isl_union_pw_aff_aff_on_domain(uset, cst);\n\n\tfor (i = 0; i < n_in; ++i) {\n\t\tisl_union_pw_aff *upa_i;\n\n\t\tif (!isl_aff_involves_dims(aff, isl_dim_in, i, 1))\n\t\t\tcontinue;\n\t\tv = isl_aff_get_coefficient_val(aff, isl_dim_in, i);\n\t\tupa_i = isl_multi_union_pw_aff_get_union_pw_aff(mupa, i);\n\t\tupa_i = isl_union_pw_aff_scale_val(upa_i, v);\n\t\tupa = isl_union_pw_aff_add(upa, upa_i);\n\t}\n\n\tfor (i = 0; i < n_div; ++i) {\n\t\tisl_aff *div;\n\t\tisl_union_pw_aff *upa_i;\n\n\t\tif (!isl_aff_involves_dims(aff, isl_dim_div, i, 1))\n\t\t\tcontinue;\n\t\tdiv = isl_aff_get_div(aff, i);\n\t\tupa_i = multi_union_pw_aff_apply_aff(\n\t\t\t\t\tisl_multi_union_pw_aff_copy(mupa), div);\n\t\tupa_i = isl_union_pw_aff_floor(upa_i);\n\t\tv = isl_aff_get_coefficient_val(aff, isl_dim_div, i);\n\t\tupa_i = isl_union_pw_aff_scale_val(upa_i, v);\n\t\tupa = isl_union_pw_aff_add(upa, upa_i);\n\t}\n\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_aff_free(aff);\n\n\treturn upa;\nerror:\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Apply \"aff\" to \"mupa\".  The space of \"mupa\" needs to be compatible\n * with the domain of \"aff\".\n * Furthermore, the dimension of this space needs to be greater than zero.\n * The result is defined over the shared domain of the elements of \"mupa\"\n *\n * We perform these checks and then hand over control to\n * multi_union_pw_aff_apply_aff.\n */\n__isl_give isl_union_pw_aff *isl_multi_union_pw_aff_apply_aff(\n\t__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_aff *aff)\n{\n\tisl_size dim;\n\tisl_space *space1, *space2;\n\tisl_bool equal;\n\n\tmupa = isl_multi_union_pw_aff_align_params(mupa,\n\t\t\t\t\t\tisl_aff_get_space(aff));\n\taff = isl_aff_align_params(aff, isl_multi_union_pw_aff_get_space(mupa));\n\tif (!mupa || !aff)\n\t\tgoto error;\n\n\tspace1 = isl_multi_union_pw_aff_get_space(mupa);\n\tspace2 = isl_aff_get_domain_space(aff);\n\tequal = isl_space_is_equal(space1, space2);\n\tisl_space_free(space1);\n\tisl_space_free(space2);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (!equal)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\tdim = isl_aff_dim(aff, isl_dim_in);\n\tif (dim < 0)\n\t\tgoto error;\n\tif (dim == 0)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"cannot determine domains\", goto error);\n\n\treturn multi_union_pw_aff_apply_aff(mupa, aff);\nerror:\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_aff_free(aff);\n\treturn NULL;\n}\n\n/* Apply \"ma\" to \"mupa\", in the special case where \"mupa\" is 0D.\n * The space of \"mupa\" is known to be compatible with the domain of \"ma\".\n *\n * Construct an isl_multi_union_pw_aff that is equal to \"ma\"\n * on the domain of \"mupa\".\n */\nstatic __isl_give isl_multi_union_pw_aff *mupa_apply_multi_aff_0D(\n\t__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_multi_aff *ma)\n{\n\tisl_union_set *dom;\n\n\tdom = isl_multi_union_pw_aff_domain(mupa);\n\tma = isl_multi_aff_project_domain_on_params(ma);\n\n\treturn isl_multi_union_pw_aff_multi_aff_on_domain(dom, ma);\n}\n\n/* Apply \"ma\" to \"mupa\".  The space of \"mupa\" needs to be compatible\n * with the domain of \"ma\".\n * The result is defined over the shared domain of the elements of \"mupa\"\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_apply_multi_aff(\n\t__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_multi_aff *ma)\n{\n\tisl_space *space1, *space2;\n\tisl_multi_union_pw_aff *res;\n\tisl_bool equal;\n\tint i;\n\tisl_size n_in, n_out;\n\n\tmupa = isl_multi_union_pw_aff_align_params(mupa,\n\t\t\t\t\t\tisl_multi_aff_get_space(ma));\n\tma = isl_multi_aff_align_params(ma,\n\t\t\t\t\tisl_multi_union_pw_aff_get_space(mupa));\n\tn_in = isl_multi_aff_dim(ma, isl_dim_in);\n\tn_out = isl_multi_aff_dim(ma, isl_dim_out);\n\tif (!mupa || n_in < 0 || n_out < 0)\n\t\tgoto error;\n\n\tspace1 = isl_multi_union_pw_aff_get_space(mupa);\n\tspace2 = isl_multi_aff_get_domain_space(ma);\n\tequal = isl_space_is_equal(space1, space2);\n\tisl_space_free(space1);\n\tisl_space_free(space2);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (!equal)\n\t\tisl_die(isl_multi_aff_get_ctx(ma), isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\tif (n_in == 0)\n\t\treturn mupa_apply_multi_aff_0D(mupa, ma);\n\n\tspace1 = isl_space_range(isl_multi_aff_get_space(ma));\n\tres = isl_multi_union_pw_aff_alloc(space1);\n\n\tfor (i = 0; i < n_out; ++i) {\n\t\tisl_aff *aff;\n\t\tisl_union_pw_aff *upa;\n\n\t\taff = isl_multi_aff_get_aff(ma, i);\n\t\tupa = multi_union_pw_aff_apply_aff(\n\t\t\t\t\tisl_multi_union_pw_aff_copy(mupa), aff);\n\t\tres = isl_multi_union_pw_aff_set_union_pw_aff(res, i, upa);\n\t}\n\n\tisl_multi_aff_free(ma);\n\tisl_multi_union_pw_aff_free(mupa);\n\treturn res;\nerror:\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_multi_aff_free(ma);\n\treturn NULL;\n}\n\n/* Apply \"pa\" to \"mupa\", in the special case where \"mupa\" is 0D.\n * The space of \"mupa\" is known to be compatible with the domain of \"pa\".\n *\n * Construct an isl_multi_union_pw_aff that is equal to \"pa\"\n * on the domain of \"mupa\".\n */\nstatic __isl_give isl_union_pw_aff *isl_multi_union_pw_aff_apply_pw_aff_0D(\n\t__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_pw_aff *pa)\n{\n\tisl_union_set *dom;\n\n\tdom = isl_multi_union_pw_aff_domain(mupa);\n\tpa = isl_pw_aff_project_domain_on_params(pa);\n\n\treturn isl_union_pw_aff_pw_aff_on_domain(dom, pa);\n}\n\n/* Apply \"pa\" to \"mupa\".  The space of \"mupa\" needs to be compatible\n * with the domain of \"pa\".\n * Furthermore, the dimension of this space needs to be greater than zero.\n * The result is defined over the shared domain of the elements of \"mupa\"\n */\n__isl_give isl_union_pw_aff *isl_multi_union_pw_aff_apply_pw_aff(\n\t__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_pw_aff *pa)\n{\n\tint i;\n\tisl_bool equal;\n\tisl_size n_in;\n\tisl_space *space, *space2;\n\tisl_union_pw_aff *upa;\n\n\tmupa = isl_multi_union_pw_aff_align_params(mupa,\n\t\t\t\t\t\tisl_pw_aff_get_space(pa));\n\tpa = isl_pw_aff_align_params(pa,\n\t\t\t\t    isl_multi_union_pw_aff_get_space(mupa));\n\tif (!mupa || !pa)\n\t\tgoto error;\n\n\tspace = isl_multi_union_pw_aff_get_space(mupa);\n\tspace2 = isl_pw_aff_get_domain_space(pa);\n\tequal = isl_space_is_equal(space, space2);\n\tisl_space_free(space);\n\tisl_space_free(space2);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (!equal)\n\t\tisl_die(isl_pw_aff_get_ctx(pa), isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\tn_in = isl_pw_aff_dim(pa, isl_dim_in);\n\tif (n_in < 0)\n\t\tgoto error;\n\tif (n_in == 0)\n\t\treturn isl_multi_union_pw_aff_apply_pw_aff_0D(mupa, pa);\n\n\tspace = isl_space_params(isl_multi_union_pw_aff_get_space(mupa));\n\tupa = isl_union_pw_aff_empty(space);\n\n\tfor (i = 0; i < pa->n; ++i) {\n\t\tisl_aff *aff;\n\t\tisl_set *domain;\n\t\tisl_multi_union_pw_aff *mupa_i;\n\t\tisl_union_pw_aff *upa_i;\n\n\t\tmupa_i = isl_multi_union_pw_aff_copy(mupa);\n\t\tdomain = isl_set_copy(pa->p[i].set);\n\t\tmupa_i = isl_multi_union_pw_aff_intersect_range(mupa_i, domain);\n\t\taff = isl_aff_copy(pa->p[i].aff);\n\t\tupa_i = multi_union_pw_aff_apply_aff(mupa_i, aff);\n\t\tupa = isl_union_pw_aff_union_add(upa, upa_i);\n\t}\n\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_pw_aff_free(pa);\n\treturn upa;\nerror:\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_pw_aff_free(pa);\n\treturn NULL;\n}\n\n/* Apply \"pma\" to \"mupa\", in the special case where \"mupa\" is 0D.\n * The space of \"mupa\" is known to be compatible with the domain of \"pma\".\n *\n * Construct an isl_multi_union_pw_aff that is equal to \"pma\"\n * on the domain of \"mupa\".\n */\nstatic __isl_give isl_multi_union_pw_aff *mupa_apply_pw_multi_aff_0D(\n\t__isl_take isl_multi_union_pw_aff *mupa,\n\t__isl_take isl_pw_multi_aff *pma)\n{\n\tisl_union_set *dom;\n\n\tdom = isl_multi_union_pw_aff_domain(mupa);\n\tpma = isl_pw_multi_aff_project_domain_on_params(pma);\n\n\treturn isl_multi_union_pw_aff_pw_multi_aff_on_domain(dom, pma);\n}\n\n/* Apply \"pma\" to \"mupa\".  The space of \"mupa\" needs to be compatible\n * with the domain of \"pma\".\n * The result is defined over the shared domain of the elements of \"mupa\"\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_apply_pw_multi_aff(\n\t__isl_take isl_multi_union_pw_aff *mupa,\n\t__isl_take isl_pw_multi_aff *pma)\n{\n\tisl_space *space1, *space2;\n\tisl_multi_union_pw_aff *res;\n\tisl_bool equal;\n\tint i;\n\tisl_size n_in, n_out;\n\n\tmupa = isl_multi_union_pw_aff_align_params(mupa,\n\t\t\t\t\tisl_pw_multi_aff_get_space(pma));\n\tpma = isl_pw_multi_aff_align_params(pma,\n\t\t\t\t\tisl_multi_union_pw_aff_get_space(mupa));\n\tif (!mupa || !pma)\n\t\tgoto error;\n\n\tspace1 = isl_multi_union_pw_aff_get_space(mupa);\n\tspace2 = isl_pw_multi_aff_get_domain_space(pma);\n\tequal = isl_space_is_equal(space1, space2);\n\tisl_space_free(space1);\n\tisl_space_free(space2);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (!equal)\n\t\tisl_die(isl_pw_multi_aff_get_ctx(pma), isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\tn_in = isl_pw_multi_aff_dim(pma, isl_dim_in);\n\tn_out = isl_pw_multi_aff_dim(pma, isl_dim_out);\n\tif (n_in < 0 || n_out < 0)\n\t\tgoto error;\n\tif (n_in == 0)\n\t\treturn mupa_apply_pw_multi_aff_0D(mupa, pma);\n\n\tspace1 = isl_space_range(isl_pw_multi_aff_get_space(pma));\n\tres = isl_multi_union_pw_aff_alloc(space1);\n\n\tfor (i = 0; i < n_out; ++i) {\n\t\tisl_pw_aff *pa;\n\t\tisl_union_pw_aff *upa;\n\n\t\tpa = isl_pw_multi_aff_get_pw_aff(pma, i);\n\t\tupa = isl_multi_union_pw_aff_apply_pw_aff(\n\t\t\t\t\tisl_multi_union_pw_aff_copy(mupa), pa);\n\t\tres = isl_multi_union_pw_aff_set_union_pw_aff(res, i, upa);\n\t}\n\n\tisl_pw_multi_aff_free(pma);\n\tisl_multi_union_pw_aff_free(mupa);\n\treturn res;\nerror:\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_pw_multi_aff_free(pma);\n\treturn NULL;\n}\n\n/* Replace the explicit domain of \"mupa\" by its preimage under \"upma\".\n * If the explicit domain only keeps track of constraints on the parameters,\n * then only update those constraints.\n */\nstatic __isl_give isl_multi_union_pw_aff *preimage_explicit_domain(\n\t__isl_take isl_multi_union_pw_aff *mupa,\n\t__isl_keep isl_union_pw_multi_aff *upma)\n{\n\tisl_bool is_params;\n\n\tif (isl_multi_union_pw_aff_check_has_explicit_domain(mupa) < 0)\n\t\treturn isl_multi_union_pw_aff_free(mupa);\n\n\tmupa = isl_multi_union_pw_aff_cow(mupa);\n\tif (!mupa)\n\t\treturn NULL;\n\n\tis_params = isl_union_set_is_params(mupa->u.dom);\n\tif (is_params < 0)\n\t\treturn isl_multi_union_pw_aff_free(mupa);\n\n\tupma = isl_union_pw_multi_aff_copy(upma);\n\tif (is_params)\n\t\tmupa->u.dom = isl_union_set_intersect_params(mupa->u.dom,\n\t\t    isl_union_set_params(isl_union_pw_multi_aff_domain(upma)));\n\telse\n\t\tmupa->u.dom = isl_union_set_preimage_union_pw_multi_aff(\n\t\t\t\t\t\t\t    mupa->u.dom, upma);\n\tif (!mupa->u.dom)\n\t\treturn isl_multi_union_pw_aff_free(mupa);\n\treturn mupa;\n}\n\n/* Compute the pullback of \"mupa\" by the function represented by \"upma\".\n * In other words, plug in \"upma\" in \"mupa\".  The result contains\n * expressions defined over the domain space of \"upma\".\n *\n * Run over all elements of \"mupa\" and plug in \"upma\" in each of them.\n *\n * If \"mupa\" has an explicit domain, then it is this domain\n * that needs to undergo a pullback instead, i.e., a preimage.\n */\n__isl_give isl_multi_union_pw_aff *\nisl_multi_union_pw_aff_pullback_union_pw_multi_aff(\n\t__isl_take isl_multi_union_pw_aff *mupa,\n\t__isl_take isl_union_pw_multi_aff *upma)\n{\n\tint i;\n\tisl_size n;\n\n\tmupa = isl_multi_union_pw_aff_align_params(mupa,\n\t\t\t\t    isl_union_pw_multi_aff_get_space(upma));\n\tupma = isl_union_pw_multi_aff_align_params(upma,\n\t\t\t\t    isl_multi_union_pw_aff_get_space(mupa));\n\tmupa = isl_multi_union_pw_aff_cow(mupa);\n\tn = isl_multi_union_pw_aff_dim(mupa, isl_dim_set);\n\tif (n < 0 || !upma)\n\t\tgoto error;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_union_pw_aff *upa;\n\n\t\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, i);\n\t\tupa = isl_union_pw_aff_pullback_union_pw_multi_aff(upa,\n\t\t\t\t\t    isl_union_pw_multi_aff_copy(upma));\n\t\tmupa = isl_multi_union_pw_aff_set_union_pw_aff(mupa, i, upa);\n\t}\n\n\tif (isl_multi_union_pw_aff_has_explicit_domain(mupa))\n\t\tmupa = preimage_explicit_domain(mupa, upma);\n\n\tisl_union_pw_multi_aff_free(upma);\n\treturn mupa;\nerror:\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_union_pw_multi_aff_free(upma);\n\treturn NULL;\n}\n\n/* Extract the sequence of elements in \"mupa\" with domain space \"space\"\n * (ignoring parameters).\n *\n * For the elements of \"mupa\" that are not defined on the specified space,\n * the corresponding element in the result is empty.\n */\n__isl_give isl_multi_pw_aff *isl_multi_union_pw_aff_extract_multi_pw_aff(\n\t__isl_keep isl_multi_union_pw_aff *mupa, __isl_take isl_space *space)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space_mpa;\n\tisl_multi_pw_aff *mpa;\n\n\tn = isl_multi_union_pw_aff_dim(mupa, isl_dim_set);\n\tif (n < 0 || !space)\n\t\tgoto error;\n\n\tspace_mpa = isl_multi_union_pw_aff_get_space(mupa);\n\tspace = isl_space_replace_params(space, space_mpa);\n\tspace_mpa = isl_space_map_from_domain_and_range(isl_space_copy(space),\n\t\t\t\t\t\t\tspace_mpa);\n\tmpa = isl_multi_pw_aff_alloc(space_mpa);\n\n\tspace = isl_space_from_domain(space);\n\tspace = isl_space_add_dims(space, isl_dim_out, 1);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_union_pw_aff *upa;\n\t\tisl_pw_aff *pa;\n\n\t\tupa = isl_multi_union_pw_aff_get_union_pw_aff(mupa, i);\n\t\tpa = isl_union_pw_aff_extract_pw_aff(upa,\n\t\t\t\t\t\t\tisl_space_copy(space));\n\t\tmpa = isl_multi_pw_aff_set_pw_aff(mpa, i, pa);\n\t\tisl_union_pw_aff_free(upa);\n\t}\n\n\tisl_space_free(space);\n\treturn mpa;\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Data structure that specifies how isl_union_pw_multi_aff_un_op\n * should modify the base expressions in the input.\n *\n * If \"filter\" is not NULL, then only the base expressions that satisfy \"filter\"\n * are taken into account.\n * \"fn\" is applied to each entry in the input.\n */\nstruct isl_union_pw_multi_aff_un_op_control {\n\tisl_bool (*filter)(__isl_keep isl_pw_multi_aff *part);\n\t__isl_give isl_pw_multi_aff *(*fn)(__isl_take isl_pw_multi_aff *pma);\n};\n\n/* Wrapper for isl_union_pw_multi_aff_un_op filter functions (which do not take\n * a second argument) for use as an isl_union_pw_multi_aff_transform\n * filter function (which does take a second argument).\n * Simply call control->filter without the second argument.\n */\nstatic isl_bool isl_union_pw_multi_aff_un_op_filter_drop_user(\n\t__isl_take isl_pw_multi_aff *pma, void *user)\n{\n\tstruct isl_union_pw_multi_aff_un_op_control *control = user;\n\n\treturn control->filter(pma);\n}\n\n/* Wrapper for isl_union_pw_multi_aff_un_op base functions (which do not take\n * a second argument) for use as an isl_union_pw_multi_aff_transform\n * base function (which does take a second argument).\n * Simply call control->fn without the second argument.\n */\nstatic __isl_give isl_pw_multi_aff *isl_union_pw_multi_aff_un_op_drop_user(\n\t__isl_take isl_pw_multi_aff *pma, void *user)\n{\n\tstruct isl_union_pw_multi_aff_un_op_control *control = user;\n\n\treturn control->fn(pma);\n}\n\n/* Construct an isl_union_pw_multi_aff that is obtained by\n * modifying \"upma\" according to \"control\".\n *\n * isl_union_pw_multi_aff_transform performs essentially\n * the same operation, but takes a filter and a callback function\n * of a different form (with an extra argument).\n * Call isl_union_pw_multi_aff_transform with wrappers\n * that remove this extra argument.\n */\nstatic __isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_un_op(\n\t__isl_take isl_union_pw_multi_aff *upma,\n\tstruct isl_union_pw_multi_aff_un_op_control *control)\n{\n\tstruct isl_union_pw_multi_aff_transform_control t_control = {\n\t\t.filter = &isl_union_pw_multi_aff_un_op_filter_drop_user,\n\t\t.filter_user = control,\n\t\t.fn = &isl_union_pw_multi_aff_un_op_drop_user,\n\t\t.fn_user = control,\n\t};\n\n\treturn isl_union_pw_multi_aff_transform(upma, &t_control);\n}\n\n/* For each function in \"upma\" of the form A -> [B -> C],\n * extract the function A -> B and collect the results.\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_range_factor_domain(\n\t__isl_take isl_union_pw_multi_aff *upma)\n{\n\tstruct isl_union_pw_multi_aff_un_op_control control = {\n\t\t.filter = &isl_pw_multi_aff_range_is_wrapping,\n\t\t.fn = &isl_pw_multi_aff_range_factor_domain,\n\t};\n\treturn isl_union_pw_multi_aff_un_op(upma, &control);\n}\n\n/* For each function in \"upma\" of the form A -> [B -> C],\n * extract the function A -> C and collect the results.\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_range_factor_range(\n\t__isl_take isl_union_pw_multi_aff *upma)\n{\n\tstruct isl_union_pw_multi_aff_un_op_control control = {\n\t\t.filter = &isl_pw_multi_aff_range_is_wrapping,\n\t\t.fn = &isl_pw_multi_aff_range_factor_range,\n\t};\n\treturn isl_union_pw_multi_aff_un_op(upma, &control);\n}\n\n/* Evaluate the affine function \"aff\" in the void point \"pnt\".\n * In particular, return the value NaN.\n */\nstatic __isl_give isl_val *eval_void(__isl_take isl_aff *aff,\n\t__isl_take isl_point *pnt)\n{\n\tisl_ctx *ctx;\n\n\tctx = isl_point_get_ctx(pnt);\n\tisl_aff_free(aff);\n\tisl_point_free(pnt);\n\treturn isl_val_nan(ctx);\n}\n\n/* Evaluate the affine expression \"aff\"\n * in the coordinates (with denominator) \"pnt\".\n */\nstatic __isl_give isl_val *eval(__isl_keep isl_vec *aff,\n\t__isl_keep isl_vec *pnt)\n{\n\tisl_int n, d;\n\tisl_ctx *ctx;\n\tisl_val *v;\n\n\tif (!aff || !pnt)\n\t\treturn NULL;\n\n\tctx = isl_vec_get_ctx(aff);\n\tisl_int_init(n);\n\tisl_int_init(d);\n\tisl_seq_inner_product(aff->el + 1, pnt->el, pnt->size, &n);\n\tisl_int_mul(d, aff->el[0], pnt->el[0]);\n\tv = isl_val_rat_from_isl_int(ctx, n, d);\n\tv = isl_val_normalize(v);\n\tisl_int_clear(n);\n\tisl_int_clear(d);\n\n\treturn v;\n}\n\n/* Check that the domain space of \"aff\" is equal to \"space\".\n */\nstatic isl_stat isl_aff_check_has_domain_space(__isl_keep isl_aff *aff,\n\t__isl_keep isl_space *space)\n{\n\tisl_bool ok;\n\n\tok = isl_space_is_equal(isl_aff_peek_domain_space(aff), space);\n\tif (ok < 0)\n\t\treturn isl_stat_error;\n\tif (!ok)\n\t\tisl_die(isl_aff_get_ctx(aff), isl_error_invalid,\n\t\t\t\"incompatible spaces\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Evaluate the affine function \"aff\" in \"pnt\".\n */\n__isl_give isl_val *isl_aff_eval(__isl_take isl_aff *aff,\n\t__isl_take isl_point *pnt)\n{\n\tisl_bool is_void;\n\tisl_val *v;\n\tisl_local_space *ls;\n\n\tif (isl_aff_check_has_domain_space(aff, isl_point_peek_space(pnt)) < 0)\n\t\tgoto error;\n\tis_void = isl_point_is_void(pnt);\n\tif (is_void < 0)\n\t\tgoto error;\n\tif (is_void)\n\t\treturn eval_void(aff, pnt);\n\n\tls = isl_aff_get_domain_local_space(aff);\n\tpnt = isl_local_space_lift_point(ls, pnt);\n\n\tv = eval(aff->v, isl_point_peek_vec(pnt));\n\n\tisl_aff_free(aff);\n\tisl_point_free(pnt);\n\n\treturn v;\nerror:\n\tisl_aff_free(aff);\n\tisl_point_free(pnt);\n\treturn NULL;\n}\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/ctx.h", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n */\n\n#ifndef ISL_CTX_H\n#define ISL_CTX_H\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <isl/arg.h>\n\n#ifndef __isl_give\n#define __isl_give\n#endif\n#ifndef __isl_take\n#define __isl_take\n#endif\n#ifndef __isl_keep\n#define __isl_keep\n#endif\n#ifndef __isl_null\n#define __isl_null\n#endif\n#ifndef __isl_export\n#define __isl_export\n#endif\n#ifndef __isl_overload\n#define __isl_overload\n#endif\n#ifndef __isl_constructor\n#define __isl_constructor\n#endif\n#ifndef __isl_subclass\n#define __isl_subclass(super)\n#endif\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/* Nearly all isa functions require a struct isl_ctx allocated using\n * isl_ctx_alloc.  This ctx contains (or will contain) options that\n * control the behavior of the library and some caches.\n *\n * An object allocated within a given ctx should never be used inside\n * another ctx.  Functions for moving objects from one ctx to another\n * will be added as the need arises.\n *\n * A given context should only be used inside a single thread.\n * A global context for synchronization between different threads\n * as well as functions for moving a context to a different thread\n * will be added as the need arises.\n *\n * If anything goes wrong (out of memory, failed assertion), then\n * the library will currently simply abort.  This will be made\n * configurable in the future.\n * Users of the library should expect functions that return\n * a pointer to a structure, to return NULL, indicating failure.\n * Any function accepting a pointer to a structure will treat\n * a NULL argument as a failure, resulting in the function freeing\n * the remaining structures (if any) and returning NULL itself\n * (in case of pointer return type).\n * The only exception is the isl_ctx argument, which should never be NULL.\n */\nstruct isl_stats {\n\tlong\tgbr_solved_lps;\n};\nenum isl_error {\n\tisl_error_none = 0,\n\tisl_error_abort,\n\tisl_error_alloc,\n\tisl_error_unknown,\n\tisl_error_internal,\n\tisl_error_invalid,\n\tisl_error_quota,\n\tisl_error_unsupported\n};\ntypedef enum {\n\tisl_stat_error = -1,\n\tisl_stat_ok = 0\n} isl_stat;\nisl_stat isl_stat_non_null(void *obj);\ntypedef enum {\n\tisl_bool_error = -1,\n\tisl_bool_false = 0,\n\tisl_bool_true = 1\n} isl_bool;\nisl_bool isl_bool_not(isl_bool b);\nisl_bool isl_bool_ok(int b);\ntypedef int\tisl_size;\n#define isl_size_error\t((int) -1)\nstruct isl_ctx;\ntypedef struct isl_ctx isl_ctx;\n\n/* Some helper macros */\n\n#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)\n#define ISL_DEPRECATED\t__attribute__((__deprecated__))\n#else\n#define ISL_DEPRECATED\n#endif\n\n#define ISL_FL_INIT(l, f)   (l) = (f)               /* Specific flags location. */\n#define ISL_FL_SET(l, f)    ((l) |= (f))\n#define ISL_FL_CLR(l, f)    ((l) &= ~(f))\n#define ISL_FL_ISSET(l, f)  (!!((l) & (f)))\n\n#define ISL_F_INIT(p, f)    ISL_FL_INIT((p)->flags, f)  /* Structure element flags. */\n#define ISL_F_SET(p, f)     ISL_FL_SET((p)->flags, f)\n#define ISL_F_CLR(p, f)     ISL_FL_CLR((p)->flags, f)\n#define ISL_F_ISSET(p, f)   ISL_FL_ISSET((p)->flags, f)\n\nvoid *isl_malloc_or_die(isl_ctx *ctx, size_t size);\nvoid *isl_calloc_or_die(isl_ctx *ctx, size_t nmemb, size_t size);\nvoid *isl_realloc_or_die(isl_ctx *ctx, void *ptr, size_t size);\n\n#define isl_alloc(ctx,type,size)\t((type *)isl_malloc_or_die(ctx, size))\n#define isl_calloc(ctx,type,size)\t((type *)isl_calloc_or_die(ctx,\\\n\t\t\t\t\t\t\t\t    1, size))\n#define isl_realloc(ctx,ptr,type,size)\t((type *)isl_realloc_or_die(ctx,\\\n\t\t\t\t\t\t\t\t    ptr, size))\n#define isl_alloc_type(ctx,type)\tisl_alloc(ctx,type,sizeof(type))\n#define isl_calloc_type(ctx,type)\tisl_calloc(ctx,type,sizeof(type))\n#define isl_realloc_type(ctx,ptr,type)\tisl_realloc(ctx,ptr,type,sizeof(type))\n#define isl_alloc_array(ctx,type,n)\tisl_alloc(ctx,type,(n)*sizeof(type))\n#define isl_calloc_array(ctx,type,n)\t((type *)isl_calloc_or_die(ctx,\\\n\t\t\t\t\t\t\t    n, sizeof(type)))\n#define isl_realloc_array(ctx,ptr,type,n) \\\n\t\t\t\t    isl_realloc(ctx,ptr,type,(n)*sizeof(type))\n\n#define isl_die(ctx,errno,msg,code)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tisl_handle_error(ctx, errno, msg, __FILE__, __LINE__);\t\\\n\t\tcode;\t\t\t\t\t\t\t\\\n\t} while (0)\n\nvoid isl_handle_error(isl_ctx *ctx, enum isl_error error, const char *msg,\n\tconst char *file, int line);\n\n#define isl_assert4(ctx,test,code,errno)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (test)\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tisl_die(ctx, errno, \"Assertion \\\"\" #test \"\\\" failed\", code);\t\\\n\t} while (0)\n#define isl_assert(ctx,test,code)\t\t\t\t\t\\\n\tisl_assert4(ctx,test,code,isl_error_unknown)\n\n#define isl_min(a,b)\t\t\t((a < b) ? (a) : (b))\n\n/* struct isl_ctx functions */\n\nstruct isl_options *isl_ctx_options(isl_ctx *ctx);\n\nisl_ctx *isl_ctx_alloc_with_options(struct isl_args *args,\n\t__isl_take void *opt);\nisl_ctx *isl_ctx_alloc(void);\nvoid *isl_ctx_peek_options(isl_ctx *ctx, struct isl_args *args);\nint isl_ctx_parse_options(isl_ctx *ctx, int argc, char **argv, unsigned flags);\nvoid isl_ctx_ref(struct isl_ctx *ctx);\nvoid isl_ctx_deref(struct isl_ctx *ctx);\nvoid isl_ctx_free(isl_ctx *ctx);\n\nvoid isl_ctx_abort(isl_ctx *ctx);\nvoid isl_ctx_resume(isl_ctx *ctx);\nint isl_ctx_aborted(isl_ctx *ctx);\n\nvoid isl_ctx_set_max_operations(isl_ctx *ctx, unsigned long max_operations);\nunsigned long isl_ctx_get_max_operations(isl_ctx *ctx);\nvoid isl_ctx_reset_operations(isl_ctx *ctx);\n\n#define ISL_ARG_CTX_DECL(prefix,st,args)\t\t\t\t\\\nst *isl_ctx_peek_ ## prefix(isl_ctx *ctx);\n\n#define ISL_ARG_CTX_DEF(prefix,st,args)\t\t\t\t\t\\\nst *isl_ctx_peek_ ## prefix(isl_ctx *ctx)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (st *)isl_ctx_peek_options(ctx, &(args));\t\t\\\n}\n\n#define ISL_CTX_GET_INT_DEF(prefix,st,args,field)\t\t\t\\\nint prefix ## _get_ ## field(isl_ctx *ctx)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tst *options;\t\t\t\t\t\t\t\\\n\toptions = isl_ctx_peek_ ## prefix(ctx);\t\t\t\t\\\n\tif (!options)\t\t\t\t\t\t\t\\\n\t\tisl_die(ctx, isl_error_invalid,\t\t\t\t\\\n\t\t\t\"isl_ctx does not reference \" #prefix,\t\t\\\n\t\t\treturn -1);\t\t\t\t\t\\\n\treturn options->field;\t\t\t\t\t\t\\\n}\n\n#define ISL_CTX_SET_INT_DEF(prefix,st,args,field)\t\t\t\\\nisl_stat prefix ## _set_ ## field(isl_ctx *ctx, int val)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tst *options;\t\t\t\t\t\t\t\\\n\toptions = isl_ctx_peek_ ## prefix(ctx);\t\t\t\t\\\n\tif (!options)\t\t\t\t\t\t\t\\\n\t\tisl_die(ctx, isl_error_invalid,\t\t\t\t\\\n\t\t\t\"isl_ctx does not reference \" #prefix,\t\t\\\n\t\t\treturn isl_stat_error);\t\t\t\t\\\n\toptions->field = val;\t\t\t\t\t\t\\\n\treturn isl_stat_ok;\t\t\t\t\t\t\\\n}\n\n#define ISL_CTX_GET_STR_DEF(prefix,st,args,field)\t\t\t\\\nconst char *prefix ## _get_ ## field(isl_ctx *ctx)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tst *options;\t\t\t\t\t\t\t\\\n\toptions = isl_ctx_peek_ ## prefix(ctx);\t\t\t\t\\\n\tif (!options)\t\t\t\t\t\t\t\\\n\t\tisl_die(ctx, isl_error_invalid,\t\t\t\t\\\n\t\t\t\"isl_ctx does not reference \" #prefix,\t\t\\\n\t\t\treturn NULL);\t\t\t\t\t\\\n\treturn options->field;\t\t\t\t\t\t\\\n}\n\n#define ISL_CTX_SET_STR_DEF(prefix,st,args,field)\t\t\t\\\nisl_stat prefix ## _set_ ## field(isl_ctx *ctx, const char *val)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tst *options;\t\t\t\t\t\t\t\\\n\toptions = isl_ctx_peek_ ## prefix(ctx);\t\t\t\t\\\n\tif (!options)\t\t\t\t\t\t\t\\\n\t\tisl_die(ctx, isl_error_invalid,\t\t\t\t\\\n\t\t\t\"isl_ctx does not reference \" #prefix,\t\t\\\n\t\t\treturn isl_stat_error);\t\t\t\t\\\n\tif (!val)\t\t\t\t\t\t\t\\\n\t\treturn isl_stat_error;\t\t\t\t\t\\\n\tfree(options->field);\t\t\t\t\t\t\\\n\toptions->field = strdup(val);\t\t\t\t\t\\\n\tif (!options->field)\t\t\t\t\t\t\\\n\t\treturn isl_stat_error;\t\t\t\t\t\\\n\treturn isl_stat_ok;\t\t\t\t\t\t\\\n}\n\n#define ISL_CTX_GET_BOOL_DEF(prefix,st,args,field)\t\t\t\\\n\tISL_CTX_GET_INT_DEF(prefix,st,args,field)\n\n#define ISL_CTX_SET_BOOL_DEF(prefix,st,args,field)\t\t\t\\\n\tISL_CTX_SET_INT_DEF(prefix,st,args,field)\n\n#define ISL_CTX_GET_CHOICE_DEF(prefix,st,args,field)\t\t\t\\\n\tISL_CTX_GET_INT_DEF(prefix,st,args,field)\n\n#define ISL_CTX_SET_CHOICE_DEF(prefix,st,args,field)\t\t\t\\\n\tISL_CTX_SET_INT_DEF(prefix,st,args,field)\n\nenum isl_error isl_ctx_last_error(isl_ctx *ctx);\nconst char *isl_ctx_last_error_msg(isl_ctx *ctx);\nconst char *isl_ctx_last_error_file(isl_ctx *ctx);\nint isl_ctx_last_error_line(isl_ctx *ctx);\nvoid isl_ctx_reset_error(isl_ctx *ctx);\nvoid isl_ctx_set_error(isl_ctx *ctx, enum isl_error error);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_pw_templ.c", "content": "/*\n * Copyright 2010-2011 INRIA Saclay\n * Copyright 2011      Sven Verdoolaege\n * Copyright 2012-2014 Ecole Normale Superieure\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,\n * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,\n * 91893 Orsay, France\n * and Ecole Normale Superieure, 45 rue d\u2019Ulm, 75230 Paris, France\n */\n\n#include <isl/id.h>\n#include <isl/aff.h>\n#include <isl_sort.h>\n#include <isl_val_private.h>\n\n#include <isl_pw_macro.h>\n\n#include \"opt_type.h\"\n\n__isl_give PW *FN(PW,alloc_size)(__isl_take isl_space *space\n\tOPT_TYPE_PARAM, int n)\n{\n\tisl_ctx *ctx;\n\tstruct PW *pw;\n\n\tif (!space)\n\t\treturn NULL;\n\tctx = isl_space_get_ctx(space);\n\tisl_assert(ctx, n >= 0, goto error);\n\tpw = isl_alloc(ctx, struct PW,\n\t\t\tsizeof(struct PW) + (n - 1) * sizeof(S(PW,piece)));\n\tif (!pw)\n\t\tgoto error;\n\n\tpw->ref = 1;\n\tOPT_SET_TYPE(pw->, type);\n\tpw->size = n;\n\tpw->n = 0;\n\tpw->dim = space;\n\treturn pw;\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n__isl_give PW *FN(PW,ZERO)(__isl_take isl_space *space OPT_TYPE_PARAM)\n{\n\treturn FN(PW,alloc_size)(space OPT_TYPE_ARG(NO_LOC), 0);\n}\n\n/* Add a piece with domain \"set\" and base expression \"el\"\n * to the piecewise expression \"pw\".\n *\n * Do this independently of the values of \"set\" and \"el\",\n * such that this function can be used by isl_pw_*_dup.\n */\n__isl_give PW *FN(PW,add_dup_piece)(__isl_take PW *pw,\n\t__isl_take isl_set *set, __isl_take EL *el)\n{\n\tisl_ctx *ctx;\n\tisl_space *el_dim = NULL;\n\n\tif (!pw || !set || !el)\n\t\tgoto error;\n\n\tctx = isl_set_get_ctx(set);\n\tif (!OPT_EQUAL_TYPES(pw->, el->))\n\t\tisl_die(ctx, isl_error_invalid, \"fold types don't match\",\n\t\t\tgoto error);\n\tel_dim = FN(EL,get_space(el));\n\tisl_assert(ctx, isl_space_is_equal(pw->dim, el_dim), goto error);\n\tisl_assert(ctx, pw->n < pw->size, goto error);\n\n\tpw->p[pw->n].set = set;\n\tpw->p[pw->n].FIELD = el;\n\tpw->n++;\n\t\n\tisl_space_free(el_dim);\n\treturn pw;\nerror:\n\tisl_space_free(el_dim);\n\tFN(PW,free)(pw);\n\tisl_set_free(set);\n\tFN(EL,free)(el);\n\treturn NULL;\n}\n\n/* Add a piece with domain \"set\" and base expression \"el\"\n * to the piecewise expression \"pw\", provided the domain\n * is not obviously empty and the base expression\n * is not equal to the default value.\n */\n__isl_give PW *FN(PW,add_piece)(__isl_take PW *pw,\n\t__isl_take isl_set *set, __isl_take EL *el)\n{\n\tisl_bool skip;\n\n\tskip = isl_set_plain_is_empty(set);\n\tif (skip >= 0 && !skip)\n\t\tskip = FN(EL,EL_IS_ZERO)(el);\n\tif (skip >= 0 && !skip)\n\t\treturn FN(PW,add_dup_piece)(pw, set, el);\n\n\tisl_set_free(set);\n\tFN(EL,free)(el);\n\tif (skip < 0)\n\t\treturn FN(PW,free)(pw);\n\treturn pw;\n}\n\n/* Does the space of \"set\" correspond to that of the domain of \"el\".\n */\nstatic isl_bool FN(PW,compatible_domain)(__isl_keep EL *el,\n\t__isl_keep isl_set *set)\n{\n\tisl_bool ok;\n\tisl_space *el_space, *set_space;\n\n\tif (!set || !el)\n\t\treturn isl_bool_error;\n\tset_space = isl_set_get_space(set);\n\tel_space = FN(EL,get_space)(el);\n\tok = isl_space_is_domain_internal(set_space, el_space);\n\tisl_space_free(el_space);\n\tisl_space_free(set_space);\n\treturn ok;\n}\n\n/* Check that the space of \"set\" corresponds to that of the domain of \"el\".\n */\nstatic isl_stat FN(PW,check_compatible_domain)(__isl_keep EL *el,\n\t__isl_keep isl_set *set)\n{\n\tisl_bool ok;\n\n\tok = FN(PW,compatible_domain)(el, set);\n\tif (ok < 0)\n\t\treturn isl_stat_error;\n\tif (!ok)\n\t\tisl_die(isl_set_get_ctx(set), isl_error_invalid,\n\t\t\t\"incompatible spaces\", return isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\n__isl_give PW *FN(PW,alloc)(OPT_TYPE_PARAM_FIRST\n\t__isl_take isl_set *set, __isl_take EL *el)\n{\n\tPW *pw;\n\n\tif (FN(PW,check_compatible_domain)(el, set) < 0)\n\t\tgoto error;\n\n\tpw = FN(PW,alloc_size)(FN(EL,get_space)(el) OPT_TYPE_ARG(NO_LOC), 1);\n\n\treturn FN(PW,add_piece)(pw, set, el);\nerror:\n\tisl_set_free(set);\n\tFN(EL,free)(el);\n\treturn NULL;\n}\n\n__isl_give PW *FN(PW,dup)(__isl_keep PW *pw)\n{\n\tint i;\n\tPW *dup;\n\n\tif (!pw)\n\t\treturn NULL;\n\n\tdup = FN(PW,alloc_size)(isl_space_copy(pw->dim)\n\t\t\t\tOPT_TYPE_ARG(pw->), pw->n);\n\tif (!dup)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pw->n; ++i)\n\t\tdup = FN(PW,add_dup_piece)(dup, isl_set_copy(pw->p[i].set),\n\t\t\t\t\t    FN(EL,copy)(pw->p[i].FIELD));\n\n\treturn dup;\n}\n\n__isl_give PW *FN(PW,cow)(__isl_take PW *pw)\n{\n\tif (!pw)\n\t\treturn NULL;\n\n\tif (pw->ref == 1)\n\t\treturn pw;\n\tpw->ref--;\n\treturn FN(PW,dup)(pw);\n}\n\n__isl_give PW *FN(PW,copy)(__isl_keep PW *pw)\n{\n\tif (!pw)\n\t\treturn NULL;\n\n\tpw->ref++;\n\treturn pw;\n}\n\n__isl_null PW *FN(PW,free)(__isl_take PW *pw)\n{\n\tint i;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (--pw->ref > 0)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tisl_set_free(pw->p[i].set);\n\t\tFN(EL,free)(pw->p[i].FIELD);\n\t}\n\tisl_space_free(pw->dim);\n\tfree(pw);\n\n\treturn NULL;\n}\n\n/* Create a piecewise expression with the given base expression on a universe\n * domain.\n */\nstatic __isl_give PW *FN(FN(FN(PW,from),BASE),type_base)(__isl_take EL *el\n\tOPT_TYPE_PARAM)\n{\n\tisl_set *dom = isl_set_universe(FN(EL,get_domain_space)(el));\n\treturn FN(PW,alloc)(OPT_TYPE_ARG_FIRST(NO_LOC) dom, el);\n}\n\n/* Create a piecewise expression with the given base expression on a universe\n * domain.\n *\n * If the default value of this piecewise type is zero and\n * if \"el\" is effectively zero, then create an empty piecewise expression\n * instead.\n */\nstatic __isl_give PW *FN(FN(FN(PW,from),BASE),type)(__isl_take EL *el\n\tOPT_TYPE_PARAM)\n{\n\tisl_bool is_zero;\n\tisl_space *space;\n\n\tif (!DEFAULT_IS_ZERO)\n\t\treturn FN(FN(FN(PW,from),BASE),type_base)(el\n\t\t\t\t\t\t\tOPT_TYPE_ARG(NO_LOC));\n\tis_zero = FN(EL,EL_IS_ZERO)(el);\n\tif (is_zero < 0)\n\t\tgoto error;\n\tif (!is_zero)\n\t\treturn FN(FN(FN(PW,from),BASE),type_base)(el\n\t\t\t\t\t\t\tOPT_TYPE_ARG(NO_LOC));\n\tspace = FN(EL,get_space)(el);\n\tFN(EL,free)(el);\n\treturn FN(PW,ZERO)(space OPT_TYPE_ARG(NO_LOC));\nerror:\n\tFN(EL,free)(el);\n\treturn NULL;\n}\n\n#ifdef HAS_TYPE\n/* Create a piecewise expression with the given base expression on a universe\n * domain.\n *\n * Pass along the type as an extra argument for improved uniformity\n * with piecewise types that do not have a fold type.\n */\n__isl_give PW *FN(FN(PW,from),BASE)(__isl_take EL *el)\n{\n\tenum isl_fold type = FN(EL,get_type)(el);\n\treturn FN(FN(FN(PW,from),BASE),type)(el, type);\n}\n#else\n__isl_give PW *FN(FN(PW,from),BASE)(__isl_take EL *el)\n{\n\treturn FN(FN(FN(PW,from),BASE),type)(el);\n}\n#endif\n\nconst char *FN(PW,get_dim_name)(__isl_keep PW *pw, enum isl_dim_type type,\n\tunsigned pos)\n{\n\treturn pw ? isl_space_get_dim_name(pw->dim, type, pos) : NULL;\n}\n\nisl_bool FN(PW,has_dim_id)(__isl_keep PW *pw, enum isl_dim_type type,\n\tunsigned pos)\n{\n\treturn pw ? isl_space_has_dim_id(pw->dim, type, pos) : isl_bool_error;\n}\n\n__isl_give isl_id *FN(PW,get_dim_id)(__isl_keep PW *pw, enum isl_dim_type type,\n\tunsigned pos)\n{\n\treturn pw ? isl_space_get_dim_id(pw->dim, type, pos) : NULL;\n}\n\nisl_bool FN(PW,has_tuple_name)(__isl_keep PW *pw, enum isl_dim_type type)\n{\n\treturn pw ? isl_space_has_tuple_name(pw->dim, type) : isl_bool_error;\n}\n\nconst char *FN(PW,get_tuple_name)(__isl_keep PW *pw, enum isl_dim_type type)\n{\n\treturn pw ? isl_space_get_tuple_name(pw->dim, type) : NULL;\n}\n\nisl_bool FN(PW,has_tuple_id)(__isl_keep PW *pw, enum isl_dim_type type)\n{\n\treturn pw ? isl_space_has_tuple_id(pw->dim, type) : isl_bool_error;\n}\n\n__isl_give isl_id *FN(PW,get_tuple_id)(__isl_keep PW *pw, enum isl_dim_type type)\n{\n\treturn pw ? isl_space_get_tuple_id(pw->dim, type) : NULL;\n}\n\nisl_bool FN(PW,IS_ZERO)(__isl_keep PW *pw)\n{\n\tif (!pw)\n\t\treturn isl_bool_error;\n\n\treturn isl_bool_ok(pw->n == 0);\n}\n\n__isl_give PW *FN(PW,realign_domain)(__isl_take PW *pw,\n\t__isl_take isl_reordering *exp)\n{\n\tint i;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw || !exp)\n\t\tgoto error;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].set = isl_set_realign(pw->p[i].set,\n\t\t\t\t\t\t    isl_reordering_copy(exp));\n\t\tif (!pw->p[i].set)\n\t\t\tgoto error;\n\t\tpw->p[i].FIELD = FN(EL,realign_domain)(pw->p[i].FIELD,\n\t\t\t\t\t\t    isl_reordering_copy(exp));\n\t\tif (!pw->p[i].FIELD)\n\t\t\tgoto error;\n\t}\n\n\tpw = FN(PW,reset_domain_space)(pw, isl_reordering_get_space(exp));\n\n\tisl_reordering_free(exp);\n\treturn pw;\nerror:\n\tisl_reordering_free(exp);\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n#undef TYPE\n#define TYPE PW\n\n#include \"isl_check_named_params_templ.c\"\n\n/* Align the parameters of \"pw\" to those of \"model\".\n */\n__isl_give PW *FN(PW,align_params)(__isl_take PW *pw, __isl_take isl_space *model)\n{\n\tisl_ctx *ctx;\n\tisl_bool equal_params;\n\n\tif (!pw || !model)\n\t\tgoto error;\n\n\tctx = isl_space_get_ctx(model);\n\tif (!isl_space_has_named_params(model))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"model has unnamed parameters\", goto error);\n\tif (FN(PW,check_named_params)(pw) < 0)\n\t\tgoto error;\n\tequal_params = isl_space_has_equal_params(pw->dim, model);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (!equal_params) {\n\t\tisl_reordering *exp;\n\n\t\texp = isl_parameter_alignment_reordering(pw->dim, model);\n\t\texp = isl_reordering_extend_space(exp,\n\t\t\t\t\tFN(PW,get_domain_space)(pw));\n\t\tpw = FN(PW,realign_domain)(pw, exp);\n\t}\n\n\tisl_space_free(model);\n\treturn pw;\nerror:\n\tisl_space_free(model);\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n#undef TYPE\n#define TYPE\tPW\n\nstatic\n#include \"isl_align_params_bin_templ.c\"\n\n#undef SUFFIX\n#define SUFFIX\tset\n#undef ARG1\n#define ARG1\tPW\n#undef ARG2\n#define ARG2\tisl_set\n\nstatic\n#include \"isl_align_params_templ.c\"\n\n#undef TYPE\n#define TYPE\tPW\n\n#include \"isl_type_has_equal_space_bin_templ.c\"\n#include \"isl_type_check_equal_space_templ.c\"\n\n/* Private version of \"union_add\".  For isl_pw_qpolynomial and\n * isl_pw_qpolynomial_fold, we prefer to simply call it \"add\".\n */\nstatic __isl_give PW *FN(PW,union_add_)(__isl_take PW *pw1, __isl_take PW *pw2)\n{\n\tint i, j, n;\n\tstruct PW *res;\n\tisl_ctx *ctx;\n\tisl_set *set;\n\n\tif (FN(PW,align_params_bin)(&pw1, &pw2) < 0)\n\t\tgoto error;\n\n\tctx = isl_space_get_ctx(pw1->dim);\n\tif (!OPT_EQUAL_TYPES(pw1->, pw2->))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"fold types don't match\", goto error);\n\tif (FN(PW,check_equal_space)(pw1, pw2) < 0)\n\t\tgoto error;\n\n\tif (FN(PW,IS_ZERO)(pw1)) {\n\t\tFN(PW,free)(pw1);\n\t\treturn pw2;\n\t}\n\n\tif (FN(PW,IS_ZERO)(pw2)) {\n\t\tFN(PW,free)(pw2);\n\t\treturn pw1;\n\t}\n\n\tn = (pw1->n + 1) * (pw2->n + 1);\n\tres = FN(PW,alloc_size)(isl_space_copy(pw1->dim)\n\t\t\t\tOPT_TYPE_ARG(pw1->), n);\n\n\tfor (i = 0; i < pw1->n; ++i) {\n\t\tset = isl_set_copy(pw1->p[i].set);\n\t\tfor (j = 0; j < pw2->n; ++j) {\n\t\t\tstruct isl_set *common;\n\t\t\tEL *sum;\n\t\t\tcommon = isl_set_intersect(isl_set_copy(pw1->p[i].set),\n\t\t\t\t\t\tisl_set_copy(pw2->p[j].set));\n\t\t\tif (isl_set_plain_is_empty(common)) {\n\t\t\t\tisl_set_free(common);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset = isl_set_subtract(set,\n\t\t\t\t\tisl_set_copy(pw2->p[j].set));\n\n\t\t\tsum = FN(EL,add_on_domain)(common,\n\t\t\t\t\t\t   FN(EL,copy)(pw1->p[i].FIELD),\n\t\t\t\t\t\t   FN(EL,copy)(pw2->p[j].FIELD));\n\n\t\t\tres = FN(PW,add_piece)(res, common, sum);\n\t\t}\n\t\tres = FN(PW,add_piece)(res, set, FN(EL,copy)(pw1->p[i].FIELD));\n\t}\n\n\tfor (j = 0; j < pw2->n; ++j) {\n\t\tset = isl_set_copy(pw2->p[j].set);\n\t\tfor (i = 0; i < pw1->n; ++i)\n\t\t\tset = isl_set_subtract(set,\n\t\t\t\t\tisl_set_copy(pw1->p[i].set));\n\t\tres = FN(PW,add_piece)(res, set, FN(EL,copy)(pw2->p[j].FIELD));\n\t}\n\n\tFN(PW,free)(pw1);\n\tFN(PW,free)(pw2);\n\n\treturn res;\nerror:\n\tFN(PW,free)(pw1);\n\tFN(PW,free)(pw2);\n\treturn NULL;\n}\n\n/* Make sure \"pw\" has room for at least \"n\" more pieces.\n *\n * If there is only one reference to pw, we extend it in place.\n * Otherwise, we create a new PW and copy the pieces.\n */\nstatic __isl_give PW *FN(PW,grow)(__isl_take PW *pw, int n)\n{\n\tint i;\n\tisl_ctx *ctx;\n\tPW *res;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (pw->n + n <= pw->size)\n\t\treturn pw;\n\tctx = FN(PW,get_ctx)(pw);\n\tn += pw->n;\n\tif (pw->ref == 1) {\n\t\tres = isl_realloc(ctx, pw, struct PW,\n\t\t\t    sizeof(struct PW) + (n - 1) * sizeof(S(PW,piece)));\n\t\tif (!res)\n\t\t\treturn FN(PW,free)(pw);\n\t\tres->size = n;\n\t\treturn res;\n\t}\n\tres = FN(PW,alloc_size)(isl_space_copy(pw->dim) OPT_TYPE_ARG(pw->), n);\n\tif (!res)\n\t\treturn FN(PW,free)(pw);\n\tfor (i = 0; i < pw->n; ++i)\n\t\tres = FN(PW,add_piece)(res, isl_set_copy(pw->p[i].set),\n\t\t\t\t\t    FN(EL,copy)(pw->p[i].FIELD));\n\tFN(PW,free)(pw);\n\treturn res;\n}\n\n__isl_give PW *FN(PW,add_disjoint)(__isl_take PW *pw1, __isl_take PW *pw2)\n{\n\tint i;\n\tisl_ctx *ctx;\n\n\tif (FN(PW,align_params_bin)(&pw1, &pw2) < 0)\n\t\tgoto error;\n\n\tif (pw1->size < pw1->n + pw2->n && pw1->n < pw2->n)\n\t\treturn FN(PW,add_disjoint)(pw2, pw1);\n\n\tctx = isl_space_get_ctx(pw1->dim);\n\tif (!OPT_EQUAL_TYPES(pw1->, pw2->))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"fold types don't match\", goto error);\n\tif (FN(PW,check_equal_space)(pw1, pw2) < 0)\n\t\tgoto error;\n\n\tif (FN(PW,IS_ZERO)(pw1)) {\n\t\tFN(PW,free)(pw1);\n\t\treturn pw2;\n\t}\n\n\tif (FN(PW,IS_ZERO)(pw2)) {\n\t\tFN(PW,free)(pw2);\n\t\treturn pw1;\n\t}\n\n\tpw1 = FN(PW,grow)(pw1, pw2->n);\n\tif (!pw1)\n\t\tgoto error;\n\n\tfor (i = 0; i < pw2->n; ++i)\n\t\tpw1 = FN(PW,add_piece)(pw1,\n\t\t\t\tisl_set_copy(pw2->p[i].set),\n\t\t\t\tFN(EL,copy)(pw2->p[i].FIELD));\n\n\tFN(PW,free)(pw2);\n\n\treturn pw1;\nerror:\n\tFN(PW,free)(pw1);\n\tFN(PW,free)(pw2);\n\treturn NULL;\n}\n\n/* This function is currently only used from isl_aff.c\n */\nstatic __isl_give PW *FN(PW,on_shared_domain_in)(__isl_take PW *pw1,\n\t__isl_take PW *pw2, __isl_take isl_space *space,\n\t__isl_give EL *(*fn)(__isl_take EL *el1, __isl_take EL *el2))\n\t__attribute__ ((unused));\n\n/* Apply \"fn\" to pairs of elements from pw1 and pw2 on shared domains.\n * The result of \"fn\" (and therefore also of this function) lives in \"space\".\n */\nstatic __isl_give PW *FN(PW,on_shared_domain_in)(__isl_take PW *pw1,\n\t__isl_take PW *pw2, __isl_take isl_space *space,\n\t__isl_give EL *(*fn)(__isl_take EL *el1, __isl_take EL *el2))\n{\n\tint i, j, n;\n\tPW *res = NULL;\n\n\tif (!pw1 || !pw2)\n\t\tgoto error;\n\n\tn = pw1->n * pw2->n;\n\tres = FN(PW,alloc_size)(isl_space_copy(space) OPT_TYPE_ARG(pw1->), n);\n\n\tfor (i = 0; i < pw1->n; ++i) {\n\t\tfor (j = 0; j < pw2->n; ++j) {\n\t\t\tisl_set *common;\n\t\t\tEL *res_ij;\n\t\t\tint empty;\n\n\t\t\tcommon = isl_set_intersect(\n\t\t\t\t\tisl_set_copy(pw1->p[i].set),\n\t\t\t\t\tisl_set_copy(pw2->p[j].set));\n\t\t\tempty = isl_set_plain_is_empty(common);\n\t\t\tif (empty < 0 || empty) {\n\t\t\t\tisl_set_free(common);\n\t\t\t\tif (empty < 0)\n\t\t\t\t\tgoto error;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres_ij = fn(FN(EL,copy)(pw1->p[i].FIELD),\n\t\t\t\t    FN(EL,copy)(pw2->p[j].FIELD));\n\t\t\tres_ij = FN(EL,gist)(res_ij, isl_set_copy(common));\n\n\t\t\tres = FN(PW,add_piece)(res, common, res_ij);\n\t\t}\n\t}\n\n\tisl_space_free(space);\n\tFN(PW,free)(pw1);\n\tFN(PW,free)(pw2);\n\treturn res;\nerror:\n\tisl_space_free(space);\n\tFN(PW,free)(pw1);\n\tFN(PW,free)(pw2);\n\tFN(PW,free)(res);\n\treturn NULL;\n}\n\n/* This function is currently only used from isl_aff.c\n */\nstatic __isl_give PW *FN(PW,on_shared_domain)(__isl_take PW *pw1,\n\t__isl_take PW *pw2,\n\t__isl_give EL *(*fn)(__isl_take EL *el1, __isl_take EL *el2))\n\t__attribute__ ((unused));\n\n/* Apply \"fn\" to pairs of elements from pw1 and pw2 on shared domains.\n * The result of \"fn\" is assumed to live in the same space as \"pw1\" and \"pw2\".\n */\nstatic __isl_give PW *FN(PW,on_shared_domain)(__isl_take PW *pw1,\n\t__isl_take PW *pw2,\n\t__isl_give EL *(*fn)(__isl_take EL *el1, __isl_take EL *el2))\n{\n\tisl_space *space;\n\n\tif (FN(PW,check_equal_space)(pw1, pw2) < 0)\n\t\tgoto error;\n\n\tspace = isl_space_copy(pw1->dim);\n\treturn FN(PW,on_shared_domain_in)(pw1, pw2, space, fn);\nerror:\n\tFN(PW,free)(pw1);\n\tFN(PW,free)(pw2);\n\treturn NULL;\n}\n\n/* Return the parameter domain of \"pw\".\n */\n__isl_give isl_set *FN(PW,params)(__isl_take PW *pw)\n{\n\treturn isl_set_params(FN(PW,domain)(pw));\n}\n\n__isl_give isl_set *FN(PW,domain)(__isl_take PW *pw)\n{\n\tint i;\n\tisl_set *dom;\n\n\tif (!pw)\n\t\treturn NULL;\n\n\tdom = isl_set_empty(FN(PW,get_domain_space)(pw));\n\tfor (i = 0; i < pw->n; ++i)\n\t\tdom = isl_set_union_disjoint(dom, isl_set_copy(pw->p[i].set));\n\n\tFN(PW,free)(pw);\n\n\treturn dom;\n}\n\n/* Exploit the equalities in the domain of piece \"i\" of \"pw\"\n * to simplify the associated function.\n * If the domain of piece \"i\" is empty, then remove it entirely,\n * replacing it with the final piece.\n */\nstatic int FN(PW,exploit_equalities_and_remove_if_empty)(__isl_keep PW *pw,\n\tint i)\n{\n\tisl_basic_set *aff;\n\tint empty = isl_set_plain_is_empty(pw->p[i].set);\n\n\tif (empty < 0)\n\t\treturn -1;\n\tif (empty) {\n\t\tisl_set_free(pw->p[i].set);\n\t\tFN(EL,free)(pw->p[i].FIELD);\n\t\tif (i != pw->n - 1)\n\t\t\tpw->p[i] = pw->p[pw->n - 1];\n\t\tpw->n--;\n\n\t\treturn 0;\n\t}\n\n\taff = isl_set_affine_hull(isl_set_copy(pw->p[i].set));\n\tpw->p[i].FIELD = FN(EL,substitute_equalities)(pw->p[i].FIELD, aff);\n\tif (!pw->p[i].FIELD)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Convert a piecewise expression defined over a parameter domain\n * into one that is defined over a zero-dimensional set.\n */\n__isl_give PW *FN(PW,from_range)(__isl_take PW *pw)\n{\n\tisl_space *space;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (!isl_space_is_set(pw->dim))\n\t\tisl_die(FN(PW,get_ctx)(pw), isl_error_invalid,\n\t\t\t\"not living in a set space\", return FN(PW,free)(pw));\n\n\tspace = FN(PW,get_space)(pw);\n\tspace = isl_space_from_range(space);\n\tpw = FN(PW,reset_space)(pw, space);\n\n\treturn pw;\n}\n\n/* Fix the value of the given parameter or domain dimension of \"pw\"\n * to be equal to \"value\".\n */\n__isl_give PW *FN(PW,fix_si)(__isl_take PW *pw, enum isl_dim_type type,\n\tunsigned pos, int value)\n{\n\tint i;\n\n\tif (!pw)\n\t\treturn NULL;\n\n\tif (type == isl_dim_out)\n\t\tisl_die(FN(PW,get_ctx)(pw), isl_error_invalid,\n\t\t\t\"cannot fix output dimension\", return FN(PW,free)(pw));\n\n\tif (pw->n == 0)\n\t\treturn pw;\n\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\treturn FN(PW,free)(pw);\n\n\tfor (i = pw->n - 1; i >= 0; --i) {\n\t\tpw->p[i].set = isl_set_fix_si(pw->p[i].set, type, pos, value);\n\t\tif (FN(PW,exploit_equalities_and_remove_if_empty)(pw, i) < 0)\n\t\t\treturn FN(PW,free)(pw);\n\t}\n\n\treturn pw;\n}\n\n/* Restrict the domain of \"pw\" by combining each cell\n * with \"set\" through a call to \"fn\", where \"fn\" may be\n * isl_set_intersect, isl_set_intersect_params, isl_set_intersect_factor_domain,\n * isl_set_intersect_factor_range or isl_set_subtract.\n */\nstatic __isl_give PW *FN(PW,restrict_domain_aligned)(__isl_take PW *pw,\n\t__isl_take isl_set *set,\n\t__isl_give isl_set *(*fn)(__isl_take isl_set *set1,\n\t\t\t\t    __isl_take isl_set *set2))\n{\n\tint i;\n\n\tif (!pw || !set)\n\t\tgoto error;\n\n\tif (pw->n == 0) {\n\t\tisl_set_free(set);\n\t\treturn pw;\n\t}\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\tgoto error;\n\n\tfor (i = pw->n - 1; i >= 0; --i) {\n\t\tpw->p[i].set = fn(pw->p[i].set, isl_set_copy(set));\n\t\tif (FN(PW,exploit_equalities_and_remove_if_empty)(pw, i) < 0)\n\t\t\tgoto error;\n\t}\n\t\n\tisl_set_free(set);\n\treturn pw;\nerror:\n\tisl_set_free(set);\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n__isl_give PW *FN(PW,intersect_domain)(__isl_take PW *pw,\n\t__isl_take isl_set *context)\n{\n\tFN(PW,align_params_set)(&pw, &context);\n\treturn FN(PW,restrict_domain_aligned)(pw, context, &isl_set_intersect);\n}\n\n/* Intersect the domain of \"pw\" with the parameter domain \"context\".\n */\n__isl_give PW *FN(PW,intersect_params)(__isl_take PW *pw,\n\t__isl_take isl_set *context)\n{\n\tFN(PW,align_params_set)(&pw, &context);\n\treturn FN(PW,restrict_domain_aligned)(pw, context,\n\t\t\t\t\t&isl_set_intersect_params);\n}\n\n/* Given a piecewise expression \"pw\" with domain in a space [A -> B] and\n * a set in the space A, intersect the domain with the set.\n */\n__isl_give PW *FN(PW,intersect_domain_wrapped_domain)(__isl_take PW *pw,\n\t__isl_take isl_set *set)\n{\n\tFN(PW,align_params_set)(&pw, &set);\n\treturn FN(PW,restrict_domain_aligned)(pw, set,\n\t\t\t\t\t    &isl_set_intersect_factor_domain);\n}\n\n/* Given a piecewise expression \"pw\" with domain in a space [A -> B] and\n * a set in the space B, intersect the domain with the set.\n */\n__isl_give PW *FN(PW,intersect_domain_wrapped_range)(__isl_take PW *pw,\n\t__isl_take isl_set *set)\n{\n\tFN(PW,align_params_set)(&pw, &set);\n\treturn FN(PW,restrict_domain_aligned)(pw, set,\n\t\t\t\t\t    &isl_set_intersect_factor_range);\n}\n\n/* Subtract \"domain' from the domain of \"pw\".\n */\n__isl_give PW *FN(PW,subtract_domain)(__isl_take PW *pw,\n\t__isl_take isl_set *domain)\n{\n\tFN(PW,align_params_set)(&pw, &domain);\n\treturn FN(PW,restrict_domain_aligned)(pw, domain, &isl_set_subtract);\n}\n\n/* Compute the gist of \"pw\" with respect to the domain constraints\n * of \"context\" for the case where the domain of the last element\n * of \"pw\" is equal to \"context\".\n * Call \"fn_el\" to compute the gist of this element, replace\n * its domain by the universe and drop all other elements\n * as their domains are necessarily disjoint from \"context\".\n */\nstatic __isl_give PW *FN(PW,gist_last)(__isl_take PW *pw,\n\t__isl_take isl_set *context,\n\t__isl_give EL *(*fn_el)(__isl_take EL *el, __isl_take isl_set *set))\n{\n\tint i;\n\tisl_space *space;\n\n\tfor (i = 0; i < pw->n - 1; ++i) {\n\t\tisl_set_free(pw->p[i].set);\n\t\tFN(EL,free)(pw->p[i].FIELD);\n\t}\n\tpw->p[0].FIELD = pw->p[pw->n - 1].FIELD;\n\tpw->p[0].set = pw->p[pw->n - 1].set;\n\tpw->n = 1;\n\n\tspace = isl_set_get_space(context);\n\tpw->p[0].FIELD = fn_el(pw->p[0].FIELD, context);\n\tcontext = isl_set_universe(space);\n\tisl_set_free(pw->p[0].set);\n\tpw->p[0].set = context;\n\n\tif (!pw->p[0].FIELD || !pw->p[0].set)\n\t\treturn FN(PW,free)(pw);\n\n\treturn pw;\n}\n\n/* Compute the gist of \"pw\" with respect to the domain constraints\n * of \"context\".  Call \"fn_el\" to compute the gist of the elements\n * and \"fn_dom\" to compute the gist of the domains.\n *\n * If the piecewise expression is empty or the context is the universe,\n * then nothing can be simplified.\n */\nstatic __isl_give PW *FN(PW,gist_aligned)(__isl_take PW *pw,\n\t__isl_take isl_set *context,\n\t__isl_give EL *(*fn_el)(__isl_take EL *el,\n\t\t\t\t    __isl_take isl_set *set),\n\t__isl_give isl_set *(*fn_dom)(__isl_take isl_set *set,\n\t\t\t\t    __isl_take isl_basic_set *bset))\n{\n\tint i;\n\tint is_universe;\n\tisl_bool aligned;\n\tisl_basic_set *hull = NULL;\n\n\tif (!pw || !context)\n\t\tgoto error;\n\n\tif (pw->n == 0) {\n\t\tisl_set_free(context);\n\t\treturn pw;\n\t}\n\n\tis_universe = isl_set_plain_is_universe(context);\n\tif (is_universe < 0)\n\t\tgoto error;\n\tif (is_universe) {\n\t\tisl_set_free(context);\n\t\treturn pw;\n\t}\n\n\taligned = isl_set_space_has_equal_params(context, pw->dim);\n\tif (aligned < 0)\n\t\tgoto error;\n\tif (!aligned) {\n\t\tpw = FN(PW,align_params)(pw, isl_set_get_space(context));\n\t\tcontext = isl_set_align_params(context, FN(PW,get_space)(pw));\n\t}\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\tgoto error;\n\n\tif (pw->n == 1) {\n\t\tint equal;\n\n\t\tequal = isl_set_plain_is_equal(pw->p[0].set, context);\n\t\tif (equal < 0)\n\t\t\tgoto error;\n\t\tif (equal)\n\t\t\treturn FN(PW,gist_last)(pw, context, fn_el);\n\t}\n\n\tcontext = isl_set_compute_divs(context);\n\thull = isl_set_simple_hull(isl_set_copy(context));\n\n\tfor (i = pw->n - 1; i >= 0; --i) {\n\t\tisl_set *set_i;\n\t\tint empty;\n\n\t\tif (i == pw->n - 1) {\n\t\t\tint equal;\n\t\t\tequal = isl_set_plain_is_equal(pw->p[i].set, context);\n\t\t\tif (equal < 0)\n\t\t\t\tgoto error;\n\t\t\tif (equal) {\n\t\t\t\tisl_basic_set_free(hull);\n\t\t\t\treturn FN(PW,gist_last)(pw, context, fn_el);\n\t\t\t}\n\t\t}\n\t\tset_i = isl_set_intersect(isl_set_copy(pw->p[i].set),\n\t\t\t\t\t\t isl_set_copy(context));\n\t\tempty = isl_set_plain_is_empty(set_i);\n\t\tpw->p[i].FIELD = fn_el(pw->p[i].FIELD, set_i);\n\t\tpw->p[i].set = fn_dom(pw->p[i].set, isl_basic_set_copy(hull));\n\t\tif (empty < 0 || !pw->p[i].FIELD || !pw->p[i].set)\n\t\t\tgoto error;\n\t\tif (empty) {\n\t\t\tisl_set_free(pw->p[i].set);\n\t\t\tFN(EL,free)(pw->p[i].FIELD);\n\t\t\tif (i != pw->n - 1)\n\t\t\t\tpw->p[i] = pw->p[pw->n - 1];\n\t\t\tpw->n--;\n\t\t}\n\t}\n\n\tisl_basic_set_free(hull);\n\tisl_set_free(context);\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\tisl_basic_set_free(hull);\n\tisl_set_free(context);\n\treturn NULL;\n}\n\n__isl_give PW *FN(PW,gist)(__isl_take PW *pw, __isl_take isl_set *context)\n{\n\tFN(PW,align_params_set)(&pw, &context);\n\treturn FN(PW,gist_aligned)(pw, context, &FN(EL,gist),\n\t\t\t\t\t&isl_set_gist_basic_set);\n}\n\n__isl_give PW *FN(PW,gist_params)(__isl_take PW *pw,\n\t__isl_take isl_set *context)\n{\n\tFN(PW,align_params_set)(&pw, &context);\n\treturn FN(PW,gist_aligned)(pw, context, &FN(EL,gist_params),\n\t\t\t\t\t&isl_set_gist_params_basic_set);\n}\n\n/* Return -1 if the piece \"p1\" should be sorted before \"p2\"\n * and 1 if it should be sorted after \"p2\".\n * Return 0 if they do not need to be sorted in a specific order.\n *\n * The two pieces are compared on the basis of their function value expressions.\n */\nstatic int FN(PW,sort_field_cmp)(const void *p1, const void *p2, void *arg)\n{\n\tstruct FN(PW,piece) const *pc1 = p1;\n\tstruct FN(PW,piece) const *pc2 = p2;\n\n\treturn FN(EL,plain_cmp)(pc1->FIELD, pc2->FIELD);\n}\n\n/* Sort the pieces of \"pw\" according to their function value\n * expressions and then combine pairs of adjacent pieces with\n * the same such expression.\n *\n * The sorting is performed in place because it does not\n * change the meaning of \"pw\", but care needs to be\n * taken not to change any possible other copies of \"pw\"\n * in case anything goes wrong.\n */\n__isl_give PW *FN(PW,sort)(__isl_take PW *pw)\n{\n\tint i, j;\n\tisl_set *set;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (pw->n <= 1)\n\t\treturn pw;\n\tif (isl_sort(pw->p, pw->n, sizeof(pw->p[0]),\n\t\t    &FN(PW,sort_field_cmp), NULL) < 0)\n\t\treturn FN(PW,free)(pw);\n\tfor (i = pw->n - 1; i >= 1; --i) {\n\t\tif (!FN(EL,plain_is_equal)(pw->p[i - 1].FIELD, pw->p[i].FIELD))\n\t\t\tcontinue;\n\t\tset = isl_set_union(isl_set_copy(pw->p[i - 1].set),\n\t\t\t\t    isl_set_copy(pw->p[i].set));\n\t\tif (!set)\n\t\t\treturn FN(PW,free)(pw);\n\t\tisl_set_free(pw->p[i].set);\n\t\tFN(EL,free)(pw->p[i].FIELD);\n\t\tisl_set_free(pw->p[i - 1].set);\n\t\tpw->p[i - 1].set = set;\n\t\tfor (j = i + 1; j < pw->n; ++j)\n\t\t\tpw->p[j - 1] = pw->p[j];\n\t\tpw->n--;\n\t}\n\n\treturn pw;\n}\n\n/* Coalesce the domains of \"pw\".\n *\n * Prior to the actual coalescing, first sort the pieces such that\n * pieces with the same function value expression are combined\n * into a single piece, the combined domain of which can then\n * be coalesced.\n */\n__isl_give PW *FN(PW,coalesce)(__isl_take PW *pw)\n{\n\tint i;\n\n\tpw = FN(PW,sort)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].set = isl_set_coalesce(pw->p[i].set);\n\t\tif (!pw->p[i].set)\n\t\t\tgoto error;\n\t}\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\nisl_ctx *FN(PW,get_ctx)(__isl_keep PW *pw)\n{\n\treturn pw ? isl_space_get_ctx(pw->dim) : NULL;\n}\n\nisl_bool FN(PW,involves_dims)(__isl_keep PW *pw, enum isl_dim_type type,\n\tunsigned first, unsigned n)\n{\n\tint i;\n\tenum isl_dim_type set_type;\n\n\tif (!pw)\n\t\treturn isl_bool_error;\n\tif (pw->n == 0 || n == 0)\n\t\treturn isl_bool_false;\n\n\tset_type = type == isl_dim_in ? isl_dim_set : type;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tisl_bool involves = FN(EL,involves_dims)(pw->p[i].FIELD,\n\t\t\t\t\t\t\ttype, first, n);\n\t\tif (involves < 0 || involves)\n\t\t\treturn involves;\n\t\tinvolves = isl_set_involves_dims(pw->p[i].set,\n\t\t\t\t\t\t\tset_type, first, n);\n\t\tif (involves < 0 || involves)\n\t\t\treturn involves;\n\t}\n\treturn isl_bool_false;\n}\n\n__isl_give PW *FN(PW,set_dim_name)(__isl_take PW *pw,\n\tenum isl_dim_type type, unsigned pos, const char *s)\n{\n\tint i;\n\tenum isl_dim_type set_type;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\n\tset_type = type == isl_dim_in ? isl_dim_set : type;\n\n\tpw->dim = isl_space_set_dim_name(pw->dim, type, pos, s);\n\tif (!pw->dim)\n\t\tgoto error;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].set = isl_set_set_dim_name(pw->p[i].set,\n\t\t\t\t\t\t\tset_type, pos, s);\n\t\tif (!pw->p[i].set)\n\t\t\tgoto error;\n\t\tpw->p[i].FIELD = FN(EL,set_dim_name)(pw->p[i].FIELD, type, pos, s);\n\t\tif (!pw->p[i].FIELD)\n\t\t\tgoto error;\n\t}\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n__isl_give PW *FN(PW,drop_dims)(__isl_take PW *pw,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\tenum isl_dim_type set_type;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (n == 0 && !isl_space_get_tuple_name(pw->dim, type))\n\t\treturn pw;\n\n\tset_type = type == isl_dim_in ? isl_dim_set : type;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\tpw->dim = isl_space_drop_dims(pw->dim, type, first, n);\n\tif (!pw->dim)\n\t\tgoto error;\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].FIELD = FN(EL,drop_dims)(pw->p[i].FIELD, type, first, n);\n\t\tif (!pw->p[i].FIELD)\n\t\t\tgoto error;\n\t\tif (type == isl_dim_out)\n\t\t\tcontinue;\n\t\tpw->p[i].set = isl_set_drop(pw->p[i].set, set_type, first, n);\n\t\tif (!pw->p[i].set)\n\t\t\tgoto error;\n\t}\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n/* This function is very similar to drop_dims.\n * The only difference is that the cells may still involve\n * the specified dimensions.  They are removed using\n * isl_set_project_out instead of isl_set_drop.\n */\n__isl_give PW *FN(PW,project_out)(__isl_take PW *pw,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\tenum isl_dim_type set_type;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (n == 0 && !isl_space_get_tuple_name(pw->dim, type))\n\t\treturn pw;\n\n\tset_type = type == isl_dim_in ? isl_dim_set : type;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\tpw->dim = isl_space_drop_dims(pw->dim, type, first, n);\n\tif (!pw->dim)\n\t\tgoto error;\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].set = isl_set_project_out(pw->p[i].set,\n\t\t\t\t\t\t\tset_type, first, n);\n\t\tif (!pw->p[i].set)\n\t\t\tgoto error;\n\t\tpw->p[i].FIELD = FN(EL,drop_dims)(pw->p[i].FIELD, type, first, n);\n\t\tif (!pw->p[i].FIELD)\n\t\t\tgoto error;\n\t}\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n/* Project the domain of pw onto its parameter space.\n */\n__isl_give PW *FN(PW,project_domain_on_params)(__isl_take PW *pw)\n{\n\tisl_space *space;\n\tisl_size n;\n\n\tn = FN(PW,dim)(pw, isl_dim_in);\n\tif (n < 0)\n\t\treturn FN(PW,free)(pw);\n\tpw = FN(PW,project_out)(pw, isl_dim_in, 0, n);\n\tspace = FN(PW,get_domain_space)(pw);\n\tspace = isl_space_params(space);\n\tpw = FN(PW,reset_domain_space)(pw, space);\n\treturn pw;\n}\n\n/* Drop all parameters not referenced by \"pw\".\n */\n__isl_give PW *FN(PW,drop_unused_params)(__isl_take PW *pw)\n{\n\tisl_size n;\n\tint i;\n\n\tif (FN(PW,check_named_params)(pw) < 0)\n\t\treturn FN(PW,free)(pw);\n\n\tn = FN(PW,dim)(pw, isl_dim_param);\n\tif (n < 0)\n\t\treturn FN(PW,free)(pw);\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tisl_bool involves;\n\n\t\tinvolves = FN(PW,involves_dims)(pw, isl_dim_param, i, 1);\n\t\tif (involves < 0)\n\t\t\treturn FN(PW,free)(pw);\n\t\tif (!involves)\n\t\t\tpw = FN(PW,drop_dims)(pw, isl_dim_param, i, 1);\n\t}\n\n\treturn pw;\n}\n\n__isl_give PW *FN(PW,fix_dim)(__isl_take PW *pw,\n\tenum isl_dim_type type, unsigned pos, isl_int v)\n{\n\tint i;\n\n\tif (!pw)\n\t\treturn NULL;\n\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].set = isl_set_fix(pw->p[i].set, type, pos, v);\n\t\tif (FN(PW,exploit_equalities_and_remove_if_empty)(pw, i) < 0)\n\t\t\treturn FN(PW,free)(pw);\n\t}\n\n\treturn pw;\n}\n\n/* Fix the value of the variable at position \"pos\" of type \"type\" of \"pw\"\n * to be equal to \"v\".\n */\n__isl_give PW *FN(PW,fix_val)(__isl_take PW *pw,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *v)\n{\n\tif (!v)\n\t\treturn FN(PW,free)(pw);\n\tif (!isl_val_is_int(v))\n\t\tisl_die(FN(PW,get_ctx)(pw), isl_error_invalid,\n\t\t\t\"expecting integer value\", goto error);\n\n\tpw = FN(PW,fix_dim)(pw, type, pos, v->n);\n\tisl_val_free(v);\n\n\treturn pw;\nerror:\n\tisl_val_free(v);\n\treturn FN(PW,free)(pw);\n}\n\nisl_size FN(PW,dim)(__isl_keep PW *pw, enum isl_dim_type type)\n{\n\treturn isl_space_dim(FN(PW,peek_space)(pw), type);\n}\n\n__isl_give PW *FN(PW,split_dims)(__isl_take PW *pw,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (n == 0)\n\t\treturn pw;\n\n\tif (type == isl_dim_in)\n\t\ttype = isl_dim_set;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\tif (!pw->dim)\n\t\tgoto error;\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].set = isl_set_split_dims(pw->p[i].set, type, first, n);\n\t\tif (!pw->p[i].set)\n\t\t\tgoto error;\n\t}\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n/* Return the space of \"pw\".\n */\n__isl_keep isl_space *FN(PW,peek_space)(__isl_keep PW *pw)\n{\n\treturn pw ? pw->dim : NULL;\n}\n\n__isl_give isl_space *FN(PW,get_space)(__isl_keep PW *pw)\n{\n\treturn isl_space_copy(FN(PW,peek_space)(pw));\n}\n\n/* Return the space of \"pw\".\n * This may be either a copy or the space itself\n * if there is only one reference to \"pw\".\n * This allows the space to be modified inplace\n * if both the piecewise expression and its space have only a single reference.\n * The caller is not allowed to modify \"pw\" between this call and\n * a subsequent call to isl_pw_*_restore_*.\n * The only exception is that isl_pw_*_free can be called instead.\n */\n__isl_give isl_space *FN(PW,take_space)(__isl_keep PW *pw)\n{\n\tisl_space *space;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (pw->ref != 1)\n\t\treturn FN(PW,get_space)(pw);\n\tspace = pw->dim;\n\tpw->dim = NULL;\n\treturn space;\n}\n\n/* Set the space of \"pw\" to \"space\", where the space of \"pw\" may be missing\n * due to a preceding call to isl_pw_*_take_space.\n * However, in this case, \"pw\" only has a single reference and\n * then the call to isl_pw_*_cow has no effect.\n */\n__isl_give PW *FN(PW,restore_space)(__isl_take PW *pw,\n\t__isl_take isl_space *space)\n{\n\tif (!pw || !space)\n\t\tgoto error;\n\n\tif (pw->dim == space) {\n\t\tisl_space_free(space);\n\t\treturn pw;\n\t}\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\tgoto error;\n\tisl_space_free(pw->dim);\n\tpw->dim = space;\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Check that \"pos\" is a valid position for a cell in \"pw\".\n */\nstatic isl_stat FN(PW,check_pos)(__isl_keep PW *pw, int pos)\n{\n\tif (!pw)\n\t\treturn isl_stat_error;\n\tif (pos < 0 || pos >= pw->n)\n\t\tisl_die(FN(PW,get_ctx)(pw), isl_error_internal,\n\t\t\t\"position out of bounds\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Return the cell at position \"pos\" in \"pw\".\n */\nstatic __isl_keep isl_set *FN(PW,peek_domain_at)(__isl_keep PW *pw, int pos)\n{\n\tif (FN(PW,check_pos)(pw, pos) < 0)\n\t\treturn NULL;\n\treturn pw->p[pos].set;\n}\n\n/* Return a copy of the cell at position \"pos\" in \"pw\".\n */\n__isl_give isl_set *FN(PW,get_domain_at)(__isl_keep PW *pw, int pos)\n{\n\treturn isl_set_copy(FN(PW,peek_domain_at)(pw, pos));\n}\n\n/* Return the base expression associated to\n * the cell at position \"pos\" in \"pw\".\n */\nstatic __isl_keep EL *FN(PW,peek_base_at)(__isl_keep PW *pw, int pos)\n{\n\tif (FN(PW,check_pos)(pw, pos) < 0)\n\t\treturn NULL;\n\treturn pw->p[pos].FIELD;\n}\n\n/* Return a copy of the base expression associated to\n * the cell at position \"pos\" in \"pw\".\n */\n__isl_give EL *FN(PW,get_base_at)(__isl_keep PW *pw, int pos)\n{\n\treturn FN(EL,copy)(FN(PW,peek_base_at)(pw, pos));\n}\n\n/* Return the base expression associated to\n * the cell at position \"pos\" in \"pw\".\n * This may be either a copy or the base expression itself\n * if there is only one reference to \"pw\".\n * This allows the base expression to be modified inplace\n * if both the piecewise expression and this base expression\n * have only a single reference.\n * The caller is not allowed to modify \"pw\" between this call and\n * a subsequent call to isl_pw_*_restore_*.\n * The only exception is that isl_pw_*_free can be called instead.\n */\n__isl_give EL *FN(PW,take_base_at)(__isl_keep PW *pw, int pos)\n{\n\tEL *el;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (pw->ref != 1)\n\t\treturn FN(PW,get_base_at)(pw, pos);\n\tif (FN(PW,check_pos)(pw, pos) < 0)\n\t\treturn NULL;\n\tel = pw->p[pos].FIELD;\n\tpw->p[pos].FIELD = NULL;\n\treturn el;\n}\n\n/* Set the base expression associated to\n * the cell at position \"pos\" in \"pw\" to \"el\",\n * where this base expression may be missing\n * due to a preceding call to isl_pw_*_take_base_at.\n * However, in this case, \"pw\" only has a single reference and\n * then the call to isl_pw_*_cow has no effect.\n */\n__isl_give PW *FN(PW,restore_base_at)(__isl_take PW *pw, int pos,\n\t__isl_take EL *el)\n{\n\tif (FN(PW,check_pos)(pw, pos) < 0 || !el)\n\t\tgoto error;\n\n\tif (pw->p[pos].FIELD == el) {\n\t\tFN(EL,free)(el);\n\t\treturn pw;\n\t}\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\tgoto error;\n\tFN(EL,free)(pw->p[pos].FIELD);\n\tpw->p[pos].FIELD = el;\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\tFN(EL,free)(el);\n\treturn NULL;\n}\n\n__isl_give isl_space *FN(PW,get_domain_space)(__isl_keep PW *pw)\n{\n\treturn pw ? isl_space_domain(isl_space_copy(pw->dim)) : NULL;\n}\n\n/* Return the position of the dimension of the given type and name\n * in \"pw\".\n * Return -1 if no such dimension can be found.\n */\nint FN(PW,find_dim_by_name)(__isl_keep PW *pw,\n\tenum isl_dim_type type, const char *name)\n{\n\tif (!pw)\n\t\treturn -1;\n\treturn isl_space_find_dim_by_name(pw->dim, type, name);\n}\n\n/* Return the position of the dimension of the given type and identifier\n * in \"pw\".\n * Return -1 if no such dimension can be found.\n */\nstatic int FN(PW,find_dim_by_id)(__isl_keep PW *pw,\n\tenum isl_dim_type type, __isl_keep isl_id *id)\n{\n\tisl_space *space;\n\n\tspace = FN(PW,peek_space)(pw);\n\treturn isl_space_find_dim_by_id(space, type, id);\n}\n\n/* Does the piecewise expression \"pw\" depend in any way\n * on the parameter with identifier \"id\"?\n */\nisl_bool FN(PW,involves_param_id)(__isl_keep PW *pw, __isl_keep isl_id *id)\n{\n\tint pos;\n\n\tif (!pw || !id)\n\t\treturn isl_bool_error;\n\tif (pw->n == 0)\n\t\treturn isl_bool_false;\n\n\tpos = FN(PW,find_dim_by_id)(pw, isl_dim_param, id);\n\tif (pos < 0)\n\t\treturn isl_bool_false;\n\treturn FN(PW,involves_dims)(pw, isl_dim_param, pos, 1);\n}\n\n/* Reset the space of \"pw\".  Since we don't know if the elements\n * represent the spaces themselves or their domains, we pass along\n * both when we call their reset_space_and_domain.\n */\nstatic __isl_give PW *FN(PW,reset_space_and_domain)(__isl_take PW *pw,\n\t__isl_take isl_space *space, __isl_take isl_space *domain)\n{\n\tint i;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw || !space || !domain)\n\t\tgoto error;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].set = isl_set_reset_space(pw->p[i].set,\n\t\t\t\t\t\t isl_space_copy(domain));\n\t\tif (!pw->p[i].set)\n\t\t\tgoto error;\n\t\tpw->p[i].FIELD = FN(EL,reset_space_and_domain)(pw->p[i].FIELD,\n\t\t\t      isl_space_copy(space), isl_space_copy(domain));\n\t\tif (!pw->p[i].FIELD)\n\t\t\tgoto error;\n\t}\n\n\tisl_space_free(domain);\n\n\tisl_space_free(pw->dim);\n\tpw->dim = space;\n\n\treturn pw;\nerror:\n\tisl_space_free(domain);\n\tisl_space_free(space);\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n__isl_give PW *FN(PW,reset_domain_space)(__isl_take PW *pw,\n\t__isl_take isl_space *domain)\n{\n\tisl_space *space;\n\n\tspace = isl_space_extend_domain_with_range(isl_space_copy(domain),\n\t\t\t\t\t\t   FN(PW,get_space)(pw));\n\treturn FN(PW,reset_space_and_domain)(pw, space, domain);\n}\n\n__isl_give PW *FN(PW,reset_space)(__isl_take PW *pw,\n\t__isl_take isl_space *space)\n{\n\tisl_space *domain;\n\n\tdomain = isl_space_domain(isl_space_copy(space));\n\treturn FN(PW,reset_space_and_domain)(pw, space, domain);\n}\n\n__isl_give PW *FN(PW,set_tuple_id)(__isl_take PW *pw, enum isl_dim_type type,\n\t__isl_take isl_id *id)\n{\n\tisl_space *space;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\tgoto error;\n\n\tspace = FN(PW,get_space)(pw);\n\tspace = isl_space_set_tuple_id(space, type, id);\n\n\treturn FN(PW,reset_space)(pw, space);\nerror:\n\tisl_id_free(id);\n\treturn FN(PW,free)(pw);\n}\n\n/* Drop the id on the specified tuple.\n */\n__isl_give PW *FN(PW,reset_tuple_id)(__isl_take PW *pw, enum isl_dim_type type)\n{\n\tisl_space *space;\n\n\tif (!pw)\n\t\treturn NULL;\n\tif (!FN(PW,has_tuple_id)(pw, type))\n\t\treturn pw;\n\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\n\tspace = FN(PW,get_space)(pw);\n\tspace = isl_space_reset_tuple_id(space, type);\n\n\treturn FN(PW,reset_space)(pw, space);\n}\n\n__isl_give PW *FN(PW,set_dim_id)(__isl_take PW *pw,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_id *id)\n{\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\tgoto error;\n\tpw->dim = isl_space_set_dim_id(pw->dim, type, pos, id);\n\treturn FN(PW,reset_space)(pw, isl_space_copy(pw->dim));\nerror:\n\tisl_id_free(id);\n\treturn FN(PW,free)(pw);\n}\n\n/* Reset the user pointer on all identifiers of parameters and tuples\n * of the space of \"pw\".\n */\n__isl_give PW *FN(PW,reset_user)(__isl_take PW *pw)\n{\n\tisl_space *space;\n\n\tspace = FN(PW,get_space)(pw);\n\tspace = isl_space_reset_user(space);\n\n\treturn FN(PW,reset_space)(pw, space);\n}\n\nisl_size FN(PW,n_piece)(__isl_keep PW *pw)\n{\n\treturn pw ? pw->n : isl_size_error;\n}\n\nisl_stat FN(PW,foreach_piece)(__isl_keep PW *pw,\n\tisl_stat (*fn)(__isl_take isl_set *set, __isl_take EL *el, void *user),\n\tvoid *user)\n{\n\tint i;\n\n\tif (!pw)\n\t\treturn isl_stat_error;\n\n\tfor (i = 0; i < pw->n; ++i)\n\t\tif (fn(isl_set_copy(pw->p[i].set),\n\t\t\t\tFN(EL,copy)(pw->p[i].FIELD), user) < 0)\n\t\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Does \"test\" succeed on every cell of \"pw\"?\n */\nisl_bool FN(PW,every_piece)(__isl_keep PW *pw,\n\tisl_bool (*test)(__isl_keep isl_set *set,\n\t\t__isl_keep EL *el, void *user), void *user)\n{\n\tint i;\n\n\tif (!pw)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tisl_bool r;\n\n\t\tr = test(pw->p[i].set, pw->p[i].FIELD, user);\n\t\tif (r < 0 || !r)\n\t\t\treturn r;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Is \"pw\" defined over a single universe domain?\n *\n * If the default value of this piecewise type is zero,\n * then a \"pw\" with a zero number of cells is also accepted\n * as it represents the default zero value.\n */\nisl_bool FN(FN(PW,isa),BASE)(__isl_keep PW *pw)\n{\n\tisl_size n;\n\n\tn = FN(PW,n_piece)(pw);\n\tif (n < 0)\n\t\treturn isl_bool_error;\n\tif (DEFAULT_IS_ZERO && n == 0)\n\t\treturn isl_bool_true;\n\tif (n != 1)\n\t\treturn isl_bool_false;\n\treturn isl_set_plain_is_universe(FN(PW,peek_domain_at)(pw, 0));\n}\n\n/* Return a zero base expression in the same space (and of the same type)\n * as \"pw\".\n */\nstatic __isl_give EL *FN(EL,zero_like_type)(__isl_take PW *pw OPT_TYPE_PARAM)\n{\n\tisl_space *space;\n\n\tspace = FN(PW,get_space)(pw);\n\tFN(PW,free)(pw);\n\treturn FN(EL,zero_in_space)(space OPT_TYPE_ARG(NO_LOC));\n}\n\n#ifndef HAS_TYPE\n/* Return a zero base expression in the same space as \"pw\".\n */\nstatic __isl_give EL *FN(EL,zero_like)(__isl_take PW *pw)\n{\n\treturn FN(EL,zero_like_type)(pw);\n}\n#else\n/* Return a zero base expression in the same space and of the same type\n * as \"pw\".\n *\n * Pass along the type as an explicit argument for uniform handling\n * in isl_*_zero_like_type.\n */\nstatic __isl_give EL *FN(EL,zero_like)(__isl_take PW *pw)\n{\n\tenum isl_fold type;\n\n\ttype = FN(PW,get_type)(pw);\n\tif (type < 0)\n\t\tgoto error;\n\treturn FN(EL,zero_like_type)(pw, type);\nerror:\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n#endif\n\n/* Given that \"pw\" is defined over a single universe domain,\n * return the base expression associated to this domain.\n *\n * If the number of cells is zero, then \"pw\" is of a piecewise type\n * with a default zero value and effectively represents zero.\n * In this case, create a zero base expression in the same space\n * (and with the same type).\n * Otherwise, simply extract the associated base expression.\n */\n__isl_give EL *FN(FN(PW,as),BASE)(__isl_take PW *pw)\n{\n\tisl_bool is_total;\n\tisl_size n;\n\tEL *el;\n\n\tis_total = FN(FN(PW,isa),BASE)(pw);\n\tif (is_total < 0)\n\t\tgoto error;\n\tif (!is_total)\n\t\tisl_die(FN(PW,get_ctx)(pw), isl_error_invalid,\n\t\t\t\"expecting single total function\", goto error);\n\tn = FN(PW,n_piece)(pw);\n\tif (n < 0)\n\t\tgoto error;\n\tif (n == 0)\n\t\treturn FN(EL,zero_like)(pw);\n\tel = FN(PW,take_base_at)(pw, 0);\n\tFN(PW,free)(pw);\n\treturn el;\nerror:\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n#ifdef HAS_TYPE\n/* Negate the type of \"pw\".\n */\nstatic __isl_give PW *FN(PW,negate_type)(__isl_take PW *pw)\n{\n\tpw = FN(PW,cow)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\tpw->type = isl_fold_type_negate(pw->type);\n\treturn pw;\n}\n#else\n/* Negate the type of \"pw\".\n * Since \"pw\" does not have a type, do nothing.\n */\nstatic __isl_give PW *FN(PW,negate_type)(__isl_take PW *pw)\n{\n\treturn pw;\n}\n#endif\n\n__isl_give PW *FN(PW,mul_isl_int)(__isl_take PW *pw, isl_int v)\n{\n\tint i;\n\n\tif (isl_int_is_one(v))\n\t\treturn pw;\n\tif (pw && DEFAULT_IS_ZERO && isl_int_is_zero(v)) {\n\t\tPW *zero;\n\t\tisl_space *space = FN(PW,get_space)(pw);\n\t\tzero = FN(PW,ZERO)(space OPT_TYPE_ARG(pw->));\n\t\tFN(PW,free)(pw);\n\t\treturn zero;\n\t}\n\tpw = FN(PW,cow)(pw);\n\tif (isl_int_is_neg(v))\n\t\tpw = FN(PW,negate_type)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\tif (pw->n == 0)\n\t\treturn pw;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].FIELD = FN(EL,scale)(pw->p[i].FIELD, v);\n\t\tif (!pw->p[i].FIELD)\n\t\t\tgoto error;\n\t}\n\n\treturn pw;\nerror:\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n/* Multiply the pieces of \"pw\" by \"v\" and return the result.\n */\n__isl_give PW *FN(PW,scale_val)(__isl_take PW *pw, __isl_take isl_val *v)\n{\n\tint i;\n\n\tif (!pw || !v)\n\t\tgoto error;\n\n\tif (isl_val_is_one(v)) {\n\t\tisl_val_free(v);\n\t\treturn pw;\n\t}\n\tif (pw && DEFAULT_IS_ZERO && isl_val_is_zero(v)) {\n\t\tPW *zero;\n\t\tisl_space *space = FN(PW,get_space)(pw);\n\t\tzero = FN(PW,ZERO)(space OPT_TYPE_ARG(pw->));\n\t\tFN(PW,free)(pw);\n\t\tisl_val_free(v);\n\t\treturn zero;\n\t}\n\tif (pw->n == 0) {\n\t\tisl_val_free(v);\n\t\treturn pw;\n\t}\n\tpw = FN(PW,cow)(pw);\n\tif (isl_val_is_neg(v))\n\t\tpw = FN(PW,negate_type)(pw);\n\tif (!pw)\n\t\tgoto error;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].FIELD = FN(EL,scale_val)(pw->p[i].FIELD,\n\t\t\t\t\t\t    isl_val_copy(v));\n\t\tif (!pw->p[i].FIELD)\n\t\t\tgoto error;\n\t}\n\n\tisl_val_free(v);\n\treturn pw;\nerror:\n\tisl_val_free(v);\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n/* Divide the pieces of \"pw\" by \"v\" and return the result.\n */\n__isl_give PW *FN(PW,scale_down_val)(__isl_take PW *pw, __isl_take isl_val *v)\n{\n\tint i;\n\n\tif (!pw || !v)\n\t\tgoto error;\n\n\tif (isl_val_is_one(v)) {\n\t\tisl_val_free(v);\n\t\treturn pw;\n\t}\n\n\tif (!isl_val_is_rat(v))\n\t\tisl_die(isl_val_get_ctx(v), isl_error_invalid,\n\t\t\t\"expecting rational factor\", goto error);\n\tif (isl_val_is_zero(v))\n\t\tisl_die(isl_val_get_ctx(v), isl_error_invalid,\n\t\t\t\"cannot scale down by zero\", goto error);\n\n\tif (pw->n == 0) {\n\t\tisl_val_free(v);\n\t\treturn pw;\n\t}\n\tpw = FN(PW,cow)(pw);\n\tif (isl_val_is_neg(v))\n\t\tpw = FN(PW,negate_type)(pw);\n\tif (!pw)\n\t\tgoto error;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tpw->p[i].FIELD = FN(EL,scale_down_val)(pw->p[i].FIELD,\n\t\t\t\t\t\t    isl_val_copy(v));\n\t\tif (!pw->p[i].FIELD)\n\t\t\tgoto error;\n\t}\n\n\tisl_val_free(v);\n\treturn pw;\nerror:\n\tisl_val_free(v);\n\tFN(PW,free)(pw);\n\treturn NULL;\n}\n\n__isl_give PW *FN(PW,scale)(__isl_take PW *pw, isl_int v)\n{\n\treturn FN(PW,mul_isl_int)(pw, v);\n}\n\n/* Apply some normalization to \"pw\".\n * In particular, sort the pieces according to their function value\n * expressions, combining pairs of adjacent pieces with\n * the same such expression, and then normalize the domains of the pieces.\n *\n * We normalize in place, but if anything goes wrong we need\n * to return NULL, so we need to make sure we don't change the\n * meaning of any possible other copies of \"pw\".\n */\n__isl_give PW *FN(PW,normalize)(__isl_take PW *pw)\n{\n\tint i;\n\tisl_set *set;\n\n\tpw = FN(PW,sort)(pw);\n\tif (!pw)\n\t\treturn NULL;\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tset = isl_set_normalize(isl_set_copy(pw->p[i].set));\n\t\tif (!set)\n\t\t\treturn FN(PW,free)(pw);\n\t\tisl_set_free(pw->p[i].set);\n\t\tpw->p[i].set = set;\n\t}\n\n\treturn pw;\n}\n\n/* Is pw1 obviously equal to pw2?\n * That is, do they have obviously identical cells and obviously identical\n * elements on each cell?\n *\n * If \"pw1\" or \"pw2\" contain any NaNs, then they are considered\n * not to be the same.  A NaN is not equal to anything, not even\n * to another NaN.\n */\nisl_bool FN(PW,plain_is_equal)(__isl_keep PW *pw1, __isl_keep PW *pw2)\n{\n\tint i;\n\tisl_bool equal, has_nan;\n\n\tif (!pw1 || !pw2)\n\t\treturn isl_bool_error;\n\n\thas_nan = FN(PW,involves_nan)(pw1);\n\tif (has_nan >= 0 && !has_nan)\n\t\thas_nan = FN(PW,involves_nan)(pw2);\n\tif (has_nan < 0 || has_nan)\n\t\treturn isl_bool_not(has_nan);\n\n\tif (pw1 == pw2)\n\t\treturn isl_bool_true;\n\tequal = FN(PW,has_equal_space)(pw1, pw2);\n\tif (equal < 0 || !equal)\n\t\treturn equal;\n\n\tpw1 = FN(PW,copy)(pw1);\n\tpw2 = FN(PW,copy)(pw2);\n\tpw1 = FN(PW,normalize)(pw1);\n\tpw2 = FN(PW,normalize)(pw2);\n\tif (!pw1 || !pw2)\n\t\tgoto error;\n\n\tequal = isl_bool_ok(pw1->n == pw2->n);\n\tfor (i = 0; equal && i < pw1->n; ++i) {\n\t\tequal = isl_set_plain_is_equal(pw1->p[i].set, pw2->p[i].set);\n\t\tif (equal < 0)\n\t\t\tgoto error;\n\t\tif (!equal)\n\t\t\tbreak;\n\t\tequal = FN(EL,plain_is_equal)(pw1->p[i].FIELD, pw2->p[i].FIELD);\n\t\tif (equal < 0)\n\t\t\tgoto error;\n\t}\n\n\tFN(PW,free)(pw1);\n\tFN(PW,free)(pw2);\n\treturn equal;\nerror:\n\tFN(PW,free)(pw1);\n\tFN(PW,free)(pw2);\n\treturn isl_bool_error;\n}\n\n/* Does \"pw\" involve any NaNs?\n */\nisl_bool FN(PW,involves_nan)(__isl_keep PW *pw)\n{\n\tint i;\n\n\tif (!pw)\n\t\treturn isl_bool_error;\n\tif (pw->n == 0)\n\t\treturn isl_bool_false;\n\n\tfor (i = 0; i < pw->n; ++i) {\n\t\tisl_bool has_nan = FN(EL,involves_nan)(pw->p[i].FIELD);\n\t\tif (has_nan < 0 || has_nan)\n\t\t\treturn has_nan;\n\t}\n\n\treturn isl_bool_false;\n}\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_union_macro.h", "content": "#define xCAT(A,B) A ## B\n#define CAT(A,B) xCAT(A,B)\n#undef PART\n#define PART CAT(isl_,BASE)\n#undef UNION\n#define UNION CAT(isl_union_,BASE)\n#define xFN(TYPE,NAME) TYPE ## _ ## NAME\n#define FN(TYPE,NAME) xFN(TYPE,NAME)\n#define xS(TYPE,NAME) struct TYPE ## _ ## NAME\n#define S(TYPE,NAME) xS(TYPE,NAME)\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_union_map_private.h", "content": "#define isl_union_set_list\tisl_union_map_list\n#define isl_union_set\tisl_union_map\n#include <isl/union_map.h>\n#include <isl/union_set.h>\n\nstruct isl_union_map {\n\tint ref;\n\tisl_space *dim;\n\n\tstruct isl_hash_table\ttable;\n};\n\nstruct isl_hash_table_entry *isl_union_set_find_entry(\n\t__isl_keep isl_union_set *uset, __isl_keep isl_space *space,\n\tint reserve);\n\n__isl_keep isl_space *isl_union_map_peek_space(__isl_keep isl_union_map *umap);\n__isl_keep isl_space *isl_union_set_peek_space(__isl_keep isl_union_set *uset);\nisl_bool isl_union_map_is_params(__isl_keep isl_union_map *umap);\nisl_bool isl_union_map_space_has_equal_params(__isl_keep isl_union_map *umap,\n\t__isl_keep isl_space *space);\nisl_bool isl_union_set_space_has_equal_params(__isl_keep isl_union_set *uset,\n\t__isl_keep isl_space *space);\n__isl_give isl_union_map *isl_union_map_reset_range_space(\n\t__isl_take isl_union_map *umap, __isl_take isl_space *space);\n__isl_give isl_union_map *isl_union_map_reset_equal_dim_space(\n\t__isl_take isl_union_map *umap, __isl_take isl_space *space);\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/opt_type.h", "content": "#define NO_LOC\n#ifdef HAS_TYPE\n#define OPT_TYPE_PARAM\t\t\t, enum isl_fold type\n#define OPT_TYPE_PARAM_FIRST\t\tenum isl_fold type,\n#define OPT_TYPE_ARG(loc)\t\t, loc type\n#define OPT_TYPE_ARG_FIRST(loc)\t\tloc type,\n#define OPT_SET_TYPE(loc,val)\t\tloc type = (val);\n#define OPT_EQUAL_TYPES(loc1, loc2)\t((loc1 type) == (loc2 type))\n#else\n#define OPT_TYPE_PARAM\n#define OPT_TYPE_PARAM_FIRST\n#define OPT_TYPE_ARG(loc)\n#define OPT_TYPE_ARG_FIRST(loc)\n#define OPT_SET_TYPE(loc,val)\n#define OPT_EQUAL_TYPES(loc1, loc2)\t1\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 8, "line": 597}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "88cd0e1317a0179ff08d3a3dc7047161", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 8, "line": 1671}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "a82f67a42734c80f7112c8f4e543eec2", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 8, "line": 2188}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "0874d4453cf25236008d9f2c6bd2a7fa", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 8, "line": 2190}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "9a92a593f35fe636862aa73496f1b81a", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 8, "line": 2541}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "c5aa66ba1b84f30990fad6433260f41c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 10, "file": 8, "line": 4158}, "message": "comparison of integers of different signs: 'isl_size' (aka 'int') and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "173b38ac52592ecd855fb2ecbb7c6964", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 8, "line": 4165}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "cb12d79cd14e77a8b152f74ed667affb", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 8, "line": 4173}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "3235e0c65f4c90d73ac70e1b4d3353d8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 8, "line": 4842}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "498ad91d889947ecd22888b457ed9cc4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 8, "line": 5205}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "a11721c3d617c7d4b3dd964f5f58ded2", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 8, "line": 5386}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff.c", "reportHash": "6b20a49c38f382f0e84b4999730193a8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 30, "line": 153}, "message": "expanded from macro 'isl_assert'"}, {"location": {"col": 7, "file": 30, "line": 148}, "message": "expanded from macro 'isl_assert4'"}, {"location": {"col": 24, "file": 29, "line": 75}, "message": "comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_pw_templ.c", "reportHash": "29f6b2a494478a67627b8d83a1a32105", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 511}, "message": "comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_pw_templ.c", "reportHash": "e63e6d842ad15d51c2b094461987f559", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 541}, "message": "comparison of integers of different signs: 'size_t' (aka 'unsigned long') and 'int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_pw_templ.c", "reportHash": "74434fbb22323ba2b72e9d3949d5ff22", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 1, "file": 37, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_union_macro.h", "reportHash": "89ef383191b26c45a6d110f1204376fa", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 38, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_union_map_private.h", "reportHash": "b320d076bd9b7092257ccbc4d1153013", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 42, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/opt_type.h", "reportHash": "193da1c6c32f161fbef4857cd1710a2a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
