<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp", "content": "//===- AsmMatcherEmitter.cpp - Generate an assembly matcher ---------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This tablegen backend emits a target specifier matcher for converting parsed\n// assembly operands in the MCInst structures. It also emits a matcher for\n// custom operand parsing.\n//\n// Converting assembly operands into MCInst structures\n// ---------------------------------------------------\n//\n// The input to the target specific matcher is a list of literal tokens and\n// operands. The target specific parser should generally eliminate any syntax\n// which is not relevant for matching; for example, comma tokens should have\n// already been consumed and eliminated by the parser. Most instructions will\n// end up with a single literal token (the instruction name) and some number of\n// operands.\n//\n// Some example inputs, for X86:\n//   'addl' (immediate ...) (register ...)\n//   'add' (immediate ...) (memory ...)\n//   'call' '*' %epc\n//\n// The assembly matcher is responsible for converting this input into a precise\n// machine instruction (i.e., an instruction with a well defined encoding). This\n// mapping has several properties which complicate matching:\n//\n//  - It may be ambiguous; many architectures can legally encode particular\n//    variants of an instruction in different ways (for example, using a smaller\n//    encoding for small immediates). Such ambiguities should never be\n//    arbitrarily resolved by the assembler, the assembler is always responsible\n//    for choosing the \"best\" available instruction.\n//\n//  - It may depend on the subtarget or the assembler context. Instructions\n//    which are invalid for the current mode, but otherwise unambiguous (e.g.,\n//    an SSE instruction in a file being assembled for i486) should be accepted\n//    and rejected by the assembler front end. However, if the proper encoding\n//    for an instruction is dependent on the assembler context then the matcher\n//    is responsible for selecting the correct machine instruction for the\n//    current mode.\n//\n// The core matching algorithm attempts to exploit the regularity in most\n// instruction sets to quickly determine the set of possibly matching\n// instructions, and the simplify the generated code. Additionally, this helps\n// to ensure that the ambiguities are intentionally resolved by the user.\n//\n// The matching is divided into two distinct phases:\n//\n//   1. Classification: Each operand is mapped to the unique set which (a)\n//      contains it, and (b) is the largest such subset for which a single\n//      instruction could match all members.\n//\n//      For register classes, we can generate these subgroups automatically. For\n//      arbitrary operands, we expect the user to define the classes and their\n//      relations to one another (for example, 8-bit signed immediates as a\n//      subset of 32-bit immediates).\n//\n//      By partitioning the operands in this way, we guarantee that for any\n//      tuple of classes, any single instruction must match either all or none\n//      of the sets of operands which could classify to that tuple.\n//\n//      In addition, the subset relation amongst classes induces a partial order\n//      on such tuples, which we use to resolve ambiguities.\n//\n//   2. The input can now be treated as a tuple of classes (static tokens are\n//      simple singleton sets). Each such tuple should generally map to a single\n//      instruction (we currently ignore cases where this isn't true, whee!!!),\n//      which we can emit a simple matcher for.\n//\n// Custom Operand Parsing\n// ----------------------\n//\n//  Some targets need a custom way to parse operands, some specific instructions\n//  can contain arguments that can represent processor flags and other kinds of\n//  identifiers that need to be mapped to specific values in the final encoded\n//  instructions. The target specific custom operand parsing works in the\n//  following way:\n//\n//   1. A operand match table is built, each entry contains a mnemonic, an\n//      operand class, a mask for all operand positions for that same\n//      class/mnemonic and target features to be checked while trying to match.\n//\n//   2. The operand matcher will try every possible entry with the same\n//      mnemonic and will check if the target feature for this mnemonic also\n//      matches. After that, if the operand to be matched has its index\n//      present in the mask, a successful match occurs. Otherwise, fallback\n//      to the regular operand parsing.\n//\n//   3. For a match success, each operand class that has a 'ParserMethod'\n//      becomes part of a switch from where the custom method is called.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CodeGenTarget.h\"\n#include \"SubtargetFeatureInfo.h\"\n#include \"Types.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/TableGen/Error.h\"\n#include \"llvm/TableGen/Record.h\"\n#include \"llvm/TableGen/StringMatcher.h\"\n#include \"llvm/TableGen/StringToOffsetTable.h\"\n#include \"llvm/TableGen/TableGenBackend.h\"\n#include <cassert>\n#include <cctype>\n#include <forward_list>\n#include <map>\n#include <set>\n\nusing namespace llvm;\n\n#define DEBUG_TYPE \"asm-matcher-emitter\"\n\ncl::OptionCategory AsmMatcherEmitterCat(\"Options for -gen-asm-matcher\");\n\nstatic cl::opt<std::string>\n    MatchPrefix(\"match-prefix\", cl::init(\"\"),\n                cl::desc(\"Only match instructions with the given prefix\"),\n                cl::cat(AsmMatcherEmitterCat));\n\nnamespace {\nclass AsmMatcherInfo;\n\n// Register sets are used as keys in some second-order sets TableGen creates\n// when generating its data structures. This means that the order of two\n// RegisterSets can be seen in the outputted AsmMatcher tables occasionally, and\n// can even affect compiler output (at least seen in diagnostics produced when\n// all matches fail). So we use a type that sorts them consistently.\ntypedef std::set<Record*, LessRecordByID> RegisterSet;\n\nclass AsmMatcherEmitter {\n  RecordKeeper &Records;\npublic:\n  AsmMatcherEmitter(RecordKeeper &R) : Records(R) {}\n\n  void run(raw_ostream &o);\n};\n\n/// ClassInfo - Helper class for storing the information about a particular\n/// class of operands which can be matched.\nstruct ClassInfo {\n  enum ClassInfoKind {\n    /// Invalid kind, for use as a sentinel value.\n    Invalid = 0,\n\n    /// The class for a particular token.\n    Token,\n\n    /// The (first) register class, subsequent register classes are\n    /// RegisterClass0+1, and so on.\n    RegisterClass0,\n\n    /// The (first) user defined class, subsequent user defined classes are\n    /// UserClass0+1, and so on.\n    UserClass0 = 1<<16\n  };\n\n  /// Kind - The class kind, which is either a predefined kind, or (UserClass0 +\n  /// N) for the Nth user defined class.\n  unsigned Kind;\n\n  /// SuperClasses - The super classes of this class. Note that for simplicities\n  /// sake user operands only record their immediate super class, while register\n  /// operands include all superclasses.\n  std::vector<ClassInfo*> SuperClasses;\n\n  /// Name - The full class name, suitable for use in an enum.\n  std::string Name;\n\n  /// ClassName - The unadorned generic name for this class (e.g., Token).\n  std::string ClassName;\n\n  /// ValueName - The name of the value this class represents; for a token this\n  /// is the literal token string, for an operand it is the TableGen class (or\n  /// empty if this is a derived class).\n  std::string ValueName;\n\n  /// PredicateMethod - The name of the operand method to test whether the\n  /// operand matches this class; this is not valid for Token or register kinds.\n  std::string PredicateMethod;\n\n  /// RenderMethod - The name of the operand method to add this operand to an\n  /// MCInst; this is not valid for Token or register kinds.\n  std::string RenderMethod;\n\n  /// ParserMethod - The name of the operand method to do a target specific\n  /// parsing on the operand.\n  std::string ParserMethod;\n\n  /// For register classes: the records for all the registers in this class.\n  RegisterSet Registers;\n\n  /// For custom match classes: the diagnostic kind for when the predicate fails.\n  std::string DiagnosticType;\n\n  /// For custom match classes: the diagnostic string for when the predicate fails.\n  std::string DiagnosticString;\n\n  /// Is this operand optional and not always required.\n  bool IsOptional;\n\n  /// DefaultMethod - The name of the method that returns the default operand\n  /// for optional operand\n  std::string DefaultMethod;\n\npublic:\n  /// isRegisterClass() - Check if this is a register class.\n  bool isRegisterClass() const {\n    return Kind >= RegisterClass0 && Kind < UserClass0;\n  }\n\n  /// isUserClass() - Check if this is a user defined class.\n  bool isUserClass() const {\n    return Kind >= UserClass0;\n  }\n\n  /// isRelatedTo - Check whether this class is \"related\" to \\p RHS. Classes\n  /// are related if they are in the same class hierarchy.\n  bool isRelatedTo(const ClassInfo &RHS) const {\n    // Tokens are only related to tokens.\n    if (Kind == Token || RHS.Kind == Token)\n      return Kind == Token && RHS.Kind == Token;\n\n    // Registers classes are only related to registers classes, and only if\n    // their intersection is non-empty.\n    if (isRegisterClass() || RHS.isRegisterClass()) {\n      if (!isRegisterClass() || !RHS.isRegisterClass())\n        return false;\n\n      RegisterSet Tmp;\n      std::insert_iterator<RegisterSet> II(Tmp, Tmp.begin());\n      std::set_intersection(Registers.begin(), Registers.end(),\n                            RHS.Registers.begin(), RHS.Registers.end(),\n                            II, LessRecordByID());\n\n      return !Tmp.empty();\n    }\n\n    // Otherwise we have two users operands; they are related if they are in the\n    // same class hierarchy.\n    //\n    // FIXME: This is an oversimplification, they should only be related if they\n    // intersect, however we don't have that information.\n    assert(isUserClass() && RHS.isUserClass() && \"Unexpected class!\");\n    const ClassInfo *Root = this;\n    while (!Root->SuperClasses.empty())\n      Root = Root->SuperClasses.front();\n\n    const ClassInfo *RHSRoot = &RHS;\n    while (!RHSRoot->SuperClasses.empty())\n      RHSRoot = RHSRoot->SuperClasses.front();\n\n    return Root == RHSRoot;\n  }\n\n  /// isSubsetOf - Test whether this class is a subset of \\p RHS.\n  bool isSubsetOf(const ClassInfo &RHS) const {\n    // This is a subset of RHS if it is the same class...\n    if (this == &RHS)\n      return true;\n\n    // ... or if any of its super classes are a subset of RHS.\n    SmallVector<const ClassInfo *, 16> Worklist(SuperClasses.begin(),\n                                                SuperClasses.end());\n    SmallPtrSet<const ClassInfo *, 16> Visited;\n    while (!Worklist.empty()) {\n      auto *CI = Worklist.pop_back_val();\n      if (CI == &RHS)\n        return true;\n      for (auto *Super : CI->SuperClasses)\n        if (Visited.insert(Super).second)\n          Worklist.push_back(Super);\n    }\n\n    return false;\n  }\n\n  int getTreeDepth() const {\n    int Depth = 0;\n    const ClassInfo *Root = this;\n    while (!Root->SuperClasses.empty()) {\n      Depth++;\n      Root = Root->SuperClasses.front();\n    }\n    return Depth;\n  }\n\n  const ClassInfo *findRoot() const {\n    const ClassInfo *Root = this;\n    while (!Root->SuperClasses.empty())\n      Root = Root->SuperClasses.front();\n    return Root;\n  }\n\n  /// Compare two classes. This does not produce a total ordering, but does\n  /// guarantee that subclasses are sorted before their parents, and that the\n  /// ordering is transitive.\n  bool operator<(const ClassInfo &RHS) const {\n    if (this == &RHS)\n      return false;\n\n    // First, enforce the ordering between the three different types of class.\n    // Tokens sort before registers, which sort before user classes.\n    if (Kind == Token) {\n      if (RHS.Kind != Token)\n        return true;\n      assert(RHS.Kind == Token);\n    } else if (isRegisterClass()) {\n      if (RHS.Kind == Token)\n        return false;\n      else if (RHS.isUserClass())\n        return true;\n      assert(RHS.isRegisterClass());\n    } else if (isUserClass()) {\n      if (!RHS.isUserClass())\n        return false;\n      assert(RHS.isUserClass());\n    } else {\n      llvm_unreachable(\"Unknown ClassInfoKind\");\n    }\n\n    if (Kind == Token || isUserClass()) {\n      // Related tokens and user classes get sorted by depth in the inheritence\n      // tree (so that subclasses are before their parents).\n      if (isRelatedTo(RHS)) {\n        if (getTreeDepth() > RHS.getTreeDepth())\n          return true;\n        if (getTreeDepth() < RHS.getTreeDepth())\n          return false;\n      } else {\n        // Unrelated tokens and user classes are ordered by the name of their\n        // root nodes, so that there is a consistent ordering between\n        // unconnected trees.\n        return findRoot()->ValueName < RHS.findRoot()->ValueName;\n      }\n    } else if (isRegisterClass()) {\n      // For register sets, sort by number of registers. This guarantees that\n      // a set will always sort before all of it's strict supersets.\n      if (Registers.size() != RHS.Registers.size())\n        return Registers.size() < RHS.Registers.size();\n    } else {\n      llvm_unreachable(\"Unknown ClassInfoKind\");\n    }\n\n    // FIXME: We should be able to just return false here, as we only need a\n    // partial order (we use stable sorts, so this is deterministic) and the\n    // name of a class shouldn't be significant. However, some of the backends\n    // accidentally rely on this behaviour, so it will have to stay like this\n    // until they are fixed.\n    return ValueName < RHS.ValueName;\n  }\n};\n\nclass AsmVariantInfo {\npublic:\n  StringRef RegisterPrefix;\n  StringRef TokenizingCharacters;\n  StringRef SeparatorCharacters;\n  StringRef BreakCharacters;\n  StringRef Name;\n  int AsmVariantNo;\n};\n\n/// MatchableInfo - Helper class for storing the necessary information for an\n/// instruction or alias which is capable of being matched.\nstruct MatchableInfo {\n  struct AsmOperand {\n    /// Token - This is the token that the operand came from.\n    StringRef Token;\n\n    /// The unique class instance this operand should match.\n    ClassInfo *Class;\n\n    /// The operand name this is, if anything.\n    StringRef SrcOpName;\n\n    /// The operand name this is, before renaming for tied operands.\n    StringRef OrigSrcOpName;\n\n    /// The suboperand index within SrcOpName, or -1 for the entire operand.\n    int SubOpIdx;\n\n    /// Whether the token is \"isolated\", i.e., it is preceded and followed\n    /// by separators.\n    bool IsIsolatedToken;\n\n    /// Register record if this token is singleton register.\n    Record *SingletonReg;\n\n    explicit AsmOperand(bool IsIsolatedToken, StringRef T)\n        : Token(T), Class(nullptr), SubOpIdx(-1),\n          IsIsolatedToken(IsIsolatedToken), SingletonReg(nullptr) {}\n  };\n\n  /// ResOperand - This represents a single operand in the result instruction\n  /// generated by the match.  In cases (like addressing modes) where a single\n  /// assembler operand expands to multiple MCOperands, this represents the\n  /// single assembler operand, not the MCOperand.\n  struct ResOperand {\n    enum {\n      /// RenderAsmOperand - This represents an operand result that is\n      /// generated by calling the render method on the assembly operand.  The\n      /// corresponding AsmOperand is specified by AsmOperandNum.\n      RenderAsmOperand,\n\n      /// TiedOperand - This represents a result operand that is a duplicate of\n      /// a previous result operand.\n      TiedOperand,\n\n      /// ImmOperand - This represents an immediate value that is dumped into\n      /// the operand.\n      ImmOperand,\n\n      /// RegOperand - This represents a fixed register that is dumped in.\n      RegOperand\n    } Kind;\n\n    /// Tuple containing the index of the (earlier) result operand that should\n    /// be copied from, as well as the indices of the corresponding (parsed)\n    /// operands in the asm string.\n    struct TiedOperandsTuple {\n      unsigned ResOpnd;\n      unsigned SrcOpnd1Idx;\n      unsigned SrcOpnd2Idx;\n    };\n\n    union {\n      /// This is the operand # in the AsmOperands list that this should be\n      /// copied from.\n      unsigned AsmOperandNum;\n\n      /// Description of tied operands.\n      TiedOperandsTuple TiedOperands;\n\n      /// ImmVal - This is the immediate value added to the instruction.\n      int64_t ImmVal;\n\n      /// Register - This is the register record.\n      Record *Register;\n    };\n\n    /// MINumOperands - The number of MCInst operands populated by this\n    /// operand.\n    unsigned MINumOperands;\n\n    static ResOperand getRenderedOp(unsigned AsmOpNum, unsigned NumOperands) {\n      ResOperand X;\n      X.Kind = RenderAsmOperand;\n      X.AsmOperandNum = AsmOpNum;\n      X.MINumOperands = NumOperands;\n      return X;\n    }\n\n    static ResOperand getTiedOp(unsigned TiedOperandNum, unsigned SrcOperand1,\n                                unsigned SrcOperand2) {\n      ResOperand X;\n      X.Kind = TiedOperand;\n      X.TiedOperands = { TiedOperandNum, SrcOperand1, SrcOperand2 };\n      X.MINumOperands = 1;\n      return X;\n    }\n\n    static ResOperand getImmOp(int64_t Val) {\n      ResOperand X;\n      X.Kind = ImmOperand;\n      X.ImmVal = Val;\n      X.MINumOperands = 1;\n      return X;\n    }\n\n    static ResOperand getRegOp(Record *Reg) {\n      ResOperand X;\n      X.Kind = RegOperand;\n      X.Register = Reg;\n      X.MINumOperands = 1;\n      return X;\n    }\n  };\n\n  /// AsmVariantID - Target's assembly syntax variant no.\n  int AsmVariantID;\n\n  /// AsmString - The assembly string for this instruction (with variants\n  /// removed), e.g. \"movsx $src, $dst\".\n  std::string AsmString;\n\n  /// TheDef - This is the definition of the instruction or InstAlias that this\n  /// matchable came from.\n  Record *const TheDef;\n\n  /// DefRec - This is the definition that it came from.\n  PointerUnion<const CodeGenInstruction*, const CodeGenInstAlias*> DefRec;\n\n  const CodeGenInstruction *getResultInst() const {\n    if (DefRec.is<const CodeGenInstruction*>())\n      return DefRec.get<const CodeGenInstruction*>();\n    return DefRec.get<const CodeGenInstAlias*>()->ResultInst;\n  }\n\n  /// ResOperands - This is the operand list that should be built for the result\n  /// MCInst.\n  SmallVector<ResOperand, 8> ResOperands;\n\n  /// Mnemonic - This is the first token of the matched instruction, its\n  /// mnemonic.\n  StringRef Mnemonic;\n\n  /// AsmOperands - The textual operands that this instruction matches,\n  /// annotated with a class and where in the OperandList they were defined.\n  /// This directly corresponds to the tokenized AsmString after the mnemonic is\n  /// removed.\n  SmallVector<AsmOperand, 8> AsmOperands;\n\n  /// Predicates - The required subtarget features to match this instruction.\n  SmallVector<const SubtargetFeatureInfo *, 4> RequiredFeatures;\n\n  /// ConversionFnKind - The enum value which is passed to the generated\n  /// convertToMCInst to convert parsed operands into an MCInst for this\n  /// function.\n  std::string ConversionFnKind;\n\n  /// If this instruction is deprecated in some form.\n  bool HasDeprecation;\n\n  /// If this is an alias, this is use to determine whether or not to using\n  /// the conversion function defined by the instruction's AsmMatchConverter\n  /// or to use the function generated by the alias.\n  bool UseInstAsmMatchConverter;\n\n  MatchableInfo(const CodeGenInstruction &CGI)\n    : AsmVariantID(0), AsmString(CGI.AsmString), TheDef(CGI.TheDef), DefRec(&CGI),\n      UseInstAsmMatchConverter(true) {\n  }\n\n  MatchableInfo(std::unique_ptr<const CodeGenInstAlias> Alias)\n    : AsmVariantID(0), AsmString(Alias->AsmString), TheDef(Alias->TheDef),\n      DefRec(Alias.release()),\n      UseInstAsmMatchConverter(\n        TheDef->getValueAsBit(\"UseInstAsmMatchConverter\")) {\n  }\n\n  // Could remove this and the dtor if PointerUnion supported unique_ptr\n  // elements with a dynamic failure/assertion (like the one below) in the case\n  // where it was copied while being in an owning state.\n  MatchableInfo(const MatchableInfo &RHS)\n      : AsmVariantID(RHS.AsmVariantID), AsmString(RHS.AsmString),\n        TheDef(RHS.TheDef), DefRec(RHS.DefRec), ResOperands(RHS.ResOperands),\n        Mnemonic(RHS.Mnemonic), AsmOperands(RHS.AsmOperands),\n        RequiredFeatures(RHS.RequiredFeatures),\n        ConversionFnKind(RHS.ConversionFnKind),\n        HasDeprecation(RHS.HasDeprecation),\n        UseInstAsmMatchConverter(RHS.UseInstAsmMatchConverter) {\n    assert(!DefRec.is<const CodeGenInstAlias *>());\n  }\n\n  ~MatchableInfo() {\n    delete DefRec.dyn_cast<const CodeGenInstAlias*>();\n  }\n\n  // Two-operand aliases clone from the main matchable, but mark the second\n  // operand as a tied operand of the first for purposes of the assembler.\n  void formTwoOperandAlias(StringRef Constraint);\n\n  void initialize(const AsmMatcherInfo &Info,\n                  SmallPtrSetImpl<Record*> &SingletonRegisters,\n                  AsmVariantInfo const &Variant,\n                  bool HasMnemonicFirst);\n\n  /// validate - Return true if this matchable is a valid thing to match against\n  /// and perform a bunch of validity checking.\n  bool validate(StringRef CommentDelimiter, bool IsAlias) const;\n\n  /// findAsmOperand - Find the AsmOperand with the specified name and\n  /// suboperand index.\n  int findAsmOperand(StringRef N, int SubOpIdx) const {\n    auto I = find_if(AsmOperands, [&](const AsmOperand &Op) {\n      return Op.SrcOpName == N && Op.SubOpIdx == SubOpIdx;\n    });\n    return (I != AsmOperands.end()) ? I - AsmOperands.begin() : -1;\n  }\n\n  /// findAsmOperandNamed - Find the first AsmOperand with the specified name.\n  /// This does not check the suboperand index.\n  int findAsmOperandNamed(StringRef N, int LastIdx = -1) const {\n    auto I = std::find_if(AsmOperands.begin() + LastIdx + 1, AsmOperands.end(),\n                     [&](const AsmOperand &Op) { return Op.SrcOpName == N; });\n    return (I != AsmOperands.end()) ? I - AsmOperands.begin() : -1;\n  }\n\n  int findAsmOperandOriginallyNamed(StringRef N) const {\n    auto I =\n        find_if(AsmOperands,\n                [&](const AsmOperand &Op) { return Op.OrigSrcOpName == N; });\n    return (I != AsmOperands.end()) ? I - AsmOperands.begin() : -1;\n  }\n\n  void buildInstructionResultOperands();\n  void buildAliasResultOperands(bool AliasConstraintsAreChecked);\n\n  /// operator< - Compare two matchables.\n  bool operator<(const MatchableInfo &RHS) const {\n    // The primary comparator is the instruction mnemonic.\n    if (int Cmp = Mnemonic.compare_lower(RHS.Mnemonic))\n      return Cmp == -1;\n\n    if (AsmOperands.size() != RHS.AsmOperands.size())\n      return AsmOperands.size() < RHS.AsmOperands.size();\n\n    // Compare lexicographically by operand. The matcher validates that other\n    // orderings wouldn't be ambiguous using \\see couldMatchAmbiguouslyWith().\n    for (unsigned i = 0, e = AsmOperands.size(); i != e; ++i) {\n      if (*AsmOperands[i].Class < *RHS.AsmOperands[i].Class)\n        return true;\n      if (*RHS.AsmOperands[i].Class < *AsmOperands[i].Class)\n        return false;\n    }\n\n    // Give matches that require more features higher precedence. This is useful\n    // because we cannot define AssemblerPredicates with the negation of\n    // processor features. For example, ARM v6 \"nop\" may be either a HINT or\n    // MOV. With v6, we want to match HINT. The assembler has no way to\n    // predicate MOV under \"NoV6\", but HINT will always match first because it\n    // requires V6 while MOV does not.\n    if (RequiredFeatures.size() != RHS.RequiredFeatures.size())\n      return RequiredFeatures.size() > RHS.RequiredFeatures.size();\n\n    return false;\n  }\n\n  /// couldMatchAmbiguouslyWith - Check whether this matchable could\n  /// ambiguously match the same set of operands as \\p RHS (without being a\n  /// strictly superior match).\n  bool couldMatchAmbiguouslyWith(const MatchableInfo &RHS) const {\n    // The primary comparator is the instruction mnemonic.\n    if (Mnemonic != RHS.Mnemonic)\n      return false;\n\n    // Different variants can't conflict.\n    if (AsmVariantID != RHS.AsmVariantID)\n      return false;\n\n    // The number of operands is unambiguous.\n    if (AsmOperands.size() != RHS.AsmOperands.size())\n      return false;\n\n    // Otherwise, make sure the ordering of the two instructions is unambiguous\n    // by checking that either (a) a token or operand kind discriminates them,\n    // or (b) the ordering among equivalent kinds is consistent.\n\n    // Tokens and operand kinds are unambiguous (assuming a correct target\n    // specific parser).\n    for (unsigned i = 0, e = AsmOperands.size(); i != e; ++i)\n      if (AsmOperands[i].Class->Kind != RHS.AsmOperands[i].Class->Kind ||\n          AsmOperands[i].Class->Kind == ClassInfo::Token)\n        if (*AsmOperands[i].Class < *RHS.AsmOperands[i].Class ||\n            *RHS.AsmOperands[i].Class < *AsmOperands[i].Class)\n          return false;\n\n    // Otherwise, this operand could commute if all operands are equivalent, or\n    // there is a pair of operands that compare less than and a pair that\n    // compare greater than.\n    bool HasLT = false, HasGT = false;\n    for (unsigned i = 0, e = AsmOperands.size(); i != e; ++i) {\n      if (*AsmOperands[i].Class < *RHS.AsmOperands[i].Class)\n        HasLT = true;\n      if (*RHS.AsmOperands[i].Class < *AsmOperands[i].Class)\n        HasGT = true;\n    }\n\n    return HasLT == HasGT;\n  }\n\n  void dump() const;\n\nprivate:\n  void tokenizeAsmString(AsmMatcherInfo const &Info,\n                         AsmVariantInfo const &Variant);\n  void addAsmOperand(StringRef Token, bool IsIsolatedToken = false);\n};\n\nstruct OperandMatchEntry {\n  unsigned OperandMask;\n  const MatchableInfo* MI;\n  ClassInfo *CI;\n\n  static OperandMatchEntry create(const MatchableInfo *mi, ClassInfo *ci,\n                                  unsigned opMask) {\n    OperandMatchEntry X;\n    X.OperandMask = opMask;\n    X.CI = ci;\n    X.MI = mi;\n    return X;\n  }\n};\n\nclass AsmMatcherInfo {\npublic:\n  /// Tracked Records\n  RecordKeeper &Records;\n\n  /// The tablegen AsmParser record.\n  Record *AsmParser;\n\n  /// Target - The target information.\n  CodeGenTarget &Target;\n\n  /// The classes which are needed for matching.\n  std::forward_list<ClassInfo> Classes;\n\n  /// The information on the matchables to match.\n  std::vector<std::unique_ptr<MatchableInfo>> Matchables;\n\n  /// Info for custom matching operands by user defined methods.\n  std::vector<OperandMatchEntry> OperandMatchInfo;\n\n  /// Map of Register records to their class information.\n  typedef std::map<Record*, ClassInfo*, LessRecordByID> RegisterClassesTy;\n  RegisterClassesTy RegisterClasses;\n\n  /// Map of Predicate records to their subtarget information.\n  std::map<Record *, SubtargetFeatureInfo, LessRecordByID> SubtargetFeatures;\n\n  /// Map of AsmOperandClass records to their class information.\n  std::map<Record*, ClassInfo*> AsmOperandClasses;\n\n  /// Map of RegisterClass records to their class information.\n  std::map<Record*, ClassInfo*> RegisterClassClasses;\n\nprivate:\n  /// Map of token to class information which has already been constructed.\n  std::map<std::string, ClassInfo*> TokenClasses;\n\nprivate:\n  /// getTokenClass - Lookup or create the class for the given token.\n  ClassInfo *getTokenClass(StringRef Token);\n\n  /// getOperandClass - Lookup or create the class for the given operand.\n  ClassInfo *getOperandClass(const CGIOperandList::OperandInfo &OI,\n                             int SubOpIdx);\n  ClassInfo *getOperandClass(Record *Rec, int SubOpIdx);\n\n  /// buildRegisterClasses - Build the ClassInfo* instances for register\n  /// classes.\n  void buildRegisterClasses(SmallPtrSetImpl<Record*> &SingletonRegisters);\n\n  /// buildOperandClasses - Build the ClassInfo* instances for user defined\n  /// operand classes.\n  void buildOperandClasses();\n\n  void buildInstructionOperandReference(MatchableInfo *II, StringRef OpName,\n                                        unsigned AsmOpIdx);\n  void buildAliasOperandReference(MatchableInfo *II, StringRef OpName,\n                                  MatchableInfo::AsmOperand &Op);\n\npublic:\n  AsmMatcherInfo(Record *AsmParser,\n                 CodeGenTarget &Target,\n                 RecordKeeper &Records);\n\n  /// Construct the various tables used during matching.\n  void buildInfo();\n\n  /// buildOperandMatchInfo - Build the necessary information to handle user\n  /// defined operand parsing methods.\n  void buildOperandMatchInfo();\n\n  /// getSubtargetFeature - Lookup or create the subtarget feature info for the\n  /// given operand.\n  const SubtargetFeatureInfo *getSubtargetFeature(Record *Def) const {\n    assert(Def->isSubClassOf(\"Predicate\") && \"Invalid predicate type!\");\n    const auto &I = SubtargetFeatures.find(Def);\n    return I == SubtargetFeatures.end() ? nullptr : &I->second;\n  }\n\n  RecordKeeper &getRecords() const {\n    return Records;\n  }\n\n  bool hasOptionalOperands() const {\n    return any_of(Classes,\n                  [](const ClassInfo &Class) { return Class.IsOptional; });\n  }\n};\n\n} // end anonymous namespace\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nLLVM_DUMP_METHOD void MatchableInfo::dump() const {\n  errs() << TheDef->getName() << \" -- \" << \"flattened:\\\"\" << AsmString <<\"\\\"\\n\";\n\n  errs() << \"  variant: \" << AsmVariantID << \"\\n\";\n\n  for (unsigned i = 0, e = AsmOperands.size(); i != e; ++i) {\n    const AsmOperand &Op = AsmOperands[i];\n    errs() << \"  op[\" << i << \"] = \" << Op.Class->ClassName << \" - \";\n    errs() << '\\\"' << Op.Token << \"\\\"\\n\";\n  }\n}\n#endif\n\nstatic std::pair<StringRef, StringRef>\nparseTwoOperandConstraint(StringRef S, ArrayRef<SMLoc> Loc) {\n  // Split via the '='.\n  std::pair<StringRef, StringRef> Ops = S.split('=');\n  if (Ops.second == \"\")\n    PrintFatalError(Loc, \"missing '=' in two-operand alias constraint\");\n  // Trim whitespace and the leading '$' on the operand names.\n  size_t start = Ops.first.find_first_of('$');\n  if (start == std::string::npos)\n    PrintFatalError(Loc, \"expected '$' prefix on asm operand name\");\n  Ops.first = Ops.first.slice(start + 1, std::string::npos);\n  size_t end = Ops.first.find_last_of(\" \\t\");\n  Ops.first = Ops.first.slice(0, end);\n  // Now the second operand.\n  start = Ops.second.find_first_of('$');\n  if (start == std::string::npos)\n    PrintFatalError(Loc, \"expected '$' prefix on asm operand name\");\n  Ops.second = Ops.second.slice(start + 1, std::string::npos);\n  end = Ops.second.find_last_of(\" \\t\");\n  Ops.first = Ops.first.slice(0, end);\n  return Ops;\n}\n\nvoid MatchableInfo::formTwoOperandAlias(StringRef Constraint) {\n  // Figure out which operands are aliased and mark them as tied.\n  std::pair<StringRef, StringRef> Ops =\n    parseTwoOperandConstraint(Constraint, TheDef->getLoc());\n\n  // Find the AsmOperands that refer to the operands we're aliasing.\n  int SrcAsmOperand = findAsmOperandNamed(Ops.first);\n  int DstAsmOperand = findAsmOperandNamed(Ops.second);\n  if (SrcAsmOperand == -1)\n    PrintFatalError(TheDef->getLoc(),\n                    \"unknown source two-operand alias operand '\" + Ops.first +\n                    \"'.\");\n  if (DstAsmOperand == -1)\n    PrintFatalError(TheDef->getLoc(),\n                    \"unknown destination two-operand alias operand '\" +\n                    Ops.second + \"'.\");\n\n  // Find the ResOperand that refers to the operand we're aliasing away\n  // and update it to refer to the combined operand instead.\n  for (ResOperand &Op : ResOperands) {\n    if (Op.Kind == ResOperand::RenderAsmOperand &&\n        Op.AsmOperandNum == (unsigned)SrcAsmOperand) {\n      Op.AsmOperandNum = DstAsmOperand;\n      break;\n    }\n  }\n  // Remove the AsmOperand for the alias operand.\n  AsmOperands.erase(AsmOperands.begin() + SrcAsmOperand);\n  // Adjust the ResOperand references to any AsmOperands that followed\n  // the one we just deleted.\n  for (ResOperand &Op : ResOperands) {\n    switch(Op.Kind) {\n    default:\n      // Nothing to do for operands that don't reference AsmOperands.\n      break;\n    case ResOperand::RenderAsmOperand:\n      if (Op.AsmOperandNum > (unsigned)SrcAsmOperand)\n        --Op.AsmOperandNum;\n      break;\n    }\n  }\n}\n\n/// extractSingletonRegisterForAsmOperand - Extract singleton register,\n/// if present, from specified token.\nstatic void\nextractSingletonRegisterForAsmOperand(MatchableInfo::AsmOperand &Op,\n                                      const AsmMatcherInfo &Info,\n                                      StringRef RegisterPrefix) {\n  StringRef Tok = Op.Token;\n\n  // If this token is not an isolated token, i.e., it isn't separated from\n  // other tokens (e.g. with whitespace), don't interpret it as a register name.\n  if (!Op.IsIsolatedToken)\n    return;\n\n  if (RegisterPrefix.empty()) {\n    std::string LoweredTok = Tok.lower();\n    if (const CodeGenRegister *Reg = Info.Target.getRegisterByName(LoweredTok))\n      Op.SingletonReg = Reg->TheDef;\n    return;\n  }\n\n  if (!Tok.startswith(RegisterPrefix))\n    return;\n\n  StringRef RegName = Tok.substr(RegisterPrefix.size());\n  if (const CodeGenRegister *Reg = Info.Target.getRegisterByName(RegName))\n    Op.SingletonReg = Reg->TheDef;\n\n  // If there is no register prefix (i.e. \"%\" in \"%eax\"), then this may\n  // be some random non-register token, just ignore it.\n}\n\nvoid MatchableInfo::initialize(const AsmMatcherInfo &Info,\n                               SmallPtrSetImpl<Record*> &SingletonRegisters,\n                               AsmVariantInfo const &Variant,\n                               bool HasMnemonicFirst) {\n  AsmVariantID = Variant.AsmVariantNo;\n  AsmString =\n    CodeGenInstruction::FlattenAsmStringVariants(AsmString,\n                                                 Variant.AsmVariantNo);\n\n  tokenizeAsmString(Info, Variant);\n\n  // The first token of the instruction is the mnemonic, which must be a\n  // simple string, not a $foo variable or a singleton register.\n  if (AsmOperands.empty())\n    PrintFatalError(TheDef->getLoc(),\n                  \"Instruction '\" + TheDef->getName() + \"' has no tokens\");\n\n  assert(!AsmOperands[0].Token.empty());\n  if (HasMnemonicFirst) {\n    Mnemonic = AsmOperands[0].Token;\n    if (Mnemonic[0] == '$')\n      PrintFatalError(TheDef->getLoc(),\n                      \"Invalid instruction mnemonic '\" + Mnemonic + \"'!\");\n\n    // Remove the first operand, it is tracked in the mnemonic field.\n    AsmOperands.erase(AsmOperands.begin());\n  } else if (AsmOperands[0].Token[0] != '$')\n    Mnemonic = AsmOperands[0].Token;\n\n  // Compute the require features.\n  for (Record *Predicate : TheDef->getValueAsListOfDefs(\"Predicates\"))\n    if (const SubtargetFeatureInfo *Feature =\n            Info.getSubtargetFeature(Predicate))\n      RequiredFeatures.push_back(Feature);\n\n  // Collect singleton registers, if used.\n  for (MatchableInfo::AsmOperand &Op : AsmOperands) {\n    extractSingletonRegisterForAsmOperand(Op, Info, Variant.RegisterPrefix);\n    if (Record *Reg = Op.SingletonReg)\n      SingletonRegisters.insert(Reg);\n  }\n\n  const RecordVal *DepMask = TheDef->getValue(\"DeprecatedFeatureMask\");\n  if (!DepMask)\n    DepMask = TheDef->getValue(\"ComplexDeprecationPredicate\");\n\n  HasDeprecation =\n      DepMask ? !DepMask->getValue()->getAsUnquotedString().empty() : false;\n}\n\n/// Append an AsmOperand for the given substring of AsmString.\nvoid MatchableInfo::addAsmOperand(StringRef Token, bool IsIsolatedToken) {\n  AsmOperands.push_back(AsmOperand(IsIsolatedToken, Token));\n}\n\n/// tokenizeAsmString - Tokenize a simplified assembly string.\nvoid MatchableInfo::tokenizeAsmString(const AsmMatcherInfo &Info,\n                                      AsmVariantInfo const &Variant) {\n  StringRef String = AsmString;\n  size_t Prev = 0;\n  bool InTok = false;\n  bool IsIsolatedToken = true;\n  for (size_t i = 0, e = String.size(); i != e; ++i) {\n    char Char = String[i];\n    if (Variant.BreakCharacters.find(Char) != std::string::npos) {\n      if (InTok) {\n        addAsmOperand(String.slice(Prev, i), false);\n        Prev = i;\n        IsIsolatedToken = false;\n      }\n      InTok = true;\n      continue;\n    }\n    if (Variant.TokenizingCharacters.find(Char) != std::string::npos) {\n      if (InTok) {\n        addAsmOperand(String.slice(Prev, i), IsIsolatedToken);\n        InTok = false;\n        IsIsolatedToken = false;\n      }\n      addAsmOperand(String.slice(i, i + 1), IsIsolatedToken);\n      Prev = i + 1;\n      IsIsolatedToken = true;\n      continue;\n    }\n    if (Variant.SeparatorCharacters.find(Char) != std::string::npos) {\n      if (InTok) {\n        addAsmOperand(String.slice(Prev, i), IsIsolatedToken);\n        InTok = false;\n      }\n      Prev = i + 1;\n      IsIsolatedToken = true;\n      continue;\n    }\n\n    switch (Char) {\n    case '\\\\':\n      if (InTok) {\n        addAsmOperand(String.slice(Prev, i), false);\n        InTok = false;\n        IsIsolatedToken = false;\n      }\n      ++i;\n      assert(i != String.size() && \"Invalid quoted character\");\n      addAsmOperand(String.slice(i, i + 1), IsIsolatedToken);\n      Prev = i + 1;\n      IsIsolatedToken = false;\n      break;\n\n    case '$': {\n      if (InTok) {\n        addAsmOperand(String.slice(Prev, i), IsIsolatedToken);\n        InTok = false;\n        IsIsolatedToken = false;\n      }\n\n      // If this isn't \"${\", start new identifier looking like \"$xxx\"\n      if (i + 1 == String.size() || String[i + 1] != '{') {\n        Prev = i;\n        break;\n      }\n\n      size_t EndPos = String.find('}', i);\n      assert(EndPos != StringRef::npos &&\n             \"Missing brace in operand reference!\");\n      addAsmOperand(String.slice(i, EndPos+1), IsIsolatedToken);\n      Prev = EndPos + 1;\n      i = EndPos;\n      IsIsolatedToken = false;\n      break;\n    }\n\n    default:\n      InTok = true;\n      break;\n    }\n  }\n  if (InTok && Prev != String.size())\n    addAsmOperand(String.substr(Prev), IsIsolatedToken);\n}\n\nbool MatchableInfo::validate(StringRef CommentDelimiter, bool IsAlias) const {\n  // Reject matchables with no .s string.\n  if (AsmString.empty())\n    PrintFatalError(TheDef->getLoc(), \"instruction with empty asm string\");\n\n  // Reject any matchables with a newline in them, they should be marked\n  // isCodeGenOnly if they are pseudo instructions.\n  if (AsmString.find('\\n') != std::string::npos)\n    PrintFatalError(TheDef->getLoc(),\n                  \"multiline instruction is not valid for the asmparser, \"\n                  \"mark it isCodeGenOnly\");\n\n  // Remove comments from the asm string.  We know that the asmstring only\n  // has one line.\n  if (!CommentDelimiter.empty() &&\n      StringRef(AsmString).find(CommentDelimiter) != StringRef::npos)\n    PrintFatalError(TheDef->getLoc(),\n                  \"asmstring for instruction has comment character in it, \"\n                  \"mark it isCodeGenOnly\");\n\n  // Reject matchables with operand modifiers, these aren't something we can\n  // handle, the target should be refactored to use operands instead of\n  // modifiers.\n  //\n  // Also, check for instructions which reference the operand multiple times,\n  // if they don't define a custom AsmMatcher: this implies a constraint that\n  // the built-in matching code would not honor.\n  std::set<std::string> OperandNames;\n  for (const AsmOperand &Op : AsmOperands) {\n    StringRef Tok = Op.Token;\n    if (Tok[0] == '$' && Tok.find(':') != StringRef::npos)\n      PrintFatalError(TheDef->getLoc(),\n                      \"matchable with operand modifier '\" + Tok +\n                      \"' not supported by asm matcher.  Mark isCodeGenOnly!\");\n    // Verify that any operand is only mentioned once.\n    // We reject aliases and ignore instructions for now.\n    if (!IsAlias && TheDef->getValueAsString(\"AsmMatchConverter\").empty() &&\n        Tok[0] == '$' && !OperandNames.insert(std::string(Tok)).second) {\n      LLVM_DEBUG({\n        errs() << \"warning: '\" << TheDef->getName() << \"': \"\n               << \"ignoring instruction with tied operand '\"\n               << Tok << \"'\\n\";\n      });\n      return false;\n    }\n  }\n\n  return true;\n}\n\nstatic std::string getEnumNameForToken(StringRef Str) {\n  std::string Res;\n\n  for (char C : Str) {\n    switch (C) {\n    case '*': Res += \"_STAR_\"; break;\n    case '%': Res += \"_PCT_\"; break;\n    case ':': Res += \"_COLON_\"; break;\n    case '!': Res += \"_EXCLAIM_\"; break;\n    case '.': Res += \"_DOT_\"; break;\n    case '<': Res += \"_LT_\"; break;\n    case '>': Res += \"_GT_\"; break;\n    case '-': Res += \"_MINUS_\"; break;\n    case '#': Res += \"_HASH_\"; break;\n    default:\n      if (isAlnum(C))\n        Res += C;\n      else\n        Res += \"_\" + utostr((unsigned)C) + \"_\";\n    }\n  }\n\n  return Res;\n}\n\nClassInfo *AsmMatcherInfo::getTokenClass(StringRef Token) {\n  ClassInfo *&Entry = TokenClasses[std::string(Token)];\n\n  if (!Entry) {\n    Classes.emplace_front();\n    Entry = &Classes.front();\n    Entry->Kind = ClassInfo::Token;\n    Entry->ClassName = \"Token\";\n    Entry->Name = \"MCK_\" + getEnumNameForToken(Token);\n    Entry->ValueName = std::string(Token);\n    Entry->PredicateMethod = \"<invalid>\";\n    Entry->RenderMethod = \"<invalid>\";\n    Entry->ParserMethod = \"\";\n    Entry->DiagnosticType = \"\";\n    Entry->IsOptional = false;\n    Entry->DefaultMethod = \"<invalid>\";\n  }\n\n  return Entry;\n}\n\nClassInfo *\nAsmMatcherInfo::getOperandClass(const CGIOperandList::OperandInfo &OI,\n                                int SubOpIdx) {\n  Record *Rec = OI.Rec;\n  if (SubOpIdx != -1)\n    Rec = cast<DefInit>(OI.MIOperandInfo->getArg(SubOpIdx))->getDef();\n  return getOperandClass(Rec, SubOpIdx);\n}\n\nClassInfo *\nAsmMatcherInfo::getOperandClass(Record *Rec, int SubOpIdx) {\n  if (Rec->isSubClassOf(\"RegisterOperand\")) {\n    // RegisterOperand may have an associated ParserMatchClass. If it does,\n    // use it, else just fall back to the underlying register class.\n    const RecordVal *R = Rec->getValue(\"ParserMatchClass\");\n    if (!R || !R->getValue())\n      PrintFatalError(Rec->getLoc(),\n                      \"Record `\" + Rec->getName() +\n                          \"' does not have a ParserMatchClass!\\n\");\n\n    if (DefInit *DI= dyn_cast<DefInit>(R->getValue())) {\n      Record *MatchClass = DI->getDef();\n      if (ClassInfo *CI = AsmOperandClasses[MatchClass])\n        return CI;\n    }\n\n    // No custom match class. Just use the register class.\n    Record *ClassRec = Rec->getValueAsDef(\"RegClass\");\n    if (!ClassRec)\n      PrintFatalError(Rec->getLoc(), \"RegisterOperand `\" + Rec->getName() +\n                    \"' has no associated register class!\\n\");\n    if (ClassInfo *CI = RegisterClassClasses[ClassRec])\n      return CI;\n    PrintFatalError(Rec->getLoc(), \"register class has no class info!\");\n  }\n\n  if (Rec->isSubClassOf(\"RegisterClass\")) {\n    if (ClassInfo *CI = RegisterClassClasses[Rec])\n      return CI;\n    PrintFatalError(Rec->getLoc(), \"register class has no class info!\");\n  }\n\n  if (!Rec->isSubClassOf(\"Operand\"))\n    PrintFatalError(Rec->getLoc(), \"Operand `\" + Rec->getName() +\n                  \"' does not derive from class Operand!\\n\");\n  Record *MatchClass = Rec->getValueAsDef(\"ParserMatchClass\");\n  if (ClassInfo *CI = AsmOperandClasses[MatchClass])\n    return CI;\n\n  PrintFatalError(Rec->getLoc(), \"operand has no match class!\");\n}\n\nstruct LessRegisterSet {\n  bool operator() (const RegisterSet &LHS, const RegisterSet & RHS) const {\n    // std::set<T> defines its own compariso \"operator<\", but it\n    // performs a lexicographical comparison by T's innate comparison\n    // for some reason. We don't want non-deterministic pointer\n    // comparisons so use this instead.\n    return std::lexicographical_compare(LHS.begin(), LHS.end(),\n                                        RHS.begin(), RHS.end(),\n                                        LessRecordByID());\n  }\n};\n\nvoid AsmMatcherInfo::\nbuildRegisterClasses(SmallPtrSetImpl<Record*> &SingletonRegisters) {\n  const auto &Registers = Target.getRegBank().getRegisters();\n  auto &RegClassList = Target.getRegBank().getRegClasses();\n\n  typedef std::set<RegisterSet, LessRegisterSet> RegisterSetSet;\n\n  // The register sets used for matching.\n  RegisterSetSet RegisterSets;\n\n  // Gather the defined sets.\n  for (const CodeGenRegisterClass &RC : RegClassList)\n    RegisterSets.insert(\n        RegisterSet(RC.getOrder().begin(), RC.getOrder().end()));\n\n  // Add any required singleton sets.\n  for (Record *Rec : SingletonRegisters) {\n    RegisterSets.insert(RegisterSet(&Rec, &Rec + 1));\n  }\n\n  // Introduce derived sets where necessary (when a register does not determine\n  // a unique register set class), and build the mapping of registers to the set\n  // they should classify to.\n  std::map<Record*, RegisterSet> RegisterMap;\n  for (const CodeGenRegister &CGR : Registers) {\n    // Compute the intersection of all sets containing this register.\n    RegisterSet ContainingSet;\n\n    for (const RegisterSet &RS : RegisterSets) {\n      if (!RS.count(CGR.TheDef))\n        continue;\n\n      if (ContainingSet.empty()) {\n        ContainingSet = RS;\n        continue;\n      }\n\n      RegisterSet Tmp;\n      std::swap(Tmp, ContainingSet);\n      std::insert_iterator<RegisterSet> II(ContainingSet,\n                                           ContainingSet.begin());\n      std::set_intersection(Tmp.begin(), Tmp.end(), RS.begin(), RS.end(), II,\n                            LessRecordByID());\n    }\n\n    if (!ContainingSet.empty()) {\n      RegisterSets.insert(ContainingSet);\n      RegisterMap.insert(std::make_pair(CGR.TheDef, ContainingSet));\n    }\n  }\n\n  // Construct the register classes.\n  std::map<RegisterSet, ClassInfo*, LessRegisterSet> RegisterSetClasses;\n  unsigned Index = 0;\n  for (const RegisterSet &RS : RegisterSets) {\n    Classes.emplace_front();\n    ClassInfo *CI = &Classes.front();\n    CI->Kind = ClassInfo::RegisterClass0 + Index;\n    CI->ClassName = \"Reg\" + utostr(Index);\n    CI->Name = \"MCK_Reg\" + utostr(Index);\n    CI->ValueName = \"\";\n    CI->PredicateMethod = \"\"; // unused\n    CI->RenderMethod = \"addRegOperands\";\n    CI->Registers = RS;\n    // FIXME: diagnostic type.\n    CI->DiagnosticType = \"\";\n    CI->IsOptional = false;\n    CI->DefaultMethod = \"\"; // unused\n    RegisterSetClasses.insert(std::make_pair(RS, CI));\n    ++Index;\n  }\n\n  // Find the superclasses; we could compute only the subgroup lattice edges,\n  // but there isn't really a point.\n  for (const RegisterSet &RS : RegisterSets) {\n    ClassInfo *CI = RegisterSetClasses[RS];\n    for (const RegisterSet &RS2 : RegisterSets)\n      if (RS != RS2 &&\n          std::includes(RS2.begin(), RS2.end(), RS.begin(), RS.end(),\n                        LessRecordByID()))\n        CI->SuperClasses.push_back(RegisterSetClasses[RS2]);\n  }\n\n  // Name the register classes which correspond to a user defined RegisterClass.\n  for (const CodeGenRegisterClass &RC : RegClassList) {\n    // Def will be NULL for non-user defined register classes.\n    Record *Def = RC.getDef();\n    if (!Def)\n      continue;\n    ClassInfo *CI = RegisterSetClasses[RegisterSet(RC.getOrder().begin(),\n                                                   RC.getOrder().end())];\n    if (CI->ValueName.empty()) {\n      CI->ClassName = RC.getName();\n      CI->Name = \"MCK_\" + RC.getName();\n      CI->ValueName = RC.getName();\n    } else\n      CI->ValueName = CI->ValueName + \",\" + RC.getName();\n\n    Init *DiagnosticType = Def->getValueInit(\"DiagnosticType\");\n    if (StringInit *SI = dyn_cast<StringInit>(DiagnosticType))\n      CI->DiagnosticType = std::string(SI->getValue());\n\n    Init *DiagnosticString = Def->getValueInit(\"DiagnosticString\");\n    if (StringInit *SI = dyn_cast<StringInit>(DiagnosticString))\n      CI->DiagnosticString = std::string(SI->getValue());\n\n    // If we have a diagnostic string but the diagnostic type is not specified\n    // explicitly, create an anonymous diagnostic type.\n    if (!CI->DiagnosticString.empty() && CI->DiagnosticType.empty())\n      CI->DiagnosticType = RC.getName();\n\n    RegisterClassClasses.insert(std::make_pair(Def, CI));\n  }\n\n  // Populate the map for individual registers.\n  for (std::map<Record*, RegisterSet>::iterator it = RegisterMap.begin(),\n         ie = RegisterMap.end(); it != ie; ++it)\n    RegisterClasses[it->first] = RegisterSetClasses[it->second];\n\n  // Name the register classes which correspond to singleton registers.\n  for (Record *Rec : SingletonRegisters) {\n    ClassInfo *CI = RegisterClasses[Rec];\n    assert(CI && \"Missing singleton register class info!\");\n\n    if (CI->ValueName.empty()) {\n      CI->ClassName = std::string(Rec->getName());\n      CI->Name = \"MCK_\" + Rec->getName().str();\n      CI->ValueName = std::string(Rec->getName());\n    } else\n      CI->ValueName = CI->ValueName + \",\" + Rec->getName().str();\n  }\n}\n\nvoid AsmMatcherInfo::buildOperandClasses() {\n  std::vector<Record*> AsmOperands =\n    Records.getAllDerivedDefinitions(\"AsmOperandClass\");\n\n  // Pre-populate AsmOperandClasses map.\n  for (Record *Rec : AsmOperands) {\n    Classes.emplace_front();\n    AsmOperandClasses[Rec] = &Classes.front();\n  }\n\n  unsigned Index = 0;\n  for (Record *Rec : AsmOperands) {\n    ClassInfo *CI = AsmOperandClasses[Rec];\n    CI->Kind = ClassInfo::UserClass0 + Index;\n\n    ListInit *Supers = Rec->getValueAsListInit(\"SuperClasses\");\n    for (Init *I : Supers->getValues()) {\n      DefInit *DI = dyn_cast<DefInit>(I);\n      if (!DI) {\n        PrintError(Rec->getLoc(), \"Invalid super class reference!\");\n        continue;\n      }\n\n      ClassInfo *SC = AsmOperandClasses[DI->getDef()];\n      if (!SC)\n        PrintError(Rec->getLoc(), \"Invalid super class reference!\");\n      else\n        CI->SuperClasses.push_back(SC);\n    }\n    CI->ClassName = std::string(Rec->getValueAsString(\"Name\"));\n    CI->Name = \"MCK_\" + CI->ClassName;\n    CI->ValueName = std::string(Rec->getName());\n\n    // Get or construct the predicate method name.\n    Init *PMName = Rec->getValueInit(\"PredicateMethod\");\n    if (StringInit *SI = dyn_cast<StringInit>(PMName)) {\n      CI->PredicateMethod = std::string(SI->getValue());\n    } else {\n      assert(isa<UnsetInit>(PMName) && \"Unexpected PredicateMethod field!\");\n      CI->PredicateMethod = \"is\" + CI->ClassName;\n    }\n\n    // Get or construct the render method name.\n    Init *RMName = Rec->getValueInit(\"RenderMethod\");\n    if (StringInit *SI = dyn_cast<StringInit>(RMName)) {\n      CI->RenderMethod = std::string(SI->getValue());\n    } else {\n      assert(isa<UnsetInit>(RMName) && \"Unexpected RenderMethod field!\");\n      CI->RenderMethod = \"add\" + CI->ClassName + \"Operands\";\n    }\n\n    // Get the parse method name or leave it as empty.\n    Init *PRMName = Rec->getValueInit(\"ParserMethod\");\n    if (StringInit *SI = dyn_cast<StringInit>(PRMName))\n      CI->ParserMethod = std::string(SI->getValue());\n\n    // Get the diagnostic type and string or leave them as empty.\n    Init *DiagnosticType = Rec->getValueInit(\"DiagnosticType\");\n    if (StringInit *SI = dyn_cast<StringInit>(DiagnosticType))\n      CI->DiagnosticType = std::string(SI->getValue());\n    Init *DiagnosticString = Rec->getValueInit(\"DiagnosticString\");\n    if (StringInit *SI = dyn_cast<StringInit>(DiagnosticString))\n      CI->DiagnosticString = std::string(SI->getValue());\n    // If we have a DiagnosticString, we need a DiagnosticType for use within\n    // the matcher.\n    if (!CI->DiagnosticString.empty() && CI->DiagnosticType.empty())\n      CI->DiagnosticType = CI->ClassName;\n\n    Init *IsOptional = Rec->getValueInit(\"IsOptional\");\n    if (BitInit *BI = dyn_cast<BitInit>(IsOptional))\n      CI->IsOptional = BI->getValue();\n\n    // Get or construct the default method name.\n    Init *DMName = Rec->getValueInit(\"DefaultMethod\");\n    if (StringInit *SI = dyn_cast<StringInit>(DMName)) {\n      CI->DefaultMethod = std::string(SI->getValue());\n    } else {\n      assert(isa<UnsetInit>(DMName) && \"Unexpected DefaultMethod field!\");\n      CI->DefaultMethod = \"default\" + CI->ClassName + \"Operands\";\n    }\n\n    ++Index;\n  }\n}\n\nAsmMatcherInfo::AsmMatcherInfo(Record *asmParser,\n                               CodeGenTarget &target,\n                               RecordKeeper &records)\n  : Records(records), AsmParser(asmParser), Target(target) {\n}\n\n/// buildOperandMatchInfo - Build the necessary information to handle user\n/// defined operand parsing methods.\nvoid AsmMatcherInfo::buildOperandMatchInfo() {\n\n  /// Map containing a mask with all operands indices that can be found for\n  /// that class inside a instruction.\n  typedef std::map<ClassInfo *, unsigned, deref<std::less<>>> OpClassMaskTy;\n  OpClassMaskTy OpClassMask;\n\n  for (const auto &MI : Matchables) {\n    OpClassMask.clear();\n\n    // Keep track of all operands of this instructions which belong to the\n    // same class.\n    for (unsigned i = 0, e = MI->AsmOperands.size(); i != e; ++i) {\n      const MatchableInfo::AsmOperand &Op = MI->AsmOperands[i];\n      if (Op.Class->ParserMethod.empty())\n        continue;\n      unsigned &OperandMask = OpClassMask[Op.Class];\n      OperandMask |= (1 << i);\n    }\n\n    // Generate operand match info for each mnemonic/operand class pair.\n    for (const auto &OCM : OpClassMask) {\n      unsigned OpMask = OCM.second;\n      ClassInfo *CI = OCM.first;\n      OperandMatchInfo.push_back(OperandMatchEntry::create(MI.get(), CI,\n                                                           OpMask));\n    }\n  }\n}\n\nvoid AsmMatcherInfo::buildInfo() {\n  // Build information about all of the AssemblerPredicates.\n  const std::vector<std::pair<Record *, SubtargetFeatureInfo>>\n      &SubtargetFeaturePairs = SubtargetFeatureInfo::getAll(Records);\n  SubtargetFeatures.insert(SubtargetFeaturePairs.begin(),\n                           SubtargetFeaturePairs.end());\n#ifndef NDEBUG\n  for (const auto &Pair : SubtargetFeatures)\n    LLVM_DEBUG(Pair.second.dump());\n#endif // NDEBUG\n\n  bool HasMnemonicFirst = AsmParser->getValueAsBit(\"HasMnemonicFirst\");\n  bool ReportMultipleNearMisses =\n      AsmParser->getValueAsBit(\"ReportMultipleNearMisses\");\n\n  // Parse the instructions; we need to do this first so that we can gather the\n  // singleton register classes.\n  SmallPtrSet<Record*, 16> SingletonRegisters;\n  unsigned VariantCount = Target.getAsmParserVariantCount();\n  for (unsigned VC = 0; VC != VariantCount; ++VC) {\n    Record *AsmVariant = Target.getAsmParserVariant(VC);\n    StringRef CommentDelimiter =\n        AsmVariant->getValueAsString(\"CommentDelimiter\");\n    AsmVariantInfo Variant;\n    Variant.RegisterPrefix = AsmVariant->getValueAsString(\"RegisterPrefix\");\n    Variant.TokenizingCharacters =\n        AsmVariant->getValueAsString(\"TokenizingCharacters\");\n    Variant.SeparatorCharacters =\n        AsmVariant->getValueAsString(\"SeparatorCharacters\");\n    Variant.BreakCharacters =\n        AsmVariant->getValueAsString(\"BreakCharacters\");\n    Variant.Name = AsmVariant->getValueAsString(\"Name\");\n    Variant.AsmVariantNo = AsmVariant->getValueAsInt(\"Variant\");\n\n    for (const CodeGenInstruction *CGI : Target.getInstructionsByEnumValue()) {\n\n      // If the tblgen -match-prefix option is specified (for tblgen hackers),\n      // filter the set of instructions we consider.\n      if (!StringRef(CGI->TheDef->getName()).startswith(MatchPrefix))\n        continue;\n\n      // Ignore \"codegen only\" instructions.\n      if (CGI->TheDef->getValueAsBit(\"isCodeGenOnly\"))\n        continue;\n\n      // Ignore instructions for different instructions\n      StringRef V = CGI->TheDef->getValueAsString(\"AsmVariantName\");\n      if (!V.empty() && V != Variant.Name)\n        continue;\n\n      auto II = std::make_unique<MatchableInfo>(*CGI);\n\n      II->initialize(*this, SingletonRegisters, Variant, HasMnemonicFirst);\n\n      // Ignore instructions which shouldn't be matched and diagnose invalid\n      // instruction definitions with an error.\n      if (!II->validate(CommentDelimiter, false))\n        continue;\n\n      Matchables.push_back(std::move(II));\n    }\n\n    // Parse all of the InstAlias definitions and stick them in the list of\n    // matchables.\n    std::vector<Record*> AllInstAliases =\n      Records.getAllDerivedDefinitions(\"InstAlias\");\n    for (unsigned i = 0, e = AllInstAliases.size(); i != e; ++i) {\n      auto Alias = std::make_unique<CodeGenInstAlias>(AllInstAliases[i],\n                                                       Target);\n\n      // If the tblgen -match-prefix option is specified (for tblgen hackers),\n      // filter the set of instruction aliases we consider, based on the target\n      // instruction.\n      if (!StringRef(Alias->ResultInst->TheDef->getName())\n            .startswith( MatchPrefix))\n        continue;\n\n      StringRef V = Alias->TheDef->getValueAsString(\"AsmVariantName\");\n      if (!V.empty() && V != Variant.Name)\n        continue;\n\n      auto II = std::make_unique<MatchableInfo>(std::move(Alias));\n\n      II->initialize(*this, SingletonRegisters, Variant, HasMnemonicFirst);\n\n      // Validate the alias definitions.\n      II->validate(CommentDelimiter, true);\n\n      Matchables.push_back(std::move(II));\n    }\n  }\n\n  // Build info for the register classes.\n  buildRegisterClasses(SingletonRegisters);\n\n  // Build info for the user defined assembly operand classes.\n  buildOperandClasses();\n\n  // Build the information about matchables, now that we have fully formed\n  // classes.\n  std::vector<std::unique_ptr<MatchableInfo>> NewMatchables;\n  for (auto &II : Matchables) {\n    // Parse the tokens after the mnemonic.\n    // Note: buildInstructionOperandReference may insert new AsmOperands, so\n    // don't precompute the loop bound.\n    for (unsigned i = 0; i != II->AsmOperands.size(); ++i) {\n      MatchableInfo::AsmOperand &Op = II->AsmOperands[i];\n      StringRef Token = Op.Token;\n\n      // Check for singleton registers.\n      if (Record *RegRecord = Op.SingletonReg) {\n        Op.Class = RegisterClasses[RegRecord];\n        assert(Op.Class && Op.Class->Registers.size() == 1 &&\n               \"Unexpected class for singleton register\");\n        continue;\n      }\n\n      // Check for simple tokens.\n      if (Token[0] != '$') {\n        Op.Class = getTokenClass(Token);\n        continue;\n      }\n\n      if (Token.size() > 1 && isdigit(Token[1])) {\n        Op.Class = getTokenClass(Token);\n        continue;\n      }\n\n      // Otherwise this is an operand reference.\n      StringRef OperandName;\n      if (Token[1] == '{')\n        OperandName = Token.substr(2, Token.size() - 3);\n      else\n        OperandName = Token.substr(1);\n\n      if (II->DefRec.is<const CodeGenInstruction*>())\n        buildInstructionOperandReference(II.get(), OperandName, i);\n      else\n        buildAliasOperandReference(II.get(), OperandName, Op);\n    }\n\n    if (II->DefRec.is<const CodeGenInstruction*>()) {\n      II->buildInstructionResultOperands();\n      // If the instruction has a two-operand alias, build up the\n      // matchable here. We'll add them in bulk at the end to avoid\n      // confusing this loop.\n      StringRef Constraint =\n          II->TheDef->getValueAsString(\"TwoOperandAliasConstraint\");\n      if (Constraint != \"\") {\n        // Start by making a copy of the original matchable.\n        auto AliasII = std::make_unique<MatchableInfo>(*II);\n\n        // Adjust it to be a two-operand alias.\n        AliasII->formTwoOperandAlias(Constraint);\n\n        // Add the alias to the matchables list.\n        NewMatchables.push_back(std::move(AliasII));\n      }\n    } else\n      // FIXME: The tied operands checking is not yet integrated with the\n      // framework for reporting multiple near misses. To prevent invalid\n      // formats from being matched with an alias if a tied-operands check\n      // would otherwise have disallowed it, we just disallow such constructs\n      // in TableGen completely.\n      II->buildAliasResultOperands(!ReportMultipleNearMisses);\n  }\n  if (!NewMatchables.empty())\n    Matchables.insert(Matchables.end(),\n                      std::make_move_iterator(NewMatchables.begin()),\n                      std::make_move_iterator(NewMatchables.end()));\n\n  // Process token alias definitions and set up the associated superclass\n  // information.\n  std::vector<Record*> AllTokenAliases =\n    Records.getAllDerivedDefinitions(\"TokenAlias\");\n  for (Record *Rec : AllTokenAliases) {\n    ClassInfo *FromClass = getTokenClass(Rec->getValueAsString(\"FromToken\"));\n    ClassInfo *ToClass = getTokenClass(Rec->getValueAsString(\"ToToken\"));\n    if (FromClass == ToClass)\n      PrintFatalError(Rec->getLoc(),\n                    \"error: Destination value identical to source value.\");\n    FromClass->SuperClasses.push_back(ToClass);\n  }\n\n  // Reorder classes so that classes precede super classes.\n  Classes.sort();\n\n#ifdef EXPENSIVE_CHECKS\n  // Verify that the table is sorted and operator < works transitively.\n  for (auto I = Classes.begin(), E = Classes.end(); I != E; ++I) {\n    for (auto J = I; J != E; ++J) {\n      assert(!(*J < *I));\n      assert(I == J || !J->isSubsetOf(*I));\n    }\n  }\n#endif\n}\n\n/// buildInstructionOperandReference - The specified operand is a reference to a\n/// named operand such as $src.  Resolve the Class and OperandInfo pointers.\nvoid AsmMatcherInfo::\nbuildInstructionOperandReference(MatchableInfo *II,\n                                 StringRef OperandName,\n                                 unsigned AsmOpIdx) {\n  const CodeGenInstruction &CGI = *II->DefRec.get<const CodeGenInstruction*>();\n  const CGIOperandList &Operands = CGI.Operands;\n  MatchableInfo::AsmOperand *Op = &II->AsmOperands[AsmOpIdx];\n\n  // Map this token to an operand.\n  unsigned Idx;\n  if (!Operands.hasOperandNamed(OperandName, Idx))\n    PrintFatalError(II->TheDef->getLoc(),\n                    \"error: unable to find operand: '\" + OperandName + \"'\");\n\n  // If the instruction operand has multiple suboperands, but the parser\n  // match class for the asm operand is still the default \"ImmAsmOperand\",\n  // then handle each suboperand separately.\n  if (Op->SubOpIdx == -1 && Operands[Idx].MINumOperands > 1) {\n    Record *Rec = Operands[Idx].Rec;\n    assert(Rec->isSubClassOf(\"Operand\") && \"Unexpected operand!\");\n    Record *MatchClass = Rec->getValueAsDef(\"ParserMatchClass\");\n    if (MatchClass && MatchClass->getValueAsString(\"Name\") == \"Imm\") {\n      // Insert remaining suboperands after AsmOpIdx in II->AsmOperands.\n      StringRef Token = Op->Token; // save this in case Op gets moved\n      for (unsigned SI = 1, SE = Operands[Idx].MINumOperands; SI != SE; ++SI) {\n        MatchableInfo::AsmOperand NewAsmOp(/*IsIsolatedToken=*/true, Token);\n        NewAsmOp.SubOpIdx = SI;\n        II->AsmOperands.insert(II->AsmOperands.begin()+AsmOpIdx+SI, NewAsmOp);\n      }\n      // Replace Op with first suboperand.\n      Op = &II->AsmOperands[AsmOpIdx]; // update the pointer in case it moved\n      Op->SubOpIdx = 0;\n    }\n  }\n\n  // Set up the operand class.\n  Op->Class = getOperandClass(Operands[Idx], Op->SubOpIdx);\n  Op->OrigSrcOpName = OperandName;\n\n  // If the named operand is tied, canonicalize it to the untied operand.\n  // For example, something like:\n  //   (outs GPR:$dst), (ins GPR:$src)\n  // with an asmstring of\n  //   \"inc $src\"\n  // we want to canonicalize to:\n  //   \"inc $dst\"\n  // so that we know how to provide the $dst operand when filling in the result.\n  int OITied = -1;\n  if (Operands[Idx].MINumOperands == 1)\n    OITied = Operands[Idx].getTiedRegister();\n  if (OITied != -1) {\n    // The tied operand index is an MIOperand index, find the operand that\n    // contains it.\n    std::pair<unsigned, unsigned> Idx = Operands.getSubOperandNumber(OITied);\n    OperandName = Operands[Idx.first].Name;\n    Op->SubOpIdx = Idx.second;\n  }\n\n  Op->SrcOpName = OperandName;\n}\n\n/// buildAliasOperandReference - When parsing an operand reference out of the\n/// matching string (e.g. \"movsx $src, $dst\"), determine what the class of the\n/// operand reference is by looking it up in the result pattern definition.\nvoid AsmMatcherInfo::buildAliasOperandReference(MatchableInfo *II,\n                                                StringRef OperandName,\n                                                MatchableInfo::AsmOperand &Op) {\n  const CodeGenInstAlias &CGA = *II->DefRec.get<const CodeGenInstAlias*>();\n\n  // Set up the operand class.\n  for (unsigned i = 0, e = CGA.ResultOperands.size(); i != e; ++i)\n    if (CGA.ResultOperands[i].isRecord() &&\n        CGA.ResultOperands[i].getName() == OperandName) {\n      // It's safe to go with the first one we find, because CodeGenInstAlias\n      // validates that all operands with the same name have the same record.\n      Op.SubOpIdx = CGA.ResultInstOperandIndex[i].second;\n      // Use the match class from the Alias definition, not the\n      // destination instruction, as we may have an immediate that's\n      // being munged by the match class.\n      Op.Class = getOperandClass(CGA.ResultOperands[i].getRecord(),\n                                 Op.SubOpIdx);\n      Op.SrcOpName = OperandName;\n      Op.OrigSrcOpName = OperandName;\n      return;\n    }\n\n  PrintFatalError(II->TheDef->getLoc(),\n                  \"error: unable to find operand: '\" + OperandName + \"'\");\n}\n\nvoid MatchableInfo::buildInstructionResultOperands() {\n  const CodeGenInstruction *ResultInst = getResultInst();\n\n  // Loop over all operands of the result instruction, determining how to\n  // populate them.\n  for (const CGIOperandList::OperandInfo &OpInfo : ResultInst->Operands) {\n    // If this is a tied operand, just copy from the previously handled operand.\n    int TiedOp = -1;\n    if (OpInfo.MINumOperands == 1)\n      TiedOp = OpInfo.getTiedRegister();\n    if (TiedOp != -1) {\n      int TiedSrcOperand = findAsmOperandOriginallyNamed(OpInfo.Name);\n      if (TiedSrcOperand != -1 &&\n          ResOperands[TiedOp].Kind == ResOperand::RenderAsmOperand)\n        ResOperands.push_back(ResOperand::getTiedOp(\n            TiedOp, ResOperands[TiedOp].AsmOperandNum, TiedSrcOperand));\n      else\n        ResOperands.push_back(ResOperand::getTiedOp(TiedOp, 0, 0));\n      continue;\n    }\n\n    int SrcOperand = findAsmOperandNamed(OpInfo.Name);\n    if (OpInfo.Name.empty() || SrcOperand == -1) {\n      // This may happen for operands that are tied to a suboperand of a\n      // complex operand.  Simply use a dummy value here; nobody should\n      // use this operand slot.\n      // FIXME: The long term goal is for the MCOperand list to not contain\n      // tied operands at all.\n      ResOperands.push_back(ResOperand::getImmOp(0));\n      continue;\n    }\n\n    // Check if the one AsmOperand populates the entire operand.\n    unsigned NumOperands = OpInfo.MINumOperands;\n    if (AsmOperands[SrcOperand].SubOpIdx == -1) {\n      ResOperands.push_back(ResOperand::getRenderedOp(SrcOperand, NumOperands));\n      continue;\n    }\n\n    // Add a separate ResOperand for each suboperand.\n    for (unsigned AI = 0; AI < NumOperands; ++AI) {\n      assert(AsmOperands[SrcOperand+AI].SubOpIdx == (int)AI &&\n             AsmOperands[SrcOperand+AI].SrcOpName == OpInfo.Name &&\n             \"unexpected AsmOperands for suboperands\");\n      ResOperands.push_back(ResOperand::getRenderedOp(SrcOperand + AI, 1));\n    }\n  }\n}\n\nvoid MatchableInfo::buildAliasResultOperands(bool AliasConstraintsAreChecked) {\n  const CodeGenInstAlias &CGA = *DefRec.get<const CodeGenInstAlias*>();\n  const CodeGenInstruction *ResultInst = getResultInst();\n\n  // Map of:  $reg -> #lastref\n  //   where $reg is the name of the operand in the asm string\n  //   where #lastref is the last processed index where $reg was referenced in\n  //   the asm string.\n  SmallDenseMap<StringRef, int> OperandRefs;\n\n  // Loop over all operands of the result instruction, determining how to\n  // populate them.\n  unsigned AliasOpNo = 0;\n  unsigned LastOpNo = CGA.ResultInstOperandIndex.size();\n  for (unsigned i = 0, e = ResultInst->Operands.size(); i != e; ++i) {\n    const CGIOperandList::OperandInfo *OpInfo = &ResultInst->Operands[i];\n\n    // If this is a tied operand, just copy from the previously handled operand.\n    int TiedOp = -1;\n    if (OpInfo->MINumOperands == 1)\n      TiedOp = OpInfo->getTiedRegister();\n    if (TiedOp != -1) {\n      unsigned SrcOp1 = 0;\n      unsigned SrcOp2 = 0;\n\n      // If an operand has been specified twice in the asm string,\n      // add the two source operand's indices to the TiedOp so that\n      // at runtime the 'tied' constraint is checked.\n      if (ResOperands[TiedOp].Kind == ResOperand::RenderAsmOperand) {\n        SrcOp1 = ResOperands[TiedOp].AsmOperandNum;\n\n        // Find the next operand (similarly named operand) in the string.\n        StringRef Name = AsmOperands[SrcOp1].SrcOpName;\n        auto Insert = OperandRefs.try_emplace(Name, SrcOp1);\n        SrcOp2 = findAsmOperandNamed(Name, Insert.first->second);\n\n        // Not updating the record in OperandRefs will cause TableGen\n        // to fail with an error at the end of this function.\n        if (AliasConstraintsAreChecked)\n          Insert.first->second = SrcOp2;\n\n        // In case it only has one reference in the asm string,\n        // it doesn't need to be checked for tied constraints.\n        SrcOp2 = (SrcOp2 == (unsigned)-1) ? SrcOp1 : SrcOp2;\n      }\n\n      // If the alias operand is of a different operand class, we only want\n      // to benefit from the tied-operands check and just match the operand\n      // as a normal, but not copy the original (TiedOp) to the result\n      // instruction. We do this by passing -1 as the tied operand to copy.\n      if (ResultInst->Operands[i].Rec->getName() !=\n          ResultInst->Operands[TiedOp].Rec->getName()) {\n        SrcOp1 = ResOperands[TiedOp].AsmOperandNum;\n        int SubIdx = CGA.ResultInstOperandIndex[AliasOpNo].second;\n        StringRef Name = CGA.ResultOperands[AliasOpNo].getName();\n        SrcOp2 = findAsmOperand(Name, SubIdx);\n        ResOperands.push_back(\n            ResOperand::getTiedOp((unsigned)-1, SrcOp1, SrcOp2));\n      } else {\n        ResOperands.push_back(ResOperand::getTiedOp(TiedOp, SrcOp1, SrcOp2));\n        continue;\n      }\n    }\n\n    // Handle all the suboperands for this operand.\n    const std::string &OpName = OpInfo->Name;\n    for ( ; AliasOpNo <  LastOpNo &&\n            CGA.ResultInstOperandIndex[AliasOpNo].first == i; ++AliasOpNo) {\n      int SubIdx = CGA.ResultInstOperandIndex[AliasOpNo].second;\n\n      // Find out what operand from the asmparser that this MCInst operand\n      // comes from.\n      switch (CGA.ResultOperands[AliasOpNo].Kind) {\n      case CodeGenInstAlias::ResultOperand::K_Record: {\n        StringRef Name = CGA.ResultOperands[AliasOpNo].getName();\n        int SrcOperand = findAsmOperand(Name, SubIdx);\n        if (SrcOperand == -1)\n          PrintFatalError(TheDef->getLoc(), \"Instruction '\" +\n                        TheDef->getName() + \"' has operand '\" + OpName +\n                        \"' that doesn't appear in asm string!\");\n\n        // Add it to the operand references. If it is added a second time, the\n        // record won't be updated and it will fail later on.\n        OperandRefs.try_emplace(Name, SrcOperand);\n\n        unsigned NumOperands = (SubIdx == -1 ? OpInfo->MINumOperands : 1);\n        ResOperands.push_back(ResOperand::getRenderedOp(SrcOperand,\n                                                        NumOperands));\n        break;\n      }\n      case CodeGenInstAlias::ResultOperand::K_Imm: {\n        int64_t ImmVal = CGA.ResultOperands[AliasOpNo].getImm();\n        ResOperands.push_back(ResOperand::getImmOp(ImmVal));\n        break;\n      }\n      case CodeGenInstAlias::ResultOperand::K_Reg: {\n        Record *Reg = CGA.ResultOperands[AliasOpNo].getRegister();\n        ResOperands.push_back(ResOperand::getRegOp(Reg));\n        break;\n      }\n      }\n    }\n  }\n\n  // Check that operands are not repeated more times than is supported.\n  for (auto &T : OperandRefs) {\n    if (T.second != -1 && findAsmOperandNamed(T.first, T.second) != -1)\n      PrintFatalError(TheDef->getLoc(),\n                      \"Operand '\" + T.first + \"' can never be matched\");\n  }\n}\n\nstatic unsigned\ngetConverterOperandID(const std::string &Name,\n                      SmallSetVector<CachedHashString, 16> &Table,\n                      bool &IsNew) {\n  IsNew = Table.insert(CachedHashString(Name));\n\n  unsigned ID = IsNew ? Table.size() - 1 : find(Table, Name) - Table.begin();\n\n  assert(ID < Table.size());\n\n  return ID;\n}\n\nstatic unsigned\nemitConvertFuncs(CodeGenTarget &Target, StringRef ClassName,\n                 std::vector<std::unique_ptr<MatchableInfo>> &Infos,\n                 bool HasMnemonicFirst, bool HasOptionalOperands,\n                 raw_ostream &OS) {\n  SmallSetVector<CachedHashString, 16> OperandConversionKinds;\n  SmallSetVector<CachedHashString, 16> InstructionConversionKinds;\n  std::vector<std::vector<uint8_t> > ConversionTable;\n  size_t MaxRowLength = 2; // minimum is custom converter plus terminator.\n\n  // TargetOperandClass - This is the target's operand class, like X86Operand.\n  std::string TargetOperandClass = Target.getName().str() + \"Operand\";\n\n  // Write the convert function to a separate stream, so we can drop it after\n  // the enum. We'll build up the conversion handlers for the individual\n  // operand types opportunistically as we encounter them.\n  std::string ConvertFnBody;\n  raw_string_ostream CvtOS(ConvertFnBody);\n  // Start the unified conversion function.\n  if (HasOptionalOperands) {\n    CvtOS << \"void \" << Target.getName() << ClassName << \"::\\n\"\n          << \"convertToMCInst(unsigned Kind, MCInst &Inst, \"\n          << \"unsigned Opcode,\\n\"\n          << \"                const OperandVector &Operands,\\n\"\n          << \"                const SmallBitVector &OptionalOperandsMask) {\\n\";\n  } else {\n    CvtOS << \"void \" << Target.getName() << ClassName << \"::\\n\"\n          << \"convertToMCInst(unsigned Kind, MCInst &Inst, \"\n          << \"unsigned Opcode,\\n\"\n          << \"                const OperandVector &Operands) {\\n\";\n  }\n  CvtOS << \"  assert(Kind < CVT_NUM_SIGNATURES && \\\"Invalid signature!\\\");\\n\";\n  CvtOS << \"  const uint8_t *Converter = ConversionTable[Kind];\\n\";\n  if (HasOptionalOperands) {\n    size_t MaxNumOperands = 0;\n    for (const auto &MI : Infos) {\n      MaxNumOperands = std::max(MaxNumOperands, MI->AsmOperands.size());\n    }\n    CvtOS << \"  unsigned DefaultsOffset[\" << (MaxNumOperands + 1)\n          << \"] = { 0 };\\n\";\n    CvtOS << \"  assert(OptionalOperandsMask.size() == \" << (MaxNumOperands)\n          << \");\\n\";\n    CvtOS << \"  for (unsigned i = 0, NumDefaults = 0; i < \" << (MaxNumOperands)\n          << \"; ++i) {\\n\";\n    CvtOS << \"    DefaultsOffset[i + 1] = NumDefaults;\\n\";\n    CvtOS << \"    NumDefaults += (OptionalOperandsMask[i] ? 1 : 0);\\n\";\n    CvtOS << \"  }\\n\";\n  }\n  CvtOS << \"  unsigned OpIdx;\\n\";\n  CvtOS << \"  Inst.setOpcode(Opcode);\\n\";\n  CvtOS << \"  for (const uint8_t *p = Converter; *p; p += 2) {\\n\";\n  if (HasOptionalOperands) {\n    CvtOS << \"    OpIdx = *(p + 1) - DefaultsOffset[*(p + 1)];\\n\";\n  } else {\n    CvtOS << \"    OpIdx = *(p + 1);\\n\";\n  }\n  CvtOS << \"    switch (*p) {\\n\";\n  CvtOS << \"    default: llvm_unreachable(\\\"invalid conversion entry!\\\");\\n\";\n  CvtOS << \"    case CVT_Reg:\\n\";\n  CvtOS << \"      static_cast<\" << TargetOperandClass\n        << \" &>(*Operands[OpIdx]).addRegOperands(Inst, 1);\\n\";\n  CvtOS << \"      break;\\n\";\n  CvtOS << \"    case CVT_Tied: {\\n\";\n  CvtOS << \"      assert(OpIdx < (size_t)(std::end(TiedAsmOperandTable) -\\n\";\n  CvtOS << \"                              std::begin(TiedAsmOperandTable)) &&\\n\";\n  CvtOS << \"             \\\"Tied operand not found\\\");\\n\";\n  CvtOS << \"      unsigned TiedResOpnd = TiedAsmOperandTable[OpIdx][0];\\n\";\n  CvtOS << \"      if (TiedResOpnd != (uint8_t)-1)\\n\";\n  CvtOS << \"        Inst.addOperand(Inst.getOperand(TiedResOpnd));\\n\";\n  CvtOS << \"      break;\\n\";\n  CvtOS << \"    }\\n\";\n\n  std::string OperandFnBody;\n  raw_string_ostream OpOS(OperandFnBody);\n  // Start the operand number lookup function.\n  OpOS << \"void \" << Target.getName() << ClassName << \"::\\n\"\n       << \"convertToMapAndConstraints(unsigned Kind,\\n\";\n  OpOS.indent(27);\n  OpOS << \"const OperandVector &Operands) {\\n\"\n       << \"  assert(Kind < CVT_NUM_SIGNATURES && \\\"Invalid signature!\\\");\\n\"\n       << \"  unsigned NumMCOperands = 0;\\n\"\n       << \"  const uint8_t *Converter = ConversionTable[Kind];\\n\"\n       << \"  for (const uint8_t *p = Converter; *p; p += 2) {\\n\"\n       << \"    switch (*p) {\\n\"\n       << \"    default: llvm_unreachable(\\\"invalid conversion entry!\\\");\\n\"\n       << \"    case CVT_Reg:\\n\"\n       << \"      Operands[*(p + 1)]->setMCOperandNum(NumMCOperands);\\n\"\n       << \"      Operands[*(p + 1)]->setConstraint(\\\"r\\\");\\n\"\n       << \"      ++NumMCOperands;\\n\"\n       << \"      break;\\n\"\n       << \"    case CVT_Tied:\\n\"\n       << \"      ++NumMCOperands;\\n\"\n       << \"      break;\\n\";\n\n  // Pre-populate the operand conversion kinds with the standard always\n  // available entries.\n  OperandConversionKinds.insert(CachedHashString(\"CVT_Done\"));\n  OperandConversionKinds.insert(CachedHashString(\"CVT_Reg\"));\n  OperandConversionKinds.insert(CachedHashString(\"CVT_Tied\"));\n  enum { CVT_Done, CVT_Reg, CVT_Tied };\n\n  // Map of e.g. <0, 2, 3> -> \"Tie_0_2_3\" enum label.\n  std::map<std::tuple<uint8_t, uint8_t, uint8_t>, std::string>\n  TiedOperandsEnumMap;\n\n  for (auto &II : Infos) {\n    // Check if we have a custom match function.\n    StringRef AsmMatchConverter =\n        II->getResultInst()->TheDef->getValueAsString(\"AsmMatchConverter\");\n    if (!AsmMatchConverter.empty() && II->UseInstAsmMatchConverter) {\n      std::string Signature = (\"ConvertCustom_\" + AsmMatchConverter).str();\n      II->ConversionFnKind = Signature;\n\n      // Check if we have already generated this signature.\n      if (!InstructionConversionKinds.insert(CachedHashString(Signature)))\n        continue;\n\n      // Remember this converter for the kind enum.\n      unsigned KindID = OperandConversionKinds.size();\n      OperandConversionKinds.insert(\n          CachedHashString(\"CVT_\" + getEnumNameForToken(AsmMatchConverter)));\n\n      // Add the converter row for this instruction.\n      ConversionTable.emplace_back();\n      ConversionTable.back().push_back(KindID);\n      ConversionTable.back().push_back(CVT_Done);\n\n      // Add the handler to the conversion driver function.\n      CvtOS << \"    case CVT_\"\n            << getEnumNameForToken(AsmMatchConverter) << \":\\n\"\n            << \"      \" << AsmMatchConverter << \"(Inst, Operands);\\n\"\n            << \"      break;\\n\";\n\n      // FIXME: Handle the operand number lookup for custom match functions.\n      continue;\n    }\n\n    // Build the conversion function signature.\n    std::string Signature = \"Convert\";\n\n    std::vector<uint8_t> ConversionRow;\n\n    // Compute the convert enum and the case body.\n    MaxRowLength = std::max(MaxRowLength, II->ResOperands.size()*2 + 1 );\n\n    for (unsigned i = 0, e = II->ResOperands.size(); i != e; ++i) {\n      const MatchableInfo::ResOperand &OpInfo = II->ResOperands[i];\n\n      // Generate code to populate each result operand.\n      switch (OpInfo.Kind) {\n      case MatchableInfo::ResOperand::RenderAsmOperand: {\n        // This comes from something we parsed.\n        const MatchableInfo::AsmOperand &Op =\n          II->AsmOperands[OpInfo.AsmOperandNum];\n\n        // Registers are always converted the same, don't duplicate the\n        // conversion function based on them.\n        Signature += \"__\";\n        std::string Class;\n        Class = Op.Class->isRegisterClass() ? \"Reg\" : Op.Class->ClassName;\n        Signature += Class;\n        Signature += utostr(OpInfo.MINumOperands);\n        Signature += \"_\" + itostr(OpInfo.AsmOperandNum);\n\n        // Add the conversion kind, if necessary, and get the associated ID\n        // the index of its entry in the vector).\n        std::string Name = \"CVT_\" + (Op.Class->isRegisterClass() ? \"Reg\" :\n                                     Op.Class->RenderMethod);\n        if (Op.Class->IsOptional) {\n          // For optional operands we must also care about DefaultMethod\n          assert(HasOptionalOperands);\n          Name += \"_\" + Op.Class->DefaultMethod;\n        }\n        Name = getEnumNameForToken(Name);\n\n        bool IsNewConverter = false;\n        unsigned ID = getConverterOperandID(Name, OperandConversionKinds,\n                                            IsNewConverter);\n\n        // Add the operand entry to the instruction kind conversion row.\n        ConversionRow.push_back(ID);\n        ConversionRow.push_back(OpInfo.AsmOperandNum + HasMnemonicFirst);\n\n        if (!IsNewConverter)\n          break;\n\n        // This is a new operand kind. Add a handler for it to the\n        // converter driver.\n        CvtOS << \"    case \" << Name << \":\\n\";\n        if (Op.Class->IsOptional) {\n          // If optional operand is not present in actual instruction then we\n          // should call its DefaultMethod before RenderMethod\n          assert(HasOptionalOperands);\n          CvtOS << \"      if (OptionalOperandsMask[*(p + 1) - 1]) {\\n\"\n                << \"        \" << Op.Class->DefaultMethod << \"()\"\n                << \"->\" << Op.Class->RenderMethod << \"(Inst, \"\n                << OpInfo.MINumOperands << \");\\n\"\n                << \"      } else {\\n\"\n                << \"        static_cast<\" << TargetOperandClass\n                << \" &>(*Operands[OpIdx]).\" << Op.Class->RenderMethod\n                << \"(Inst, \" << OpInfo.MINumOperands << \");\\n\"\n                << \"      }\\n\";\n        } else {\n          CvtOS << \"      static_cast<\" << TargetOperandClass\n                << \" &>(*Operands[OpIdx]).\" << Op.Class->RenderMethod\n                << \"(Inst, \" << OpInfo.MINumOperands << \");\\n\";\n        }\n        CvtOS << \"      break;\\n\";\n\n        // Add a handler for the operand number lookup.\n        OpOS << \"    case \" << Name << \":\\n\"\n             << \"      Operands[*(p + 1)]->setMCOperandNum(NumMCOperands);\\n\";\n\n        if (Op.Class->isRegisterClass())\n          OpOS << \"      Operands[*(p + 1)]->setConstraint(\\\"r\\\");\\n\";\n        else\n          OpOS << \"      Operands[*(p + 1)]->setConstraint(\\\"m\\\");\\n\";\n        OpOS << \"      NumMCOperands += \" << OpInfo.MINumOperands << \";\\n\"\n             << \"      break;\\n\";\n        break;\n      }\n      case MatchableInfo::ResOperand::TiedOperand: {\n        // If this operand is tied to a previous one, just copy the MCInst\n        // operand from the earlier one.We can only tie single MCOperand values.\n        assert(OpInfo.MINumOperands == 1 && \"Not a singular MCOperand\");\n        uint8_t TiedOp = OpInfo.TiedOperands.ResOpnd;\n        uint8_t SrcOp1 =\n            OpInfo.TiedOperands.SrcOpnd1Idx + HasMnemonicFirst;\n        uint8_t SrcOp2 =\n            OpInfo.TiedOperands.SrcOpnd2Idx + HasMnemonicFirst;\n        assert((i > TiedOp || TiedOp == (uint8_t)-1) &&\n               \"Tied operand precedes its target!\");\n        auto TiedTupleName = std::string(\"Tie\") + utostr(TiedOp) + '_' +\n                             utostr(SrcOp1) + '_' + utostr(SrcOp2);\n        Signature += \"__\" + TiedTupleName;\n        ConversionRow.push_back(CVT_Tied);\n        ConversionRow.push_back(TiedOp);\n        ConversionRow.push_back(SrcOp1);\n        ConversionRow.push_back(SrcOp2);\n\n        // Also create an 'enum' for this combination of tied operands.\n        auto Key = std::make_tuple(TiedOp, SrcOp1, SrcOp2);\n        TiedOperandsEnumMap.emplace(Key, TiedTupleName);\n        break;\n      }\n      case MatchableInfo::ResOperand::ImmOperand: {\n        int64_t Val = OpInfo.ImmVal;\n        std::string Ty = \"imm_\" + itostr(Val);\n        Ty = getEnumNameForToken(Ty);\n        Signature += \"__\" + Ty;\n\n        std::string Name = \"CVT_\" + Ty;\n        bool IsNewConverter = false;\n        unsigned ID = getConverterOperandID(Name, OperandConversionKinds,\n                                            IsNewConverter);\n        // Add the operand entry to the instruction kind conversion row.\n        ConversionRow.push_back(ID);\n        ConversionRow.push_back(0);\n\n        if (!IsNewConverter)\n          break;\n\n        CvtOS << \"    case \" << Name << \":\\n\"\n              << \"      Inst.addOperand(MCOperand::createImm(\" << Val << \"));\\n\"\n              << \"      break;\\n\";\n\n        OpOS << \"    case \" << Name << \":\\n\"\n             << \"      Operands[*(p + 1)]->setMCOperandNum(NumMCOperands);\\n\"\n             << \"      Operands[*(p + 1)]->setConstraint(\\\"\\\");\\n\"\n             << \"      ++NumMCOperands;\\n\"\n             << \"      break;\\n\";\n        break;\n      }\n      case MatchableInfo::ResOperand::RegOperand: {\n        std::string Reg, Name;\n        if (!OpInfo.Register) {\n          Name = \"reg0\";\n          Reg = \"0\";\n        } else {\n          Reg = getQualifiedName(OpInfo.Register);\n          Name = \"reg\" + OpInfo.Register->getName().str();\n        }\n        Signature += \"__\" + Name;\n        Name = \"CVT_\" + Name;\n        bool IsNewConverter = false;\n        unsigned ID = getConverterOperandID(Name, OperandConversionKinds,\n                                            IsNewConverter);\n        // Add the operand entry to the instruction kind conversion row.\n        ConversionRow.push_back(ID);\n        ConversionRow.push_back(0);\n\n        if (!IsNewConverter)\n          break;\n        CvtOS << \"    case \" << Name << \":\\n\"\n              << \"      Inst.addOperand(MCOperand::createReg(\" << Reg << \"));\\n\"\n              << \"      break;\\n\";\n\n        OpOS << \"    case \" << Name << \":\\n\"\n             << \"      Operands[*(p + 1)]->setMCOperandNum(NumMCOperands);\\n\"\n             << \"      Operands[*(p + 1)]->setConstraint(\\\"m\\\");\\n\"\n             << \"      ++NumMCOperands;\\n\"\n             << \"      break;\\n\";\n      }\n      }\n    }\n\n    // If there were no operands, add to the signature to that effect\n    if (Signature == \"Convert\")\n      Signature += \"_NoOperands\";\n\n    II->ConversionFnKind = Signature;\n\n    // Save the signature. If we already have it, don't add a new row\n    // to the table.\n    if (!InstructionConversionKinds.insert(CachedHashString(Signature)))\n      continue;\n\n    // Add the row to the table.\n    ConversionTable.push_back(std::move(ConversionRow));\n  }\n\n  // Finish up the converter driver function.\n  CvtOS << \"    }\\n  }\\n}\\n\\n\";\n\n  // Finish up the operand number lookup function.\n  OpOS << \"    }\\n  }\\n}\\n\\n\";\n\n  // Output a static table for tied operands.\n  if (TiedOperandsEnumMap.size()) {\n    // The number of tied operand combinations will be small in practice,\n    // but just add the assert to be sure.\n    assert(TiedOperandsEnumMap.size() <= 254 &&\n           \"Too many tied-operand combinations to reference with \"\n           \"an 8bit offset from the conversion table, where index \"\n           \"'255' is reserved as operand not to be copied.\");\n\n    OS << \"enum {\\n\";\n    for (auto &KV : TiedOperandsEnumMap) {\n      OS << \"  \" << KV.second << \",\\n\";\n    }\n    OS << \"};\\n\\n\";\n\n    OS << \"static const uint8_t TiedAsmOperandTable[][3] = {\\n\";\n    for (auto &KV : TiedOperandsEnumMap) {\n      OS << \"  /* \" << KV.second << \" */ { \"\n         << utostr(std::get<0>(KV.first)) << \", \"\n         << utostr(std::get<1>(KV.first)) << \", \"\n         << utostr(std::get<2>(KV.first)) << \" },\\n\";\n    }\n    OS << \"};\\n\\n\";\n  } else\n    OS << \"static const uint8_t TiedAsmOperandTable[][3] = \"\n          \"{ /* empty  */ {0, 0, 0} };\\n\\n\";\n\n  OS << \"namespace {\\n\";\n\n  // Output the operand conversion kind enum.\n  OS << \"enum OperatorConversionKind {\\n\";\n  for (const auto &Converter : OperandConversionKinds)\n    OS << \"  \" << Converter << \",\\n\";\n  OS << \"  CVT_NUM_CONVERTERS\\n\";\n  OS << \"};\\n\\n\";\n\n  // Output the instruction conversion kind enum.\n  OS << \"enum InstructionConversionKind {\\n\";\n  for (const auto &Signature : InstructionConversionKinds)\n    OS << \"  \" << Signature << \",\\n\";\n  OS << \"  CVT_NUM_SIGNATURES\\n\";\n  OS << \"};\\n\\n\";\n\n  OS << \"} // end anonymous namespace\\n\\n\";\n\n  // Output the conversion table.\n  OS << \"static const uint8_t ConversionTable[CVT_NUM_SIGNATURES][\"\n     << MaxRowLength << \"] = {\\n\";\n\n  for (unsigned Row = 0, ERow = ConversionTable.size(); Row != ERow; ++Row) {\n    assert(ConversionTable[Row].size() % 2 == 0 && \"bad conversion row!\");\n    OS << \"  // \" << InstructionConversionKinds[Row] << \"\\n\";\n    OS << \"  { \";\n    for (unsigned i = 0, e = ConversionTable[Row].size(); i != e; i += 2) {\n      OS << OperandConversionKinds[ConversionTable[Row][i]] << \", \";\n      if (OperandConversionKinds[ConversionTable[Row][i]] !=\n          CachedHashString(\"CVT_Tied\")) {\n        OS << (unsigned)(ConversionTable[Row][i + 1]) << \", \";\n        continue;\n      }\n\n      // For a tied operand, emit a reference to the TiedAsmOperandTable\n      // that contains the operand to copy, and the parsed operands to\n      // check for their tied constraints.\n      auto Key = std::make_tuple((uint8_t)ConversionTable[Row][i + 1],\n                                 (uint8_t)ConversionTable[Row][i + 2],\n                                 (uint8_t)ConversionTable[Row][i + 3]);\n      auto TiedOpndEnum = TiedOperandsEnumMap.find(Key);\n      assert(TiedOpndEnum != TiedOperandsEnumMap.end() &&\n             \"No record for tied operand pair\");\n      OS << TiedOpndEnum->second << \", \";\n      i += 2;\n    }\n    OS << \"CVT_Done },\\n\";\n  }\n\n  OS << \"};\\n\\n\";\n\n  // Spit out the conversion driver function.\n  OS << CvtOS.str();\n\n  // Spit out the operand number lookup function.\n  OS << OpOS.str();\n\n  return ConversionTable.size();\n}\n\n/// emitMatchClassEnumeration - Emit the enumeration for match class kinds.\nstatic void emitMatchClassEnumeration(CodeGenTarget &Target,\n                                      std::forward_list<ClassInfo> &Infos,\n                                      raw_ostream &OS) {\n  OS << \"namespace {\\n\\n\";\n\n  OS << \"/// MatchClassKind - The kinds of classes which participate in\\n\"\n     << \"/// instruction matching.\\n\";\n  OS << \"enum MatchClassKind {\\n\";\n  OS << \"  InvalidMatchClass = 0,\\n\";\n  OS << \"  OptionalMatchClass = 1,\\n\";\n  ClassInfo::ClassInfoKind LastKind = ClassInfo::Token;\n  StringRef LastName = \"OptionalMatchClass\";\n  for (const auto &CI : Infos) {\n    if (LastKind == ClassInfo::Token && CI.Kind != ClassInfo::Token) {\n      OS << \"  MCK_LAST_TOKEN = \" << LastName << \",\\n\";\n    } else if (LastKind < ClassInfo::UserClass0 &&\n               CI.Kind >= ClassInfo::UserClass0) {\n      OS << \"  MCK_LAST_REGISTER = \" << LastName << \",\\n\";\n    }\n    LastKind = (ClassInfo::ClassInfoKind)CI.Kind;\n    LastName = CI.Name;\n\n    OS << \"  \" << CI.Name << \", // \";\n    if (CI.Kind == ClassInfo::Token) {\n      OS << \"'\" << CI.ValueName << \"'\\n\";\n    } else if (CI.isRegisterClass()) {\n      if (!CI.ValueName.empty())\n        OS << \"register class '\" << CI.ValueName << \"'\\n\";\n      else\n        OS << \"derived register class\\n\";\n    } else {\n      OS << \"user defined class '\" << CI.ValueName << \"'\\n\";\n    }\n  }\n  OS << \"  NumMatchClassKinds\\n\";\n  OS << \"};\\n\\n\";\n\n  OS << \"} // end anonymous namespace\\n\\n\";\n}\n\n/// emitMatchClassDiagStrings - Emit a function to get the diagnostic text to be\n/// used when an assembly operand does not match the expected operand class.\nstatic void emitOperandMatchErrorDiagStrings(AsmMatcherInfo &Info, raw_ostream &OS) {\n  // If the target does not use DiagnosticString for any operands, don't emit\n  // an unused function.\n  if (llvm::all_of(Info.Classes, [](const ClassInfo &CI) {\n        return CI.DiagnosticString.empty();\n      }))\n    return;\n\n  OS << \"static const char *getMatchKindDiag(\" << Info.Target.getName()\n     << \"AsmParser::\" << Info.Target.getName()\n     << \"MatchResultTy MatchResult) {\\n\";\n  OS << \"  switch (MatchResult) {\\n\";\n\n  for (const auto &CI: Info.Classes) {\n    if (!CI.DiagnosticString.empty()) {\n      assert(!CI.DiagnosticType.empty() &&\n             \"DiagnosticString set without DiagnosticType\");\n      OS << \"  case \" << Info.Target.getName()\n         << \"AsmParser::Match_\" << CI.DiagnosticType << \":\\n\";\n      OS << \"    return \\\"\" << CI.DiagnosticString << \"\\\";\\n\";\n    }\n  }\n\n  OS << \"  default:\\n\";\n  OS << \"    return nullptr;\\n\";\n\n  OS << \"  }\\n\";\n  OS << \"}\\n\\n\";\n}\n\nstatic void emitRegisterMatchErrorFunc(AsmMatcherInfo &Info, raw_ostream &OS) {\n  OS << \"static unsigned getDiagKindFromRegisterClass(MatchClassKind \"\n        \"RegisterClass) {\\n\";\n  if (none_of(Info.Classes, [](const ClassInfo &CI) {\n        return CI.isRegisterClass() && !CI.DiagnosticType.empty();\n      })) {\n    OS << \"  return MCTargetAsmParser::Match_InvalidOperand;\\n\";\n  } else {\n    OS << \"  switch (RegisterClass) {\\n\";\n    for (const auto &CI: Info.Classes) {\n      if (CI.isRegisterClass() && !CI.DiagnosticType.empty()) {\n        OS << \"  case \" << CI.Name << \":\\n\";\n        OS << \"    return \" << Info.Target.getName() << \"AsmParser::Match_\"\n           << CI.DiagnosticType << \";\\n\";\n      }\n    }\n\n    OS << \"  default:\\n\";\n    OS << \"    return MCTargetAsmParser::Match_InvalidOperand;\\n\";\n\n    OS << \"  }\\n\";\n  }\n  OS << \"}\\n\\n\";\n}\n\n/// emitValidateOperandClass - Emit the function to validate an operand class.\nstatic void emitValidateOperandClass(AsmMatcherInfo &Info,\n                                     raw_ostream &OS) {\n  OS << \"static unsigned validateOperandClass(MCParsedAsmOperand &GOp, \"\n     << \"MatchClassKind Kind) {\\n\";\n  OS << \"  \" << Info.Target.getName() << \"Operand &Operand = (\"\n     << Info.Target.getName() << \"Operand &)GOp;\\n\";\n\n  // The InvalidMatchClass is not to match any operand.\n  OS << \"  if (Kind == InvalidMatchClass)\\n\";\n  OS << \"    return MCTargetAsmParser::Match_InvalidOperand;\\n\\n\";\n\n  // Check for Token operands first.\n  // FIXME: Use a more specific diagnostic type.\n  OS << \"  if (Operand.isToken() && Kind <= MCK_LAST_TOKEN)\\n\";\n  OS << \"    return isSubclass(matchTokenString(Operand.getToken()), Kind) ?\\n\"\n     << \"             MCTargetAsmParser::Match_Success :\\n\"\n     << \"             MCTargetAsmParser::Match_InvalidOperand;\\n\\n\";\n\n  // Check the user classes. We don't care what order since we're only\n  // actually matching against one of them.\n  OS << \"  switch (Kind) {\\n\"\n        \"  default: break;\\n\";\n  for (const auto &CI : Info.Classes) {\n    if (!CI.isUserClass())\n      continue;\n\n    OS << \"  // '\" << CI.ClassName << \"' class\\n\";\n    OS << \"  case \" << CI.Name << \": {\\n\";\n    OS << \"    DiagnosticPredicate DP(Operand.\" << CI.PredicateMethod\n       << \"());\\n\";\n    OS << \"    if (DP.isMatch())\\n\";\n    OS << \"      return MCTargetAsmParser::Match_Success;\\n\";\n    if (!CI.DiagnosticType.empty()) {\n      OS << \"    if (DP.isNearMatch())\\n\";\n      OS << \"      return \" << Info.Target.getName() << \"AsmParser::Match_\"\n         << CI.DiagnosticType << \";\\n\";\n      OS << \"    break;\\n\";\n    }\n    else\n      OS << \"    break;\\n\";\n    OS << \"    }\\n\";\n  }\n  OS << \"  } // end switch (Kind)\\n\\n\";\n\n  // Check for register operands, including sub-classes.\n  OS << \"  if (Operand.isReg()) {\\n\";\n  OS << \"    MatchClassKind OpKind;\\n\";\n  OS << \"    switch (Operand.getReg()) {\\n\";\n  OS << \"    default: OpKind = InvalidMatchClass; break;\\n\";\n  for (const auto &RC : Info.RegisterClasses)\n    OS << \"    case \" << RC.first->getValueAsString(\"Namespace\") << \"::\"\n       << RC.first->getName() << \": OpKind = \" << RC.second->Name\n       << \"; break;\\n\";\n  OS << \"    }\\n\";\n  OS << \"    return isSubclass(OpKind, Kind) ? \"\n     << \"(unsigned)MCTargetAsmParser::Match_Success :\\n                     \"\n     << \"                 getDiagKindFromRegisterClass(Kind);\\n  }\\n\\n\";\n\n  // Expected operand is a register, but actual is not.\n  OS << \"  if (Kind > MCK_LAST_TOKEN && Kind <= MCK_LAST_REGISTER)\\n\";\n  OS << \"    return getDiagKindFromRegisterClass(Kind);\\n\\n\";\n\n  // Generic fallthrough match failure case for operands that don't have\n  // specialized diagnostic types.\n  OS << \"  return MCTargetAsmParser::Match_InvalidOperand;\\n\";\n  OS << \"}\\n\\n\";\n}\n\n/// emitIsSubclass - Emit the subclass predicate function.\nstatic void emitIsSubclass(CodeGenTarget &Target,\n                           std::forward_list<ClassInfo> &Infos,\n                           raw_ostream &OS) {\n  OS << \"/// isSubclass - Compute whether \\\\p A is a subclass of \\\\p B.\\n\";\n  OS << \"static bool isSubclass(MatchClassKind A, MatchClassKind B) {\\n\";\n  OS << \"  if (A == B)\\n\";\n  OS << \"    return true;\\n\\n\";\n\n  bool EmittedSwitch = false;\n  for (const auto &A : Infos) {\n    std::vector<StringRef> SuperClasses;\n    if (A.IsOptional)\n      SuperClasses.push_back(\"OptionalMatchClass\");\n    for (const auto &B : Infos) {\n      if (&A != &B && A.isSubsetOf(B))\n        SuperClasses.push_back(B.Name);\n    }\n\n    if (SuperClasses.empty())\n      continue;\n\n    // If this is the first SuperClass, emit the switch header.\n    if (!EmittedSwitch) {\n      OS << \"  switch (A) {\\n\";\n      OS << \"  default:\\n\";\n      OS << \"    return false;\\n\";\n      EmittedSwitch = true;\n    }\n\n    OS << \"\\n  case \" << A.Name << \":\\n\";\n\n    if (SuperClasses.size() == 1) {\n      OS << \"    return B == \" << SuperClasses.back() << \";\\n\";\n      continue;\n    }\n\n    if (!SuperClasses.empty()) {\n      OS << \"    switch (B) {\\n\";\n      OS << \"    default: return false;\\n\";\n      for (StringRef SC : SuperClasses)\n        OS << \"    case \" << SC << \": return true;\\n\";\n      OS << \"    }\\n\";\n    } else {\n      // No case statement to emit\n      OS << \"    return false;\\n\";\n    }\n  }\n\n  // If there were case statements emitted into the string stream write the\n  // default.\n  if (EmittedSwitch)\n    OS << \"  }\\n\";\n  else\n    OS << \"  return false;\\n\";\n\n  OS << \"}\\n\\n\";\n}\n\n/// emitMatchTokenString - Emit the function to match a token string to the\n/// appropriate match class value.\nstatic void emitMatchTokenString(CodeGenTarget &Target,\n                                 std::forward_list<ClassInfo> &Infos,\n                                 raw_ostream &OS) {\n  // Construct the match list.\n  std::vector<StringMatcher::StringPair> Matches;\n  for (const auto &CI : Infos) {\n    if (CI.Kind == ClassInfo::Token)\n      Matches.emplace_back(CI.ValueName, \"return \" + CI.Name + \";\");\n  }\n\n  OS << \"static MatchClassKind matchTokenString(StringRef Name) {\\n\";\n\n  StringMatcher(\"Name\", Matches, OS).Emit();\n\n  OS << \"  return InvalidMatchClass;\\n\";\n  OS << \"}\\n\\n\";\n}\n\n/// emitMatchRegisterName - Emit the function to match a string to the target\n/// specific register enum.\nstatic void emitMatchRegisterName(CodeGenTarget &Target, Record *AsmParser,\n                                  raw_ostream &OS) {\n  // Construct the match list.\n  std::vector<StringMatcher::StringPair> Matches;\n  const auto &Regs = Target.getRegBank().getRegisters();\n  for (const CodeGenRegister &Reg : Regs) {\n    if (Reg.TheDef->getValueAsString(\"AsmName\").empty())\n      continue;\n\n    Matches.emplace_back(std::string(Reg.TheDef->getValueAsString(\"AsmName\")),\n                         \"return \" + utostr(Reg.EnumValue) + \";\");\n  }\n\n  OS << \"static unsigned MatchRegisterName(StringRef Name) {\\n\";\n\n  bool IgnoreDuplicates =\n      AsmParser->getValueAsBit(\"AllowDuplicateRegisterNames\");\n  StringMatcher(\"Name\", Matches, OS).Emit(0, IgnoreDuplicates);\n\n  OS << \"  return 0;\\n\";\n  OS << \"}\\n\\n\";\n}\n\n/// Emit the function to match a string to the target\n/// specific register enum.\nstatic void emitMatchRegisterAltName(CodeGenTarget &Target, Record *AsmParser,\n                                     raw_ostream &OS) {\n  // Construct the match list.\n  std::vector<StringMatcher::StringPair> Matches;\n  const auto &Regs = Target.getRegBank().getRegisters();\n  for (const CodeGenRegister &Reg : Regs) {\n\n    auto AltNames = Reg.TheDef->getValueAsListOfStrings(\"AltNames\");\n\n    for (auto AltName : AltNames) {\n      AltName = StringRef(AltName).trim();\n\n      // don't handle empty alternative names\n      if (AltName.empty())\n        continue;\n\n      Matches.emplace_back(std::string(AltName),\n                           \"return \" + utostr(Reg.EnumValue) + \";\");\n    }\n  }\n\n  OS << \"static unsigned MatchRegisterAltName(StringRef Name) {\\n\";\n\n  bool IgnoreDuplicates =\n      AsmParser->getValueAsBit(\"AllowDuplicateRegisterNames\");\n  StringMatcher(\"Name\", Matches, OS).Emit(0, IgnoreDuplicates);\n\n  OS << \"  return 0;\\n\";\n  OS << \"}\\n\\n\";\n}\n\n/// emitOperandDiagnosticTypes - Emit the operand matching diagnostic types.\nstatic void emitOperandDiagnosticTypes(AsmMatcherInfo &Info, raw_ostream &OS) {\n  // Get the set of diagnostic types from all of the operand classes.\n  std::set<StringRef> Types;\n  for (const auto &OpClassEntry : Info.AsmOperandClasses) {\n    if (!OpClassEntry.second->DiagnosticType.empty())\n      Types.insert(OpClassEntry.second->DiagnosticType);\n  }\n  for (const auto &OpClassEntry : Info.RegisterClassClasses) {\n    if (!OpClassEntry.second->DiagnosticType.empty())\n      Types.insert(OpClassEntry.second->DiagnosticType);\n  }\n\n  if (Types.empty()) return;\n\n  // Now emit the enum entries.\n  for (StringRef Type : Types)\n    OS << \"  Match_\" << Type << \",\\n\";\n  OS << \"  END_OPERAND_DIAGNOSTIC_TYPES\\n\";\n}\n\n/// emitGetSubtargetFeatureName - Emit the helper function to get the\n/// user-level name for a subtarget feature.\nstatic void emitGetSubtargetFeatureName(AsmMatcherInfo &Info, raw_ostream &OS) {\n  OS << \"// User-level names for subtarget features that participate in\\n\"\n     << \"// instruction matching.\\n\"\n     << \"static const char *getSubtargetFeatureName(uint64_t Val) {\\n\";\n  if (!Info.SubtargetFeatures.empty()) {\n    OS << \"  switch(Val) {\\n\";\n    for (const auto &SF : Info.SubtargetFeatures) {\n      const SubtargetFeatureInfo &SFI = SF.second;\n      // FIXME: Totally just a placeholder name to get the algorithm working.\n      OS << \"  case \" << SFI.getEnumBitName() << \": return \\\"\"\n         << SFI.TheDef->getValueAsString(\"PredicateName\") << \"\\\";\\n\";\n    }\n    OS << \"  default: return \\\"(unknown)\\\";\\n\";\n    OS << \"  }\\n\";\n  } else {\n    // Nothing to emit, so skip the switch\n    OS << \"  return \\\"(unknown)\\\";\\n\";\n  }\n  OS << \"}\\n\\n\";\n}\n\nstatic std::string GetAliasRequiredFeatures(Record *R,\n                                            const AsmMatcherInfo &Info) {\n  std::vector<Record*> ReqFeatures = R->getValueAsListOfDefs(\"Predicates\");\n  std::string Result;\n\n  if (ReqFeatures.empty())\n    return Result;\n\n  for (unsigned i = 0, e = ReqFeatures.size(); i != e; ++i) {\n    const SubtargetFeatureInfo *F = Info.getSubtargetFeature(ReqFeatures[i]);\n\n    if (!F)\n      PrintFatalError(R->getLoc(), \"Predicate '\" + ReqFeatures[i]->getName() +\n                    \"' is not marked as an AssemblerPredicate!\");\n\n    if (i)\n      Result += \" && \";\n\n    Result += \"Features.test(\" + F->getEnumBitName() + ')';\n  }\n\n  return Result;\n}\n\nstatic void emitMnemonicAliasVariant(raw_ostream &OS,const AsmMatcherInfo &Info,\n                                     std::vector<Record*> &Aliases,\n                                     unsigned Indent = 0,\n                                  StringRef AsmParserVariantName = StringRef()){\n  // Keep track of all the aliases from a mnemonic.  Use an std::map so that the\n  // iteration order of the map is stable.\n  std::map<std::string, std::vector<Record*> > AliasesFromMnemonic;\n\n  for (Record *R : Aliases) {\n    // FIXME: Allow AssemblerVariantName to be a comma separated list.\n    StringRef AsmVariantName = R->getValueAsString(\"AsmVariantName\");\n    if (AsmVariantName != AsmParserVariantName)\n      continue;\n    AliasesFromMnemonic[std::string(R->getValueAsString(\"FromMnemonic\"))]\n        .push_back(R);\n  }\n  if (AliasesFromMnemonic.empty())\n    return;\n\n  // Process each alias a \"from\" mnemonic at a time, building the code executed\n  // by the string remapper.\n  std::vector<StringMatcher::StringPair> Cases;\n  for (const auto &AliasEntry : AliasesFromMnemonic) {\n    const std::vector<Record*> &ToVec = AliasEntry.second;\n\n    // Loop through each alias and emit code that handles each case.  If there\n    // are two instructions without predicates, emit an error.  If there is one,\n    // emit it last.\n    std::string MatchCode;\n    int AliasWithNoPredicate = -1;\n\n    for (unsigned i = 0, e = ToVec.size(); i != e; ++i) {\n      Record *R = ToVec[i];\n      std::string FeatureMask = GetAliasRequiredFeatures(R, Info);\n\n      // If this unconditionally matches, remember it for later and diagnose\n      // duplicates.\n      if (FeatureMask.empty()) {\n        if (AliasWithNoPredicate != -1) {\n          // We can't have two aliases from the same mnemonic with no predicate.\n          PrintError(ToVec[AliasWithNoPredicate]->getLoc(),\n                     \"two MnemonicAliases with the same 'from' mnemonic!\");\n          PrintFatalError(R->getLoc(), \"this is the other MnemonicAlias.\");\n        }\n\n        AliasWithNoPredicate = i;\n        continue;\n      }\n      if (R->getValueAsString(\"ToMnemonic\") == AliasEntry.first)\n        PrintFatalError(R->getLoc(), \"MnemonicAlias to the same string\");\n\n      if (!MatchCode.empty())\n        MatchCode += \"else \";\n      MatchCode += \"if (\" + FeatureMask + \")\\n\";\n      MatchCode += \"  Mnemonic = \\\"\";\n      MatchCode += R->getValueAsString(\"ToMnemonic\");\n      MatchCode += \"\\\";\\n\";\n    }\n\n    if (AliasWithNoPredicate != -1) {\n      Record *R = ToVec[AliasWithNoPredicate];\n      if (!MatchCode.empty())\n        MatchCode += \"else\\n  \";\n      MatchCode += \"Mnemonic = \\\"\";\n      MatchCode += R->getValueAsString(\"ToMnemonic\");\n      MatchCode += \"\\\";\\n\";\n    }\n\n    MatchCode += \"return;\";\n\n    Cases.push_back(std::make_pair(AliasEntry.first, MatchCode));\n  }\n  StringMatcher(\"Mnemonic\", Cases, OS).Emit(Indent);\n}\n\n/// emitMnemonicAliases - If the target has any MnemonicAlias<> definitions,\n/// emit a function for them and return true, otherwise return false.\nstatic bool emitMnemonicAliases(raw_ostream &OS, const AsmMatcherInfo &Info,\n                                CodeGenTarget &Target) {\n  // Ignore aliases when match-prefix is set.\n  if (!MatchPrefix.empty())\n    return false;\n\n  std::vector<Record*> Aliases =\n    Info.getRecords().getAllDerivedDefinitions(\"MnemonicAlias\");\n  if (Aliases.empty()) return false;\n\n  OS << \"static void applyMnemonicAliases(StringRef &Mnemonic, \"\n    \"const FeatureBitset &Features, unsigned VariantID) {\\n\";\n  OS << \"  switch (VariantID) {\\n\";\n  unsigned VariantCount = Target.getAsmParserVariantCount();\n  for (unsigned VC = 0; VC != VariantCount; ++VC) {\n    Record *AsmVariant = Target.getAsmParserVariant(VC);\n    int AsmParserVariantNo = AsmVariant->getValueAsInt(\"Variant\");\n    StringRef AsmParserVariantName = AsmVariant->getValueAsString(\"Name\");\n    OS << \"  case \" << AsmParserVariantNo << \":\\n\";\n    emitMnemonicAliasVariant(OS, Info, Aliases, /*Indent=*/2,\n                             AsmParserVariantName);\n    OS << \"    break;\\n\";\n  }\n  OS << \"  }\\n\";\n\n  // Emit aliases that apply to all variants.\n  emitMnemonicAliasVariant(OS, Info, Aliases);\n\n  OS << \"}\\n\\n\";\n\n  return true;\n}\n\nstatic void emitCustomOperandParsing(raw_ostream &OS, CodeGenTarget &Target,\n                              const AsmMatcherInfo &Info, StringRef ClassName,\n                              StringToOffsetTable &StringTable,\n                              unsigned MaxMnemonicIndex,\n                              unsigned MaxFeaturesIndex,\n                              bool HasMnemonicFirst) {\n  unsigned MaxMask = 0;\n  for (const OperandMatchEntry &OMI : Info.OperandMatchInfo) {\n    MaxMask |= OMI.OperandMask;\n  }\n\n  // Emit the static custom operand parsing table;\n  OS << \"namespace {\\n\";\n  OS << \"  struct OperandMatchEntry {\\n\";\n  OS << \"    \" << getMinimalTypeForRange(MaxMnemonicIndex)\n               << \" Mnemonic;\\n\";\n  OS << \"    \" << getMinimalTypeForRange(MaxMask)\n               << \" OperandMask;\\n\";\n  OS << \"    \" << getMinimalTypeForRange(std::distance(\n                      Info.Classes.begin(), Info.Classes.end())) << \" Class;\\n\";\n  OS << \"    \" << getMinimalTypeForRange(MaxFeaturesIndex)\n               << \" RequiredFeaturesIdx;\\n\\n\";\n  OS << \"    StringRef getMnemonic() const {\\n\";\n  OS << \"      return StringRef(MnemonicTable + Mnemonic + 1,\\n\";\n  OS << \"                       MnemonicTable[Mnemonic]);\\n\";\n  OS << \"    }\\n\";\n  OS << \"  };\\n\\n\";\n\n  OS << \"  // Predicate for searching for an opcode.\\n\";\n  OS << \"  struct LessOpcodeOperand {\\n\";\n  OS << \"    bool operator()(const OperandMatchEntry &LHS, StringRef RHS) {\\n\";\n  OS << \"      return LHS.getMnemonic()  < RHS;\\n\";\n  OS << \"    }\\n\";\n  OS << \"    bool operator()(StringRef LHS, const OperandMatchEntry &RHS) {\\n\";\n  OS << \"      return LHS < RHS.getMnemonic();\\n\";\n  OS << \"    }\\n\";\n  OS << \"    bool operator()(const OperandMatchEntry &LHS,\";\n  OS << \" const OperandMatchEntry &RHS) {\\n\";\n  OS << \"      return LHS.getMnemonic() < RHS.getMnemonic();\\n\";\n  OS << \"    }\\n\";\n  OS << \"  };\\n\";\n\n  OS << \"} // end anonymous namespace\\n\\n\";\n\n  OS << \"static const OperandMatchEntry OperandMatchTable[\"\n     << Info.OperandMatchInfo.size() << \"] = {\\n\";\n\n  OS << \"  /* Operand List Mnemonic, Mask, Operand Class, Features */\\n\";\n  for (const OperandMatchEntry &OMI : Info.OperandMatchInfo) {\n    const MatchableInfo &II = *OMI.MI;\n\n    OS << \"  { \";\n\n    // Store a pascal-style length byte in the mnemonic.\n    std::string LenMnemonic = char(II.Mnemonic.size()) + II.Mnemonic.lower();\n    OS << StringTable.GetOrAddStringOffset(LenMnemonic, false)\n       << \" /* \" << II.Mnemonic << \" */, \";\n\n    OS << OMI.OperandMask;\n    OS << \" /* \";\n    ListSeparator LS;\n    for (int i = 0, e = 31; i !=e; ++i)\n      if (OMI.OperandMask & (1 << i))\n        OS << LS << i;\n    OS << \" */, \";\n\n    OS << OMI.CI->Name;\n\n    // Write the required features mask.\n    OS << \", AMFBS\";\n    if (II.RequiredFeatures.empty())\n      OS << \"_None\";\n    else\n      for (unsigned i = 0, e = II.RequiredFeatures.size(); i != e; ++i)\n        OS << '_' << II.RequiredFeatures[i]->TheDef->getName();\n\n    OS << \" },\\n\";\n  }\n  OS << \"};\\n\\n\";\n\n  // Emit the operand class switch to call the correct custom parser for\n  // the found operand class.\n  OS << \"OperandMatchResultTy \" << Target.getName() << ClassName << \"::\\n\"\n     << \"tryCustomParseOperand(OperandVector\"\n     << \" &Operands,\\n                      unsigned MCK) {\\n\\n\"\n     << \"  switch(MCK) {\\n\";\n\n  for (const auto &CI : Info.Classes) {\n    if (CI.ParserMethod.empty())\n      continue;\n    OS << \"  case \" << CI.Name << \":\\n\"\n       << \"    return \" << CI.ParserMethod << \"(Operands);\\n\";\n  }\n\n  OS << \"  default:\\n\";\n  OS << \"    return MatchOperand_NoMatch;\\n\";\n  OS << \"  }\\n\";\n  OS << \"  return MatchOperand_NoMatch;\\n\";\n  OS << \"}\\n\\n\";\n\n  // Emit the static custom operand parser. This code is very similar with\n  // the other matcher. Also use MatchResultTy here just in case we go for\n  // a better error handling.\n  OS << \"OperandMatchResultTy \" << Target.getName() << ClassName << \"::\\n\"\n     << \"MatchOperandParserImpl(OperandVector\"\n     << \" &Operands,\\n                       StringRef Mnemonic,\\n\"\n     << \"                       bool ParseForAllFeatures) {\\n\";\n\n  // Emit code to get the available features.\n  OS << \"  // Get the current feature set.\\n\";\n  OS << \"  const FeatureBitset &AvailableFeatures = getAvailableFeatures();\\n\\n\";\n\n  OS << \"  // Get the next operand index.\\n\";\n  OS << \"  unsigned NextOpNum = Operands.size()\"\n     << (HasMnemonicFirst ? \" - 1\" : \"\") << \";\\n\";\n\n  // Emit code to search the table.\n  OS << \"  // Search the table.\\n\";\n  if (HasMnemonicFirst) {\n    OS << \"  auto MnemonicRange =\\n\";\n    OS << \"    std::equal_range(std::begin(OperandMatchTable), \"\n          \"std::end(OperandMatchTable),\\n\";\n    OS << \"                     Mnemonic, LessOpcodeOperand());\\n\\n\";\n  } else {\n    OS << \"  auto MnemonicRange = std::make_pair(std::begin(OperandMatchTable),\"\n          \" std::end(OperandMatchTable));\\n\";\n    OS << \"  if (!Mnemonic.empty())\\n\";\n    OS << \"    MnemonicRange =\\n\";\n    OS << \"      std::equal_range(std::begin(OperandMatchTable), \"\n          \"std::end(OperandMatchTable),\\n\";\n    OS << \"                       Mnemonic, LessOpcodeOperand());\\n\\n\";\n  }\n\n  OS << \"  if (MnemonicRange.first == MnemonicRange.second)\\n\";\n  OS << \"    return MatchOperand_NoMatch;\\n\\n\";\n\n  OS << \"  for (const OperandMatchEntry *it = MnemonicRange.first,\\n\"\n     << \"       *ie = MnemonicRange.second; it != ie; ++it) {\\n\";\n\n  OS << \"    // equal_range guarantees that instruction mnemonic matches.\\n\";\n  OS << \"    assert(Mnemonic == it->getMnemonic());\\n\\n\";\n\n  // Emit check that the required features are available.\n  OS << \"    // check if the available features match\\n\";\n  OS << \"    const FeatureBitset &RequiredFeatures = \"\n        \"FeatureBitsets[it->RequiredFeaturesIdx];\\n\";\n  OS << \"    if (!ParseForAllFeatures && (AvailableFeatures & \"\n        \"RequiredFeatures) != RequiredFeatures)\\n\";\n  OS << \"      continue;\\n\\n\";\n\n  // Emit check to ensure the operand number matches.\n  OS << \"    // check if the operand in question has a custom parser.\\n\";\n  OS << \"    if (!(it->OperandMask & (1 << NextOpNum)))\\n\";\n  OS << \"      continue;\\n\\n\";\n\n  // Emit call to the custom parser method\n  OS << \"    // call custom parse method to handle the operand\\n\";\n  OS << \"    OperandMatchResultTy Result = \";\n  OS << \"tryCustomParseOperand(Operands, it->Class);\\n\";\n  OS << \"    if (Result != MatchOperand_NoMatch)\\n\";\n  OS << \"      return Result;\\n\";\n  OS << \"  }\\n\\n\";\n\n  OS << \"  // Okay, we had no match.\\n\";\n  OS << \"  return MatchOperand_NoMatch;\\n\";\n  OS << \"}\\n\\n\";\n}\n\nstatic void emitAsmTiedOperandConstraints(CodeGenTarget &Target,\n                                          AsmMatcherInfo &Info,\n                                          raw_ostream &OS) {\n  std::string AsmParserName =\n      std::string(Info.AsmParser->getValueAsString(\"AsmParserClassName\"));\n  OS << \"static bool \";\n  OS << \"checkAsmTiedOperandConstraints(const \" << Target.getName()\n     << AsmParserName << \"&AsmParser,\\n\";\n  OS << \"                               unsigned Kind,\\n\";\n  OS << \"                               const OperandVector &Operands,\\n\";\n  OS << \"                               uint64_t &ErrorInfo) {\\n\";\n  OS << \"  assert(Kind < CVT_NUM_SIGNATURES && \\\"Invalid signature!\\\");\\n\";\n  OS << \"  const uint8_t *Converter = ConversionTable[Kind];\\n\";\n  OS << \"  for (const uint8_t *p = Converter; *p; p += 2) {\\n\";\n  OS << \"    switch (*p) {\\n\";\n  OS << \"    case CVT_Tied: {\\n\";\n  OS << \"      unsigned OpIdx = *(p + 1);\\n\";\n  OS << \"      assert(OpIdx < (size_t)(std::end(TiedAsmOperandTable) -\\n\";\n  OS << \"                              std::begin(TiedAsmOperandTable)) &&\\n\";\n  OS << \"             \\\"Tied operand not found\\\");\\n\";\n  OS << \"      unsigned OpndNum1 = TiedAsmOperandTable[OpIdx][1];\\n\";\n  OS << \"      unsigned OpndNum2 = TiedAsmOperandTable[OpIdx][2];\\n\";\n  OS << \"      if (OpndNum1 != OpndNum2) {\\n\";\n  OS << \"        auto &SrcOp1 = Operands[OpndNum1];\\n\";\n  OS << \"        auto &SrcOp2 = Operands[OpndNum2];\\n\";\n  OS << \"        if (SrcOp1->isReg() && SrcOp2->isReg()) {\\n\";\n  OS << \"          if (!AsmParser.regsEqual(*SrcOp1, *SrcOp2)) {\\n\";\n  OS << \"            ErrorInfo = OpndNum2;\\n\";\n  OS << \"            return false;\\n\";\n  OS << \"          }\\n\";\n  OS << \"        }\\n\";\n  OS << \"      }\\n\";\n  OS << \"      break;\\n\";\n  OS << \"    }\\n\";\n  OS << \"    default:\\n\";\n  OS << \"      break;\\n\";\n  OS << \"    }\\n\";\n  OS << \"  }\\n\";\n  OS << \"  return true;\\n\";\n  OS << \"}\\n\\n\";\n}\n\nstatic void emitMnemonicSpellChecker(raw_ostream &OS, CodeGenTarget &Target,\n                                     unsigned VariantCount) {\n  OS << \"static std::string \" << Target.getName()\n     << \"MnemonicSpellCheck(StringRef S, const FeatureBitset &FBS,\"\n     << \" unsigned VariantID) {\\n\";\n  if (!VariantCount)\n    OS <<  \"  return \\\"\\\";\";\n  else {\n    OS << \"  const unsigned MaxEditDist = 2;\\n\";\n    OS << \"  std::vector<StringRef> Candidates;\\n\";\n    OS << \"  StringRef Prev = \\\"\\\";\\n\\n\";\n\n    OS << \"  // Find the appropriate table for this asm variant.\\n\";\n    OS << \"  const MatchEntry *Start, *End;\\n\";\n    OS << \"  switch (VariantID) {\\n\";\n    OS << \"  default: llvm_unreachable(\\\"invalid variant!\\\");\\n\";\n    for (unsigned VC = 0; VC != VariantCount; ++VC) {\n      Record *AsmVariant = Target.getAsmParserVariant(VC);\n      int AsmVariantNo = AsmVariant->getValueAsInt(\"Variant\");\n      OS << \"  case \" << AsmVariantNo << \": Start = std::begin(MatchTable\" << VC\n         << \"); End = std::end(MatchTable\" << VC << \"); break;\\n\";\n    }\n    OS << \"  }\\n\\n\";\n    OS << \"  for (auto I = Start; I < End; I++) {\\n\";\n    OS << \"    // Ignore unsupported instructions.\\n\";\n    OS << \"    const FeatureBitset &RequiredFeatures = \"\n          \"FeatureBitsets[I->RequiredFeaturesIdx];\\n\";\n    OS << \"    if ((FBS & RequiredFeatures) != RequiredFeatures)\\n\";\n    OS << \"      continue;\\n\";\n    OS << \"\\n\";\n    OS << \"    StringRef T = I->getMnemonic();\\n\";\n    OS << \"    // Avoid recomputing the edit distance for the same string.\\n\";\n    OS << \"    if (T.equals(Prev))\\n\";\n    OS << \"      continue;\\n\";\n    OS << \"\\n\";\n    OS << \"    Prev = T;\\n\";\n    OS << \"    unsigned Dist = S.edit_distance(T, false, MaxEditDist);\\n\";\n    OS << \"    if (Dist <= MaxEditDist)\\n\";\n    OS << \"      Candidates.push_back(T);\\n\";\n    OS << \"  }\\n\";\n    OS << \"\\n\";\n    OS << \"  if (Candidates.empty())\\n\";\n    OS << \"    return \\\"\\\";\\n\";\n    OS << \"\\n\";\n    OS << \"  std::string Res = \\\", did you mean: \\\";\\n\";\n    OS << \"  unsigned i = 0;\\n\";\n    OS << \"  for (; i < Candidates.size() - 1; i++)\\n\";\n    OS << \"    Res += Candidates[i].str() + \\\", \\\";\\n\";\n    OS << \"  return Res + Candidates[i].str() + \\\"?\\\";\\n\";\n  }\n  OS << \"}\\n\";\n  OS << \"\\n\";\n}\n\nstatic void emitMnemonicChecker(raw_ostream &OS,\n                                CodeGenTarget &Target,\n                                unsigned VariantCount,\n                                bool HasMnemonicFirst,\n                                bool HasMnemonicAliases) {\n  OS << \"static bool \" << Target.getName()\n     << \"CheckMnemonic(StringRef Mnemonic,\\n\";\n  OS << \"                                \"\n     << \"const FeatureBitset &AvailableFeatures,\\n\";\n  OS << \"                                \"\n     << \"unsigned VariantID) {\\n\";\n\n  if (!VariantCount) {\n    OS <<  \"  return false;\\n\";\n  } else {\n    if (HasMnemonicAliases) {\n      OS << \"  // Process all MnemonicAliases to remap the mnemonic.\\n\";\n      OS << \"  applyMnemonicAliases(Mnemonic, AvailableFeatures, VariantID);\";\n      OS << \"\\n\\n\";\n    }\n    OS << \"  // Find the appropriate table for this asm variant.\\n\";\n    OS << \"  const MatchEntry *Start, *End;\\n\";\n    OS << \"  switch (VariantID) {\\n\";\n    OS << \"  default: llvm_unreachable(\\\"invalid variant!\\\");\\n\";\n    for (unsigned VC = 0; VC != VariantCount; ++VC) {\n      Record *AsmVariant = Target.getAsmParserVariant(VC);\n      int AsmVariantNo = AsmVariant->getValueAsInt(\"Variant\");\n      OS << \"  case \" << AsmVariantNo << \": Start = std::begin(MatchTable\" << VC\n         << \"); End = std::end(MatchTable\" << VC << \"); break;\\n\";\n    }\n    OS << \"  }\\n\\n\";\n\n    OS << \"  // Search the table.\\n\";\n    if (HasMnemonicFirst) {\n      OS << \"  auto MnemonicRange = \"\n            \"std::equal_range(Start, End, Mnemonic, LessOpcode());\\n\\n\";\n    } else {\n      OS << \"  auto MnemonicRange = std::make_pair(Start, End);\\n\";\n      OS << \"  unsigned SIndex = Mnemonic.empty() ? 0 : 1;\\n\";\n      OS << \"  if (!Mnemonic.empty())\\n\";\n      OS << \"    MnemonicRange = \"\n         << \"std::equal_range(Start, End, Mnemonic.lower(), LessOpcode());\\n\\n\";\n    }\n\n    OS << \"  if (MnemonicRange.first == MnemonicRange.second)\\n\";\n    OS << \"    return false;\\n\\n\";\n\n    OS << \"  for (const MatchEntry *it = MnemonicRange.first, \"\n       << \"*ie = MnemonicRange.second;\\n\";\n    OS << \"       it != ie; ++it) {\\n\";\n    OS << \"    const FeatureBitset &RequiredFeatures =\\n\";\n    OS << \"      FeatureBitsets[it->RequiredFeaturesIdx];\\n\";\n    OS << \"    if ((AvailableFeatures & RequiredFeatures) == \";\n    OS << \"RequiredFeatures)\\n\";\n    OS << \"      return true;\\n\";\n    OS << \"  }\\n\";\n    OS << \"  return false;\\n\";\n  }\n  OS << \"}\\n\";\n  OS << \"\\n\";\n}\n\n// Emit a function mapping match classes to strings, for debugging.\nstatic void emitMatchClassKindNames(std::forward_list<ClassInfo> &Infos,\n                                    raw_ostream &OS) {\n  OS << \"#ifndef NDEBUG\\n\";\n  OS << \"const char *getMatchClassName(MatchClassKind Kind) {\\n\";\n  OS << \"  switch (Kind) {\\n\";\n\n  OS << \"  case InvalidMatchClass: return \\\"InvalidMatchClass\\\";\\n\";\n  OS << \"  case OptionalMatchClass: return \\\"OptionalMatchClass\\\";\\n\";\n  for (const auto &CI : Infos) {\n    OS << \"  case \" << CI.Name << \": return \\\"\" << CI.Name << \"\\\";\\n\";\n  }\n  OS << \"  case NumMatchClassKinds: return \\\"NumMatchClassKinds\\\";\\n\";\n\n  OS << \"  }\\n\";\n  OS << \"  llvm_unreachable(\\\"unhandled MatchClassKind!\\\");\\n\";\n  OS << \"}\\n\\n\";\n  OS << \"#endif // NDEBUG\\n\";\n}\n\nstatic std::string\ngetNameForFeatureBitset(const std::vector<Record *> &FeatureBitset) {\n  std::string Name = \"AMFBS\";\n  for (const auto &Feature : FeatureBitset)\n    Name += (\"_\" + Feature->getName()).str();\n  return Name;\n}\n\nvoid AsmMatcherEmitter::run(raw_ostream &OS) {\n  CodeGenTarget Target(Records);\n  Record *AsmParser = Target.getAsmParser();\n  StringRef ClassName = AsmParser->getValueAsString(\"AsmParserClassName\");\n\n  // Compute the information on the instructions to match.\n  AsmMatcherInfo Info(AsmParser, Target, Records);\n  Info.buildInfo();\n\n  // Sort the instruction table using the partial order on classes. We use\n  // stable_sort to ensure that ambiguous instructions are still\n  // deterministically ordered.\n  llvm::stable_sort(\n      Info.Matchables,\n      [](const std::unique_ptr<MatchableInfo> &a,\n         const std::unique_ptr<MatchableInfo> &b) { return *a < *b; });\n\n#ifdef EXPENSIVE_CHECKS\n  // Verify that the table is sorted and operator < works transitively.\n  for (auto I = Info.Matchables.begin(), E = Info.Matchables.end(); I != E;\n       ++I) {\n    for (auto J = I; J != E; ++J) {\n      assert(!(**J < **I));\n    }\n  }\n#endif\n\n  DEBUG_WITH_TYPE(\"instruction_info\", {\n      for (const auto &MI : Info.Matchables)\n        MI->dump();\n    });\n\n  // Check for ambiguous matchables.\n  DEBUG_WITH_TYPE(\"ambiguous_instrs\", {\n    unsigned NumAmbiguous = 0;\n    for (auto I = Info.Matchables.begin(), E = Info.Matchables.end(); I != E;\n         ++I) {\n      for (auto J = std::next(I); J != E; ++J) {\n        const MatchableInfo &A = **I;\n        const MatchableInfo &B = **J;\n\n        if (A.couldMatchAmbiguouslyWith(B)) {\n          errs() << \"warning: ambiguous matchables:\\n\";\n          A.dump();\n          errs() << \"\\nis incomparable with:\\n\";\n          B.dump();\n          errs() << \"\\n\\n\";\n          ++NumAmbiguous;\n        }\n      }\n    }\n    if (NumAmbiguous)\n      errs() << \"warning: \" << NumAmbiguous\n             << \" ambiguous matchables!\\n\";\n  });\n\n  // Compute the information on the custom operand parsing.\n  Info.buildOperandMatchInfo();\n\n  bool HasMnemonicFirst = AsmParser->getValueAsBit(\"HasMnemonicFirst\");\n  bool HasOptionalOperands = Info.hasOptionalOperands();\n  bool ReportMultipleNearMisses =\n      AsmParser->getValueAsBit(\"ReportMultipleNearMisses\");\n\n  // Write the output.\n\n  // Information for the class declaration.\n  OS << \"\\n#ifdef GET_ASSEMBLER_HEADER\\n\";\n  OS << \"#undef GET_ASSEMBLER_HEADER\\n\";\n  OS << \"  // This should be included into the middle of the declaration of\\n\";\n  OS << \"  // your subclasses implementation of MCTargetAsmParser.\\n\";\n  OS << \"  FeatureBitset ComputeAvailableFeatures(const FeatureBitset &FB) const;\\n\";\n  if (HasOptionalOperands) {\n    OS << \"  void convertToMCInst(unsigned Kind, MCInst &Inst, \"\n       << \"unsigned Opcode,\\n\"\n       << \"                       const OperandVector &Operands,\\n\"\n       << \"                       const SmallBitVector &OptionalOperandsMask);\\n\";\n  } else {\n    OS << \"  void convertToMCInst(unsigned Kind, MCInst &Inst, \"\n       << \"unsigned Opcode,\\n\"\n       << \"                       const OperandVector &Operands);\\n\";\n  }\n  OS << \"  void convertToMapAndConstraints(unsigned Kind,\\n                \";\n  OS << \"           const OperandVector &Operands) override;\\n\";\n  OS << \"  unsigned MatchInstructionImpl(const OperandVector &Operands,\\n\"\n     << \"                                MCInst &Inst,\\n\";\n  if (ReportMultipleNearMisses)\n    OS << \"                                SmallVectorImpl<NearMissInfo> *NearMisses,\\n\";\n  else\n    OS << \"                                uint64_t &ErrorInfo,\\n\"\n       << \"                                FeatureBitset &MissingFeatures,\\n\";\n  OS << \"                                bool matchingInlineAsm,\\n\"\n     << \"                                unsigned VariantID = 0);\\n\";\n  if (!ReportMultipleNearMisses)\n    OS << \"  unsigned MatchInstructionImpl(const OperandVector &Operands,\\n\"\n       << \"                                MCInst &Inst,\\n\"\n       << \"                                uint64_t &ErrorInfo,\\n\"\n       << \"                                bool matchingInlineAsm,\\n\"\n       << \"                                unsigned VariantID = 0) {\\n\"\n       << \"    FeatureBitset MissingFeatures;\\n\"\n       << \"    return MatchInstructionImpl(Operands, Inst, ErrorInfo, MissingFeatures,\\n\"\n       << \"                                matchingInlineAsm, VariantID);\\n\"\n       << \"  }\\n\\n\";\n\n\n  if (!Info.OperandMatchInfo.empty()) {\n    OS << \"  OperandMatchResultTy MatchOperandParserImpl(\\n\";\n    OS << \"    OperandVector &Operands,\\n\";\n    OS << \"    StringRef Mnemonic,\\n\";\n    OS << \"    bool ParseForAllFeatures = false);\\n\";\n\n    OS << \"  OperandMatchResultTy tryCustomParseOperand(\\n\";\n    OS << \"    OperandVector &Operands,\\n\";\n    OS << \"    unsigned MCK);\\n\\n\";\n  }\n\n  OS << \"#endif // GET_ASSEMBLER_HEADER_INFO\\n\\n\";\n\n  // Emit the operand match diagnostic enum names.\n  OS << \"\\n#ifdef GET_OPERAND_DIAGNOSTIC_TYPES\\n\";\n  OS << \"#undef GET_OPERAND_DIAGNOSTIC_TYPES\\n\\n\";\n  emitOperandDiagnosticTypes(Info, OS);\n  OS << \"#endif // GET_OPERAND_DIAGNOSTIC_TYPES\\n\\n\";\n\n  OS << \"\\n#ifdef GET_REGISTER_MATCHER\\n\";\n  OS << \"#undef GET_REGISTER_MATCHER\\n\\n\";\n\n  // Emit the subtarget feature enumeration.\n  SubtargetFeatureInfo::emitSubtargetFeatureBitEnumeration(\n      Info.SubtargetFeatures, OS);\n\n  // Emit the function to match a register name to number.\n  // This should be omitted for Mips target\n  if (AsmParser->getValueAsBit(\"ShouldEmitMatchRegisterName\"))\n    emitMatchRegisterName(Target, AsmParser, OS);\n\n  if (AsmParser->getValueAsBit(\"ShouldEmitMatchRegisterAltName\"))\n    emitMatchRegisterAltName(Target, AsmParser, OS);\n\n  OS << \"#endif // GET_REGISTER_MATCHER\\n\\n\";\n\n  OS << \"\\n#ifdef GET_SUBTARGET_FEATURE_NAME\\n\";\n  OS << \"#undef GET_SUBTARGET_FEATURE_NAME\\n\\n\";\n\n  // Generate the helper function to get the names for subtarget features.\n  emitGetSubtargetFeatureName(Info, OS);\n\n  OS << \"#endif // GET_SUBTARGET_FEATURE_NAME\\n\\n\";\n\n  OS << \"\\n#ifdef GET_MATCHER_IMPLEMENTATION\\n\";\n  OS << \"#undef GET_MATCHER_IMPLEMENTATION\\n\\n\";\n\n  // Generate the function that remaps for mnemonic aliases.\n  bool HasMnemonicAliases = emitMnemonicAliases(OS, Info, Target);\n\n  // Generate the convertToMCInst function to convert operands into an MCInst.\n  // Also, generate the convertToMapAndConstraints function for MS-style inline\n  // assembly.  The latter doesn't actually generate a MCInst.\n  unsigned NumConverters = emitConvertFuncs(Target, ClassName, Info.Matchables,\n                                            HasMnemonicFirst,\n                                            HasOptionalOperands, OS);\n\n  // Emit the enumeration for classes which participate in matching.\n  emitMatchClassEnumeration(Target, Info.Classes, OS);\n\n  // Emit a function to get the user-visible string to describe an operand\n  // match failure in diagnostics.\n  emitOperandMatchErrorDiagStrings(Info, OS);\n\n  // Emit a function to map register classes to operand match failure codes.\n  emitRegisterMatchErrorFunc(Info, OS);\n\n  // Emit the routine to match token strings to their match class.\n  emitMatchTokenString(Target, Info.Classes, OS);\n\n  // Emit the subclass predicate routine.\n  emitIsSubclass(Target, Info.Classes, OS);\n\n  // Emit the routine to validate an operand against a match class.\n  emitValidateOperandClass(Info, OS);\n\n  emitMatchClassKindNames(Info.Classes, OS);\n\n  // Emit the available features compute function.\n  SubtargetFeatureInfo::emitComputeAssemblerAvailableFeatures(\n      Info.Target.getName(), ClassName, \"ComputeAvailableFeatures\",\n      Info.SubtargetFeatures, OS);\n\n  if (!ReportMultipleNearMisses)\n    emitAsmTiedOperandConstraints(Target, Info, OS);\n\n  StringToOffsetTable StringTable;\n\n  size_t MaxNumOperands = 0;\n  unsigned MaxMnemonicIndex = 0;\n  bool HasDeprecation = false;\n  for (const auto &MI : Info.Matchables) {\n    MaxNumOperands = std::max(MaxNumOperands, MI->AsmOperands.size());\n    HasDeprecation |= MI->HasDeprecation;\n\n    // Store a pascal-style length byte in the mnemonic.\n    std::string LenMnemonic = char(MI->Mnemonic.size()) + MI->Mnemonic.lower();\n    MaxMnemonicIndex = std::max(MaxMnemonicIndex,\n                        StringTable.GetOrAddStringOffset(LenMnemonic, false));\n  }\n\n  OS << \"static const char *const MnemonicTable =\\n\";\n  StringTable.EmitString(OS);\n  OS << \";\\n\\n\";\n\n  std::vector<std::vector<Record *>> FeatureBitsets;\n  for (const auto &MI : Info.Matchables) {\n    if (MI->RequiredFeatures.empty())\n      continue;\n    FeatureBitsets.emplace_back();\n    for (unsigned I = 0, E = MI->RequiredFeatures.size(); I != E; ++I)\n      FeatureBitsets.back().push_back(MI->RequiredFeatures[I]->TheDef);\n  }\n\n  llvm::sort(FeatureBitsets, [&](const std::vector<Record *> &A,\n                                 const std::vector<Record *> &B) {\n    if (A.size() < B.size())\n      return true;\n    if (A.size() > B.size())\n      return false;\n    for (auto Pair : zip(A, B)) {\n      if (std::get<0>(Pair)->getName() < std::get<1>(Pair)->getName())\n        return true;\n      if (std::get<0>(Pair)->getName() > std::get<1>(Pair)->getName())\n        return false;\n    }\n    return false;\n  });\n  FeatureBitsets.erase(\n      std::unique(FeatureBitsets.begin(), FeatureBitsets.end()),\n      FeatureBitsets.end());\n  OS << \"// Feature bitsets.\\n\"\n     << \"enum : \" << getMinimalTypeForRange(FeatureBitsets.size()) << \" {\\n\"\n     << \"  AMFBS_None,\\n\";\n  for (const auto &FeatureBitset : FeatureBitsets) {\n    if (FeatureBitset.empty())\n      continue;\n    OS << \"  \" << getNameForFeatureBitset(FeatureBitset) << \",\\n\";\n  }\n  OS << \"};\\n\\n\"\n     << \"static constexpr FeatureBitset FeatureBitsets[] = {\\n\"\n     << \"  {}, // AMFBS_None\\n\";\n  for (const auto &FeatureBitset : FeatureBitsets) {\n    if (FeatureBitset.empty())\n      continue;\n    OS << \"  {\";\n    for (const auto &Feature : FeatureBitset) {\n      const auto &I = Info.SubtargetFeatures.find(Feature);\n      assert(I != Info.SubtargetFeatures.end() && \"Didn't import predicate?\");\n      OS << I->second.getEnumBitName() << \", \";\n    }\n    OS << \"},\\n\";\n  }\n  OS << \"};\\n\\n\";\n\n  // Emit the static match table; unused classes get initialized to 0 which is\n  // guaranteed to be InvalidMatchClass.\n  //\n  // FIXME: We can reduce the size of this table very easily. First, we change\n  // it so that store the kinds in separate bit-fields for each index, which\n  // only needs to be the max width used for classes at that index (we also need\n  // to reject based on this during classification). If we then make sure to\n  // order the match kinds appropriately (putting mnemonics last), then we\n  // should only end up using a few bits for each class, especially the ones\n  // following the mnemonic.\n  OS << \"namespace {\\n\";\n  OS << \"  struct MatchEntry {\\n\";\n  OS << \"    \" << getMinimalTypeForRange(MaxMnemonicIndex)\n               << \" Mnemonic;\\n\";\n  OS << \"    uint16_t Opcode;\\n\";\n  OS << \"    \" << getMinimalTypeForRange(NumConverters)\n               << \" ConvertFn;\\n\";\n  OS << \"    \" << getMinimalTypeForRange(FeatureBitsets.size())\n               << \" RequiredFeaturesIdx;\\n\";\n  OS << \"    \" << getMinimalTypeForRange(\n                      std::distance(Info.Classes.begin(), Info.Classes.end()))\n     << \" Classes[\" << MaxNumOperands << \"];\\n\";\n  OS << \"    StringRef getMnemonic() const {\\n\";\n  OS << \"      return StringRef(MnemonicTable + Mnemonic + 1,\\n\";\n  OS << \"                       MnemonicTable[Mnemonic]);\\n\";\n  OS << \"    }\\n\";\n  OS << \"  };\\n\\n\";\n\n  OS << \"  // Predicate for searching for an opcode.\\n\";\n  OS << \"  struct LessOpcode {\\n\";\n  OS << \"    bool operator()(const MatchEntry &LHS, StringRef RHS) {\\n\";\n  OS << \"      return LHS.getMnemonic() < RHS;\\n\";\n  OS << \"    }\\n\";\n  OS << \"    bool operator()(StringRef LHS, const MatchEntry &RHS) {\\n\";\n  OS << \"      return LHS < RHS.getMnemonic();\\n\";\n  OS << \"    }\\n\";\n  OS << \"    bool operator()(const MatchEntry &LHS, const MatchEntry &RHS) {\\n\";\n  OS << \"      return LHS.getMnemonic() < RHS.getMnemonic();\\n\";\n  OS << \"    }\\n\";\n  OS << \"  };\\n\";\n\n  OS << \"} // end anonymous namespace\\n\\n\";\n\n  unsigned VariantCount = Target.getAsmParserVariantCount();\n  for (unsigned VC = 0; VC != VariantCount; ++VC) {\n    Record *AsmVariant = Target.getAsmParserVariant(VC);\n    int AsmVariantNo = AsmVariant->getValueAsInt(\"Variant\");\n\n    OS << \"static const MatchEntry MatchTable\" << VC << \"[] = {\\n\";\n\n    for (const auto &MI : Info.Matchables) {\n      if (MI->AsmVariantID != AsmVariantNo)\n        continue;\n\n      // Store a pascal-style length byte in the mnemonic.\n      std::string LenMnemonic =\n          char(MI->Mnemonic.size()) + MI->Mnemonic.lower();\n      OS << \"  { \" << StringTable.GetOrAddStringOffset(LenMnemonic, false)\n         << \" /* \" << MI->Mnemonic << \" */, \"\n         << Target.getInstNamespace() << \"::\"\n         << MI->getResultInst()->TheDef->getName() << \", \"\n         << MI->ConversionFnKind << \", \";\n\n      // Write the required features mask.\n      OS << \"AMFBS\";\n      if (MI->RequiredFeatures.empty())\n        OS << \"_None\";\n      else\n        for (unsigned i = 0, e = MI->RequiredFeatures.size(); i != e; ++i)\n          OS << '_' << MI->RequiredFeatures[i]->TheDef->getName();\n\n      OS << \", { \";\n      ListSeparator LS;\n      for (const MatchableInfo::AsmOperand &Op : MI->AsmOperands)\n        OS << LS << Op.Class->Name;\n      OS << \" }, },\\n\";\n    }\n\n    OS << \"};\\n\\n\";\n  }\n\n  OS << \"#include \\\"llvm/Support/Debug.h\\\"\\n\";\n  OS << \"#include \\\"llvm/Support/Format.h\\\"\\n\\n\";\n\n  // Finally, build the match function.\n  OS << \"unsigned \" << Target.getName() << ClassName << \"::\\n\"\n     << \"MatchInstructionImpl(const OperandVector &Operands,\\n\";\n  OS << \"                     MCInst &Inst,\\n\";\n  if (ReportMultipleNearMisses)\n    OS << \"                     SmallVectorImpl<NearMissInfo> *NearMisses,\\n\";\n  else\n    OS << \"                     uint64_t &ErrorInfo,\\n\"\n       << \"                     FeatureBitset &MissingFeatures,\\n\";\n  OS << \"                     bool matchingInlineAsm, unsigned VariantID) {\\n\";\n\n  if (!ReportMultipleNearMisses) {\n    OS << \"  // Eliminate obvious mismatches.\\n\";\n    OS << \"  if (Operands.size() > \"\n       << (MaxNumOperands + HasMnemonicFirst) << \") {\\n\";\n    OS << \"    ErrorInfo = \"\n       << (MaxNumOperands + HasMnemonicFirst) << \";\\n\";\n    OS << \"    return Match_InvalidOperand;\\n\";\n    OS << \"  }\\n\\n\";\n  }\n\n  // Emit code to get the available features.\n  OS << \"  // Get the current feature set.\\n\";\n  OS << \"  const FeatureBitset &AvailableFeatures = getAvailableFeatures();\\n\\n\";\n\n  OS << \"  // Get the instruction mnemonic, which is the first token.\\n\";\n  if (HasMnemonicFirst) {\n    OS << \"  StringRef Mnemonic = ((\" << Target.getName()\n       << \"Operand &)*Operands[0]).getToken();\\n\\n\";\n  } else {\n    OS << \"  StringRef Mnemonic;\\n\";\n    OS << \"  if (Operands[0]->isToken())\\n\";\n    OS << \"    Mnemonic = ((\" << Target.getName()\n       << \"Operand &)*Operands[0]).getToken();\\n\\n\";\n  }\n\n  if (HasMnemonicAliases) {\n    OS << \"  // Process all MnemonicAliases to remap the mnemonic.\\n\";\n    OS << \"  applyMnemonicAliases(Mnemonic, AvailableFeatures, VariantID);\\n\\n\";\n  }\n\n  // Emit code to compute the class list for this operand vector.\n  if (!ReportMultipleNearMisses) {\n    OS << \"  // Some state to try to produce better error messages.\\n\";\n    OS << \"  bool HadMatchOtherThanFeatures = false;\\n\";\n    OS << \"  bool HadMatchOtherThanPredicate = false;\\n\";\n    OS << \"  unsigned RetCode = Match_InvalidOperand;\\n\";\n    OS << \"  MissingFeatures.set();\\n\";\n    OS << \"  // Set ErrorInfo to the operand that mismatches if it is\\n\";\n    OS << \"  // wrong for all instances of the instruction.\\n\";\n    OS << \"  ErrorInfo = ~0ULL;\\n\";\n  }\n\n  if (HasOptionalOperands) {\n    OS << \"  SmallBitVector OptionalOperandsMask(\" << MaxNumOperands << \");\\n\";\n  }\n\n  // Emit code to search the table.\n  OS << \"  // Find the appropriate table for this asm variant.\\n\";\n  OS << \"  const MatchEntry *Start, *End;\\n\";\n  OS << \"  switch (VariantID) {\\n\";\n  OS << \"  default: llvm_unreachable(\\\"invalid variant!\\\");\\n\";\n  for (unsigned VC = 0; VC != VariantCount; ++VC) {\n    Record *AsmVariant = Target.getAsmParserVariant(VC);\n    int AsmVariantNo = AsmVariant->getValueAsInt(\"Variant\");\n    OS << \"  case \" << AsmVariantNo << \": Start = std::begin(MatchTable\" << VC\n       << \"); End = std::end(MatchTable\" << VC << \"); break;\\n\";\n  }\n  OS << \"  }\\n\";\n\n  OS << \"  // Search the table.\\n\";\n  if (HasMnemonicFirst) {\n    OS << \"  auto MnemonicRange = \"\n          \"std::equal_range(Start, End, Mnemonic, LessOpcode());\\n\\n\";\n  } else {\n    OS << \"  auto MnemonicRange = std::make_pair(Start, End);\\n\";\n    OS << \"  unsigned SIndex = Mnemonic.empty() ? 0 : 1;\\n\";\n    OS << \"  if (!Mnemonic.empty())\\n\";\n    OS << \"    MnemonicRange = \"\n          \"std::equal_range(Start, End, Mnemonic.lower(), LessOpcode());\\n\\n\";\n  }\n\n  OS << \"  DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"AsmMatcher: found \\\" <<\\n\"\n     << \"  std::distance(MnemonicRange.first, MnemonicRange.second) <<\\n\"\n     << \"  \\\" encodings with mnemonic '\\\" << Mnemonic << \\\"'\\\\n\\\");\\n\\n\";\n\n  OS << \"  // Return a more specific error code if no mnemonics match.\\n\";\n  OS << \"  if (MnemonicRange.first == MnemonicRange.second)\\n\";\n  OS << \"    return Match_MnemonicFail;\\n\\n\";\n\n  OS << \"  for (const MatchEntry *it = MnemonicRange.first, \"\n     << \"*ie = MnemonicRange.second;\\n\";\n  OS << \"       it != ie; ++it) {\\n\";\n  OS << \"    const FeatureBitset &RequiredFeatures = \"\n        \"FeatureBitsets[it->RequiredFeaturesIdx];\\n\";\n  OS << \"    bool HasRequiredFeatures =\\n\";\n  OS << \"      (AvailableFeatures & RequiredFeatures) == RequiredFeatures;\\n\";\n  OS << \"    DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"Trying to match opcode \\\"\\n\";\n  OS << \"                                          << MII.getName(it->Opcode) << \\\"\\\\n\\\");\\n\";\n\n  if (ReportMultipleNearMisses) {\n    OS << \"    // Some state to record ways in which this instruction did not match.\\n\";\n    OS << \"    NearMissInfo OperandNearMiss = NearMissInfo::getSuccess();\\n\";\n    OS << \"    NearMissInfo FeaturesNearMiss = NearMissInfo::getSuccess();\\n\";\n    OS << \"    NearMissInfo EarlyPredicateNearMiss = NearMissInfo::getSuccess();\\n\";\n    OS << \"    NearMissInfo LatePredicateNearMiss = NearMissInfo::getSuccess();\\n\";\n    OS << \"    bool MultipleInvalidOperands = false;\\n\";\n  }\n\n  if (HasMnemonicFirst) {\n    OS << \"    // equal_range guarantees that instruction mnemonic matches.\\n\";\n    OS << \"    assert(Mnemonic == it->getMnemonic());\\n\";\n  }\n\n  // Emit check that the subclasses match.\n  if (!ReportMultipleNearMisses)\n    OS << \"    bool OperandsValid = true;\\n\";\n  if (HasOptionalOperands) {\n    OS << \"    OptionalOperandsMask.reset(0, \" << MaxNumOperands << \");\\n\";\n  }\n  OS << \"    for (unsigned FormalIdx = \" << (HasMnemonicFirst ? \"0\" : \"SIndex\")\n     << \", ActualIdx = \" << (HasMnemonicFirst ? \"1\" : \"SIndex\")\n     << \"; FormalIdx != \" << MaxNumOperands << \"; ++FormalIdx) {\\n\";\n  OS << \"      auto Formal = \"\n     << \"static_cast<MatchClassKind>(it->Classes[FormalIdx]);\\n\";\n  OS << \"      DEBUG_WITH_TYPE(\\\"asm-matcher\\\",\\n\";\n  OS << \"                      dbgs() << \\\"  Matching formal operand class \\\" << getMatchClassName(Formal)\\n\";\n  OS << \"                             << \\\" against actual operand at index \\\" << ActualIdx);\\n\";\n  OS << \"      if (ActualIdx < Operands.size())\\n\";\n  OS << \"        DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\" (\\\";\\n\";\n  OS << \"                        Operands[ActualIdx]->print(dbgs()); dbgs() << \\\"): \\\");\\n\";\n  OS << \"      else\\n\";\n  OS << \"        DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\": \\\");\\n\";\n  OS << \"      if (ActualIdx >= Operands.size()) {\\n\";\n  OS << \"        DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"actual operand index out of range \\\");\\n\";\n  if (ReportMultipleNearMisses) {\n    OS << \"        bool ThisOperandValid = (Formal == \" <<\"InvalidMatchClass) || \"\n                                   \"isSubclass(Formal, OptionalMatchClass);\\n\";\n    OS << \"        if (!ThisOperandValid) {\\n\";\n    OS << \"          if (!OperandNearMiss) {\\n\";\n    OS << \"            // Record info about match failure for later use.\\n\";\n    OS << \"            DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"recording too-few-operands near miss\\\\n\\\");\\n\";\n    OS << \"            OperandNearMiss =\\n\";\n    OS << \"                NearMissInfo::getTooFewOperands(Formal, it->Opcode);\\n\";\n    OS << \"          } else if (OperandNearMiss.getKind() != NearMissInfo::NearMissTooFewOperands) {\\n\";\n    OS << \"            // If more than one operand is invalid, give up on this match entry.\\n\";\n    OS << \"            DEBUG_WITH_TYPE(\\n\";\n    OS << \"                \\\"asm-matcher\\\",\\n\";\n    OS << \"                dbgs() << \\\"second invalid operand, giving up on this opcode\\\\n\\\");\\n\";\n    OS << \"            MultipleInvalidOperands = true;\\n\";\n    OS << \"            break;\\n\";\n    OS << \"          }\\n\";\n    OS << \"        } else {\\n\";\n    OS << \"          DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"but formal operand not required\\\\n\\\");\\n\";\n    OS << \"          break;\\n\";\n    OS << \"        }\\n\";\n    OS << \"        continue;\\n\";\n  } else {\n    OS << \"        OperandsValid = (Formal == InvalidMatchClass) || isSubclass(Formal, OptionalMatchClass);\\n\";\n    OS << \"        if (!OperandsValid) ErrorInfo = ActualIdx;\\n\";\n    if (HasOptionalOperands) {\n      OS << \"        OptionalOperandsMask.set(FormalIdx, \" << MaxNumOperands\n         << \");\\n\";\n    }\n    OS << \"        break;\\n\";\n  }\n  OS << \"      }\\n\";\n  OS << \"      MCParsedAsmOperand &Actual = *Operands[ActualIdx];\\n\";\n  OS << \"      unsigned Diag = validateOperandClass(Actual, Formal);\\n\";\n  OS << \"      if (Diag == Match_Success) {\\n\";\n  OS << \"        DEBUG_WITH_TYPE(\\\"asm-matcher\\\",\\n\";\n  OS << \"                        dbgs() << \\\"match success using generic matcher\\\\n\\\");\\n\";\n  OS << \"        ++ActualIdx;\\n\";\n  OS << \"        continue;\\n\";\n  OS << \"      }\\n\";\n  OS << \"      // If the generic handler indicates an invalid operand\\n\";\n  OS << \"      // failure, check for a special case.\\n\";\n  OS << \"      if (Diag != Match_Success) {\\n\";\n  OS << \"        unsigned TargetDiag = validateTargetOperandClass(Actual, Formal);\\n\";\n  OS << \"        if (TargetDiag == Match_Success) {\\n\";\n  OS << \"          DEBUG_WITH_TYPE(\\\"asm-matcher\\\",\\n\";\n  OS << \"                          dbgs() << \\\"match success using target matcher\\\\n\\\");\\n\";\n  OS << \"          ++ActualIdx;\\n\";\n  OS << \"          continue;\\n\";\n  OS << \"        }\\n\";\n  OS << \"        // If the target matcher returned a specific error code use\\n\";\n  OS << \"        // that, else use the one from the generic matcher.\\n\";\n  OS << \"        if (TargetDiag != Match_InvalidOperand && \"\n        \"HasRequiredFeatures)\\n\";\n  OS << \"          Diag = TargetDiag;\\n\";\n  OS << \"      }\\n\";\n  OS << \"      // If current formal operand wasn't matched and it is optional\\n\"\n     << \"      // then try to match next formal operand\\n\";\n  OS << \"      if (Diag == Match_InvalidOperand \"\n     << \"&& isSubclass(Formal, OptionalMatchClass)) {\\n\";\n  if (HasOptionalOperands) {\n    OS << \"        OptionalOperandsMask.set(FormalIdx);\\n\";\n  }\n    OS << \"        DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"ignoring optional operand\\\\n\\\");\\n\";\n  OS << \"        continue;\\n\";\n  OS << \"      }\\n\";\n\n  if (ReportMultipleNearMisses) {\n    OS << \"      if (!OperandNearMiss) {\\n\";\n    OS << \"        // If this is the first invalid operand we have seen, record some\\n\";\n    OS << \"        // information about it.\\n\";\n    OS << \"        DEBUG_WITH_TYPE(\\n\";\n    OS << \"            \\\"asm-matcher\\\",\\n\";\n    OS << \"            dbgs()\\n\";\n    OS << \"                << \\\"operand match failed, recording near-miss with diag code \\\"\\n\";\n    OS << \"                << Diag << \\\"\\\\n\\\");\\n\";\n    OS << \"        OperandNearMiss =\\n\";\n    OS << \"            NearMissInfo::getMissedOperand(Diag, Formal, it->Opcode, ActualIdx);\\n\";\n    OS << \"        ++ActualIdx;\\n\";\n    OS << \"      } else {\\n\";\n    OS << \"        // If more than one operand is invalid, give up on this match entry.\\n\";\n    OS << \"        DEBUG_WITH_TYPE(\\n\";\n    OS << \"            \\\"asm-matcher\\\",\\n\";\n    OS << \"            dbgs() << \\\"second operand mismatch, skipping this opcode\\\\n\\\");\\n\";\n    OS << \"        MultipleInvalidOperands = true;\\n\";\n    OS << \"        break;\\n\";\n    OS << \"      }\\n\";\n    OS << \"    }\\n\\n\";\n  } else {\n    OS << \"      // If this operand is broken for all of the instances of this\\n\";\n    OS << \"      // mnemonic, keep track of it so we can report loc info.\\n\";\n    OS << \"      // If we already had a match that only failed due to a\\n\";\n    OS << \"      // target predicate, that diagnostic is preferred.\\n\";\n    OS << \"      if (!HadMatchOtherThanPredicate &&\\n\";\n    OS << \"          (it == MnemonicRange.first || ErrorInfo <= ActualIdx)) {\\n\";\n    OS << \"        if (HasRequiredFeatures && (ErrorInfo != ActualIdx || Diag \"\n          \"!= Match_InvalidOperand))\\n\";\n    OS << \"          RetCode = Diag;\\n\";\n    OS << \"        ErrorInfo = ActualIdx;\\n\";\n    OS << \"      }\\n\";\n    OS << \"      // Otherwise, just reject this instance of the mnemonic.\\n\";\n    OS << \"      OperandsValid = false;\\n\";\n    OS << \"      break;\\n\";\n    OS << \"    }\\n\\n\";\n  }\n\n  if (ReportMultipleNearMisses)\n    OS << \"    if (MultipleInvalidOperands) {\\n\";\n  else\n    OS << \"    if (!OperandsValid) {\\n\";\n  OS << \"      DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"Opcode result: multiple \\\"\\n\";\n  OS << \"                                               \\\"operand mismatches, ignoring \\\"\\n\";\n  OS << \"                                               \\\"this opcode\\\\n\\\");\\n\";\n  OS << \"      continue;\\n\";\n  OS << \"    }\\n\";\n\n  // Emit check that the required features are available.\n  OS << \"    if (!HasRequiredFeatures) {\\n\";\n  if (!ReportMultipleNearMisses)\n    OS << \"      HadMatchOtherThanFeatures = true;\\n\";\n  OS << \"      FeatureBitset NewMissingFeatures = RequiredFeatures & \"\n        \"~AvailableFeatures;\\n\";\n  OS << \"      DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"Missing target features:\\\";\\n\";\n  OS << \"                      for (unsigned I = 0, E = NewMissingFeatures.size(); I != E; ++I)\\n\";\n  OS << \"                        if (NewMissingFeatures[I])\\n\";\n  OS << \"                          dbgs() << ' ' << I;\\n\";\n  OS << \"                      dbgs() << \\\"\\\\n\\\");\\n\";\n  if (ReportMultipleNearMisses) {\n    OS << \"      FeaturesNearMiss = NearMissInfo::getMissedFeature(NewMissingFeatures);\\n\";\n  } else {\n    OS << \"      if (NewMissingFeatures.count() <=\\n\"\n          \"          MissingFeatures.count())\\n\";\n    OS << \"        MissingFeatures = NewMissingFeatures;\\n\";\n    OS << \"      continue;\\n\";\n  }\n  OS << \"    }\\n\";\n  OS << \"\\n\";\n  OS << \"    Inst.clear();\\n\\n\";\n  OS << \"    Inst.setOpcode(it->Opcode);\\n\";\n  // Verify the instruction with the target-specific match predicate function.\n  OS << \"    // We have a potential match but have not rendered the operands.\\n\"\n     << \"    // Check the target predicate to handle any context sensitive\\n\"\n        \"    // constraints.\\n\"\n     << \"    // For example, Ties that are referenced multiple times must be\\n\"\n        \"    // checked here to ensure the input is the same for each match\\n\"\n        \"    // constraints. If we leave it any later the ties will have been\\n\"\n        \"    // canonicalized\\n\"\n     << \"    unsigned MatchResult;\\n\"\n     << \"    if ((MatchResult = checkEarlyTargetMatchPredicate(Inst, \"\n        \"Operands)) != Match_Success) {\\n\"\n     << \"      Inst.clear();\\n\";\n  OS << \"      DEBUG_WITH_TYPE(\\n\";\n  OS << \"          \\\"asm-matcher\\\",\\n\";\n  OS << \"          dbgs() << \\\"Early target match predicate failed with diag code \\\"\\n\";\n  OS << \"                 << MatchResult << \\\"\\\\n\\\");\\n\";\n  if (ReportMultipleNearMisses) {\n    OS << \"      EarlyPredicateNearMiss = NearMissInfo::getMissedPredicate(MatchResult);\\n\";\n  } else {\n    OS << \"      RetCode = MatchResult;\\n\"\n       << \"      HadMatchOtherThanPredicate = true;\\n\"\n       << \"      continue;\\n\";\n  }\n  OS << \"    }\\n\\n\";\n\n  if (ReportMultipleNearMisses) {\n    OS << \"    // If we did not successfully match the operands, then we can't convert to\\n\";\n    OS << \"    // an MCInst, so bail out on this instruction variant now.\\n\";\n    OS << \"    if (OperandNearMiss) {\\n\";\n    OS << \"      // If the operand mismatch was the only problem, reprrt it as a near-miss.\\n\";\n    OS << \"      if (NearMisses && !FeaturesNearMiss && !EarlyPredicateNearMiss) {\\n\";\n    OS << \"        DEBUG_WITH_TYPE(\\n\";\n    OS << \"            \\\"asm-matcher\\\",\\n\";\n    OS << \"            dbgs()\\n\";\n    OS << \"                << \\\"Opcode result: one mismatched operand, adding near-miss\\\\n\\\");\\n\";\n    OS << \"        NearMisses->push_back(OperandNearMiss);\\n\";\n    OS << \"      } else {\\n\";\n    OS << \"        DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"Opcode result: multiple \\\"\\n\";\n    OS << \"                                                 \\\"types of mismatch, so not \\\"\\n\";\n    OS << \"                                                 \\\"reporting near-miss\\\\n\\\");\\n\";\n    OS << \"      }\\n\";\n    OS << \"      continue;\\n\";\n    OS << \"    }\\n\\n\";\n  }\n\n  OS << \"    if (matchingInlineAsm) {\\n\";\n  OS << \"      convertToMapAndConstraints(it->ConvertFn, Operands);\\n\";\n  if (!ReportMultipleNearMisses) {\n    OS << \"      if (!checkAsmTiedOperandConstraints(*this, it->ConvertFn, \"\n          \"Operands, ErrorInfo))\\n\";\n    OS << \"        return Match_InvalidTiedOperand;\\n\";\n    OS << \"\\n\";\n  }\n  OS << \"      return Match_Success;\\n\";\n  OS << \"    }\\n\\n\";\n  OS << \"    // We have selected a definite instruction, convert the parsed\\n\"\n     << \"    // operands into the appropriate MCInst.\\n\";\n  if (HasOptionalOperands) {\n    OS << \"    convertToMCInst(it->ConvertFn, Inst, it->Opcode, Operands,\\n\"\n       << \"                    OptionalOperandsMask);\\n\";\n  } else {\n    OS << \"    convertToMCInst(it->ConvertFn, Inst, it->Opcode, Operands);\\n\";\n  }\n  OS << \"\\n\";\n\n  // Verify the instruction with the target-specific match predicate function.\n  OS << \"    // We have a potential match. Check the target predicate to\\n\"\n     << \"    // handle any context sensitive constraints.\\n\"\n     << \"    if ((MatchResult = checkTargetMatchPredicate(Inst)) !=\"\n     << \" Match_Success) {\\n\"\n     << \"      DEBUG_WITH_TYPE(\\\"asm-matcher\\\",\\n\"\n     << \"                      dbgs() << \\\"Target match predicate failed with diag code \\\"\\n\"\n     << \"                             << MatchResult << \\\"\\\\n\\\");\\n\"\n     << \"      Inst.clear();\\n\";\n  if (ReportMultipleNearMisses) {\n    OS << \"      LatePredicateNearMiss = NearMissInfo::getMissedPredicate(MatchResult);\\n\";\n  } else {\n    OS << \"      RetCode = MatchResult;\\n\"\n       << \"      HadMatchOtherThanPredicate = true;\\n\"\n       << \"      continue;\\n\";\n  }\n  OS << \"    }\\n\\n\";\n\n  if (ReportMultipleNearMisses) {\n    OS << \"    int NumNearMisses = ((int)(bool)OperandNearMiss +\\n\";\n    OS << \"                         (int)(bool)FeaturesNearMiss +\\n\";\n    OS << \"                         (int)(bool)EarlyPredicateNearMiss +\\n\";\n    OS << \"                         (int)(bool)LatePredicateNearMiss);\\n\";\n    OS << \"    if (NumNearMisses == 1) {\\n\";\n    OS << \"      // We had exactly one type of near-miss, so add that to the list.\\n\";\n    OS << \"      assert(!OperandNearMiss && \\\"OperandNearMiss was handled earlier\\\");\\n\";\n    OS << \"      DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"Opcode result: found one type of \\\"\\n\";\n    OS << \"                                            \\\"mismatch, so reporting a \\\"\\n\";\n    OS << \"                                            \\\"near-miss\\\\n\\\");\\n\";\n    OS << \"      if (NearMisses && FeaturesNearMiss)\\n\";\n    OS << \"        NearMisses->push_back(FeaturesNearMiss);\\n\";\n    OS << \"      else if (NearMisses && EarlyPredicateNearMiss)\\n\";\n    OS << \"        NearMisses->push_back(EarlyPredicateNearMiss);\\n\";\n    OS << \"      else if (NearMisses && LatePredicateNearMiss)\\n\";\n    OS << \"        NearMisses->push_back(LatePredicateNearMiss);\\n\";\n    OS << \"\\n\";\n    OS << \"      continue;\\n\";\n    OS << \"    } else if (NumNearMisses > 1) {\\n\";\n    OS << \"      // This instruction missed in more than one way, so ignore it.\\n\";\n    OS << \"      DEBUG_WITH_TYPE(\\\"asm-matcher\\\", dbgs() << \\\"Opcode result: multiple \\\"\\n\";\n    OS << \"                                               \\\"types of mismatch, so not \\\"\\n\";\n    OS << \"                                               \\\"reporting near-miss\\\\n\\\");\\n\";\n    OS << \"      continue;\\n\";\n    OS << \"    }\\n\";\n  }\n\n  // Call the post-processing function, if used.\n  StringRef InsnCleanupFn = AsmParser->getValueAsString(\"AsmParserInstCleanup\");\n  if (!InsnCleanupFn.empty())\n    OS << \"    \" << InsnCleanupFn << \"(Inst);\\n\";\n\n  if (HasDeprecation) {\n    OS << \"    std::string Info;\\n\";\n    OS << \"    if (!getParser().getTargetParser().\\n\";\n    OS << \"        getTargetOptions().MCNoDeprecatedWarn &&\\n\";\n    OS << \"        MII.getDeprecatedInfo(Inst, getSTI(), Info)) {\\n\";\n    OS << \"      SMLoc Loc = ((\" << Target.getName()\n       << \"Operand &)*Operands[0]).getStartLoc();\\n\";\n    OS << \"      getParser().Warning(Loc, Info, None);\\n\";\n    OS << \"    }\\n\";\n  }\n\n  if (!ReportMultipleNearMisses) {\n    OS << \"    if (!checkAsmTiedOperandConstraints(*this, it->ConvertFn, \"\n          \"Operands, ErrorInfo))\\n\";\n    OS << \"      return Match_InvalidTiedOperand;\\n\";\n    OS << \"\\n\";\n  }\n\n  OS << \"    DEBUG_WITH_TYPE(\\n\";\n  OS << \"        \\\"asm-matcher\\\",\\n\";\n  OS << \"        dbgs() << \\\"Opcode result: complete match, selecting this opcode\\\\n\\\");\\n\";\n  OS << \"    return Match_Success;\\n\";\n  OS << \"  }\\n\\n\";\n\n  if (ReportMultipleNearMisses) {\n    OS << \"  // No instruction variants matched exactly.\\n\";\n    OS << \"  return Match_NearMisses;\\n\";\n  } else {\n    OS << \"  // Okay, we had no match.  Try to return a useful error code.\\n\";\n    OS << \"  if (HadMatchOtherThanPredicate || !HadMatchOtherThanFeatures)\\n\";\n    OS << \"    return RetCode;\\n\\n\";\n    OS << \"  ErrorInfo = 0;\\n\";\n    OS << \"  return Match_MissingFeature;\\n\";\n  }\n  OS << \"}\\n\\n\";\n\n  if (!Info.OperandMatchInfo.empty())\n    emitCustomOperandParsing(OS, Target, Info, ClassName, StringTable,\n                             MaxMnemonicIndex, FeatureBitsets.size(),\n                             HasMnemonicFirst);\n\n  OS << \"#endif // GET_MATCHER_IMPLEMENTATION\\n\\n\";\n\n  OS << \"\\n#ifdef GET_MNEMONIC_SPELL_CHECKER\\n\";\n  OS << \"#undef GET_MNEMONIC_SPELL_CHECKER\\n\\n\";\n\n  emitMnemonicSpellChecker(OS, Target, VariantCount);\n\n  OS << \"#endif // GET_MNEMONIC_SPELL_CHECKER\\n\\n\";\n\n  OS << \"\\n#ifdef GET_MNEMONIC_CHECKER\\n\";\n  OS << \"#undef GET_MNEMONIC_CHECKER\\n\\n\";\n\n  emitMnemonicChecker(OS, Target, VariantCount,\n                      HasMnemonicFirst, HasMnemonicAliases);\n\n  OS << \"#endif // GET_MNEMONIC_CHECKER\\n\\n\";\n}\n\nnamespace llvm {\n\nvoid EmitAsmMatcher(RecordKeeper &RK, raw_ostream &OS) {\n  emitSourceFileHeader(\"Assembly Matcher Source Fragment\", OS);\n  AsmMatcherEmitter(RK).run(OS);\n}\n\n} // end namespace llvm\n"}}, "reports": [{"events": [{"location": {"col": 1, "file": 1, "line": 1667}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 762}, "message": "differing parameters are named here: ('OpName'), in definition: ('OperandName')"}, {"location": {"col": 8, "file": 1, "line": 762}, "message": "function '(anonymous namespace)::AsmMatcherInfo::buildInstructionOperandReference' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp", "reportHash": "d9540b170cabffe45e96ce50a8e2e9f3", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 1, "line": 1730}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 764}, "message": "differing parameters are named here: ('OpName'), in definition: ('OperandName')"}, {"location": {"col": 8, "file": 1, "line": 764}, "message": "function '(anonymous namespace)::AsmMatcherInfo::buildAliasOperandReference' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp", "reportHash": "4e108da660dc71c50317db324cb6609d", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
