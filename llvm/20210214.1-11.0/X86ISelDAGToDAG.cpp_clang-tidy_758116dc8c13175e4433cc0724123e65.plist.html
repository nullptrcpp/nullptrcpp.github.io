<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp", "content": "//===- X86ISelDAGToDAG.cpp - A DAG pattern matching inst selector for X86 -===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a DAG pattern matching instruction selector for X86,\n// converting from a legalized dag to a X86 dag.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"X86.h\"\n#include \"X86MachineFunctionInfo.h\"\n#include \"X86RegisterInfo.h\"\n#include \"X86Subtarget.h\"\n#include \"X86TargetMachine.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/CodeGen/MachineModuleInfo.h\"\n#include \"llvm/CodeGen/SelectionDAGISel.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/IntrinsicsX86.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <stdint.h>\nusing namespace llvm;\n\n#define DEBUG_TYPE \"x86-isel\"\n\nSTATISTIC(NumLoadMoved, \"Number of loads moved below TokenFactor\");\n\nstatic cl::opt<bool> AndImmShrink(\"x86-and-imm-shrink\", cl::init(true),\n    cl::desc(\"Enable setting constant bits to reduce size of mask immediates\"),\n    cl::Hidden);\n\nstatic cl::opt<bool> EnablePromoteAnyextLoad(\n    \"x86-promote-anyext-load\", cl::init(true),\n    cl::desc(\"Enable promoting aligned anyext load to wider load\"), cl::Hidden);\n\nextern cl::opt<bool> IndirectBranchTracking;\n\n//===----------------------------------------------------------------------===//\n//                      Pattern Matcher Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n  /// This corresponds to X86AddressMode, but uses SDValue's instead of register\n  /// numbers for the leaves of the matched tree.\n  struct X86ISelAddressMode {\n    enum {\n      RegBase,\n      FrameIndexBase\n    } BaseType;\n\n    // This is really a union, discriminated by BaseType!\n    SDValue Base_Reg;\n    int Base_FrameIndex;\n\n    unsigned Scale;\n    SDValue IndexReg;\n    int32_t Disp;\n    SDValue Segment;\n    const GlobalValue *GV;\n    const Constant *CP;\n    const BlockAddress *BlockAddr;\n    const char *ES;\n    MCSymbol *MCSym;\n    int JT;\n    Align Alignment;            // CP alignment.\n    unsigned char SymbolFlags;  // X86II::MO_*\n    bool NegateIndex = false;\n\n    X86ISelAddressMode()\n        : BaseType(RegBase), Base_FrameIndex(0), Scale(1), IndexReg(), Disp(0),\n          Segment(), GV(nullptr), CP(nullptr), BlockAddr(nullptr), ES(nullptr),\n          MCSym(nullptr), JT(-1), SymbolFlags(X86II::MO_NO_FLAG) {}\n\n    bool hasSymbolicDisplacement() const {\n      return GV != nullptr || CP != nullptr || ES != nullptr ||\n             MCSym != nullptr || JT != -1 || BlockAddr != nullptr;\n    }\n\n    bool hasBaseOrIndexReg() const {\n      return BaseType == FrameIndexBase ||\n             IndexReg.getNode() != nullptr || Base_Reg.getNode() != nullptr;\n    }\n\n    /// Return true if this addressing mode is already RIP-relative.\n    bool isRIPRelative() const {\n      if (BaseType != RegBase) return false;\n      if (RegisterSDNode *RegNode =\n            dyn_cast_or_null<RegisterSDNode>(Base_Reg.getNode()))\n        return RegNode->getReg() == X86::RIP;\n      return false;\n    }\n\n    void setBaseReg(SDValue Reg) {\n      BaseType = RegBase;\n      Base_Reg = Reg;\n    }\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n    void dump(SelectionDAG *DAG = nullptr) {\n      dbgs() << \"X86ISelAddressMode \" << this << '\\n';\n      dbgs() << \"Base_Reg \";\n      if (Base_Reg.getNode())\n        Base_Reg.getNode()->dump(DAG);\n      else\n        dbgs() << \"nul\\n\";\n      if (BaseType == FrameIndexBase)\n        dbgs() << \" Base.FrameIndex \" << Base_FrameIndex << '\\n';\n      dbgs() << \" Scale \" << Scale << '\\n'\n             << \"IndexReg \";\n      if (NegateIndex)\n        dbgs() << \"negate \";\n      if (IndexReg.getNode())\n        IndexReg.getNode()->dump(DAG);\n      else\n        dbgs() << \"nul\\n\";\n      dbgs() << \" Disp \" << Disp << '\\n'\n             << \"GV \";\n      if (GV)\n        GV->dump();\n      else\n        dbgs() << \"nul\";\n      dbgs() << \" CP \";\n      if (CP)\n        CP->dump();\n      else\n        dbgs() << \"nul\";\n      dbgs() << '\\n'\n             << \"ES \";\n      if (ES)\n        dbgs() << ES;\n      else\n        dbgs() << \"nul\";\n      dbgs() << \" MCSym \";\n      if (MCSym)\n        dbgs() << MCSym;\n      else\n        dbgs() << \"nul\";\n      dbgs() << \" JT\" << JT << \" Align\" << Alignment.value() << '\\n';\n    }\n#endif\n  };\n}\n\nnamespace {\n  //===--------------------------------------------------------------------===//\n  /// ISel - X86-specific code to select X86 machine instructions for\n  /// SelectionDAG operations.\n  ///\n  class X86DAGToDAGISel final : public SelectionDAGISel {\n    /// Keep a pointer to the X86Subtarget around so that we can\n    /// make the right decision when generating code for different targets.\n    const X86Subtarget *Subtarget;\n\n    /// If true, selector should try to optimize for minimum code size.\n    bool OptForMinSize;\n\n    /// Disable direct TLS access through segment registers.\n    bool IndirectTlsSegRefs;\n\n  public:\n    explicit X86DAGToDAGISel(X86TargetMachine &tm, CodeGenOpt::Level OptLevel)\n        : SelectionDAGISel(tm, OptLevel), Subtarget(nullptr),\n          OptForMinSize(false), IndirectTlsSegRefs(false) {}\n\n    StringRef getPassName() const override {\n      return \"X86 DAG->DAG Instruction Selection\";\n    }\n\n    bool runOnMachineFunction(MachineFunction &MF) override {\n      // Reset the subtarget each time through.\n      Subtarget = &MF.getSubtarget<X86Subtarget>();\n      IndirectTlsSegRefs = MF.getFunction().hasFnAttribute(\n                             \"indirect-tls-seg-refs\");\n\n      // OptFor[Min]Size are used in pattern predicates that isel is matching.\n      OptForMinSize = MF.getFunction().hasMinSize();\n      assert((!OptForMinSize || MF.getFunction().hasOptSize()) &&\n             \"OptForMinSize implies OptForSize\");\n\n      SelectionDAGISel::runOnMachineFunction(MF);\n      return true;\n    }\n\n    void emitFunctionEntryCode() override;\n\n    bool IsProfitableToFold(SDValue N, SDNode *U, SDNode *Root) const override;\n\n    void PreprocessISelDAG() override;\n    void PostprocessISelDAG() override;\n\n// Include the pieces autogenerated from the target description.\n#include \"X86GenDAGISel.inc\"\n\n  private:\n    void Select(SDNode *N) override;\n\n    bool foldOffsetIntoAddress(uint64_t Offset, X86ISelAddressMode &AM);\n    bool matchLoadInAddress(LoadSDNode *N, X86ISelAddressMode &AM,\n                            bool AllowSegmentRegForX32 = false);\n    bool matchWrapper(SDValue N, X86ISelAddressMode &AM);\n    bool matchAddress(SDValue N, X86ISelAddressMode &AM);\n    bool matchVectorAddress(SDValue N, X86ISelAddressMode &AM);\n    bool matchAdd(SDValue &N, X86ISelAddressMode &AM, unsigned Depth);\n    bool matchAddressRecursively(SDValue N, X86ISelAddressMode &AM,\n                                 unsigned Depth);\n    bool matchAddressBase(SDValue N, X86ISelAddressMode &AM);\n    bool selectAddr(SDNode *Parent, SDValue N, SDValue &Base,\n                    SDValue &Scale, SDValue &Index, SDValue &Disp,\n                    SDValue &Segment);\n    bool selectVectorAddr(MemSDNode *Parent, SDValue BasePtr, SDValue IndexOp,\n                          SDValue ScaleOp, SDValue &Base, SDValue &Scale,\n                          SDValue &Index, SDValue &Disp, SDValue &Segment);\n    bool selectMOV64Imm32(SDValue N, SDValue &Imm);\n    bool selectLEAAddr(SDValue N, SDValue &Base,\n                       SDValue &Scale, SDValue &Index, SDValue &Disp,\n                       SDValue &Segment);\n    bool selectLEA64_32Addr(SDValue N, SDValue &Base,\n                            SDValue &Scale, SDValue &Index, SDValue &Disp,\n                            SDValue &Segment);\n    bool selectTLSADDRAddr(SDValue N, SDValue &Base,\n                           SDValue &Scale, SDValue &Index, SDValue &Disp,\n                           SDValue &Segment);\n    bool selectRelocImm(SDValue N, SDValue &Op);\n\n    bool tryFoldLoad(SDNode *Root, SDNode *P, SDValue N,\n                     SDValue &Base, SDValue &Scale,\n                     SDValue &Index, SDValue &Disp,\n                     SDValue &Segment);\n\n    // Convenience method where P is also root.\n    bool tryFoldLoad(SDNode *P, SDValue N,\n                     SDValue &Base, SDValue &Scale,\n                     SDValue &Index, SDValue &Disp,\n                     SDValue &Segment) {\n      return tryFoldLoad(P, P, N, Base, Scale, Index, Disp, Segment);\n    }\n\n    bool tryFoldBroadcast(SDNode *Root, SDNode *P, SDValue N,\n                          SDValue &Base, SDValue &Scale,\n                          SDValue &Index, SDValue &Disp,\n                          SDValue &Segment);\n\n    bool isProfitableToFormMaskedOp(SDNode *N) const;\n\n    /// Implement addressing mode selection for inline asm expressions.\n    bool SelectInlineAsmMemoryOperand(const SDValue &Op,\n                                      unsigned ConstraintID,\n                                      std::vector<SDValue> &OutOps) override;\n\n    void emitSpecialCodeForMain();\n\n    inline void getAddressOperands(X86ISelAddressMode &AM, const SDLoc &DL,\n                                   MVT VT, SDValue &Base, SDValue &Scale,\n                                   SDValue &Index, SDValue &Disp,\n                                   SDValue &Segment) {\n      if (AM.BaseType == X86ISelAddressMode::FrameIndexBase)\n        Base = CurDAG->getTargetFrameIndex(\n            AM.Base_FrameIndex, TLI->getPointerTy(CurDAG->getDataLayout()));\n      else if (AM.Base_Reg.getNode())\n        Base = AM.Base_Reg;\n      else\n        Base = CurDAG->getRegister(0, VT);\n\n      Scale = getI8Imm(AM.Scale, DL);\n\n      // Negate the index if needed.\n      if (AM.NegateIndex) {\n        unsigned NegOpc = VT == MVT::i64 ? X86::NEG64r : X86::NEG32r;\n        SDValue Neg = SDValue(CurDAG->getMachineNode(NegOpc, DL, VT, MVT::i32,\n                                                     AM.IndexReg), 0);\n        AM.IndexReg = Neg;\n      }\n\n      if (AM.IndexReg.getNode())\n        Index = AM.IndexReg;\n      else\n        Index = CurDAG->getRegister(0, VT);\n\n      // These are 32-bit even in 64-bit mode since RIP-relative offset\n      // is 32-bit.\n      if (AM.GV)\n        Disp = CurDAG->getTargetGlobalAddress(AM.GV, SDLoc(),\n                                              MVT::i32, AM.Disp,\n                                              AM.SymbolFlags);\n      else if (AM.CP)\n        Disp = CurDAG->getTargetConstantPool(AM.CP, MVT::i32, AM.Alignment,\n                                             AM.Disp, AM.SymbolFlags);\n      else if (AM.ES) {\n        assert(!AM.Disp && \"Non-zero displacement is ignored with ES.\");\n        Disp = CurDAG->getTargetExternalSymbol(AM.ES, MVT::i32, AM.SymbolFlags);\n      } else if (AM.MCSym) {\n        assert(!AM.Disp && \"Non-zero displacement is ignored with MCSym.\");\n        assert(AM.SymbolFlags == 0 && \"oo\");\n        Disp = CurDAG->getMCSymbol(AM.MCSym, MVT::i32);\n      } else if (AM.JT != -1) {\n        assert(!AM.Disp && \"Non-zero displacement is ignored with JT.\");\n        Disp = CurDAG->getTargetJumpTable(AM.JT, MVT::i32, AM.SymbolFlags);\n      } else if (AM.BlockAddr)\n        Disp = CurDAG->getTargetBlockAddress(AM.BlockAddr, MVT::i32, AM.Disp,\n                                             AM.SymbolFlags);\n      else\n        Disp = CurDAG->getTargetConstant(AM.Disp, DL, MVT::i32);\n\n      if (AM.Segment.getNode())\n        Segment = AM.Segment;\n      else\n        Segment = CurDAG->getRegister(0, MVT::i16);\n    }\n\n    // Utility function to determine whether we should avoid selecting\n    // immediate forms of instructions for better code size or not.\n    // At a high level, we'd like to avoid such instructions when\n    // we have similar constants used within the same basic block\n    // that can be kept in a register.\n    //\n    bool shouldAvoidImmediateInstFormsForSize(SDNode *N) const {\n      uint32_t UseCount = 0;\n\n      // Do not want to hoist if we're not optimizing for size.\n      // TODO: We'd like to remove this restriction.\n      // See the comment in X86InstrInfo.td for more info.\n      if (!CurDAG->shouldOptForSize())\n        return false;\n\n      // Walk all the users of the immediate.\n      for (SDNode::use_iterator UI = N->use_begin(),\n           UE = N->use_end(); (UI != UE) && (UseCount < 2); ++UI) {\n\n        SDNode *User = *UI;\n\n        // This user is already selected. Count it as a legitimate use and\n        // move on.\n        if (User->isMachineOpcode()) {\n          UseCount++;\n          continue;\n        }\n\n        // We want to count stores of immediates as real uses.\n        if (User->getOpcode() == ISD::STORE &&\n            User->getOperand(1).getNode() == N) {\n          UseCount++;\n          continue;\n        }\n\n        // We don't currently match users that have > 2 operands (except\n        // for stores, which are handled above)\n        // Those instruction won't match in ISEL, for now, and would\n        // be counted incorrectly.\n        // This may change in the future as we add additional instruction\n        // types.\n        if (User->getNumOperands() != 2)\n          continue;\n\n        // If this is a sign-extended 8-bit integer immediate used in an ALU\n        // instruction, there is probably an opcode encoding to save space.\n        auto *C = dyn_cast<ConstantSDNode>(N);\n        if (C && isInt<8>(C->getSExtValue()))\n          continue;\n\n        // Immediates that are used for offsets as part of stack\n        // manipulation should be left alone. These are typically\n        // used to indicate SP offsets for argument passing and\n        // will get pulled into stores/pushes (implicitly).\n        if (User->getOpcode() == X86ISD::ADD ||\n            User->getOpcode() == ISD::ADD    ||\n            User->getOpcode() == X86ISD::SUB ||\n            User->getOpcode() == ISD::SUB) {\n\n          // Find the other operand of the add/sub.\n          SDValue OtherOp = User->getOperand(0);\n          if (OtherOp.getNode() == N)\n            OtherOp = User->getOperand(1);\n\n          // Don't count if the other operand is SP.\n          RegisterSDNode *RegNode;\n          if (OtherOp->getOpcode() == ISD::CopyFromReg &&\n              (RegNode = dyn_cast_or_null<RegisterSDNode>(\n                 OtherOp->getOperand(1).getNode())))\n            if ((RegNode->getReg() == X86::ESP) ||\n                (RegNode->getReg() == X86::RSP))\n              continue;\n        }\n\n        // ... otherwise, count this and move on.\n        UseCount++;\n      }\n\n      // If we have more than 1 use, then recommend for hoisting.\n      return (UseCount > 1);\n    }\n\n    /// Return a target constant with the specified value of type i8.\n    inline SDValue getI8Imm(unsigned Imm, const SDLoc &DL) {\n      return CurDAG->getTargetConstant(Imm, DL, MVT::i8);\n    }\n\n    /// Return a target constant with the specified value, of type i32.\n    inline SDValue getI32Imm(unsigned Imm, const SDLoc &DL) {\n      return CurDAG->getTargetConstant(Imm, DL, MVT::i32);\n    }\n\n    /// Return a target constant with the specified value, of type i64.\n    inline SDValue getI64Imm(uint64_t Imm, const SDLoc &DL) {\n      return CurDAG->getTargetConstant(Imm, DL, MVT::i64);\n    }\n\n    SDValue getExtractVEXTRACTImmediate(SDNode *N, unsigned VecWidth,\n                                        const SDLoc &DL) {\n      assert((VecWidth == 128 || VecWidth == 256) && \"Unexpected vector width\");\n      uint64_t Index = N->getConstantOperandVal(1);\n      MVT VecVT = N->getOperand(0).getSimpleValueType();\n      return getI8Imm((Index * VecVT.getScalarSizeInBits()) / VecWidth, DL);\n    }\n\n    SDValue getInsertVINSERTImmediate(SDNode *N, unsigned VecWidth,\n                                      const SDLoc &DL) {\n      assert((VecWidth == 128 || VecWidth == 256) && \"Unexpected vector width\");\n      uint64_t Index = N->getConstantOperandVal(2);\n      MVT VecVT = N->getSimpleValueType(0);\n      return getI8Imm((Index * VecVT.getScalarSizeInBits()) / VecWidth, DL);\n    }\n\n    // Helper to detect unneeded and instructions on shift amounts. Called\n    // from PatFrags in tablegen.\n    bool isUnneededShiftMask(SDNode *N, unsigned Width) const {\n      assert(N->getOpcode() == ISD::AND && \"Unexpected opcode\");\n      const APInt &Val = cast<ConstantSDNode>(N->getOperand(1))->getAPIntValue();\n\n      if (Val.countTrailingOnes() >= Width)\n        return true;\n\n      APInt Mask = Val | CurDAG->computeKnownBits(N->getOperand(0)).Zero;\n      return Mask.countTrailingOnes() >= Width;\n    }\n\n    /// Return an SDNode that returns the value of the global base register.\n    /// Output instructions required to initialize the global base register,\n    /// if necessary.\n    SDNode *getGlobalBaseReg();\n\n    /// Return a reference to the TargetMachine, casted to the target-specific\n    /// type.\n    const X86TargetMachine &getTargetMachine() const {\n      return static_cast<const X86TargetMachine &>(TM);\n    }\n\n    /// Return a reference to the TargetInstrInfo, casted to the target-specific\n    /// type.\n    const X86InstrInfo *getInstrInfo() const {\n      return Subtarget->getInstrInfo();\n    }\n\n    /// Address-mode matching performs shift-of-and to and-of-shift\n    /// reassociation in order to expose more scaled addressing\n    /// opportunities.\n    bool ComplexPatternFuncMutatesDAG() const override {\n      return true;\n    }\n\n    bool isSExtAbsoluteSymbolRef(unsigned Width, SDNode *N) const;\n\n    // Indicates we should prefer to use a non-temporal load for this load.\n    bool useNonTemporalLoad(LoadSDNode *N) const {\n      if (!N->isNonTemporal())\n        return false;\n\n      unsigned StoreSize = N->getMemoryVT().getStoreSize();\n\n      if (N->getAlignment() < StoreSize)\n        return false;\n\n      switch (StoreSize) {\n      default: llvm_unreachable(\"Unsupported store size\");\n      case 4:\n      case 8:\n        return false;\n      case 16:\n        return Subtarget->hasSSE41();\n      case 32:\n        return Subtarget->hasAVX2();\n      case 64:\n        return Subtarget->hasAVX512();\n      }\n    }\n\n    bool foldLoadStoreIntoMemOperand(SDNode *Node);\n    MachineSDNode *matchBEXTRFromAndImm(SDNode *Node);\n    bool matchBitExtract(SDNode *Node);\n    bool shrinkAndImmediate(SDNode *N);\n    bool isMaskZeroExtended(SDNode *N) const;\n    bool tryShiftAmountMod(SDNode *N);\n    bool tryShrinkShlLogicImm(SDNode *N);\n    bool tryVPTERNLOG(SDNode *N);\n    bool matchVPTERNLOG(SDNode *Root, SDNode *ParentA, SDNode *ParentBC,\n                        SDValue A, SDValue B, SDValue C, uint8_t Imm);\n    bool tryVPTESTM(SDNode *Root, SDValue Setcc, SDValue Mask);\n    bool tryMatchBitSelect(SDNode *N);\n\n    MachineSDNode *emitPCMPISTR(unsigned ROpc, unsigned MOpc, bool MayFoldLoad,\n                                const SDLoc &dl, MVT VT, SDNode *Node);\n    MachineSDNode *emitPCMPESTR(unsigned ROpc, unsigned MOpc, bool MayFoldLoad,\n                                const SDLoc &dl, MVT VT, SDNode *Node,\n                                SDValue &InFlag);\n\n    bool tryOptimizeRem8Extend(SDNode *N);\n\n    bool onlyUsesZeroFlag(SDValue Flags) const;\n    bool hasNoSignFlagUses(SDValue Flags) const;\n    bool hasNoCarryFlagUses(SDValue Flags) const;\n  };\n}\n\n\n// Returns true if this masked compare can be implemented legally with this\n// type.\nstatic bool isLegalMaskCompare(SDNode *N, const X86Subtarget *Subtarget) {\n  unsigned Opcode = N->getOpcode();\n  if (Opcode == X86ISD::CMPM || Opcode == X86ISD::CMPMM ||\n      Opcode == X86ISD::STRICT_CMPM || Opcode == ISD::SETCC ||\n      Opcode == X86ISD::CMPMM_SAE || Opcode == X86ISD::VFPCLASS) {\n    // We can get 256-bit 8 element types here without VLX being enabled. When\n    // this happens we will use 512-bit operations and the mask will not be\n    // zero extended.\n    EVT OpVT = N->getOperand(0).getValueType();\n    // The first operand of X86ISD::STRICT_CMPM is chain, so we need to get the\n    // second operand.\n    if (Opcode == X86ISD::STRICT_CMPM)\n      OpVT = N->getOperand(1).getValueType();\n    if (OpVT.is256BitVector() || OpVT.is128BitVector())\n      return Subtarget->hasVLX();\n\n    return true;\n  }\n  // Scalar opcodes use 128 bit registers, but aren't subject to the VLX check.\n  if (Opcode == X86ISD::VFPCLASSS || Opcode == X86ISD::FSETCCM ||\n      Opcode == X86ISD::FSETCCM_SAE)\n    return true;\n\n  return false;\n}\n\n// Returns true if we can assume the writer of the mask has zero extended it\n// for us.\nbool X86DAGToDAGISel::isMaskZeroExtended(SDNode *N) const {\n  // If this is an AND, check if we have a compare on either side. As long as\n  // one side guarantees the mask is zero extended, the AND will preserve those\n  // zeros.\n  if (N->getOpcode() == ISD::AND)\n    return isLegalMaskCompare(N->getOperand(0).getNode(), Subtarget) ||\n           isLegalMaskCompare(N->getOperand(1).getNode(), Subtarget);\n\n  return isLegalMaskCompare(N, Subtarget);\n}\n\nbool\nX86DAGToDAGISel::IsProfitableToFold(SDValue N, SDNode *U, SDNode *Root) const {\n  if (OptLevel == CodeGenOpt::None) return false;\n\n  if (!N.hasOneUse())\n    return false;\n\n  if (N.getOpcode() != ISD::LOAD)\n    return true;\n\n  // Don't fold non-temporal loads if we have an instruction for them.\n  if (useNonTemporalLoad(cast<LoadSDNode>(N)))\n    return false;\n\n  // If N is a load, do additional profitability checks.\n  if (U == Root) {\n    switch (U->getOpcode()) {\n    default: break;\n    case X86ISD::ADD:\n    case X86ISD::ADC:\n    case X86ISD::SUB:\n    case X86ISD::SBB:\n    case X86ISD::AND:\n    case X86ISD::XOR:\n    case X86ISD::OR:\n    case ISD::ADD:\n    case ISD::ADDCARRY:\n    case ISD::AND:\n    case ISD::OR:\n    case ISD::XOR: {\n      SDValue Op1 = U->getOperand(1);\n\n      // If the other operand is a 8-bit immediate we should fold the immediate\n      // instead. This reduces code size.\n      // e.g.\n      // movl 4(%esp), %eax\n      // addl $4, %eax\n      // vs.\n      // movl $4, %eax\n      // addl 4(%esp), %eax\n      // The former is 2 bytes shorter. In case where the increment is 1, then\n      // the saving can be 4 bytes (by using incl %eax).\n      if (ConstantSDNode *Imm = dyn_cast<ConstantSDNode>(Op1)) {\n        if (Imm->getAPIntValue().isSignedIntN(8))\n          return false;\n\n        // If this is a 64-bit AND with an immediate that fits in 32-bits,\n        // prefer using the smaller and over folding the load. This is needed to\n        // make sure immediates created by shrinkAndImmediate are always folded.\n        // Ideally we would narrow the load during DAG combine and get the\n        // best of both worlds.\n        if (U->getOpcode() == ISD::AND &&\n            Imm->getAPIntValue().getBitWidth() == 64 &&\n            Imm->getAPIntValue().isIntN(32))\n          return false;\n\n        // If this really a zext_inreg that can be represented with a movzx\n        // instruction, prefer that.\n        // TODO: We could shrink the load and fold if it is non-volatile.\n        if (U->getOpcode() == ISD::AND &&\n            (Imm->getAPIntValue() == UINT8_MAX ||\n             Imm->getAPIntValue() == UINT16_MAX ||\n             Imm->getAPIntValue() == UINT32_MAX))\n          return false;\n\n        // ADD/SUB with can negate the immediate and use the opposite operation\n        // to fit 128 into a sign extended 8 bit immediate.\n        if ((U->getOpcode() == ISD::ADD || U->getOpcode() == ISD::SUB) &&\n            (-Imm->getAPIntValue()).isSignedIntN(8))\n          return false;\n\n        if ((U->getOpcode() == X86ISD::ADD || U->getOpcode() == X86ISD::SUB) &&\n            (-Imm->getAPIntValue()).isSignedIntN(8) &&\n            hasNoCarryFlagUses(SDValue(U, 1)))\n          return false;\n      }\n\n      // If the other operand is a TLS address, we should fold it instead.\n      // This produces\n      // movl    %gs:0, %eax\n      // leal    i@NTPOFF(%eax), %eax\n      // instead of\n      // movl    $i@NTPOFF, %eax\n      // addl    %gs:0, %eax\n      // if the block also has an access to a second TLS address this will save\n      // a load.\n      // FIXME: This is probably also true for non-TLS addresses.\n      if (Op1.getOpcode() == X86ISD::Wrapper) {\n        SDValue Val = Op1.getOperand(0);\n        if (Val.getOpcode() == ISD::TargetGlobalTLSAddress)\n          return false;\n      }\n\n      // Don't fold load if this matches the BTS/BTR/BTC patterns.\n      // BTS: (or X, (shl 1, n))\n      // BTR: (and X, (rotl -2, n))\n      // BTC: (xor X, (shl 1, n))\n      if (U->getOpcode() == ISD::OR || U->getOpcode() == ISD::XOR) {\n        if (U->getOperand(0).getOpcode() == ISD::SHL &&\n            isOneConstant(U->getOperand(0).getOperand(0)))\n          return false;\n\n        if (U->getOperand(1).getOpcode() == ISD::SHL &&\n            isOneConstant(U->getOperand(1).getOperand(0)))\n          return false;\n      }\n      if (U->getOpcode() == ISD::AND) {\n        SDValue U0 = U->getOperand(0);\n        SDValue U1 = U->getOperand(1);\n        if (U0.getOpcode() == ISD::ROTL) {\n          auto *C = dyn_cast<ConstantSDNode>(U0.getOperand(0));\n          if (C && C->getSExtValue() == -2)\n            return false;\n        }\n\n        if (U1.getOpcode() == ISD::ROTL) {\n          auto *C = dyn_cast<ConstantSDNode>(U1.getOperand(0));\n          if (C && C->getSExtValue() == -2)\n            return false;\n        }\n      }\n\n      break;\n    }\n    case ISD::SHL:\n    case ISD::SRA:\n    case ISD::SRL:\n      // Don't fold a load into a shift by immediate. The BMI2 instructions\n      // support folding a load, but not an immediate. The legacy instructions\n      // support folding an immediate, but can't fold a load. Folding an\n      // immediate is preferable to folding a load.\n      if (isa<ConstantSDNode>(U->getOperand(1)))\n        return false;\n\n      break;\n    }\n  }\n\n  // Prevent folding a load if this can implemented with an insert_subreg or\n  // a move that implicitly zeroes.\n  if (Root->getOpcode() == ISD::INSERT_SUBVECTOR &&\n      isNullConstant(Root->getOperand(2)) &&\n      (Root->getOperand(0).isUndef() ||\n       ISD::isBuildVectorAllZeros(Root->getOperand(0).getNode())))\n    return false;\n\n  return true;\n}\n\n// Indicates it is profitable to form an AVX512 masked operation. Returning\n// false will favor a masked register-register masked move or vblendm and the\n// operation will be selected separately.\nbool X86DAGToDAGISel::isProfitableToFormMaskedOp(SDNode *N) const {\n  assert(\n      (N->getOpcode() == ISD::VSELECT || N->getOpcode() == X86ISD::SELECTS) &&\n      \"Unexpected opcode!\");\n\n  // If the operation has additional users, the operation will be duplicated.\n  // Check the use count to prevent that.\n  // FIXME: Are there cheap opcodes we might want to duplicate?\n  return N->getOperand(1).hasOneUse();\n}\n\n/// Replace the original chain operand of the call with\n/// load's chain operand and move load below the call's chain operand.\nstatic void moveBelowOrigChain(SelectionDAG *CurDAG, SDValue Load,\n                               SDValue Call, SDValue OrigChain) {\n  SmallVector<SDValue, 8> Ops;\n  SDValue Chain = OrigChain.getOperand(0);\n  if (Chain.getNode() == Load.getNode())\n    Ops.push_back(Load.getOperand(0));\n  else {\n    assert(Chain.getOpcode() == ISD::TokenFactor &&\n           \"Unexpected chain operand\");\n    for (unsigned i = 0, e = Chain.getNumOperands(); i != e; ++i)\n      if (Chain.getOperand(i).getNode() == Load.getNode())\n        Ops.push_back(Load.getOperand(0));\n      else\n        Ops.push_back(Chain.getOperand(i));\n    SDValue NewChain =\n      CurDAG->getNode(ISD::TokenFactor, SDLoc(Load), MVT::Other, Ops);\n    Ops.clear();\n    Ops.push_back(NewChain);\n  }\n  Ops.append(OrigChain->op_begin() + 1, OrigChain->op_end());\n  CurDAG->UpdateNodeOperands(OrigChain.getNode(), Ops);\n  CurDAG->UpdateNodeOperands(Load.getNode(), Call.getOperand(0),\n                             Load.getOperand(1), Load.getOperand(2));\n\n  Ops.clear();\n  Ops.push_back(SDValue(Load.getNode(), 1));\n  Ops.append(Call->op_begin() + 1, Call->op_end());\n  CurDAG->UpdateNodeOperands(Call.getNode(), Ops);\n}\n\n/// Return true if call address is a load and it can be\n/// moved below CALLSEQ_START and the chains leading up to the call.\n/// Return the CALLSEQ_START by reference as a second output.\n/// In the case of a tail call, there isn't a callseq node between the call\n/// chain and the load.\nstatic bool isCalleeLoad(SDValue Callee, SDValue &Chain, bool HasCallSeq) {\n  // The transformation is somewhat dangerous if the call's chain was glued to\n  // the call. After MoveBelowOrigChain the load is moved between the call and\n  // the chain, this can create a cycle if the load is not folded. So it is\n  // *really* important that we are sure the load will be folded.\n  if (Callee.getNode() == Chain.getNode() || !Callee.hasOneUse())\n    return false;\n  LoadSDNode *LD = dyn_cast<LoadSDNode>(Callee.getNode());\n  if (!LD ||\n      !LD->isSimple() ||\n      LD->getAddressingMode() != ISD::UNINDEXED ||\n      LD->getExtensionType() != ISD::NON_EXTLOAD)\n    return false;\n\n  // Now let's find the callseq_start.\n  while (HasCallSeq && Chain.getOpcode() != ISD::CALLSEQ_START) {\n    if (!Chain.hasOneUse())\n      return false;\n    Chain = Chain.getOperand(0);\n  }\n\n  if (!Chain.getNumOperands())\n    return false;\n  // Since we are not checking for AA here, conservatively abort if the chain\n  // writes to memory. It's not safe to move the callee (a load) across a store.\n  if (isa<MemSDNode>(Chain.getNode()) &&\n      cast<MemSDNode>(Chain.getNode())->writeMem())\n    return false;\n  if (Chain.getOperand(0).getNode() == Callee.getNode())\n    return true;\n  if (Chain.getOperand(0).getOpcode() == ISD::TokenFactor &&\n      Callee.getValue(1).isOperandOf(Chain.getOperand(0).getNode()) &&\n      Callee.getValue(1).hasOneUse())\n    return true;\n  return false;\n}\n\nstatic bool isEndbrImm64(uint64_t Imm) {\n// There may be some other prefix bytes between 0xF3 and 0x0F1EFA.\n// i.g: 0xF3660F1EFA, 0xF3670F1EFA\n  if ((Imm & 0x00FFFFFF) != 0x0F1EFA)\n    return false;\n\n  uint8_t OptionalPrefixBytes [] = {0x26, 0x2e, 0x36, 0x3e, 0x64,\n                                    0x65, 0x66, 0x67, 0xf0, 0xf2};\n  int i = 24; // 24bit 0x0F1EFA has matched\n  while (i < 64) {\n    uint8_t Byte = (Imm >> i) & 0xFF;\n    if (Byte == 0xF3)\n      return true;\n    if (!llvm::is_contained(OptionalPrefixBytes, Byte))\n      return false;\n    i += 8;\n  }\n\n  return false;\n}\n\nvoid X86DAGToDAGISel::PreprocessISelDAG() {\n  bool MadeChange = false;\n  for (SelectionDAG::allnodes_iterator I = CurDAG->allnodes_begin(),\n       E = CurDAG->allnodes_end(); I != E; ) {\n    SDNode *N = &*I++; // Preincrement iterator to avoid invalidation issues.\n\n    // This is for CET enhancement.\n    //\n    // ENDBR32 and ENDBR64 have specific opcodes:\n    // ENDBR32: F3 0F 1E FB\n    // ENDBR64: F3 0F 1E FA\n    // And we want that attackers won\u2019t find unintended ENDBR32/64\n    // opcode matches in the binary\n    // Here\u2019s an example:\n    // If the compiler had to generate asm for the following code:\n    // a = 0xF30F1EFA\n    // it could, for example, generate:\n    // mov 0xF30F1EFA, dword ptr[a]\n    // In such a case, the binary would include a gadget that starts\n    // with a fake ENDBR64 opcode. Therefore, we split such generation\n    // into multiple operations, let it not shows in the binary\n    if (N->getOpcode() == ISD::Constant) {\n      MVT VT = N->getSimpleValueType(0);\n      int64_t Imm = cast<ConstantSDNode>(N)->getSExtValue();\n      int32_t EndbrImm = Subtarget->is64Bit() ? 0xF30F1EFA : 0xF30F1EFB;\n      if (Imm == EndbrImm || isEndbrImm64(Imm)) {\n        // Check that the cf-protection-branch is enabled.\n        Metadata *CFProtectionBranch =\n          MF->getMMI().getModule()->getModuleFlag(\"cf-protection-branch\");\n        if (CFProtectionBranch || IndirectBranchTracking) {\n          SDLoc dl(N);\n          SDValue Complement = CurDAG->getConstant(~Imm, dl, VT, false, true);\n          Complement = CurDAG->getNOT(dl, Complement, VT);\n          --I;\n          CurDAG->ReplaceAllUsesOfValueWith(SDValue(N, 0), Complement);\n          ++I;\n          MadeChange = true;\n          continue;\n        }\n      }\n    }\n\n    // If this is a target specific AND node with no flag usages, turn it back\n    // into ISD::AND to enable test instruction matching.\n    if (N->getOpcode() == X86ISD::AND && !N->hasAnyUseOfValue(1)) {\n      SDValue Res = CurDAG->getNode(ISD::AND, SDLoc(N), N->getValueType(0),\n                                    N->getOperand(0), N->getOperand(1));\n      --I;\n      CurDAG->ReplaceAllUsesOfValueWith(SDValue(N, 0), Res);\n      ++I;\n      MadeChange = true;\n      continue;\n    }\n\n    /// Convert vector increment or decrement to sub/add with an all-ones\n    /// constant:\n    /// add X, <1, 1...> --> sub X, <-1, -1...>\n    /// sub X, <1, 1...> --> add X, <-1, -1...>\n    /// The all-ones vector constant can be materialized using a pcmpeq\n    /// instruction that is commonly recognized as an idiom (has no register\n    /// dependency), so that's better/smaller than loading a splat 1 constant.\n    if ((N->getOpcode() == ISD::ADD || N->getOpcode() == ISD::SUB) &&\n        N->getSimpleValueType(0).isVector()) {\n\n      APInt SplatVal;\n      if (X86::isConstantSplat(N->getOperand(1), SplatVal) &&\n          SplatVal.isOneValue()) {\n        SDLoc DL(N);\n\n        MVT VT = N->getSimpleValueType(0);\n        unsigned NumElts = VT.getSizeInBits() / 32;\n        SDValue AllOnes =\n            CurDAG->getAllOnesConstant(DL, MVT::getVectorVT(MVT::i32, NumElts));\n        AllOnes = CurDAG->getBitcast(VT, AllOnes);\n\n        unsigned NewOpcode = N->getOpcode() == ISD::ADD ? ISD::SUB : ISD::ADD;\n        SDValue Res =\n            CurDAG->getNode(NewOpcode, DL, VT, N->getOperand(0), AllOnes);\n        --I;\n        CurDAG->ReplaceAllUsesWith(N, Res.getNode());\n        ++I;\n        MadeChange = true;\n        continue;\n      }\n    }\n\n    switch (N->getOpcode()) {\n    case X86ISD::VBROADCAST: {\n      MVT VT = N->getSimpleValueType(0);\n      // Emulate v32i16/v64i8 broadcast without BWI.\n      if (!Subtarget->hasBWI() && (VT == MVT::v32i16 || VT == MVT::v64i8)) {\n        MVT NarrowVT = VT == MVT::v32i16 ? MVT::v16i16 : MVT::v32i8;\n        SDLoc dl(N);\n        SDValue NarrowBCast =\n            CurDAG->getNode(X86ISD::VBROADCAST, dl, NarrowVT, N->getOperand(0));\n        SDValue Res =\n            CurDAG->getNode(ISD::INSERT_SUBVECTOR, dl, VT, CurDAG->getUNDEF(VT),\n                            NarrowBCast, CurDAG->getIntPtrConstant(0, dl));\n        unsigned Index = VT == MVT::v32i16 ? 16 : 32;\n        Res = CurDAG->getNode(ISD::INSERT_SUBVECTOR, dl, VT, Res, NarrowBCast,\n                              CurDAG->getIntPtrConstant(Index, dl));\n\n        --I;\n        CurDAG->ReplaceAllUsesWith(N, Res.getNode());\n        ++I;\n        MadeChange = true;\n        continue;\n      }\n\n      break;\n    }\n    case X86ISD::VBROADCAST_LOAD: {\n      MVT VT = N->getSimpleValueType(0);\n      // Emulate v32i16/v64i8 broadcast without BWI.\n      if (!Subtarget->hasBWI() && (VT == MVT::v32i16 || VT == MVT::v64i8)) {\n        MVT NarrowVT = VT == MVT::v32i16 ? MVT::v16i16 : MVT::v32i8;\n        auto *MemNode = cast<MemSDNode>(N);\n        SDLoc dl(N);\n        SDVTList VTs = CurDAG->getVTList(NarrowVT, MVT::Other);\n        SDValue Ops[] = {MemNode->getChain(), MemNode->getBasePtr()};\n        SDValue NarrowBCast = CurDAG->getMemIntrinsicNode(\n            X86ISD::VBROADCAST_LOAD, dl, VTs, Ops, MemNode->getMemoryVT(),\n            MemNode->getMemOperand());\n        SDValue Res =\n            CurDAG->getNode(ISD::INSERT_SUBVECTOR, dl, VT, CurDAG->getUNDEF(VT),\n                            NarrowBCast, CurDAG->getIntPtrConstant(0, dl));\n        unsigned Index = VT == MVT::v32i16 ? 16 : 32;\n        Res = CurDAG->getNode(ISD::INSERT_SUBVECTOR, dl, VT, Res, NarrowBCast,\n                              CurDAG->getIntPtrConstant(Index, dl));\n\n        --I;\n        SDValue To[] = {Res, NarrowBCast.getValue(1)};\n        CurDAG->ReplaceAllUsesWith(N, To);\n        ++I;\n        MadeChange = true;\n        continue;\n      }\n\n      break;\n    }\n    case ISD::VSELECT: {\n      // Replace VSELECT with non-mask conditions with with BLENDV.\n      if (N->getOperand(0).getValueType().getVectorElementType() == MVT::i1)\n        break;\n\n      assert(Subtarget->hasSSE41() && \"Expected SSE4.1 support!\");\n      SDValue Blendv =\n          CurDAG->getNode(X86ISD::BLENDV, SDLoc(N), N->getValueType(0),\n                          N->getOperand(0), N->getOperand(1), N->getOperand(2));\n      --I;\n      CurDAG->ReplaceAllUsesWith(N, Blendv.getNode());\n      ++I;\n      MadeChange = true;\n      continue;\n    }\n    case ISD::FP_ROUND:\n    case ISD::STRICT_FP_ROUND:\n    case ISD::FP_TO_SINT:\n    case ISD::FP_TO_UINT:\n    case ISD::STRICT_FP_TO_SINT:\n    case ISD::STRICT_FP_TO_UINT: {\n      // Replace vector fp_to_s/uint with their X86 specific equivalent so we\n      // don't need 2 sets of patterns.\n      if (!N->getSimpleValueType(0).isVector())\n        break;\n\n      unsigned NewOpc;\n      switch (N->getOpcode()) {\n      default: llvm_unreachable(\"Unexpected opcode!\");\n      case ISD::FP_ROUND:          NewOpc = X86ISD::VFPROUND;        break;\n      case ISD::STRICT_FP_ROUND:   NewOpc = X86ISD::STRICT_VFPROUND; break;\n      case ISD::STRICT_FP_TO_SINT: NewOpc = X86ISD::STRICT_CVTTP2SI; break;\n      case ISD::FP_TO_SINT:        NewOpc = X86ISD::CVTTP2SI;        break;\n      case ISD::STRICT_FP_TO_UINT: NewOpc = X86ISD::STRICT_CVTTP2UI; break;\n      case ISD::FP_TO_UINT:        NewOpc = X86ISD::CVTTP2UI;        break;\n      }\n      SDValue Res;\n      if (N->isStrictFPOpcode())\n        Res =\n            CurDAG->getNode(NewOpc, SDLoc(N), {N->getValueType(0), MVT::Other},\n                            {N->getOperand(0), N->getOperand(1)});\n      else\n        Res =\n            CurDAG->getNode(NewOpc, SDLoc(N), N->getValueType(0),\n                            N->getOperand(0));\n      --I;\n      CurDAG->ReplaceAllUsesWith(N, Res.getNode());\n      ++I;\n      MadeChange = true;\n      continue;\n    }\n    case ISD::SHL:\n    case ISD::SRA:\n    case ISD::SRL: {\n      // Replace vector shifts with their X86 specific equivalent so we don't\n      // need 2 sets of patterns.\n      if (!N->getValueType(0).isVector())\n        break;\n\n      unsigned NewOpc;\n      switch (N->getOpcode()) {\n      default: llvm_unreachable(\"Unexpected opcode!\");\n      case ISD::SHL: NewOpc = X86ISD::VSHLV; break;\n      case ISD::SRA: NewOpc = X86ISD::VSRAV; break;\n      case ISD::SRL: NewOpc = X86ISD::VSRLV; break;\n      }\n      SDValue Res = CurDAG->getNode(NewOpc, SDLoc(N), N->getValueType(0),\n                                    N->getOperand(0), N->getOperand(1));\n      --I;\n      CurDAG->ReplaceAllUsesOfValueWith(SDValue(N, 0), Res);\n      ++I;\n      MadeChange = true;\n      continue;\n    }\n    case ISD::ANY_EXTEND:\n    case ISD::ANY_EXTEND_VECTOR_INREG: {\n      // Replace vector any extend with the zero extend equivalents so we don't\n      // need 2 sets of patterns. Ignore vXi1 extensions.\n      if (!N->getValueType(0).isVector())\n        break;\n\n      unsigned NewOpc;\n      if (N->getOperand(0).getScalarValueSizeInBits() == 1) {\n        assert(N->getOpcode() == ISD::ANY_EXTEND &&\n               \"Unexpected opcode for mask vector!\");\n        NewOpc = ISD::SIGN_EXTEND;\n      } else {\n        NewOpc = N->getOpcode() == ISD::ANY_EXTEND\n                              ? ISD::ZERO_EXTEND\n                              : ISD::ZERO_EXTEND_VECTOR_INREG;\n      }\n\n      SDValue Res = CurDAG->getNode(NewOpc, SDLoc(N), N->getValueType(0),\n                                    N->getOperand(0));\n      --I;\n      CurDAG->ReplaceAllUsesOfValueWith(SDValue(N, 0), Res);\n      ++I;\n      MadeChange = true;\n      continue;\n    }\n    case ISD::FCEIL:\n    case ISD::STRICT_FCEIL:\n    case ISD::FFLOOR:\n    case ISD::STRICT_FFLOOR:\n    case ISD::FTRUNC:\n    case ISD::STRICT_FTRUNC:\n    case ISD::FROUNDEVEN:\n    case ISD::STRICT_FROUNDEVEN:\n    case ISD::FNEARBYINT:\n    case ISD::STRICT_FNEARBYINT:\n    case ISD::FRINT:\n    case ISD::STRICT_FRINT: {\n      // Replace fp rounding with their X86 specific equivalent so we don't\n      // need 2 sets of patterns.\n      unsigned Imm;\n      switch (N->getOpcode()) {\n      default: llvm_unreachable(\"Unexpected opcode!\");\n      case ISD::STRICT_FCEIL:\n      case ISD::FCEIL:      Imm = 0xA; break;\n      case ISD::STRICT_FFLOOR:\n      case ISD::FFLOOR:     Imm = 0x9; break;\n      case ISD::STRICT_FTRUNC:\n      case ISD::FTRUNC:     Imm = 0xB; break;\n      case ISD::STRICT_FROUNDEVEN:\n      case ISD::FROUNDEVEN: Imm = 0x8; break;\n      case ISD::STRICT_FNEARBYINT:\n      case ISD::FNEARBYINT: Imm = 0xC; break;\n      case ISD::STRICT_FRINT:\n      case ISD::FRINT:      Imm = 0x4; break;\n      }\n      SDLoc dl(N);\n      bool IsStrict = N->isStrictFPOpcode();\n      SDValue Res;\n      if (IsStrict)\n        Res = CurDAG->getNode(X86ISD::STRICT_VRNDSCALE, dl,\n                              {N->getValueType(0), MVT::Other},\n                              {N->getOperand(0), N->getOperand(1),\n                               CurDAG->getTargetConstant(Imm, dl, MVT::i32)});\n      else\n        Res = CurDAG->getNode(X86ISD::VRNDSCALE, dl, N->getValueType(0),\n                              N->getOperand(0),\n                              CurDAG->getTargetConstant(Imm, dl, MVT::i32));\n      --I;\n      CurDAG->ReplaceAllUsesWith(N, Res.getNode());\n      ++I;\n      MadeChange = true;\n      continue;\n    }\n    case X86ISD::FANDN:\n    case X86ISD::FAND:\n    case X86ISD::FOR:\n    case X86ISD::FXOR: {\n      // Widen scalar fp logic ops to vector to reduce isel patterns.\n      // FIXME: Can we do this during lowering/combine.\n      MVT VT = N->getSimpleValueType(0);\n      if (VT.isVector() || VT == MVT::f128)\n        break;\n\n      MVT VecVT = VT == MVT::f64 ? MVT::v2f64 : MVT::v4f32;\n      SDLoc dl(N);\n      SDValue Op0 = CurDAG->getNode(ISD::SCALAR_TO_VECTOR, dl, VecVT,\n                                    N->getOperand(0));\n      SDValue Op1 = CurDAG->getNode(ISD::SCALAR_TO_VECTOR, dl, VecVT,\n                                    N->getOperand(1));\n\n      SDValue Res;\n      if (Subtarget->hasSSE2()) {\n        EVT IntVT = EVT(VecVT).changeVectorElementTypeToInteger();\n        Op0 = CurDAG->getNode(ISD::BITCAST, dl, IntVT, Op0);\n        Op1 = CurDAG->getNode(ISD::BITCAST, dl, IntVT, Op1);\n        unsigned Opc;\n        switch (N->getOpcode()) {\n        default: llvm_unreachable(\"Unexpected opcode!\");\n        case X86ISD::FANDN: Opc = X86ISD::ANDNP; break;\n        case X86ISD::FAND:  Opc = ISD::AND;      break;\n        case X86ISD::FOR:   Opc = ISD::OR;       break;\n        case X86ISD::FXOR:  Opc = ISD::XOR;      break;\n        }\n        Res = CurDAG->getNode(Opc, dl, IntVT, Op0, Op1);\n        Res = CurDAG->getNode(ISD::BITCAST, dl, VecVT, Res);\n      } else {\n        Res = CurDAG->getNode(N->getOpcode(), dl, VecVT, Op0, Op1);\n      }\n      Res = CurDAG->getNode(ISD::EXTRACT_VECTOR_ELT, dl, VT, Res,\n                            CurDAG->getIntPtrConstant(0, dl));\n      --I;\n      CurDAG->ReplaceAllUsesOfValueWith(SDValue(N, 0), Res);\n      ++I;\n      MadeChange = true;\n      continue;\n    }\n    }\n\n    if (OptLevel != CodeGenOpt::None &&\n        // Only do this when the target can fold the load into the call or\n        // jmp.\n        !Subtarget->useIndirectThunkCalls() &&\n        ((N->getOpcode() == X86ISD::CALL && !Subtarget->slowTwoMemOps()) ||\n         (N->getOpcode() == X86ISD::TC_RETURN &&\n          (Subtarget->is64Bit() ||\n           !getTargetMachine().isPositionIndependent())))) {\n      /// Also try moving call address load from outside callseq_start to just\n      /// before the call to allow it to be folded.\n      ///\n      ///     [Load chain]\n      ///         ^\n      ///         |\n      ///       [Load]\n      ///       ^    ^\n      ///       |    |\n      ///      /      \\--\n      ///     /          |\n      ///[CALLSEQ_START] |\n      ///     ^          |\n      ///     |          |\n      /// [LOAD/C2Reg]   |\n      ///     |          |\n      ///      \\        /\n      ///       \\      /\n      ///       [CALL]\n      bool HasCallSeq = N->getOpcode() == X86ISD::CALL;\n      SDValue Chain = N->getOperand(0);\n      SDValue Load  = N->getOperand(1);\n      if (!isCalleeLoad(Load, Chain, HasCallSeq))\n        continue;\n      moveBelowOrigChain(CurDAG, Load, SDValue(N, 0), Chain);\n      ++NumLoadMoved;\n      MadeChange = true;\n      continue;\n    }\n\n    // Lower fpround and fpextend nodes that target the FP stack to be store and\n    // load to the stack.  This is a gross hack.  We would like to simply mark\n    // these as being illegal, but when we do that, legalize produces these when\n    // it expands calls, then expands these in the same legalize pass.  We would\n    // like dag combine to be able to hack on these between the call expansion\n    // and the node legalization.  As such this pass basically does \"really\n    // late\" legalization of these inline with the X86 isel pass.\n    // FIXME: This should only happen when not compiled with -O0.\n    switch (N->getOpcode()) {\n    default: continue;\n    case ISD::FP_ROUND:\n    case ISD::FP_EXTEND:\n    {\n      MVT SrcVT = N->getOperand(0).getSimpleValueType();\n      MVT DstVT = N->getSimpleValueType(0);\n\n      // If any of the sources are vectors, no fp stack involved.\n      if (SrcVT.isVector() || DstVT.isVector())\n        continue;\n\n      // If the source and destination are SSE registers, then this is a legal\n      // conversion that should not be lowered.\n      const X86TargetLowering *X86Lowering =\n          static_cast<const X86TargetLowering *>(TLI);\n      bool SrcIsSSE = X86Lowering->isScalarFPTypeInSSEReg(SrcVT);\n      bool DstIsSSE = X86Lowering->isScalarFPTypeInSSEReg(DstVT);\n      if (SrcIsSSE && DstIsSSE)\n        continue;\n\n      if (!SrcIsSSE && !DstIsSSE) {\n        // If this is an FPStack extension, it is a noop.\n        if (N->getOpcode() == ISD::FP_EXTEND)\n          continue;\n        // If this is a value-preserving FPStack truncation, it is a noop.\n        if (N->getConstantOperandVal(1))\n          continue;\n      }\n\n      // Here we could have an FP stack truncation or an FPStack <-> SSE convert.\n      // FPStack has extload and truncstore.  SSE can fold direct loads into other\n      // operations.  Based on this, decide what we want to do.\n      MVT MemVT = (N->getOpcode() == ISD::FP_ROUND) ? DstVT : SrcVT;\n      SDValue MemTmp = CurDAG->CreateStackTemporary(MemVT);\n      int SPFI = cast<FrameIndexSDNode>(MemTmp)->getIndex();\n      MachinePointerInfo MPI =\n          MachinePointerInfo::getFixedStack(CurDAG->getMachineFunction(), SPFI);\n      SDLoc dl(N);\n\n      // FIXME: optimize the case where the src/dest is a load or store?\n\n      SDValue Store = CurDAG->getTruncStore(\n          CurDAG->getEntryNode(), dl, N->getOperand(0), MemTmp, MPI, MemVT);\n      SDValue Result = CurDAG->getExtLoad(ISD::EXTLOAD, dl, DstVT, Store,\n                                          MemTmp, MPI, MemVT);\n\n      // We're about to replace all uses of the FP_ROUND/FP_EXTEND with the\n      // extload we created.  This will cause general havok on the dag because\n      // anything below the conversion could be folded into other existing nodes.\n      // To avoid invalidating 'I', back it up to the convert node.\n      --I;\n      CurDAG->ReplaceAllUsesOfValueWith(SDValue(N, 0), Result);\n      break;\n    }\n\n    //The sequence of events for lowering STRICT_FP versions of these nodes requires\n    //dealing with the chain differently, as there is already a preexisting chain.\n    case ISD::STRICT_FP_ROUND:\n    case ISD::STRICT_FP_EXTEND:\n    {\n      MVT SrcVT = N->getOperand(1).getSimpleValueType();\n      MVT DstVT = N->getSimpleValueType(0);\n\n      // If any of the sources are vectors, no fp stack involved.\n      if (SrcVT.isVector() || DstVT.isVector())\n        continue;\n\n      // If the source and destination are SSE registers, then this is a legal\n      // conversion that should not be lowered.\n      const X86TargetLowering *X86Lowering =\n          static_cast<const X86TargetLowering *>(TLI);\n      bool SrcIsSSE = X86Lowering->isScalarFPTypeInSSEReg(SrcVT);\n      bool DstIsSSE = X86Lowering->isScalarFPTypeInSSEReg(DstVT);\n      if (SrcIsSSE && DstIsSSE)\n        continue;\n\n      if (!SrcIsSSE && !DstIsSSE) {\n        // If this is an FPStack extension, it is a noop.\n        if (N->getOpcode() == ISD::STRICT_FP_EXTEND)\n          continue;\n        // If this is a value-preserving FPStack truncation, it is a noop.\n        if (N->getConstantOperandVal(2))\n          continue;\n      }\n\n      // Here we could have an FP stack truncation or an FPStack <-> SSE convert.\n      // FPStack has extload and truncstore.  SSE can fold direct loads into other\n      // operations.  Based on this, decide what we want to do.\n      MVT MemVT = (N->getOpcode() == ISD::STRICT_FP_ROUND) ? DstVT : SrcVT;\n      SDValue MemTmp = CurDAG->CreateStackTemporary(MemVT);\n      int SPFI = cast<FrameIndexSDNode>(MemTmp)->getIndex();\n      MachinePointerInfo MPI =\n          MachinePointerInfo::getFixedStack(CurDAG->getMachineFunction(), SPFI);\n      SDLoc dl(N);\n\n      // FIXME: optimize the case where the src/dest is a load or store?\n\n      //Since the operation is StrictFP, use the preexisting chain.\n      SDValue Store, Result;\n      if (!SrcIsSSE) {\n        SDVTList VTs = CurDAG->getVTList(MVT::Other);\n        SDValue Ops[] = {N->getOperand(0), N->getOperand(1), MemTmp};\n        Store = CurDAG->getMemIntrinsicNode(X86ISD::FST, dl, VTs, Ops, MemVT,\n                                            MPI, /*Align*/ None,\n                                            MachineMemOperand::MOStore);\n        if (N->getFlags().hasNoFPExcept()) {\n          SDNodeFlags Flags = Store->getFlags();\n          Flags.setNoFPExcept(true);\n          Store->setFlags(Flags);\n        }\n      } else {\n        assert(SrcVT == MemVT && \"Unexpected VT!\");\n        Store = CurDAG->getStore(N->getOperand(0), dl, N->getOperand(1), MemTmp,\n                                 MPI);\n      }\n\n      if (!DstIsSSE) {\n        SDVTList VTs = CurDAG->getVTList(DstVT, MVT::Other);\n        SDValue Ops[] = {Store, MemTmp};\n        Result = CurDAG->getMemIntrinsicNode(\n            X86ISD::FLD, dl, VTs, Ops, MemVT, MPI,\n            /*Align*/ None, MachineMemOperand::MOLoad);\n        if (N->getFlags().hasNoFPExcept()) {\n          SDNodeFlags Flags = Result->getFlags();\n          Flags.setNoFPExcept(true);\n          Result->setFlags(Flags);\n        }\n      } else {\n        assert(DstVT == MemVT && \"Unexpected VT!\");\n        Result = CurDAG->getLoad(DstVT, dl, Store, MemTmp, MPI);\n      }\n\n      // We're about to replace all uses of the FP_ROUND/FP_EXTEND with the\n      // extload we created.  This will cause general havok on the dag because\n      // anything below the conversion could be folded into other existing nodes.\n      // To avoid invalidating 'I', back it up to the convert node.\n      --I;\n      CurDAG->ReplaceAllUsesWith(N, Result.getNode());\n      break;\n    }\n    }\n\n\n    // Now that we did that, the node is dead.  Increment the iterator to the\n    // next node to process, then delete N.\n    ++I;\n    MadeChange = true;\n  }\n\n  // Remove any dead nodes that may have been left behind.\n  if (MadeChange)\n    CurDAG->RemoveDeadNodes();\n}\n\n// Look for a redundant movzx/movsx that can occur after an 8-bit divrem.\nbool X86DAGToDAGISel::tryOptimizeRem8Extend(SDNode *N) {\n  unsigned Opc = N->getMachineOpcode();\n  if (Opc != X86::MOVZX32rr8 && Opc != X86::MOVSX32rr8 &&\n      Opc != X86::MOVSX64rr8)\n    return false;\n\n  SDValue N0 = N->getOperand(0);\n\n  // We need to be extracting the lower bit of an extend.\n  if (!N0.isMachineOpcode() ||\n      N0.getMachineOpcode() != TargetOpcode::EXTRACT_SUBREG ||\n      N0.getConstantOperandVal(1) != X86::sub_8bit)\n    return false;\n\n  // We're looking for either a movsx or movzx to match the original opcode.\n  unsigned ExpectedOpc = Opc == X86::MOVZX32rr8 ? X86::MOVZX32rr8_NOREX\n                                                : X86::MOVSX32rr8_NOREX;\n  SDValue N00 = N0.getOperand(0);\n  if (!N00.isMachineOpcode() || N00.getMachineOpcode() != ExpectedOpc)\n    return false;\n\n  if (Opc == X86::MOVSX64rr8) {\n    // If we had a sign extend from 8 to 64 bits. We still need to go from 32\n    // to 64.\n    MachineSDNode *Extend = CurDAG->getMachineNode(X86::MOVSX64rr32, SDLoc(N),\n                                                   MVT::i64, N00);\n    ReplaceUses(N, Extend);\n  } else {\n    // Ok we can drop this extend and just use the original extend.\n    ReplaceUses(N, N00.getNode());\n  }\n\n  return true;\n}\n\nvoid X86DAGToDAGISel::PostprocessISelDAG() {\n  // Skip peepholes at -O0.\n  if (TM.getOptLevel() == CodeGenOpt::None)\n    return;\n\n  SelectionDAG::allnodes_iterator Position = CurDAG->allnodes_end();\n\n  bool MadeChange = false;\n  while (Position != CurDAG->allnodes_begin()) {\n    SDNode *N = &*--Position;\n    // Skip dead nodes and any non-machine opcodes.\n    if (N->use_empty() || !N->isMachineOpcode())\n      continue;\n\n    if (tryOptimizeRem8Extend(N)) {\n      MadeChange = true;\n      continue;\n    }\n\n    // Look for a TESTrr+ANDrr pattern where both operands of the test are\n    // the same. Rewrite to remove the AND.\n    unsigned Opc = N->getMachineOpcode();\n    if ((Opc == X86::TEST8rr || Opc == X86::TEST16rr ||\n         Opc == X86::TEST32rr || Opc == X86::TEST64rr) &&\n        N->getOperand(0) == N->getOperand(1) &&\n        N->isOnlyUserOf(N->getOperand(0).getNode()) &&\n        N->getOperand(0).isMachineOpcode()) {\n      SDValue And = N->getOperand(0);\n      unsigned N0Opc = And.getMachineOpcode();\n      if (N0Opc == X86::AND8rr || N0Opc == X86::AND16rr ||\n          N0Opc == X86::AND32rr || N0Opc == X86::AND64rr) {\n        MachineSDNode *Test = CurDAG->getMachineNode(Opc, SDLoc(N),\n                                                     MVT::i32,\n                                                     And.getOperand(0),\n                                                     And.getOperand(1));\n        ReplaceUses(N, Test);\n        MadeChange = true;\n        continue;\n      }\n      if (N0Opc == X86::AND8rm || N0Opc == X86::AND16rm ||\n          N0Opc == X86::AND32rm || N0Opc == X86::AND64rm) {\n        unsigned NewOpc;\n        switch (N0Opc) {\n        case X86::AND8rm:  NewOpc = X86::TEST8mr; break;\n        case X86::AND16rm: NewOpc = X86::TEST16mr; break;\n        case X86::AND32rm: NewOpc = X86::TEST32mr; break;\n        case X86::AND64rm: NewOpc = X86::TEST64mr; break;\n        }\n\n        // Need to swap the memory and register operand.\n        SDValue Ops[] = { And.getOperand(1),\n                          And.getOperand(2),\n                          And.getOperand(3),\n                          And.getOperand(4),\n                          And.getOperand(5),\n                          And.getOperand(0),\n                          And.getOperand(6)  /* Chain */ };\n        MachineSDNode *Test = CurDAG->getMachineNode(NewOpc, SDLoc(N),\n                                                     MVT::i32, MVT::Other, Ops);\n        CurDAG->setNodeMemRefs(\n            Test, cast<MachineSDNode>(And.getNode())->memoperands());\n        ReplaceUses(N, Test);\n        MadeChange = true;\n        continue;\n      }\n    }\n\n    // Look for a KAND+KORTEST and turn it into KTEST if only the zero flag is\n    // used. We're doing this late so we can prefer to fold the AND into masked\n    // comparisons. Doing that can be better for the live range of the mask\n    // register.\n    if ((Opc == X86::KORTESTBrr || Opc == X86::KORTESTWrr ||\n         Opc == X86::KORTESTDrr || Opc == X86::KORTESTQrr) &&\n        N->getOperand(0) == N->getOperand(1) &&\n        N->isOnlyUserOf(N->getOperand(0).getNode()) &&\n        N->getOperand(0).isMachineOpcode() &&\n        onlyUsesZeroFlag(SDValue(N, 0))) {\n      SDValue And = N->getOperand(0);\n      unsigned N0Opc = And.getMachineOpcode();\n      // KANDW is legal with AVX512F, but KTESTW requires AVX512DQ. The other\n      // KAND instructions and KTEST use the same ISA feature.\n      if (N0Opc == X86::KANDBrr ||\n          (N0Opc == X86::KANDWrr && Subtarget->hasDQI()) ||\n          N0Opc == X86::KANDDrr || N0Opc == X86::KANDQrr) {\n        unsigned NewOpc;\n        switch (Opc) {\n        default: llvm_unreachable(\"Unexpected opcode!\");\n        case X86::KORTESTBrr: NewOpc = X86::KTESTBrr; break;\n        case X86::KORTESTWrr: NewOpc = X86::KTESTWrr; break;\n        case X86::KORTESTDrr: NewOpc = X86::KTESTDrr; break;\n        case X86::KORTESTQrr: NewOpc = X86::KTESTQrr; break;\n        }\n        MachineSDNode *KTest = CurDAG->getMachineNode(NewOpc, SDLoc(N),\n                                                      MVT::i32,\n                                                      And.getOperand(0),\n                                                      And.getOperand(1));\n        ReplaceUses(N, KTest);\n        MadeChange = true;\n        continue;\n      }\n    }\n\n    // Attempt to remove vectors moves that were inserted to zero upper bits.\n    if (Opc != TargetOpcode::SUBREG_TO_REG)\n      continue;\n\n    unsigned SubRegIdx = N->getConstantOperandVal(2);\n    if (SubRegIdx != X86::sub_xmm && SubRegIdx != X86::sub_ymm)\n      continue;\n\n    SDValue Move = N->getOperand(1);\n    if (!Move.isMachineOpcode())\n      continue;\n\n    // Make sure its one of the move opcodes we recognize.\n    switch (Move.getMachineOpcode()) {\n    default:\n      continue;\n    case X86::VMOVAPDrr:       case X86::VMOVUPDrr:\n    case X86::VMOVAPSrr:       case X86::VMOVUPSrr:\n    case X86::VMOVDQArr:       case X86::VMOVDQUrr:\n    case X86::VMOVAPDYrr:      case X86::VMOVUPDYrr:\n    case X86::VMOVAPSYrr:      case X86::VMOVUPSYrr:\n    case X86::VMOVDQAYrr:      case X86::VMOVDQUYrr:\n    case X86::VMOVAPDZ128rr:   case X86::VMOVUPDZ128rr:\n    case X86::VMOVAPSZ128rr:   case X86::VMOVUPSZ128rr:\n    case X86::VMOVDQA32Z128rr: case X86::VMOVDQU32Z128rr:\n    case X86::VMOVDQA64Z128rr: case X86::VMOVDQU64Z128rr:\n    case X86::VMOVAPDZ256rr:   case X86::VMOVUPDZ256rr:\n    case X86::VMOVAPSZ256rr:   case X86::VMOVUPSZ256rr:\n    case X86::VMOVDQA32Z256rr: case X86::VMOVDQU32Z256rr:\n    case X86::VMOVDQA64Z256rr: case X86::VMOVDQU64Z256rr:\n      break;\n    }\n\n    SDValue In = Move.getOperand(0);\n    if (!In.isMachineOpcode() ||\n        In.getMachineOpcode() <= TargetOpcode::GENERIC_OP_END)\n      continue;\n\n    // Make sure the instruction has a VEX, XOP, or EVEX prefix. This covers\n    // the SHA instructions which use a legacy encoding.\n    uint64_t TSFlags = getInstrInfo()->get(In.getMachineOpcode()).TSFlags;\n    if ((TSFlags & X86II::EncodingMask) != X86II::VEX &&\n        (TSFlags & X86II::EncodingMask) != X86II::EVEX &&\n        (TSFlags & X86II::EncodingMask) != X86II::XOP)\n      continue;\n\n    // Producing instruction is another vector instruction. We can drop the\n    // move.\n    CurDAG->UpdateNodeOperands(N, N->getOperand(0), In, N->getOperand(2));\n    MadeChange = true;\n  }\n\n  if (MadeChange)\n    CurDAG->RemoveDeadNodes();\n}\n\n\n/// Emit any code that needs to be executed only in the main function.\nvoid X86DAGToDAGISel::emitSpecialCodeForMain() {\n  if (Subtarget->isTargetCygMing()) {\n    TargetLowering::ArgListTy Args;\n    auto &DL = CurDAG->getDataLayout();\n\n    TargetLowering::CallLoweringInfo CLI(*CurDAG);\n    CLI.setChain(CurDAG->getRoot())\n        .setCallee(CallingConv::C, Type::getVoidTy(*CurDAG->getContext()),\n                   CurDAG->getExternalSymbol(\"__main\", TLI->getPointerTy(DL)),\n                   std::move(Args));\n    const TargetLowering &TLI = CurDAG->getTargetLoweringInfo();\n    std::pair<SDValue, SDValue> Result = TLI.LowerCallTo(CLI);\n    CurDAG->setRoot(Result.second);\n  }\n}\n\nvoid X86DAGToDAGISel::emitFunctionEntryCode() {\n  // If this is main, emit special code for main.\n  const Function &F = MF->getFunction();\n  if (F.hasExternalLinkage() && F.getName() == \"main\")\n    emitSpecialCodeForMain();\n}\n\nstatic bool isDispSafeForFrameIndex(int64_t Val) {\n  // On 64-bit platforms, we can run into an issue where a frame index\n  // includes a displacement that, when added to the explicit displacement,\n  // will overflow the displacement field. Assuming that the frame index\n  // displacement fits into a 31-bit integer  (which is only slightly more\n  // aggressive than the current fundamental assumption that it fits into\n  // a 32-bit integer), a 31-bit disp should always be safe.\n  return isInt<31>(Val);\n}\n\nbool X86DAGToDAGISel::foldOffsetIntoAddress(uint64_t Offset,\n                                            X86ISelAddressMode &AM) {\n  // We may have already matched a displacement and the caller just added the\n  // symbolic displacement. So we still need to do the checks even if Offset\n  // is zero.\n\n  int64_t Val = AM.Disp + Offset;\n\n  // Cannot combine ExternalSymbol displacements with integer offsets.\n  if (Val != 0 && (AM.ES || AM.MCSym))\n    return true;\n\n  CodeModel::Model M = TM.getCodeModel();\n  if (Subtarget->is64Bit()) {\n    if (Val != 0 &&\n        !X86::isOffsetSuitableForCodeModel(Val, M,\n                                           AM.hasSymbolicDisplacement()))\n      return true;\n    // In addition to the checks required for a register base, check that\n    // we do not try to use an unsafe Disp with a frame index.\n    if (AM.BaseType == X86ISelAddressMode::FrameIndexBase &&\n        !isDispSafeForFrameIndex(Val))\n      return true;\n  }\n  AM.Disp = Val;\n  return false;\n\n}\n\nbool X86DAGToDAGISel::matchLoadInAddress(LoadSDNode *N, X86ISelAddressMode &AM,\n                                         bool AllowSegmentRegForX32) {\n  SDValue Address = N->getOperand(1);\n\n  // load gs:0 -> GS segment register.\n  // load fs:0 -> FS segment register.\n  //\n  // This optimization is generally valid because the GNU TLS model defines that\n  // gs:0 (or fs:0 on X86-64) contains its own address. However, for X86-64 mode\n  // with 32-bit registers, as we get in ILP32 mode, those registers are first\n  // zero-extended to 64 bits and then added it to the base address, which gives\n  // unwanted results when the register holds a negative value.\n  // For more information see http://people.redhat.com/drepper/tls.pdf\n  if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Address)) {\n    if (C->getSExtValue() == 0 && AM.Segment.getNode() == nullptr &&\n        !IndirectTlsSegRefs &&\n        (Subtarget->isTargetGlibc() || Subtarget->isTargetAndroid() ||\n         Subtarget->isTargetFuchsia())) {\n      if (Subtarget->isTarget64BitILP32() && !AllowSegmentRegForX32)\n        return true;\n      switch (N->getPointerInfo().getAddrSpace()) {\n      case X86AS::GS:\n        AM.Segment = CurDAG->getRegister(X86::GS, MVT::i16);\n        return false;\n      case X86AS::FS:\n        AM.Segment = CurDAG->getRegister(X86::FS, MVT::i16);\n        return false;\n      // Address space X86AS::SS is not handled here, because it is not used to\n      // address TLS areas.\n      }\n    }\n  }\n\n  return true;\n}\n\n/// Try to match X86ISD::Wrapper and X86ISD::WrapperRIP nodes into an addressing\n/// mode. These wrap things that will resolve down into a symbol reference.\n/// If no match is possible, this returns true, otherwise it returns false.\nbool X86DAGToDAGISel::matchWrapper(SDValue N, X86ISelAddressMode &AM) {\n  // If the addressing mode already has a symbol as the displacement, we can\n  // never match another symbol.\n  if (AM.hasSymbolicDisplacement())\n    return true;\n\n  bool IsRIPRelTLS = false;\n  bool IsRIPRel = N.getOpcode() == X86ISD::WrapperRIP;\n  if (IsRIPRel) {\n    SDValue Val = N.getOperand(0);\n    if (Val.getOpcode() == ISD::TargetGlobalTLSAddress)\n      IsRIPRelTLS = true;\n  }\n\n  // We can't use an addressing mode in the 64-bit large code model.\n  // Global TLS addressing is an exception. In the medium code model,\n  // we use can use a mode when RIP wrappers are present.\n  // That signifies access to globals that are known to be \"near\",\n  // such as the GOT itself.\n  CodeModel::Model M = TM.getCodeModel();\n  if (Subtarget->is64Bit() &&\n      ((M == CodeModel::Large && !IsRIPRelTLS) ||\n       (M == CodeModel::Medium && !IsRIPRel)))\n    return true;\n\n  // Base and index reg must be 0 in order to use %rip as base.\n  if (IsRIPRel && AM.hasBaseOrIndexReg())\n    return true;\n\n  // Make a local copy in case we can't do this fold.\n  X86ISelAddressMode Backup = AM;\n\n  int64_t Offset = 0;\n  SDValue N0 = N.getOperand(0);\n  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(N0)) {\n    AM.GV = G->getGlobal();\n    AM.SymbolFlags = G->getTargetFlags();\n    Offset = G->getOffset();\n  } else if (ConstantPoolSDNode *CP = dyn_cast<ConstantPoolSDNode>(N0)) {\n    AM.CP = CP->getConstVal();\n    AM.Alignment = CP->getAlign();\n    AM.SymbolFlags = CP->getTargetFlags();\n    Offset = CP->getOffset();\n  } else if (ExternalSymbolSDNode *S = dyn_cast<ExternalSymbolSDNode>(N0)) {\n    AM.ES = S->getSymbol();\n    AM.SymbolFlags = S->getTargetFlags();\n  } else if (auto *S = dyn_cast<MCSymbolSDNode>(N0)) {\n    AM.MCSym = S->getMCSymbol();\n  } else if (JumpTableSDNode *J = dyn_cast<JumpTableSDNode>(N0)) {\n    AM.JT = J->getIndex();\n    AM.SymbolFlags = J->getTargetFlags();\n  } else if (BlockAddressSDNode *BA = dyn_cast<BlockAddressSDNode>(N0)) {\n    AM.BlockAddr = BA->getBlockAddress();\n    AM.SymbolFlags = BA->getTargetFlags();\n    Offset = BA->getOffset();\n  } else\n    llvm_unreachable(\"Unhandled symbol reference node.\");\n\n  if (foldOffsetIntoAddress(Offset, AM)) {\n    AM = Backup;\n    return true;\n  }\n\n  if (IsRIPRel)\n    AM.setBaseReg(CurDAG->getRegister(X86::RIP, MVT::i64));\n\n  // Commit the changes now that we know this fold is safe.\n  return false;\n}\n\n/// Add the specified node to the specified addressing mode, returning true if\n/// it cannot be done. This just pattern matches for the addressing mode.\nbool X86DAGToDAGISel::matchAddress(SDValue N, X86ISelAddressMode &AM) {\n  if (matchAddressRecursively(N, AM, 0))\n    return true;\n\n  // Post-processing: Make a second attempt to fold a load, if we now know\n  // that there will not be any other register. This is only performed for\n  // 64-bit ILP32 mode since 32-bit mode and 64-bit LP64 mode will have folded\n  // any foldable load the first time.\n  if (Subtarget->isTarget64BitILP32() &&\n      AM.BaseType == X86ISelAddressMode::RegBase &&\n      AM.Base_Reg.getNode() != nullptr && AM.IndexReg.getNode() == nullptr) {\n    SDValue Save_Base_Reg = AM.Base_Reg;\n    if (auto *LoadN = dyn_cast<LoadSDNode>(Save_Base_Reg)) {\n      AM.Base_Reg = SDValue();\n      if (matchLoadInAddress(LoadN, AM, /*AllowSegmentRegForX32=*/true))\n        AM.Base_Reg = Save_Base_Reg;\n    }\n  }\n\n  // Post-processing: Convert lea(,%reg,2) to lea(%reg,%reg), which has\n  // a smaller encoding and avoids a scaled-index.\n  if (AM.Scale == 2 &&\n      AM.BaseType == X86ISelAddressMode::RegBase &&\n      AM.Base_Reg.getNode() == nullptr) {\n    AM.Base_Reg = AM.IndexReg;\n    AM.Scale = 1;\n  }\n\n  // Post-processing: Convert foo to foo(%rip), even in non-PIC mode,\n  // because it has a smaller encoding.\n  // TODO: Which other code models can use this?\n  switch (TM.getCodeModel()) {\n    default: break;\n    case CodeModel::Small:\n    case CodeModel::Kernel:\n      if (Subtarget->is64Bit() &&\n          AM.Scale == 1 &&\n          AM.BaseType == X86ISelAddressMode::RegBase &&\n          AM.Base_Reg.getNode() == nullptr &&\n          AM.IndexReg.getNode() == nullptr &&\n          AM.SymbolFlags == X86II::MO_NO_FLAG &&\n          AM.hasSymbolicDisplacement())\n        AM.Base_Reg = CurDAG->getRegister(X86::RIP, MVT::i64);\n      break;\n  }\n\n  return false;\n}\n\nbool X86DAGToDAGISel::matchAdd(SDValue &N, X86ISelAddressMode &AM,\n                               unsigned Depth) {\n  // Add an artificial use to this node so that we can keep track of\n  // it if it gets CSE'd with a different node.\n  HandleSDNode Handle(N);\n\n  X86ISelAddressMode Backup = AM;\n  if (!matchAddressRecursively(N.getOperand(0), AM, Depth+1) &&\n      !matchAddressRecursively(Handle.getValue().getOperand(1), AM, Depth+1))\n    return false;\n  AM = Backup;\n\n  // Try again after commutating the operands.\n  if (!matchAddressRecursively(Handle.getValue().getOperand(1), AM,\n                               Depth + 1) &&\n      !matchAddressRecursively(Handle.getValue().getOperand(0), AM, Depth + 1))\n    return false;\n  AM = Backup;\n\n  // If we couldn't fold both operands into the address at the same time,\n  // see if we can just put each operand into a register and fold at least\n  // the add.\n  if (AM.BaseType == X86ISelAddressMode::RegBase &&\n      !AM.Base_Reg.getNode() &&\n      !AM.IndexReg.getNode()) {\n    N = Handle.getValue();\n    AM.Base_Reg = N.getOperand(0);\n    AM.IndexReg = N.getOperand(1);\n    AM.Scale = 1;\n    return false;\n  }\n  N = Handle.getValue();\n  return true;\n}\n\n// Insert a node into the DAG at least before the Pos node's position. This\n// will reposition the node as needed, and will assign it a node ID that is <=\n// the Pos node's ID. Note that this does *not* preserve the uniqueness of node\n// IDs! The selection DAG must no longer depend on their uniqueness when this\n// is used.\nstatic void insertDAGNode(SelectionDAG &DAG, SDValue Pos, SDValue N) {\n  if (N->getNodeId() == -1 ||\n      (SelectionDAGISel::getUninvalidatedNodeId(N.getNode()) >\n       SelectionDAGISel::getUninvalidatedNodeId(Pos.getNode()))) {\n    DAG.RepositionNode(Pos->getIterator(), N.getNode());\n    // Mark Node as invalid for pruning as after this it may be a successor to a\n    // selected node but otherwise be in the same position of Pos.\n    // Conservatively mark it with the same -abs(Id) to assure node id\n    // invariant is preserved.\n    N->setNodeId(Pos->getNodeId());\n    SelectionDAGISel::InvalidateNodeId(N.getNode());\n  }\n}\n\n// Transform \"(X >> (8-C1)) & (0xff << C1)\" to \"((X >> 8) & 0xff) << C1\" if\n// safe. This allows us to convert the shift and and into an h-register\n// extract and a scaled index. Returns false if the simplification is\n// performed.\nstatic bool foldMaskAndShiftToExtract(SelectionDAG &DAG, SDValue N,\n                                      uint64_t Mask,\n                                      SDValue Shift, SDValue X,\n                                      X86ISelAddressMode &AM) {\n  if (Shift.getOpcode() != ISD::SRL ||\n      !isa<ConstantSDNode>(Shift.getOperand(1)) ||\n      !Shift.hasOneUse())\n    return true;\n\n  int ScaleLog = 8 - Shift.getConstantOperandVal(1);\n  if (ScaleLog <= 0 || ScaleLog >= 4 ||\n      Mask != (0xffu << ScaleLog))\n    return true;\n\n  MVT VT = N.getSimpleValueType();\n  SDLoc DL(N);\n  SDValue Eight = DAG.getConstant(8, DL, MVT::i8);\n  SDValue NewMask = DAG.getConstant(0xff, DL, VT);\n  SDValue Srl = DAG.getNode(ISD::SRL, DL, VT, X, Eight);\n  SDValue And = DAG.getNode(ISD::AND, DL, VT, Srl, NewMask);\n  SDValue ShlCount = DAG.getConstant(ScaleLog, DL, MVT::i8);\n  SDValue Shl = DAG.getNode(ISD::SHL, DL, VT, And, ShlCount);\n\n  // Insert the new nodes into the topological ordering. We must do this in\n  // a valid topological ordering as nothing is going to go back and re-sort\n  // these nodes. We continually insert before 'N' in sequence as this is\n  // essentially a pre-flattened and pre-sorted sequence of nodes. There is no\n  // hierarchy left to express.\n  insertDAGNode(DAG, N, Eight);\n  insertDAGNode(DAG, N, Srl);\n  insertDAGNode(DAG, N, NewMask);\n  insertDAGNode(DAG, N, And);\n  insertDAGNode(DAG, N, ShlCount);\n  insertDAGNode(DAG, N, Shl);\n  DAG.ReplaceAllUsesWith(N, Shl);\n  DAG.RemoveDeadNode(N.getNode());\n  AM.IndexReg = And;\n  AM.Scale = (1 << ScaleLog);\n  return false;\n}\n\n// Transforms \"(X << C1) & C2\" to \"(X & (C2>>C1)) << C1\" if safe and if this\n// allows us to fold the shift into this addressing mode. Returns false if the\n// transform succeeded.\nstatic bool foldMaskedShiftToScaledMask(SelectionDAG &DAG, SDValue N,\n                                        X86ISelAddressMode &AM) {\n  SDValue Shift = N.getOperand(0);\n\n  // Use a signed mask so that shifting right will insert sign bits. These\n  // bits will be removed when we shift the result left so it doesn't matter\n  // what we use. This might allow a smaller immediate encoding.\n  int64_t Mask = cast<ConstantSDNode>(N->getOperand(1))->getSExtValue();\n\n  // If we have an any_extend feeding the AND, look through it to see if there\n  // is a shift behind it. But only if the AND doesn't use the extended bits.\n  // FIXME: Generalize this to other ANY_EXTEND than i32 to i64?\n  bool FoundAnyExtend = false;\n  if (Shift.getOpcode() == ISD::ANY_EXTEND && Shift.hasOneUse() &&\n      Shift.getOperand(0).getSimpleValueType() == MVT::i32 &&\n      isUInt<32>(Mask)) {\n    FoundAnyExtend = true;\n    Shift = Shift.getOperand(0);\n  }\n\n  if (Shift.getOpcode() != ISD::SHL ||\n      !isa<ConstantSDNode>(Shift.getOperand(1)))\n    return true;\n\n  SDValue X = Shift.getOperand(0);\n\n  // Not likely to be profitable if either the AND or SHIFT node has more\n  // than one use (unless all uses are for address computation). Besides,\n  // isel mechanism requires their node ids to be reused.\n  if (!N.hasOneUse() || !Shift.hasOneUse())\n    return true;\n\n  // Verify that the shift amount is something we can fold.\n  unsigned ShiftAmt = Shift.getConstantOperandVal(1);\n  if (ShiftAmt != 1 && ShiftAmt != 2 && ShiftAmt != 3)\n    return true;\n\n  MVT VT = N.getSimpleValueType();\n  SDLoc DL(N);\n  if (FoundAnyExtend) {\n    SDValue NewX = DAG.getNode(ISD::ANY_EXTEND, DL, VT, X);\n    insertDAGNode(DAG, N, NewX);\n    X = NewX;\n  }\n\n  SDValue NewMask = DAG.getConstant(Mask >> ShiftAmt, DL, VT);\n  SDValue NewAnd = DAG.getNode(ISD::AND, DL, VT, X, NewMask);\n  SDValue NewShift = DAG.getNode(ISD::SHL, DL, VT, NewAnd, Shift.getOperand(1));\n\n  // Insert the new nodes into the topological ordering. We must do this in\n  // a valid topological ordering as nothing is going to go back and re-sort\n  // these nodes. We continually insert before 'N' in sequence as this is\n  // essentially a pre-flattened and pre-sorted sequence of nodes. There is no\n  // hierarchy left to express.\n  insertDAGNode(DAG, N, NewMask);\n  insertDAGNode(DAG, N, NewAnd);\n  insertDAGNode(DAG, N, NewShift);\n  DAG.ReplaceAllUsesWith(N, NewShift);\n  DAG.RemoveDeadNode(N.getNode());\n\n  AM.Scale = 1 << ShiftAmt;\n  AM.IndexReg = NewAnd;\n  return false;\n}\n\n// Implement some heroics to detect shifts of masked values where the mask can\n// be replaced by extending the shift and undoing that in the addressing mode\n// scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and\n// (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in\n// the addressing mode. This results in code such as:\n//\n//   int f(short *y, int *lookup_table) {\n//     ...\n//     return *y + lookup_table[*y >> 11];\n//   }\n//\n// Turning into:\n//   movzwl (%rdi), %eax\n//   movl %eax, %ecx\n//   shrl $11, %ecx\n//   addl (%rsi,%rcx,4), %eax\n//\n// Instead of:\n//   movzwl (%rdi), %eax\n//   movl %eax, %ecx\n//   shrl $9, %ecx\n//   andl $124, %rcx\n//   addl (%rsi,%rcx), %eax\n//\n// Note that this function assumes the mask is provided as a mask *after* the\n// value is shifted. The input chain may or may not match that, but computing\n// such a mask is trivial.\nstatic bool foldMaskAndShiftToScale(SelectionDAG &DAG, SDValue N,\n                                    uint64_t Mask,\n                                    SDValue Shift, SDValue X,\n                                    X86ISelAddressMode &AM) {\n  if (Shift.getOpcode() != ISD::SRL || !Shift.hasOneUse() ||\n      !isa<ConstantSDNode>(Shift.getOperand(1)))\n    return true;\n\n  unsigned ShiftAmt = Shift.getConstantOperandVal(1);\n  unsigned MaskLZ = countLeadingZeros(Mask);\n  unsigned MaskTZ = countTrailingZeros(Mask);\n\n  // The amount of shift we're trying to fit into the addressing mode is taken\n  // from the trailing zeros of the mask.\n  unsigned AMShiftAmt = MaskTZ;\n\n  // There is nothing we can do here unless the mask is removing some bits.\n  // Also, the addressing mode can only represent shifts of 1, 2, or 3 bits.\n  if (AMShiftAmt == 0 || AMShiftAmt > 3) return true;\n\n  // We also need to ensure that mask is a continuous run of bits.\n  if (countTrailingOnes(Mask >> MaskTZ) + MaskTZ + MaskLZ != 64) return true;\n\n  // Scale the leading zero count down based on the actual size of the value.\n  // Also scale it down based on the size of the shift.\n  unsigned ScaleDown = (64 - X.getSimpleValueType().getSizeInBits()) + ShiftAmt;\n  if (MaskLZ < ScaleDown)\n    return true;\n  MaskLZ -= ScaleDown;\n\n  // The final check is to ensure that any masked out high bits of X are\n  // already known to be zero. Otherwise, the mask has a semantic impact\n  // other than masking out a couple of low bits. Unfortunately, because of\n  // the mask, zero extensions will be removed from operands in some cases.\n  // This code works extra hard to look through extensions because we can\n  // replace them with zero extensions cheaply if necessary.\n  bool ReplacingAnyExtend = false;\n  if (X.getOpcode() == ISD::ANY_EXTEND) {\n    unsigned ExtendBits = X.getSimpleValueType().getSizeInBits() -\n                          X.getOperand(0).getSimpleValueType().getSizeInBits();\n    // Assume that we'll replace the any-extend with a zero-extend, and\n    // narrow the search to the extended value.\n    X = X.getOperand(0);\n    MaskLZ = ExtendBits > MaskLZ ? 0 : MaskLZ - ExtendBits;\n    ReplacingAnyExtend = true;\n  }\n  APInt MaskedHighBits =\n    APInt::getHighBitsSet(X.getSimpleValueType().getSizeInBits(), MaskLZ);\n  KnownBits Known = DAG.computeKnownBits(X);\n  if (MaskedHighBits != Known.Zero) return true;\n\n  // We've identified a pattern that can be transformed into a single shift\n  // and an addressing mode. Make it so.\n  MVT VT = N.getSimpleValueType();\n  if (ReplacingAnyExtend) {\n    assert(X.getValueType() != VT);\n    // We looked through an ANY_EXTEND node, insert a ZERO_EXTEND.\n    SDValue NewX = DAG.getNode(ISD::ZERO_EXTEND, SDLoc(X), VT, X);\n    insertDAGNode(DAG, N, NewX);\n    X = NewX;\n  }\n  SDLoc DL(N);\n  SDValue NewSRLAmt = DAG.getConstant(ShiftAmt + AMShiftAmt, DL, MVT::i8);\n  SDValue NewSRL = DAG.getNode(ISD::SRL, DL, VT, X, NewSRLAmt);\n  SDValue NewSHLAmt = DAG.getConstant(AMShiftAmt, DL, MVT::i8);\n  SDValue NewSHL = DAG.getNode(ISD::SHL, DL, VT, NewSRL, NewSHLAmt);\n\n  // Insert the new nodes into the topological ordering. We must do this in\n  // a valid topological ordering as nothing is going to go back and re-sort\n  // these nodes. We continually insert before 'N' in sequence as this is\n  // essentially a pre-flattened and pre-sorted sequence of nodes. There is no\n  // hierarchy left to express.\n  insertDAGNode(DAG, N, NewSRLAmt);\n  insertDAGNode(DAG, N, NewSRL);\n  insertDAGNode(DAG, N, NewSHLAmt);\n  insertDAGNode(DAG, N, NewSHL);\n  DAG.ReplaceAllUsesWith(N, NewSHL);\n  DAG.RemoveDeadNode(N.getNode());\n\n  AM.Scale = 1 << AMShiftAmt;\n  AM.IndexReg = NewSRL;\n  return false;\n}\n\n// Transform \"(X >> SHIFT) & (MASK << C1)\" to\n// \"((X >> (SHIFT + C1)) & (MASK)) << C1\". Everything before the SHL will be\n// matched to a BEXTR later. Returns false if the simplification is performed.\nstatic bool foldMaskedShiftToBEXTR(SelectionDAG &DAG, SDValue N,\n                                   uint64_t Mask,\n                                   SDValue Shift, SDValue X,\n                                   X86ISelAddressMode &AM,\n                                   const X86Subtarget &Subtarget) {\n  if (Shift.getOpcode() != ISD::SRL ||\n      !isa<ConstantSDNode>(Shift.getOperand(1)) ||\n      !Shift.hasOneUse() || !N.hasOneUse())\n    return true;\n\n  // Only do this if BEXTR will be matched by matchBEXTRFromAndImm.\n  if (!Subtarget.hasTBM() &&\n      !(Subtarget.hasBMI() && Subtarget.hasFastBEXTR()))\n    return true;\n\n  // We need to ensure that mask is a continuous run of bits.\n  if (!isShiftedMask_64(Mask)) return true;\n\n  unsigned ShiftAmt = Shift.getConstantOperandVal(1);\n\n  // The amount of shift we're trying to fit into the addressing mode is taken\n  // from the trailing zeros of the mask.\n  unsigned AMShiftAmt = countTrailingZeros(Mask);\n\n  // There is nothing we can do here unless the mask is removing some bits.\n  // Also, the addressing mode can only represent shifts of 1, 2, or 3 bits.\n  if (AMShiftAmt == 0 || AMShiftAmt > 3) return true;\n\n  MVT VT = N.getSimpleValueType();\n  SDLoc DL(N);\n  SDValue NewSRLAmt = DAG.getConstant(ShiftAmt + AMShiftAmt, DL, MVT::i8);\n  SDValue NewSRL = DAG.getNode(ISD::SRL, DL, VT, X, NewSRLAmt);\n  SDValue NewMask = DAG.getConstant(Mask >> AMShiftAmt, DL, VT);\n  SDValue NewAnd = DAG.getNode(ISD::AND, DL, VT, NewSRL, NewMask);\n  SDValue NewSHLAmt = DAG.getConstant(AMShiftAmt, DL, MVT::i8);\n  SDValue NewSHL = DAG.getNode(ISD::SHL, DL, VT, NewAnd, NewSHLAmt);\n\n  // Insert the new nodes into the topological ordering. We must do this in\n  // a valid topological ordering as nothing is going to go back and re-sort\n  // these nodes. We continually insert before 'N' in sequence as this is\n  // essentially a pre-flattened and pre-sorted sequence of nodes. There is no\n  // hierarchy left to express.\n  insertDAGNode(DAG, N, NewSRLAmt);\n  insertDAGNode(DAG, N, NewSRL);\n  insertDAGNode(DAG, N, NewMask);\n  insertDAGNode(DAG, N, NewAnd);\n  insertDAGNode(DAG, N, NewSHLAmt);\n  insertDAGNode(DAG, N, NewSHL);\n  DAG.ReplaceAllUsesWith(N, NewSHL);\n  DAG.RemoveDeadNode(N.getNode());\n\n  AM.Scale = 1 << AMShiftAmt;\n  AM.IndexReg = NewAnd;\n  return false;\n}\n\nbool X86DAGToDAGISel::matchAddressRecursively(SDValue N, X86ISelAddressMode &AM,\n                                              unsigned Depth) {\n  SDLoc dl(N);\n  LLVM_DEBUG({\n    dbgs() << \"MatchAddress: \";\n    AM.dump(CurDAG);\n  });\n  // Limit recursion.\n  if (Depth > 5)\n    return matchAddressBase(N, AM);\n\n  // If this is already a %rip relative address, we can only merge immediates\n  // into it.  Instead of handling this in every case, we handle it here.\n  // RIP relative addressing: %rip + 32-bit displacement!\n  if (AM.isRIPRelative()) {\n    // FIXME: JumpTable and ExternalSymbol address currently don't like\n    // displacements.  It isn't very important, but this should be fixed for\n    // consistency.\n    if (!(AM.ES || AM.MCSym) && AM.JT != -1)\n      return true;\n\n    if (ConstantSDNode *Cst = dyn_cast<ConstantSDNode>(N))\n      if (!foldOffsetIntoAddress(Cst->getSExtValue(), AM))\n        return false;\n    return true;\n  }\n\n  switch (N.getOpcode()) {\n  default: break;\n  case ISD::LOCAL_RECOVER: {\n    if (!AM.hasSymbolicDisplacement() && AM.Disp == 0)\n      if (const auto *ESNode = dyn_cast<MCSymbolSDNode>(N.getOperand(0))) {\n        // Use the symbol and don't prefix it.\n        AM.MCSym = ESNode->getMCSymbol();\n        return false;\n      }\n    break;\n  }\n  case ISD::Constant: {\n    uint64_t Val = cast<ConstantSDNode>(N)->getSExtValue();\n    if (!foldOffsetIntoAddress(Val, AM))\n      return false;\n    break;\n  }\n\n  case X86ISD::Wrapper:\n  case X86ISD::WrapperRIP:\n    if (!matchWrapper(N, AM))\n      return false;\n    break;\n\n  case ISD::LOAD:\n    if (!matchLoadInAddress(cast<LoadSDNode>(N), AM))\n      return false;\n    break;\n\n  case ISD::FrameIndex:\n    if (AM.BaseType == X86ISelAddressMode::RegBase &&\n        AM.Base_Reg.getNode() == nullptr &&\n        (!Subtarget->is64Bit() || isDispSafeForFrameIndex(AM.Disp))) {\n      AM.BaseType = X86ISelAddressMode::FrameIndexBase;\n      AM.Base_FrameIndex = cast<FrameIndexSDNode>(N)->getIndex();\n      return false;\n    }\n    break;\n\n  case ISD::SHL:\n    if (AM.IndexReg.getNode() != nullptr || AM.Scale != 1)\n      break;\n\n    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N.getOperand(1))) {\n      unsigned Val = CN->getZExtValue();\n      // Note that we handle x<<1 as (,x,2) rather than (x,x) here so\n      // that the base operand remains free for further matching. If\n      // the base doesn't end up getting used, a post-processing step\n      // in MatchAddress turns (,x,2) into (x,x), which is cheaper.\n      if (Val == 1 || Val == 2 || Val == 3) {\n        AM.Scale = 1 << Val;\n        SDValue ShVal = N.getOperand(0);\n\n        // Okay, we know that we have a scale by now.  However, if the scaled\n        // value is an add of something and a constant, we can fold the\n        // constant into the disp field here.\n        if (CurDAG->isBaseWithConstantOffset(ShVal)) {\n          AM.IndexReg = ShVal.getOperand(0);\n          ConstantSDNode *AddVal = cast<ConstantSDNode>(ShVal.getOperand(1));\n          uint64_t Disp = (uint64_t)AddVal->getSExtValue() << Val;\n          if (!foldOffsetIntoAddress(Disp, AM))\n            return false;\n        }\n\n        AM.IndexReg = ShVal;\n        return false;\n      }\n    }\n    break;\n\n  case ISD::SRL: {\n    // Scale must not be used already.\n    if (AM.IndexReg.getNode() != nullptr || AM.Scale != 1) break;\n\n    // We only handle up to 64-bit values here as those are what matter for\n    // addressing mode optimizations.\n    assert(N.getSimpleValueType().getSizeInBits() <= 64 &&\n           \"Unexpected value size!\");\n\n    SDValue And = N.getOperand(0);\n    if (And.getOpcode() != ISD::AND) break;\n    SDValue X = And.getOperand(0);\n\n    // The mask used for the transform is expected to be post-shift, but we\n    // found the shift first so just apply the shift to the mask before passing\n    // it down.\n    if (!isa<ConstantSDNode>(N.getOperand(1)) ||\n        !isa<ConstantSDNode>(And.getOperand(1)))\n      break;\n    uint64_t Mask = And.getConstantOperandVal(1) >> N.getConstantOperandVal(1);\n\n    // Try to fold the mask and shift into the scale, and return false if we\n    // succeed.\n    if (!foldMaskAndShiftToScale(*CurDAG, N, Mask, N, X, AM))\n      return false;\n    break;\n  }\n\n  case ISD::SMUL_LOHI:\n  case ISD::UMUL_LOHI:\n    // A mul_lohi where we need the low part can be folded as a plain multiply.\n    if (N.getResNo() != 0) break;\n    LLVM_FALLTHROUGH;\n  case ISD::MUL:\n  case X86ISD::MUL_IMM:\n    // X*[3,5,9] -> X+X*[2,4,8]\n    if (AM.BaseType == X86ISelAddressMode::RegBase &&\n        AM.Base_Reg.getNode() == nullptr &&\n        AM.IndexReg.getNode() == nullptr) {\n      if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N.getOperand(1)))\n        if (CN->getZExtValue() == 3 || CN->getZExtValue() == 5 ||\n            CN->getZExtValue() == 9) {\n          AM.Scale = unsigned(CN->getZExtValue())-1;\n\n          SDValue MulVal = N.getOperand(0);\n          SDValue Reg;\n\n          // Okay, we know that we have a scale by now.  However, if the scaled\n          // value is an add of something and a constant, we can fold the\n          // constant into the disp field here.\n          if (MulVal.getNode()->getOpcode() == ISD::ADD && MulVal.hasOneUse() &&\n              isa<ConstantSDNode>(MulVal.getOperand(1))) {\n            Reg = MulVal.getOperand(0);\n            ConstantSDNode *AddVal =\n              cast<ConstantSDNode>(MulVal.getOperand(1));\n            uint64_t Disp = AddVal->getSExtValue() * CN->getZExtValue();\n            if (foldOffsetIntoAddress(Disp, AM))\n              Reg = N.getOperand(0);\n          } else {\n            Reg = N.getOperand(0);\n          }\n\n          AM.IndexReg = AM.Base_Reg = Reg;\n          return false;\n        }\n    }\n    break;\n\n  case ISD::SUB: {\n    // Given A-B, if A can be completely folded into the address and\n    // the index field with the index field unused, use -B as the index.\n    // This is a win if a has multiple parts that can be folded into\n    // the address. Also, this saves a mov if the base register has\n    // other uses, since it avoids a two-address sub instruction, however\n    // it costs an additional mov if the index register has other uses.\n\n    // Add an artificial use to this node so that we can keep track of\n    // it if it gets CSE'd with a different node.\n    HandleSDNode Handle(N);\n\n    // Test if the LHS of the sub can be folded.\n    X86ISelAddressMode Backup = AM;\n    if (matchAddressRecursively(N.getOperand(0), AM, Depth+1)) {\n      N = Handle.getValue();\n      AM = Backup;\n      break;\n    }\n    N = Handle.getValue();\n    // Test if the index field is free for use.\n    if (AM.IndexReg.getNode() || AM.isRIPRelative()) {\n      AM = Backup;\n      break;\n    }\n\n    int Cost = 0;\n    SDValue RHS = N.getOperand(1);\n    // If the RHS involves a register with multiple uses, this\n    // transformation incurs an extra mov, due to the neg instruction\n    // clobbering its operand.\n    if (!RHS.getNode()->hasOneUse() ||\n        RHS.getNode()->getOpcode() == ISD::CopyFromReg ||\n        RHS.getNode()->getOpcode() == ISD::TRUNCATE ||\n        RHS.getNode()->getOpcode() == ISD::ANY_EXTEND ||\n        (RHS.getNode()->getOpcode() == ISD::ZERO_EXTEND &&\n         RHS.getOperand(0).getValueType() == MVT::i32))\n      ++Cost;\n    // If the base is a register with multiple uses, this\n    // transformation may save a mov.\n    if ((AM.BaseType == X86ISelAddressMode::RegBase && AM.Base_Reg.getNode() &&\n         !AM.Base_Reg.getNode()->hasOneUse()) ||\n        AM.BaseType == X86ISelAddressMode::FrameIndexBase)\n      --Cost;\n    // If the folded LHS was interesting, this transformation saves\n    // address arithmetic.\n    if ((AM.hasSymbolicDisplacement() && !Backup.hasSymbolicDisplacement()) +\n        ((AM.Disp != 0) && (Backup.Disp == 0)) +\n        (AM.Segment.getNode() && !Backup.Segment.getNode()) >= 2)\n      --Cost;\n    // If it doesn't look like it may be an overall win, don't do it.\n    if (Cost >= 0) {\n      AM = Backup;\n      break;\n    }\n\n    // Ok, the transformation is legal and appears profitable. Go for it.\n    // Negation will be emitted later to avoid creating dangling nodes if this\n    // was an unprofitable LEA.\n    AM.IndexReg = RHS;\n    AM.NegateIndex = true;\n    AM.Scale = 1;\n    return false;\n  }\n\n  case ISD::ADD:\n    if (!matchAdd(N, AM, Depth))\n      return false;\n    break;\n\n  case ISD::OR:\n    // We want to look through a transform in InstCombine and DAGCombiner that\n    // turns 'add' into 'or', so we can treat this 'or' exactly like an 'add'.\n    // Example: (or (and x, 1), (shl y, 3)) --> (add (and x, 1), (shl y, 3))\n    // An 'lea' can then be used to match the shift (multiply) and add:\n    // and $1, %esi\n    // lea (%rsi, %rdi, 8), %rax\n    if (CurDAG->haveNoCommonBitsSet(N.getOperand(0), N.getOperand(1)) &&\n        !matchAdd(N, AM, Depth))\n      return false;\n    break;\n\n  case ISD::AND: {\n    // Perform some heroic transforms on an and of a constant-count shift\n    // with a constant to enable use of the scaled offset field.\n\n    // Scale must not be used already.\n    if (AM.IndexReg.getNode() != nullptr || AM.Scale != 1) break;\n\n    // We only handle up to 64-bit values here as those are what matter for\n    // addressing mode optimizations.\n    assert(N.getSimpleValueType().getSizeInBits() <= 64 &&\n           \"Unexpected value size!\");\n\n    if (!isa<ConstantSDNode>(N.getOperand(1)))\n      break;\n\n    if (N.getOperand(0).getOpcode() == ISD::SRL) {\n      SDValue Shift = N.getOperand(0);\n      SDValue X = Shift.getOperand(0);\n\n      uint64_t Mask = N.getConstantOperandVal(1);\n\n      // Try to fold the mask and shift into an extract and scale.\n      if (!foldMaskAndShiftToExtract(*CurDAG, N, Mask, Shift, X, AM))\n        return false;\n\n      // Try to fold the mask and shift directly into the scale.\n      if (!foldMaskAndShiftToScale(*CurDAG, N, Mask, Shift, X, AM))\n        return false;\n\n      // Try to fold the mask and shift into BEXTR and scale.\n      if (!foldMaskedShiftToBEXTR(*CurDAG, N, Mask, Shift, X, AM, *Subtarget))\n        return false;\n    }\n\n    // Try to swap the mask and shift to place shifts which can be done as\n    // a scale on the outside of the mask.\n    if (!foldMaskedShiftToScaledMask(*CurDAG, N, AM))\n      return false;\n\n    break;\n  }\n  case ISD::ZERO_EXTEND: {\n    // Try to widen a zexted shift left to the same size as its use, so we can\n    // match the shift as a scale factor.\n    if (AM.IndexReg.getNode() != nullptr || AM.Scale != 1)\n      break;\n    if (N.getOperand(0).getOpcode() != ISD::SHL || !N.getOperand(0).hasOneUse())\n      break;\n\n    // Give up if the shift is not a valid scale factor [1,2,3].\n    SDValue Shl = N.getOperand(0);\n    auto *ShAmtC = dyn_cast<ConstantSDNode>(Shl.getOperand(1));\n    if (!ShAmtC || ShAmtC->getZExtValue() > 3)\n      break;\n\n    // The narrow shift must only shift out zero bits (it must be 'nuw').\n    // That makes it safe to widen to the destination type.\n    APInt HighZeros = APInt::getHighBitsSet(Shl.getValueSizeInBits(),\n                                            ShAmtC->getZExtValue());\n    if (!CurDAG->MaskedValueIsZero(Shl.getOperand(0), HighZeros))\n      break;\n\n    // zext (shl nuw i8 %x, C) to i32 --> shl (zext i8 %x to i32), (zext C)\n    MVT VT = N.getSimpleValueType();\n    SDLoc DL(N);\n    SDValue Zext = CurDAG->getNode(ISD::ZERO_EXTEND, DL, VT, Shl.getOperand(0));\n    SDValue NewShl = CurDAG->getNode(ISD::SHL, DL, VT, Zext, Shl.getOperand(1));\n\n    // Convert the shift to scale factor.\n    AM.Scale = 1 << ShAmtC->getZExtValue();\n    AM.IndexReg = Zext;\n\n    insertDAGNode(*CurDAG, N, Zext);\n    insertDAGNode(*CurDAG, N, NewShl);\n    CurDAG->ReplaceAllUsesWith(N, NewShl);\n    CurDAG->RemoveDeadNode(N.getNode());\n    return false;\n  }\n  }\n\n  return matchAddressBase(N, AM);\n}\n\n/// Helper for MatchAddress. Add the specified node to the\n/// specified addressing mode without any further recursion.\nbool X86DAGToDAGISel::matchAddressBase(SDValue N, X86ISelAddressMode &AM) {\n  // Is the base register already occupied?\n  if (AM.BaseType != X86ISelAddressMode::RegBase || AM.Base_Reg.getNode()) {\n    // If so, check to see if the scale index register is set.\n    if (!AM.IndexReg.getNode()) {\n      AM.IndexReg = N;\n      AM.Scale = 1;\n      return false;\n    }\n\n    // Otherwise, we cannot select it.\n    return true;\n  }\n\n  // Default, generate it as a register.\n  AM.BaseType = X86ISelAddressMode::RegBase;\n  AM.Base_Reg = N;\n  return false;\n}\n\n/// Helper for selectVectorAddr. Handles things that can be folded into a\n/// gather scatter address. The index register and scale should have already\n/// been handled.\nbool X86DAGToDAGISel::matchVectorAddress(SDValue N, X86ISelAddressMode &AM) {\n  // TODO: Support other operations.\n  switch (N.getOpcode()) {\n  case ISD::Constant: {\n    uint64_t Val = cast<ConstantSDNode>(N)->getSExtValue();\n    if (!foldOffsetIntoAddress(Val, AM))\n      return false;\n    break;\n  }\n  case X86ISD::Wrapper:\n    if (!matchWrapper(N, AM))\n      return false;\n    break;\n  }\n\n  return matchAddressBase(N, AM);\n}\n\nbool X86DAGToDAGISel::selectVectorAddr(MemSDNode *Parent, SDValue BasePtr,\n                                       SDValue IndexOp, SDValue ScaleOp,\n                                       SDValue &Base, SDValue &Scale,\n                                       SDValue &Index, SDValue &Disp,\n                                       SDValue &Segment) {\n  X86ISelAddressMode AM;\n  AM.IndexReg = IndexOp;\n  AM.Scale = cast<ConstantSDNode>(ScaleOp)->getZExtValue();\n\n  unsigned AddrSpace = Parent->getPointerInfo().getAddrSpace();\n  if (AddrSpace == X86AS::GS)\n    AM.Segment = CurDAG->getRegister(X86::GS, MVT::i16);\n  if (AddrSpace == X86AS::FS)\n    AM.Segment = CurDAG->getRegister(X86::FS, MVT::i16);\n  if (AddrSpace == X86AS::SS)\n    AM.Segment = CurDAG->getRegister(X86::SS, MVT::i16);\n\n  SDLoc DL(BasePtr);\n  MVT VT = BasePtr.getSimpleValueType();\n\n  // Try to match into the base and displacement fields.\n  if (matchVectorAddress(BasePtr, AM))\n    return false;\n\n  getAddressOperands(AM, DL, VT, Base, Scale, Index, Disp, Segment);\n  return true;\n}\n\n/// Returns true if it is able to pattern match an addressing mode.\n/// It returns the operands which make up the maximal addressing mode it can\n/// match by reference.\n///\n/// Parent is the parent node of the addr operand that is being matched.  It\n/// is always a load, store, atomic node, or null.  It is only null when\n/// checking memory operands for inline asm nodes.\nbool X86DAGToDAGISel::selectAddr(SDNode *Parent, SDValue N, SDValue &Base,\n                                 SDValue &Scale, SDValue &Index,\n                                 SDValue &Disp, SDValue &Segment) {\n  X86ISelAddressMode AM;\n\n  if (Parent &&\n      // This list of opcodes are all the nodes that have an \"addr:$ptr\" operand\n      // that are not a MemSDNode, and thus don't have proper addrspace info.\n      Parent->getOpcode() != ISD::INTRINSIC_W_CHAIN && // unaligned loads, fixme\n      Parent->getOpcode() != ISD::INTRINSIC_VOID && // nontemporal stores\n      Parent->getOpcode() != X86ISD::TLSCALL && // Fixme\n      Parent->getOpcode() != X86ISD::ENQCMD && // Fixme\n      Parent->getOpcode() != X86ISD::ENQCMDS && // Fixme\n      Parent->getOpcode() != X86ISD::EH_SJLJ_SETJMP && // setjmp\n      Parent->getOpcode() != X86ISD::EH_SJLJ_LONGJMP) { // longjmp\n    unsigned AddrSpace =\n      cast<MemSDNode>(Parent)->getPointerInfo().getAddrSpace();\n    if (AddrSpace == X86AS::GS)\n      AM.Segment = CurDAG->getRegister(X86::GS, MVT::i16);\n    if (AddrSpace == X86AS::FS)\n      AM.Segment = CurDAG->getRegister(X86::FS, MVT::i16);\n    if (AddrSpace == X86AS::SS)\n      AM.Segment = CurDAG->getRegister(X86::SS, MVT::i16);\n  }\n\n  // Save the DL and VT before calling matchAddress, it can invalidate N.\n  SDLoc DL(N);\n  MVT VT = N.getSimpleValueType();\n\n  if (matchAddress(N, AM))\n    return false;\n\n  getAddressOperands(AM, DL, VT, Base, Scale, Index, Disp, Segment);\n  return true;\n}\n\nbool X86DAGToDAGISel::selectMOV64Imm32(SDValue N, SDValue &Imm) {\n  // In static codegen with small code model, we can get the address of a label\n  // into a register with 'movl'\n  if (N->getOpcode() != X86ISD::Wrapper)\n    return false;\n\n  N = N.getOperand(0);\n\n  // At least GNU as does not accept 'movl' for TPOFF relocations.\n  // FIXME: We could use 'movl' when we know we are targeting MC.\n  if (N->getOpcode() == ISD::TargetGlobalTLSAddress)\n    return false;\n\n  Imm = N;\n  if (N->getOpcode() != ISD::TargetGlobalAddress)\n    return TM.getCodeModel() == CodeModel::Small;\n\n  Optional<ConstantRange> CR =\n      cast<GlobalAddressSDNode>(N)->getGlobal()->getAbsoluteSymbolRange();\n  if (!CR)\n    return TM.getCodeModel() == CodeModel::Small;\n\n  return CR->getUnsignedMax().ult(1ull << 32);\n}\n\nbool X86DAGToDAGISel::selectLEA64_32Addr(SDValue N, SDValue &Base,\n                                         SDValue &Scale, SDValue &Index,\n                                         SDValue &Disp, SDValue &Segment) {\n  // Save the debug loc before calling selectLEAAddr, in case it invalidates N.\n  SDLoc DL(N);\n\n  if (!selectLEAAddr(N, Base, Scale, Index, Disp, Segment))\n    return false;\n\n  RegisterSDNode *RN = dyn_cast<RegisterSDNode>(Base);\n  if (RN && RN->getReg() == 0)\n    Base = CurDAG->getRegister(0, MVT::i64);\n  else if (Base.getValueType() == MVT::i32 && !isa<FrameIndexSDNode>(Base)) {\n    // Base could already be %rip, particularly in the x32 ABI.\n    SDValue ImplDef = SDValue(CurDAG->getMachineNode(X86::IMPLICIT_DEF, DL,\n                                                     MVT::i64), 0);\n    Base = CurDAG->getTargetInsertSubreg(X86::sub_32bit, DL, MVT::i64, ImplDef,\n                                         Base);\n  }\n\n  RN = dyn_cast<RegisterSDNode>(Index);\n  if (RN && RN->getReg() == 0)\n    Index = CurDAG->getRegister(0, MVT::i64);\n  else {\n    assert(Index.getValueType() == MVT::i32 &&\n           \"Expect to be extending 32-bit registers for use in LEA\");\n    SDValue ImplDef = SDValue(CurDAG->getMachineNode(X86::IMPLICIT_DEF, DL,\n                                                     MVT::i64), 0);\n    Index = CurDAG->getTargetInsertSubreg(X86::sub_32bit, DL, MVT::i64, ImplDef,\n                                          Index);\n  }\n\n  return true;\n}\n\n/// Calls SelectAddr and determines if the maximal addressing\n/// mode it matches can be cost effectively emitted as an LEA instruction.\nbool X86DAGToDAGISel::selectLEAAddr(SDValue N,\n                                    SDValue &Base, SDValue &Scale,\n                                    SDValue &Index, SDValue &Disp,\n                                    SDValue &Segment) {\n  X86ISelAddressMode AM;\n\n  // Save the DL and VT before calling matchAddress, it can invalidate N.\n  SDLoc DL(N);\n  MVT VT = N.getSimpleValueType();\n\n  // Set AM.Segment to prevent MatchAddress from using one. LEA doesn't support\n  // segments.\n  SDValue Copy = AM.Segment;\n  SDValue T = CurDAG->getRegister(0, MVT::i32);\n  AM.Segment = T;\n  if (matchAddress(N, AM))\n    return false;\n  assert (T == AM.Segment);\n  AM.Segment = Copy;\n\n  unsigned Complexity = 0;\n  if (AM.BaseType == X86ISelAddressMode::RegBase && AM.Base_Reg.getNode())\n    Complexity = 1;\n  else if (AM.BaseType == X86ISelAddressMode::FrameIndexBase)\n    Complexity = 4;\n\n  if (AM.IndexReg.getNode())\n    Complexity++;\n\n  // Don't match just leal(,%reg,2). It's cheaper to do addl %reg, %reg, or with\n  // a simple shift.\n  if (AM.Scale > 1)\n    Complexity++;\n\n  // FIXME: We are artificially lowering the criteria to turn ADD %reg, $GA\n  // to a LEA. This is determined with some experimentation but is by no means\n  // optimal (especially for code size consideration). LEA is nice because of\n  // its three-address nature. Tweak the cost function again when we can run\n  // convertToThreeAddress() at register allocation time.\n  if (AM.hasSymbolicDisplacement()) {\n    // For X86-64, always use LEA to materialize RIP-relative addresses.\n    if (Subtarget->is64Bit())\n      Complexity = 4;\n    else\n      Complexity += 2;\n  }\n\n  // Heuristic: try harder to form an LEA from ADD if the operands set flags.\n  // Unlike ADD, LEA does not affect flags, so we will be less likely to require\n  // duplicating flag-producing instructions later in the pipeline.\n  if (N.getOpcode() == ISD::ADD) {\n    auto isMathWithFlags = [](SDValue V) {\n      switch (V.getOpcode()) {\n      case X86ISD::ADD:\n      case X86ISD::SUB:\n      case X86ISD::ADC:\n      case X86ISD::SBB:\n      /* TODO: These opcodes can be added safely, but we may want to justify\n               their inclusion for different reasons (better for reg-alloc).\n      case X86ISD::SMUL:\n      case X86ISD::UMUL:\n      case X86ISD::OR:\n      case X86ISD::XOR:\n      case X86ISD::AND:\n      */\n        // Value 1 is the flag output of the node - verify it's not dead.\n        return !SDValue(V.getNode(), 1).use_empty();\n      default:\n        return false;\n      }\n    };\n    // TODO: This could be an 'or' rather than 'and' to make the transform more\n    //       likely to happen. We might want to factor in whether there's a\n    //       load folding opportunity for the math op that disappears with LEA.\n    if (isMathWithFlags(N.getOperand(0)) && isMathWithFlags(N.getOperand(1)))\n      Complexity++;\n  }\n\n  if (AM.Disp)\n    Complexity++;\n\n  // If it isn't worth using an LEA, reject it.\n  if (Complexity <= 2)\n    return false;\n\n  getAddressOperands(AM, DL, VT, Base, Scale, Index, Disp, Segment);\n  return true;\n}\n\n/// This is only run on TargetGlobalTLSAddress nodes.\nbool X86DAGToDAGISel::selectTLSADDRAddr(SDValue N, SDValue &Base,\n                                        SDValue &Scale, SDValue &Index,\n                                        SDValue &Disp, SDValue &Segment) {\n  assert(N.getOpcode() == ISD::TargetGlobalTLSAddress);\n  const GlobalAddressSDNode *GA = cast<GlobalAddressSDNode>(N);\n\n  X86ISelAddressMode AM;\n  AM.GV = GA->getGlobal();\n  AM.Disp += GA->getOffset();\n  AM.SymbolFlags = GA->getTargetFlags();\n\n  if (Subtarget->is32Bit()) {\n    AM.Scale = 1;\n    AM.IndexReg = CurDAG->getRegister(X86::EBX, MVT::i32);\n  }\n\n  MVT VT = N.getSimpleValueType();\n  getAddressOperands(AM, SDLoc(N), VT, Base, Scale, Index, Disp, Segment);\n  return true;\n}\n\nbool X86DAGToDAGISel::selectRelocImm(SDValue N, SDValue &Op) {\n  // Keep track of the original value type and whether this value was\n  // truncated. If we see a truncation from pointer type to VT that truncates\n  // bits that are known to be zero, we can use a narrow reference.\n  EVT VT = N.getValueType();\n  bool WasTruncated = false;\n  if (N.getOpcode() == ISD::TRUNCATE) {\n    WasTruncated = true;\n    N = N.getOperand(0);\n  }\n\n  if (N.getOpcode() != X86ISD::Wrapper)\n    return false;\n\n  // We can only use non-GlobalValues as immediates if they were not truncated,\n  // as we do not have any range information. If we have a GlobalValue and the\n  // address was not truncated, we can select it as an operand directly.\n  unsigned Opc = N.getOperand(0)->getOpcode();\n  if (Opc != ISD::TargetGlobalAddress || !WasTruncated) {\n    Op = N.getOperand(0);\n    // We can only select the operand directly if we didn't have to look past a\n    // truncate.\n    return !WasTruncated;\n  }\n\n  // Check that the global's range fits into VT.\n  auto *GA = cast<GlobalAddressSDNode>(N.getOperand(0));\n  Optional<ConstantRange> CR = GA->getGlobal()->getAbsoluteSymbolRange();\n  if (!CR || CR->getUnsignedMax().uge(1ull << VT.getSizeInBits()))\n    return false;\n\n  // Okay, we can use a narrow reference.\n  Op = CurDAG->getTargetGlobalAddress(GA->getGlobal(), SDLoc(N), VT,\n                                      GA->getOffset(), GA->getTargetFlags());\n  return true;\n}\n\nbool X86DAGToDAGISel::tryFoldLoad(SDNode *Root, SDNode *P, SDValue N,\n                                  SDValue &Base, SDValue &Scale,\n                                  SDValue &Index, SDValue &Disp,\n                                  SDValue &Segment) {\n  assert(Root && P && \"Unknown root/parent nodes\");\n  if (!ISD::isNON_EXTLoad(N.getNode()) ||\n      !IsProfitableToFold(N, P, Root) ||\n      !IsLegalToFold(N, P, Root, OptLevel))\n    return false;\n\n  return selectAddr(N.getNode(),\n                    N.getOperand(1), Base, Scale, Index, Disp, Segment);\n}\n\nbool X86DAGToDAGISel::tryFoldBroadcast(SDNode *Root, SDNode *P, SDValue N,\n                                       SDValue &Base, SDValue &Scale,\n                                       SDValue &Index, SDValue &Disp,\n                                       SDValue &Segment) {\n  assert(Root && P && \"Unknown root/parent nodes\");\n  if (N->getOpcode() != X86ISD::VBROADCAST_LOAD ||\n      !IsProfitableToFold(N, P, Root) ||\n      !IsLegalToFold(N, P, Root, OptLevel))\n    return false;\n\n  return selectAddr(N.getNode(),\n                    N.getOperand(1), Base, Scale, Index, Disp, Segment);\n}\n\n/// Return an SDNode that returns the value of the global base register.\n/// Output instructions required to initialize the global base register,\n/// if necessary.\nSDNode *X86DAGToDAGISel::getGlobalBaseReg() {\n  unsigned GlobalBaseReg = getInstrInfo()->getGlobalBaseReg(MF);\n  auto &DL = MF->getDataLayout();\n  return CurDAG->getRegister(GlobalBaseReg, TLI->getPointerTy(DL)).getNode();\n}\n\nbool X86DAGToDAGISel::isSExtAbsoluteSymbolRef(unsigned Width, SDNode *N) const {\n  if (N->getOpcode() == ISD::TRUNCATE)\n    N = N->getOperand(0).getNode();\n  if (N->getOpcode() != X86ISD::Wrapper)\n    return false;\n\n  auto *GA = dyn_cast<GlobalAddressSDNode>(N->getOperand(0));\n  if (!GA)\n    return false;\n\n  Optional<ConstantRange> CR = GA->getGlobal()->getAbsoluteSymbolRange();\n  if (!CR)\n    return Width == 32 && TM.getCodeModel() == CodeModel::Small;\n\n  return CR->getSignedMin().sge(-1ull << Width) &&\n         CR->getSignedMax().slt(1ull << Width);\n}\n\nstatic X86::CondCode getCondFromNode(SDNode *N) {\n  assert(N->isMachineOpcode() && \"Unexpected node\");\n  X86::CondCode CC = X86::COND_INVALID;\n  unsigned Opc = N->getMachineOpcode();\n  if (Opc == X86::JCC_1)\n    CC = static_cast<X86::CondCode>(N->getConstantOperandVal(1));\n  else if (Opc == X86::SETCCr)\n    CC = static_cast<X86::CondCode>(N->getConstantOperandVal(0));\n  else if (Opc == X86::SETCCm)\n    CC = static_cast<X86::CondCode>(N->getConstantOperandVal(5));\n  else if (Opc == X86::CMOV16rr || Opc == X86::CMOV32rr ||\n           Opc == X86::CMOV64rr)\n    CC = static_cast<X86::CondCode>(N->getConstantOperandVal(2));\n  else if (Opc == X86::CMOV16rm || Opc == X86::CMOV32rm ||\n           Opc == X86::CMOV64rm)\n    CC = static_cast<X86::CondCode>(N->getConstantOperandVal(6));\n\n  return CC;\n}\n\n/// Test whether the given X86ISD::CMP node has any users that use a flag\n/// other than ZF.\nbool X86DAGToDAGISel::onlyUsesZeroFlag(SDValue Flags) const {\n  // Examine each user of the node.\n  for (SDNode::use_iterator UI = Flags->use_begin(), UE = Flags->use_end();\n         UI != UE; ++UI) {\n    // Only check things that use the flags.\n    if (UI.getUse().getResNo() != Flags.getResNo())\n      continue;\n    // Only examine CopyToReg uses that copy to EFLAGS.\n    if (UI->getOpcode() != ISD::CopyToReg ||\n        cast<RegisterSDNode>(UI->getOperand(1))->getReg() != X86::EFLAGS)\n      return false;\n    // Examine each user of the CopyToReg use.\n    for (SDNode::use_iterator FlagUI = UI->use_begin(),\n           FlagUE = UI->use_end(); FlagUI != FlagUE; ++FlagUI) {\n      // Only examine the Flag result.\n      if (FlagUI.getUse().getResNo() != 1) continue;\n      // Anything unusual: assume conservatively.\n      if (!FlagUI->isMachineOpcode()) return false;\n      // Examine the condition code of the user.\n      X86::CondCode CC = getCondFromNode(*FlagUI);\n\n      switch (CC) {\n      // Comparisons which only use the zero flag.\n      case X86::COND_E: case X86::COND_NE:\n        continue;\n      // Anything else: assume conservatively.\n      default:\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/// Test whether the given X86ISD::CMP node has any uses which require the SF\n/// flag to be accurate.\nbool X86DAGToDAGISel::hasNoSignFlagUses(SDValue Flags) const {\n  // Examine each user of the node.\n  for (SDNode::use_iterator UI = Flags->use_begin(), UE = Flags->use_end();\n         UI != UE; ++UI) {\n    // Only check things that use the flags.\n    if (UI.getUse().getResNo() != Flags.getResNo())\n      continue;\n    // Only examine CopyToReg uses that copy to EFLAGS.\n    if (UI->getOpcode() != ISD::CopyToReg ||\n        cast<RegisterSDNode>(UI->getOperand(1))->getReg() != X86::EFLAGS)\n      return false;\n    // Examine each user of the CopyToReg use.\n    for (SDNode::use_iterator FlagUI = UI->use_begin(),\n           FlagUE = UI->use_end(); FlagUI != FlagUE; ++FlagUI) {\n      // Only examine the Flag result.\n      if (FlagUI.getUse().getResNo() != 1) continue;\n      // Anything unusual: assume conservatively.\n      if (!FlagUI->isMachineOpcode()) return false;\n      // Examine the condition code of the user.\n      X86::CondCode CC = getCondFromNode(*FlagUI);\n\n      switch (CC) {\n      // Comparisons which don't examine the SF flag.\n      case X86::COND_A: case X86::COND_AE:\n      case X86::COND_B: case X86::COND_BE:\n      case X86::COND_E: case X86::COND_NE:\n      case X86::COND_O: case X86::COND_NO:\n      case X86::COND_P: case X86::COND_NP:\n        continue;\n      // Anything else: assume conservatively.\n      default:\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nstatic bool mayUseCarryFlag(X86::CondCode CC) {\n  switch (CC) {\n  // Comparisons which don't examine the CF flag.\n  case X86::COND_O: case X86::COND_NO:\n  case X86::COND_E: case X86::COND_NE:\n  case X86::COND_S: case X86::COND_NS:\n  case X86::COND_P: case X86::COND_NP:\n  case X86::COND_L: case X86::COND_GE:\n  case X86::COND_G: case X86::COND_LE:\n    return false;\n  // Anything else: assume conservatively.\n  default:\n    return true;\n  }\n}\n\n/// Test whether the given node which sets flags has any uses which require the\n/// CF flag to be accurate.\n bool X86DAGToDAGISel::hasNoCarryFlagUses(SDValue Flags) const {\n  // Examine each user of the node.\n  for (SDNode::use_iterator UI = Flags->use_begin(), UE = Flags->use_end();\n         UI != UE; ++UI) {\n    // Only check things that use the flags.\n    if (UI.getUse().getResNo() != Flags.getResNo())\n      continue;\n\n    unsigned UIOpc = UI->getOpcode();\n\n    if (UIOpc == ISD::CopyToReg) {\n      // Only examine CopyToReg uses that copy to EFLAGS.\n      if (cast<RegisterSDNode>(UI->getOperand(1))->getReg() != X86::EFLAGS)\n        return false;\n      // Examine each user of the CopyToReg use.\n      for (SDNode::use_iterator FlagUI = UI->use_begin(), FlagUE = UI->use_end();\n           FlagUI != FlagUE; ++FlagUI) {\n        // Only examine the Flag result.\n        if (FlagUI.getUse().getResNo() != 1)\n          continue;\n        // Anything unusual: assume conservatively.\n        if (!FlagUI->isMachineOpcode())\n          return false;\n        // Examine the condition code of the user.\n        X86::CondCode CC = getCondFromNode(*FlagUI);\n\n        if (mayUseCarryFlag(CC))\n          return false;\n      }\n\n      // This CopyToReg is ok. Move on to the next user.\n      continue;\n    }\n\n    // This might be an unselected node. So look for the pre-isel opcodes that\n    // use flags.\n    unsigned CCOpNo;\n    switch (UIOpc) {\n    default:\n      // Something unusual. Be conservative.\n      return false;\n    case X86ISD::SETCC:       CCOpNo = 0; break;\n    case X86ISD::SETCC_CARRY: CCOpNo = 0; break;\n    case X86ISD::CMOV:        CCOpNo = 2; break;\n    case X86ISD::BRCOND:      CCOpNo = 2; break;\n    }\n\n    X86::CondCode CC = (X86::CondCode)UI->getConstantOperandVal(CCOpNo);\n    if (mayUseCarryFlag(CC))\n      return false;\n  }\n  return true;\n}\n\n/// Check whether or not the chain ending in StoreNode is suitable for doing\n/// the {load; op; store} to modify transformation.\nstatic bool isFusableLoadOpStorePattern(StoreSDNode *StoreNode,\n                                        SDValue StoredVal, SelectionDAG *CurDAG,\n                                        unsigned LoadOpNo,\n                                        LoadSDNode *&LoadNode,\n                                        SDValue &InputChain) {\n  // Is the stored value result 0 of the operation?\n  if (StoredVal.getResNo() != 0) return false;\n\n  // Are there other uses of the operation other than the store?\n  if (!StoredVal.getNode()->hasNUsesOfValue(1, 0)) return false;\n\n  // Is the store non-extending and non-indexed?\n  if (!ISD::isNormalStore(StoreNode) || StoreNode->isNonTemporal())\n    return false;\n\n  SDValue Load = StoredVal->getOperand(LoadOpNo);\n  // Is the stored value a non-extending and non-indexed load?\n  if (!ISD::isNormalLoad(Load.getNode())) return false;\n\n  // Return LoadNode by reference.\n  LoadNode = cast<LoadSDNode>(Load);\n\n  // Is store the only read of the loaded value?\n  if (!Load.hasOneUse())\n    return false;\n\n  // Is the address of the store the same as the load?\n  if (LoadNode->getBasePtr() != StoreNode->getBasePtr() ||\n      LoadNode->getOffset() != StoreNode->getOffset())\n    return false;\n\n  bool FoundLoad = false;\n  SmallVector<SDValue, 4> ChainOps;\n  SmallVector<const SDNode *, 4> LoopWorklist;\n  SmallPtrSet<const SDNode *, 16> Visited;\n  const unsigned int Max = 1024;\n\n  //  Visualization of Load-Op-Store fusion:\n  // -------------------------\n  // Legend:\n  //    *-lines = Chain operand dependencies.\n  //    |-lines = Normal operand dependencies.\n  //    Dependencies flow down and right. n-suffix references multiple nodes.\n  //\n  //        C                        Xn  C\n  //        *                         *  *\n  //        *                          * *\n  //  Xn  A-LD    Yn                    TF         Yn\n  //   *    * \\   |                       *        |\n  //    *   *  \\  |                        *       |\n  //     *  *   \\ |             =>       A--LD_OP_ST\n  //      * *    \\|                                 \\\n  //       TF    OP                                  \\\n  //         *   | \\                                  Zn\n  //          *  |  \\\n  //         A-ST    Zn\n  //\n\n  // This merge induced dependences from: #1: Xn -> LD, OP, Zn\n  //                                      #2: Yn -> LD\n  //                                      #3: ST -> Zn\n\n  // Ensure the transform is safe by checking for the dual\n  // dependencies to make sure we do not induce a loop.\n\n  // As LD is a predecessor to both OP and ST we can do this by checking:\n  //  a). if LD is a predecessor to a member of Xn or Yn.\n  //  b). if a Zn is a predecessor to ST.\n\n  // However, (b) can only occur through being a chain predecessor to\n  // ST, which is the same as Zn being a member or predecessor of Xn,\n  // which is a subset of LD being a predecessor of Xn. So it's\n  // subsumed by check (a).\n\n  SDValue Chain = StoreNode->getChain();\n\n  // Gather X elements in ChainOps.\n  if (Chain == Load.getValue(1)) {\n    FoundLoad = true;\n    ChainOps.push_back(Load.getOperand(0));\n  } else if (Chain.getOpcode() == ISD::TokenFactor) {\n    for (unsigned i = 0, e = Chain.getNumOperands(); i != e; ++i) {\n      SDValue Op = Chain.getOperand(i);\n      if (Op == Load.getValue(1)) {\n        FoundLoad = true;\n        // Drop Load, but keep its chain. No cycle check necessary.\n        ChainOps.push_back(Load.getOperand(0));\n        continue;\n      }\n      LoopWorklist.push_back(Op.getNode());\n      ChainOps.push_back(Op);\n    }\n  }\n\n  if (!FoundLoad)\n    return false;\n\n  // Worklist is currently Xn. Add Yn to worklist.\n  for (SDValue Op : StoredVal->ops())\n    if (Op.getNode() != LoadNode)\n      LoopWorklist.push_back(Op.getNode());\n\n  // Check (a) if Load is a predecessor to Xn + Yn\n  if (SDNode::hasPredecessorHelper(Load.getNode(), Visited, LoopWorklist, Max,\n                                   true))\n    return false;\n\n  InputChain =\n      CurDAG->getNode(ISD::TokenFactor, SDLoc(Chain), MVT::Other, ChainOps);\n  return true;\n}\n\n// Change a chain of {load; op; store} of the same value into a simple op\n// through memory of that value, if the uses of the modified value and its\n// address are suitable.\n//\n// The tablegen pattern memory operand pattern is currently not able to match\n// the case where the EFLAGS on the original operation are used.\n//\n// To move this to tablegen, we'll need to improve tablegen to allow flags to\n// be transferred from a node in the pattern to the result node, probably with\n// a new keyword. For example, we have this\n// def DEC64m : RI<0xFF, MRM1m, (outs), (ins i64mem:$dst), \"dec{q}\\t$dst\",\n//  [(store (add (loadi64 addr:$dst), -1), addr:$dst),\n//   (implicit EFLAGS)]>;\n// but maybe need something like this\n// def DEC64m : RI<0xFF, MRM1m, (outs), (ins i64mem:$dst), \"dec{q}\\t$dst\",\n//  [(store (add (loadi64 addr:$dst), -1), addr:$dst),\n//   (transferrable EFLAGS)]>;\n//\n// Until then, we manually fold these and instruction select the operation\n// here.\nbool X86DAGToDAGISel::foldLoadStoreIntoMemOperand(SDNode *Node) {\n  StoreSDNode *StoreNode = cast<StoreSDNode>(Node);\n  SDValue StoredVal = StoreNode->getOperand(1);\n  unsigned Opc = StoredVal->getOpcode();\n\n  // Before we try to select anything, make sure this is memory operand size\n  // and opcode we can handle. Note that this must match the code below that\n  // actually lowers the opcodes.\n  EVT MemVT = StoreNode->getMemoryVT();\n  if (MemVT != MVT::i64 && MemVT != MVT::i32 && MemVT != MVT::i16 &&\n      MemVT != MVT::i8)\n    return false;\n\n  bool IsCommutable = false;\n  bool IsNegate = false;\n  switch (Opc) {\n  default:\n    return false;\n  case X86ISD::SUB:\n    IsNegate = isNullConstant(StoredVal.getOperand(0));\n    break;\n  case X86ISD::SBB:\n    break;\n  case X86ISD::ADD:\n  case X86ISD::ADC:\n  case X86ISD::AND:\n  case X86ISD::OR:\n  case X86ISD::XOR:\n    IsCommutable = true;\n    break;\n  }\n\n  unsigned LoadOpNo = IsNegate ? 1 : 0;\n  LoadSDNode *LoadNode = nullptr;\n  SDValue InputChain;\n  if (!isFusableLoadOpStorePattern(StoreNode, StoredVal, CurDAG, LoadOpNo,\n                                   LoadNode, InputChain)) {\n    if (!IsCommutable)\n      return false;\n\n    // This operation is commutable, try the other operand.\n    LoadOpNo = 1;\n    if (!isFusableLoadOpStorePattern(StoreNode, StoredVal, CurDAG, LoadOpNo,\n                                     LoadNode, InputChain))\n      return false;\n  }\n\n  SDValue Base, Scale, Index, Disp, Segment;\n  if (!selectAddr(LoadNode, LoadNode->getBasePtr(), Base, Scale, Index, Disp,\n                  Segment))\n    return false;\n\n  auto SelectOpcode = [&](unsigned Opc64, unsigned Opc32, unsigned Opc16,\n                          unsigned Opc8) {\n    switch (MemVT.getSimpleVT().SimpleTy) {\n    case MVT::i64:\n      return Opc64;\n    case MVT::i32:\n      return Opc32;\n    case MVT::i16:\n      return Opc16;\n    case MVT::i8:\n      return Opc8;\n    default:\n      llvm_unreachable(\"Invalid size!\");\n    }\n  };\n\n  MachineSDNode *Result;\n  switch (Opc) {\n  case X86ISD::SUB:\n    // Handle negate.\n    if (IsNegate) {\n      unsigned NewOpc = SelectOpcode(X86::NEG64m, X86::NEG32m, X86::NEG16m,\n                                     X86::NEG8m);\n      const SDValue Ops[] = {Base, Scale, Index, Disp, Segment, InputChain};\n      Result = CurDAG->getMachineNode(NewOpc, SDLoc(Node), MVT::i32,\n                                      MVT::Other, Ops);\n      break;\n    }\n   LLVM_FALLTHROUGH;\n  case X86ISD::ADD:\n    // Try to match inc/dec.\n    if (!Subtarget->slowIncDec() || CurDAG->shouldOptForSize()) {\n      bool IsOne = isOneConstant(StoredVal.getOperand(1));\n      bool IsNegOne = isAllOnesConstant(StoredVal.getOperand(1));\n      // ADD/SUB with 1/-1 and carry flag isn't used can use inc/dec.\n      if ((IsOne || IsNegOne) && hasNoCarryFlagUses(StoredVal.getValue(1))) {\n        unsigned NewOpc =\n          ((Opc == X86ISD::ADD) == IsOne)\n              ? SelectOpcode(X86::INC64m, X86::INC32m, X86::INC16m, X86::INC8m)\n              : SelectOpcode(X86::DEC64m, X86::DEC32m, X86::DEC16m, X86::DEC8m);\n        const SDValue Ops[] = {Base, Scale, Index, Disp, Segment, InputChain};\n        Result = CurDAG->getMachineNode(NewOpc, SDLoc(Node), MVT::i32,\n                                        MVT::Other, Ops);\n        break;\n      }\n    }\n    LLVM_FALLTHROUGH;\n  case X86ISD::ADC:\n  case X86ISD::SBB:\n  case X86ISD::AND:\n  case X86ISD::OR:\n  case X86ISD::XOR: {\n    auto SelectRegOpcode = [SelectOpcode](unsigned Opc) {\n      switch (Opc) {\n      case X86ISD::ADD:\n        return SelectOpcode(X86::ADD64mr, X86::ADD32mr, X86::ADD16mr,\n                            X86::ADD8mr);\n      case X86ISD::ADC:\n        return SelectOpcode(X86::ADC64mr, X86::ADC32mr, X86::ADC16mr,\n                            X86::ADC8mr);\n      case X86ISD::SUB:\n        return SelectOpcode(X86::SUB64mr, X86::SUB32mr, X86::SUB16mr,\n                            X86::SUB8mr);\n      case X86ISD::SBB:\n        return SelectOpcode(X86::SBB64mr, X86::SBB32mr, X86::SBB16mr,\n                            X86::SBB8mr);\n      case X86ISD::AND:\n        return SelectOpcode(X86::AND64mr, X86::AND32mr, X86::AND16mr,\n                            X86::AND8mr);\n      case X86ISD::OR:\n        return SelectOpcode(X86::OR64mr, X86::OR32mr, X86::OR16mr, X86::OR8mr);\n      case X86ISD::XOR:\n        return SelectOpcode(X86::XOR64mr, X86::XOR32mr, X86::XOR16mr,\n                            X86::XOR8mr);\n      default:\n        llvm_unreachable(\"Invalid opcode!\");\n      }\n    };\n    auto SelectImm8Opcode = [SelectOpcode](unsigned Opc) {\n      switch (Opc) {\n      case X86ISD::ADD:\n        return SelectOpcode(X86::ADD64mi8, X86::ADD32mi8, X86::ADD16mi8, 0);\n      case X86ISD::ADC:\n        return SelectOpcode(X86::ADC64mi8, X86::ADC32mi8, X86::ADC16mi8, 0);\n      case X86ISD::SUB:\n        return SelectOpcode(X86::SUB64mi8, X86::SUB32mi8, X86::SUB16mi8, 0);\n      case X86ISD::SBB:\n        return SelectOpcode(X86::SBB64mi8, X86::SBB32mi8, X86::SBB16mi8, 0);\n      case X86ISD::AND:\n        return SelectOpcode(X86::AND64mi8, X86::AND32mi8, X86::AND16mi8, 0);\n      case X86ISD::OR:\n        return SelectOpcode(X86::OR64mi8, X86::OR32mi8, X86::OR16mi8, 0);\n      case X86ISD::XOR:\n        return SelectOpcode(X86::XOR64mi8, X86::XOR32mi8, X86::XOR16mi8, 0);\n      default:\n        llvm_unreachable(\"Invalid opcode!\");\n      }\n    };\n    auto SelectImmOpcode = [SelectOpcode](unsigned Opc) {\n      switch (Opc) {\n      case X86ISD::ADD:\n        return SelectOpcode(X86::ADD64mi32, X86::ADD32mi, X86::ADD16mi,\n                            X86::ADD8mi);\n      case X86ISD::ADC:\n        return SelectOpcode(X86::ADC64mi32, X86::ADC32mi, X86::ADC16mi,\n                            X86::ADC8mi);\n      case X86ISD::SUB:\n        return SelectOpcode(X86::SUB64mi32, X86::SUB32mi, X86::SUB16mi,\n                            X86::SUB8mi);\n      case X86ISD::SBB:\n        return SelectOpcode(X86::SBB64mi32, X86::SBB32mi, X86::SBB16mi,\n                            X86::SBB8mi);\n      case X86ISD::AND:\n        return SelectOpcode(X86::AND64mi32, X86::AND32mi, X86::AND16mi,\n                            X86::AND8mi);\n      case X86ISD::OR:\n        return SelectOpcode(X86::OR64mi32, X86::OR32mi, X86::OR16mi,\n                            X86::OR8mi);\n      case X86ISD::XOR:\n        return SelectOpcode(X86::XOR64mi32, X86::XOR32mi, X86::XOR16mi,\n                            X86::XOR8mi);\n      default:\n        llvm_unreachable(\"Invalid opcode!\");\n      }\n    };\n\n    unsigned NewOpc = SelectRegOpcode(Opc);\n    SDValue Operand = StoredVal->getOperand(1-LoadOpNo);\n\n    // See if the operand is a constant that we can fold into an immediate\n    // operand.\n    if (auto *OperandC = dyn_cast<ConstantSDNode>(Operand)) {\n      int64_t OperandV = OperandC->getSExtValue();\n\n      // Check if we can shrink the operand enough to fit in an immediate (or\n      // fit into a smaller immediate) by negating it and switching the\n      // operation.\n      if ((Opc == X86ISD::ADD || Opc == X86ISD::SUB) &&\n          ((MemVT != MVT::i8 && !isInt<8>(OperandV) && isInt<8>(-OperandV)) ||\n           (MemVT == MVT::i64 && !isInt<32>(OperandV) &&\n            isInt<32>(-OperandV))) &&\n          hasNoCarryFlagUses(StoredVal.getValue(1))) {\n        OperandV = -OperandV;\n        Opc = Opc == X86ISD::ADD ? X86ISD::SUB : X86ISD::ADD;\n      }\n\n      // First try to fit this into an Imm8 operand. If it doesn't fit, then try\n      // the larger immediate operand.\n      if (MemVT != MVT::i8 && isInt<8>(OperandV)) {\n        Operand = CurDAG->getTargetConstant(OperandV, SDLoc(Node), MemVT);\n        NewOpc = SelectImm8Opcode(Opc);\n      } else if (MemVT != MVT::i64 || isInt<32>(OperandV)) {\n        Operand = CurDAG->getTargetConstant(OperandV, SDLoc(Node), MemVT);\n        NewOpc = SelectImmOpcode(Opc);\n      }\n    }\n\n    if (Opc == X86ISD::ADC || Opc == X86ISD::SBB) {\n      SDValue CopyTo =\n          CurDAG->getCopyToReg(InputChain, SDLoc(Node), X86::EFLAGS,\n                               StoredVal.getOperand(2), SDValue());\n\n      const SDValue Ops[] = {Base,    Scale,   Index,  Disp,\n                             Segment, Operand, CopyTo, CopyTo.getValue(1)};\n      Result = CurDAG->getMachineNode(NewOpc, SDLoc(Node), MVT::i32, MVT::Other,\n                                      Ops);\n    } else {\n      const SDValue Ops[] = {Base,    Scale,   Index,     Disp,\n                             Segment, Operand, InputChain};\n      Result = CurDAG->getMachineNode(NewOpc, SDLoc(Node), MVT::i32, MVT::Other,\n                                      Ops);\n    }\n    break;\n  }\n  default:\n    llvm_unreachable(\"Invalid opcode!\");\n  }\n\n  MachineMemOperand *MemOps[] = {StoreNode->getMemOperand(),\n                                 LoadNode->getMemOperand()};\n  CurDAG->setNodeMemRefs(Result, MemOps);\n\n  // Update Load Chain uses as well.\n  ReplaceUses(SDValue(LoadNode, 1), SDValue(Result, 1));\n  ReplaceUses(SDValue(StoreNode, 0), SDValue(Result, 1));\n  ReplaceUses(SDValue(StoredVal.getNode(), 1), SDValue(Result, 0));\n  CurDAG->RemoveDeadNode(Node);\n  return true;\n}\n\n// See if this is an  X & Mask  that we can match to BEXTR/BZHI.\n// Where Mask is one of the following patterns:\n//   a) x &  (1 << nbits) - 1\n//   b) x & ~(-1 << nbits)\n//   c) x &  (-1 >> (32 - y))\n//   d) x << (32 - y) >> (32 - y)\nbool X86DAGToDAGISel::matchBitExtract(SDNode *Node) {\n  assert(\n      (Node->getOpcode() == ISD::AND || Node->getOpcode() == ISD::SRL) &&\n      \"Should be either an and-mask, or right-shift after clearing high bits.\");\n\n  // BEXTR is BMI instruction, BZHI is BMI2 instruction. We need at least one.\n  if (!Subtarget->hasBMI() && !Subtarget->hasBMI2())\n    return false;\n\n  MVT NVT = Node->getSimpleValueType(0);\n\n  // Only supported for 32 and 64 bits.\n  if (NVT != MVT::i32 && NVT != MVT::i64)\n    return false;\n\n  SDValue NBits;\n\n  // If we have BMI2's BZHI, we are ok with muti-use patterns.\n  // Else, if we only have BMI1's BEXTR, we require one-use.\n  const bool CanHaveExtraUses = Subtarget->hasBMI2();\n  auto checkUses = [CanHaveExtraUses](SDValue Op, unsigned NUses) {\n    return CanHaveExtraUses ||\n           Op.getNode()->hasNUsesOfValue(NUses, Op.getResNo());\n  };\n  auto checkOneUse = [checkUses](SDValue Op) { return checkUses(Op, 1); };\n  auto checkTwoUse = [checkUses](SDValue Op) { return checkUses(Op, 2); };\n\n  auto peekThroughOneUseTruncation = [checkOneUse](SDValue V) {\n    if (V->getOpcode() == ISD::TRUNCATE && checkOneUse(V)) {\n      assert(V.getSimpleValueType() == MVT::i32 &&\n             V.getOperand(0).getSimpleValueType() == MVT::i64 &&\n             \"Expected i64 -> i32 truncation\");\n      V = V.getOperand(0);\n    }\n    return V;\n  };\n\n  // a) x & ((1 << nbits) + (-1))\n  auto matchPatternA = [checkOneUse, peekThroughOneUseTruncation,\n                        &NBits](SDValue Mask) -> bool {\n    // Match `add`. Must only have one use!\n    if (Mask->getOpcode() != ISD::ADD || !checkOneUse(Mask))\n      return false;\n    // We should be adding all-ones constant (i.e. subtracting one.)\n    if (!isAllOnesConstant(Mask->getOperand(1)))\n      return false;\n    // Match `1 << nbits`. Might be truncated. Must only have one use!\n    SDValue M0 = peekThroughOneUseTruncation(Mask->getOperand(0));\n    if (M0->getOpcode() != ISD::SHL || !checkOneUse(M0))\n      return false;\n    if (!isOneConstant(M0->getOperand(0)))\n      return false;\n    NBits = M0->getOperand(1);\n    return true;\n  };\n\n  auto isAllOnes = [this, peekThroughOneUseTruncation, NVT](SDValue V) {\n    V = peekThroughOneUseTruncation(V);\n    return CurDAG->MaskedValueIsAllOnes(\n        V, APInt::getLowBitsSet(V.getSimpleValueType().getSizeInBits(),\n                                NVT.getSizeInBits()));\n  };\n\n  // b) x & ~(-1 << nbits)\n  auto matchPatternB = [checkOneUse, isAllOnes, peekThroughOneUseTruncation,\n                        &NBits](SDValue Mask) -> bool {\n    // Match `~()`. Must only have one use!\n    if (Mask.getOpcode() != ISD::XOR || !checkOneUse(Mask))\n      return false;\n    // The -1 only has to be all-ones for the final Node's NVT.\n    if (!isAllOnes(Mask->getOperand(1)))\n      return false;\n    // Match `-1 << nbits`. Might be truncated. Must only have one use!\n    SDValue M0 = peekThroughOneUseTruncation(Mask->getOperand(0));\n    if (M0->getOpcode() != ISD::SHL || !checkOneUse(M0))\n      return false;\n    // The -1 only has to be all-ones for the final Node's NVT.\n    if (!isAllOnes(M0->getOperand(0)))\n      return false;\n    NBits = M0->getOperand(1);\n    return true;\n  };\n\n  // Match potentially-truncated (bitwidth - y)\n  auto matchShiftAmt = [checkOneUse, &NBits](SDValue ShiftAmt,\n                                             unsigned Bitwidth) {\n    // Skip over a truncate of the shift amount.\n    if (ShiftAmt.getOpcode() == ISD::TRUNCATE) {\n      ShiftAmt = ShiftAmt.getOperand(0);\n      // The trunc should have been the only user of the real shift amount.\n      if (!checkOneUse(ShiftAmt))\n        return false;\n    }\n    // Match the shift amount as: (bitwidth - y). It should go away, too.\n    if (ShiftAmt.getOpcode() != ISD::SUB)\n      return false;\n    auto *V0 = dyn_cast<ConstantSDNode>(ShiftAmt.getOperand(0));\n    if (!V0 || V0->getZExtValue() != Bitwidth)\n      return false;\n    NBits = ShiftAmt.getOperand(1);\n    return true;\n  };\n\n  // c) x &  (-1 >> (32 - y))\n  auto matchPatternC = [checkOneUse, peekThroughOneUseTruncation,\n                        matchShiftAmt](SDValue Mask) -> bool {\n    // The mask itself may be truncated.\n    Mask = peekThroughOneUseTruncation(Mask);\n    unsigned Bitwidth = Mask.getSimpleValueType().getSizeInBits();\n    // Match `l>>`. Must only have one use!\n    if (Mask.getOpcode() != ISD::SRL || !checkOneUse(Mask))\n      return false;\n    // We should be shifting truly all-ones constant.\n    if (!isAllOnesConstant(Mask.getOperand(0)))\n      return false;\n    SDValue M1 = Mask.getOperand(1);\n    // The shift amount should not be used externally.\n    if (!checkOneUse(M1))\n      return false;\n    return matchShiftAmt(M1, Bitwidth);\n  };\n\n  SDValue X;\n\n  // d) x << (32 - y) >> (32 - y)\n  auto matchPatternD = [checkOneUse, checkTwoUse, matchShiftAmt,\n                        &X](SDNode *Node) -> bool {\n    if (Node->getOpcode() != ISD::SRL)\n      return false;\n    SDValue N0 = Node->getOperand(0);\n    if (N0->getOpcode() != ISD::SHL || !checkOneUse(N0))\n      return false;\n    unsigned Bitwidth = N0.getSimpleValueType().getSizeInBits();\n    SDValue N1 = Node->getOperand(1);\n    SDValue N01 = N0->getOperand(1);\n    // Both of the shifts must be by the exact same value.\n    // There should not be any uses of the shift amount outside of the pattern.\n    if (N1 != N01 || !checkTwoUse(N1))\n      return false;\n    if (!matchShiftAmt(N1, Bitwidth))\n      return false;\n    X = N0->getOperand(0);\n    return true;\n  };\n\n  auto matchLowBitMask = [matchPatternA, matchPatternB,\n                          matchPatternC](SDValue Mask) -> bool {\n    return matchPatternA(Mask) || matchPatternB(Mask) || matchPatternC(Mask);\n  };\n\n  if (Node->getOpcode() == ISD::AND) {\n    X = Node->getOperand(0);\n    SDValue Mask = Node->getOperand(1);\n\n    if (matchLowBitMask(Mask)) {\n      // Great.\n    } else {\n      std::swap(X, Mask);\n      if (!matchLowBitMask(Mask))\n        return false;\n    }\n  } else if (!matchPatternD(Node))\n    return false;\n\n  SDLoc DL(Node);\n\n  // Truncate the shift amount.\n  NBits = CurDAG->getNode(ISD::TRUNCATE, DL, MVT::i8, NBits);\n  insertDAGNode(*CurDAG, SDValue(Node, 0), NBits);\n\n  // Insert 8-bit NBits into lowest 8 bits of 32-bit register.\n  // All the other bits are undefined, we do not care about them.\n  SDValue ImplDef = SDValue(\n      CurDAG->getMachineNode(TargetOpcode::IMPLICIT_DEF, DL, MVT::i32), 0);\n  insertDAGNode(*CurDAG, SDValue(Node, 0), ImplDef);\n\n  SDValue SRIdxVal = CurDAG->getTargetConstant(X86::sub_8bit, DL, MVT::i32);\n  insertDAGNode(*CurDAG, SDValue(Node, 0), SRIdxVal);\n  NBits = SDValue(\n      CurDAG->getMachineNode(TargetOpcode::INSERT_SUBREG, DL, MVT::i32, ImplDef,\n                             NBits, SRIdxVal), 0);\n  insertDAGNode(*CurDAG, SDValue(Node, 0), NBits);\n\n  if (Subtarget->hasBMI2()) {\n    // Great, just emit the the BZHI..\n    if (NVT != MVT::i32) {\n      // But have to place the bit count into the wide-enough register first.\n      NBits = CurDAG->getNode(ISD::ANY_EXTEND, DL, NVT, NBits);\n      insertDAGNode(*CurDAG, SDValue(Node, 0), NBits);\n    }\n\n    SDValue Extract = CurDAG->getNode(X86ISD::BZHI, DL, NVT, X, NBits);\n    ReplaceNode(Node, Extract.getNode());\n    SelectCode(Extract.getNode());\n    return true;\n  }\n\n  // Else, if we do *NOT* have BMI2, let's find out if the if the 'X' is\n  // *logically* shifted (potentially with one-use trunc inbetween),\n  // and the truncation was the only use of the shift,\n  // and if so look past one-use truncation.\n  {\n    SDValue RealX = peekThroughOneUseTruncation(X);\n    // FIXME: only if the shift is one-use?\n    if (RealX != X && RealX.getOpcode() == ISD::SRL)\n      X = RealX;\n  }\n\n  MVT XVT = X.getSimpleValueType();\n\n  // Else, emitting BEXTR requires one more step.\n  // The 'control' of BEXTR has the pattern of:\n  // [15...8 bit][ 7...0 bit] location\n  // [ bit count][     shift] name\n  // I.e. 0b000000011'00000001 means  (x >> 0b1) & 0b11\n\n  // Shift NBits left by 8 bits, thus producing 'control'.\n  // This makes the low 8 bits to be zero.\n  SDValue C8 = CurDAG->getConstant(8, DL, MVT::i8);\n  insertDAGNode(*CurDAG, SDValue(Node, 0), C8);\n  SDValue Control = CurDAG->getNode(ISD::SHL, DL, MVT::i32, NBits, C8);\n  insertDAGNode(*CurDAG, SDValue(Node, 0), Control);\n\n  // If the 'X' is *logically* shifted, we can fold that shift into 'control'.\n  // FIXME: only if the shift is one-use?\n  if (X.getOpcode() == ISD::SRL) {\n    SDValue ShiftAmt = X.getOperand(1);\n    X = X.getOperand(0);\n\n    assert(ShiftAmt.getValueType() == MVT::i8 &&\n           \"Expected shift amount to be i8\");\n\n    // Now, *zero*-extend the shift amount. The bits 8...15 *must* be zero!\n    // We could zext to i16 in some form, but we intentionally don't do that.\n    SDValue OrigShiftAmt = ShiftAmt;\n    ShiftAmt = CurDAG->getNode(ISD::ZERO_EXTEND, DL, MVT::i32, ShiftAmt);\n    insertDAGNode(*CurDAG, OrigShiftAmt, ShiftAmt);\n\n    // And now 'or' these low 8 bits of shift amount into the 'control'.\n    Control = CurDAG->getNode(ISD::OR, DL, MVT::i32, Control, ShiftAmt);\n    insertDAGNode(*CurDAG, SDValue(Node, 0), Control);\n  }\n\n  // But have to place the 'control' into the wide-enough register first.\n  if (XVT != MVT::i32) {\n    Control = CurDAG->getNode(ISD::ANY_EXTEND, DL, XVT, Control);\n    insertDAGNode(*CurDAG, SDValue(Node, 0), Control);\n  }\n\n  // And finally, form the BEXTR itself.\n  SDValue Extract = CurDAG->getNode(X86ISD::BEXTR, DL, XVT, X, Control);\n\n  // The 'X' was originally truncated. Do that now.\n  if (XVT != NVT) {\n    insertDAGNode(*CurDAG, SDValue(Node, 0), Extract);\n    Extract = CurDAG->getNode(ISD::TRUNCATE, DL, NVT, Extract);\n  }\n\n  ReplaceNode(Node, Extract.getNode());\n  SelectCode(Extract.getNode());\n\n  return true;\n}\n\n// See if this is an (X >> C1) & C2 that we can match to BEXTR/BEXTRI.\nMachineSDNode *X86DAGToDAGISel::matchBEXTRFromAndImm(SDNode *Node) {\n  MVT NVT = Node->getSimpleValueType(0);\n  SDLoc dl(Node);\n\n  SDValue N0 = Node->getOperand(0);\n  SDValue N1 = Node->getOperand(1);\n\n  // If we have TBM we can use an immediate for the control. If we have BMI\n  // we should only do this if the BEXTR instruction is implemented well.\n  // Otherwise moving the control into a register makes this more costly.\n  // TODO: Maybe load folding, greater than 32-bit masks, or a guarantee of LICM\n  // hoisting the move immediate would make it worthwhile with a less optimal\n  // BEXTR?\n  bool PreferBEXTR =\n      Subtarget->hasTBM() || (Subtarget->hasBMI() && Subtarget->hasFastBEXTR());\n  if (!PreferBEXTR && !Subtarget->hasBMI2())\n    return nullptr;\n\n  // Must have a shift right.\n  if (N0->getOpcode() != ISD::SRL && N0->getOpcode() != ISD::SRA)\n    return nullptr;\n\n  // Shift can't have additional users.\n  if (!N0->hasOneUse())\n    return nullptr;\n\n  // Only supported for 32 and 64 bits.\n  if (NVT != MVT::i32 && NVT != MVT::i64)\n    return nullptr;\n\n  // Shift amount and RHS of and must be constant.\n  ConstantSDNode *MaskCst = dyn_cast<ConstantSDNode>(N1);\n  ConstantSDNode *ShiftCst = dyn_cast<ConstantSDNode>(N0->getOperand(1));\n  if (!MaskCst || !ShiftCst)\n    return nullptr;\n\n  // And RHS must be a mask.\n  uint64_t Mask = MaskCst->getZExtValue();\n  if (!isMask_64(Mask))\n    return nullptr;\n\n  uint64_t Shift = ShiftCst->getZExtValue();\n  uint64_t MaskSize = countPopulation(Mask);\n\n  // Don't interfere with something that can be handled by extracting AH.\n  // TODO: If we are able to fold a load, BEXTR might still be better than AH.\n  if (Shift == 8 && MaskSize == 8)\n    return nullptr;\n\n  // Make sure we are only using bits that were in the original value, not\n  // shifted in.\n  if (Shift + MaskSize > NVT.getSizeInBits())\n    return nullptr;\n\n  // BZHI, if available, is always fast, unlike BEXTR. But even if we decide\n  // that we can't use BEXTR, it is only worthwhile using BZHI if the mask\n  // does not fit into 32 bits. Load folding is not a sufficient reason.\n  if (!PreferBEXTR && MaskSize <= 32)\n    return nullptr;\n\n  SDValue Control;\n  unsigned ROpc, MOpc;\n\n  if (!PreferBEXTR) {\n    assert(Subtarget->hasBMI2() && \"We must have BMI2's BZHI then.\");\n    // If we can't make use of BEXTR then we can't fuse shift+mask stages.\n    // Let's perform the mask first, and apply shift later. Note that we need to\n    // widen the mask to account for the fact that we'll apply shift afterwards!\n    Control = CurDAG->getTargetConstant(Shift + MaskSize, dl, NVT);\n    ROpc = NVT == MVT::i64 ? X86::BZHI64rr : X86::BZHI32rr;\n    MOpc = NVT == MVT::i64 ? X86::BZHI64rm : X86::BZHI32rm;\n    unsigned NewOpc = NVT == MVT::i64 ? X86::MOV32ri64 : X86::MOV32ri;\n    Control = SDValue(CurDAG->getMachineNode(NewOpc, dl, NVT, Control), 0);\n  } else {\n    // The 'control' of BEXTR has the pattern of:\n    // [15...8 bit][ 7...0 bit] location\n    // [ bit count][     shift] name\n    // I.e. 0b000000011'00000001 means  (x >> 0b1) & 0b11\n    Control = CurDAG->getTargetConstant(Shift | (MaskSize << 8), dl, NVT);\n    if (Subtarget->hasTBM()) {\n      ROpc = NVT == MVT::i64 ? X86::BEXTRI64ri : X86::BEXTRI32ri;\n      MOpc = NVT == MVT::i64 ? X86::BEXTRI64mi : X86::BEXTRI32mi;\n    } else {\n      assert(Subtarget->hasBMI() && \"We must have BMI1's BEXTR then.\");\n      // BMI requires the immediate to placed in a register.\n      ROpc = NVT == MVT::i64 ? X86::BEXTR64rr : X86::BEXTR32rr;\n      MOpc = NVT == MVT::i64 ? X86::BEXTR64rm : X86::BEXTR32rm;\n      unsigned NewOpc = NVT == MVT::i64 ? X86::MOV32ri64 : X86::MOV32ri;\n      Control = SDValue(CurDAG->getMachineNode(NewOpc, dl, NVT, Control), 0);\n    }\n  }\n\n  MachineSDNode *NewNode;\n  SDValue Input = N0->getOperand(0);\n  SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n  if (tryFoldLoad(Node, N0.getNode(), Input, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4)) {\n    SDValue Ops[] = {\n        Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, Control, Input.getOperand(0)};\n    SDVTList VTs = CurDAG->getVTList(NVT, MVT::i32, MVT::Other);\n    NewNode = CurDAG->getMachineNode(MOpc, dl, VTs, Ops);\n    // Update the chain.\n    ReplaceUses(Input.getValue(1), SDValue(NewNode, 2));\n    // Record the mem-refs\n    CurDAG->setNodeMemRefs(NewNode, {cast<LoadSDNode>(Input)->getMemOperand()});\n  } else {\n    NewNode = CurDAG->getMachineNode(ROpc, dl, NVT, MVT::i32, Input, Control);\n  }\n\n  if (!PreferBEXTR) {\n    // We still need to apply the shift.\n    SDValue ShAmt = CurDAG->getTargetConstant(Shift, dl, NVT);\n    unsigned NewOpc = NVT == MVT::i64 ? X86::SHR64ri : X86::SHR32ri;\n    NewNode =\n        CurDAG->getMachineNode(NewOpc, dl, NVT, SDValue(NewNode, 0), ShAmt);\n  }\n\n  return NewNode;\n}\n\n// Emit a PCMISTR(I/M) instruction.\nMachineSDNode *X86DAGToDAGISel::emitPCMPISTR(unsigned ROpc, unsigned MOpc,\n                                             bool MayFoldLoad, const SDLoc &dl,\n                                             MVT VT, SDNode *Node) {\n  SDValue N0 = Node->getOperand(0);\n  SDValue N1 = Node->getOperand(1);\n  SDValue Imm = Node->getOperand(2);\n  const ConstantInt *Val = cast<ConstantSDNode>(Imm)->getConstantIntValue();\n  Imm = CurDAG->getTargetConstant(*Val, SDLoc(Node), Imm.getValueType());\n\n  // Try to fold a load. No need to check alignment.\n  SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n  if (MayFoldLoad && tryFoldLoad(Node, N1, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4)) {\n    SDValue Ops[] = { N0, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, Imm,\n                      N1.getOperand(0) };\n    SDVTList VTs = CurDAG->getVTList(VT, MVT::i32, MVT::Other);\n    MachineSDNode *CNode = CurDAG->getMachineNode(MOpc, dl, VTs, Ops);\n    // Update the chain.\n    ReplaceUses(N1.getValue(1), SDValue(CNode, 2));\n    // Record the mem-refs\n    CurDAG->setNodeMemRefs(CNode, {cast<LoadSDNode>(N1)->getMemOperand()});\n    return CNode;\n  }\n\n  SDValue Ops[] = { N0, N1, Imm };\n  SDVTList VTs = CurDAG->getVTList(VT, MVT::i32);\n  MachineSDNode *CNode = CurDAG->getMachineNode(ROpc, dl, VTs, Ops);\n  return CNode;\n}\n\n// Emit a PCMESTR(I/M) instruction. Also return the Glue result in case we need\n// to emit a second instruction after this one. This is needed since we have two\n// copyToReg nodes glued before this and we need to continue that glue through.\nMachineSDNode *X86DAGToDAGISel::emitPCMPESTR(unsigned ROpc, unsigned MOpc,\n                                             bool MayFoldLoad, const SDLoc &dl,\n                                             MVT VT, SDNode *Node,\n                                             SDValue &InFlag) {\n  SDValue N0 = Node->getOperand(0);\n  SDValue N2 = Node->getOperand(2);\n  SDValue Imm = Node->getOperand(4);\n  const ConstantInt *Val = cast<ConstantSDNode>(Imm)->getConstantIntValue();\n  Imm = CurDAG->getTargetConstant(*Val, SDLoc(Node), Imm.getValueType());\n\n  // Try to fold a load. No need to check alignment.\n  SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n  if (MayFoldLoad && tryFoldLoad(Node, N2, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4)) {\n    SDValue Ops[] = { N0, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, Imm,\n                      N2.getOperand(0), InFlag };\n    SDVTList VTs = CurDAG->getVTList(VT, MVT::i32, MVT::Other, MVT::Glue);\n    MachineSDNode *CNode = CurDAG->getMachineNode(MOpc, dl, VTs, Ops);\n    InFlag = SDValue(CNode, 3);\n    // Update the chain.\n    ReplaceUses(N2.getValue(1), SDValue(CNode, 2));\n    // Record the mem-refs\n    CurDAG->setNodeMemRefs(CNode, {cast<LoadSDNode>(N2)->getMemOperand()});\n    return CNode;\n  }\n\n  SDValue Ops[] = { N0, N2, Imm, InFlag };\n  SDVTList VTs = CurDAG->getVTList(VT, MVT::i32, MVT::Glue);\n  MachineSDNode *CNode = CurDAG->getMachineNode(ROpc, dl, VTs, Ops);\n  InFlag = SDValue(CNode, 2);\n  return CNode;\n}\n\nbool X86DAGToDAGISel::tryShiftAmountMod(SDNode *N) {\n  EVT VT = N->getValueType(0);\n\n  // Only handle scalar shifts.\n  if (VT.isVector())\n    return false;\n\n  // Narrower shifts only mask to 5 bits in hardware.\n  unsigned Size = VT == MVT::i64 ? 64 : 32;\n\n  SDValue OrigShiftAmt = N->getOperand(1);\n  SDValue ShiftAmt = OrigShiftAmt;\n  SDLoc DL(N);\n\n  // Skip over a truncate of the shift amount.\n  if (ShiftAmt->getOpcode() == ISD::TRUNCATE)\n    ShiftAmt = ShiftAmt->getOperand(0);\n\n  // This function is called after X86DAGToDAGISel::matchBitExtract(),\n  // so we are not afraid that we might mess up BZHI/BEXTR pattern.\n\n  SDValue NewShiftAmt;\n  if (ShiftAmt->getOpcode() == ISD::ADD || ShiftAmt->getOpcode() == ISD::SUB) {\n    SDValue Add0 = ShiftAmt->getOperand(0);\n    SDValue Add1 = ShiftAmt->getOperand(1);\n    // If we are shifting by X+/-N where N == 0 mod Size, then just shift by X\n    // to avoid the ADD/SUB.\n    if (isa<ConstantSDNode>(Add1) &&\n        cast<ConstantSDNode>(Add1)->getZExtValue() % Size == 0) {\n      NewShiftAmt = Add0;\n    // If we are shifting by N-X where N == 0 mod Size, then just shift by -X to\n    // generate a NEG instead of a SUB of a constant.\n    } else if (ShiftAmt->getOpcode() == ISD::SUB &&\n               isa<ConstantSDNode>(Add0) &&\n               cast<ConstantSDNode>(Add0)->getZExtValue() != 0 &&\n               cast<ConstantSDNode>(Add0)->getZExtValue() % Size == 0) {\n      // Insert a negate op.\n      // TODO: This isn't guaranteed to replace the sub if there is a logic cone\n      // that uses it that's not a shift.\n      EVT SubVT = ShiftAmt.getValueType();\n      SDValue Zero = CurDAG->getConstant(0, DL, SubVT);\n      SDValue Neg = CurDAG->getNode(ISD::SUB, DL, SubVT, Zero, Add1);\n      NewShiftAmt = Neg;\n\n      // Insert these operands into a valid topological order so they can\n      // get selected independently.\n      insertDAGNode(*CurDAG, OrigShiftAmt, Zero);\n      insertDAGNode(*CurDAG, OrigShiftAmt, Neg);\n    } else\n      return false;\n  } else\n    return false;\n\n  if (NewShiftAmt.getValueType() != MVT::i8) {\n    // Need to truncate the shift amount.\n    NewShiftAmt = CurDAG->getNode(ISD::TRUNCATE, DL, MVT::i8, NewShiftAmt);\n    // Add to a correct topological ordering.\n    insertDAGNode(*CurDAG, OrigShiftAmt, NewShiftAmt);\n  }\n\n  // Insert a new mask to keep the shift amount legal. This should be removed\n  // by isel patterns.\n  NewShiftAmt = CurDAG->getNode(ISD::AND, DL, MVT::i8, NewShiftAmt,\n                                CurDAG->getConstant(Size - 1, DL, MVT::i8));\n  // Place in a correct topological ordering.\n  insertDAGNode(*CurDAG, OrigShiftAmt, NewShiftAmt);\n\n  SDNode *UpdatedNode = CurDAG->UpdateNodeOperands(N, N->getOperand(0),\n                                                   NewShiftAmt);\n  if (UpdatedNode != N) {\n    // If we found an existing node, we should replace ourselves with that node\n    // and wait for it to be selected after its other users.\n    ReplaceNode(N, UpdatedNode);\n    return true;\n  }\n\n  // If the original shift amount is now dead, delete it so that we don't run\n  // it through isel.\n  if (OrigShiftAmt.getNode()->use_empty())\n    CurDAG->RemoveDeadNode(OrigShiftAmt.getNode());\n\n  // Now that we've optimized the shift amount, defer to normal isel to get\n  // load folding and legacy vs BMI2 selection without repeating it here.\n  SelectCode(N);\n  return true;\n}\n\nbool X86DAGToDAGISel::tryShrinkShlLogicImm(SDNode *N) {\n  MVT NVT = N->getSimpleValueType(0);\n  unsigned Opcode = N->getOpcode();\n  SDLoc dl(N);\n\n  // For operations of the form (x << C1) op C2, check if we can use a smaller\n  // encoding for C2 by transforming it into (x op (C2>>C1)) << C1.\n  SDValue Shift = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n\n  ConstantSDNode *Cst = dyn_cast<ConstantSDNode>(N1);\n  if (!Cst)\n    return false;\n\n  int64_t Val = Cst->getSExtValue();\n\n  // If we have an any_extend feeding the AND, look through it to see if there\n  // is a shift behind it. But only if the AND doesn't use the extended bits.\n  // FIXME: Generalize this to other ANY_EXTEND than i32 to i64?\n  bool FoundAnyExtend = false;\n  if (Shift.getOpcode() == ISD::ANY_EXTEND && Shift.hasOneUse() &&\n      Shift.getOperand(0).getSimpleValueType() == MVT::i32 &&\n      isUInt<32>(Val)) {\n    FoundAnyExtend = true;\n    Shift = Shift.getOperand(0);\n  }\n\n  if (Shift.getOpcode() != ISD::SHL || !Shift.hasOneUse())\n    return false;\n\n  // i8 is unshrinkable, i16 should be promoted to i32.\n  if (NVT != MVT::i32 && NVT != MVT::i64)\n    return false;\n\n  ConstantSDNode *ShlCst = dyn_cast<ConstantSDNode>(Shift.getOperand(1));\n  if (!ShlCst)\n    return false;\n\n  uint64_t ShAmt = ShlCst->getZExtValue();\n\n  // Make sure that we don't change the operation by removing bits.\n  // This only matters for OR and XOR, AND is unaffected.\n  uint64_t RemovedBitsMask = (1ULL << ShAmt) - 1;\n  if (Opcode != ISD::AND && (Val & RemovedBitsMask) != 0)\n    return false;\n\n  // Check the minimum bitwidth for the new constant.\n  // TODO: Using 16 and 8 bit operations is also possible for or32 & xor32.\n  auto CanShrinkImmediate = [&](int64_t &ShiftedVal) {\n    if (Opcode == ISD::AND) {\n      // AND32ri is the same as AND64ri32 with zext imm.\n      // Try this before sign extended immediates below.\n      ShiftedVal = (uint64_t)Val >> ShAmt;\n      if (NVT == MVT::i64 && !isUInt<32>(Val) && isUInt<32>(ShiftedVal))\n        return true;\n      // Also swap order when the AND can become MOVZX.\n      if (ShiftedVal == UINT8_MAX || ShiftedVal == UINT16_MAX)\n        return true;\n    }\n    ShiftedVal = Val >> ShAmt;\n    if ((!isInt<8>(Val) && isInt<8>(ShiftedVal)) ||\n        (!isInt<32>(Val) && isInt<32>(ShiftedVal)))\n      return true;\n    if (Opcode != ISD::AND) {\n      // MOV32ri+OR64r/XOR64r is cheaper than MOV64ri64+OR64rr/XOR64rr\n      ShiftedVal = (uint64_t)Val >> ShAmt;\n      if (NVT == MVT::i64 && !isUInt<32>(Val) && isUInt<32>(ShiftedVal))\n        return true;\n    }\n    return false;\n  };\n\n  int64_t ShiftedVal;\n  if (!CanShrinkImmediate(ShiftedVal))\n    return false;\n\n  // Ok, we can reorder to get a smaller immediate.\n\n  // But, its possible the original immediate allowed an AND to become MOVZX.\n  // Doing this late due to avoid the MakedValueIsZero call as late as\n  // possible.\n  if (Opcode == ISD::AND) {\n    // Find the smallest zext this could possibly be.\n    unsigned ZExtWidth = Cst->getAPIntValue().getActiveBits();\n    ZExtWidth = PowerOf2Ceil(std::max(ZExtWidth, 8U));\n\n    // Figure out which bits need to be zero to achieve that mask.\n    APInt NeededMask = APInt::getLowBitsSet(NVT.getSizeInBits(),\n                                            ZExtWidth);\n    NeededMask &= ~Cst->getAPIntValue();\n\n    if (CurDAG->MaskedValueIsZero(N->getOperand(0), NeededMask))\n      return false;\n  }\n\n  SDValue X = Shift.getOperand(0);\n  if (FoundAnyExtend) {\n    SDValue NewX = CurDAG->getNode(ISD::ANY_EXTEND, dl, NVT, X);\n    insertDAGNode(*CurDAG, SDValue(N, 0), NewX);\n    X = NewX;\n  }\n\n  SDValue NewCst = CurDAG->getConstant(ShiftedVal, dl, NVT);\n  insertDAGNode(*CurDAG, SDValue(N, 0), NewCst);\n  SDValue NewBinOp = CurDAG->getNode(Opcode, dl, NVT, X, NewCst);\n  insertDAGNode(*CurDAG, SDValue(N, 0), NewBinOp);\n  SDValue NewSHL = CurDAG->getNode(ISD::SHL, dl, NVT, NewBinOp,\n                                   Shift.getOperand(1));\n  ReplaceNode(N, NewSHL.getNode());\n  SelectCode(NewSHL.getNode());\n  return true;\n}\n\nbool X86DAGToDAGISel::matchVPTERNLOG(SDNode *Root, SDNode *ParentA,\n                                     SDNode *ParentBC, SDValue A, SDValue B,\n                                     SDValue C, uint8_t Imm) {\n  assert(A.isOperandOf(ParentA));\n  assert(B.isOperandOf(ParentBC));\n  assert(C.isOperandOf(ParentBC));\n\n  auto tryFoldLoadOrBCast =\n      [this](SDNode *Root, SDNode *P, SDValue &L, SDValue &Base, SDValue &Scale,\n             SDValue &Index, SDValue &Disp, SDValue &Segment) {\n        if (tryFoldLoad(Root, P, L, Base, Scale, Index, Disp, Segment))\n          return true;\n\n        // Not a load, check for broadcast which may be behind a bitcast.\n        if (L.getOpcode() == ISD::BITCAST && L.hasOneUse()) {\n          P = L.getNode();\n          L = L.getOperand(0);\n        }\n\n        if (L.getOpcode() != X86ISD::VBROADCAST_LOAD)\n          return false;\n\n        // Only 32 and 64 bit broadcasts are supported.\n        auto *MemIntr = cast<MemIntrinsicSDNode>(L);\n        unsigned Size = MemIntr->getMemoryVT().getSizeInBits();\n        if (Size != 32 && Size != 64)\n          return false;\n\n        return tryFoldBroadcast(Root, P, L, Base, Scale, Index, Disp, Segment);\n      };\n\n  bool FoldedLoad = false;\n  SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n  if (tryFoldLoadOrBCast(Root, ParentBC, C, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4)) {\n    FoldedLoad = true;\n  } else if (tryFoldLoadOrBCast(Root, ParentA, A, Tmp0, Tmp1, Tmp2, Tmp3,\n                                Tmp4)) {\n    FoldedLoad = true;\n    std::swap(A, C);\n    // Swap bits 1/4 and 3/6.\n    uint8_t OldImm = Imm;\n    Imm = OldImm & 0xa5;\n    if (OldImm & 0x02) Imm |= 0x10;\n    if (OldImm & 0x10) Imm |= 0x02;\n    if (OldImm & 0x08) Imm |= 0x40;\n    if (OldImm & 0x40) Imm |= 0x08;\n  } else if (tryFoldLoadOrBCast(Root, ParentBC, B, Tmp0, Tmp1, Tmp2, Tmp3,\n                                Tmp4)) {\n    FoldedLoad = true;\n    std::swap(B, C);\n    // Swap bits 1/2 and 5/6.\n    uint8_t OldImm = Imm;\n    Imm = OldImm & 0x99;\n    if (OldImm & 0x02) Imm |= 0x04;\n    if (OldImm & 0x04) Imm |= 0x02;\n    if (OldImm & 0x20) Imm |= 0x40;\n    if (OldImm & 0x40) Imm |= 0x20;\n  }\n\n  SDLoc DL(Root);\n\n  SDValue TImm = CurDAG->getTargetConstant(Imm, DL, MVT::i8);\n\n  MVT NVT = Root->getSimpleValueType(0);\n\n  MachineSDNode *MNode;\n  if (FoldedLoad) {\n    SDVTList VTs = CurDAG->getVTList(NVT, MVT::Other);\n\n    unsigned Opc;\n    if (C.getOpcode() == X86ISD::VBROADCAST_LOAD) {\n      auto *MemIntr = cast<MemIntrinsicSDNode>(C);\n      unsigned EltSize = MemIntr->getMemoryVT().getSizeInBits();\n      assert((EltSize == 32 || EltSize == 64) && \"Unexpected broadcast size!\");\n\n      bool UseD = EltSize == 32;\n      if (NVT.is128BitVector())\n        Opc = UseD ? X86::VPTERNLOGDZ128rmbi : X86::VPTERNLOGQZ128rmbi;\n      else if (NVT.is256BitVector())\n        Opc = UseD ? X86::VPTERNLOGDZ256rmbi : X86::VPTERNLOGQZ256rmbi;\n      else if (NVT.is512BitVector())\n        Opc = UseD ? X86::VPTERNLOGDZrmbi : X86::VPTERNLOGQZrmbi;\n      else\n        llvm_unreachable(\"Unexpected vector size!\");\n    } else {\n      bool UseD = NVT.getVectorElementType() == MVT::i32;\n      if (NVT.is128BitVector())\n        Opc = UseD ? X86::VPTERNLOGDZ128rmi : X86::VPTERNLOGQZ128rmi;\n      else if (NVT.is256BitVector())\n        Opc = UseD ? X86::VPTERNLOGDZ256rmi : X86::VPTERNLOGQZ256rmi;\n      else if (NVT.is512BitVector())\n        Opc = UseD ? X86::VPTERNLOGDZrmi : X86::VPTERNLOGQZrmi;\n      else\n        llvm_unreachable(\"Unexpected vector size!\");\n    }\n\n    SDValue Ops[] = {A, B, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, TImm, C.getOperand(0)};\n    MNode = CurDAG->getMachineNode(Opc, DL, VTs, Ops);\n\n    // Update the chain.\n    ReplaceUses(C.getValue(1), SDValue(MNode, 1));\n    // Record the mem-refs\n    CurDAG->setNodeMemRefs(MNode, {cast<MemSDNode>(C)->getMemOperand()});\n  } else {\n    bool UseD = NVT.getVectorElementType() == MVT::i32;\n    unsigned Opc;\n    if (NVT.is128BitVector())\n      Opc = UseD ? X86::VPTERNLOGDZ128rri : X86::VPTERNLOGQZ128rri;\n    else if (NVT.is256BitVector())\n      Opc = UseD ? X86::VPTERNLOGDZ256rri : X86::VPTERNLOGQZ256rri;\n    else if (NVT.is512BitVector())\n      Opc = UseD ? X86::VPTERNLOGDZrri : X86::VPTERNLOGQZrri;\n    else\n      llvm_unreachable(\"Unexpected vector size!\");\n\n    MNode = CurDAG->getMachineNode(Opc, DL, NVT, {A, B, C, TImm});\n  }\n\n  ReplaceUses(SDValue(Root, 0), SDValue(MNode, 0));\n  CurDAG->RemoveDeadNode(Root);\n  return true;\n}\n\n// Try to match two logic ops to a VPTERNLOG.\n// FIXME: Handle inverted inputs?\n// FIXME: Handle more complex patterns that use an operand more than once?\nbool X86DAGToDAGISel::tryVPTERNLOG(SDNode *N) {\n  MVT NVT = N->getSimpleValueType(0);\n\n  // Make sure we support VPTERNLOG.\n  if (!NVT.isVector() || !Subtarget->hasAVX512() ||\n      NVT.getVectorElementType() == MVT::i1)\n    return false;\n\n  // We need VLX for 128/256-bit.\n  if (!(Subtarget->hasVLX() || NVT.is512BitVector()))\n    return false;\n\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n\n  auto getFoldableLogicOp = [](SDValue Op) {\n    // Peek through single use bitcast.\n    if (Op.getOpcode() == ISD::BITCAST && Op.hasOneUse())\n      Op = Op.getOperand(0);\n\n    if (!Op.hasOneUse())\n      return SDValue();\n\n    unsigned Opc = Op.getOpcode();\n    if (Opc == ISD::AND || Opc == ISD::OR || Opc == ISD::XOR ||\n        Opc == X86ISD::ANDNP)\n      return Op;\n\n    return SDValue();\n  };\n\n  SDValue A, FoldableOp;\n  if ((FoldableOp = getFoldableLogicOp(N1))) {\n    A = N0;\n  } else if ((FoldableOp = getFoldableLogicOp(N0))) {\n    A = N1;\n  } else\n    return false;\n\n  SDValue B = FoldableOp.getOperand(0);\n  SDValue C = FoldableOp.getOperand(1);\n\n  // We can build the appropriate control immediate by performing the logic\n  // operation we're matching using these constants for A, B, and C.\n  const uint8_t TernlogMagicA = 0xf0;\n  const uint8_t TernlogMagicB = 0xcc;\n  const uint8_t TernlogMagicC = 0xaa;\n\n  uint8_t Imm;\n  switch (FoldableOp.getOpcode()) {\n  default: llvm_unreachable(\"Unexpected opcode!\");\n  case ISD::AND:      Imm = TernlogMagicB & TernlogMagicC; break;\n  case ISD::OR:       Imm = TernlogMagicB | TernlogMagicC; break;\n  case ISD::XOR:      Imm = TernlogMagicB ^ TernlogMagicC; break;\n  case X86ISD::ANDNP: Imm = ~(TernlogMagicB) & TernlogMagicC; break;\n  }\n\n  switch (N->getOpcode()) {\n  default: llvm_unreachable(\"Unexpected opcode!\");\n  case X86ISD::ANDNP:\n    if (A == N0)\n      Imm &= ~TernlogMagicA;\n    else\n      Imm = ~(Imm) & TernlogMagicA;\n    break;\n  case ISD::AND: Imm &= TernlogMagicA; break;\n  case ISD::OR:  Imm |= TernlogMagicA; break;\n  case ISD::XOR: Imm ^= TernlogMagicA; break;\n  }\n\n  return matchVPTERNLOG(N, N, FoldableOp.getNode(), A, B, C, Imm);\n}\n\n/// If the high bits of an 'and' operand are known zero, try setting the\n/// high bits of an 'and' constant operand to produce a smaller encoding by\n/// creating a small, sign-extended negative immediate rather than a large\n/// positive one. This reverses a transform in SimplifyDemandedBits that\n/// shrinks mask constants by clearing bits. There is also a possibility that\n/// the 'and' mask can be made -1, so the 'and' itself is unnecessary. In that\n/// case, just replace the 'and'. Return 'true' if the node is replaced.\nbool X86DAGToDAGISel::shrinkAndImmediate(SDNode *And) {\n  // i8 is unshrinkable, i16 should be promoted to i32, and vector ops don't\n  // have immediate operands.\n  MVT VT = And->getSimpleValueType(0);\n  if (VT != MVT::i32 && VT != MVT::i64)\n    return false;\n\n  auto *And1C = dyn_cast<ConstantSDNode>(And->getOperand(1));\n  if (!And1C)\n    return false;\n\n  // Bail out if the mask constant is already negative. It's can't shrink more.\n  // If the upper 32 bits of a 64 bit mask are all zeros, we have special isel\n  // patterns to use a 32-bit and instead of a 64-bit and by relying on the\n  // implicit zeroing of 32 bit ops. So we should check if the lower 32 bits\n  // are negative too.\n  APInt MaskVal = And1C->getAPIntValue();\n  unsigned MaskLZ = MaskVal.countLeadingZeros();\n  if (!MaskLZ || (VT == MVT::i64 && MaskLZ == 32))\n    return false;\n\n  // Don't extend into the upper 32 bits of a 64 bit mask.\n  if (VT == MVT::i64 && MaskLZ >= 32) {\n    MaskLZ -= 32;\n    MaskVal = MaskVal.trunc(32);\n  }\n\n  SDValue And0 = And->getOperand(0);\n  APInt HighZeros = APInt::getHighBitsSet(MaskVal.getBitWidth(), MaskLZ);\n  APInt NegMaskVal = MaskVal | HighZeros;\n\n  // If a negative constant would not allow a smaller encoding, there's no need\n  // to continue. Only change the constant when we know it's a win.\n  unsigned MinWidth = NegMaskVal.getMinSignedBits();\n  if (MinWidth > 32 || (MinWidth > 8 && MaskVal.getMinSignedBits() <= 32))\n    return false;\n\n  // Extend masks if we truncated above.\n  if (VT == MVT::i64 && MaskVal.getBitWidth() < 64) {\n    NegMaskVal = NegMaskVal.zext(64);\n    HighZeros = HighZeros.zext(64);\n  }\n\n  // The variable operand must be all zeros in the top bits to allow using the\n  // new, negative constant as the mask.\n  if (!CurDAG->MaskedValueIsZero(And0, HighZeros))\n    return false;\n\n  // Check if the mask is -1. In that case, this is an unnecessary instruction\n  // that escaped earlier analysis.\n  if (NegMaskVal.isAllOnesValue()) {\n    ReplaceNode(And, And0.getNode());\n    return true;\n  }\n\n  // A negative mask allows a smaller encoding. Create a new 'and' node.\n  SDValue NewMask = CurDAG->getConstant(NegMaskVal, SDLoc(And), VT);\n  insertDAGNode(*CurDAG, SDValue(And, 0), NewMask);\n  SDValue NewAnd = CurDAG->getNode(ISD::AND, SDLoc(And), VT, And0, NewMask);\n  ReplaceNode(And, NewAnd.getNode());\n  SelectCode(NewAnd.getNode());\n  return true;\n}\n\nstatic unsigned getVPTESTMOpc(MVT TestVT, bool IsTestN, bool FoldedLoad,\n                              bool FoldedBCast, bool Masked) {\n#define VPTESTM_CASE(VT, SUFFIX) \\\ncase MVT::VT: \\\n  if (Masked) \\\n    return IsTestN ? X86::VPTESTNM##SUFFIX##k: X86::VPTESTM##SUFFIX##k; \\\n  return IsTestN ? X86::VPTESTNM##SUFFIX : X86::VPTESTM##SUFFIX;\n\n\n#define VPTESTM_BROADCAST_CASES(SUFFIX) \\\ndefault: llvm_unreachable(\"Unexpected VT!\"); \\\nVPTESTM_CASE(v4i32, DZ128##SUFFIX) \\\nVPTESTM_CASE(v2i64, QZ128##SUFFIX) \\\nVPTESTM_CASE(v8i32, DZ256##SUFFIX) \\\nVPTESTM_CASE(v4i64, QZ256##SUFFIX) \\\nVPTESTM_CASE(v16i32, DZ##SUFFIX) \\\nVPTESTM_CASE(v8i64, QZ##SUFFIX)\n\n#define VPTESTM_FULL_CASES(SUFFIX) \\\nVPTESTM_BROADCAST_CASES(SUFFIX) \\\nVPTESTM_CASE(v16i8, BZ128##SUFFIX) \\\nVPTESTM_CASE(v8i16, WZ128##SUFFIX) \\\nVPTESTM_CASE(v32i8, BZ256##SUFFIX) \\\nVPTESTM_CASE(v16i16, WZ256##SUFFIX) \\\nVPTESTM_CASE(v64i8, BZ##SUFFIX) \\\nVPTESTM_CASE(v32i16, WZ##SUFFIX)\n\n  if (FoldedBCast) {\n    switch (TestVT.SimpleTy) {\n    VPTESTM_BROADCAST_CASES(rmb)\n    }\n  }\n\n  if (FoldedLoad) {\n    switch (TestVT.SimpleTy) {\n    VPTESTM_FULL_CASES(rm)\n    }\n  }\n\n  switch (TestVT.SimpleTy) {\n  VPTESTM_FULL_CASES(rr)\n  }\n\n#undef VPTESTM_FULL_CASES\n#undef VPTESTM_BROADCAST_CASES\n#undef VPTESTM_CASE\n}\n\n// Try to create VPTESTM instruction. If InMask is not null, it will be used\n// to form a masked operation.\nbool X86DAGToDAGISel::tryVPTESTM(SDNode *Root, SDValue Setcc,\n                                 SDValue InMask) {\n  assert(Subtarget->hasAVX512() && \"Expected AVX512!\");\n  assert(Setcc.getSimpleValueType().getVectorElementType() == MVT::i1 &&\n         \"Unexpected VT!\");\n\n  // Look for equal and not equal compares.\n  ISD::CondCode CC = cast<CondCodeSDNode>(Setcc.getOperand(2))->get();\n  if (CC != ISD::SETEQ && CC != ISD::SETNE)\n    return false;\n\n  SDValue SetccOp0 = Setcc.getOperand(0);\n  SDValue SetccOp1 = Setcc.getOperand(1);\n\n  // Canonicalize the all zero vector to the RHS.\n  if (ISD::isBuildVectorAllZeros(SetccOp0.getNode()))\n    std::swap(SetccOp0, SetccOp1);\n\n  // See if we're comparing against zero.\n  if (!ISD::isBuildVectorAllZeros(SetccOp1.getNode()))\n    return false;\n\n  SDValue N0 = SetccOp0;\n\n  MVT CmpVT = N0.getSimpleValueType();\n  MVT CmpSVT = CmpVT.getVectorElementType();\n\n  // Start with both operands the same. We'll try to refine this.\n  SDValue Src0 = N0;\n  SDValue Src1 = N0;\n\n  {\n    // Look through single use bitcasts.\n    SDValue N0Temp = N0;\n    if (N0Temp.getOpcode() == ISD::BITCAST && N0Temp.hasOneUse())\n      N0Temp = N0.getOperand(0);\n\n     // Look for single use AND.\n    if (N0Temp.getOpcode() == ISD::AND && N0Temp.hasOneUse()) {\n      Src0 = N0Temp.getOperand(0);\n      Src1 = N0Temp.getOperand(1);\n    }\n  }\n\n  // Without VLX we need to widen the operation.\n  bool Widen = !Subtarget->hasVLX() && !CmpVT.is512BitVector();\n\n  auto tryFoldLoadOrBCast = [&](SDNode *Root, SDNode *P, SDValue &L,\n                                SDValue &Base, SDValue &Scale, SDValue &Index,\n                                SDValue &Disp, SDValue &Segment) {\n    // If we need to widen, we can't fold the load.\n    if (!Widen)\n      if (tryFoldLoad(Root, P, L, Base, Scale, Index, Disp, Segment))\n        return true;\n\n    // If we didn't fold a load, try to match broadcast. No widening limitation\n    // for this. But only 32 and 64 bit types are supported.\n    if (CmpSVT != MVT::i32 && CmpSVT != MVT::i64)\n      return false;\n\n    // Look through single use bitcasts.\n    if (L.getOpcode() == ISD::BITCAST && L.hasOneUse()) {\n      P = L.getNode();\n      L = L.getOperand(0);\n    }\n\n    if (L.getOpcode() != X86ISD::VBROADCAST_LOAD)\n      return false;\n\n    auto *MemIntr = cast<MemIntrinsicSDNode>(L);\n    if (MemIntr->getMemoryVT().getSizeInBits() != CmpSVT.getSizeInBits())\n      return false;\n\n    return tryFoldBroadcast(Root, P, L, Base, Scale, Index, Disp, Segment);\n  };\n\n  // We can only fold loads if the sources are unique.\n  bool CanFoldLoads = Src0 != Src1;\n\n  bool FoldedLoad = false;\n  SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n  if (CanFoldLoads) {\n    FoldedLoad = tryFoldLoadOrBCast(Root, N0.getNode(), Src1, Tmp0, Tmp1, Tmp2,\n                                    Tmp3, Tmp4);\n    if (!FoldedLoad) {\n      // And is commutative.\n      FoldedLoad = tryFoldLoadOrBCast(Root, N0.getNode(), Src0, Tmp0, Tmp1,\n                                      Tmp2, Tmp3, Tmp4);\n      if (FoldedLoad)\n        std::swap(Src0, Src1);\n    }\n  }\n\n  bool FoldedBCast = FoldedLoad && Src1.getOpcode() == X86ISD::VBROADCAST_LOAD;\n\n  bool IsMasked = InMask.getNode() != nullptr;\n\n  SDLoc dl(Root);\n\n  MVT ResVT = Setcc.getSimpleValueType();\n  MVT MaskVT = ResVT;\n  if (Widen) {\n    // Widen the inputs using insert_subreg or copy_to_regclass.\n    unsigned Scale = CmpVT.is128BitVector() ? 4 : 2;\n    unsigned SubReg = CmpVT.is128BitVector() ? X86::sub_xmm : X86::sub_ymm;\n    unsigned NumElts = CmpVT.getVectorNumElements() * Scale;\n    CmpVT = MVT::getVectorVT(CmpSVT, NumElts);\n    MaskVT = MVT::getVectorVT(MVT::i1, NumElts);\n    SDValue ImplDef = SDValue(CurDAG->getMachineNode(X86::IMPLICIT_DEF, dl,\n                                                     CmpVT), 0);\n    Src0 = CurDAG->getTargetInsertSubreg(SubReg, dl, CmpVT, ImplDef, Src0);\n\n    if (!FoldedBCast)\n      Src1 = CurDAG->getTargetInsertSubreg(SubReg, dl, CmpVT, ImplDef, Src1);\n\n    if (IsMasked) {\n      // Widen the mask.\n      unsigned RegClass = TLI->getRegClassFor(MaskVT)->getID();\n      SDValue RC = CurDAG->getTargetConstant(RegClass, dl, MVT::i32);\n      InMask = SDValue(CurDAG->getMachineNode(TargetOpcode::COPY_TO_REGCLASS,\n                                              dl, MaskVT, InMask, RC), 0);\n    }\n  }\n\n  bool IsTestN = CC == ISD::SETEQ;\n  unsigned Opc = getVPTESTMOpc(CmpVT, IsTestN, FoldedLoad, FoldedBCast,\n                               IsMasked);\n\n  MachineSDNode *CNode;\n  if (FoldedLoad) {\n    SDVTList VTs = CurDAG->getVTList(MaskVT, MVT::Other);\n\n    if (IsMasked) {\n      SDValue Ops[] = { InMask, Src0, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4,\n                        Src1.getOperand(0) };\n      CNode = CurDAG->getMachineNode(Opc, dl, VTs, Ops);\n    } else {\n      SDValue Ops[] = { Src0, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4,\n                        Src1.getOperand(0) };\n      CNode = CurDAG->getMachineNode(Opc, dl, VTs, Ops);\n    }\n\n    // Update the chain.\n    ReplaceUses(Src1.getValue(1), SDValue(CNode, 1));\n    // Record the mem-refs\n    CurDAG->setNodeMemRefs(CNode, {cast<MemSDNode>(Src1)->getMemOperand()});\n  } else {\n    if (IsMasked)\n      CNode = CurDAG->getMachineNode(Opc, dl, MaskVT, InMask, Src0, Src1);\n    else\n      CNode = CurDAG->getMachineNode(Opc, dl, MaskVT, Src0, Src1);\n  }\n\n  // If we widened, we need to shrink the mask VT.\n  if (Widen) {\n    unsigned RegClass = TLI->getRegClassFor(ResVT)->getID();\n    SDValue RC = CurDAG->getTargetConstant(RegClass, dl, MVT::i32);\n    CNode = CurDAG->getMachineNode(TargetOpcode::COPY_TO_REGCLASS,\n                                   dl, ResVT, SDValue(CNode, 0), RC);\n  }\n\n  ReplaceUses(SDValue(Root, 0), SDValue(CNode, 0));\n  CurDAG->RemoveDeadNode(Root);\n  return true;\n}\n\n// Try to match the bitselect pattern (or (and A, B), (andn A, C)). Turn it\n// into vpternlog.\nbool X86DAGToDAGISel::tryMatchBitSelect(SDNode *N) {\n  assert(N->getOpcode() == ISD::OR && \"Unexpected opcode!\");\n\n  MVT NVT = N->getSimpleValueType(0);\n\n  // Make sure we support VPTERNLOG.\n  if (!NVT.isVector() || !Subtarget->hasAVX512())\n    return false;\n\n  // We need VLX for 128/256-bit.\n  if (!(Subtarget->hasVLX() || NVT.is512BitVector()))\n    return false;\n\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n\n  // Canonicalize AND to LHS.\n  if (N1.getOpcode() == ISD::AND)\n    std::swap(N0, N1);\n\n  if (N0.getOpcode() != ISD::AND ||\n      N1.getOpcode() != X86ISD::ANDNP ||\n      !N0.hasOneUse() || !N1.hasOneUse())\n    return false;\n\n  // ANDN is not commutable, use it to pick down A and C.\n  SDValue A = N1.getOperand(0);\n  SDValue C = N1.getOperand(1);\n\n  // AND is commutable, if one operand matches A, the other operand is B.\n  // Otherwise this isn't a match.\n  SDValue B;\n  if (N0.getOperand(0) == A)\n    B = N0.getOperand(1);\n  else if (N0.getOperand(1) == A)\n    B = N0.getOperand(0);\n  else\n    return false;\n\n  SDLoc dl(N);\n  SDValue Imm = CurDAG->getTargetConstant(0xCA, dl, MVT::i8);\n  SDValue Ternlog = CurDAG->getNode(X86ISD::VPTERNLOG, dl, NVT, A, B, C, Imm);\n  ReplaceNode(N, Ternlog.getNode());\n\n  return matchVPTERNLOG(Ternlog.getNode(), Ternlog.getNode(), Ternlog.getNode(),\n                        A, B, C, 0xCA);\n}\n\nvoid X86DAGToDAGISel::Select(SDNode *Node) {\n  MVT NVT = Node->getSimpleValueType(0);\n  unsigned Opcode = Node->getOpcode();\n  SDLoc dl(Node);\n\n  if (Node->isMachineOpcode()) {\n    LLVM_DEBUG(dbgs() << \"== \"; Node->dump(CurDAG); dbgs() << '\\n');\n    Node->setNodeId(-1);\n    return;   // Already selected.\n  }\n\n  switch (Opcode) {\n  default: break;\n  case ISD::INTRINSIC_W_CHAIN: {\n    unsigned IntNo = Node->getConstantOperandVal(1);\n    switch (IntNo) {\n    default: break;\n    case Intrinsic::x86_encodekey128:\n    case Intrinsic::x86_encodekey256: {\n      if (!Subtarget->hasKL())\n        break;\n\n      unsigned Opcode;\n      switch (IntNo) {\n      default: llvm_unreachable(\"Impossible intrinsic\");\n      case Intrinsic::x86_encodekey128: Opcode = X86::ENCODEKEY128; break;\n      case Intrinsic::x86_encodekey256: Opcode = X86::ENCODEKEY256; break;\n      }\n\n      SDValue Chain = Node->getOperand(0);\n      Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM0, Node->getOperand(3),\n                                   SDValue());\n      if (Opcode == X86::ENCODEKEY256)\n        Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM1, Node->getOperand(4),\n                                     Chain.getValue(1));\n\n      MachineSDNode *Res = CurDAG->getMachineNode(\n          Opcode, dl, Node->getVTList(),\n          {Node->getOperand(2), Chain, Chain.getValue(1)});\n      ReplaceNode(Node, Res);\n      return;\n    }\n    case Intrinsic::x86_tileloadd64_internal: {\n      if (!Subtarget->hasAMXTILE())\n        break;\n      unsigned Opc = X86::PTILELOADDV;\n      // _tile_loadd_internal(row, col, buf, STRIDE)\n      SDValue Base = Node->getOperand(4);\n      SDValue Scale = getI8Imm(1, dl);\n      SDValue Index = Node->getOperand(5);\n      SDValue Disp = CurDAG->getTargetConstant(0, dl, MVT::i32);\n      SDValue Segment = CurDAG->getRegister(0, MVT::i16);\n      SDValue Chain = Node->getOperand(0);\n      MachineSDNode *CNode;\n      SDValue Ops[] = {Node->getOperand(2),\n                       Node->getOperand(3),\n                       Base,\n                       Scale,\n                       Index,\n                       Disp,\n                       Segment,\n                       Chain};\n      CNode = CurDAG->getMachineNode(Opc, dl, {MVT::x86amx, MVT::Other}, Ops);\n      ReplaceNode(Node, CNode);\n      return;\n    }\n    case Intrinsic::x86_tdpbssd_internal: {\n      if (!Subtarget->hasAMXTILE())\n        break;\n      SDValue Chain = Node->getOperand(0);\n      unsigned Opc = X86::PTDPBSSDV;\n      SDValue Ops[] = {Node->getOperand(2),\n                       Node->getOperand(3),\n                       Node->getOperand(4),\n                       Node->getOperand(5),\n                       Node->getOperand(6),\n                       Node->getOperand(7),\n                       Chain};\n      MachineSDNode *CNode =\n          CurDAG->getMachineNode(Opc, dl, {MVT::x86amx, MVT::Other}, Ops);\n      ReplaceNode(Node, CNode);\n      return;\n    }\n    case Intrinsic::x86_tilezero_internal: {\n      if (!Subtarget->hasAMXTILE())\n        break;\n      unsigned Opc = X86::PTILEZEROV;\n      SDValue Chain = Node->getOperand(0);\n      SDValue Ops[] = {Node->getOperand(2), Node->getOperand(3), Chain};\n      MachineSDNode *CNode =\n          CurDAG->getMachineNode(Opc, dl, {MVT::x86amx, MVT::Other}, Ops);\n      ReplaceNode(Node, CNode);\n      return;\n    }\n    }\n    break;\n  }\n  case ISD::INTRINSIC_VOID: {\n    unsigned IntNo = Node->getConstantOperandVal(1);\n    switch (IntNo) {\n    default: break;\n    case Intrinsic::x86_sse3_monitor:\n    case Intrinsic::x86_monitorx:\n    case Intrinsic::x86_clzero: {\n      bool Use64BitPtr = Node->getOperand(2).getValueType() == MVT::i64;\n\n      unsigned Opc = 0;\n      switch (IntNo) {\n      default: llvm_unreachable(\"Unexpected intrinsic!\");\n      case Intrinsic::x86_sse3_monitor:\n        if (!Subtarget->hasSSE3())\n          break;\n        Opc = Use64BitPtr ? X86::MONITOR64rrr : X86::MONITOR32rrr;\n        break;\n      case Intrinsic::x86_monitorx:\n        if (!Subtarget->hasMWAITX())\n          break;\n        Opc = Use64BitPtr ? X86::MONITORX64rrr : X86::MONITORX32rrr;\n        break;\n      case Intrinsic::x86_clzero:\n        if (!Subtarget->hasCLZERO())\n          break;\n        Opc = Use64BitPtr ? X86::CLZERO64r : X86::CLZERO32r;\n        break;\n      }\n\n      if (Opc) {\n        unsigned PtrReg = Use64BitPtr ? X86::RAX : X86::EAX;\n        SDValue Chain = CurDAG->getCopyToReg(Node->getOperand(0), dl, PtrReg,\n                                             Node->getOperand(2), SDValue());\n        SDValue InFlag = Chain.getValue(1);\n\n        if (IntNo == Intrinsic::x86_sse3_monitor ||\n            IntNo == Intrinsic::x86_monitorx) {\n          // Copy the other two operands to ECX and EDX.\n          Chain = CurDAG->getCopyToReg(Chain, dl, X86::ECX, Node->getOperand(3),\n                                       InFlag);\n          InFlag = Chain.getValue(1);\n          Chain = CurDAG->getCopyToReg(Chain, dl, X86::EDX, Node->getOperand(4),\n                                       InFlag);\n          InFlag = Chain.getValue(1);\n        }\n\n        MachineSDNode *CNode = CurDAG->getMachineNode(Opc, dl, MVT::Other,\n                                                      { Chain, InFlag});\n        ReplaceNode(Node, CNode);\n        return;\n      }\n\n      break;\n    }\n    case Intrinsic::x86_tilestored64_internal: {\n      unsigned Opc = X86::PTILESTOREDV;\n      // _tile_stored_internal(row, col, buf, STRIDE, c)\n      SDValue Base = Node->getOperand(4);\n      SDValue Scale = getI8Imm(1, dl);\n      SDValue Index = Node->getOperand(5);\n      SDValue Disp = CurDAG->getTargetConstant(0, dl, MVT::i32);\n      SDValue Segment = CurDAG->getRegister(0, MVT::i16);\n      SDValue Chain = Node->getOperand(0);\n      MachineSDNode *CNode;\n      SDValue Ops[] = {Node->getOperand(2),\n                       Node->getOperand(3),\n                       Base,\n                       Scale,\n                       Index,\n                       Disp,\n                       Segment,\n                       Node->getOperand(6),\n                       Chain};\n      CNode = CurDAG->getMachineNode(Opc, dl, MVT::Other, Ops);\n      ReplaceNode(Node, CNode);\n      return;\n    }\n    case Intrinsic::x86_tileloadd64:\n    case Intrinsic::x86_tileloaddt164:\n    case Intrinsic::x86_tilestored64: {\n      if (!Subtarget->hasAMXTILE())\n        break;\n      unsigned Opc;\n      switch (IntNo) {\n      default: llvm_unreachable(\"Unexpected intrinsic!\");\n      case Intrinsic::x86_tileloadd64:   Opc = X86::PTILELOADD; break;\n      case Intrinsic::x86_tileloaddt164: Opc = X86::PTILELOADDT1; break;\n      case Intrinsic::x86_tilestored64:  Opc = X86::PTILESTORED; break;\n      }\n      // FIXME: Match displacement and scale.\n      unsigned TIndex = Node->getConstantOperandVal(2);\n      SDValue TReg = getI8Imm(TIndex, dl);\n      SDValue Base = Node->getOperand(3);\n      SDValue Scale = getI8Imm(1, dl);\n      SDValue Index = Node->getOperand(4);\n      SDValue Disp = CurDAG->getTargetConstant(0, dl, MVT::i32);\n      SDValue Segment = CurDAG->getRegister(0, MVT::i16);\n      SDValue Chain = Node->getOperand(0);\n      MachineSDNode *CNode;\n      if (Opc == X86::PTILESTORED) {\n        SDValue Ops[] = { Base, Scale, Index, Disp, Segment, TReg, Chain };\n        CNode = CurDAG->getMachineNode(Opc, dl, MVT::Other, Ops);\n      } else {\n        SDValue Ops[] = { TReg, Base, Scale, Index, Disp, Segment, Chain };\n        CNode = CurDAG->getMachineNode(Opc, dl, MVT::Other, Ops);\n      }\n      ReplaceNode(Node, CNode);\n      return;\n    }\n    }\n    break;\n  }\n  case ISD::BRIND: {\n    if (Subtarget->isTargetNaCl())\n      // NaCl has its own pass where jmp %r32 are converted to jmp %r64. We\n      // leave the instruction alone.\n      break;\n    if (Subtarget->isTarget64BitILP32()) {\n      // Converts a 32-bit register to a 64-bit, zero-extended version of\n      // it. This is needed because x86-64 can do many things, but jmp %r32\n      // ain't one of them.\n      SDValue Target = Node->getOperand(1);\n      assert(Target.getValueType() == MVT::i32 && \"Unexpected VT!\");\n      SDValue ZextTarget = CurDAG->getZExtOrTrunc(Target, dl, MVT::i64);\n      SDValue Brind = CurDAG->getNode(ISD::BRIND, dl, MVT::Other,\n                                      Node->getOperand(0), ZextTarget);\n      ReplaceNode(Node, Brind.getNode());\n      SelectCode(ZextTarget.getNode());\n      SelectCode(Brind.getNode());\n      return;\n    }\n    break;\n  }\n  case X86ISD::GlobalBaseReg:\n    ReplaceNode(Node, getGlobalBaseReg());\n    return;\n\n  case ISD::BITCAST:\n    // Just drop all 128/256/512-bit bitcasts.\n    if (NVT.is512BitVector() || NVT.is256BitVector() || NVT.is128BitVector() ||\n        NVT == MVT::f128) {\n      ReplaceUses(SDValue(Node, 0), Node->getOperand(0));\n      CurDAG->RemoveDeadNode(Node);\n      return;\n    }\n    break;\n\n  case ISD::SRL:\n    if (matchBitExtract(Node))\n      return;\n    LLVM_FALLTHROUGH;\n  case ISD::SRA:\n  case ISD::SHL:\n    if (tryShiftAmountMod(Node))\n      return;\n    break;\n\n  case X86ISD::VPTERNLOG: {\n    uint8_t Imm = cast<ConstantSDNode>(Node->getOperand(3))->getZExtValue();\n    if (matchVPTERNLOG(Node, Node, Node, Node->getOperand(0),\n                       Node->getOperand(1), Node->getOperand(2), Imm))\n      return;\n    break;\n  }\n\n  case X86ISD::ANDNP:\n    if (tryVPTERNLOG(Node))\n      return;\n    break;\n\n  case ISD::AND:\n    if (NVT.isVector() && NVT.getVectorElementType() == MVT::i1) {\n      // Try to form a masked VPTESTM. Operands can be in either order.\n      SDValue N0 = Node->getOperand(0);\n      SDValue N1 = Node->getOperand(1);\n      if (N0.getOpcode() == ISD::SETCC && N0.hasOneUse() &&\n          tryVPTESTM(Node, N0, N1))\n        return;\n      if (N1.getOpcode() == ISD::SETCC && N1.hasOneUse() &&\n          tryVPTESTM(Node, N1, N0))\n        return;\n    }\n\n    if (MachineSDNode *NewNode = matchBEXTRFromAndImm(Node)) {\n      ReplaceUses(SDValue(Node, 0), SDValue(NewNode, 0));\n      CurDAG->RemoveDeadNode(Node);\n      return;\n    }\n    if (matchBitExtract(Node))\n      return;\n    if (AndImmShrink && shrinkAndImmediate(Node))\n      return;\n\n    LLVM_FALLTHROUGH;\n  case ISD::OR:\n  case ISD::XOR:\n    if (tryShrinkShlLogicImm(Node))\n      return;\n    if (Opcode == ISD::OR && tryMatchBitSelect(Node))\n      return;\n    if (tryVPTERNLOG(Node))\n      return;\n\n    LLVM_FALLTHROUGH;\n  case ISD::ADD:\n  case ISD::SUB: {\n    // Try to avoid folding immediates with multiple uses for optsize.\n    // This code tries to select to register form directly to avoid going\n    // through the isel table which might fold the immediate. We can't change\n    // the patterns on the add/sub/and/or/xor with immediate paterns in the\n    // tablegen files to check immediate use count without making the patterns\n    // unavailable to the fast-isel table.\n    if (!CurDAG->shouldOptForSize())\n      break;\n\n    // Only handle i8/i16/i32/i64.\n    if (NVT != MVT::i8 && NVT != MVT::i16 && NVT != MVT::i32 && NVT != MVT::i64)\n      break;\n\n    SDValue N0 = Node->getOperand(0);\n    SDValue N1 = Node->getOperand(1);\n\n    ConstantSDNode *Cst = dyn_cast<ConstantSDNode>(N1);\n    if (!Cst)\n      break;\n\n    int64_t Val = Cst->getSExtValue();\n\n    // Make sure its an immediate that is considered foldable.\n    // FIXME: Handle unsigned 32 bit immediates for 64-bit AND.\n    if (!isInt<8>(Val) && !isInt<32>(Val))\n      break;\n\n    // If this can match to INC/DEC, let it go.\n    if (Opcode == ISD::ADD && (Val == 1 || Val == -1))\n      break;\n\n    // Check if we should avoid folding this immediate.\n    if (!shouldAvoidImmediateInstFormsForSize(N1.getNode()))\n      break;\n\n    // We should not fold the immediate. So we need a register form instead.\n    unsigned ROpc, MOpc;\n    switch (NVT.SimpleTy) {\n    default: llvm_unreachable(\"Unexpected VT!\");\n    case MVT::i8:\n      switch (Opcode) {\n      default: llvm_unreachable(\"Unexpected opcode!\");\n      case ISD::ADD: ROpc = X86::ADD8rr; MOpc = X86::ADD8rm; break;\n      case ISD::SUB: ROpc = X86::SUB8rr; MOpc = X86::SUB8rm; break;\n      case ISD::AND: ROpc = X86::AND8rr; MOpc = X86::AND8rm; break;\n      case ISD::OR:  ROpc = X86::OR8rr;  MOpc = X86::OR8rm;  break;\n      case ISD::XOR: ROpc = X86::XOR8rr; MOpc = X86::XOR8rm; break;\n      }\n      break;\n    case MVT::i16:\n      switch (Opcode) {\n      default: llvm_unreachable(\"Unexpected opcode!\");\n      case ISD::ADD: ROpc = X86::ADD16rr; MOpc = X86::ADD16rm; break;\n      case ISD::SUB: ROpc = X86::SUB16rr; MOpc = X86::SUB16rm; break;\n      case ISD::AND: ROpc = X86::AND16rr; MOpc = X86::AND16rm; break;\n      case ISD::OR:  ROpc = X86::OR16rr;  MOpc = X86::OR16rm;  break;\n      case ISD::XOR: ROpc = X86::XOR16rr; MOpc = X86::XOR16rm; break;\n      }\n      break;\n    case MVT::i32:\n      switch (Opcode) {\n      default: llvm_unreachable(\"Unexpected opcode!\");\n      case ISD::ADD: ROpc = X86::ADD32rr; MOpc = X86::ADD32rm; break;\n      case ISD::SUB: ROpc = X86::SUB32rr; MOpc = X86::SUB32rm; break;\n      case ISD::AND: ROpc = X86::AND32rr; MOpc = X86::AND32rm; break;\n      case ISD::OR:  ROpc = X86::OR32rr;  MOpc = X86::OR32rm;  break;\n      case ISD::XOR: ROpc = X86::XOR32rr; MOpc = X86::XOR32rm; break;\n      }\n      break;\n    case MVT::i64:\n      switch (Opcode) {\n      default: llvm_unreachable(\"Unexpected opcode!\");\n      case ISD::ADD: ROpc = X86::ADD64rr; MOpc = X86::ADD64rm; break;\n      case ISD::SUB: ROpc = X86::SUB64rr; MOpc = X86::SUB64rm; break;\n      case ISD::AND: ROpc = X86::AND64rr; MOpc = X86::AND64rm; break;\n      case ISD::OR:  ROpc = X86::OR64rr;  MOpc = X86::OR64rm;  break;\n      case ISD::XOR: ROpc = X86::XOR64rr; MOpc = X86::XOR64rm; break;\n      }\n      break;\n    }\n\n    // Ok this is a AND/OR/XOR/ADD/SUB with constant.\n\n    // If this is a not a subtract, we can still try to fold a load.\n    if (Opcode != ISD::SUB) {\n      SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n      if (tryFoldLoad(Node, N0, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4)) {\n        SDValue Ops[] = { N1, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, N0.getOperand(0) };\n        SDVTList VTs = CurDAG->getVTList(NVT, MVT::i32, MVT::Other);\n        MachineSDNode *CNode = CurDAG->getMachineNode(MOpc, dl, VTs, Ops);\n        // Update the chain.\n        ReplaceUses(N0.getValue(1), SDValue(CNode, 2));\n        // Record the mem-refs\n        CurDAG->setNodeMemRefs(CNode, {cast<LoadSDNode>(N0)->getMemOperand()});\n        ReplaceUses(SDValue(Node, 0), SDValue(CNode, 0));\n        CurDAG->RemoveDeadNode(Node);\n        return;\n      }\n    }\n\n    CurDAG->SelectNodeTo(Node, ROpc, NVT, MVT::i32, N0, N1);\n    return;\n  }\n\n  case X86ISD::SMUL:\n    // i16/i32/i64 are handled with isel patterns.\n    if (NVT != MVT::i8)\n      break;\n    LLVM_FALLTHROUGH;\n  case X86ISD::UMUL: {\n    SDValue N0 = Node->getOperand(0);\n    SDValue N1 = Node->getOperand(1);\n\n    unsigned LoReg, ROpc, MOpc;\n    switch (NVT.SimpleTy) {\n    default: llvm_unreachable(\"Unsupported VT!\");\n    case MVT::i8:\n      LoReg = X86::AL;\n      ROpc = Opcode == X86ISD::SMUL ? X86::IMUL8r : X86::MUL8r;\n      MOpc = Opcode == X86ISD::SMUL ? X86::IMUL8m : X86::MUL8m;\n      break;\n    case MVT::i16:\n      LoReg = X86::AX;\n      ROpc = X86::MUL16r;\n      MOpc = X86::MUL16m;\n      break;\n    case MVT::i32:\n      LoReg = X86::EAX;\n      ROpc = X86::MUL32r;\n      MOpc = X86::MUL32m;\n      break;\n    case MVT::i64:\n      LoReg = X86::RAX;\n      ROpc = X86::MUL64r;\n      MOpc = X86::MUL64m;\n      break;\n    }\n\n    SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n    bool FoldedLoad = tryFoldLoad(Node, N1, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4);\n    // Multiply is commutative.\n    if (!FoldedLoad) {\n      FoldedLoad = tryFoldLoad(Node, N0, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4);\n      if (FoldedLoad)\n        std::swap(N0, N1);\n    }\n\n    SDValue InFlag = CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl, LoReg,\n                                          N0, SDValue()).getValue(1);\n\n    MachineSDNode *CNode;\n    if (FoldedLoad) {\n      // i16/i32/i64 use an instruction that produces a low and high result even\n      // though only the low result is used.\n      SDVTList VTs;\n      if (NVT == MVT::i8)\n        VTs = CurDAG->getVTList(NVT, MVT::i32, MVT::Other);\n      else\n        VTs = CurDAG->getVTList(NVT, NVT, MVT::i32, MVT::Other);\n\n      SDValue Ops[] = { Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, N1.getOperand(0),\n                        InFlag };\n      CNode = CurDAG->getMachineNode(MOpc, dl, VTs, Ops);\n\n      // Update the chain.\n      ReplaceUses(N1.getValue(1), SDValue(CNode, NVT == MVT::i8 ? 2 : 3));\n      // Record the mem-refs\n      CurDAG->setNodeMemRefs(CNode, {cast<LoadSDNode>(N1)->getMemOperand()});\n    } else {\n      // i16/i32/i64 use an instruction that produces a low and high result even\n      // though only the low result is used.\n      SDVTList VTs;\n      if (NVT == MVT::i8)\n        VTs = CurDAG->getVTList(NVT, MVT::i32);\n      else\n        VTs = CurDAG->getVTList(NVT, NVT, MVT::i32);\n\n      CNode = CurDAG->getMachineNode(ROpc, dl, VTs, {N1, InFlag});\n    }\n\n    ReplaceUses(SDValue(Node, 0), SDValue(CNode, 0));\n    ReplaceUses(SDValue(Node, 1), SDValue(CNode, NVT == MVT::i8 ? 1 : 2));\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n\n  case ISD::SMUL_LOHI:\n  case ISD::UMUL_LOHI: {\n    SDValue N0 = Node->getOperand(0);\n    SDValue N1 = Node->getOperand(1);\n\n    unsigned Opc, MOpc;\n    unsigned LoReg, HiReg;\n    bool IsSigned = Opcode == ISD::SMUL_LOHI;\n    bool UseMULX = !IsSigned && Subtarget->hasBMI2();\n    bool UseMULXHi = UseMULX && SDValue(Node, 0).use_empty();\n    switch (NVT.SimpleTy) {\n    default: llvm_unreachable(\"Unsupported VT!\");\n    case MVT::i32:\n      Opc  = UseMULXHi ? X86::MULX32Hrr :\n             UseMULX ? X86::MULX32rr :\n             IsSigned ? X86::IMUL32r : X86::MUL32r;\n      MOpc = UseMULXHi ? X86::MULX32Hrm :\n             UseMULX ? X86::MULX32rm :\n             IsSigned ? X86::IMUL32m : X86::MUL32m;\n      LoReg = UseMULX ? X86::EDX : X86::EAX;\n      HiReg = X86::EDX;\n      break;\n    case MVT::i64:\n      Opc  = UseMULXHi ? X86::MULX64Hrr :\n             UseMULX ? X86::MULX64rr :\n             IsSigned ? X86::IMUL64r : X86::MUL64r;\n      MOpc = UseMULXHi ? X86::MULX64Hrm :\n             UseMULX ? X86::MULX64rm :\n             IsSigned ? X86::IMUL64m : X86::MUL64m;\n      LoReg = UseMULX ? X86::RDX : X86::RAX;\n      HiReg = X86::RDX;\n      break;\n    }\n\n    SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n    bool foldedLoad = tryFoldLoad(Node, N1, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4);\n    // Multiply is commmutative.\n    if (!foldedLoad) {\n      foldedLoad = tryFoldLoad(Node, N0, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4);\n      if (foldedLoad)\n        std::swap(N0, N1);\n    }\n\n    SDValue InFlag = CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl, LoReg,\n                                          N0, SDValue()).getValue(1);\n    SDValue ResHi, ResLo;\n    if (foldedLoad) {\n      SDValue Chain;\n      MachineSDNode *CNode = nullptr;\n      SDValue Ops[] = { Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, N1.getOperand(0),\n                        InFlag };\n      if (UseMULXHi) {\n        SDVTList VTs = CurDAG->getVTList(NVT, MVT::Other);\n        CNode = CurDAG->getMachineNode(MOpc, dl, VTs, Ops);\n        ResHi = SDValue(CNode, 0);\n        Chain = SDValue(CNode, 1);\n      } else if (UseMULX) {\n        SDVTList VTs = CurDAG->getVTList(NVT, NVT, MVT::Other);\n        CNode = CurDAG->getMachineNode(MOpc, dl, VTs, Ops);\n        ResHi = SDValue(CNode, 0);\n        ResLo = SDValue(CNode, 1);\n        Chain = SDValue(CNode, 2);\n      } else {\n        SDVTList VTs = CurDAG->getVTList(MVT::Other, MVT::Glue);\n        CNode = CurDAG->getMachineNode(MOpc, dl, VTs, Ops);\n        Chain = SDValue(CNode, 0);\n        InFlag = SDValue(CNode, 1);\n      }\n\n      // Update the chain.\n      ReplaceUses(N1.getValue(1), Chain);\n      // Record the mem-refs\n      CurDAG->setNodeMemRefs(CNode, {cast<LoadSDNode>(N1)->getMemOperand()});\n    } else {\n      SDValue Ops[] = { N1, InFlag };\n      if (UseMULXHi) {\n        SDVTList VTs = CurDAG->getVTList(NVT);\n        SDNode *CNode = CurDAG->getMachineNode(Opc, dl, VTs, Ops);\n        ResHi = SDValue(CNode, 0);\n      } else if (UseMULX) {\n        SDVTList VTs = CurDAG->getVTList(NVT, NVT);\n        SDNode *CNode = CurDAG->getMachineNode(Opc, dl, VTs, Ops);\n        ResHi = SDValue(CNode, 0);\n        ResLo = SDValue(CNode, 1);\n      } else {\n        SDVTList VTs = CurDAG->getVTList(MVT::Glue);\n        SDNode *CNode = CurDAG->getMachineNode(Opc, dl, VTs, Ops);\n        InFlag = SDValue(CNode, 0);\n      }\n    }\n\n    // Copy the low half of the result, if it is needed.\n    if (!SDValue(Node, 0).use_empty()) {\n      if (!ResLo) {\n        assert(LoReg && \"Register for low half is not defined!\");\n        ResLo = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), dl, LoReg,\n                                       NVT, InFlag);\n        InFlag = ResLo.getValue(2);\n      }\n      ReplaceUses(SDValue(Node, 0), ResLo);\n      LLVM_DEBUG(dbgs() << \"=> \"; ResLo.getNode()->dump(CurDAG);\n                 dbgs() << '\\n');\n    }\n    // Copy the high half of the result, if it is needed.\n    if (!SDValue(Node, 1).use_empty()) {\n      if (!ResHi) {\n        assert(HiReg && \"Register for high half is not defined!\");\n        ResHi = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), dl, HiReg,\n                                       NVT, InFlag);\n        InFlag = ResHi.getValue(2);\n      }\n      ReplaceUses(SDValue(Node, 1), ResHi);\n      LLVM_DEBUG(dbgs() << \"=> \"; ResHi.getNode()->dump(CurDAG);\n                 dbgs() << '\\n');\n    }\n\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n\n  case ISD::SDIVREM:\n  case ISD::UDIVREM: {\n    SDValue N0 = Node->getOperand(0);\n    SDValue N1 = Node->getOperand(1);\n\n    unsigned ROpc, MOpc;\n    bool isSigned = Opcode == ISD::SDIVREM;\n    if (!isSigned) {\n      switch (NVT.SimpleTy) {\n      default: llvm_unreachable(\"Unsupported VT!\");\n      case MVT::i8:  ROpc = X86::DIV8r;  MOpc = X86::DIV8m;  break;\n      case MVT::i16: ROpc = X86::DIV16r; MOpc = X86::DIV16m; break;\n      case MVT::i32: ROpc = X86::DIV32r; MOpc = X86::DIV32m; break;\n      case MVT::i64: ROpc = X86::DIV64r; MOpc = X86::DIV64m; break;\n      }\n    } else {\n      switch (NVT.SimpleTy) {\n      default: llvm_unreachable(\"Unsupported VT!\");\n      case MVT::i8:  ROpc = X86::IDIV8r;  MOpc = X86::IDIV8m;  break;\n      case MVT::i16: ROpc = X86::IDIV16r; MOpc = X86::IDIV16m; break;\n      case MVT::i32: ROpc = X86::IDIV32r; MOpc = X86::IDIV32m; break;\n      case MVT::i64: ROpc = X86::IDIV64r; MOpc = X86::IDIV64m; break;\n      }\n    }\n\n    unsigned LoReg, HiReg, ClrReg;\n    unsigned SExtOpcode;\n    switch (NVT.SimpleTy) {\n    default: llvm_unreachable(\"Unsupported VT!\");\n    case MVT::i8:\n      LoReg = X86::AL;  ClrReg = HiReg = X86::AH;\n      SExtOpcode = 0; // Not used.\n      break;\n    case MVT::i16:\n      LoReg = X86::AX;  HiReg = X86::DX;\n      ClrReg = X86::DX;\n      SExtOpcode = X86::CWD;\n      break;\n    case MVT::i32:\n      LoReg = X86::EAX; ClrReg = HiReg = X86::EDX;\n      SExtOpcode = X86::CDQ;\n      break;\n    case MVT::i64:\n      LoReg = X86::RAX; ClrReg = HiReg = X86::RDX;\n      SExtOpcode = X86::CQO;\n      break;\n    }\n\n    SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n    bool foldedLoad = tryFoldLoad(Node, N1, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4);\n    bool signBitIsZero = CurDAG->SignBitIsZero(N0);\n\n    SDValue InFlag;\n    if (NVT == MVT::i8) {\n      // Special case for div8, just use a move with zero extension to AX to\n      // clear the upper 8 bits (AH).\n      SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, Chain;\n      MachineSDNode *Move;\n      if (tryFoldLoad(Node, N0, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4)) {\n        SDValue Ops[] = { Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, N0.getOperand(0) };\n        unsigned Opc = (isSigned && !signBitIsZero) ? X86::MOVSX16rm8\n                                                    : X86::MOVZX16rm8;\n        Move = CurDAG->getMachineNode(Opc, dl, MVT::i16, MVT::Other, Ops);\n        Chain = SDValue(Move, 1);\n        ReplaceUses(N0.getValue(1), Chain);\n        // Record the mem-refs\n        CurDAG->setNodeMemRefs(Move, {cast<LoadSDNode>(N0)->getMemOperand()});\n      } else {\n        unsigned Opc = (isSigned && !signBitIsZero) ? X86::MOVSX16rr8\n                                                    : X86::MOVZX16rr8;\n        Move = CurDAG->getMachineNode(Opc, dl, MVT::i16, N0);\n        Chain = CurDAG->getEntryNode();\n      }\n      Chain  = CurDAG->getCopyToReg(Chain, dl, X86::AX, SDValue(Move, 0),\n                                    SDValue());\n      InFlag = Chain.getValue(1);\n    } else {\n      InFlag =\n        CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl,\n                             LoReg, N0, SDValue()).getValue(1);\n      if (isSigned && !signBitIsZero) {\n        // Sign extend the low part into the high part.\n        InFlag =\n          SDValue(CurDAG->getMachineNode(SExtOpcode, dl, MVT::Glue, InFlag),0);\n      } else {\n        // Zero out the high part, effectively zero extending the input.\n        SDVTList VTs = CurDAG->getVTList(MVT::i32, MVT::i32);\n        SDValue ClrNode =\n            SDValue(CurDAG->getMachineNode(X86::MOV32r0, dl, VTs, None), 0);\n        switch (NVT.SimpleTy) {\n        case MVT::i16:\n          ClrNode =\n              SDValue(CurDAG->getMachineNode(\n                          TargetOpcode::EXTRACT_SUBREG, dl, MVT::i16, ClrNode,\n                          CurDAG->getTargetConstant(X86::sub_16bit, dl,\n                                                    MVT::i32)),\n                      0);\n          break;\n        case MVT::i32:\n          break;\n        case MVT::i64:\n          ClrNode =\n              SDValue(CurDAG->getMachineNode(\n                          TargetOpcode::SUBREG_TO_REG, dl, MVT::i64,\n                          CurDAG->getTargetConstant(0, dl, MVT::i64), ClrNode,\n                          CurDAG->getTargetConstant(X86::sub_32bit, dl,\n                                                    MVT::i32)),\n                      0);\n          break;\n        default:\n          llvm_unreachable(\"Unexpected division source\");\n        }\n\n        InFlag = CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl, ClrReg,\n                                      ClrNode, InFlag).getValue(1);\n      }\n    }\n\n    if (foldedLoad) {\n      SDValue Ops[] = { Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, N1.getOperand(0),\n                        InFlag };\n      MachineSDNode *CNode =\n        CurDAG->getMachineNode(MOpc, dl, MVT::Other, MVT::Glue, Ops);\n      InFlag = SDValue(CNode, 1);\n      // Update the chain.\n      ReplaceUses(N1.getValue(1), SDValue(CNode, 0));\n      // Record the mem-refs\n      CurDAG->setNodeMemRefs(CNode, {cast<LoadSDNode>(N1)->getMemOperand()});\n    } else {\n      InFlag =\n        SDValue(CurDAG->getMachineNode(ROpc, dl, MVT::Glue, N1, InFlag), 0);\n    }\n\n    // Prevent use of AH in a REX instruction by explicitly copying it to\n    // an ABCD_L register.\n    //\n    // The current assumption of the register allocator is that isel\n    // won't generate explicit references to the GR8_ABCD_H registers. If\n    // the allocator and/or the backend get enhanced to be more robust in\n    // that regard, this can be, and should be, removed.\n    if (HiReg == X86::AH && !SDValue(Node, 1).use_empty()) {\n      SDValue AHCopy = CurDAG->getRegister(X86::AH, MVT::i8);\n      unsigned AHExtOpcode =\n          isSigned ? X86::MOVSX32rr8_NOREX : X86::MOVZX32rr8_NOREX;\n\n      SDNode *RNode = CurDAG->getMachineNode(AHExtOpcode, dl, MVT::i32,\n                                             MVT::Glue, AHCopy, InFlag);\n      SDValue Result(RNode, 0);\n      InFlag = SDValue(RNode, 1);\n\n      Result =\n          CurDAG->getTargetExtractSubreg(X86::sub_8bit, dl, MVT::i8, Result);\n\n      ReplaceUses(SDValue(Node, 1), Result);\n      LLVM_DEBUG(dbgs() << \"=> \"; Result.getNode()->dump(CurDAG);\n                 dbgs() << '\\n');\n    }\n    // Copy the division (low) result, if it is needed.\n    if (!SDValue(Node, 0).use_empty()) {\n      SDValue Result = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), dl,\n                                                LoReg, NVT, InFlag);\n      InFlag = Result.getValue(2);\n      ReplaceUses(SDValue(Node, 0), Result);\n      LLVM_DEBUG(dbgs() << \"=> \"; Result.getNode()->dump(CurDAG);\n                 dbgs() << '\\n');\n    }\n    // Copy the remainder (high) result, if it is needed.\n    if (!SDValue(Node, 1).use_empty()) {\n      SDValue Result = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), dl,\n                                              HiReg, NVT, InFlag);\n      InFlag = Result.getValue(2);\n      ReplaceUses(SDValue(Node, 1), Result);\n      LLVM_DEBUG(dbgs() << \"=> \"; Result.getNode()->dump(CurDAG);\n                 dbgs() << '\\n');\n    }\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n\n  case X86ISD::FCMP:\n  case X86ISD::STRICT_FCMP:\n  case X86ISD::STRICT_FCMPS: {\n    bool IsStrictCmp = Node->getOpcode() == X86ISD::STRICT_FCMP ||\n                       Node->getOpcode() == X86ISD::STRICT_FCMPS;\n    SDValue N0 = Node->getOperand(IsStrictCmp ? 1 : 0);\n    SDValue N1 = Node->getOperand(IsStrictCmp ? 2 : 1);\n\n    // Save the original VT of the compare.\n    MVT CmpVT = N0.getSimpleValueType();\n\n    // Floating point needs special handling if we don't have FCOMI.\n    if (Subtarget->hasCMov())\n      break;\n\n    bool IsSignaling = Node->getOpcode() == X86ISD::STRICT_FCMPS;\n\n    unsigned Opc;\n    switch (CmpVT.SimpleTy) {\n    default: llvm_unreachable(\"Unexpected type!\");\n    case MVT::f32:\n      Opc = IsSignaling ? X86::COM_Fpr32 : X86::UCOM_Fpr32;\n      break;\n    case MVT::f64:\n      Opc = IsSignaling ? X86::COM_Fpr64 : X86::UCOM_Fpr64;\n      break;\n    case MVT::f80:\n      Opc = IsSignaling ? X86::COM_Fpr80 : X86::UCOM_Fpr80;\n      break;\n    }\n\n    SDValue Cmp;\n    SDValue Chain =\n        IsStrictCmp ? Node->getOperand(0) : CurDAG->getEntryNode();\n    if (IsStrictCmp) {\n      SDVTList VTs = CurDAG->getVTList(MVT::i16, MVT::Other);\n      Cmp = SDValue(CurDAG->getMachineNode(Opc, dl, VTs, {N0, N1, Chain}), 0);\n      Chain = Cmp.getValue(1);\n    } else {\n      Cmp = SDValue(CurDAG->getMachineNode(Opc, dl, MVT::i16, N0, N1), 0);\n    }\n\n    // Move FPSW to AX.\n    SDValue FPSW = CurDAG->getCopyToReg(Chain, dl, X86::FPSW, Cmp, SDValue());\n    Chain = FPSW;\n    SDValue FNSTSW =\n        SDValue(CurDAG->getMachineNode(X86::FNSTSW16r, dl, MVT::i16, FPSW,\n                                       FPSW.getValue(1)),\n                0);\n\n    // Extract upper 8-bits of AX.\n    SDValue Extract =\n        CurDAG->getTargetExtractSubreg(X86::sub_8bit_hi, dl, MVT::i8, FNSTSW);\n\n    // Move AH into flags.\n    // Some 64-bit targets lack SAHF support, but they do support FCOMI.\n    assert(Subtarget->hasLAHFSAHF() &&\n           \"Target doesn't support SAHF or FCOMI?\");\n    SDValue AH = CurDAG->getCopyToReg(Chain, dl, X86::AH, Extract, SDValue());\n    Chain = AH;\n    SDValue SAHF = SDValue(\n        CurDAG->getMachineNode(X86::SAHF, dl, MVT::i32, AH.getValue(1)), 0);\n\n    if (IsStrictCmp)\n      ReplaceUses(SDValue(Node, 1), Chain);\n\n    ReplaceUses(SDValue(Node, 0), SAHF);\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n\n  case X86ISD::CMP: {\n    SDValue N0 = Node->getOperand(0);\n    SDValue N1 = Node->getOperand(1);\n\n    // Optimizations for TEST compares.\n    if (!isNullConstant(N1))\n      break;\n\n    // Save the original VT of the compare.\n    MVT CmpVT = N0.getSimpleValueType();\n\n    // If we are comparing (and (shr X, C, Mask) with 0, emit a BEXTR followed\n    // by a test instruction. The test should be removed later by\n    // analyzeCompare if we are using only the zero flag.\n    // TODO: Should we check the users and use the BEXTR flags directly?\n    if (N0.getOpcode() == ISD::AND && N0.hasOneUse()) {\n      if (MachineSDNode *NewNode = matchBEXTRFromAndImm(N0.getNode())) {\n        unsigned TestOpc = CmpVT == MVT::i64 ? X86::TEST64rr\n                                             : X86::TEST32rr;\n        SDValue BEXTR = SDValue(NewNode, 0);\n        NewNode = CurDAG->getMachineNode(TestOpc, dl, MVT::i32, BEXTR, BEXTR);\n        ReplaceUses(SDValue(Node, 0), SDValue(NewNode, 0));\n        CurDAG->RemoveDeadNode(Node);\n        return;\n      }\n    }\n\n    // We can peek through truncates, but we need to be careful below.\n    if (N0.getOpcode() == ISD::TRUNCATE && N0.hasOneUse())\n      N0 = N0.getOperand(0);\n\n    // Look for (X86cmp (and $op, $imm), 0) and see if we can convert it to\n    // use a smaller encoding.\n    // Look past the truncate if CMP is the only use of it.\n    if (N0.getOpcode() == ISD::AND &&\n        N0.getNode()->hasOneUse() &&\n        N0.getValueType() != MVT::i8) {\n      ConstantSDNode *C = dyn_cast<ConstantSDNode>(N0.getOperand(1));\n      if (!C) break;\n      uint64_t Mask = C->getZExtValue();\n\n      // Check if we can replace AND+IMM64 with a shift. This is possible for\n      // masks/ like 0xFF000000 or 0x00FFFFFF and if we care only about the zero\n      // flag.\n      if (CmpVT == MVT::i64 && !isInt<32>(Mask) &&\n          onlyUsesZeroFlag(SDValue(Node, 0))) {\n        if (isMask_64(~Mask)) {\n          unsigned TrailingZeros = countTrailingZeros(Mask);\n          SDValue Imm = CurDAG->getTargetConstant(TrailingZeros, dl, MVT::i64);\n          SDValue Shift =\n            SDValue(CurDAG->getMachineNode(X86::SHR64ri, dl, MVT::i64, MVT::i32,\n                                           N0.getOperand(0), Imm), 0);\n          MachineSDNode *Test = CurDAG->getMachineNode(X86::TEST64rr, dl,\n                                                       MVT::i32, Shift, Shift);\n          ReplaceNode(Node, Test);\n          return;\n        }\n        if (isMask_64(Mask)) {\n          unsigned LeadingZeros = countLeadingZeros(Mask);\n          SDValue Imm = CurDAG->getTargetConstant(LeadingZeros, dl, MVT::i64);\n          SDValue Shift =\n            SDValue(CurDAG->getMachineNode(X86::SHL64ri, dl, MVT::i64, MVT::i32,\n                                           N0.getOperand(0), Imm), 0);\n          MachineSDNode *Test = CurDAG->getMachineNode(X86::TEST64rr, dl,\n                                                       MVT::i32, Shift, Shift);\n          ReplaceNode(Node, Test);\n          return;\n        }\n      }\n\n      MVT VT;\n      int SubRegOp;\n      unsigned ROpc, MOpc;\n\n      // For each of these checks we need to be careful if the sign flag is\n      // being used. It is only safe to use the sign flag in two conditions,\n      // either the sign bit in the shrunken mask is zero or the final test\n      // size is equal to the original compare size.\n\n      if (isUInt<8>(Mask) &&\n          (!(Mask & 0x80) || CmpVT == MVT::i8 ||\n           hasNoSignFlagUses(SDValue(Node, 0)))) {\n        // For example, convert \"testl %eax, $8\" to \"testb %al, $8\"\n        VT = MVT::i8;\n        SubRegOp = X86::sub_8bit;\n        ROpc = X86::TEST8ri;\n        MOpc = X86::TEST8mi;\n      } else if (OptForMinSize && isUInt<16>(Mask) &&\n                 (!(Mask & 0x8000) || CmpVT == MVT::i16 ||\n                  hasNoSignFlagUses(SDValue(Node, 0)))) {\n        // For example, \"testl %eax, $32776\" to \"testw %ax, $32776\".\n        // NOTE: We only want to form TESTW instructions if optimizing for\n        // min size. Otherwise we only save one byte and possibly get a length\n        // changing prefix penalty in the decoders.\n        VT = MVT::i16;\n        SubRegOp = X86::sub_16bit;\n        ROpc = X86::TEST16ri;\n        MOpc = X86::TEST16mi;\n      } else if (isUInt<32>(Mask) && N0.getValueType() != MVT::i16 &&\n                 ((!(Mask & 0x80000000) &&\n                   // Without minsize 16-bit Cmps can get here so we need to\n                   // be sure we calculate the correct sign flag if needed.\n                   (CmpVT != MVT::i16 || !(Mask & 0x8000))) ||\n                  CmpVT == MVT::i32 ||\n                  hasNoSignFlagUses(SDValue(Node, 0)))) {\n        // For example, \"testq %rax, $268468232\" to \"testl %eax, $268468232\".\n        // NOTE: We only want to run that transform if N0 is 32 or 64 bits.\n        // Otherwize, we find ourselves in a position where we have to do\n        // promotion. If previous passes did not promote the and, we assume\n        // they had a good reason not to and do not promote here.\n        VT = MVT::i32;\n        SubRegOp = X86::sub_32bit;\n        ROpc = X86::TEST32ri;\n        MOpc = X86::TEST32mi;\n      } else {\n        // No eligible transformation was found.\n        break;\n      }\n\n      SDValue Imm = CurDAG->getTargetConstant(Mask, dl, VT);\n      SDValue Reg = N0.getOperand(0);\n\n      // Emit a testl or testw.\n      MachineSDNode *NewNode;\n      SDValue Tmp0, Tmp1, Tmp2, Tmp3, Tmp4;\n      if (tryFoldLoad(Node, N0.getNode(), Reg, Tmp0, Tmp1, Tmp2, Tmp3, Tmp4)) {\n        if (auto *LoadN = dyn_cast<LoadSDNode>(N0.getOperand(0).getNode())) {\n          if (!LoadN->isSimple()) {\n            unsigned NumVolBits = LoadN->getValueType(0).getSizeInBits();\n            if (MOpc == X86::TEST8mi && NumVolBits != 8)\n              break;\n            else if (MOpc == X86::TEST16mi && NumVolBits != 16)\n              break;\n            else if (MOpc == X86::TEST32mi && NumVolBits != 32)\n              break;\n          }\n        }\n        SDValue Ops[] = { Tmp0, Tmp1, Tmp2, Tmp3, Tmp4, Imm,\n                          Reg.getOperand(0) };\n        NewNode = CurDAG->getMachineNode(MOpc, dl, MVT::i32, MVT::Other, Ops);\n        // Update the chain.\n        ReplaceUses(Reg.getValue(1), SDValue(NewNode, 1));\n        // Record the mem-refs\n        CurDAG->setNodeMemRefs(NewNode,\n                               {cast<LoadSDNode>(Reg)->getMemOperand()});\n      } else {\n        // Extract the subregister if necessary.\n        if (N0.getValueType() != VT)\n          Reg = CurDAG->getTargetExtractSubreg(SubRegOp, dl, VT, Reg);\n\n        NewNode = CurDAG->getMachineNode(ROpc, dl, MVT::i32, Reg, Imm);\n      }\n      // Replace CMP with TEST.\n      ReplaceNode(Node, NewNode);\n      return;\n    }\n    break;\n  }\n  case X86ISD::PCMPISTR: {\n    if (!Subtarget->hasSSE42())\n      break;\n\n    bool NeedIndex = !SDValue(Node, 0).use_empty();\n    bool NeedMask = !SDValue(Node, 1).use_empty();\n    // We can't fold a load if we are going to make two instructions.\n    bool MayFoldLoad = !NeedIndex || !NeedMask;\n\n    MachineSDNode *CNode;\n    if (NeedMask) {\n      unsigned ROpc = Subtarget->hasAVX() ? X86::VPCMPISTRMrr : X86::PCMPISTRMrr;\n      unsigned MOpc = Subtarget->hasAVX() ? X86::VPCMPISTRMrm : X86::PCMPISTRMrm;\n      CNode = emitPCMPISTR(ROpc, MOpc, MayFoldLoad, dl, MVT::v16i8, Node);\n      ReplaceUses(SDValue(Node, 1), SDValue(CNode, 0));\n    }\n    if (NeedIndex || !NeedMask) {\n      unsigned ROpc = Subtarget->hasAVX() ? X86::VPCMPISTRIrr : X86::PCMPISTRIrr;\n      unsigned MOpc = Subtarget->hasAVX() ? X86::VPCMPISTRIrm : X86::PCMPISTRIrm;\n      CNode = emitPCMPISTR(ROpc, MOpc, MayFoldLoad, dl, MVT::i32, Node);\n      ReplaceUses(SDValue(Node, 0), SDValue(CNode, 0));\n    }\n\n    // Connect the flag usage to the last instruction created.\n    ReplaceUses(SDValue(Node, 2), SDValue(CNode, 1));\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n  case X86ISD::PCMPESTR: {\n    if (!Subtarget->hasSSE42())\n      break;\n\n    // Copy the two implicit register inputs.\n    SDValue InFlag = CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl, X86::EAX,\n                                          Node->getOperand(1),\n                                          SDValue()).getValue(1);\n    InFlag = CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl, X86::EDX,\n                                  Node->getOperand(3), InFlag).getValue(1);\n\n    bool NeedIndex = !SDValue(Node, 0).use_empty();\n    bool NeedMask = !SDValue(Node, 1).use_empty();\n    // We can't fold a load if we are going to make two instructions.\n    bool MayFoldLoad = !NeedIndex || !NeedMask;\n\n    MachineSDNode *CNode;\n    if (NeedMask) {\n      unsigned ROpc = Subtarget->hasAVX() ? X86::VPCMPESTRMrr : X86::PCMPESTRMrr;\n      unsigned MOpc = Subtarget->hasAVX() ? X86::VPCMPESTRMrm : X86::PCMPESTRMrm;\n      CNode = emitPCMPESTR(ROpc, MOpc, MayFoldLoad, dl, MVT::v16i8, Node,\n                           InFlag);\n      ReplaceUses(SDValue(Node, 1), SDValue(CNode, 0));\n    }\n    if (NeedIndex || !NeedMask) {\n      unsigned ROpc = Subtarget->hasAVX() ? X86::VPCMPESTRIrr : X86::PCMPESTRIrr;\n      unsigned MOpc = Subtarget->hasAVX() ? X86::VPCMPESTRIrm : X86::PCMPESTRIrm;\n      CNode = emitPCMPESTR(ROpc, MOpc, MayFoldLoad, dl, MVT::i32, Node, InFlag);\n      ReplaceUses(SDValue(Node, 0), SDValue(CNode, 0));\n    }\n    // Connect the flag usage to the last instruction created.\n    ReplaceUses(SDValue(Node, 2), SDValue(CNode, 1));\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n\n  case ISD::SETCC: {\n    if (NVT.isVector() && tryVPTESTM(Node, SDValue(Node, 0), SDValue()))\n      return;\n\n    break;\n  }\n\n  case ISD::STORE:\n    if (foldLoadStoreIntoMemOperand(Node))\n      return;\n    break;\n\n  case X86ISD::SETCC_CARRY: {\n    // We have to do this manually because tblgen will put the eflags copy in\n    // the wrong place if we use an extract_subreg in the pattern.\n    MVT VT = Node->getSimpleValueType(0);\n\n    // Copy flags to the EFLAGS register and glue it to next node.\n    SDValue EFLAGS =\n        CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl, X86::EFLAGS,\n                             Node->getOperand(1), SDValue());\n\n    // Create a 64-bit instruction if the result is 64-bits otherwise use the\n    // 32-bit version.\n    unsigned Opc = VT == MVT::i64 ? X86::SETB_C64r : X86::SETB_C32r;\n    MVT SetVT = VT == MVT::i64 ? MVT::i64 : MVT::i32;\n    SDValue Result = SDValue(\n        CurDAG->getMachineNode(Opc, dl, SetVT, EFLAGS, EFLAGS.getValue(1)), 0);\n\n    // For less than 32-bits we need to extract from the 32-bit node.\n    if (VT == MVT::i8 || VT == MVT::i16) {\n      int SubIndex = VT == MVT::i16 ? X86::sub_16bit : X86::sub_8bit;\n      Result = CurDAG->getTargetExtractSubreg(SubIndex, dl, VT, Result);\n    }\n\n    ReplaceUses(SDValue(Node, 0), Result);\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n  case X86ISD::SBB: {\n    if (isNullConstant(Node->getOperand(0)) &&\n        isNullConstant(Node->getOperand(1))) {\n      MVT VT = Node->getSimpleValueType(0);\n\n      // Create zero.\n      SDVTList VTs = CurDAG->getVTList(MVT::i32, MVT::i32);\n      SDValue Zero =\n          SDValue(CurDAG->getMachineNode(X86::MOV32r0, dl, VTs, None), 0);\n      if (VT == MVT::i64) {\n        Zero = SDValue(\n            CurDAG->getMachineNode(\n                TargetOpcode::SUBREG_TO_REG, dl, MVT::i64,\n                CurDAG->getTargetConstant(0, dl, MVT::i64), Zero,\n                CurDAG->getTargetConstant(X86::sub_32bit, dl, MVT::i32)),\n            0);\n      }\n\n      // Copy flags to the EFLAGS register and glue it to next node.\n      SDValue EFLAGS =\n          CurDAG->getCopyToReg(CurDAG->getEntryNode(), dl, X86::EFLAGS,\n                               Node->getOperand(2), SDValue());\n\n      // Create a 64-bit instruction if the result is 64-bits otherwise use the\n      // 32-bit version.\n      unsigned Opc = VT == MVT::i64 ? X86::SBB64rr : X86::SBB32rr;\n      MVT SBBVT = VT == MVT::i64 ? MVT::i64 : MVT::i32;\n      VTs = CurDAG->getVTList(SBBVT, MVT::i32);\n      SDValue Result =\n          SDValue(CurDAG->getMachineNode(Opc, dl, VTs, {Zero, Zero, EFLAGS,\n                                         EFLAGS.getValue(1)}),\n                  0);\n\n      // Replace the flag use.\n      ReplaceUses(SDValue(Node, 1), Result.getValue(1));\n\n      // Replace the result use.\n      if (!SDValue(Node, 0).use_empty()) {\n        // For less than 32-bits we need to extract from the 32-bit node.\n        if (VT == MVT::i8 || VT == MVT::i16) {\n          int SubIndex = VT == MVT::i16 ? X86::sub_16bit : X86::sub_8bit;\n          Result = CurDAG->getTargetExtractSubreg(SubIndex, dl, VT, Result);\n        }\n        ReplaceUses(SDValue(Node, 0), Result);\n      }\n\n      CurDAG->RemoveDeadNode(Node);\n      return;\n    }\n    break;\n  }\n  case X86ISD::MGATHER: {\n    auto *Mgt = cast<X86MaskedGatherSDNode>(Node);\n    SDValue IndexOp = Mgt->getIndex();\n    SDValue Mask = Mgt->getMask();\n    MVT IndexVT = IndexOp.getSimpleValueType();\n    MVT ValueVT = Node->getSimpleValueType(0);\n    MVT MaskVT = Mask.getSimpleValueType();\n\n    // This is just to prevent crashes if the nodes are malformed somehow. We're\n    // otherwise only doing loose type checking in here based on type what\n    // a type constraint would say just like table based isel.\n    if (!ValueVT.isVector() || !MaskVT.isVector())\n      break;\n\n    unsigned NumElts = ValueVT.getVectorNumElements();\n    MVT ValueSVT = ValueVT.getVectorElementType();\n\n    bool IsFP = ValueSVT.isFloatingPoint();\n    unsigned EltSize = ValueSVT.getSizeInBits();\n\n    unsigned Opc = 0;\n    bool AVX512Gather = MaskVT.getVectorElementType() == MVT::i1;\n    if (AVX512Gather) {\n      if (IndexVT == MVT::v4i32 && NumElts == 4 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERDPSZ128rm : X86::VPGATHERDDZ128rm;\n      else if (IndexVT == MVT::v8i32 && NumElts == 8 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERDPSZ256rm : X86::VPGATHERDDZ256rm;\n      else if (IndexVT == MVT::v16i32 && NumElts == 16 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERDPSZrm : X86::VPGATHERDDZrm;\n      else if (IndexVT == MVT::v4i32 && NumElts == 2 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERDPDZ128rm : X86::VPGATHERDQZ128rm;\n      else if (IndexVT == MVT::v4i32 && NumElts == 4 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERDPDZ256rm : X86::VPGATHERDQZ256rm;\n      else if (IndexVT == MVT::v8i32 && NumElts == 8 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERDPDZrm : X86::VPGATHERDQZrm;\n      else if (IndexVT == MVT::v2i64 && NumElts == 4 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERQPSZ128rm : X86::VPGATHERQDZ128rm;\n      else if (IndexVT == MVT::v4i64 && NumElts == 4 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERQPSZ256rm : X86::VPGATHERQDZ256rm;\n      else if (IndexVT == MVT::v8i64 && NumElts == 8 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERQPSZrm : X86::VPGATHERQDZrm;\n      else if (IndexVT == MVT::v2i64 && NumElts == 2 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERQPDZ128rm : X86::VPGATHERQQZ128rm;\n      else if (IndexVT == MVT::v4i64 && NumElts == 4 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERQPDZ256rm : X86::VPGATHERQQZ256rm;\n      else if (IndexVT == MVT::v8i64 && NumElts == 8 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERQPDZrm : X86::VPGATHERQQZrm;\n    } else {\n      assert(EVT(MaskVT) == EVT(ValueVT).changeVectorElementTypeToInteger() &&\n             \"Unexpected mask VT!\");\n      if (IndexVT == MVT::v4i32 && NumElts == 4 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERDPSrm : X86::VPGATHERDDrm;\n      else if (IndexVT == MVT::v8i32 && NumElts == 8 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERDPSYrm : X86::VPGATHERDDYrm;\n      else if (IndexVT == MVT::v4i32 && NumElts == 2 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERDPDrm : X86::VPGATHERDQrm;\n      else if (IndexVT == MVT::v4i32 && NumElts == 4 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERDPDYrm : X86::VPGATHERDQYrm;\n      else if (IndexVT == MVT::v2i64 && NumElts == 4 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERQPSrm : X86::VPGATHERQDrm;\n      else if (IndexVT == MVT::v4i64 && NumElts == 4 && EltSize == 32)\n        Opc = IsFP ? X86::VGATHERQPSYrm : X86::VPGATHERQDYrm;\n      else if (IndexVT == MVT::v2i64 && NumElts == 2 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERQPDrm : X86::VPGATHERQQrm;\n      else if (IndexVT == MVT::v4i64 && NumElts == 4 && EltSize == 64)\n        Opc = IsFP ? X86::VGATHERQPDYrm : X86::VPGATHERQQYrm;\n    }\n\n    if (!Opc)\n      break;\n\n    SDValue Base, Scale, Index, Disp, Segment;\n    if (!selectVectorAddr(Mgt, Mgt->getBasePtr(), IndexOp, Mgt->getScale(),\n                          Base, Scale, Index, Disp, Segment))\n      break;\n\n    SDValue PassThru = Mgt->getPassThru();\n    SDValue Chain = Mgt->getChain();\n    // Gather instructions have a mask output not in the ISD node.\n    SDVTList VTs = CurDAG->getVTList(ValueVT, MaskVT, MVT::Other);\n\n    MachineSDNode *NewNode;\n    if (AVX512Gather) {\n      SDValue Ops[] = {PassThru, Mask, Base,    Scale,\n                       Index,    Disp, Segment, Chain};\n      NewNode = CurDAG->getMachineNode(Opc, SDLoc(dl), VTs, Ops);\n    } else {\n      SDValue Ops[] = {PassThru, Base,    Scale, Index,\n                       Disp,     Segment, Mask,  Chain};\n      NewNode = CurDAG->getMachineNode(Opc, SDLoc(dl), VTs, Ops);\n    }\n    CurDAG->setNodeMemRefs(NewNode, {Mgt->getMemOperand()});\n    ReplaceUses(SDValue(Node, 0), SDValue(NewNode, 0));\n    ReplaceUses(SDValue(Node, 1), SDValue(NewNode, 2));\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n  case X86ISD::MSCATTER: {\n    auto *Sc = cast<X86MaskedScatterSDNode>(Node);\n    SDValue Value = Sc->getValue();\n    SDValue IndexOp = Sc->getIndex();\n    MVT IndexVT = IndexOp.getSimpleValueType();\n    MVT ValueVT = Value.getSimpleValueType();\n\n    // This is just to prevent crashes if the nodes are malformed somehow. We're\n    // otherwise only doing loose type checking in here based on type what\n    // a type constraint would say just like table based isel.\n    if (!ValueVT.isVector())\n      break;\n\n    unsigned NumElts = ValueVT.getVectorNumElements();\n    MVT ValueSVT = ValueVT.getVectorElementType();\n\n    bool IsFP = ValueSVT.isFloatingPoint();\n    unsigned EltSize = ValueSVT.getSizeInBits();\n\n    unsigned Opc;\n    if (IndexVT == MVT::v4i32 && NumElts == 4 && EltSize == 32)\n      Opc = IsFP ? X86::VSCATTERDPSZ128mr : X86::VPSCATTERDDZ128mr;\n    else if (IndexVT == MVT::v8i32 && NumElts == 8 && EltSize == 32)\n      Opc = IsFP ? X86::VSCATTERDPSZ256mr : X86::VPSCATTERDDZ256mr;\n    else if (IndexVT == MVT::v16i32 && NumElts == 16 && EltSize == 32)\n      Opc = IsFP ? X86::VSCATTERDPSZmr : X86::VPSCATTERDDZmr;\n    else if (IndexVT == MVT::v4i32 && NumElts == 2 && EltSize == 64)\n      Opc = IsFP ? X86::VSCATTERDPDZ128mr : X86::VPSCATTERDQZ128mr;\n    else if (IndexVT == MVT::v4i32 && NumElts == 4 && EltSize == 64)\n      Opc = IsFP ? X86::VSCATTERDPDZ256mr : X86::VPSCATTERDQZ256mr;\n    else if (IndexVT == MVT::v8i32 && NumElts == 8 && EltSize == 64)\n      Opc = IsFP ? X86::VSCATTERDPDZmr : X86::VPSCATTERDQZmr;\n    else if (IndexVT == MVT::v2i64 && NumElts == 4 && EltSize == 32)\n      Opc = IsFP ? X86::VSCATTERQPSZ128mr : X86::VPSCATTERQDZ128mr;\n    else if (IndexVT == MVT::v4i64 && NumElts == 4 && EltSize == 32)\n      Opc = IsFP ? X86::VSCATTERQPSZ256mr : X86::VPSCATTERQDZ256mr;\n    else if (IndexVT == MVT::v8i64 && NumElts == 8 && EltSize == 32)\n      Opc = IsFP ? X86::VSCATTERQPSZmr : X86::VPSCATTERQDZmr;\n    else if (IndexVT == MVT::v2i64 && NumElts == 2 && EltSize == 64)\n      Opc = IsFP ? X86::VSCATTERQPDZ128mr : X86::VPSCATTERQQZ128mr;\n    else if (IndexVT == MVT::v4i64 && NumElts == 4 && EltSize == 64)\n      Opc = IsFP ? X86::VSCATTERQPDZ256mr : X86::VPSCATTERQQZ256mr;\n    else if (IndexVT == MVT::v8i64 && NumElts == 8 && EltSize == 64)\n      Opc = IsFP ? X86::VSCATTERQPDZmr : X86::VPSCATTERQQZmr;\n    else\n      break;\n\n    SDValue Base, Scale, Index, Disp, Segment;\n    if (!selectVectorAddr(Sc, Sc->getBasePtr(), IndexOp, Sc->getScale(),\n                          Base, Scale, Index, Disp, Segment))\n      break;\n\n    SDValue Mask = Sc->getMask();\n    SDValue Chain = Sc->getChain();\n    // Scatter instructions have a mask output not in the ISD node.\n    SDVTList VTs = CurDAG->getVTList(Mask.getValueType(), MVT::Other);\n    SDValue Ops[] = {Base, Scale, Index, Disp, Segment, Mask, Value, Chain};\n\n    MachineSDNode *NewNode = CurDAG->getMachineNode(Opc, SDLoc(dl), VTs, Ops);\n    CurDAG->setNodeMemRefs(NewNode, {Sc->getMemOperand()});\n    ReplaceUses(SDValue(Node, 0), SDValue(NewNode, 1));\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n  case ISD::PREALLOCATED_SETUP: {\n    auto *MFI = CurDAG->getMachineFunction().getInfo<X86MachineFunctionInfo>();\n    auto CallId = MFI->getPreallocatedIdForCallSite(\n        cast<SrcValueSDNode>(Node->getOperand(1))->getValue());\n    SDValue Chain = Node->getOperand(0);\n    SDValue CallIdValue = CurDAG->getTargetConstant(CallId, dl, MVT::i32);\n    MachineSDNode *New = CurDAG->getMachineNode(\n        TargetOpcode::PREALLOCATED_SETUP, dl, MVT::Other, CallIdValue, Chain);\n    ReplaceUses(SDValue(Node, 0), SDValue(New, 0)); // Chain\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n  case ISD::PREALLOCATED_ARG: {\n    auto *MFI = CurDAG->getMachineFunction().getInfo<X86MachineFunctionInfo>();\n    auto CallId = MFI->getPreallocatedIdForCallSite(\n        cast<SrcValueSDNode>(Node->getOperand(1))->getValue());\n    SDValue Chain = Node->getOperand(0);\n    SDValue CallIdValue = CurDAG->getTargetConstant(CallId, dl, MVT::i32);\n    SDValue ArgIndex = Node->getOperand(2);\n    SDValue Ops[3];\n    Ops[0] = CallIdValue;\n    Ops[1] = ArgIndex;\n    Ops[2] = Chain;\n    MachineSDNode *New = CurDAG->getMachineNode(\n        TargetOpcode::PREALLOCATED_ARG, dl,\n        CurDAG->getVTList(TLI->getPointerTy(CurDAG->getDataLayout()),\n                          MVT::Other),\n        Ops);\n    ReplaceUses(SDValue(Node, 0), SDValue(New, 0)); // Arg pointer\n    ReplaceUses(SDValue(Node, 1), SDValue(New, 1)); // Chain\n    CurDAG->RemoveDeadNode(Node);\n    return;\n  }\n  case X86ISD::AESENCWIDE128KL:\n  case X86ISD::AESDECWIDE128KL:\n  case X86ISD::AESENCWIDE256KL:\n  case X86ISD::AESDECWIDE256KL: {\n    if (!Subtarget->hasWIDEKL())\n      break;\n\n    unsigned Opcode;\n    switch (Node->getOpcode()) {\n    default:\n      llvm_unreachable(\"Unexpected opcode!\");\n    case X86ISD::AESENCWIDE128KL:\n      Opcode = X86::AESENCWIDE128KL;\n      break;\n    case X86ISD::AESDECWIDE128KL:\n      Opcode = X86::AESDECWIDE128KL;\n      break;\n    case X86ISD::AESENCWIDE256KL:\n      Opcode = X86::AESENCWIDE256KL;\n      break;\n    case X86ISD::AESDECWIDE256KL:\n      Opcode = X86::AESDECWIDE256KL;\n      break;\n    }\n\n    SDValue Chain = Node->getOperand(0);\n    SDValue Addr = Node->getOperand(1);\n\n    SDValue Base, Scale, Index, Disp, Segment;\n    if (!selectAddr(Node, Addr, Base, Scale, Index, Disp, Segment))\n      break;\n\n    Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM0, Node->getOperand(2),\n                                 SDValue());\n    Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM1, Node->getOperand(3),\n                                 Chain.getValue(1));\n    Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM2, Node->getOperand(4),\n                                 Chain.getValue(1));\n    Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM3, Node->getOperand(5),\n                                 Chain.getValue(1));\n    Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM4, Node->getOperand(6),\n                                 Chain.getValue(1));\n    Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM5, Node->getOperand(7),\n                                 Chain.getValue(1));\n    Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM6, Node->getOperand(8),\n                                 Chain.getValue(1));\n    Chain = CurDAG->getCopyToReg(Chain, dl, X86::XMM7, Node->getOperand(9),\n                                 Chain.getValue(1));\n\n    MachineSDNode *Res = CurDAG->getMachineNode(\n        Opcode, dl, Node->getVTList(),\n        {Base, Scale, Index, Disp, Segment, Chain, Chain.getValue(1)});\n    CurDAG->setNodeMemRefs(Res, cast<MemSDNode>(Node)->getMemOperand());\n    ReplaceNode(Node, Res);\n    return;\n  }\n  }\n\n  SelectCode(Node);\n}\n\nbool X86DAGToDAGISel::\nSelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,\n                             std::vector<SDValue> &OutOps) {\n  SDValue Op0, Op1, Op2, Op3, Op4;\n  switch (ConstraintID) {\n  default:\n    llvm_unreachable(\"Unexpected asm memory constraint\");\n  case InlineAsm::Constraint_o: // offsetable        ??\n  case InlineAsm::Constraint_v: // not offsetable    ??\n  case InlineAsm::Constraint_m: // memory\n  case InlineAsm::Constraint_X:\n    if (!selectAddr(nullptr, Op, Op0, Op1, Op2, Op3, Op4))\n      return true;\n    break;\n  }\n\n  OutOps.push_back(Op0);\n  OutOps.push_back(Op1);\n  OutOps.push_back(Op2);\n  OutOps.push_back(Op3);\n  OutOps.push_back(Op4);\n  return false;\n}\n\n/// This pass converts a legalized DAG into a X86-specific DAG,\n/// ready for instruction scheduling.\nFunctionPass *llvm::createX86ISelDag(X86TargetMachine &TM,\n                                     CodeGenOpt::Level OptLevel) {\n  return new X86DAGToDAGISel(TM, OptLevel);\n}\n"}}, "reports": [{"events": [{"location": {"col": 23, "file": 3, "line": 4228}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 3, "line": 501}, "message": "differing parameters are named here: ('N'), in definition: ('And')"}, {"location": {"col": 10, "file": 3, "line": 501}, "message": "function '(anonymous namespace)::X86DAGToDAGISel::shrinkAndImmediate' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp", "reportHash": "f941e734812d5e573ffc3182f3f47d62", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
