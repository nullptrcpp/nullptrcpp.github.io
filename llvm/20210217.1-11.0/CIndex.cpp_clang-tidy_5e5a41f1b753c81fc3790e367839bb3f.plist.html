<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndex.cpp", "content": "//===- CIndex.cpp - Clang-C Source Indexing Library -----------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the main API hooks in the Clang-C Source Indexing\n// library.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CIndexDiagnostic.h\"\n#include \"CIndexer.h\"\n#include \"CLog.h\"\n#include \"CXCursor.h\"\n#include \"CXSourceLocation.h\"\n#include \"CXString.h\"\n#include \"CXTranslationUnit.h\"\n#include \"CXType.h\"\n#include \"CursorVisitor.h\"\n#include \"clang-c/FatalErrorHandler.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/DeclObjCCommon.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticCategories.h\"\n#include \"clang/Basic/DiagnosticIDs.h\"\n#include \"clang/Basic/Stack.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Frontend/ASTUnit.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Index/CommentToXML.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/CrashRecoveryContext.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Program.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include \"llvm/Support/Signals.h\"\n#include \"llvm/Support/TargetSelect.h\"\n#include \"llvm/Support/Threading.h\"\n#include \"llvm/Support/Timer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <mutex>\n\n#if LLVM_ENABLE_THREADS != 0 && defined(__APPLE__)\n#define USE_DARWIN_THREADS\n#endif\n\n#ifdef USE_DARWIN_THREADS\n#include <pthread.h>\n#endif\n\nusing namespace clang;\nusing namespace clang::cxcursor;\nusing namespace clang::cxtu;\nusing namespace clang::cxindex;\n\nCXTranslationUnit cxtu::MakeCXTranslationUnit(CIndexer *CIdx,\n                                              std::unique_ptr<ASTUnit> AU) {\n  if (!AU)\n    return nullptr;\n  assert(CIdx);\n  CXTranslationUnit D = new CXTranslationUnitImpl();\n  D->CIdx = CIdx;\n  D->TheASTUnit = AU.release();\n  D->StringPool = new cxstring::CXStringPool();\n  D->Diagnostics = nullptr;\n  D->OverridenCursorsPool = createOverridenCXCursorsPool();\n  D->CommentToXML = nullptr;\n  D->ParsingOptions = 0;\n  D->Arguments = {};\n  return D;\n}\n\nbool cxtu::isASTReadError(ASTUnit *AU) {\n  for (ASTUnit::stored_diag_iterator D = AU->stored_diag_begin(),\n                                     DEnd = AU->stored_diag_end();\n       D != DEnd; ++D) {\n    if (D->getLevel() >= DiagnosticsEngine::Error &&\n        DiagnosticIDs::getCategoryNumberForDiag(D->getID()) ==\n            diag::DiagCat_AST_Deserialization_Issue)\n      return true;\n  }\n  return false;\n}\n\ncxtu::CXTUOwner::~CXTUOwner() {\n  if (TU)\n    clang_disposeTranslationUnit(TU);\n}\n\n/// Compare two source ranges to determine their relative position in\n/// the translation unit.\nstatic RangeComparisonResult RangeCompare(SourceManager &SM, SourceRange R1,\n                                          SourceRange R2) {\n  assert(R1.isValid() && \"First range is invalid?\");\n  assert(R2.isValid() && \"Second range is invalid?\");\n  if (R1.getEnd() != R2.getBegin() &&\n      SM.isBeforeInTranslationUnit(R1.getEnd(), R2.getBegin()))\n    return RangeBefore;\n  if (R2.getEnd() != R1.getBegin() &&\n      SM.isBeforeInTranslationUnit(R2.getEnd(), R1.getBegin()))\n    return RangeAfter;\n  return RangeOverlap;\n}\n\n/// Determine if a source location falls within, before, or after a\n///   a given source range.\nstatic RangeComparisonResult LocationCompare(SourceManager &SM,\n                                             SourceLocation L, SourceRange R) {\n  assert(R.isValid() && \"First range is invalid?\");\n  assert(L.isValid() && \"Second range is invalid?\");\n  if (L == R.getBegin() || L == R.getEnd())\n    return RangeOverlap;\n  if (SM.isBeforeInTranslationUnit(L, R.getBegin()))\n    return RangeBefore;\n  if (SM.isBeforeInTranslationUnit(R.getEnd(), L))\n    return RangeAfter;\n  return RangeOverlap;\n}\n\n/// Translate a Clang source range into a CIndex source range.\n///\n/// Clang internally represents ranges where the end location points to the\n/// start of the token at the end. However, for external clients it is more\n/// useful to have a CXSourceRange be a proper half-open interval. This routine\n/// does the appropriate translation.\nCXSourceRange cxloc::translateSourceRange(const SourceManager &SM,\n                                          const LangOptions &LangOpts,\n                                          const CharSourceRange &R) {\n  // We want the last character in this location, so we will adjust the\n  // location accordingly.\n  SourceLocation EndLoc = R.getEnd();\n  bool IsTokenRange = R.isTokenRange();\n  if (EndLoc.isValid() && EndLoc.isMacroID() &&\n      !SM.isMacroArgExpansion(EndLoc)) {\n    CharSourceRange Expansion = SM.getExpansionRange(EndLoc);\n    EndLoc = Expansion.getEnd();\n    IsTokenRange = Expansion.isTokenRange();\n  }\n  if (IsTokenRange && EndLoc.isValid()) {\n    unsigned Length =\n        Lexer::MeasureTokenLength(SM.getSpellingLoc(EndLoc), SM, LangOpts);\n    EndLoc = EndLoc.getLocWithOffset(Length);\n  }\n\n  CXSourceRange Result = {\n      {&SM, &LangOpts}, R.getBegin().getRawEncoding(), EndLoc.getRawEncoding()};\n  return Result;\n}\n\nCharSourceRange cxloc::translateCXRangeToCharRange(CXSourceRange R) {\n  return CharSourceRange::getCharRange(\n      SourceLocation::getFromRawEncoding(R.begin_int_data),\n      SourceLocation::getFromRawEncoding(R.end_int_data));\n}\n\n//===----------------------------------------------------------------------===//\n// Cursor visitor.\n//===----------------------------------------------------------------------===//\n\nstatic SourceRange getRawCursorExtent(CXCursor C);\nstatic SourceRange getFullCursorExtent(CXCursor C, SourceManager &SrcMgr);\n\nRangeComparisonResult CursorVisitor::CompareRegionOfInterest(SourceRange R) {\n  return RangeCompare(AU->getSourceManager(), R, RegionOfInterest);\n}\n\n/// Visit the given cursor and, if requested by the visitor,\n/// its children.\n///\n/// \\param Cursor the cursor to visit.\n///\n/// \\param CheckedRegionOfInterest if true, then the caller already checked\n/// that this cursor is within the region of interest.\n///\n/// \\returns true if the visitation should be aborted, false if it\n/// should continue.\nbool CursorVisitor::Visit(CXCursor Cursor, bool CheckedRegionOfInterest) {\n  if (clang_isInvalid(Cursor.kind))\n    return false;\n\n  if (clang_isDeclaration(Cursor.kind)) {\n    const Decl *D = getCursorDecl(Cursor);\n    if (!D) {\n      assert(0 && \"Invalid declaration cursor\");\n      return true; // abort.\n    }\n\n    // Ignore implicit declarations, unless it's an objc method because\n    // currently we should report implicit methods for properties when indexing.\n    if (D->isImplicit() && !isa<ObjCMethodDecl>(D))\n      return false;\n  }\n\n  // If we have a range of interest, and this cursor doesn't intersect with it,\n  // we're done.\n  if (RegionOfInterest.isValid() && !CheckedRegionOfInterest) {\n    SourceRange Range = getRawCursorExtent(Cursor);\n    if (Range.isInvalid() || CompareRegionOfInterest(Range))\n      return false;\n  }\n\n  switch (Visitor(Cursor, Parent, ClientData)) {\n  case CXChildVisit_Break:\n    return true;\n\n  case CXChildVisit_Continue:\n    return false;\n\n  case CXChildVisit_Recurse: {\n    bool ret = VisitChildren(Cursor);\n    if (PostChildrenVisitor)\n      if (PostChildrenVisitor(Cursor, ClientData))\n        return true;\n    return ret;\n  }\n  }\n\n  llvm_unreachable(\"Invalid CXChildVisitResult!\");\n}\n\nstatic bool visitPreprocessedEntitiesInRange(SourceRange R,\n                                             PreprocessingRecord &PPRec,\n                                             CursorVisitor &Visitor) {\n  SourceManager &SM = Visitor.getASTUnit()->getSourceManager();\n  FileID FID;\n\n  if (!Visitor.shouldVisitIncludedEntities()) {\n    // If the begin/end of the range lie in the same FileID, do the optimization\n    // where we skip preprocessed entities that do not come from the same\n    // FileID.\n    FID = SM.getFileID(SM.getFileLoc(R.getBegin()));\n    if (FID != SM.getFileID(SM.getFileLoc(R.getEnd())))\n      FID = FileID();\n  }\n\n  const auto &Entities = PPRec.getPreprocessedEntitiesInRange(R);\n  return Visitor.visitPreprocessedEntities(Entities.begin(), Entities.end(),\n                                           PPRec, FID);\n}\n\nbool CursorVisitor::visitFileRegion() {\n  if (RegionOfInterest.isInvalid())\n    return false;\n\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n  SourceManager &SM = Unit->getSourceManager();\n\n  std::pair<FileID, unsigned> Begin = SM.getDecomposedLoc(\n                                  SM.getFileLoc(RegionOfInterest.getBegin())),\n                              End = SM.getDecomposedLoc(\n                                  SM.getFileLoc(RegionOfInterest.getEnd()));\n\n  if (End.first != Begin.first) {\n    // If the end does not reside in the same file, try to recover by\n    // picking the end of the file of begin location.\n    End.first = Begin.first;\n    End.second = SM.getFileIDSize(Begin.first);\n  }\n\n  assert(Begin.first == End.first);\n  if (Begin.second > End.second)\n    return false;\n\n  FileID File = Begin.first;\n  unsigned Offset = Begin.second;\n  unsigned Length = End.second - Begin.second;\n\n  if (!VisitDeclsOnly && !VisitPreprocessorLast)\n    if (visitPreprocessedEntitiesInRegion())\n      return true; // visitation break.\n\n  if (visitDeclsFromFileRegion(File, Offset, Length))\n    return true; // visitation break.\n\n  if (!VisitDeclsOnly && VisitPreprocessorLast)\n    return visitPreprocessedEntitiesInRegion();\n\n  return false;\n}\n\nstatic bool isInLexicalContext(Decl *D, DeclContext *DC) {\n  if (!DC)\n    return false;\n\n  for (DeclContext *DeclDC = D->getLexicalDeclContext(); DeclDC;\n       DeclDC = DeclDC->getLexicalParent()) {\n    if (DeclDC == DC)\n      return true;\n  }\n  return false;\n}\n\nbool CursorVisitor::visitDeclsFromFileRegion(FileID File, unsigned Offset,\n                                             unsigned Length) {\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n  SourceManager &SM = Unit->getSourceManager();\n  SourceRange Range = RegionOfInterest;\n\n  SmallVector<Decl *, 16> Decls;\n  Unit->findFileRegionDecls(File, Offset, Length, Decls);\n\n  // If we didn't find any file level decls for the file, try looking at the\n  // file that it was included from.\n  while (Decls.empty() || Decls.front()->isTopLevelDeclInObjCContainer()) {\n    bool Invalid = false;\n    const SrcMgr::SLocEntry &SLEntry = SM.getSLocEntry(File, &Invalid);\n    if (Invalid)\n      return false;\n\n    SourceLocation Outer;\n    if (SLEntry.isFile())\n      Outer = SLEntry.getFile().getIncludeLoc();\n    else\n      Outer = SLEntry.getExpansion().getExpansionLocStart();\n    if (Outer.isInvalid())\n      return false;\n\n    std::tie(File, Offset) = SM.getDecomposedExpansionLoc(Outer);\n    Length = 0;\n    Unit->findFileRegionDecls(File, Offset, Length, Decls);\n  }\n\n  assert(!Decls.empty());\n\n  bool VisitedAtLeastOnce = false;\n  DeclContext *CurDC = nullptr;\n  SmallVectorImpl<Decl *>::iterator DIt = Decls.begin();\n  for (SmallVectorImpl<Decl *>::iterator DE = Decls.end(); DIt != DE; ++DIt) {\n    Decl *D = *DIt;\n    if (D->getSourceRange().isInvalid())\n      continue;\n\n    if (isInLexicalContext(D, CurDC))\n      continue;\n\n    CurDC = dyn_cast<DeclContext>(D);\n\n    if (TagDecl *TD = dyn_cast<TagDecl>(D))\n      if (!TD->isFreeStanding())\n        continue;\n\n    RangeComparisonResult CompRes =\n        RangeCompare(SM, D->getSourceRange(), Range);\n    if (CompRes == RangeBefore)\n      continue;\n    if (CompRes == RangeAfter)\n      break;\n\n    assert(CompRes == RangeOverlap);\n    VisitedAtLeastOnce = true;\n\n    if (isa<ObjCContainerDecl>(D)) {\n      FileDI_current = &DIt;\n      FileDE_current = DE;\n    } else {\n      FileDI_current = nullptr;\n    }\n\n    if (Visit(MakeCXCursor(D, TU, Range), /*CheckedRegionOfInterest=*/true))\n      return true; // visitation break.\n  }\n\n  if (VisitedAtLeastOnce)\n    return false;\n\n  // No Decls overlapped with the range. Move up the lexical context until there\n  // is a context that contains the range or we reach the translation unit\n  // level.\n  DeclContext *DC = DIt == Decls.begin()\n                        ? (*DIt)->getLexicalDeclContext()\n                        : (*(DIt - 1))->getLexicalDeclContext();\n\n  while (DC && !DC->isTranslationUnit()) {\n    Decl *D = cast<Decl>(DC);\n    SourceRange CurDeclRange = D->getSourceRange();\n    if (CurDeclRange.isInvalid())\n      break;\n\n    if (RangeCompare(SM, CurDeclRange, Range) == RangeOverlap) {\n      if (Visit(MakeCXCursor(D, TU, Range), /*CheckedRegionOfInterest=*/true))\n        return true; // visitation break.\n    }\n\n    DC = D->getLexicalDeclContext();\n  }\n\n  return false;\n}\n\nbool CursorVisitor::visitPreprocessedEntitiesInRegion() {\n  if (!AU->getPreprocessor().getPreprocessingRecord())\n    return false;\n\n  PreprocessingRecord &PPRec = *AU->getPreprocessor().getPreprocessingRecord();\n  SourceManager &SM = AU->getSourceManager();\n\n  if (RegionOfInterest.isValid()) {\n    SourceRange MappedRange = AU->mapRangeToPreamble(RegionOfInterest);\n    SourceLocation B = MappedRange.getBegin();\n    SourceLocation E = MappedRange.getEnd();\n\n    if (AU->isInPreambleFileID(B)) {\n      if (SM.isLoadedSourceLocation(E))\n        return visitPreprocessedEntitiesInRange(SourceRange(B, E), PPRec,\n                                                *this);\n\n      // Beginning of range lies in the preamble but it also extends beyond\n      // it into the main file. Split the range into 2 parts, one covering\n      // the preamble and another covering the main file. This allows subsequent\n      // calls to visitPreprocessedEntitiesInRange to accept a source range that\n      // lies in the same FileID, allowing it to skip preprocessed entities that\n      // do not come from the same FileID.\n      bool breaked = visitPreprocessedEntitiesInRange(\n          SourceRange(B, AU->getEndOfPreambleFileID()), PPRec, *this);\n      if (breaked)\n        return true;\n      return visitPreprocessedEntitiesInRange(\n          SourceRange(AU->getStartOfMainFileID(), E), PPRec, *this);\n    }\n\n    return visitPreprocessedEntitiesInRange(SourceRange(B, E), PPRec, *this);\n  }\n\n  bool OnlyLocalDecls = !AU->isMainFileAST() && AU->getOnlyLocalDecls();\n\n  if (OnlyLocalDecls)\n    return visitPreprocessedEntities(PPRec.local_begin(), PPRec.local_end(),\n                                     PPRec);\n\n  return visitPreprocessedEntities(PPRec.begin(), PPRec.end(), PPRec);\n}\n\ntemplate <typename InputIterator>\nbool CursorVisitor::visitPreprocessedEntities(InputIterator First,\n                                              InputIterator Last,\n                                              PreprocessingRecord &PPRec,\n                                              FileID FID) {\n  for (; First != Last; ++First) {\n    if (!FID.isInvalid() && !PPRec.isEntityInFileID(First, FID))\n      continue;\n\n    PreprocessedEntity *PPE = *First;\n    if (!PPE)\n      continue;\n\n    if (MacroExpansion *ME = dyn_cast<MacroExpansion>(PPE)) {\n      if (Visit(MakeMacroExpansionCursor(ME, TU)))\n        return true;\n\n      continue;\n    }\n\n    if (MacroDefinitionRecord *MD = dyn_cast<MacroDefinitionRecord>(PPE)) {\n      if (Visit(MakeMacroDefinitionCursor(MD, TU)))\n        return true;\n\n      continue;\n    }\n\n    if (InclusionDirective *ID = dyn_cast<InclusionDirective>(PPE)) {\n      if (Visit(MakeInclusionDirectiveCursor(ID, TU)))\n        return true;\n\n      continue;\n    }\n  }\n\n  return false;\n}\n\n/// Visit the children of the given cursor.\n///\n/// \\returns true if the visitation should be aborted, false if it\n/// should continue.\nbool CursorVisitor::VisitChildren(CXCursor Cursor) {\n  if (clang_isReference(Cursor.kind) &&\n      Cursor.kind != CXCursor_CXXBaseSpecifier) {\n    // By definition, references have no children.\n    return false;\n  }\n\n  // Set the Parent field to Cursor, then back to its old value once we're\n  // done.\n  SetParentRAII SetParent(Parent, StmtParent, Cursor);\n\n  if (clang_isDeclaration(Cursor.kind)) {\n    Decl *D = const_cast<Decl *>(getCursorDecl(Cursor));\n    if (!D)\n      return false;\n\n    return VisitAttributes(D) || Visit(D);\n  }\n\n  if (clang_isStatement(Cursor.kind)) {\n    if (const Stmt *S = getCursorStmt(Cursor))\n      return Visit(S);\n\n    return false;\n  }\n\n  if (clang_isExpression(Cursor.kind)) {\n    if (const Expr *E = getCursorExpr(Cursor))\n      return Visit(E);\n\n    return false;\n  }\n\n  if (clang_isTranslationUnit(Cursor.kind)) {\n    CXTranslationUnit TU = getCursorTU(Cursor);\n    ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n\n    int VisitOrder[2] = {VisitPreprocessorLast, !VisitPreprocessorLast};\n    for (unsigned I = 0; I != 2; ++I) {\n      if (VisitOrder[I]) {\n        if (!CXXUnit->isMainFileAST() && CXXUnit->getOnlyLocalDecls() &&\n            RegionOfInterest.isInvalid()) {\n          for (ASTUnit::top_level_iterator TL = CXXUnit->top_level_begin(),\n                                           TLEnd = CXXUnit->top_level_end();\n               TL != TLEnd; ++TL) {\n            const Optional<bool> V = handleDeclForVisitation(*TL);\n            if (!V.hasValue())\n              continue;\n            return V.getValue();\n          }\n        } else if (VisitDeclContext(\n                       CXXUnit->getASTContext().getTranslationUnitDecl()))\n          return true;\n        continue;\n      }\n\n      // Walk the preprocessing record.\n      if (CXXUnit->getPreprocessor().getPreprocessingRecord())\n        visitPreprocessedEntitiesInRegion();\n    }\n\n    return false;\n  }\n\n  if (Cursor.kind == CXCursor_CXXBaseSpecifier) {\n    if (const CXXBaseSpecifier *Base = getCursorCXXBaseSpecifier(Cursor)) {\n      if (TypeSourceInfo *BaseTSInfo = Base->getTypeSourceInfo()) {\n        return Visit(BaseTSInfo->getTypeLoc());\n      }\n    }\n  }\n\n  if (Cursor.kind == CXCursor_IBOutletCollectionAttr) {\n    const IBOutletCollectionAttr *A =\n        cast<IBOutletCollectionAttr>(cxcursor::getCursorAttr(Cursor));\n    if (const ObjCObjectType *ObjT = A->getInterface()->getAs<ObjCObjectType>())\n      return Visit(cxcursor::MakeCursorObjCClassRef(\n          ObjT->getInterface(),\n          A->getInterfaceLoc()->getTypeLoc().getBeginLoc(), TU));\n  }\n\n  // If pointing inside a macro definition, check if the token is an identifier\n  // that was ever defined as a macro. In such a case, create a \"pseudo\" macro\n  // expansion cursor for that token.\n  SourceLocation BeginLoc = RegionOfInterest.getBegin();\n  if (Cursor.kind == CXCursor_MacroDefinition &&\n      BeginLoc == RegionOfInterest.getEnd()) {\n    SourceLocation Loc = AU->mapLocationToPreamble(BeginLoc);\n    const MacroInfo *MI =\n        getMacroInfo(cxcursor::getCursorMacroDefinition(Cursor), TU);\n    if (MacroDefinitionRecord *MacroDef =\n            checkForMacroInMacroDefinition(MI, Loc, TU))\n      return Visit(cxcursor::MakeMacroExpansionCursor(MacroDef, BeginLoc, TU));\n  }\n\n  // Nothing to visit at the moment.\n  return false;\n}\n\nbool CursorVisitor::VisitBlockDecl(BlockDecl *B) {\n  if (TypeSourceInfo *TSInfo = B->getSignatureAsWritten())\n    if (Visit(TSInfo->getTypeLoc()))\n      return true;\n\n  if (Stmt *Body = B->getBody())\n    return Visit(MakeCXCursor(Body, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nOptional<bool> CursorVisitor::shouldVisitCursor(CXCursor Cursor) {\n  if (RegionOfInterest.isValid()) {\n    SourceRange Range = getFullCursorExtent(Cursor, AU->getSourceManager());\n    if (Range.isInvalid())\n      return None;\n\n    switch (CompareRegionOfInterest(Range)) {\n    case RangeBefore:\n      // This declaration comes before the region of interest; skip it.\n      return None;\n\n    case RangeAfter:\n      // This declaration comes after the region of interest; we're done.\n      return false;\n\n    case RangeOverlap:\n      // This declaration overlaps the region of interest; visit it.\n      break;\n    }\n  }\n  return true;\n}\n\nbool CursorVisitor::VisitDeclContext(DeclContext *DC) {\n  DeclContext::decl_iterator I = DC->decls_begin(), E = DC->decls_end();\n\n  // FIXME: Eventually remove.  This part of a hack to support proper\n  // iteration over all Decls contained lexically within an ObjC container.\n  SaveAndRestore<DeclContext::decl_iterator *> DI_saved(DI_current, &I);\n  SaveAndRestore<DeclContext::decl_iterator> DE_saved(DE_current, E);\n\n  for (; I != E; ++I) {\n    Decl *D = *I;\n    if (D->getLexicalDeclContext() != DC)\n      continue;\n    // Filter out synthesized property accessor redeclarations.\n    if (isa<ObjCImplDecl>(DC))\n      if (auto *OMD = dyn_cast<ObjCMethodDecl>(D))\n        if (OMD->isSynthesizedAccessorStub())\n          continue;\n    const Optional<bool> V = handleDeclForVisitation(D);\n    if (!V.hasValue())\n      continue;\n    return V.getValue();\n  }\n  return false;\n}\n\nOptional<bool> CursorVisitor::handleDeclForVisitation(const Decl *D) {\n  CXCursor Cursor = MakeCXCursor(D, TU, RegionOfInterest);\n\n  // Ignore synthesized ivars here, otherwise if we have something like:\n  //   @synthesize prop = _prop;\n  // and '_prop' is not declared, we will encounter a '_prop' ivar before\n  // encountering the 'prop' synthesize declaration and we will think that\n  // we passed the region-of-interest.\n  if (auto *ivarD = dyn_cast<ObjCIvarDecl>(D)) {\n    if (ivarD->getSynthesize())\n      return None;\n  }\n\n  // FIXME: ObjCClassRef/ObjCProtocolRef for forward class/protocol\n  // declarations is a mismatch with the compiler semantics.\n  if (Cursor.kind == CXCursor_ObjCInterfaceDecl) {\n    auto *ID = cast<ObjCInterfaceDecl>(D);\n    if (!ID->isThisDeclarationADefinition())\n      Cursor = MakeCursorObjCClassRef(ID, ID->getLocation(), TU);\n\n  } else if (Cursor.kind == CXCursor_ObjCProtocolDecl) {\n    auto *PD = cast<ObjCProtocolDecl>(D);\n    if (!PD->isThisDeclarationADefinition())\n      Cursor = MakeCursorObjCProtocolRef(PD, PD->getLocation(), TU);\n  }\n\n  const Optional<bool> V = shouldVisitCursor(Cursor);\n  if (!V.hasValue())\n    return None;\n  if (!V.getValue())\n    return false;\n  if (Visit(Cursor, true))\n    return true;\n  return None;\n}\n\nbool CursorVisitor::VisitTranslationUnitDecl(TranslationUnitDecl *D) {\n  llvm_unreachable(\"Translation units are visited directly by Visit()\");\n}\n\nbool CursorVisitor::VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D) {\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  return Visit(MakeCXCursor(D->getTemplatedDecl(), TU, RegionOfInterest));\n}\n\nbool CursorVisitor::VisitTypeAliasDecl(TypeAliasDecl *D) {\n  if (TypeSourceInfo *TSInfo = D->getTypeSourceInfo())\n    return Visit(TSInfo->getTypeLoc());\n\n  return false;\n}\n\nbool CursorVisitor::VisitTypedefDecl(TypedefDecl *D) {\n  if (TypeSourceInfo *TSInfo = D->getTypeSourceInfo())\n    return Visit(TSInfo->getTypeLoc());\n\n  return false;\n}\n\nbool CursorVisitor::VisitTagDecl(TagDecl *D) { return VisitDeclContext(D); }\n\nbool CursorVisitor::VisitClassTemplateSpecializationDecl(\n    ClassTemplateSpecializationDecl *D) {\n  bool ShouldVisitBody = false;\n  switch (D->getSpecializationKind()) {\n  case TSK_Undeclared:\n  case TSK_ImplicitInstantiation:\n    // Nothing to visit\n    return false;\n\n  case TSK_ExplicitInstantiationDeclaration:\n  case TSK_ExplicitInstantiationDefinition:\n    break;\n\n  case TSK_ExplicitSpecialization:\n    ShouldVisitBody = true;\n    break;\n  }\n\n  // Visit the template arguments used in the specialization.\n  if (TypeSourceInfo *SpecType = D->getTypeAsWritten()) {\n    TypeLoc TL = SpecType->getTypeLoc();\n    if (TemplateSpecializationTypeLoc TSTLoc =\n            TL.getAs<TemplateSpecializationTypeLoc>()) {\n      for (unsigned I = 0, N = TSTLoc.getNumArgs(); I != N; ++I)\n        if (VisitTemplateArgumentLoc(TSTLoc.getArgLoc(I)))\n          return true;\n    }\n  }\n\n  return ShouldVisitBody && VisitCXXRecordDecl(D);\n}\n\nbool CursorVisitor::VisitClassTemplatePartialSpecializationDecl(\n    ClassTemplatePartialSpecializationDecl *D) {\n  // FIXME: Visit the \"outer\" template parameter lists on the TagDecl\n  // before visiting these template parameters.\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  // Visit the partial specialization arguments.\n  const ASTTemplateArgumentListInfo *Info = D->getTemplateArgsAsWritten();\n  const TemplateArgumentLoc *TemplateArgs = Info->getTemplateArgs();\n  for (unsigned I = 0, N = Info->NumTemplateArgs; I != N; ++I)\n    if (VisitTemplateArgumentLoc(TemplateArgs[I]))\n      return true;\n\n  return VisitCXXRecordDecl(D);\n}\n\nbool CursorVisitor::VisitTemplateTypeParmDecl(TemplateTypeParmDecl *D) {\n  if (const auto *TC = D->getTypeConstraint())\n    if (Visit(MakeCXCursor(TC->getImmediatelyDeclaredConstraint(), StmtParent,\n                           TU, RegionOfInterest)))\n      return true;\n\n  // Visit the default argument.\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited())\n    if (TypeSourceInfo *DefArg = D->getDefaultArgumentInfo())\n      if (Visit(DefArg->getTypeLoc()))\n        return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitEnumConstantDecl(EnumConstantDecl *D) {\n  if (Expr *Init = D->getInitExpr())\n    return Visit(MakeCXCursor(Init, StmtParent, TU, RegionOfInterest));\n  return false;\n}\n\nbool CursorVisitor::VisitDeclaratorDecl(DeclaratorDecl *DD) {\n  unsigned NumParamList = DD->getNumTemplateParameterLists();\n  for (unsigned i = 0; i < NumParamList; i++) {\n    TemplateParameterList *Params = DD->getTemplateParameterList(i);\n    if (VisitTemplateParameters(Params))\n      return true;\n  }\n\n  if (TypeSourceInfo *TSInfo = DD->getTypeSourceInfo())\n    if (Visit(TSInfo->getTypeLoc()))\n      return true;\n\n  // Visit the nested-name-specifier, if present.\n  if (NestedNameSpecifierLoc QualifierLoc = DD->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  return false;\n}\n\nstatic bool HasTrailingReturnType(FunctionDecl *ND) {\n  const QualType Ty = ND->getType();\n  if (const FunctionType *AFT = Ty->getAs<FunctionType>()) {\n    if (const FunctionProtoType *FT = dyn_cast<FunctionProtoType>(AFT))\n      return FT->hasTrailingReturn();\n  }\n\n  return false;\n}\n\n/// Compare two base or member initializers based on their source order.\nstatic int CompareCXXCtorInitializers(CXXCtorInitializer *const *X,\n                                      CXXCtorInitializer *const *Y) {\n  return (*X)->getSourceOrder() - (*Y)->getSourceOrder();\n}\n\nbool CursorVisitor::VisitFunctionDecl(FunctionDecl *ND) {\n  unsigned NumParamList = ND->getNumTemplateParameterLists();\n  for (unsigned i = 0; i < NumParamList; i++) {\n    TemplateParameterList *Params = ND->getTemplateParameterList(i);\n    if (VisitTemplateParameters(Params))\n      return true;\n  }\n\n  if (TypeSourceInfo *TSInfo = ND->getTypeSourceInfo()) {\n    // Visit the function declaration's syntactic components in the order\n    // written. This requires a bit of work.\n    TypeLoc TL = TSInfo->getTypeLoc().IgnoreParens();\n    FunctionTypeLoc FTL = TL.getAs<FunctionTypeLoc>();\n    const bool HasTrailingRT = HasTrailingReturnType(ND);\n\n    // If we have a function declared directly (without the use of a typedef),\n    // visit just the return type. Otherwise, just visit the function's type\n    // now.\n    if ((FTL && !isa<CXXConversionDecl>(ND) && !HasTrailingRT &&\n         Visit(FTL.getReturnLoc())) ||\n        (!FTL && Visit(TL)))\n      return true;\n\n    // Visit the nested-name-specifier, if present.\n    if (NestedNameSpecifierLoc QualifierLoc = ND->getQualifierLoc())\n      if (VisitNestedNameSpecifierLoc(QualifierLoc))\n        return true;\n\n    // Visit the declaration name.\n    if (!isa<CXXDestructorDecl>(ND))\n      if (VisitDeclarationNameInfo(ND->getNameInfo()))\n        return true;\n\n    // FIXME: Visit explicitly-specified template arguments!\n\n    // Visit the function parameters, if we have a function type.\n    if (FTL && VisitFunctionTypeLoc(FTL, true))\n      return true;\n\n    // Visit the function's trailing return type.\n    if (FTL && HasTrailingRT && Visit(FTL.getReturnLoc()))\n      return true;\n\n    // FIXME: Attributes?\n  }\n\n  if (ND->doesThisDeclarationHaveABody() && !ND->isLateTemplateParsed()) {\n    if (CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(ND)) {\n      // Find the initializers that were written in the source.\n      SmallVector<CXXCtorInitializer *, 4> WrittenInits;\n      for (auto *I : Constructor->inits()) {\n        if (!I->isWritten())\n          continue;\n\n        WrittenInits.push_back(I);\n      }\n\n      // Sort the initializers in source order\n      llvm::array_pod_sort(WrittenInits.begin(), WrittenInits.end(),\n                           &CompareCXXCtorInitializers);\n\n      // Visit the initializers in source order\n      for (unsigned I = 0, N = WrittenInits.size(); I != N; ++I) {\n        CXXCtorInitializer *Init = WrittenInits[I];\n        if (Init->isAnyMemberInitializer()) {\n          if (Visit(MakeCursorMemberRef(Init->getAnyMember(),\n                                        Init->getMemberLocation(), TU)))\n            return true;\n        } else if (TypeSourceInfo *TInfo = Init->getTypeSourceInfo()) {\n          if (Visit(TInfo->getTypeLoc()))\n            return true;\n        }\n\n        // Visit the initializer value.\n        if (Expr *Initializer = Init->getInit())\n          if (Visit(MakeCXCursor(Initializer, ND, TU, RegionOfInterest)))\n            return true;\n      }\n    }\n\n    if (Visit(MakeCXCursor(ND->getBody(), StmtParent, TU, RegionOfInterest)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitFieldDecl(FieldDecl *D) {\n  if (VisitDeclaratorDecl(D))\n    return true;\n\n  if (Expr *BitWidth = D->getBitWidth())\n    return Visit(MakeCXCursor(BitWidth, StmtParent, TU, RegionOfInterest));\n\n  if (Expr *Init = D->getInClassInitializer())\n    return Visit(MakeCXCursor(Init, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nbool CursorVisitor::VisitVarDecl(VarDecl *D) {\n  if (VisitDeclaratorDecl(D))\n    return true;\n\n  if (Expr *Init = D->getInit())\n    return Visit(MakeCXCursor(Init, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nbool CursorVisitor::VisitNonTypeTemplateParmDecl(NonTypeTemplateParmDecl *D) {\n  if (VisitDeclaratorDecl(D))\n    return true;\n\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited())\n    if (Expr *DefArg = D->getDefaultArgument())\n      return Visit(MakeCXCursor(DefArg, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nbool CursorVisitor::VisitFunctionTemplateDecl(FunctionTemplateDecl *D) {\n  // FIXME: Visit the \"outer\" template parameter lists on the FunctionDecl\n  // before visiting these template parameters.\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  auto *FD = D->getTemplatedDecl();\n  return VisitAttributes(FD) || VisitFunctionDecl(FD);\n}\n\nbool CursorVisitor::VisitClassTemplateDecl(ClassTemplateDecl *D) {\n  // FIXME: Visit the \"outer\" template parameter lists on the TagDecl\n  // before visiting these template parameters.\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  auto *CD = D->getTemplatedDecl();\n  return VisitAttributes(CD) || VisitCXXRecordDecl(CD);\n}\n\nbool CursorVisitor::VisitTemplateTemplateParmDecl(TemplateTemplateParmDecl *D) {\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited() &&\n      VisitTemplateArgumentLoc(D->getDefaultArgument()))\n    return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCTypeParamDecl(ObjCTypeParamDecl *D) {\n  // Visit the bound, if it's explicit.\n  if (D->hasExplicitBound()) {\n    if (auto TInfo = D->getTypeSourceInfo()) {\n      if (Visit(TInfo->getTypeLoc()))\n        return true;\n    }\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCMethodDecl(ObjCMethodDecl *ND) {\n  if (TypeSourceInfo *TSInfo = ND->getReturnTypeSourceInfo())\n    if (Visit(TSInfo->getTypeLoc()))\n      return true;\n\n  for (const auto *P : ND->parameters()) {\n    if (Visit(MakeCXCursor(P, TU, RegionOfInterest)))\n      return true;\n  }\n\n  return ND->isThisDeclarationADefinition() &&\n         Visit(MakeCXCursor(ND->getBody(), StmtParent, TU, RegionOfInterest));\n}\n\ntemplate <typename DeclIt>\nstatic void addRangedDeclsInContainer(DeclIt *DI_current, DeclIt DE_current,\n                                      SourceManager &SM, SourceLocation EndLoc,\n                                      SmallVectorImpl<Decl *> &Decls) {\n  DeclIt next = *DI_current;\n  while (++next != DE_current) {\n    Decl *D_next = *next;\n    if (!D_next)\n      break;\n    SourceLocation L = D_next->getBeginLoc();\n    if (!L.isValid())\n      break;\n    if (SM.isBeforeInTranslationUnit(L, EndLoc)) {\n      *DI_current = next;\n      Decls.push_back(D_next);\n      continue;\n    }\n    break;\n  }\n}\n\nbool CursorVisitor::VisitObjCContainerDecl(ObjCContainerDecl *D) {\n  // FIXME: Eventually convert back to just 'VisitDeclContext()'.  Essentially\n  // an @implementation can lexically contain Decls that are not properly\n  // nested in the AST.  When we identify such cases, we need to retrofit\n  // this nesting here.\n  if (!DI_current && !FileDI_current)\n    return VisitDeclContext(D);\n\n  // Scan the Decls that immediately come after the container\n  // in the current DeclContext.  If any fall within the\n  // container's lexical region, stash them into a vector\n  // for later processing.\n  SmallVector<Decl *, 24> DeclsInContainer;\n  SourceLocation EndLoc = D->getSourceRange().getEnd();\n  SourceManager &SM = AU->getSourceManager();\n  if (EndLoc.isValid()) {\n    if (DI_current) {\n      addRangedDeclsInContainer(DI_current, DE_current, SM, EndLoc,\n                                DeclsInContainer);\n    } else {\n      addRangedDeclsInContainer(FileDI_current, FileDE_current, SM, EndLoc,\n                                DeclsInContainer);\n    }\n  }\n\n  // The common case.\n  if (DeclsInContainer.empty())\n    return VisitDeclContext(D);\n\n  // Get all the Decls in the DeclContext, and sort them with the\n  // additional ones we've collected.  Then visit them.\n  for (auto *SubDecl : D->decls()) {\n    if (!SubDecl || SubDecl->getLexicalDeclContext() != D ||\n        SubDecl->getBeginLoc().isInvalid())\n      continue;\n    DeclsInContainer.push_back(SubDecl);\n  }\n\n  // Now sort the Decls so that they appear in lexical order.\n  llvm::sort(DeclsInContainer, [&SM](Decl *A, Decl *B) {\n    SourceLocation L_A = A->getBeginLoc();\n    SourceLocation L_B = B->getBeginLoc();\n    return L_A != L_B\n               ? SM.isBeforeInTranslationUnit(L_A, L_B)\n               : SM.isBeforeInTranslationUnit(A->getEndLoc(), B->getEndLoc());\n  });\n\n  // Now visit the decls.\n  for (SmallVectorImpl<Decl *>::iterator I = DeclsInContainer.begin(),\n                                         E = DeclsInContainer.end();\n       I != E; ++I) {\n    CXCursor Cursor = MakeCXCursor(*I, TU, RegionOfInterest);\n    const Optional<bool> &V = shouldVisitCursor(Cursor);\n    if (!V.hasValue())\n      continue;\n    if (!V.getValue())\n      return false;\n    if (Visit(Cursor, true))\n      return true;\n  }\n  return false;\n}\n\nbool CursorVisitor::VisitObjCCategoryDecl(ObjCCategoryDecl *ND) {\n  if (Visit(MakeCursorObjCClassRef(ND->getClassInterface(), ND->getLocation(),\n                                   TU)))\n    return true;\n\n  if (VisitObjCTypeParamList(ND->getTypeParamList()))\n    return true;\n\n  ObjCCategoryDecl::protocol_loc_iterator PL = ND->protocol_loc_begin();\n  for (ObjCCategoryDecl::protocol_iterator I = ND->protocol_begin(),\n                                           E = ND->protocol_end();\n       I != E; ++I, ++PL)\n    if (Visit(MakeCursorObjCProtocolRef(*I, *PL, TU)))\n      return true;\n\n  return VisitObjCContainerDecl(ND);\n}\n\nbool CursorVisitor::VisitObjCProtocolDecl(ObjCProtocolDecl *PID) {\n  if (!PID->isThisDeclarationADefinition())\n    return Visit(MakeCursorObjCProtocolRef(PID, PID->getLocation(), TU));\n\n  ObjCProtocolDecl::protocol_loc_iterator PL = PID->protocol_loc_begin();\n  for (ObjCProtocolDecl::protocol_iterator I = PID->protocol_begin(),\n                                           E = PID->protocol_end();\n       I != E; ++I, ++PL)\n    if (Visit(MakeCursorObjCProtocolRef(*I, *PL, TU)))\n      return true;\n\n  return VisitObjCContainerDecl(PID);\n}\n\nbool CursorVisitor::VisitObjCPropertyDecl(ObjCPropertyDecl *PD) {\n  if (PD->getTypeSourceInfo() && Visit(PD->getTypeSourceInfo()->getTypeLoc()))\n    return true;\n\n  // FIXME: This implements a workaround with @property declarations also being\n  // installed in the DeclContext for the @interface.  Eventually this code\n  // should be removed.\n  ObjCCategoryDecl *CDecl = dyn_cast<ObjCCategoryDecl>(PD->getDeclContext());\n  if (!CDecl || !CDecl->IsClassExtension())\n    return false;\n\n  ObjCInterfaceDecl *ID = CDecl->getClassInterface();\n  if (!ID)\n    return false;\n\n  IdentifierInfo *PropertyId = PD->getIdentifier();\n  ObjCPropertyDecl *prevDecl = ObjCPropertyDecl::findPropertyDecl(\n      cast<DeclContext>(ID), PropertyId, PD->getQueryKind());\n\n  if (!prevDecl)\n    return false;\n\n  // Visit synthesized methods since they will be skipped when visiting\n  // the @interface.\n  if (ObjCMethodDecl *MD = prevDecl->getGetterMethodDecl())\n    if (MD->isPropertyAccessor() && MD->getLexicalDeclContext() == CDecl)\n      if (Visit(MakeCXCursor(MD, TU, RegionOfInterest)))\n        return true;\n\n  if (ObjCMethodDecl *MD = prevDecl->getSetterMethodDecl())\n    if (MD->isPropertyAccessor() && MD->getLexicalDeclContext() == CDecl)\n      if (Visit(MakeCXCursor(MD, TU, RegionOfInterest)))\n        return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCTypeParamList(ObjCTypeParamList *typeParamList) {\n  if (!typeParamList)\n    return false;\n\n  for (auto *typeParam : *typeParamList) {\n    // Visit the type parameter.\n    if (Visit(MakeCXCursor(typeParam, TU, RegionOfInterest)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCInterfaceDecl(ObjCInterfaceDecl *D) {\n  if (!D->isThisDeclarationADefinition()) {\n    // Forward declaration is treated like a reference.\n    return Visit(MakeCursorObjCClassRef(D, D->getLocation(), TU));\n  }\n\n  // Objective-C type parameters.\n  if (VisitObjCTypeParamList(D->getTypeParamListAsWritten()))\n    return true;\n\n  // Issue callbacks for super class.\n  if (D->getSuperClass() && Visit(MakeCursorObjCSuperClassRef(\n                                D->getSuperClass(), D->getSuperClassLoc(), TU)))\n    return true;\n\n  if (TypeSourceInfo *SuperClassTInfo = D->getSuperClassTInfo())\n    if (Visit(SuperClassTInfo->getTypeLoc()))\n      return true;\n\n  ObjCInterfaceDecl::protocol_loc_iterator PL = D->protocol_loc_begin();\n  for (ObjCInterfaceDecl::protocol_iterator I = D->protocol_begin(),\n                                            E = D->protocol_end();\n       I != E; ++I, ++PL)\n    if (Visit(MakeCursorObjCProtocolRef(*I, *PL, TU)))\n      return true;\n\n  return VisitObjCContainerDecl(D);\n}\n\nbool CursorVisitor::VisitObjCImplDecl(ObjCImplDecl *D) {\n  return VisitObjCContainerDecl(D);\n}\n\nbool CursorVisitor::VisitObjCCategoryImplDecl(ObjCCategoryImplDecl *D) {\n  // 'ID' could be null when dealing with invalid code.\n  if (ObjCInterfaceDecl *ID = D->getClassInterface())\n    if (Visit(MakeCursorObjCClassRef(ID, D->getLocation(), TU)))\n      return true;\n\n  return VisitObjCImplDecl(D);\n}\n\nbool CursorVisitor::VisitObjCImplementationDecl(ObjCImplementationDecl *D) {\n#if 0\n  // Issue callbacks for super class.\n  // FIXME: No source location information!\n  if (D->getSuperClass() &&\n      Visit(MakeCursorObjCSuperClassRef(D->getSuperClass(),\n                                        D->getSuperClassLoc(),\n                                        TU)))\n    return true;\n#endif\n\n  return VisitObjCImplDecl(D);\n}\n\nbool CursorVisitor::VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *PD) {\n  if (ObjCIvarDecl *Ivar = PD->getPropertyIvarDecl())\n    if (PD->isIvarNameSpecified())\n      return Visit(MakeCursorMemberRef(Ivar, PD->getPropertyIvarDeclLoc(), TU));\n\n  return false;\n}\n\nbool CursorVisitor::VisitNamespaceDecl(NamespaceDecl *D) {\n  return VisitDeclContext(D);\n}\n\nbool CursorVisitor::VisitNamespaceAliasDecl(NamespaceAliasDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  return Visit(MakeCursorNamespaceRef(D->getAliasedNamespace(),\n                                      D->getTargetNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitUsingDecl(UsingDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc()) {\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n  }\n\n  if (Visit(MakeCursorOverloadedDeclRef(D, D->getLocation(), TU)))\n    return true;\n\n  return VisitDeclarationNameInfo(D->getNameInfo());\n}\n\nbool CursorVisitor::VisitUsingDirectiveDecl(UsingDirectiveDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  return Visit(MakeCursorNamespaceRef(D->getNominatedNamespaceAsWritten(),\n                                      D->getIdentLocation(), TU));\n}\n\nbool CursorVisitor::VisitUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc()) {\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n  }\n\n  return VisitDeclarationNameInfo(D->getNameInfo());\n}\n\nbool CursorVisitor::VisitUnresolvedUsingTypenameDecl(\n    UnresolvedUsingTypenameDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitStaticAssertDecl(StaticAssertDecl *D) {\n  if (Visit(MakeCXCursor(D->getAssertExpr(), StmtParent, TU, RegionOfInterest)))\n    return true;\n  if (StringLiteral *Message = D->getMessage())\n    if (Visit(MakeCXCursor(Message, StmtParent, TU, RegionOfInterest)))\n      return true;\n  return false;\n}\n\nbool CursorVisitor::VisitFriendDecl(FriendDecl *D) {\n  if (NamedDecl *FriendD = D->getFriendDecl()) {\n    if (Visit(MakeCXCursor(FriendD, TU, RegionOfInterest)))\n      return true;\n  } else if (TypeSourceInfo *TI = D->getFriendType()) {\n    if (Visit(TI->getTypeLoc()))\n      return true;\n  }\n  return false;\n}\n\nbool CursorVisitor::VisitDecompositionDecl(DecompositionDecl *D) {\n  for (auto *B : D->bindings()) {\n    if (Visit(MakeCXCursor(B, TU, RegionOfInterest)))\n      return true;\n  }\n  return VisitVarDecl(D);\n}\n\nbool CursorVisitor::VisitDeclarationNameInfo(DeclarationNameInfo Name) {\n  switch (Name.getName().getNameKind()) {\n  case clang::DeclarationName::Identifier:\n  case clang::DeclarationName::CXXLiteralOperatorName:\n  case clang::DeclarationName::CXXDeductionGuideName:\n  case clang::DeclarationName::CXXOperatorName:\n  case clang::DeclarationName::CXXUsingDirective:\n    return false;\n\n  case clang::DeclarationName::CXXConstructorName:\n  case clang::DeclarationName::CXXDestructorName:\n  case clang::DeclarationName::CXXConversionFunctionName:\n    if (TypeSourceInfo *TSInfo = Name.getNamedTypeInfo())\n      return Visit(TSInfo->getTypeLoc());\n    return false;\n\n  case clang::DeclarationName::ObjCZeroArgSelector:\n  case clang::DeclarationName::ObjCOneArgSelector:\n  case clang::DeclarationName::ObjCMultiArgSelector:\n    // FIXME: Per-identifier location info?\n    return false;\n  }\n\n  llvm_unreachable(\"Invalid DeclarationName::Kind!\");\n}\n\nbool CursorVisitor::VisitNestedNameSpecifier(NestedNameSpecifier *NNS,\n                                             SourceRange Range) {\n  // FIXME: This whole routine is a hack to work around the lack of proper\n  // source information in nested-name-specifiers (PR5791). Since we do have\n  // a beginning source location, we can visit the first component of the\n  // nested-name-specifier, if it's a single-token component.\n  if (!NNS)\n    return false;\n\n  // Get the first component in the nested-name-specifier.\n  while (NestedNameSpecifier *Prefix = NNS->getPrefix())\n    NNS = Prefix;\n\n  switch (NNS->getKind()) {\n  case NestedNameSpecifier::Namespace:\n    return Visit(\n        MakeCursorNamespaceRef(NNS->getAsNamespace(), Range.getBegin(), TU));\n\n  case NestedNameSpecifier::NamespaceAlias:\n    return Visit(MakeCursorNamespaceRef(NNS->getAsNamespaceAlias(),\n                                        Range.getBegin(), TU));\n\n  case NestedNameSpecifier::TypeSpec: {\n    // If the type has a form where we know that the beginning of the source\n    // range matches up with a reference cursor. Visit the appropriate reference\n    // cursor.\n    const Type *T = NNS->getAsType();\n    if (const TypedefType *Typedef = dyn_cast<TypedefType>(T))\n      return Visit(MakeCursorTypeRef(Typedef->getDecl(), Range.getBegin(), TU));\n    if (const TagType *Tag = dyn_cast<TagType>(T))\n      return Visit(MakeCursorTypeRef(Tag->getDecl(), Range.getBegin(), TU));\n    if (const TemplateSpecializationType *TST =\n            dyn_cast<TemplateSpecializationType>(T))\n      return VisitTemplateName(TST->getTemplateName(), Range.getBegin());\n    break;\n  }\n\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n  case NestedNameSpecifier::Global:\n  case NestedNameSpecifier::Identifier:\n  case NestedNameSpecifier::Super:\n    break;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitNestedNameSpecifierLoc(\n    NestedNameSpecifierLoc Qualifier) {\n  SmallVector<NestedNameSpecifierLoc, 4> Qualifiers;\n  for (; Qualifier; Qualifier = Qualifier.getPrefix())\n    Qualifiers.push_back(Qualifier);\n\n  while (!Qualifiers.empty()) {\n    NestedNameSpecifierLoc Q = Qualifiers.pop_back_val();\n    NestedNameSpecifier *NNS = Q.getNestedNameSpecifier();\n    switch (NNS->getKind()) {\n    case NestedNameSpecifier::Namespace:\n      if (Visit(MakeCursorNamespaceRef(NNS->getAsNamespace(),\n                                       Q.getLocalBeginLoc(), TU)))\n        return true;\n\n      break;\n\n    case NestedNameSpecifier::NamespaceAlias:\n      if (Visit(MakeCursorNamespaceRef(NNS->getAsNamespaceAlias(),\n                                       Q.getLocalBeginLoc(), TU)))\n        return true;\n\n      break;\n\n    case NestedNameSpecifier::TypeSpec:\n    case NestedNameSpecifier::TypeSpecWithTemplate:\n      if (Visit(Q.getTypeLoc()))\n        return true;\n\n      break;\n\n    case NestedNameSpecifier::Global:\n    case NestedNameSpecifier::Identifier:\n    case NestedNameSpecifier::Super:\n      break;\n    }\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitTemplateParameters(\n    const TemplateParameterList *Params) {\n  if (!Params)\n    return false;\n\n  for (TemplateParameterList::const_iterator P = Params->begin(),\n                                             PEnd = Params->end();\n       P != PEnd; ++P) {\n    if (Visit(MakeCXCursor(*P, TU, RegionOfInterest)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitTemplateName(TemplateName Name, SourceLocation Loc) {\n  switch (Name.getKind()) {\n  case TemplateName::Template:\n    return Visit(MakeCursorTemplateRef(Name.getAsTemplateDecl(), Loc, TU));\n\n  case TemplateName::OverloadedTemplate:\n    // Visit the overloaded template set.\n    if (Visit(MakeCursorOverloadedDeclRef(Name, Loc, TU)))\n      return true;\n\n    return false;\n\n  case TemplateName::AssumedTemplate:\n    // FIXME: Visit DeclarationName?\n    return false;\n\n  case TemplateName::DependentTemplate:\n    // FIXME: Visit nested-name-specifier.\n    return false;\n\n  case TemplateName::QualifiedTemplate:\n    // FIXME: Visit nested-name-specifier.\n    return Visit(MakeCursorTemplateRef(\n        Name.getAsQualifiedTemplateName()->getDecl(), Loc, TU));\n\n  case TemplateName::SubstTemplateTemplateParm:\n    return Visit(MakeCursorTemplateRef(\n        Name.getAsSubstTemplateTemplateParm()->getParameter(), Loc, TU));\n\n  case TemplateName::SubstTemplateTemplateParmPack:\n    return Visit(MakeCursorTemplateRef(\n        Name.getAsSubstTemplateTemplateParmPack()->getParameterPack(), Loc,\n        TU));\n  }\n\n  llvm_unreachable(\"Invalid TemplateName::Kind!\");\n}\n\nbool CursorVisitor::VisitTemplateArgumentLoc(const TemplateArgumentLoc &TAL) {\n  switch (TAL.getArgument().getKind()) {\n  case TemplateArgument::Null:\n  case TemplateArgument::Integral:\n  case TemplateArgument::Pack:\n    return false;\n\n  case TemplateArgument::Type:\n    if (TypeSourceInfo *TSInfo = TAL.getTypeSourceInfo())\n      return Visit(TSInfo->getTypeLoc());\n    return false;\n\n  case TemplateArgument::Declaration:\n    if (Expr *E = TAL.getSourceDeclExpression())\n      return Visit(MakeCXCursor(E, StmtParent, TU, RegionOfInterest));\n    return false;\n\n  case TemplateArgument::NullPtr:\n    if (Expr *E = TAL.getSourceNullPtrExpression())\n      return Visit(MakeCXCursor(E, StmtParent, TU, RegionOfInterest));\n    return false;\n\n  case TemplateArgument::Expression:\n    if (Expr *E = TAL.getSourceExpression())\n      return Visit(MakeCXCursor(E, StmtParent, TU, RegionOfInterest));\n    return false;\n\n  case TemplateArgument::Template:\n  case TemplateArgument::TemplateExpansion:\n    if (VisitNestedNameSpecifierLoc(TAL.getTemplateQualifierLoc()))\n      return true;\n\n    return VisitTemplateName(TAL.getArgument().getAsTemplateOrTemplatePattern(),\n                             TAL.getTemplateNameLoc());\n  }\n\n  llvm_unreachable(\"Invalid TemplateArgument::Kind!\");\n}\n\nbool CursorVisitor::VisitLinkageSpecDecl(LinkageSpecDecl *D) {\n  return VisitDeclContext(D);\n}\n\nbool CursorVisitor::VisitQualifiedTypeLoc(QualifiedTypeLoc TL) {\n  return Visit(TL.getUnqualifiedLoc());\n}\n\nbool CursorVisitor::VisitBuiltinTypeLoc(BuiltinTypeLoc TL) {\n  ASTContext &Context = AU->getASTContext();\n\n  // Some builtin types (such as Objective-C's \"id\", \"sel\", and\n  // \"Class\") have associated declarations. Create cursors for those.\n  QualType VisitType;\n  switch (TL.getTypePtr()->getKind()) {\n\n  case BuiltinType::Void:\n  case BuiltinType::NullPtr:\n  case BuiltinType::Dependent:\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \\\n  case BuiltinType::Id:\n#include \"clang/Basic/OpenCLImageTypes.def\"\n#define EXT_OPAQUE_TYPE(ExtTYpe, Id, Ext) case BuiltinType::Id:\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n  case BuiltinType::OCLSampler:\n  case BuiltinType::OCLEvent:\n  case BuiltinType::OCLClkEvent:\n  case BuiltinType::OCLQueue:\n  case BuiltinType::OCLReserveID:\n#define SVE_TYPE(Name, Id, SingletonId) case BuiltinType::Id:\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) case BuiltinType::Id:\n#include \"clang/Basic/PPCTypes.def\"\n#define BUILTIN_TYPE(Id, SingletonId)\n#define SIGNED_TYPE(Id, SingletonId) case BuiltinType::Id:\n#define UNSIGNED_TYPE(Id, SingletonId) case BuiltinType::Id:\n#define FLOATING_TYPE(Id, SingletonId) case BuiltinType::Id:\n#define PLACEHOLDER_TYPE(Id, SingletonId) case BuiltinType::Id:\n#include \"clang/AST/BuiltinTypes.def\"\n    break;\n\n  case BuiltinType::ObjCId:\n    VisitType = Context.getObjCIdType();\n    break;\n\n  case BuiltinType::ObjCClass:\n    VisitType = Context.getObjCClassType();\n    break;\n\n  case BuiltinType::ObjCSel:\n    VisitType = Context.getObjCSelType();\n    break;\n  }\n\n  if (!VisitType.isNull()) {\n    if (const TypedefType *Typedef = VisitType->getAs<TypedefType>())\n      return Visit(\n          MakeCursorTypeRef(Typedef->getDecl(), TL.getBuiltinLoc(), TU));\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitTypedefTypeLoc(TypedefTypeLoc TL) {\n  return Visit(MakeCursorTypeRef(TL.getTypedefNameDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitUnresolvedUsingTypeLoc(UnresolvedUsingTypeLoc TL) {\n  return Visit(MakeCursorTypeRef(TL.getDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitTagTypeLoc(TagTypeLoc TL) {\n  if (TL.isDefinition())\n    return Visit(MakeCXCursor(TL.getDecl(), TU, RegionOfInterest));\n\n  return Visit(MakeCursorTypeRef(TL.getDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitTemplateTypeParmTypeLoc(TemplateTypeParmTypeLoc TL) {\n  return Visit(MakeCursorTypeRef(TL.getDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitObjCInterfaceTypeLoc(ObjCInterfaceTypeLoc TL) {\n  return Visit(MakeCursorObjCClassRef(TL.getIFaceDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitObjCTypeParamTypeLoc(ObjCTypeParamTypeLoc TL) {\n  if (Visit(MakeCursorTypeRef(TL.getDecl(), TL.getBeginLoc(), TU)))\n    return true;\n  for (unsigned I = 0, N = TL.getNumProtocols(); I != N; ++I) {\n    if (Visit(MakeCursorObjCProtocolRef(TL.getProtocol(I), TL.getProtocolLoc(I),\n                                        TU)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCObjectTypeLoc(ObjCObjectTypeLoc TL) {\n  if (TL.hasBaseTypeAsWritten() && Visit(TL.getBaseLoc()))\n    return true;\n\n  for (unsigned I = 0, N = TL.getNumTypeArgs(); I != N; ++I) {\n    if (Visit(TL.getTypeArgTInfo(I)->getTypeLoc()))\n      return true;\n  }\n\n  for (unsigned I = 0, N = TL.getNumProtocols(); I != N; ++I) {\n    if (Visit(MakeCursorObjCProtocolRef(TL.getProtocol(I), TL.getProtocolLoc(I),\n                                        TU)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCObjectPointerTypeLoc(ObjCObjectPointerTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitParenTypeLoc(ParenTypeLoc TL) {\n  return Visit(TL.getInnerLoc());\n}\n\nbool CursorVisitor::VisitMacroQualifiedTypeLoc(MacroQualifiedTypeLoc TL) {\n  return Visit(TL.getInnerLoc());\n}\n\nbool CursorVisitor::VisitPointerTypeLoc(PointerTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitBlockPointerTypeLoc(BlockPointerTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitMemberPointerTypeLoc(MemberPointerTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitLValueReferenceTypeLoc(LValueReferenceTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitRValueReferenceTypeLoc(RValueReferenceTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitAttributedTypeLoc(AttributedTypeLoc TL) {\n  return Visit(TL.getModifiedLoc());\n}\n\nbool CursorVisitor::VisitFunctionTypeLoc(FunctionTypeLoc TL,\n                                         bool SkipResultType) {\n  if (!SkipResultType && Visit(TL.getReturnLoc()))\n    return true;\n\n  for (unsigned I = 0, N = TL.getNumParams(); I != N; ++I)\n    if (Decl *D = TL.getParam(I))\n      if (Visit(MakeCXCursor(D, TU, RegionOfInterest)))\n        return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitArrayTypeLoc(ArrayTypeLoc TL) {\n  if (Visit(TL.getElementLoc()))\n    return true;\n\n  if (Expr *Size = TL.getSizeExpr())\n    return Visit(MakeCXCursor(Size, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nbool CursorVisitor::VisitDecayedTypeLoc(DecayedTypeLoc TL) {\n  return Visit(TL.getOriginalLoc());\n}\n\nbool CursorVisitor::VisitAdjustedTypeLoc(AdjustedTypeLoc TL) {\n  return Visit(TL.getOriginalLoc());\n}\n\nbool CursorVisitor::VisitDeducedTemplateSpecializationTypeLoc(\n    DeducedTemplateSpecializationTypeLoc TL) {\n  if (VisitTemplateName(TL.getTypePtr()->getTemplateName(),\n                        TL.getTemplateNameLoc()))\n    return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitTemplateSpecializationTypeLoc(\n    TemplateSpecializationTypeLoc TL) {\n  // Visit the template name.\n  if (VisitTemplateName(TL.getTypePtr()->getTemplateName(),\n                        TL.getTemplateNameLoc()))\n    return true;\n\n  // Visit the template arguments.\n  for (unsigned I = 0, N = TL.getNumArgs(); I != N; ++I)\n    if (VisitTemplateArgumentLoc(TL.getArgLoc(I)))\n      return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitTypeOfExprTypeLoc(TypeOfExprTypeLoc TL) {\n  return Visit(MakeCXCursor(TL.getUnderlyingExpr(), StmtParent, TU));\n}\n\nbool CursorVisitor::VisitTypeOfTypeLoc(TypeOfTypeLoc TL) {\n  if (TypeSourceInfo *TSInfo = TL.getUnderlyingTInfo())\n    return Visit(TSInfo->getTypeLoc());\n\n  return false;\n}\n\nbool CursorVisitor::VisitUnaryTransformTypeLoc(UnaryTransformTypeLoc TL) {\n  if (TypeSourceInfo *TSInfo = TL.getUnderlyingTInfo())\n    return Visit(TSInfo->getTypeLoc());\n\n  return false;\n}\n\nbool CursorVisitor::VisitDependentNameTypeLoc(DependentNameTypeLoc TL) {\n  return VisitNestedNameSpecifierLoc(TL.getQualifierLoc());\n}\n\nbool CursorVisitor::VisitDependentTemplateSpecializationTypeLoc(\n    DependentTemplateSpecializationTypeLoc TL) {\n  // Visit the nested-name-specifier, if there is one.\n  if (TL.getQualifierLoc() && VisitNestedNameSpecifierLoc(TL.getQualifierLoc()))\n    return true;\n\n  // Visit the template arguments.\n  for (unsigned I = 0, N = TL.getNumArgs(); I != N; ++I)\n    if (VisitTemplateArgumentLoc(TL.getArgLoc(I)))\n      return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitElaboratedTypeLoc(ElaboratedTypeLoc TL) {\n  if (VisitNestedNameSpecifierLoc(TL.getQualifierLoc()))\n    return true;\n\n  return Visit(TL.getNamedTypeLoc());\n}\n\nbool CursorVisitor::VisitPackExpansionTypeLoc(PackExpansionTypeLoc TL) {\n  return Visit(TL.getPatternLoc());\n}\n\nbool CursorVisitor::VisitDecltypeTypeLoc(DecltypeTypeLoc TL) {\n  if (Expr *E = TL.getUnderlyingExpr())\n    return Visit(MakeCXCursor(E, StmtParent, TU));\n\n  return false;\n}\n\nbool CursorVisitor::VisitInjectedClassNameTypeLoc(InjectedClassNameTypeLoc TL) {\n  return Visit(MakeCursorTypeRef(TL.getDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitAtomicTypeLoc(AtomicTypeLoc TL) {\n  return Visit(TL.getValueLoc());\n}\n\nbool CursorVisitor::VisitPipeTypeLoc(PipeTypeLoc TL) {\n  return Visit(TL.getValueLoc());\n}\n\n#define DEFAULT_TYPELOC_IMPL(CLASS, PARENT)                                    \\\n  bool CursorVisitor::Visit##CLASS##TypeLoc(CLASS##TypeLoc TL) {               \\\n    return Visit##PARENT##Loc(TL);                                             \\\n  }\n\nDEFAULT_TYPELOC_IMPL(Complex, Type)\nDEFAULT_TYPELOC_IMPL(ConstantArray, ArrayType)\nDEFAULT_TYPELOC_IMPL(IncompleteArray, ArrayType)\nDEFAULT_TYPELOC_IMPL(VariableArray, ArrayType)\nDEFAULT_TYPELOC_IMPL(DependentSizedArray, ArrayType)\nDEFAULT_TYPELOC_IMPL(DependentAddressSpace, Type)\nDEFAULT_TYPELOC_IMPL(DependentVector, Type)\nDEFAULT_TYPELOC_IMPL(DependentSizedExtVector, Type)\nDEFAULT_TYPELOC_IMPL(Vector, Type)\nDEFAULT_TYPELOC_IMPL(ExtVector, VectorType)\nDEFAULT_TYPELOC_IMPL(ConstantMatrix, MatrixType)\nDEFAULT_TYPELOC_IMPL(DependentSizedMatrix, MatrixType)\nDEFAULT_TYPELOC_IMPL(FunctionProto, FunctionType)\nDEFAULT_TYPELOC_IMPL(FunctionNoProto, FunctionType)\nDEFAULT_TYPELOC_IMPL(Record, TagType)\nDEFAULT_TYPELOC_IMPL(Enum, TagType)\nDEFAULT_TYPELOC_IMPL(SubstTemplateTypeParm, Type)\nDEFAULT_TYPELOC_IMPL(SubstTemplateTypeParmPack, Type)\nDEFAULT_TYPELOC_IMPL(Auto, Type)\nDEFAULT_TYPELOC_IMPL(ExtInt, Type)\nDEFAULT_TYPELOC_IMPL(DependentExtInt, Type)\n\nbool CursorVisitor::VisitCXXRecordDecl(CXXRecordDecl *D) {\n  // Visit the nested-name-specifier, if present.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  if (D->isCompleteDefinition()) {\n    for (const auto &I : D->bases()) {\n      if (Visit(cxcursor::MakeCursorCXXBaseSpecifier(&I, TU)))\n        return true;\n    }\n  }\n\n  return VisitTagDecl(D);\n}\n\nbool CursorVisitor::VisitAttributes(Decl *D) {\n  for (const auto *I : D->attrs())\n    if ((TU->ParsingOptions & CXTranslationUnit_VisitImplicitAttributes ||\n         !I->isImplicit()) &&\n        Visit(MakeCXCursor(I, D, TU)))\n      return true;\n\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Data-recursive visitor methods.\n//===----------------------------------------------------------------------===//\n\nnamespace {\n#define DEF_JOB(NAME, DATA, KIND)                                              \\\n  class NAME : public VisitorJob {                                             \\\n  public:                                                                      \\\n    NAME(const DATA *d, CXCursor parent)                                       \\\n        : VisitorJob(parent, VisitorJob::KIND, d) {}                           \\\n    static bool classof(const VisitorJob *VJ) {                                \\\n      return VJ->getKind() == KIND;                                            \\\n    }                                                                          \\\n    const DATA *get() const { return static_cast<const DATA *>(data[0]); }     \\\n  };\n\nDEF_JOB(StmtVisit, Stmt, StmtVisitKind)\nDEF_JOB(MemberExprParts, MemberExpr, MemberExprPartsKind)\nDEF_JOB(DeclRefExprParts, DeclRefExpr, DeclRefExprPartsKind)\nDEF_JOB(OverloadExprParts, OverloadExpr, OverloadExprPartsKind)\nDEF_JOB(SizeOfPackExprParts, SizeOfPackExpr, SizeOfPackExprPartsKind)\nDEF_JOB(LambdaExprParts, LambdaExpr, LambdaExprPartsKind)\nDEF_JOB(PostChildrenVisit, void, PostChildrenVisitKind)\n#undef DEF_JOB\n\nclass ExplicitTemplateArgsVisit : public VisitorJob {\npublic:\n  ExplicitTemplateArgsVisit(const TemplateArgumentLoc *Begin,\n                            const TemplateArgumentLoc *End, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::ExplicitTemplateArgsVisitKind, Begin,\n                   End) {}\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == ExplicitTemplateArgsVisitKind;\n  }\n  const TemplateArgumentLoc *begin() const {\n    return static_cast<const TemplateArgumentLoc *>(data[0]);\n  }\n  const TemplateArgumentLoc *end() {\n    return static_cast<const TemplateArgumentLoc *>(data[1]);\n  }\n};\nclass DeclVisit : public VisitorJob {\npublic:\n  DeclVisit(const Decl *D, CXCursor parent, bool isFirst)\n      : VisitorJob(parent, VisitorJob::DeclVisitKind, D,\n                   isFirst ? (void *)1 : (void *)nullptr) {}\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == DeclVisitKind;\n  }\n  const Decl *get() const { return static_cast<const Decl *>(data[0]); }\n  bool isFirst() const { return data[1] != nullptr; }\n};\nclass TypeLocVisit : public VisitorJob {\npublic:\n  TypeLocVisit(TypeLoc tl, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::TypeLocVisitKind,\n                   tl.getType().getAsOpaquePtr(), tl.getOpaqueData()) {}\n\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == TypeLocVisitKind;\n  }\n\n  TypeLoc get() const {\n    QualType T = QualType::getFromOpaquePtr(data[0]);\n    return TypeLoc(T, const_cast<void *>(data[1]));\n  }\n};\n\nclass LabelRefVisit : public VisitorJob {\npublic:\n  LabelRefVisit(LabelDecl *LD, SourceLocation labelLoc, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::LabelRefVisitKind, LD,\n                   labelLoc.getPtrEncoding()) {}\n\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == VisitorJob::LabelRefVisitKind;\n  }\n  const LabelDecl *get() const {\n    return static_cast<const LabelDecl *>(data[0]);\n  }\n  SourceLocation getLoc() const {\n    return SourceLocation::getFromPtrEncoding(data[1]);\n  }\n};\n\nclass NestedNameSpecifierLocVisit : public VisitorJob {\npublic:\n  NestedNameSpecifierLocVisit(NestedNameSpecifierLoc Qualifier, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::NestedNameSpecifierLocVisitKind,\n                   Qualifier.getNestedNameSpecifier(),\n                   Qualifier.getOpaqueData()) {}\n\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == VisitorJob::NestedNameSpecifierLocVisitKind;\n  }\n\n  NestedNameSpecifierLoc get() const {\n    return NestedNameSpecifierLoc(\n        const_cast<NestedNameSpecifier *>(\n            static_cast<const NestedNameSpecifier *>(data[0])),\n        const_cast<void *>(data[1]));\n  }\n};\n\nclass DeclarationNameInfoVisit : public VisitorJob {\npublic:\n  DeclarationNameInfoVisit(const Stmt *S, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::DeclarationNameInfoVisitKind, S) {}\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == VisitorJob::DeclarationNameInfoVisitKind;\n  }\n  DeclarationNameInfo get() const {\n    const Stmt *S = static_cast<const Stmt *>(data[0]);\n    switch (S->getStmtClass()) {\n    default:\n      llvm_unreachable(\"Unhandled Stmt\");\n    case clang::Stmt::MSDependentExistsStmtClass:\n      return cast<MSDependentExistsStmt>(S)->getNameInfo();\n    case Stmt::CXXDependentScopeMemberExprClass:\n      return cast<CXXDependentScopeMemberExpr>(S)->getMemberNameInfo();\n    case Stmt::DependentScopeDeclRefExprClass:\n      return cast<DependentScopeDeclRefExpr>(S)->getNameInfo();\n    case Stmt::OMPCriticalDirectiveClass:\n      return cast<OMPCriticalDirective>(S)->getDirectiveName();\n    }\n  }\n};\nclass MemberRefVisit : public VisitorJob {\npublic:\n  MemberRefVisit(const FieldDecl *D, SourceLocation L, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::MemberRefVisitKind, D,\n                   L.getPtrEncoding()) {}\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == VisitorJob::MemberRefVisitKind;\n  }\n  const FieldDecl *get() const {\n    return static_cast<const FieldDecl *>(data[0]);\n  }\n  SourceLocation getLoc() const {\n    return SourceLocation::getFromRawEncoding((unsigned)(uintptr_t)data[1]);\n  }\n};\nclass EnqueueVisitor : public ConstStmtVisitor<EnqueueVisitor, void> {\n  friend class OMPClauseEnqueue;\n  VisitorWorkList &WL;\n  CXCursor Parent;\n\npublic:\n  EnqueueVisitor(VisitorWorkList &wl, CXCursor parent)\n      : WL(wl), Parent(parent) {}\n\n  void VisitAddrLabelExpr(const AddrLabelExpr *E);\n  void VisitBlockExpr(const BlockExpr *B);\n  void VisitCompoundLiteralExpr(const CompoundLiteralExpr *E);\n  void VisitCompoundStmt(const CompoundStmt *S);\n  void VisitCXXDefaultArgExpr(const CXXDefaultArgExpr *E) { /* Do nothing. */\n  }\n  void VisitMSDependentExistsStmt(const MSDependentExistsStmt *S);\n  void VisitCXXDependentScopeMemberExpr(const CXXDependentScopeMemberExpr *E);\n  void VisitCXXNewExpr(const CXXNewExpr *E);\n  void VisitCXXScalarValueInitExpr(const CXXScalarValueInitExpr *E);\n  void VisitCXXOperatorCallExpr(const CXXOperatorCallExpr *E);\n  void VisitCXXPseudoDestructorExpr(const CXXPseudoDestructorExpr *E);\n  void VisitCXXTemporaryObjectExpr(const CXXTemporaryObjectExpr *E);\n  void VisitCXXTypeidExpr(const CXXTypeidExpr *E);\n  void VisitCXXUnresolvedConstructExpr(const CXXUnresolvedConstructExpr *E);\n  void VisitCXXUuidofExpr(const CXXUuidofExpr *E);\n  void VisitCXXCatchStmt(const CXXCatchStmt *S);\n  void VisitCXXForRangeStmt(const CXXForRangeStmt *S);\n  void VisitDeclRefExpr(const DeclRefExpr *D);\n  void VisitDeclStmt(const DeclStmt *S);\n  void VisitDependentScopeDeclRefExpr(const DependentScopeDeclRefExpr *E);\n  void VisitDesignatedInitExpr(const DesignatedInitExpr *E);\n  void VisitExplicitCastExpr(const ExplicitCastExpr *E);\n  void VisitForStmt(const ForStmt *FS);\n  void VisitGotoStmt(const GotoStmt *GS);\n  void VisitIfStmt(const IfStmt *If);\n  void VisitInitListExpr(const InitListExpr *IE);\n  void VisitMemberExpr(const MemberExpr *M);\n  void VisitOffsetOfExpr(const OffsetOfExpr *E);\n  void VisitObjCEncodeExpr(const ObjCEncodeExpr *E);\n  void VisitObjCMessageExpr(const ObjCMessageExpr *M);\n  void VisitOverloadExpr(const OverloadExpr *E);\n  void VisitUnaryExprOrTypeTraitExpr(const UnaryExprOrTypeTraitExpr *E);\n  void VisitStmt(const Stmt *S);\n  void VisitSwitchStmt(const SwitchStmt *S);\n  void VisitWhileStmt(const WhileStmt *W);\n  void VisitTypeTraitExpr(const TypeTraitExpr *E);\n  void VisitArrayTypeTraitExpr(const ArrayTypeTraitExpr *E);\n  void VisitExpressionTraitExpr(const ExpressionTraitExpr *E);\n  void VisitUnresolvedMemberExpr(const UnresolvedMemberExpr *U);\n  void VisitVAArgExpr(const VAArgExpr *E);\n  void VisitSizeOfPackExpr(const SizeOfPackExpr *E);\n  void VisitPseudoObjectExpr(const PseudoObjectExpr *E);\n  void VisitOpaqueValueExpr(const OpaqueValueExpr *E);\n  void VisitLambdaExpr(const LambdaExpr *E);\n  void VisitOMPExecutableDirective(const OMPExecutableDirective *D);\n  void VisitOMPLoopBasedDirective(const OMPLoopBasedDirective *D);\n  void VisitOMPLoopDirective(const OMPLoopDirective *D);\n  void VisitOMPParallelDirective(const OMPParallelDirective *D);\n  void VisitOMPSimdDirective(const OMPSimdDirective *D);\n  void VisitOMPTileDirective(const OMPTileDirective *D);\n  void VisitOMPForDirective(const OMPForDirective *D);\n  void VisitOMPForSimdDirective(const OMPForSimdDirective *D);\n  void VisitOMPSectionsDirective(const OMPSectionsDirective *D);\n  void VisitOMPSectionDirective(const OMPSectionDirective *D);\n  void VisitOMPSingleDirective(const OMPSingleDirective *D);\n  void VisitOMPMasterDirective(const OMPMasterDirective *D);\n  void VisitOMPCriticalDirective(const OMPCriticalDirective *D);\n  void VisitOMPParallelForDirective(const OMPParallelForDirective *D);\n  void VisitOMPParallelForSimdDirective(const OMPParallelForSimdDirective *D);\n  void VisitOMPParallelMasterDirective(const OMPParallelMasterDirective *D);\n  void VisitOMPParallelSectionsDirective(const OMPParallelSectionsDirective *D);\n  void VisitOMPTaskDirective(const OMPTaskDirective *D);\n  void VisitOMPTaskyieldDirective(const OMPTaskyieldDirective *D);\n  void VisitOMPBarrierDirective(const OMPBarrierDirective *D);\n  void VisitOMPTaskwaitDirective(const OMPTaskwaitDirective *D);\n  void VisitOMPTaskgroupDirective(const OMPTaskgroupDirective *D);\n  void\n  VisitOMPCancellationPointDirective(const OMPCancellationPointDirective *D);\n  void VisitOMPCancelDirective(const OMPCancelDirective *D);\n  void VisitOMPFlushDirective(const OMPFlushDirective *D);\n  void VisitOMPDepobjDirective(const OMPDepobjDirective *D);\n  void VisitOMPScanDirective(const OMPScanDirective *D);\n  void VisitOMPOrderedDirective(const OMPOrderedDirective *D);\n  void VisitOMPAtomicDirective(const OMPAtomicDirective *D);\n  void VisitOMPTargetDirective(const OMPTargetDirective *D);\n  void VisitOMPTargetDataDirective(const OMPTargetDataDirective *D);\n  void VisitOMPTargetEnterDataDirective(const OMPTargetEnterDataDirective *D);\n  void VisitOMPTargetExitDataDirective(const OMPTargetExitDataDirective *D);\n  void VisitOMPTargetParallelDirective(const OMPTargetParallelDirective *D);\n  void\n  VisitOMPTargetParallelForDirective(const OMPTargetParallelForDirective *D);\n  void VisitOMPTeamsDirective(const OMPTeamsDirective *D);\n  void VisitOMPTaskLoopDirective(const OMPTaskLoopDirective *D);\n  void VisitOMPTaskLoopSimdDirective(const OMPTaskLoopSimdDirective *D);\n  void VisitOMPMasterTaskLoopDirective(const OMPMasterTaskLoopDirective *D);\n  void\n  VisitOMPMasterTaskLoopSimdDirective(const OMPMasterTaskLoopSimdDirective *D);\n  void VisitOMPParallelMasterTaskLoopDirective(\n      const OMPParallelMasterTaskLoopDirective *D);\n  void VisitOMPParallelMasterTaskLoopSimdDirective(\n      const OMPParallelMasterTaskLoopSimdDirective *D);\n  void VisitOMPDistributeDirective(const OMPDistributeDirective *D);\n  void VisitOMPDistributeParallelForDirective(\n      const OMPDistributeParallelForDirective *D);\n  void VisitOMPDistributeParallelForSimdDirective(\n      const OMPDistributeParallelForSimdDirective *D);\n  void VisitOMPDistributeSimdDirective(const OMPDistributeSimdDirective *D);\n  void VisitOMPTargetParallelForSimdDirective(\n      const OMPTargetParallelForSimdDirective *D);\n  void VisitOMPTargetSimdDirective(const OMPTargetSimdDirective *D);\n  void VisitOMPTeamsDistributeDirective(const OMPTeamsDistributeDirective *D);\n  void VisitOMPTeamsDistributeSimdDirective(\n      const OMPTeamsDistributeSimdDirective *D);\n  void VisitOMPTeamsDistributeParallelForSimdDirective(\n      const OMPTeamsDistributeParallelForSimdDirective *D);\n  void VisitOMPTeamsDistributeParallelForDirective(\n      const OMPTeamsDistributeParallelForDirective *D);\n  void VisitOMPTargetTeamsDirective(const OMPTargetTeamsDirective *D);\n  void VisitOMPTargetTeamsDistributeDirective(\n      const OMPTargetTeamsDistributeDirective *D);\n  void VisitOMPTargetTeamsDistributeParallelForDirective(\n      const OMPTargetTeamsDistributeParallelForDirective *D);\n  void VisitOMPTargetTeamsDistributeParallelForSimdDirective(\n      const OMPTargetTeamsDistributeParallelForSimdDirective *D);\n  void VisitOMPTargetTeamsDistributeSimdDirective(\n      const OMPTargetTeamsDistributeSimdDirective *D);\n\nprivate:\n  void AddDeclarationNameInfo(const Stmt *S);\n  void AddNestedNameSpecifierLoc(NestedNameSpecifierLoc Qualifier);\n  void AddExplicitTemplateArgs(const TemplateArgumentLoc *A,\n                               unsigned NumTemplateArgs);\n  void AddMemberRef(const FieldDecl *D, SourceLocation L);\n  void AddStmt(const Stmt *S);\n  void AddDecl(const Decl *D, bool isFirst = true);\n  void AddTypeLoc(TypeSourceInfo *TI);\n  void EnqueueChildren(const Stmt *S);\n  void EnqueueChildren(const OMPClause *S);\n};\n} // namespace\n\nvoid EnqueueVisitor::AddDeclarationNameInfo(const Stmt *S) {\n  // 'S' should always be non-null, since it comes from the\n  // statement we are visiting.\n  WL.push_back(DeclarationNameInfoVisit(S, Parent));\n}\n\nvoid EnqueueVisitor::AddNestedNameSpecifierLoc(\n    NestedNameSpecifierLoc Qualifier) {\n  if (Qualifier)\n    WL.push_back(NestedNameSpecifierLocVisit(Qualifier, Parent));\n}\n\nvoid EnqueueVisitor::AddStmt(const Stmt *S) {\n  if (S)\n    WL.push_back(StmtVisit(S, Parent));\n}\nvoid EnqueueVisitor::AddDecl(const Decl *D, bool isFirst) {\n  if (D)\n    WL.push_back(DeclVisit(D, Parent, isFirst));\n}\nvoid EnqueueVisitor::AddExplicitTemplateArgs(const TemplateArgumentLoc *A,\n                                             unsigned NumTemplateArgs) {\n  WL.push_back(ExplicitTemplateArgsVisit(A, A + NumTemplateArgs, Parent));\n}\nvoid EnqueueVisitor::AddMemberRef(const FieldDecl *D, SourceLocation L) {\n  if (D)\n    WL.push_back(MemberRefVisit(D, L, Parent));\n}\nvoid EnqueueVisitor::AddTypeLoc(TypeSourceInfo *TI) {\n  if (TI)\n    WL.push_back(TypeLocVisit(TI->getTypeLoc(), Parent));\n}\nvoid EnqueueVisitor::EnqueueChildren(const Stmt *S) {\n  unsigned size = WL.size();\n  for (const Stmt *SubStmt : S->children()) {\n    AddStmt(SubStmt);\n  }\n  if (size == WL.size())\n    return;\n  // Now reverse the entries we just added.  This will match the DFS\n  // ordering performed by the worklist.\n  VisitorWorkList::iterator I = WL.begin() + size, E = WL.end();\n  std::reverse(I, E);\n}\nnamespace {\nclass OMPClauseEnqueue : public ConstOMPClauseVisitor<OMPClauseEnqueue> {\n  EnqueueVisitor *Visitor;\n  /// Process clauses with list of variables.\n  template <typename T> void VisitOMPClauseList(T *Node);\n\npublic:\n  OMPClauseEnqueue(EnqueueVisitor *Visitor) : Visitor(Visitor) {}\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) void Visit##Class(const Class *C);\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n  void VisitOMPClauseWithPreInit(const OMPClauseWithPreInit *C);\n  void VisitOMPClauseWithPostUpdate(const OMPClauseWithPostUpdate *C);\n};\n\nvoid OMPClauseEnqueue::VisitOMPClauseWithPreInit(\n    const OMPClauseWithPreInit *C) {\n  Visitor->AddStmt(C->getPreInitStmt());\n}\n\nvoid OMPClauseEnqueue::VisitOMPClauseWithPostUpdate(\n    const OMPClauseWithPostUpdate *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getPostUpdateExpr());\n}\n\nvoid OMPClauseEnqueue::VisitOMPIfClause(const OMPIfClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getCondition());\n}\n\nvoid OMPClauseEnqueue::VisitOMPFinalClause(const OMPFinalClause *C) {\n  Visitor->AddStmt(C->getCondition());\n}\n\nvoid OMPClauseEnqueue::VisitOMPNumThreadsClause(const OMPNumThreadsClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getNumThreads());\n}\n\nvoid OMPClauseEnqueue::VisitOMPSafelenClause(const OMPSafelenClause *C) {\n  Visitor->AddStmt(C->getSafelen());\n}\n\nvoid OMPClauseEnqueue::VisitOMPSimdlenClause(const OMPSimdlenClause *C) {\n  Visitor->AddStmt(C->getSimdlen());\n}\n\nvoid OMPClauseEnqueue::VisitOMPSizesClause(const OMPSizesClause *C) {\n  for (auto E : C->getSizesRefs())\n    Visitor->AddStmt(E);\n}\n\nvoid OMPClauseEnqueue::VisitOMPAllocatorClause(const OMPAllocatorClause *C) {\n  Visitor->AddStmt(C->getAllocator());\n}\n\nvoid OMPClauseEnqueue::VisitOMPCollapseClause(const OMPCollapseClause *C) {\n  Visitor->AddStmt(C->getNumForLoops());\n}\n\nvoid OMPClauseEnqueue::VisitOMPDefaultClause(const OMPDefaultClause *C) {}\n\nvoid OMPClauseEnqueue::VisitOMPProcBindClause(const OMPProcBindClause *C) {}\n\nvoid OMPClauseEnqueue::VisitOMPScheduleClause(const OMPScheduleClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getChunkSize());\n}\n\nvoid OMPClauseEnqueue::VisitOMPOrderedClause(const OMPOrderedClause *C) {\n  Visitor->AddStmt(C->getNumForLoops());\n}\n\nvoid OMPClauseEnqueue::VisitOMPDetachClause(const OMPDetachClause *C) {\n  Visitor->AddStmt(C->getEventHandler());\n}\n\nvoid OMPClauseEnqueue::VisitOMPNowaitClause(const OMPNowaitClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPUntiedClause(const OMPUntiedClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPMergeableClause(const OMPMergeableClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPReadClause(const OMPReadClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPWriteClause(const OMPWriteClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPUpdateClause(const OMPUpdateClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPCaptureClause(const OMPCaptureClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPSeqCstClause(const OMPSeqCstClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPAcqRelClause(const OMPAcqRelClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPAcquireClause(const OMPAcquireClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPReleaseClause(const OMPReleaseClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPRelaxedClause(const OMPRelaxedClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPThreadsClause(const OMPThreadsClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPSIMDClause(const OMPSIMDClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPNogroupClause(const OMPNogroupClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPDestroyClause(const OMPDestroyClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPUnifiedAddressClause(\n    const OMPUnifiedAddressClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPUnifiedSharedMemoryClause(\n    const OMPUnifiedSharedMemoryClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPReverseOffloadClause(\n    const OMPReverseOffloadClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPDynamicAllocatorsClause(\n    const OMPDynamicAllocatorsClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPAtomicDefaultMemOrderClause(\n    const OMPAtomicDefaultMemOrderClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPDeviceClause(const OMPDeviceClause *C) {\n  Visitor->AddStmt(C->getDevice());\n}\n\nvoid OMPClauseEnqueue::VisitOMPNumTeamsClause(const OMPNumTeamsClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getNumTeams());\n}\n\nvoid OMPClauseEnqueue::VisitOMPThreadLimitClause(\n    const OMPThreadLimitClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getThreadLimit());\n}\n\nvoid OMPClauseEnqueue::VisitOMPPriorityClause(const OMPPriorityClause *C) {\n  Visitor->AddStmt(C->getPriority());\n}\n\nvoid OMPClauseEnqueue::VisitOMPGrainsizeClause(const OMPGrainsizeClause *C) {\n  Visitor->AddStmt(C->getGrainsize());\n}\n\nvoid OMPClauseEnqueue::VisitOMPNumTasksClause(const OMPNumTasksClause *C) {\n  Visitor->AddStmt(C->getNumTasks());\n}\n\nvoid OMPClauseEnqueue::VisitOMPHintClause(const OMPHintClause *C) {\n  Visitor->AddStmt(C->getHint());\n}\n\ntemplate <typename T> void OMPClauseEnqueue::VisitOMPClauseList(T *Node) {\n  for (const auto *I : Node->varlists()) {\n    Visitor->AddStmt(I);\n  }\n}\n\nvoid OMPClauseEnqueue::VisitOMPInclusiveClause(const OMPInclusiveClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPExclusiveClause(const OMPExclusiveClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPAllocateClause(const OMPAllocateClause *C) {\n  VisitOMPClauseList(C);\n  Visitor->AddStmt(C->getAllocator());\n}\nvoid OMPClauseEnqueue::VisitOMPPrivateClause(const OMPPrivateClause *C) {\n  VisitOMPClauseList(C);\n  for (const auto *E : C->private_copies()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPFirstprivateClause(\n    const OMPFirstprivateClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPreInit(C);\n  for (const auto *E : C->private_copies()) {\n    Visitor->AddStmt(E);\n  }\n  for (const auto *E : C->inits()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPLastprivateClause(\n    const OMPLastprivateClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (auto *E : C->private_copies()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->source_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->destination_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->assignment_ops()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPSharedClause(const OMPSharedClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPReductionClause(const OMPReductionClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (auto *E : C->privates()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->lhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->rhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->reduction_ops()) {\n    Visitor->AddStmt(E);\n  }\n  if (C->getModifier() == clang::OMPC_REDUCTION_inscan) {\n    for (auto *E : C->copy_ops()) {\n      Visitor->AddStmt(E);\n    }\n    for (auto *E : C->copy_array_temps()) {\n      Visitor->AddStmt(E);\n    }\n    for (auto *E : C->copy_array_elems()) {\n      Visitor->AddStmt(E);\n    }\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPTaskReductionClause(\n    const OMPTaskReductionClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (auto *E : C->privates()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->lhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->rhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->reduction_ops()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPInReductionClause(\n    const OMPInReductionClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (auto *E : C->privates()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->lhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->rhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->reduction_ops()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->taskgroup_descriptors())\n    Visitor->AddStmt(E);\n}\nvoid OMPClauseEnqueue::VisitOMPLinearClause(const OMPLinearClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (const auto *E : C->privates()) {\n    Visitor->AddStmt(E);\n  }\n  for (const auto *E : C->inits()) {\n    Visitor->AddStmt(E);\n  }\n  for (const auto *E : C->updates()) {\n    Visitor->AddStmt(E);\n  }\n  for (const auto *E : C->finals()) {\n    Visitor->AddStmt(E);\n  }\n  Visitor->AddStmt(C->getStep());\n  Visitor->AddStmt(C->getCalcStep());\n}\nvoid OMPClauseEnqueue::VisitOMPAlignedClause(const OMPAlignedClause *C) {\n  VisitOMPClauseList(C);\n  Visitor->AddStmt(C->getAlignment());\n}\nvoid OMPClauseEnqueue::VisitOMPCopyinClause(const OMPCopyinClause *C) {\n  VisitOMPClauseList(C);\n  for (auto *E : C->source_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->destination_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->assignment_ops()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPCopyprivateClause(\n    const OMPCopyprivateClause *C) {\n  VisitOMPClauseList(C);\n  for (auto *E : C->source_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->destination_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->assignment_ops()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPFlushClause(const OMPFlushClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPDepobjClause(const OMPDepobjClause *C) {\n  Visitor->AddStmt(C->getDepobj());\n}\nvoid OMPClauseEnqueue::VisitOMPDependClause(const OMPDependClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPMapClause(const OMPMapClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPDistScheduleClause(\n    const OMPDistScheduleClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getChunkSize());\n}\nvoid OMPClauseEnqueue::VisitOMPDefaultmapClause(\n    const OMPDefaultmapClause * /*C*/) {}\nvoid OMPClauseEnqueue::VisitOMPToClause(const OMPToClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPFromClause(const OMPFromClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPUseDevicePtrClause(\n    const OMPUseDevicePtrClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPUseDeviceAddrClause(\n    const OMPUseDeviceAddrClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPIsDevicePtrClause(\n    const OMPIsDevicePtrClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPNontemporalClause(\n    const OMPNontemporalClause *C) {\n  VisitOMPClauseList(C);\n  for (const auto *E : C->private_refs())\n    Visitor->AddStmt(E);\n}\nvoid OMPClauseEnqueue::VisitOMPOrderClause(const OMPOrderClause *C) {}\nvoid OMPClauseEnqueue::VisitOMPUsesAllocatorsClause(\n    const OMPUsesAllocatorsClause *C) {\n  for (unsigned I = 0, E = C->getNumberOfAllocators(); I < E; ++I) {\n    const OMPUsesAllocatorsClause::Data &D = C->getAllocatorData(I);\n    Visitor->AddStmt(D.Allocator);\n    Visitor->AddStmt(D.AllocatorTraits);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPAffinityClause(const OMPAffinityClause *C) {\n  Visitor->AddStmt(C->getModifier());\n  for (const Expr *E : C->varlists())\n    Visitor->AddStmt(E);\n}\n} // namespace\n\nvoid EnqueueVisitor::EnqueueChildren(const OMPClause *S) {\n  unsigned size = WL.size();\n  OMPClauseEnqueue Visitor(this);\n  Visitor.Visit(S);\n  if (size == WL.size())\n    return;\n  // Now reverse the entries we just added.  This will match the DFS\n  // ordering performed by the worklist.\n  VisitorWorkList::iterator I = WL.begin() + size, E = WL.end();\n  std::reverse(I, E);\n}\nvoid EnqueueVisitor::VisitAddrLabelExpr(const AddrLabelExpr *E) {\n  WL.push_back(LabelRefVisit(E->getLabel(), E->getLabelLoc(), Parent));\n}\nvoid EnqueueVisitor::VisitBlockExpr(const BlockExpr *B) {\n  AddDecl(B->getBlockDecl());\n}\nvoid EnqueueVisitor::VisitCompoundLiteralExpr(const CompoundLiteralExpr *E) {\n  EnqueueChildren(E);\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitCompoundStmt(const CompoundStmt *S) {\n  for (auto &I : llvm::reverse(S->body()))\n    AddStmt(I);\n}\nvoid EnqueueVisitor::VisitMSDependentExistsStmt(\n    const MSDependentExistsStmt *S) {\n  AddStmt(S->getSubStmt());\n  AddDeclarationNameInfo(S);\n  if (NestedNameSpecifierLoc QualifierLoc = S->getQualifierLoc())\n    AddNestedNameSpecifierLoc(QualifierLoc);\n}\n\nvoid EnqueueVisitor::VisitCXXDependentScopeMemberExpr(\n    const CXXDependentScopeMemberExpr *E) {\n  if (E->hasExplicitTemplateArgs())\n    AddExplicitTemplateArgs(E->getTemplateArgs(), E->getNumTemplateArgs());\n  AddDeclarationNameInfo(E);\n  if (NestedNameSpecifierLoc QualifierLoc = E->getQualifierLoc())\n    AddNestedNameSpecifierLoc(QualifierLoc);\n  if (!E->isImplicitAccess())\n    AddStmt(E->getBase());\n}\nvoid EnqueueVisitor::VisitCXXNewExpr(const CXXNewExpr *E) {\n  // Enqueue the initializer , if any.\n  AddStmt(E->getInitializer());\n  // Enqueue the array size, if any.\n  AddStmt(E->getArraySize().getValueOr(nullptr));\n  // Enqueue the allocated type.\n  AddTypeLoc(E->getAllocatedTypeSourceInfo());\n  // Enqueue the placement arguments.\n  for (unsigned I = E->getNumPlacementArgs(); I > 0; --I)\n    AddStmt(E->getPlacementArg(I - 1));\n}\nvoid EnqueueVisitor::VisitCXXOperatorCallExpr(const CXXOperatorCallExpr *CE) {\n  for (unsigned I = CE->getNumArgs(); I > 1 /* Yes, this is 1 */; --I)\n    AddStmt(CE->getArg(I - 1));\n  AddStmt(CE->getCallee());\n  AddStmt(CE->getArg(0));\n}\nvoid EnqueueVisitor::VisitCXXPseudoDestructorExpr(\n    const CXXPseudoDestructorExpr *E) {\n  // Visit the name of the type being destroyed.\n  AddTypeLoc(E->getDestroyedTypeInfo());\n  // Visit the scope type that looks disturbingly like the nested-name-specifier\n  // but isn't.\n  AddTypeLoc(E->getScopeTypeInfo());\n  // Visit the nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = E->getQualifierLoc())\n    AddNestedNameSpecifierLoc(QualifierLoc);\n  // Visit base expression.\n  AddStmt(E->getBase());\n}\nvoid EnqueueVisitor::VisitCXXScalarValueInitExpr(\n    const CXXScalarValueInitExpr *E) {\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitCXXTemporaryObjectExpr(\n    const CXXTemporaryObjectExpr *E) {\n  EnqueueChildren(E);\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitCXXTypeidExpr(const CXXTypeidExpr *E) {\n  EnqueueChildren(E);\n  if (E->isTypeOperand())\n    AddTypeLoc(E->getTypeOperandSourceInfo());\n}\n\nvoid EnqueueVisitor::VisitCXXUnresolvedConstructExpr(\n    const CXXUnresolvedConstructExpr *E) {\n  EnqueueChildren(E);\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitCXXUuidofExpr(const CXXUuidofExpr *E) {\n  EnqueueChildren(E);\n  if (E->isTypeOperand())\n    AddTypeLoc(E->getTypeOperandSourceInfo());\n}\n\nvoid EnqueueVisitor::VisitCXXCatchStmt(const CXXCatchStmt *S) {\n  EnqueueChildren(S);\n  AddDecl(S->getExceptionDecl());\n}\n\nvoid EnqueueVisitor::VisitCXXForRangeStmt(const CXXForRangeStmt *S) {\n  AddStmt(S->getBody());\n  AddStmt(S->getRangeInit());\n  AddDecl(S->getLoopVariable());\n}\n\nvoid EnqueueVisitor::VisitDeclRefExpr(const DeclRefExpr *DR) {\n  if (DR->hasExplicitTemplateArgs())\n    AddExplicitTemplateArgs(DR->getTemplateArgs(), DR->getNumTemplateArgs());\n  WL.push_back(DeclRefExprParts(DR, Parent));\n}\nvoid EnqueueVisitor::VisitDependentScopeDeclRefExpr(\n    const DependentScopeDeclRefExpr *E) {\n  if (E->hasExplicitTemplateArgs())\n    AddExplicitTemplateArgs(E->getTemplateArgs(), E->getNumTemplateArgs());\n  AddDeclarationNameInfo(E);\n  AddNestedNameSpecifierLoc(E->getQualifierLoc());\n}\nvoid EnqueueVisitor::VisitDeclStmt(const DeclStmt *S) {\n  unsigned size = WL.size();\n  bool isFirst = true;\n  for (const auto *D : S->decls()) {\n    AddDecl(D, isFirst);\n    isFirst = false;\n  }\n  if (size == WL.size())\n    return;\n  // Now reverse the entries we just added.  This will match the DFS\n  // ordering performed by the worklist.\n  VisitorWorkList::iterator I = WL.begin() + size, E = WL.end();\n  std::reverse(I, E);\n}\nvoid EnqueueVisitor::VisitDesignatedInitExpr(const DesignatedInitExpr *E) {\n  AddStmt(E->getInit());\n  for (const DesignatedInitExpr::Designator &D :\n       llvm::reverse(E->designators())) {\n    if (D.isFieldDesignator()) {\n      if (FieldDecl *Field = D.getField())\n        AddMemberRef(Field, D.getFieldLoc());\n      continue;\n    }\n    if (D.isArrayDesignator()) {\n      AddStmt(E->getArrayIndex(D));\n      continue;\n    }\n    assert(D.isArrayRangeDesignator() && \"Unknown designator kind\");\n    AddStmt(E->getArrayRangeEnd(D));\n    AddStmt(E->getArrayRangeStart(D));\n  }\n}\nvoid EnqueueVisitor::VisitExplicitCastExpr(const ExplicitCastExpr *E) {\n  EnqueueChildren(E);\n  AddTypeLoc(E->getTypeInfoAsWritten());\n}\nvoid EnqueueVisitor::VisitForStmt(const ForStmt *FS) {\n  AddStmt(FS->getBody());\n  AddStmt(FS->getInc());\n  AddStmt(FS->getCond());\n  AddDecl(FS->getConditionVariable());\n  AddStmt(FS->getInit());\n}\nvoid EnqueueVisitor::VisitGotoStmt(const GotoStmt *GS) {\n  WL.push_back(LabelRefVisit(GS->getLabel(), GS->getLabelLoc(), Parent));\n}\nvoid EnqueueVisitor::VisitIfStmt(const IfStmt *If) {\n  AddStmt(If->getElse());\n  AddStmt(If->getThen());\n  AddStmt(If->getCond());\n  AddStmt(If->getInit());\n  AddDecl(If->getConditionVariable());\n}\nvoid EnqueueVisitor::VisitInitListExpr(const InitListExpr *IE) {\n  // We care about the syntactic form of the initializer list, only.\n  if (InitListExpr *Syntactic = IE->getSyntacticForm())\n    IE = Syntactic;\n  EnqueueChildren(IE);\n}\nvoid EnqueueVisitor::VisitMemberExpr(const MemberExpr *M) {\n  WL.push_back(MemberExprParts(M, Parent));\n\n  // If the base of the member access expression is an implicit 'this', don't\n  // visit it.\n  // FIXME: If we ever want to show these implicit accesses, this will be\n  // unfortunate. However, clang_getCursor() relies on this behavior.\n  if (M->isImplicitAccess())\n    return;\n\n  // Ignore base anonymous struct/union fields, otherwise they will shadow the\n  // real field that we are interested in.\n  if (auto *SubME = dyn_cast<MemberExpr>(M->getBase())) {\n    if (auto *FD = dyn_cast_or_null<FieldDecl>(SubME->getMemberDecl())) {\n      if (FD->isAnonymousStructOrUnion()) {\n        AddStmt(SubME->getBase());\n        return;\n      }\n    }\n  }\n\n  AddStmt(M->getBase());\n}\nvoid EnqueueVisitor::VisitObjCEncodeExpr(const ObjCEncodeExpr *E) {\n  AddTypeLoc(E->getEncodedTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitObjCMessageExpr(const ObjCMessageExpr *M) {\n  EnqueueChildren(M);\n  AddTypeLoc(M->getClassReceiverTypeInfo());\n}\nvoid EnqueueVisitor::VisitOffsetOfExpr(const OffsetOfExpr *E) {\n  // Visit the components of the offsetof expression.\n  for (unsigned N = E->getNumComponents(), I = N; I > 0; --I) {\n    const OffsetOfNode &Node = E->getComponent(I - 1);\n    switch (Node.getKind()) {\n    case OffsetOfNode::Array:\n      AddStmt(E->getIndexExpr(Node.getArrayExprIndex()));\n      break;\n    case OffsetOfNode::Field:\n      AddMemberRef(Node.getField(), Node.getSourceRange().getEnd());\n      break;\n    case OffsetOfNode::Identifier:\n    case OffsetOfNode::Base:\n      continue;\n    }\n  }\n  // Visit the type into which we're computing the offset.\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitOverloadExpr(const OverloadExpr *E) {\n  if (E->hasExplicitTemplateArgs())\n    AddExplicitTemplateArgs(E->getTemplateArgs(), E->getNumTemplateArgs());\n  WL.push_back(OverloadExprParts(E, Parent));\n}\nvoid EnqueueVisitor::VisitUnaryExprOrTypeTraitExpr(\n    const UnaryExprOrTypeTraitExpr *E) {\n  EnqueueChildren(E);\n  if (E->isArgumentType())\n    AddTypeLoc(E->getArgumentTypeInfo());\n}\nvoid EnqueueVisitor::VisitStmt(const Stmt *S) { EnqueueChildren(S); }\nvoid EnqueueVisitor::VisitSwitchStmt(const SwitchStmt *S) {\n  AddStmt(S->getBody());\n  AddStmt(S->getCond());\n  AddDecl(S->getConditionVariable());\n}\n\nvoid EnqueueVisitor::VisitWhileStmt(const WhileStmt *W) {\n  AddStmt(W->getBody());\n  AddStmt(W->getCond());\n  AddDecl(W->getConditionVariable());\n}\n\nvoid EnqueueVisitor::VisitTypeTraitExpr(const TypeTraitExpr *E) {\n  for (unsigned I = E->getNumArgs(); I > 0; --I)\n    AddTypeLoc(E->getArg(I - 1));\n}\n\nvoid EnqueueVisitor::VisitArrayTypeTraitExpr(const ArrayTypeTraitExpr *E) {\n  AddTypeLoc(E->getQueriedTypeSourceInfo());\n}\n\nvoid EnqueueVisitor::VisitExpressionTraitExpr(const ExpressionTraitExpr *E) {\n  EnqueueChildren(E);\n}\n\nvoid EnqueueVisitor::VisitUnresolvedMemberExpr(const UnresolvedMemberExpr *U) {\n  VisitOverloadExpr(U);\n  if (!U->isImplicitAccess())\n    AddStmt(U->getBase());\n}\nvoid EnqueueVisitor::VisitVAArgExpr(const VAArgExpr *E) {\n  AddStmt(E->getSubExpr());\n  AddTypeLoc(E->getWrittenTypeInfo());\n}\nvoid EnqueueVisitor::VisitSizeOfPackExpr(const SizeOfPackExpr *E) {\n  WL.push_back(SizeOfPackExprParts(E, Parent));\n}\nvoid EnqueueVisitor::VisitOpaqueValueExpr(const OpaqueValueExpr *E) {\n  // If the opaque value has a source expression, just transparently\n  // visit that.  This is useful for (e.g.) pseudo-object expressions.\n  if (Expr *SourceExpr = E->getSourceExpr())\n    return Visit(SourceExpr);\n}\nvoid EnqueueVisitor::VisitLambdaExpr(const LambdaExpr *E) {\n  AddStmt(E->getBody());\n  WL.push_back(LambdaExprParts(E, Parent));\n}\nvoid EnqueueVisitor::VisitPseudoObjectExpr(const PseudoObjectExpr *E) {\n  // Treat the expression like its syntactic form.\n  Visit(E->getSyntacticForm());\n}\n\nvoid EnqueueVisitor::VisitOMPExecutableDirective(\n    const OMPExecutableDirective *D) {\n  EnqueueChildren(D);\n  for (ArrayRef<OMPClause *>::iterator I = D->clauses().begin(),\n                                       E = D->clauses().end();\n       I != E; ++I)\n    EnqueueChildren(*I);\n}\n\nvoid EnqueueVisitor::VisitOMPLoopBasedDirective(\n    const OMPLoopBasedDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPLoopDirective(const OMPLoopDirective *D) {\n  VisitOMPLoopBasedDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelDirective(const OMPParallelDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPSimdDirective(const OMPSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTileDirective(const OMPTileDirective *D) {\n  VisitOMPLoopBasedDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPForDirective(const OMPForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPForSimdDirective(const OMPForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPSectionsDirective(const OMPSectionsDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPSectionDirective(const OMPSectionDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPSingleDirective(const OMPSingleDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPMasterDirective(const OMPMasterDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPCriticalDirective(const OMPCriticalDirective *D) {\n  VisitOMPExecutableDirective(D);\n  AddDeclarationNameInfo(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelForDirective(\n    const OMPParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelForSimdDirective(\n    const OMPParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelMasterDirective(\n    const OMPParallelMasterDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelSectionsDirective(\n    const OMPParallelSectionsDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskDirective(const OMPTaskDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskyieldDirective(\n    const OMPTaskyieldDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPBarrierDirective(const OMPBarrierDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskwaitDirective(const OMPTaskwaitDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskgroupDirective(\n    const OMPTaskgroupDirective *D) {\n  VisitOMPExecutableDirective(D);\n  if (const Expr *E = D->getReductionRef())\n    VisitStmt(E);\n}\n\nvoid EnqueueVisitor::VisitOMPFlushDirective(const OMPFlushDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDepobjDirective(const OMPDepobjDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPScanDirective(const OMPScanDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPOrderedDirective(const OMPOrderedDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPAtomicDirective(const OMPAtomicDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetDirective(const OMPTargetDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetDataDirective(\n    const OMPTargetDataDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetEnterDataDirective(\n    const OMPTargetEnterDataDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetExitDataDirective(\n    const OMPTargetExitDataDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetParallelDirective(\n    const OMPTargetParallelDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetParallelForDirective(\n    const OMPTargetParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDirective(const OMPTeamsDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPCancellationPointDirective(\n    const OMPCancellationPointDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPCancelDirective(const OMPCancelDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskLoopDirective(const OMPTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskLoopSimdDirective(\n    const OMPTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPMasterTaskLoopDirective(\n    const OMPMasterTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPMasterTaskLoopSimdDirective(\n    const OMPMasterTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelMasterTaskLoopDirective(\n    const OMPParallelMasterTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelMasterTaskLoopSimdDirective(\n    const OMPParallelMasterTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDistributeDirective(\n    const OMPDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDistributeParallelForDirective(\n    const OMPDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDistributeParallelForSimdDirective(\n    const OMPDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDistributeSimdDirective(\n    const OMPDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetParallelForSimdDirective(\n    const OMPTargetParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetSimdDirective(\n    const OMPTargetSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDistributeDirective(\n    const OMPTeamsDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDistributeSimdDirective(\n    const OMPTeamsDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDistributeParallelForSimdDirective(\n    const OMPTeamsDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDistributeParallelForDirective(\n    const OMPTeamsDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDirective(\n    const OMPTargetTeamsDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDistributeDirective(\n    const OMPTargetTeamsDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDistributeParallelForDirective(\n    const OMPTargetTeamsDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDistributeParallelForSimdDirective(\n    const OMPTargetTeamsDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDistributeSimdDirective(\n    const OMPTargetTeamsDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid CursorVisitor::EnqueueWorkList(VisitorWorkList &WL, const Stmt *S) {\n  EnqueueVisitor(WL, MakeCXCursor(S, StmtParent, TU, RegionOfInterest))\n      .Visit(S);\n}\n\nbool CursorVisitor::IsInRegionOfInterest(CXCursor C) {\n  if (RegionOfInterest.isValid()) {\n    SourceRange Range = getRawCursorExtent(C);\n    if (Range.isInvalid() || CompareRegionOfInterest(Range))\n      return false;\n  }\n  return true;\n}\n\nbool CursorVisitor::RunVisitorWorkList(VisitorWorkList &WL) {\n  while (!WL.empty()) {\n    // Dequeue the worklist item.\n    VisitorJob LI = WL.pop_back_val();\n\n    // Set the Parent field, then back to its old value once we're done.\n    SetParentRAII SetParent(Parent, StmtParent, LI.getParent());\n\n    switch (LI.getKind()) {\n    case VisitorJob::DeclVisitKind: {\n      const Decl *D = cast<DeclVisit>(&LI)->get();\n      if (!D)\n        continue;\n\n      // For now, perform default visitation for Decls.\n      if (Visit(MakeCXCursor(D, TU, RegionOfInterest,\n                             cast<DeclVisit>(&LI)->isFirst())))\n        return true;\n\n      continue;\n    }\n    case VisitorJob::ExplicitTemplateArgsVisitKind: {\n      for (const TemplateArgumentLoc &Arg :\n           *cast<ExplicitTemplateArgsVisit>(&LI)) {\n        if (VisitTemplateArgumentLoc(Arg))\n          return true;\n      }\n      continue;\n    }\n    case VisitorJob::TypeLocVisitKind: {\n      // Perform default visitation for TypeLocs.\n      if (Visit(cast<TypeLocVisit>(&LI)->get()))\n        return true;\n      continue;\n    }\n    case VisitorJob::LabelRefVisitKind: {\n      const LabelDecl *LS = cast<LabelRefVisit>(&LI)->get();\n      if (LabelStmt *stmt = LS->getStmt()) {\n        if (Visit(MakeCursorLabelRef(stmt, cast<LabelRefVisit>(&LI)->getLoc(),\n                                     TU))) {\n          return true;\n        }\n      }\n      continue;\n    }\n\n    case VisitorJob::NestedNameSpecifierLocVisitKind: {\n      NestedNameSpecifierLocVisit *V = cast<NestedNameSpecifierLocVisit>(&LI);\n      if (VisitNestedNameSpecifierLoc(V->get()))\n        return true;\n      continue;\n    }\n\n    case VisitorJob::DeclarationNameInfoVisitKind: {\n      if (VisitDeclarationNameInfo(cast<DeclarationNameInfoVisit>(&LI)->get()))\n        return true;\n      continue;\n    }\n    case VisitorJob::MemberRefVisitKind: {\n      MemberRefVisit *V = cast<MemberRefVisit>(&LI);\n      if (Visit(MakeCursorMemberRef(V->get(), V->getLoc(), TU)))\n        return true;\n      continue;\n    }\n    case VisitorJob::StmtVisitKind: {\n      const Stmt *S = cast<StmtVisit>(&LI)->get();\n      if (!S)\n        continue;\n\n      // Update the current cursor.\n      CXCursor Cursor = MakeCXCursor(S, StmtParent, TU, RegionOfInterest);\n      if (!IsInRegionOfInterest(Cursor))\n        continue;\n      switch (Visitor(Cursor, Parent, ClientData)) {\n      case CXChildVisit_Break:\n        return true;\n      case CXChildVisit_Continue:\n        break;\n      case CXChildVisit_Recurse:\n        if (PostChildrenVisitor)\n          WL.push_back(PostChildrenVisit(nullptr, Cursor));\n        EnqueueWorkList(WL, S);\n        break;\n      }\n      continue;\n    }\n    case VisitorJob::MemberExprPartsKind: {\n      // Handle the other pieces in the MemberExpr besides the base.\n      const MemberExpr *M = cast<MemberExprParts>(&LI)->get();\n\n      // Visit the nested-name-specifier\n      if (NestedNameSpecifierLoc QualifierLoc = M->getQualifierLoc())\n        if (VisitNestedNameSpecifierLoc(QualifierLoc))\n          return true;\n\n      // Visit the declaration name.\n      if (VisitDeclarationNameInfo(M->getMemberNameInfo()))\n        return true;\n\n      // Visit the explicitly-specified template arguments, if any.\n      if (M->hasExplicitTemplateArgs()) {\n        for (const TemplateArgumentLoc *Arg = M->getTemplateArgs(),\n                                       *ArgEnd = Arg + M->getNumTemplateArgs();\n             Arg != ArgEnd; ++Arg) {\n          if (VisitTemplateArgumentLoc(*Arg))\n            return true;\n        }\n      }\n      continue;\n    }\n    case VisitorJob::DeclRefExprPartsKind: {\n      const DeclRefExpr *DR = cast<DeclRefExprParts>(&LI)->get();\n      // Visit nested-name-specifier, if present.\n      if (NestedNameSpecifierLoc QualifierLoc = DR->getQualifierLoc())\n        if (VisitNestedNameSpecifierLoc(QualifierLoc))\n          return true;\n      // Visit declaration name.\n      if (VisitDeclarationNameInfo(DR->getNameInfo()))\n        return true;\n      continue;\n    }\n    case VisitorJob::OverloadExprPartsKind: {\n      const OverloadExpr *O = cast<OverloadExprParts>(&LI)->get();\n      // Visit the nested-name-specifier.\n      if (NestedNameSpecifierLoc QualifierLoc = O->getQualifierLoc())\n        if (VisitNestedNameSpecifierLoc(QualifierLoc))\n          return true;\n      // Visit the declaration name.\n      if (VisitDeclarationNameInfo(O->getNameInfo()))\n        return true;\n      // Visit the overloaded declaration reference.\n      if (Visit(MakeCursorOverloadedDeclRef(O, TU)))\n        return true;\n      continue;\n    }\n    case VisitorJob::SizeOfPackExprPartsKind: {\n      const SizeOfPackExpr *E = cast<SizeOfPackExprParts>(&LI)->get();\n      NamedDecl *Pack = E->getPack();\n      if (isa<TemplateTypeParmDecl>(Pack)) {\n        if (Visit(MakeCursorTypeRef(cast<TemplateTypeParmDecl>(Pack),\n                                    E->getPackLoc(), TU)))\n          return true;\n\n        continue;\n      }\n\n      if (isa<TemplateTemplateParmDecl>(Pack)) {\n        if (Visit(MakeCursorTemplateRef(cast<TemplateTemplateParmDecl>(Pack),\n                                        E->getPackLoc(), TU)))\n          return true;\n\n        continue;\n      }\n\n      // Non-type template parameter packs and function parameter packs are\n      // treated like DeclRefExpr cursors.\n      continue;\n    }\n\n    case VisitorJob::LambdaExprPartsKind: {\n      // Visit non-init captures.\n      const LambdaExpr *E = cast<LambdaExprParts>(&LI)->get();\n      for (LambdaExpr::capture_iterator C = E->explicit_capture_begin(),\n                                        CEnd = E->explicit_capture_end();\n           C != CEnd; ++C) {\n        if (!C->capturesVariable())\n          continue;\n\n        if (Visit(MakeCursorVariableRef(C->getCapturedVar(), C->getLocation(),\n                                        TU)))\n          return true;\n      }\n      // Visit init captures\n      for (auto InitExpr : E->capture_inits()) {\n        if (InitExpr && Visit(InitExpr))\n          return true;\n      }\n\n      TypeLoc TL = E->getCallOperator()->getTypeSourceInfo()->getTypeLoc();\n      // Visit parameters and return type, if present.\n      if (FunctionTypeLoc Proto = TL.getAs<FunctionProtoTypeLoc>()) {\n        if (E->hasExplicitParameters()) {\n          // Visit parameters.\n          for (unsigned I = 0, N = Proto.getNumParams(); I != N; ++I)\n            if (Visit(MakeCXCursor(Proto.getParam(I), TU)))\n              return true;\n        }\n        if (E->hasExplicitResultType()) {\n          // Visit result type.\n          if (Visit(Proto.getReturnLoc()))\n            return true;\n        }\n      }\n      break;\n    }\n\n    case VisitorJob::PostChildrenVisitKind:\n      if (PostChildrenVisitor(Parent, ClientData))\n        return true;\n      break;\n    }\n  }\n  return false;\n}\n\nbool CursorVisitor::Visit(const Stmt *S) {\n  VisitorWorkList *WL = nullptr;\n  if (!WorkListFreeList.empty()) {\n    WL = WorkListFreeList.back();\n    WL->clear();\n    WorkListFreeList.pop_back();\n  } else {\n    WL = new VisitorWorkList();\n    WorkListCache.push_back(WL);\n  }\n  EnqueueWorkList(*WL, S);\n  bool result = RunVisitorWorkList(*WL);\n  WorkListFreeList.push_back(WL);\n  return result;\n}\n\nnamespace {\ntypedef SmallVector<SourceRange, 4> RefNamePieces;\nRefNamePieces buildPieces(unsigned NameFlags, bool IsMemberRefExpr,\n                          const DeclarationNameInfo &NI, SourceRange QLoc,\n                          const SourceRange *TemplateArgsLoc = nullptr) {\n  const bool WantQualifier = NameFlags & CXNameRange_WantQualifier;\n  const bool WantTemplateArgs = NameFlags & CXNameRange_WantTemplateArgs;\n  const bool WantSinglePiece = NameFlags & CXNameRange_WantSinglePiece;\n\n  const DeclarationName::NameKind Kind = NI.getName().getNameKind();\n\n  RefNamePieces Pieces;\n\n  if (WantQualifier && QLoc.isValid())\n    Pieces.push_back(QLoc);\n\n  if (Kind != DeclarationName::CXXOperatorName || IsMemberRefExpr)\n    Pieces.push_back(NI.getLoc());\n\n  if (WantTemplateArgs && TemplateArgsLoc && TemplateArgsLoc->isValid())\n    Pieces.push_back(*TemplateArgsLoc);\n\n  if (Kind == DeclarationName::CXXOperatorName) {\n    Pieces.push_back(NI.getInfo().getCXXOperatorNameBeginLoc());\n    Pieces.push_back(NI.getInfo().getCXXOperatorNameEndLoc());\n  }\n\n  if (WantSinglePiece) {\n    SourceRange R(Pieces.front().getBegin(), Pieces.back().getEnd());\n    Pieces.clear();\n    Pieces.push_back(R);\n  }\n\n  return Pieces;\n}\n} // namespace\n\n//===----------------------------------------------------------------------===//\n// Misc. API hooks.\n//===----------------------------------------------------------------------===//\n\nnamespace {\nstruct RegisterFatalErrorHandler {\n  RegisterFatalErrorHandler() {\n    clang_install_aborting_llvm_fatal_error_handler();\n  }\n};\n} // namespace\n\nstatic llvm::ManagedStatic<RegisterFatalErrorHandler>\n    RegisterFatalErrorHandlerOnce;\n\nCXIndex clang_createIndex(int excludeDeclarationsFromPCH,\n                          int displayDiagnostics) {\n  // We use crash recovery to make some of our APIs more reliable, implicitly\n  // enable it.\n  if (!getenv(\"LIBCLANG_DISABLE_CRASH_RECOVERY\"))\n    llvm::CrashRecoveryContext::Enable();\n\n  // Look through the managed static to trigger construction of the managed\n  // static which registers our fatal error handler. This ensures it is only\n  // registered once.\n  (void)*RegisterFatalErrorHandlerOnce;\n\n  // Initialize targets for clang module support.\n  llvm::InitializeAllTargets();\n  llvm::InitializeAllTargetMCs();\n  llvm::InitializeAllAsmPrinters();\n  llvm::InitializeAllAsmParsers();\n\n  CIndexer *CIdxr = new CIndexer();\n\n  if (excludeDeclarationsFromPCH)\n    CIdxr->setOnlyLocalDecls();\n  if (displayDiagnostics)\n    CIdxr->setDisplayDiagnostics();\n\n  if (getenv(\"LIBCLANG_BGPRIO_INDEX\"))\n    CIdxr->setCXGlobalOptFlags(CIdxr->getCXGlobalOptFlags() |\n                               CXGlobalOpt_ThreadBackgroundPriorityForIndexing);\n  if (getenv(\"LIBCLANG_BGPRIO_EDIT\"))\n    CIdxr->setCXGlobalOptFlags(CIdxr->getCXGlobalOptFlags() |\n                               CXGlobalOpt_ThreadBackgroundPriorityForEditing);\n\n  return CIdxr;\n}\n\nvoid clang_disposeIndex(CXIndex CIdx) {\n  if (CIdx)\n    delete static_cast<CIndexer *>(CIdx);\n}\n\nvoid clang_CXIndex_setGlobalOptions(CXIndex CIdx, unsigned options) {\n  if (CIdx)\n    static_cast<CIndexer *>(CIdx)->setCXGlobalOptFlags(options);\n}\n\nunsigned clang_CXIndex_getGlobalOptions(CXIndex CIdx) {\n  if (CIdx)\n    return static_cast<CIndexer *>(CIdx)->getCXGlobalOptFlags();\n  return 0;\n}\n\nvoid clang_CXIndex_setInvocationEmissionPathOption(CXIndex CIdx,\n                                                   const char *Path) {\n  if (CIdx)\n    static_cast<CIndexer *>(CIdx)->setInvocationEmissionPath(Path ? Path : \"\");\n}\n\nvoid clang_toggleCrashRecovery(unsigned isEnabled) {\n  if (isEnabled)\n    llvm::CrashRecoveryContext::Enable();\n  else\n    llvm::CrashRecoveryContext::Disable();\n}\n\nCXTranslationUnit clang_createTranslationUnit(CXIndex CIdx,\n                                              const char *ast_filename) {\n  CXTranslationUnit TU;\n  enum CXErrorCode Result =\n      clang_createTranslationUnit2(CIdx, ast_filename, &TU);\n  (void)Result;\n  assert((TU && Result == CXError_Success) ||\n         (!TU && Result != CXError_Success));\n  return TU;\n}\n\nenum CXErrorCode clang_createTranslationUnit2(CXIndex CIdx,\n                                              const char *ast_filename,\n                                              CXTranslationUnit *out_TU) {\n  if (out_TU)\n    *out_TU = nullptr;\n\n  if (!CIdx || !ast_filename || !out_TU)\n    return CXError_InvalidArguments;\n\n  LOG_FUNC_SECTION { *Log << ast_filename; }\n\n  CIndexer *CXXIdx = static_cast<CIndexer *>(CIdx);\n  FileSystemOptions FileSystemOpts;\n\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diags =\n      CompilerInstance::createDiagnostics(new DiagnosticOptions());\n  std::unique_ptr<ASTUnit> AU = ASTUnit::LoadFromASTFile(\n      ast_filename, CXXIdx->getPCHContainerOperations()->getRawReader(),\n      ASTUnit::LoadEverything, Diags, FileSystemOpts, /*UseDebugInfo=*/false,\n      CXXIdx->getOnlyLocalDecls(), CaptureDiagsKind::All,\n      /*AllowASTWithCompilerErrors=*/true,\n      /*UserFilesAreVolatile=*/true);\n  *out_TU = MakeCXTranslationUnit(CXXIdx, std::move(AU));\n  return *out_TU ? CXError_Success : CXError_Failure;\n}\n\nunsigned clang_defaultEditingTranslationUnitOptions() {\n  return CXTranslationUnit_PrecompiledPreamble |\n         CXTranslationUnit_CacheCompletionResults;\n}\n\nCXTranslationUnit clang_createTranslationUnitFromSourceFile(\n    CXIndex CIdx, const char *source_filename, int num_command_line_args,\n    const char *const *command_line_args, unsigned num_unsaved_files,\n    struct CXUnsavedFile *unsaved_files) {\n  unsigned Options = CXTranslationUnit_DetailedPreprocessingRecord;\n  return clang_parseTranslationUnit(CIdx, source_filename, command_line_args,\n                                    num_command_line_args, unsaved_files,\n                                    num_unsaved_files, Options);\n}\n\nstatic CXErrorCode\nclang_parseTranslationUnit_Impl(CXIndex CIdx, const char *source_filename,\n                                const char *const *command_line_args,\n                                int num_command_line_args,\n                                ArrayRef<CXUnsavedFile> unsaved_files,\n                                unsigned options, CXTranslationUnit *out_TU) {\n  // Set up the initial return values.\n  if (out_TU)\n    *out_TU = nullptr;\n\n  // Check arguments.\n  if (!CIdx || !out_TU)\n    return CXError_InvalidArguments;\n\n  CIndexer *CXXIdx = static_cast<CIndexer *>(CIdx);\n\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForIndexing))\n    setThreadBackgroundPriority();\n\n  bool PrecompilePreamble = options & CXTranslationUnit_PrecompiledPreamble;\n  bool CreatePreambleOnFirstParse =\n      options & CXTranslationUnit_CreatePreambleOnFirstParse;\n  // FIXME: Add a flag for modules.\n  TranslationUnitKind TUKind = (options & (CXTranslationUnit_Incomplete |\n                                           CXTranslationUnit_SingleFileParse))\n                                   ? TU_Prefix\n                                   : TU_Complete;\n  bool CacheCodeCompletionResults =\n      options & CXTranslationUnit_CacheCompletionResults;\n  bool IncludeBriefCommentsInCodeCompletion =\n      options & CXTranslationUnit_IncludeBriefCommentsInCodeCompletion;\n  bool SingleFileParse = options & CXTranslationUnit_SingleFileParse;\n  bool ForSerialization = options & CXTranslationUnit_ForSerialization;\n  bool RetainExcludedCB =\n      options & CXTranslationUnit_RetainExcludedConditionalBlocks;\n  SkipFunctionBodiesScope SkipFunctionBodies = SkipFunctionBodiesScope::None;\n  if (options & CXTranslationUnit_SkipFunctionBodies) {\n    SkipFunctionBodies =\n        (options & CXTranslationUnit_LimitSkipFunctionBodiesToPreamble)\n            ? SkipFunctionBodiesScope::Preamble\n            : SkipFunctionBodiesScope::PreambleAndMainFile;\n  }\n\n  // Configure the diagnostics.\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diags(\n      CompilerInstance::createDiagnostics(new DiagnosticOptions));\n\n  if (options & CXTranslationUnit_KeepGoing)\n    Diags->setFatalsAsError(true);\n\n  CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::All;\n  if (options & CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles)\n    CaptureDiagnostics = CaptureDiagsKind::AllWithoutNonErrorsFromIncludes;\n\n  // Recover resources if we crash before exiting this function.\n  llvm::CrashRecoveryContextCleanupRegistrar<\n      DiagnosticsEngine,\n      llvm::CrashRecoveryContextReleaseRefCleanup<DiagnosticsEngine>>\n      DiagCleanup(Diags.get());\n\n  std::unique_ptr<std::vector<ASTUnit::RemappedFile>> RemappedFiles(\n      new std::vector<ASTUnit::RemappedFile>());\n\n  // Recover resources if we crash before exiting this function.\n  llvm::CrashRecoveryContextCleanupRegistrar<std::vector<ASTUnit::RemappedFile>>\n      RemappedCleanup(RemappedFiles.get());\n\n  for (auto &UF : unsaved_files) {\n    std::unique_ptr<llvm::MemoryBuffer> MB =\n        llvm::MemoryBuffer::getMemBufferCopy(getContents(UF), UF.Filename);\n    RemappedFiles->push_back(std::make_pair(UF.Filename, MB.release()));\n  }\n\n  std::unique_ptr<std::vector<const char *>> Args(\n      new std::vector<const char *>());\n\n  // Recover resources if we crash before exiting this method.\n  llvm::CrashRecoveryContextCleanupRegistrar<std::vector<const char *>>\n      ArgsCleanup(Args.get());\n\n  // Since the Clang C library is primarily used by batch tools dealing with\n  // (often very broken) source code, where spell-checking can have a\n  // significant negative impact on performance (particularly when\n  // precompiled headers are involved), we disable it by default.\n  // Only do this if we haven't found a spell-checking-related argument.\n  bool FoundSpellCheckingArgument = false;\n  for (int I = 0; I != num_command_line_args; ++I) {\n    if (strcmp(command_line_args[I], \"-fno-spell-checking\") == 0 ||\n        strcmp(command_line_args[I], \"-fspell-checking\") == 0) {\n      FoundSpellCheckingArgument = true;\n      break;\n    }\n  }\n  Args->insert(Args->end(), command_line_args,\n               command_line_args + num_command_line_args);\n\n  if (!FoundSpellCheckingArgument)\n    Args->insert(Args->begin() + 1, \"-fno-spell-checking\");\n\n  // The 'source_filename' argument is optional.  If the caller does not\n  // specify it then it is assumed that the source file is specified\n  // in the actual argument list.\n  // Put the source file after command_line_args otherwise if '-x' flag is\n  // present it will be unused.\n  if (source_filename)\n    Args->push_back(source_filename);\n\n  // Do we need the detailed preprocessing record?\n  if (options & CXTranslationUnit_DetailedPreprocessingRecord) {\n    Args->push_back(\"-Xclang\");\n    Args->push_back(\"-detailed-preprocessing-record\");\n  }\n\n  // Suppress any editor placeholder diagnostics.\n  Args->push_back(\"-fallow-editor-placeholders\");\n\n  unsigned NumErrors = Diags->getClient()->getNumErrors();\n  std::unique_ptr<ASTUnit> ErrUnit;\n  // Unless the user specified that they want the preamble on the first parse\n  // set it up to be created on the first reparse. This makes the first parse\n  // faster, trading for a slower (first) reparse.\n  unsigned PrecompilePreambleAfterNParses =\n      !PrecompilePreamble ? 0 : 2 - CreatePreambleOnFirstParse;\n\n  LibclangInvocationReporter InvocationReporter(\n      *CXXIdx, LibclangInvocationReporter::OperationKind::ParseOperation,\n      options, llvm::makeArrayRef(*Args), /*InvocationArgs=*/None,\n      unsaved_files);\n  std::unique_ptr<ASTUnit> Unit(ASTUnit::LoadFromCommandLine(\n      Args->data(), Args->data() + Args->size(),\n      CXXIdx->getPCHContainerOperations(), Diags,\n      CXXIdx->getClangResourcesPath(), CXXIdx->getOnlyLocalDecls(),\n      CaptureDiagnostics, *RemappedFiles.get(),\n      /*RemappedFilesKeepOriginalName=*/true, PrecompilePreambleAfterNParses,\n      TUKind, CacheCodeCompletionResults, IncludeBriefCommentsInCodeCompletion,\n      /*AllowPCHWithCompilerErrors=*/true, SkipFunctionBodies, SingleFileParse,\n      /*UserFilesAreVolatile=*/true, ForSerialization, RetainExcludedCB,\n      CXXIdx->getPCHContainerOperations()->getRawReader().getFormat(),\n      &ErrUnit));\n\n  // Early failures in LoadFromCommandLine may return with ErrUnit unset.\n  if (!Unit && !ErrUnit)\n    return CXError_ASTReadError;\n\n  if (NumErrors != Diags->getClient()->getNumErrors()) {\n    // Make sure to check that 'Unit' is non-NULL.\n    if (CXXIdx->getDisplayDiagnostics())\n      printDiagsToStderr(Unit ? Unit.get() : ErrUnit.get());\n  }\n\n  if (isASTReadError(Unit ? Unit.get() : ErrUnit.get()))\n    return CXError_ASTReadError;\n\n  *out_TU = MakeCXTranslationUnit(CXXIdx, std::move(Unit));\n  if (CXTranslationUnitImpl *TU = *out_TU) {\n    TU->ParsingOptions = options;\n    TU->Arguments.reserve(Args->size());\n    for (const char *Arg : *Args)\n      TU->Arguments.push_back(Arg);\n    return CXError_Success;\n  }\n  return CXError_Failure;\n}\n\nCXTranslationUnit\nclang_parseTranslationUnit(CXIndex CIdx, const char *source_filename,\n                           const char *const *command_line_args,\n                           int num_command_line_args,\n                           struct CXUnsavedFile *unsaved_files,\n                           unsigned num_unsaved_files, unsigned options) {\n  CXTranslationUnit TU;\n  enum CXErrorCode Result = clang_parseTranslationUnit2(\n      CIdx, source_filename, command_line_args, num_command_line_args,\n      unsaved_files, num_unsaved_files, options, &TU);\n  (void)Result;\n  assert((TU && Result == CXError_Success) ||\n         (!TU && Result != CXError_Success));\n  return TU;\n}\n\nenum CXErrorCode clang_parseTranslationUnit2(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU) {\n  noteBottomOfStack();\n  SmallVector<const char *, 4> Args;\n  Args.push_back(\"clang\");\n  Args.append(command_line_args, command_line_args + num_command_line_args);\n  return clang_parseTranslationUnit2FullArgv(\n      CIdx, source_filename, Args.data(), Args.size(), unsaved_files,\n      num_unsaved_files, options, out_TU);\n}\n\nenum CXErrorCode clang_parseTranslationUnit2FullArgv(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU) {\n  LOG_FUNC_SECTION {\n    *Log << source_filename << \": \";\n    for (int i = 0; i != num_command_line_args; ++i)\n      *Log << command_line_args[i] << \" \";\n  }\n\n  if (num_unsaved_files && !unsaved_files)\n    return CXError_InvalidArguments;\n\n  CXErrorCode result = CXError_Failure;\n  auto ParseTranslationUnitImpl = [=, &result] {\n    noteBottomOfStack();\n    result = clang_parseTranslationUnit_Impl(\n        CIdx, source_filename, command_line_args, num_command_line_args,\n        llvm::makeArrayRef(unsaved_files, num_unsaved_files), options, out_TU);\n  };\n\n  llvm::CrashRecoveryContext CRC;\n\n  if (!RunSafely(CRC, ParseTranslationUnitImpl)) {\n    fprintf(stderr, \"libclang: crash detected during parsing: {\\n\");\n    fprintf(stderr, \"  'source_filename' : '%s'\\n\", source_filename);\n    fprintf(stderr, \"  'command_line_args' : [\");\n    for (int i = 0; i != num_command_line_args; ++i) {\n      if (i)\n        fprintf(stderr, \", \");\n      fprintf(stderr, \"'%s'\", command_line_args[i]);\n    }\n    fprintf(stderr, \"],\\n\");\n    fprintf(stderr, \"  'unsaved_files' : [\");\n    for (unsigned i = 0; i != num_unsaved_files; ++i) {\n      if (i)\n        fprintf(stderr, \", \");\n      fprintf(stderr, \"('%s', '...', %ld)\", unsaved_files[i].Filename,\n              unsaved_files[i].Length);\n    }\n    fprintf(stderr, \"],\\n\");\n    fprintf(stderr, \"  'options' : %d,\\n\", options);\n    fprintf(stderr, \"}\\n\");\n\n    return CXError_Crashed;\n  } else if (getenv(\"LIBCLANG_RESOURCE_USAGE\")) {\n    if (CXTranslationUnit *TU = out_TU)\n      PrintLibclangResourceUsage(*TU);\n  }\n\n  return result;\n}\n\nCXString clang_Type_getObjCEncoding(CXType CT) {\n  CXTranslationUnit tu = static_cast<CXTranslationUnit>(CT.data[1]);\n  ASTContext &Ctx = getASTUnit(tu)->getASTContext();\n  std::string encoding;\n  Ctx.getObjCEncodingForType(QualType::getFromOpaquePtr(CT.data[0]), encoding);\n\n  return cxstring::createDup(encoding);\n}\n\nstatic const IdentifierInfo *getMacroIdentifier(CXCursor C) {\n  if (C.kind == CXCursor_MacroDefinition) {\n    if (const MacroDefinitionRecord *MDR = getCursorMacroDefinition(C))\n      return MDR->getName();\n  } else if (C.kind == CXCursor_MacroExpansion) {\n    MacroExpansionCursor ME = getCursorMacroExpansion(C);\n    return ME.getName();\n  }\n  return nullptr;\n}\n\nunsigned clang_Cursor_isMacroFunctionLike(CXCursor C) {\n  const IdentifierInfo *II = getMacroIdentifier(C);\n  if (!II) {\n    return false;\n  }\n  ASTUnit *ASTU = getCursorASTUnit(C);\n  Preprocessor &PP = ASTU->getPreprocessor();\n  if (const MacroInfo *MI = PP.getMacroInfo(II))\n    return MI->isFunctionLike();\n  return false;\n}\n\nunsigned clang_Cursor_isMacroBuiltin(CXCursor C) {\n  const IdentifierInfo *II = getMacroIdentifier(C);\n  if (!II) {\n    return false;\n  }\n  ASTUnit *ASTU = getCursorASTUnit(C);\n  Preprocessor &PP = ASTU->getPreprocessor();\n  if (const MacroInfo *MI = PP.getMacroInfo(II))\n    return MI->isBuiltinMacro();\n  return false;\n}\n\nunsigned clang_Cursor_isFunctionInlined(CXCursor C) {\n  const Decl *D = getCursorDecl(C);\n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n  if (!FD) {\n    return false;\n  }\n  return FD->isInlined();\n}\n\nstatic StringLiteral *getCFSTR_value(CallExpr *callExpr) {\n  if (callExpr->getNumArgs() != 1) {\n    return nullptr;\n  }\n\n  StringLiteral *S = nullptr;\n  auto *arg = callExpr->getArg(0);\n  if (arg->getStmtClass() == Stmt::ImplicitCastExprClass) {\n    ImplicitCastExpr *I = static_cast<ImplicitCastExpr *>(arg);\n    auto *subExpr = I->getSubExprAsWritten();\n\n    if (subExpr->getStmtClass() != Stmt::StringLiteralClass) {\n      return nullptr;\n    }\n\n    S = static_cast<StringLiteral *>(I->getSubExprAsWritten());\n  } else if (arg->getStmtClass() == Stmt::StringLiteralClass) {\n    S = static_cast<StringLiteral *>(callExpr->getArg(0));\n  } else {\n    return nullptr;\n  }\n  return S;\n}\n\nstruct ExprEvalResult {\n  CXEvalResultKind EvalType;\n  union {\n    unsigned long long unsignedVal;\n    long long intVal;\n    double floatVal;\n    char *stringVal;\n  } EvalData;\n  bool IsUnsignedInt;\n  ~ExprEvalResult() {\n    if (EvalType != CXEval_UnExposed && EvalType != CXEval_Float &&\n        EvalType != CXEval_Int) {\n      delete[] EvalData.stringVal;\n    }\n  }\n};\n\nvoid clang_EvalResult_dispose(CXEvalResult E) {\n  delete static_cast<ExprEvalResult *>(E);\n}\n\nCXEvalResultKind clang_EvalResult_getKind(CXEvalResult E) {\n  if (!E) {\n    return CXEval_UnExposed;\n  }\n  return ((ExprEvalResult *)E)->EvalType;\n}\n\nint clang_EvalResult_getAsInt(CXEvalResult E) {\n  return clang_EvalResult_getAsLongLong(E);\n}\n\nlong long clang_EvalResult_getAsLongLong(CXEvalResult E) {\n  if (!E) {\n    return 0;\n  }\n  ExprEvalResult *Result = (ExprEvalResult *)E;\n  if (Result->IsUnsignedInt)\n    return Result->EvalData.unsignedVal;\n  return Result->EvalData.intVal;\n}\n\nunsigned clang_EvalResult_isUnsignedInt(CXEvalResult E) {\n  return ((ExprEvalResult *)E)->IsUnsignedInt;\n}\n\nunsigned long long clang_EvalResult_getAsUnsigned(CXEvalResult E) {\n  if (!E) {\n    return 0;\n  }\n\n  ExprEvalResult *Result = (ExprEvalResult *)E;\n  if (Result->IsUnsignedInt)\n    return Result->EvalData.unsignedVal;\n  return Result->EvalData.intVal;\n}\n\ndouble clang_EvalResult_getAsDouble(CXEvalResult E) {\n  if (!E) {\n    return 0;\n  }\n  return ((ExprEvalResult *)E)->EvalData.floatVal;\n}\n\nconst char *clang_EvalResult_getAsStr(CXEvalResult E) {\n  if (!E) {\n    return nullptr;\n  }\n  return ((ExprEvalResult *)E)->EvalData.stringVal;\n}\n\nstatic const ExprEvalResult *evaluateExpr(Expr *expr, CXCursor C) {\n  Expr::EvalResult ER;\n  ASTContext &ctx = getCursorContext(C);\n  if (!expr)\n    return nullptr;\n\n  expr = expr->IgnoreParens();\n  if (expr->isValueDependent())\n    return nullptr;\n  if (!expr->EvaluateAsRValue(ER, ctx))\n    return nullptr;\n\n  QualType rettype;\n  CallExpr *callExpr;\n  auto result = std::make_unique<ExprEvalResult>();\n  result->EvalType = CXEval_UnExposed;\n  result->IsUnsignedInt = false;\n\n  if (ER.Val.isInt()) {\n    result->EvalType = CXEval_Int;\n\n    auto &val = ER.Val.getInt();\n    if (val.isUnsigned()) {\n      result->IsUnsignedInt = true;\n      result->EvalData.unsignedVal = val.getZExtValue();\n    } else {\n      result->EvalData.intVal = val.getExtValue();\n    }\n\n    return result.release();\n  }\n\n  if (ER.Val.isFloat()) {\n    llvm::SmallVector<char, 100> Buffer;\n    ER.Val.getFloat().toString(Buffer);\n    std::string floatStr(Buffer.data(), Buffer.size());\n    result->EvalType = CXEval_Float;\n    bool ignored;\n    llvm::APFloat apFloat = ER.Val.getFloat();\n    apFloat.convert(llvm::APFloat::IEEEdouble(),\n                    llvm::APFloat::rmNearestTiesToEven, &ignored);\n    result->EvalData.floatVal = apFloat.convertToDouble();\n    return result.release();\n  }\n\n  if (expr->getStmtClass() == Stmt::ImplicitCastExprClass) {\n    const ImplicitCastExpr *I = dyn_cast<ImplicitCastExpr>(expr);\n    auto *subExpr = I->getSubExprAsWritten();\n    if (subExpr->getStmtClass() == Stmt::StringLiteralClass ||\n        subExpr->getStmtClass() == Stmt::ObjCStringLiteralClass) {\n      const StringLiteral *StrE = nullptr;\n      const ObjCStringLiteral *ObjCExpr;\n      ObjCExpr = dyn_cast<ObjCStringLiteral>(subExpr);\n\n      if (ObjCExpr) {\n        StrE = ObjCExpr->getString();\n        result->EvalType = CXEval_ObjCStrLiteral;\n      } else {\n        StrE = cast<StringLiteral>(I->getSubExprAsWritten());\n        result->EvalType = CXEval_StrLiteral;\n      }\n\n      std::string strRef(StrE->getString().str());\n      result->EvalData.stringVal = new char[strRef.size() + 1];\n      strncpy((char *)result->EvalData.stringVal, strRef.c_str(),\n              strRef.size());\n      result->EvalData.stringVal[strRef.size()] = '\\0';\n      return result.release();\n    }\n  } else if (expr->getStmtClass() == Stmt::ObjCStringLiteralClass ||\n             expr->getStmtClass() == Stmt::StringLiteralClass) {\n    const StringLiteral *StrE = nullptr;\n    const ObjCStringLiteral *ObjCExpr;\n    ObjCExpr = dyn_cast<ObjCStringLiteral>(expr);\n\n    if (ObjCExpr) {\n      StrE = ObjCExpr->getString();\n      result->EvalType = CXEval_ObjCStrLiteral;\n    } else {\n      StrE = cast<StringLiteral>(expr);\n      result->EvalType = CXEval_StrLiteral;\n    }\n\n    std::string strRef(StrE->getString().str());\n    result->EvalData.stringVal = new char[strRef.size() + 1];\n    strncpy((char *)result->EvalData.stringVal, strRef.c_str(), strRef.size());\n    result->EvalData.stringVal[strRef.size()] = '\\0';\n    return result.release();\n  }\n\n  if (expr->getStmtClass() == Stmt::CStyleCastExprClass) {\n    CStyleCastExpr *CC = static_cast<CStyleCastExpr *>(expr);\n\n    rettype = CC->getType();\n    if (rettype.getAsString() == \"CFStringRef\" &&\n        CC->getSubExpr()->getStmtClass() == Stmt::CallExprClass) {\n\n      callExpr = static_cast<CallExpr *>(CC->getSubExpr());\n      StringLiteral *S = getCFSTR_value(callExpr);\n      if (S) {\n        std::string strLiteral(S->getString().str());\n        result->EvalType = CXEval_CFStr;\n\n        result->EvalData.stringVal = new char[strLiteral.size() + 1];\n        strncpy((char *)result->EvalData.stringVal, strLiteral.c_str(),\n                strLiteral.size());\n        result->EvalData.stringVal[strLiteral.size()] = '\\0';\n        return result.release();\n      }\n    }\n\n  } else if (expr->getStmtClass() == Stmt::CallExprClass) {\n    callExpr = static_cast<CallExpr *>(expr);\n    rettype = callExpr->getCallReturnType(ctx);\n\n    if (rettype->isVectorType() || callExpr->getNumArgs() > 1)\n      return nullptr;\n\n    if (rettype->isIntegralType(ctx) || rettype->isRealFloatingType()) {\n      if (callExpr->getNumArgs() == 1 &&\n          !callExpr->getArg(0)->getType()->isIntegralType(ctx))\n        return nullptr;\n    } else if (rettype.getAsString() == \"CFStringRef\") {\n\n      StringLiteral *S = getCFSTR_value(callExpr);\n      if (S) {\n        std::string strLiteral(S->getString().str());\n        result->EvalType = CXEval_CFStr;\n        result->EvalData.stringVal = new char[strLiteral.size() + 1];\n        strncpy((char *)result->EvalData.stringVal, strLiteral.c_str(),\n                strLiteral.size());\n        result->EvalData.stringVal[strLiteral.size()] = '\\0';\n        return result.release();\n      }\n    }\n  } else if (expr->getStmtClass() == Stmt::DeclRefExprClass) {\n    DeclRefExpr *D = static_cast<DeclRefExpr *>(expr);\n    ValueDecl *V = D->getDecl();\n    if (V->getKind() == Decl::Function) {\n      std::string strName = V->getNameAsString();\n      result->EvalType = CXEval_Other;\n      result->EvalData.stringVal = new char[strName.size() + 1];\n      strncpy(result->EvalData.stringVal, strName.c_str(), strName.size());\n      result->EvalData.stringVal[strName.size()] = '\\0';\n      return result.release();\n    }\n  }\n\n  return nullptr;\n}\n\nstatic const Expr *evaluateDeclExpr(const Decl *D) {\n  if (!D)\n    return nullptr;\n  if (auto *Var = dyn_cast<VarDecl>(D))\n    return Var->getInit();\n  else if (auto *Field = dyn_cast<FieldDecl>(D))\n    return Field->getInClassInitializer();\n  return nullptr;\n}\n\nstatic const Expr *evaluateCompoundStmtExpr(const CompoundStmt *CS) {\n  assert(CS && \"invalid compound statement\");\n  for (auto *bodyIterator : CS->body()) {\n    if (const auto *E = dyn_cast<Expr>(bodyIterator))\n      return E;\n  }\n  return nullptr;\n}\n\nCXEvalResult clang_Cursor_Evaluate(CXCursor C) {\n  const Expr *E = nullptr;\n  if (clang_getCursorKind(C) == CXCursor_CompoundStmt)\n    E = evaluateCompoundStmtExpr(cast<CompoundStmt>(getCursorStmt(C)));\n  else if (clang_isDeclaration(C.kind))\n    E = evaluateDeclExpr(getCursorDecl(C));\n  else if (clang_isExpression(C.kind))\n    E = getCursorExpr(C);\n  if (E)\n    return const_cast<CXEvalResult>(\n        reinterpret_cast<const void *>(evaluateExpr(const_cast<Expr *>(E), C)));\n  return nullptr;\n}\n\nunsigned clang_Cursor_hasAttrs(CXCursor C) {\n  const Decl *D = getCursorDecl(C);\n  if (!D) {\n    return 0;\n  }\n\n  if (D->hasAttrs()) {\n    return 1;\n  }\n\n  return 0;\n}\nunsigned clang_defaultSaveOptions(CXTranslationUnit TU) {\n  return CXSaveTranslationUnit_None;\n}\n\nstatic CXSaveError clang_saveTranslationUnit_Impl(CXTranslationUnit TU,\n                                                  const char *FileName,\n                                                  unsigned options) {\n  CIndexer *CXXIdx = TU->CIdx;\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForIndexing))\n    setThreadBackgroundPriority();\n\n  bool hadError = cxtu::getASTUnit(TU)->Save(FileName);\n  return hadError ? CXSaveError_Unknown : CXSaveError_None;\n}\n\nint clang_saveTranslationUnit(CXTranslationUnit TU, const char *FileName,\n                              unsigned options) {\n  LOG_FUNC_SECTION { *Log << TU << ' ' << FileName; }\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return CXSaveError_InvalidTU;\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n  if (!CXXUnit->hasSema())\n    return CXSaveError_InvalidTU;\n\n  CXSaveError result;\n  auto SaveTranslationUnitImpl = [=, &result]() {\n    result = clang_saveTranslationUnit_Impl(TU, FileName, options);\n  };\n\n  if (!CXXUnit->getDiagnostics().hasUnrecoverableErrorOccurred()) {\n    SaveTranslationUnitImpl();\n\n    if (getenv(\"LIBCLANG_RESOURCE_USAGE\"))\n      PrintLibclangResourceUsage(TU);\n\n    return result;\n  }\n\n  // We have an AST that has invalid nodes due to compiler errors.\n  // Use a crash recovery thread for protection.\n\n  llvm::CrashRecoveryContext CRC;\n\n  if (!RunSafely(CRC, SaveTranslationUnitImpl)) {\n    fprintf(stderr, \"libclang: crash detected during AST saving: {\\n\");\n    fprintf(stderr, \"  'filename' : '%s'\\n\", FileName);\n    fprintf(stderr, \"  'options' : %d,\\n\", options);\n    fprintf(stderr, \"}\\n\");\n\n    return CXSaveError_Unknown;\n\n  } else if (getenv(\"LIBCLANG_RESOURCE_USAGE\")) {\n    PrintLibclangResourceUsage(TU);\n  }\n\n  return result;\n}\n\nvoid clang_disposeTranslationUnit(CXTranslationUnit CTUnit) {\n  if (CTUnit) {\n    // If the translation unit has been marked as unsafe to free, just discard\n    // it.\n    ASTUnit *Unit = cxtu::getASTUnit(CTUnit);\n    if (Unit && Unit->isUnsafeToFree())\n      return;\n\n    delete cxtu::getASTUnit(CTUnit);\n    delete CTUnit->StringPool;\n    delete static_cast<CXDiagnosticSetImpl *>(CTUnit->Diagnostics);\n    disposeOverridenCXCursorsPool(CTUnit->OverridenCursorsPool);\n    delete CTUnit->CommentToXML;\n    delete CTUnit;\n  }\n}\n\nunsigned clang_suspendTranslationUnit(CXTranslationUnit CTUnit) {\n  if (CTUnit) {\n    ASTUnit *Unit = cxtu::getASTUnit(CTUnit);\n\n    if (Unit && Unit->isUnsafeToFree())\n      return false;\n\n    Unit->ResetForParse();\n    return true;\n  }\n\n  return false;\n}\n\nunsigned clang_defaultReparseOptions(CXTranslationUnit TU) {\n  return CXReparse_None;\n}\n\nstatic CXErrorCode\nclang_reparseTranslationUnit_Impl(CXTranslationUnit TU,\n                                  ArrayRef<CXUnsavedFile> unsaved_files,\n                                  unsigned options) {\n  // Check arguments.\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return CXError_InvalidArguments;\n  }\n\n  // Reset the associated diagnostics.\n  delete static_cast<CXDiagnosticSetImpl *>(TU->Diagnostics);\n  TU->Diagnostics = nullptr;\n\n  CIndexer *CXXIdx = TU->CIdx;\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForEditing))\n    setThreadBackgroundPriority();\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n\n  std::unique_ptr<std::vector<ASTUnit::RemappedFile>> RemappedFiles(\n      new std::vector<ASTUnit::RemappedFile>());\n\n  // Recover resources if we crash before exiting this function.\n  llvm::CrashRecoveryContextCleanupRegistrar<std::vector<ASTUnit::RemappedFile>>\n      RemappedCleanup(RemappedFiles.get());\n\n  for (auto &UF : unsaved_files) {\n    std::unique_ptr<llvm::MemoryBuffer> MB =\n        llvm::MemoryBuffer::getMemBufferCopy(getContents(UF), UF.Filename);\n    RemappedFiles->push_back(std::make_pair(UF.Filename, MB.release()));\n  }\n\n  if (!CXXUnit->Reparse(CXXIdx->getPCHContainerOperations(),\n                        *RemappedFiles.get()))\n    return CXError_Success;\n  if (isASTReadError(CXXUnit))\n    return CXError_ASTReadError;\n  return CXError_Failure;\n}\n\nint clang_reparseTranslationUnit(CXTranslationUnit TU,\n                                 unsigned num_unsaved_files,\n                                 struct CXUnsavedFile *unsaved_files,\n                                 unsigned options) {\n  LOG_FUNC_SECTION { *Log << TU; }\n\n  if (num_unsaved_files && !unsaved_files)\n    return CXError_InvalidArguments;\n\n  CXErrorCode result;\n  auto ReparseTranslationUnitImpl = [=, &result]() {\n    result = clang_reparseTranslationUnit_Impl(\n        TU, llvm::makeArrayRef(unsaved_files, num_unsaved_files), options);\n  };\n\n  llvm::CrashRecoveryContext CRC;\n\n  if (!RunSafely(CRC, ReparseTranslationUnitImpl)) {\n    fprintf(stderr, \"libclang: crash detected during reparsing\\n\");\n    cxtu::getASTUnit(TU)->setUnsafeToFree(true);\n    return CXError_Crashed;\n  } else if (getenv(\"LIBCLANG_RESOURCE_USAGE\"))\n    PrintLibclangResourceUsage(TU);\n\n  return result;\n}\n\nCXString clang_getTranslationUnitSpelling(CXTranslationUnit CTUnit) {\n  if (isNotUsableTU(CTUnit)) {\n    LOG_BAD_TU(CTUnit);\n    return cxstring::createEmpty();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(CTUnit);\n  return cxstring::createDup(CXXUnit->getOriginalSourceFileName());\n}\n\nCXCursor clang_getTranslationUnitCursor(CXTranslationUnit TU) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return clang_getNullCursor();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  return MakeCXCursor(CXXUnit->getASTContext().getTranslationUnitDecl(), TU);\n}\n\nCXTargetInfo clang_getTranslationUnitTargetInfo(CXTranslationUnit CTUnit) {\n  if (isNotUsableTU(CTUnit)) {\n    LOG_BAD_TU(CTUnit);\n    return nullptr;\n  }\n\n  CXTargetInfoImpl *impl = new CXTargetInfoImpl();\n  impl->TranslationUnit = CTUnit;\n  return impl;\n}\n\nCXString clang_TargetInfo_getTriple(CXTargetInfo TargetInfo) {\n  if (!TargetInfo)\n    return cxstring::createEmpty();\n\n  CXTranslationUnit CTUnit = TargetInfo->TranslationUnit;\n  assert(!isNotUsableTU(CTUnit) &&\n         \"Unexpected unusable translation unit in TargetInfo\");\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(CTUnit);\n  std::string Triple =\n      CXXUnit->getASTContext().getTargetInfo().getTriple().normalize();\n  return cxstring::createDup(Triple);\n}\n\nint clang_TargetInfo_getPointerWidth(CXTargetInfo TargetInfo) {\n  if (!TargetInfo)\n    return -1;\n\n  CXTranslationUnit CTUnit = TargetInfo->TranslationUnit;\n  assert(!isNotUsableTU(CTUnit) &&\n         \"Unexpected unusable translation unit in TargetInfo\");\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(CTUnit);\n  return CXXUnit->getASTContext().getTargetInfo().getMaxPointerWidth();\n}\n\nvoid clang_TargetInfo_dispose(CXTargetInfo TargetInfo) {\n  if (!TargetInfo)\n    return;\n\n  delete TargetInfo;\n}\n\n//===----------------------------------------------------------------------===//\n// CXFile Operations.\n//===----------------------------------------------------------------------===//\n\nCXString clang_getFileName(CXFile SFile) {\n  if (!SFile)\n    return cxstring::createNull();\n\n  FileEntry *FEnt = static_cast<FileEntry *>(SFile);\n  return cxstring::createRef(FEnt->getName());\n}\n\ntime_t clang_getFileTime(CXFile SFile) {\n  if (!SFile)\n    return 0;\n\n  FileEntry *FEnt = static_cast<FileEntry *>(SFile);\n  return FEnt->getModificationTime();\n}\n\nCXFile clang_getFile(CXTranslationUnit TU, const char *file_name) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n\n  FileManager &FMgr = CXXUnit->getFileManager();\n  auto File = FMgr.getFile(file_name);\n  if (!File)\n    return nullptr;\n  return const_cast<FileEntry *>(*File);\n}\n\nconst char *clang_getFileContents(CXTranslationUnit TU, CXFile file,\n                                  size_t *size) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n\n  const SourceManager &SM = cxtu::getASTUnit(TU)->getSourceManager();\n  FileID fid = SM.translateFile(static_cast<FileEntry *>(file));\n  llvm::Optional<llvm::MemoryBufferRef> buf = SM.getBufferOrNone(fid);\n  if (!buf) {\n    if (size)\n      *size = 0;\n    return nullptr;\n  }\n  if (size)\n    *size = buf->getBufferSize();\n  return buf->getBufferStart();\n}\n\nunsigned clang_isFileMultipleIncludeGuarded(CXTranslationUnit TU, CXFile file) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return 0;\n  }\n\n  if (!file)\n    return 0;\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  FileEntry *FEnt = static_cast<FileEntry *>(file);\n  return CXXUnit->getPreprocessor()\n      .getHeaderSearchInfo()\n      .isFileMultipleIncludeGuarded(FEnt);\n}\n\nint clang_getFileUniqueID(CXFile file, CXFileUniqueID *outID) {\n  if (!file || !outID)\n    return 1;\n\n  FileEntry *FEnt = static_cast<FileEntry *>(file);\n  const llvm::sys::fs::UniqueID &ID = FEnt->getUniqueID();\n  outID->data[0] = ID.getDevice();\n  outID->data[1] = ID.getFile();\n  outID->data[2] = FEnt->getModificationTime();\n  return 0;\n}\n\nint clang_File_isEqual(CXFile file1, CXFile file2) {\n  if (file1 == file2)\n    return true;\n\n  if (!file1 || !file2)\n    return false;\n\n  FileEntry *FEnt1 = static_cast<FileEntry *>(file1);\n  FileEntry *FEnt2 = static_cast<FileEntry *>(file2);\n  return FEnt1->getUniqueID() == FEnt2->getUniqueID();\n}\n\nCXString clang_File_tryGetRealPathName(CXFile SFile) {\n  if (!SFile)\n    return cxstring::createNull();\n\n  FileEntry *FEnt = static_cast<FileEntry *>(SFile);\n  return cxstring::createRef(FEnt->tryGetRealPathName());\n}\n\n//===----------------------------------------------------------------------===//\n// CXCursor Operations.\n//===----------------------------------------------------------------------===//\n\nstatic const Decl *getDeclFromExpr(const Stmt *E) {\n  if (const ImplicitCastExpr *CE = dyn_cast<ImplicitCastExpr>(E))\n    return getDeclFromExpr(CE->getSubExpr());\n\n  if (const DeclRefExpr *RefExpr = dyn_cast<DeclRefExpr>(E))\n    return RefExpr->getDecl();\n  if (const MemberExpr *ME = dyn_cast<MemberExpr>(E))\n    return ME->getMemberDecl();\n  if (const ObjCIvarRefExpr *RE = dyn_cast<ObjCIvarRefExpr>(E))\n    return RE->getDecl();\n  if (const ObjCPropertyRefExpr *PRE = dyn_cast<ObjCPropertyRefExpr>(E)) {\n    if (PRE->isExplicitProperty())\n      return PRE->getExplicitProperty();\n    // It could be messaging both getter and setter as in:\n    // ++myobj.myprop;\n    // in which case prefer to associate the setter since it is less obvious\n    // from inspecting the source that the setter is going to get called.\n    if (PRE->isMessagingSetter())\n      return PRE->getImplicitPropertySetter();\n    return PRE->getImplicitPropertyGetter();\n  }\n  if (const PseudoObjectExpr *POE = dyn_cast<PseudoObjectExpr>(E))\n    return getDeclFromExpr(POE->getSyntacticForm());\n  if (const OpaqueValueExpr *OVE = dyn_cast<OpaqueValueExpr>(E))\n    if (Expr *Src = OVE->getSourceExpr())\n      return getDeclFromExpr(Src);\n\n  if (const CallExpr *CE = dyn_cast<CallExpr>(E))\n    return getDeclFromExpr(CE->getCallee());\n  if (const CXXConstructExpr *CE = dyn_cast<CXXConstructExpr>(E))\n    if (!CE->isElidable())\n      return CE->getConstructor();\n  if (const CXXInheritedCtorInitExpr *CE =\n          dyn_cast<CXXInheritedCtorInitExpr>(E))\n    return CE->getConstructor();\n  if (const ObjCMessageExpr *OME = dyn_cast<ObjCMessageExpr>(E))\n    return OME->getMethodDecl();\n\n  if (const ObjCProtocolExpr *PE = dyn_cast<ObjCProtocolExpr>(E))\n    return PE->getProtocol();\n  if (const SubstNonTypeTemplateParmPackExpr *NTTP =\n          dyn_cast<SubstNonTypeTemplateParmPackExpr>(E))\n    return NTTP->getParameterPack();\n  if (const SizeOfPackExpr *SizeOfPack = dyn_cast<SizeOfPackExpr>(E))\n    if (isa<NonTypeTemplateParmDecl>(SizeOfPack->getPack()) ||\n        isa<ParmVarDecl>(SizeOfPack->getPack()))\n      return SizeOfPack->getPack();\n\n  return nullptr;\n}\n\nstatic SourceLocation getLocationFromExpr(const Expr *E) {\n  if (const ImplicitCastExpr *CE = dyn_cast<ImplicitCastExpr>(E))\n    return getLocationFromExpr(CE->getSubExpr());\n\n  if (const ObjCMessageExpr *Msg = dyn_cast<ObjCMessageExpr>(E))\n    return /*FIXME:*/ Msg->getLeftLoc();\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E))\n    return DRE->getLocation();\n  if (const MemberExpr *Member = dyn_cast<MemberExpr>(E))\n    return Member->getMemberLoc();\n  if (const ObjCIvarRefExpr *Ivar = dyn_cast<ObjCIvarRefExpr>(E))\n    return Ivar->getLocation();\n  if (const SizeOfPackExpr *SizeOfPack = dyn_cast<SizeOfPackExpr>(E))\n    return SizeOfPack->getPackLoc();\n  if (const ObjCPropertyRefExpr *PropRef = dyn_cast<ObjCPropertyRefExpr>(E))\n    return PropRef->getLocation();\n\n  return E->getBeginLoc();\n}\n\nextern \"C\" {\n\nunsigned clang_visitChildren(CXCursor parent, CXCursorVisitor visitor,\n                             CXClientData client_data) {\n  CursorVisitor CursorVis(getCursorTU(parent), visitor, client_data,\n                          /*VisitPreprocessorLast=*/false);\n  return CursorVis.VisitChildren(parent);\n}\n\n#ifndef __has_feature\n#define __has_feature(x) 0\n#endif\n#if __has_feature(blocks)\ntypedef enum CXChildVisitResult (^CXCursorVisitorBlock)(CXCursor cursor,\n                                                        CXCursor parent);\n\nstatic enum CXChildVisitResult visitWithBlock(CXCursor cursor, CXCursor parent,\n                                              CXClientData client_data) {\n  CXCursorVisitorBlock block = (CXCursorVisitorBlock)client_data;\n  return block(cursor, parent);\n}\n#else\n// If we are compiled with a compiler that doesn't have native blocks support,\n// define and call the block manually, so the\ntypedef struct _CXChildVisitResult {\n  void *isa;\n  int flags;\n  int reserved;\n  enum CXChildVisitResult (*invoke)(struct _CXChildVisitResult *, CXCursor,\n                                    CXCursor);\n} * CXCursorVisitorBlock;\n\nstatic enum CXChildVisitResult visitWithBlock(CXCursor cursor, CXCursor parent,\n                                              CXClientData client_data) {\n  CXCursorVisitorBlock block = (CXCursorVisitorBlock)client_data;\n  return block->invoke(block, cursor, parent);\n}\n#endif\n\nunsigned clang_visitChildrenWithBlock(CXCursor parent,\n                                      CXCursorVisitorBlock block) {\n  return clang_visitChildren(parent, visitWithBlock, block);\n}\n\nstatic CXString getDeclSpelling(const Decl *D) {\n  if (!D)\n    return cxstring::createEmpty();\n\n  const NamedDecl *ND = dyn_cast<NamedDecl>(D);\n  if (!ND) {\n    if (const ObjCPropertyImplDecl *PropImpl =\n            dyn_cast<ObjCPropertyImplDecl>(D))\n      if (ObjCPropertyDecl *Property = PropImpl->getPropertyDecl())\n        return cxstring::createDup(Property->getIdentifier()->getName());\n\n    if (const ImportDecl *ImportD = dyn_cast<ImportDecl>(D))\n      if (Module *Mod = ImportD->getImportedModule())\n        return cxstring::createDup(Mod->getFullModuleName());\n\n    return cxstring::createEmpty();\n  }\n\n  if (const ObjCMethodDecl *OMD = dyn_cast<ObjCMethodDecl>(ND))\n    return cxstring::createDup(OMD->getSelector().getAsString());\n\n  if (const ObjCCategoryImplDecl *CIMP = dyn_cast<ObjCCategoryImplDecl>(ND))\n    // No, this isn't the same as the code below. getIdentifier() is non-virtual\n    // and returns different names. NamedDecl returns the class name and\n    // ObjCCategoryImplDecl returns the category name.\n    return cxstring::createRef(CIMP->getIdentifier()->getNameStart());\n\n  if (isa<UsingDirectiveDecl>(D))\n    return cxstring::createEmpty();\n\n  SmallString<1024> S;\n  llvm::raw_svector_ostream os(S);\n  ND->printName(os);\n\n  return cxstring::createDup(os.str());\n}\n\nCXString clang_getCursorSpelling(CXCursor C) {\n  if (clang_isTranslationUnit(C.kind))\n    return clang_getTranslationUnitSpelling(getCursorTU(C));\n\n  if (clang_isReference(C.kind)) {\n    switch (C.kind) {\n    case CXCursor_ObjCSuperClassRef: {\n      const ObjCInterfaceDecl *Super = getCursorObjCSuperClassRef(C).first;\n      return cxstring::createRef(Super->getIdentifier()->getNameStart());\n    }\n    case CXCursor_ObjCClassRef: {\n      const ObjCInterfaceDecl *Class = getCursorObjCClassRef(C).first;\n      return cxstring::createRef(Class->getIdentifier()->getNameStart());\n    }\n    case CXCursor_ObjCProtocolRef: {\n      const ObjCProtocolDecl *OID = getCursorObjCProtocolRef(C).first;\n      assert(OID && \"getCursorSpelling(): Missing protocol decl\");\n      return cxstring::createRef(OID->getIdentifier()->getNameStart());\n    }\n    case CXCursor_CXXBaseSpecifier: {\n      const CXXBaseSpecifier *B = getCursorCXXBaseSpecifier(C);\n      return cxstring::createDup(B->getType().getAsString());\n    }\n    case CXCursor_TypeRef: {\n      const TypeDecl *Type = getCursorTypeRef(C).first;\n      assert(Type && \"Missing type decl\");\n\n      return cxstring::createDup(\n          getCursorContext(C).getTypeDeclType(Type).getAsString());\n    }\n    case CXCursor_TemplateRef: {\n      const TemplateDecl *Template = getCursorTemplateRef(C).first;\n      assert(Template && \"Missing template decl\");\n\n      return cxstring::createDup(Template->getNameAsString());\n    }\n\n    case CXCursor_NamespaceRef: {\n      const NamedDecl *NS = getCursorNamespaceRef(C).first;\n      assert(NS && \"Missing namespace decl\");\n\n      return cxstring::createDup(NS->getNameAsString());\n    }\n\n    case CXCursor_MemberRef: {\n      const FieldDecl *Field = getCursorMemberRef(C).first;\n      assert(Field && \"Missing member decl\");\n\n      return cxstring::createDup(Field->getNameAsString());\n    }\n\n    case CXCursor_LabelRef: {\n      const LabelStmt *Label = getCursorLabelRef(C).first;\n      assert(Label && \"Missing label\");\n\n      return cxstring::createRef(Label->getName());\n    }\n\n    case CXCursor_OverloadedDeclRef: {\n      OverloadedDeclRefStorage Storage = getCursorOverloadedDeclRef(C).first;\n      if (const Decl *D = Storage.dyn_cast<const Decl *>()) {\n        if (const NamedDecl *ND = dyn_cast<NamedDecl>(D))\n          return cxstring::createDup(ND->getNameAsString());\n        return cxstring::createEmpty();\n      }\n      if (const OverloadExpr *E = Storage.dyn_cast<const OverloadExpr *>())\n        return cxstring::createDup(E->getName().getAsString());\n      OverloadedTemplateStorage *Ovl =\n          Storage.get<OverloadedTemplateStorage *>();\n      if (Ovl->size() == 0)\n        return cxstring::createEmpty();\n      return cxstring::createDup((*Ovl->begin())->getNameAsString());\n    }\n\n    case CXCursor_VariableRef: {\n      const VarDecl *Var = getCursorVariableRef(C).first;\n      assert(Var && \"Missing variable decl\");\n\n      return cxstring::createDup(Var->getNameAsString());\n    }\n\n    default:\n      return cxstring::createRef(\"<not implemented>\");\n    }\n  }\n\n  if (clang_isExpression(C.kind)) {\n    const Expr *E = getCursorExpr(C);\n\n    if (C.kind == CXCursor_ObjCStringLiteral ||\n        C.kind == CXCursor_StringLiteral) {\n      const StringLiteral *SLit;\n      if (const ObjCStringLiteral *OSL = dyn_cast<ObjCStringLiteral>(E)) {\n        SLit = OSL->getString();\n      } else {\n        SLit = cast<StringLiteral>(E);\n      }\n      SmallString<256> Buf;\n      llvm::raw_svector_ostream OS(Buf);\n      SLit->outputString(OS);\n      return cxstring::createDup(OS.str());\n    }\n\n    const Decl *D = getDeclFromExpr(getCursorExpr(C));\n    if (D)\n      return getDeclSpelling(D);\n    return cxstring::createEmpty();\n  }\n\n  if (clang_isStatement(C.kind)) {\n    const Stmt *S = getCursorStmt(C);\n    if (const LabelStmt *Label = dyn_cast_or_null<LabelStmt>(S))\n      return cxstring::createRef(Label->getName());\n\n    return cxstring::createEmpty();\n  }\n\n  if (C.kind == CXCursor_MacroExpansion)\n    return cxstring::createRef(\n        getCursorMacroExpansion(C).getName()->getNameStart());\n\n  if (C.kind == CXCursor_MacroDefinition)\n    return cxstring::createRef(\n        getCursorMacroDefinition(C)->getName()->getNameStart());\n\n  if (C.kind == CXCursor_InclusionDirective)\n    return cxstring::createDup(getCursorInclusionDirective(C)->getFileName());\n\n  if (clang_isDeclaration(C.kind))\n    return getDeclSpelling(getCursorDecl(C));\n\n  if (C.kind == CXCursor_AnnotateAttr) {\n    const AnnotateAttr *AA = cast<AnnotateAttr>(cxcursor::getCursorAttr(C));\n    return cxstring::createDup(AA->getAnnotation());\n  }\n\n  if (C.kind == CXCursor_AsmLabelAttr) {\n    const AsmLabelAttr *AA = cast<AsmLabelAttr>(cxcursor::getCursorAttr(C));\n    return cxstring::createDup(AA->getLabel());\n  }\n\n  if (C.kind == CXCursor_PackedAttr) {\n    return cxstring::createRef(\"packed\");\n  }\n\n  if (C.kind == CXCursor_VisibilityAttr) {\n    const VisibilityAttr *AA = cast<VisibilityAttr>(cxcursor::getCursorAttr(C));\n    switch (AA->getVisibility()) {\n    case VisibilityAttr::VisibilityType::Default:\n      return cxstring::createRef(\"default\");\n    case VisibilityAttr::VisibilityType::Hidden:\n      return cxstring::createRef(\"hidden\");\n    case VisibilityAttr::VisibilityType::Protected:\n      return cxstring::createRef(\"protected\");\n    }\n    llvm_unreachable(\"unknown visibility type\");\n  }\n\n  return cxstring::createEmpty();\n}\n\nCXSourceRange clang_Cursor_getSpellingNameRange(CXCursor C, unsigned pieceIndex,\n                                                unsigned options) {\n  if (clang_Cursor_isNull(C))\n    return clang_getNullRange();\n\n  ASTContext &Ctx = getCursorContext(C);\n\n  if (clang_isStatement(C.kind)) {\n    const Stmt *S = getCursorStmt(C);\n    if (const LabelStmt *Label = dyn_cast_or_null<LabelStmt>(S)) {\n      if (pieceIndex > 0)\n        return clang_getNullRange();\n      return cxloc::translateSourceRange(Ctx, Label->getIdentLoc());\n    }\n\n    return clang_getNullRange();\n  }\n\n  if (C.kind == CXCursor_ObjCMessageExpr) {\n    if (const ObjCMessageExpr *ME =\n            dyn_cast_or_null<ObjCMessageExpr>(getCursorExpr(C))) {\n      if (pieceIndex >= ME->getNumSelectorLocs())\n        return clang_getNullRange();\n      return cxloc::translateSourceRange(Ctx, ME->getSelectorLoc(pieceIndex));\n    }\n  }\n\n  if (C.kind == CXCursor_ObjCInstanceMethodDecl ||\n      C.kind == CXCursor_ObjCClassMethodDecl) {\n    if (const ObjCMethodDecl *MD =\n            dyn_cast_or_null<ObjCMethodDecl>(getCursorDecl(C))) {\n      if (pieceIndex >= MD->getNumSelectorLocs())\n        return clang_getNullRange();\n      return cxloc::translateSourceRange(Ctx, MD->getSelectorLoc(pieceIndex));\n    }\n  }\n\n  if (C.kind == CXCursor_ObjCCategoryDecl ||\n      C.kind == CXCursor_ObjCCategoryImplDecl) {\n    if (pieceIndex > 0)\n      return clang_getNullRange();\n    if (const ObjCCategoryDecl *CD =\n            dyn_cast_or_null<ObjCCategoryDecl>(getCursorDecl(C)))\n      return cxloc::translateSourceRange(Ctx, CD->getCategoryNameLoc());\n    if (const ObjCCategoryImplDecl *CID =\n            dyn_cast_or_null<ObjCCategoryImplDecl>(getCursorDecl(C)))\n      return cxloc::translateSourceRange(Ctx, CID->getCategoryNameLoc());\n  }\n\n  if (C.kind == CXCursor_ModuleImportDecl) {\n    if (pieceIndex > 0)\n      return clang_getNullRange();\n    if (const ImportDecl *ImportD =\n            dyn_cast_or_null<ImportDecl>(getCursorDecl(C))) {\n      ArrayRef<SourceLocation> Locs = ImportD->getIdentifierLocs();\n      if (!Locs.empty())\n        return cxloc::translateSourceRange(\n            Ctx, SourceRange(Locs.front(), Locs.back()));\n    }\n    return clang_getNullRange();\n  }\n\n  if (C.kind == CXCursor_CXXMethod || C.kind == CXCursor_Destructor ||\n      C.kind == CXCursor_ConversionFunction ||\n      C.kind == CXCursor_FunctionDecl) {\n    if (pieceIndex > 0)\n      return clang_getNullRange();\n    if (const FunctionDecl *FD =\n            dyn_cast_or_null<FunctionDecl>(getCursorDecl(C))) {\n      DeclarationNameInfo FunctionName = FD->getNameInfo();\n      return cxloc::translateSourceRange(Ctx, FunctionName.getSourceRange());\n    }\n    return clang_getNullRange();\n  }\n\n  // FIXME: A CXCursor_InclusionDirective should give the location of the\n  // filename, but we don't keep track of this.\n\n  // FIXME: A CXCursor_AnnotateAttr should give the location of the annotation\n  // but we don't keep track of this.\n\n  // FIXME: A CXCursor_AsmLabelAttr should give the location of the label\n  // but we don't keep track of this.\n\n  // Default handling, give the location of the cursor.\n\n  if (pieceIndex > 0)\n    return clang_getNullRange();\n\n  CXSourceLocation CXLoc = clang_getCursorLocation(C);\n  SourceLocation Loc = cxloc::translateSourceLocation(CXLoc);\n  return cxloc::translateSourceRange(Ctx, Loc);\n}\n\nCXString clang_Cursor_getMangling(CXCursor C) {\n  if (clang_isInvalid(C.kind) || !clang_isDeclaration(C.kind))\n    return cxstring::createEmpty();\n\n  // Mangling only works for functions and variables.\n  const Decl *D = getCursorDecl(C);\n  if (!D || !(isa<FunctionDecl>(D) || isa<VarDecl>(D)))\n    return cxstring::createEmpty();\n\n  ASTContext &Ctx = D->getASTContext();\n  ASTNameGenerator ASTNameGen(Ctx);\n  return cxstring::createDup(ASTNameGen.getName(D));\n}\n\nCXStringSet *clang_Cursor_getCXXManglings(CXCursor C) {\n  if (clang_isInvalid(C.kind) || !clang_isDeclaration(C.kind))\n    return nullptr;\n\n  const Decl *D = getCursorDecl(C);\n  if (!(isa<CXXRecordDecl>(D) || isa<CXXMethodDecl>(D)))\n    return nullptr;\n\n  ASTContext &Ctx = D->getASTContext();\n  ASTNameGenerator ASTNameGen(Ctx);\n  std::vector<std::string> Manglings = ASTNameGen.getAllManglings(D);\n  return cxstring::createSet(Manglings);\n}\n\nCXStringSet *clang_Cursor_getObjCManglings(CXCursor C) {\n  if (clang_isInvalid(C.kind) || !clang_isDeclaration(C.kind))\n    return nullptr;\n\n  const Decl *D = getCursorDecl(C);\n  if (!(isa<ObjCInterfaceDecl>(D) || isa<ObjCImplementationDecl>(D)))\n    return nullptr;\n\n  ASTContext &Ctx = D->getASTContext();\n  ASTNameGenerator ASTNameGen(Ctx);\n  std::vector<std::string> Manglings = ASTNameGen.getAllManglings(D);\n  return cxstring::createSet(Manglings);\n}\n\nCXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor C) {\n  if (clang_Cursor_isNull(C))\n    return 0;\n  return new PrintingPolicy(getCursorContext(C).getPrintingPolicy());\n}\n\nvoid clang_PrintingPolicy_dispose(CXPrintingPolicy Policy) {\n  if (Policy)\n    delete static_cast<PrintingPolicy *>(Policy);\n}\n\nunsigned\nclang_PrintingPolicy_getProperty(CXPrintingPolicy Policy,\n                                 enum CXPrintingPolicyProperty Property) {\n  if (!Policy)\n    return 0;\n\n  PrintingPolicy *P = static_cast<PrintingPolicy *>(Policy);\n  switch (Property) {\n  case CXPrintingPolicy_Indentation:\n    return P->Indentation;\n  case CXPrintingPolicy_SuppressSpecifiers:\n    return P->SuppressSpecifiers;\n  case CXPrintingPolicy_SuppressTagKeyword:\n    return P->SuppressTagKeyword;\n  case CXPrintingPolicy_IncludeTagDefinition:\n    return P->IncludeTagDefinition;\n  case CXPrintingPolicy_SuppressScope:\n    return P->SuppressScope;\n  case CXPrintingPolicy_SuppressUnwrittenScope:\n    return P->SuppressUnwrittenScope;\n  case CXPrintingPolicy_SuppressInitializers:\n    return P->SuppressInitializers;\n  case CXPrintingPolicy_ConstantArraySizeAsWritten:\n    return P->ConstantArraySizeAsWritten;\n  case CXPrintingPolicy_AnonymousTagLocations:\n    return P->AnonymousTagLocations;\n  case CXPrintingPolicy_SuppressStrongLifetime:\n    return P->SuppressStrongLifetime;\n  case CXPrintingPolicy_SuppressLifetimeQualifiers:\n    return P->SuppressLifetimeQualifiers;\n  case CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors:\n    return P->SuppressTemplateArgsInCXXConstructors;\n  case CXPrintingPolicy_Bool:\n    return P->Bool;\n  case CXPrintingPolicy_Restrict:\n    return P->Restrict;\n  case CXPrintingPolicy_Alignof:\n    return P->Alignof;\n  case CXPrintingPolicy_UnderscoreAlignof:\n    return P->UnderscoreAlignof;\n  case CXPrintingPolicy_UseVoidForZeroParams:\n    return P->UseVoidForZeroParams;\n  case CXPrintingPolicy_TerseOutput:\n    return P->TerseOutput;\n  case CXPrintingPolicy_PolishForDeclaration:\n    return P->PolishForDeclaration;\n  case CXPrintingPolicy_Half:\n    return P->Half;\n  case CXPrintingPolicy_MSWChar:\n    return P->MSWChar;\n  case CXPrintingPolicy_IncludeNewlines:\n    return P->IncludeNewlines;\n  case CXPrintingPolicy_MSVCFormatting:\n    return P->MSVCFormatting;\n  case CXPrintingPolicy_ConstantsAsWritten:\n    return P->ConstantsAsWritten;\n  case CXPrintingPolicy_SuppressImplicitBase:\n    return P->SuppressImplicitBase;\n  case CXPrintingPolicy_FullyQualifiedName:\n    return P->FullyQualifiedName;\n  }\n\n  assert(false && \"Invalid CXPrintingPolicyProperty\");\n  return 0;\n}\n\nvoid clang_PrintingPolicy_setProperty(CXPrintingPolicy Policy,\n                                      enum CXPrintingPolicyProperty Property,\n                                      unsigned Value) {\n  if (!Policy)\n    return;\n\n  PrintingPolicy *P = static_cast<PrintingPolicy *>(Policy);\n  switch (Property) {\n  case CXPrintingPolicy_Indentation:\n    P->Indentation = Value;\n    return;\n  case CXPrintingPolicy_SuppressSpecifiers:\n    P->SuppressSpecifiers = Value;\n    return;\n  case CXPrintingPolicy_SuppressTagKeyword:\n    P->SuppressTagKeyword = Value;\n    return;\n  case CXPrintingPolicy_IncludeTagDefinition:\n    P->IncludeTagDefinition = Value;\n    return;\n  case CXPrintingPolicy_SuppressScope:\n    P->SuppressScope = Value;\n    return;\n  case CXPrintingPolicy_SuppressUnwrittenScope:\n    P->SuppressUnwrittenScope = Value;\n    return;\n  case CXPrintingPolicy_SuppressInitializers:\n    P->SuppressInitializers = Value;\n    return;\n  case CXPrintingPolicy_ConstantArraySizeAsWritten:\n    P->ConstantArraySizeAsWritten = Value;\n    return;\n  case CXPrintingPolicy_AnonymousTagLocations:\n    P->AnonymousTagLocations = Value;\n    return;\n  case CXPrintingPolicy_SuppressStrongLifetime:\n    P->SuppressStrongLifetime = Value;\n    return;\n  case CXPrintingPolicy_SuppressLifetimeQualifiers:\n    P->SuppressLifetimeQualifiers = Value;\n    return;\n  case CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors:\n    P->SuppressTemplateArgsInCXXConstructors = Value;\n    return;\n  case CXPrintingPolicy_Bool:\n    P->Bool = Value;\n    return;\n  case CXPrintingPolicy_Restrict:\n    P->Restrict = Value;\n    return;\n  case CXPrintingPolicy_Alignof:\n    P->Alignof = Value;\n    return;\n  case CXPrintingPolicy_UnderscoreAlignof:\n    P->UnderscoreAlignof = Value;\n    return;\n  case CXPrintingPolicy_UseVoidForZeroParams:\n    P->UseVoidForZeroParams = Value;\n    return;\n  case CXPrintingPolicy_TerseOutput:\n    P->TerseOutput = Value;\n    return;\n  case CXPrintingPolicy_PolishForDeclaration:\n    P->PolishForDeclaration = Value;\n    return;\n  case CXPrintingPolicy_Half:\n    P->Half = Value;\n    return;\n  case CXPrintingPolicy_MSWChar:\n    P->MSWChar = Value;\n    return;\n  case CXPrintingPolicy_IncludeNewlines:\n    P->IncludeNewlines = Value;\n    return;\n  case CXPrintingPolicy_MSVCFormatting:\n    P->MSVCFormatting = Value;\n    return;\n  case CXPrintingPolicy_ConstantsAsWritten:\n    P->ConstantsAsWritten = Value;\n    return;\n  case CXPrintingPolicy_SuppressImplicitBase:\n    P->SuppressImplicitBase = Value;\n    return;\n  case CXPrintingPolicy_FullyQualifiedName:\n    P->FullyQualifiedName = Value;\n    return;\n  }\n\n  assert(false && \"Invalid CXPrintingPolicyProperty\");\n}\n\nCXString clang_getCursorPrettyPrinted(CXCursor C, CXPrintingPolicy cxPolicy) {\n  if (clang_Cursor_isNull(C))\n    return cxstring::createEmpty();\n\n  if (clang_isDeclaration(C.kind)) {\n    const Decl *D = getCursorDecl(C);\n    if (!D)\n      return cxstring::createEmpty();\n\n    SmallString<128> Str;\n    llvm::raw_svector_ostream OS(Str);\n    PrintingPolicy *UserPolicy = static_cast<PrintingPolicy *>(cxPolicy);\n    D->print(OS, UserPolicy ? *UserPolicy\n                            : getCursorContext(C).getPrintingPolicy());\n\n    return cxstring::createDup(OS.str());\n  }\n\n  return cxstring::createEmpty();\n}\n\nCXString clang_getCursorDisplayName(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return clang_getCursorSpelling(C);\n\n  const Decl *D = getCursorDecl(C);\n  if (!D)\n    return cxstring::createEmpty();\n\n  PrintingPolicy Policy = getCursorContext(C).getPrintingPolicy();\n  if (const FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(D))\n    D = FunTmpl->getTemplatedDecl();\n\n  if (const FunctionDecl *Function = dyn_cast<FunctionDecl>(D)) {\n    SmallString<64> Str;\n    llvm::raw_svector_ostream OS(Str);\n    OS << *Function;\n    if (Function->getPrimaryTemplate())\n      OS << \"<>\";\n    OS << \"(\";\n    for (unsigned I = 0, N = Function->getNumParams(); I != N; ++I) {\n      if (I)\n        OS << \", \";\n      OS << Function->getParamDecl(I)->getType().getAsString(Policy);\n    }\n\n    if (Function->isVariadic()) {\n      if (Function->getNumParams())\n        OS << \", \";\n      OS << \"...\";\n    }\n    OS << \")\";\n    return cxstring::createDup(OS.str());\n  }\n\n  if (const ClassTemplateDecl *ClassTemplate = dyn_cast<ClassTemplateDecl>(D)) {\n    SmallString<64> Str;\n    llvm::raw_svector_ostream OS(Str);\n    OS << *ClassTemplate;\n    OS << \"<\";\n    TemplateParameterList *Params = ClassTemplate->getTemplateParameters();\n    for (unsigned I = 0, N = Params->size(); I != N; ++I) {\n      if (I)\n        OS << \", \";\n\n      NamedDecl *Param = Params->getParam(I);\n      if (Param->getIdentifier()) {\n        OS << Param->getIdentifier()->getName();\n        continue;\n      }\n\n      // There is no parameter name, which makes this tricky. Try to come up\n      // with something useful that isn't too long.\n      if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(Param))\n        if (const auto *TC = TTP->getTypeConstraint()) {\n          TC->getConceptNameInfo().printName(OS, Policy);\n          if (TC->hasExplicitTemplateArgs())\n            OS << \"<...>\";\n        } else\n          OS << (TTP->wasDeclaredWithTypename() ? \"typename\" : \"class\");\n      else if (NonTypeTemplateParmDecl *NTTP =\n                   dyn_cast<NonTypeTemplateParmDecl>(Param))\n        OS << NTTP->getType().getAsString(Policy);\n      else\n        OS << \"template<...> class\";\n    }\n\n    OS << \">\";\n    return cxstring::createDup(OS.str());\n  }\n\n  if (const ClassTemplateSpecializationDecl *ClassSpec =\n          dyn_cast<ClassTemplateSpecializationDecl>(D)) {\n    // If the type was explicitly written, use that.\n    if (TypeSourceInfo *TSInfo = ClassSpec->getTypeAsWritten())\n      return cxstring::createDup(TSInfo->getType().getAsString(Policy));\n\n    SmallString<128> Str;\n    llvm::raw_svector_ostream OS(Str);\n    OS << *ClassSpec;\n    printTemplateArgumentList(OS, ClassSpec->getTemplateArgs().asArray(),\n                              Policy);\n    return cxstring::createDup(OS.str());\n  }\n\n  return clang_getCursorSpelling(C);\n}\n\nCXString clang_getCursorKindSpelling(enum CXCursorKind Kind) {\n  switch (Kind) {\n  case CXCursor_FunctionDecl:\n    return cxstring::createRef(\"FunctionDecl\");\n  case CXCursor_TypedefDecl:\n    return cxstring::createRef(\"TypedefDecl\");\n  case CXCursor_EnumDecl:\n    return cxstring::createRef(\"EnumDecl\");\n  case CXCursor_EnumConstantDecl:\n    return cxstring::createRef(\"EnumConstantDecl\");\n  case CXCursor_StructDecl:\n    return cxstring::createRef(\"StructDecl\");\n  case CXCursor_UnionDecl:\n    return cxstring::createRef(\"UnionDecl\");\n  case CXCursor_ClassDecl:\n    return cxstring::createRef(\"ClassDecl\");\n  case CXCursor_FieldDecl:\n    return cxstring::createRef(\"FieldDecl\");\n  case CXCursor_VarDecl:\n    return cxstring::createRef(\"VarDecl\");\n  case CXCursor_ParmDecl:\n    return cxstring::createRef(\"ParmDecl\");\n  case CXCursor_ObjCInterfaceDecl:\n    return cxstring::createRef(\"ObjCInterfaceDecl\");\n  case CXCursor_ObjCCategoryDecl:\n    return cxstring::createRef(\"ObjCCategoryDecl\");\n  case CXCursor_ObjCProtocolDecl:\n    return cxstring::createRef(\"ObjCProtocolDecl\");\n  case CXCursor_ObjCPropertyDecl:\n    return cxstring::createRef(\"ObjCPropertyDecl\");\n  case CXCursor_ObjCIvarDecl:\n    return cxstring::createRef(\"ObjCIvarDecl\");\n  case CXCursor_ObjCInstanceMethodDecl:\n    return cxstring::createRef(\"ObjCInstanceMethodDecl\");\n  case CXCursor_ObjCClassMethodDecl:\n    return cxstring::createRef(\"ObjCClassMethodDecl\");\n  case CXCursor_ObjCImplementationDecl:\n    return cxstring::createRef(\"ObjCImplementationDecl\");\n  case CXCursor_ObjCCategoryImplDecl:\n    return cxstring::createRef(\"ObjCCategoryImplDecl\");\n  case CXCursor_CXXMethod:\n    return cxstring::createRef(\"CXXMethod\");\n  case CXCursor_UnexposedDecl:\n    return cxstring::createRef(\"UnexposedDecl\");\n  case CXCursor_ObjCSuperClassRef:\n    return cxstring::createRef(\"ObjCSuperClassRef\");\n  case CXCursor_ObjCProtocolRef:\n    return cxstring::createRef(\"ObjCProtocolRef\");\n  case CXCursor_ObjCClassRef:\n    return cxstring::createRef(\"ObjCClassRef\");\n  case CXCursor_TypeRef:\n    return cxstring::createRef(\"TypeRef\");\n  case CXCursor_TemplateRef:\n    return cxstring::createRef(\"TemplateRef\");\n  case CXCursor_NamespaceRef:\n    return cxstring::createRef(\"NamespaceRef\");\n  case CXCursor_MemberRef:\n    return cxstring::createRef(\"MemberRef\");\n  case CXCursor_LabelRef:\n    return cxstring::createRef(\"LabelRef\");\n  case CXCursor_OverloadedDeclRef:\n    return cxstring::createRef(\"OverloadedDeclRef\");\n  case CXCursor_VariableRef:\n    return cxstring::createRef(\"VariableRef\");\n  case CXCursor_IntegerLiteral:\n    return cxstring::createRef(\"IntegerLiteral\");\n  case CXCursor_FixedPointLiteral:\n    return cxstring::createRef(\"FixedPointLiteral\");\n  case CXCursor_FloatingLiteral:\n    return cxstring::createRef(\"FloatingLiteral\");\n  case CXCursor_ImaginaryLiteral:\n    return cxstring::createRef(\"ImaginaryLiteral\");\n  case CXCursor_StringLiteral:\n    return cxstring::createRef(\"StringLiteral\");\n  case CXCursor_CharacterLiteral:\n    return cxstring::createRef(\"CharacterLiteral\");\n  case CXCursor_ParenExpr:\n    return cxstring::createRef(\"ParenExpr\");\n  case CXCursor_UnaryOperator:\n    return cxstring::createRef(\"UnaryOperator\");\n  case CXCursor_ArraySubscriptExpr:\n    return cxstring::createRef(\"ArraySubscriptExpr\");\n  case CXCursor_OMPArraySectionExpr:\n    return cxstring::createRef(\"OMPArraySectionExpr\");\n  case CXCursor_OMPArrayShapingExpr:\n    return cxstring::createRef(\"OMPArrayShapingExpr\");\n  case CXCursor_OMPIteratorExpr:\n    return cxstring::createRef(\"OMPIteratorExpr\");\n  case CXCursor_BinaryOperator:\n    return cxstring::createRef(\"BinaryOperator\");\n  case CXCursor_CompoundAssignOperator:\n    return cxstring::createRef(\"CompoundAssignOperator\");\n  case CXCursor_ConditionalOperator:\n    return cxstring::createRef(\"ConditionalOperator\");\n  case CXCursor_CStyleCastExpr:\n    return cxstring::createRef(\"CStyleCastExpr\");\n  case CXCursor_CompoundLiteralExpr:\n    return cxstring::createRef(\"CompoundLiteralExpr\");\n  case CXCursor_InitListExpr:\n    return cxstring::createRef(\"InitListExpr\");\n  case CXCursor_AddrLabelExpr:\n    return cxstring::createRef(\"AddrLabelExpr\");\n  case CXCursor_StmtExpr:\n    return cxstring::createRef(\"StmtExpr\");\n  case CXCursor_GenericSelectionExpr:\n    return cxstring::createRef(\"GenericSelectionExpr\");\n  case CXCursor_GNUNullExpr:\n    return cxstring::createRef(\"GNUNullExpr\");\n  case CXCursor_CXXStaticCastExpr:\n    return cxstring::createRef(\"CXXStaticCastExpr\");\n  case CXCursor_CXXDynamicCastExpr:\n    return cxstring::createRef(\"CXXDynamicCastExpr\");\n  case CXCursor_CXXReinterpretCastExpr:\n    return cxstring::createRef(\"CXXReinterpretCastExpr\");\n  case CXCursor_CXXConstCastExpr:\n    return cxstring::createRef(\"CXXConstCastExpr\");\n  case CXCursor_CXXFunctionalCastExpr:\n    return cxstring::createRef(\"CXXFunctionalCastExpr\");\n  case CXCursor_CXXAddrspaceCastExpr:\n    return cxstring::createRef(\"CXXAddrspaceCastExpr\");\n  case CXCursor_CXXTypeidExpr:\n    return cxstring::createRef(\"CXXTypeidExpr\");\n  case CXCursor_CXXBoolLiteralExpr:\n    return cxstring::createRef(\"CXXBoolLiteralExpr\");\n  case CXCursor_CXXNullPtrLiteralExpr:\n    return cxstring::createRef(\"CXXNullPtrLiteralExpr\");\n  case CXCursor_CXXThisExpr:\n    return cxstring::createRef(\"CXXThisExpr\");\n  case CXCursor_CXXThrowExpr:\n    return cxstring::createRef(\"CXXThrowExpr\");\n  case CXCursor_CXXNewExpr:\n    return cxstring::createRef(\"CXXNewExpr\");\n  case CXCursor_CXXDeleteExpr:\n    return cxstring::createRef(\"CXXDeleteExpr\");\n  case CXCursor_UnaryExpr:\n    return cxstring::createRef(\"UnaryExpr\");\n  case CXCursor_ObjCStringLiteral:\n    return cxstring::createRef(\"ObjCStringLiteral\");\n  case CXCursor_ObjCBoolLiteralExpr:\n    return cxstring::createRef(\"ObjCBoolLiteralExpr\");\n  case CXCursor_ObjCAvailabilityCheckExpr:\n    return cxstring::createRef(\"ObjCAvailabilityCheckExpr\");\n  case CXCursor_ObjCSelfExpr:\n    return cxstring::createRef(\"ObjCSelfExpr\");\n  case CXCursor_ObjCEncodeExpr:\n    return cxstring::createRef(\"ObjCEncodeExpr\");\n  case CXCursor_ObjCSelectorExpr:\n    return cxstring::createRef(\"ObjCSelectorExpr\");\n  case CXCursor_ObjCProtocolExpr:\n    return cxstring::createRef(\"ObjCProtocolExpr\");\n  case CXCursor_ObjCBridgedCastExpr:\n    return cxstring::createRef(\"ObjCBridgedCastExpr\");\n  case CXCursor_BlockExpr:\n    return cxstring::createRef(\"BlockExpr\");\n  case CXCursor_PackExpansionExpr:\n    return cxstring::createRef(\"PackExpansionExpr\");\n  case CXCursor_SizeOfPackExpr:\n    return cxstring::createRef(\"SizeOfPackExpr\");\n  case CXCursor_LambdaExpr:\n    return cxstring::createRef(\"LambdaExpr\");\n  case CXCursor_UnexposedExpr:\n    return cxstring::createRef(\"UnexposedExpr\");\n  case CXCursor_DeclRefExpr:\n    return cxstring::createRef(\"DeclRefExpr\");\n  case CXCursor_MemberRefExpr:\n    return cxstring::createRef(\"MemberRefExpr\");\n  case CXCursor_CallExpr:\n    return cxstring::createRef(\"CallExpr\");\n  case CXCursor_ObjCMessageExpr:\n    return cxstring::createRef(\"ObjCMessageExpr\");\n  case CXCursor_BuiltinBitCastExpr:\n    return cxstring::createRef(\"BuiltinBitCastExpr\");\n  case CXCursor_UnexposedStmt:\n    return cxstring::createRef(\"UnexposedStmt\");\n  case CXCursor_DeclStmt:\n    return cxstring::createRef(\"DeclStmt\");\n  case CXCursor_LabelStmt:\n    return cxstring::createRef(\"LabelStmt\");\n  case CXCursor_CompoundStmt:\n    return cxstring::createRef(\"CompoundStmt\");\n  case CXCursor_CaseStmt:\n    return cxstring::createRef(\"CaseStmt\");\n  case CXCursor_DefaultStmt:\n    return cxstring::createRef(\"DefaultStmt\");\n  case CXCursor_IfStmt:\n    return cxstring::createRef(\"IfStmt\");\n  case CXCursor_SwitchStmt:\n    return cxstring::createRef(\"SwitchStmt\");\n  case CXCursor_WhileStmt:\n    return cxstring::createRef(\"WhileStmt\");\n  case CXCursor_DoStmt:\n    return cxstring::createRef(\"DoStmt\");\n  case CXCursor_ForStmt:\n    return cxstring::createRef(\"ForStmt\");\n  case CXCursor_GotoStmt:\n    return cxstring::createRef(\"GotoStmt\");\n  case CXCursor_IndirectGotoStmt:\n    return cxstring::createRef(\"IndirectGotoStmt\");\n  case CXCursor_ContinueStmt:\n    return cxstring::createRef(\"ContinueStmt\");\n  case CXCursor_BreakStmt:\n    return cxstring::createRef(\"BreakStmt\");\n  case CXCursor_ReturnStmt:\n    return cxstring::createRef(\"ReturnStmt\");\n  case CXCursor_GCCAsmStmt:\n    return cxstring::createRef(\"GCCAsmStmt\");\n  case CXCursor_MSAsmStmt:\n    return cxstring::createRef(\"MSAsmStmt\");\n  case CXCursor_ObjCAtTryStmt:\n    return cxstring::createRef(\"ObjCAtTryStmt\");\n  case CXCursor_ObjCAtCatchStmt:\n    return cxstring::createRef(\"ObjCAtCatchStmt\");\n  case CXCursor_ObjCAtFinallyStmt:\n    return cxstring::createRef(\"ObjCAtFinallyStmt\");\n  case CXCursor_ObjCAtThrowStmt:\n    return cxstring::createRef(\"ObjCAtThrowStmt\");\n  case CXCursor_ObjCAtSynchronizedStmt:\n    return cxstring::createRef(\"ObjCAtSynchronizedStmt\");\n  case CXCursor_ObjCAutoreleasePoolStmt:\n    return cxstring::createRef(\"ObjCAutoreleasePoolStmt\");\n  case CXCursor_ObjCForCollectionStmt:\n    return cxstring::createRef(\"ObjCForCollectionStmt\");\n  case CXCursor_CXXCatchStmt:\n    return cxstring::createRef(\"CXXCatchStmt\");\n  case CXCursor_CXXTryStmt:\n    return cxstring::createRef(\"CXXTryStmt\");\n  case CXCursor_CXXForRangeStmt:\n    return cxstring::createRef(\"CXXForRangeStmt\");\n  case CXCursor_SEHTryStmt:\n    return cxstring::createRef(\"SEHTryStmt\");\n  case CXCursor_SEHExceptStmt:\n    return cxstring::createRef(\"SEHExceptStmt\");\n  case CXCursor_SEHFinallyStmt:\n    return cxstring::createRef(\"SEHFinallyStmt\");\n  case CXCursor_SEHLeaveStmt:\n    return cxstring::createRef(\"SEHLeaveStmt\");\n  case CXCursor_NullStmt:\n    return cxstring::createRef(\"NullStmt\");\n  case CXCursor_InvalidFile:\n    return cxstring::createRef(\"InvalidFile\");\n  case CXCursor_InvalidCode:\n    return cxstring::createRef(\"InvalidCode\");\n  case CXCursor_NoDeclFound:\n    return cxstring::createRef(\"NoDeclFound\");\n  case CXCursor_NotImplemented:\n    return cxstring::createRef(\"NotImplemented\");\n  case CXCursor_TranslationUnit:\n    return cxstring::createRef(\"TranslationUnit\");\n  case CXCursor_UnexposedAttr:\n    return cxstring::createRef(\"UnexposedAttr\");\n  case CXCursor_IBActionAttr:\n    return cxstring::createRef(\"attribute(ibaction)\");\n  case CXCursor_IBOutletAttr:\n    return cxstring::createRef(\"attribute(iboutlet)\");\n  case CXCursor_IBOutletCollectionAttr:\n    return cxstring::createRef(\"attribute(iboutletcollection)\");\n  case CXCursor_CXXFinalAttr:\n    return cxstring::createRef(\"attribute(final)\");\n  case CXCursor_CXXOverrideAttr:\n    return cxstring::createRef(\"attribute(override)\");\n  case CXCursor_AnnotateAttr:\n    return cxstring::createRef(\"attribute(annotate)\");\n  case CXCursor_AsmLabelAttr:\n    return cxstring::createRef(\"asm label\");\n  case CXCursor_PackedAttr:\n    return cxstring::createRef(\"attribute(packed)\");\n  case CXCursor_PureAttr:\n    return cxstring::createRef(\"attribute(pure)\");\n  case CXCursor_ConstAttr:\n    return cxstring::createRef(\"attribute(const)\");\n  case CXCursor_NoDuplicateAttr:\n    return cxstring::createRef(\"attribute(noduplicate)\");\n  case CXCursor_CUDAConstantAttr:\n    return cxstring::createRef(\"attribute(constant)\");\n  case CXCursor_CUDADeviceAttr:\n    return cxstring::createRef(\"attribute(device)\");\n  case CXCursor_CUDAGlobalAttr:\n    return cxstring::createRef(\"attribute(global)\");\n  case CXCursor_CUDAHostAttr:\n    return cxstring::createRef(\"attribute(host)\");\n  case CXCursor_CUDASharedAttr:\n    return cxstring::createRef(\"attribute(shared)\");\n  case CXCursor_VisibilityAttr:\n    return cxstring::createRef(\"attribute(visibility)\");\n  case CXCursor_DLLExport:\n    return cxstring::createRef(\"attribute(dllexport)\");\n  case CXCursor_DLLImport:\n    return cxstring::createRef(\"attribute(dllimport)\");\n  case CXCursor_NSReturnsRetained:\n    return cxstring::createRef(\"attribute(ns_returns_retained)\");\n  case CXCursor_NSReturnsNotRetained:\n    return cxstring::createRef(\"attribute(ns_returns_not_retained)\");\n  case CXCursor_NSReturnsAutoreleased:\n    return cxstring::createRef(\"attribute(ns_returns_autoreleased)\");\n  case CXCursor_NSConsumesSelf:\n    return cxstring::createRef(\"attribute(ns_consumes_self)\");\n  case CXCursor_NSConsumed:\n    return cxstring::createRef(\"attribute(ns_consumed)\");\n  case CXCursor_ObjCException:\n    return cxstring::createRef(\"attribute(objc_exception)\");\n  case CXCursor_ObjCNSObject:\n    return cxstring::createRef(\"attribute(NSObject)\");\n  case CXCursor_ObjCIndependentClass:\n    return cxstring::createRef(\"attribute(objc_independent_class)\");\n  case CXCursor_ObjCPreciseLifetime:\n    return cxstring::createRef(\"attribute(objc_precise_lifetime)\");\n  case CXCursor_ObjCReturnsInnerPointer:\n    return cxstring::createRef(\"attribute(objc_returns_inner_pointer)\");\n  case CXCursor_ObjCRequiresSuper:\n    return cxstring::createRef(\"attribute(objc_requires_super)\");\n  case CXCursor_ObjCRootClass:\n    return cxstring::createRef(\"attribute(objc_root_class)\");\n  case CXCursor_ObjCSubclassingRestricted:\n    return cxstring::createRef(\"attribute(objc_subclassing_restricted)\");\n  case CXCursor_ObjCExplicitProtocolImpl:\n    return cxstring::createRef(\n        \"attribute(objc_protocol_requires_explicit_implementation)\");\n  case CXCursor_ObjCDesignatedInitializer:\n    return cxstring::createRef(\"attribute(objc_designated_initializer)\");\n  case CXCursor_ObjCRuntimeVisible:\n    return cxstring::createRef(\"attribute(objc_runtime_visible)\");\n  case CXCursor_ObjCBoxable:\n    return cxstring::createRef(\"attribute(objc_boxable)\");\n  case CXCursor_FlagEnum:\n    return cxstring::createRef(\"attribute(flag_enum)\");\n  case CXCursor_PreprocessingDirective:\n    return cxstring::createRef(\"preprocessing directive\");\n  case CXCursor_MacroDefinition:\n    return cxstring::createRef(\"macro definition\");\n  case CXCursor_MacroExpansion:\n    return cxstring::createRef(\"macro expansion\");\n  case CXCursor_InclusionDirective:\n    return cxstring::createRef(\"inclusion directive\");\n  case CXCursor_Namespace:\n    return cxstring::createRef(\"Namespace\");\n  case CXCursor_LinkageSpec:\n    return cxstring::createRef(\"LinkageSpec\");\n  case CXCursor_CXXBaseSpecifier:\n    return cxstring::createRef(\"C++ base class specifier\");\n  case CXCursor_Constructor:\n    return cxstring::createRef(\"CXXConstructor\");\n  case CXCursor_Destructor:\n    return cxstring::createRef(\"CXXDestructor\");\n  case CXCursor_ConversionFunction:\n    return cxstring::createRef(\"CXXConversion\");\n  case CXCursor_TemplateTypeParameter:\n    return cxstring::createRef(\"TemplateTypeParameter\");\n  case CXCursor_NonTypeTemplateParameter:\n    return cxstring::createRef(\"NonTypeTemplateParameter\");\n  case CXCursor_TemplateTemplateParameter:\n    return cxstring::createRef(\"TemplateTemplateParameter\");\n  case CXCursor_FunctionTemplate:\n    return cxstring::createRef(\"FunctionTemplate\");\n  case CXCursor_ClassTemplate:\n    return cxstring::createRef(\"ClassTemplate\");\n  case CXCursor_ClassTemplatePartialSpecialization:\n    return cxstring::createRef(\"ClassTemplatePartialSpecialization\");\n  case CXCursor_NamespaceAlias:\n    return cxstring::createRef(\"NamespaceAlias\");\n  case CXCursor_UsingDirective:\n    return cxstring::createRef(\"UsingDirective\");\n  case CXCursor_UsingDeclaration:\n    return cxstring::createRef(\"UsingDeclaration\");\n  case CXCursor_TypeAliasDecl:\n    return cxstring::createRef(\"TypeAliasDecl\");\n  case CXCursor_ObjCSynthesizeDecl:\n    return cxstring::createRef(\"ObjCSynthesizeDecl\");\n  case CXCursor_ObjCDynamicDecl:\n    return cxstring::createRef(\"ObjCDynamicDecl\");\n  case CXCursor_CXXAccessSpecifier:\n    return cxstring::createRef(\"CXXAccessSpecifier\");\n  case CXCursor_ModuleImportDecl:\n    return cxstring::createRef(\"ModuleImport\");\n  case CXCursor_OMPParallelDirective:\n    return cxstring::createRef(\"OMPParallelDirective\");\n  case CXCursor_OMPSimdDirective:\n    return cxstring::createRef(\"OMPSimdDirective\");\n  case CXCursor_OMPTileDirective:\n    return cxstring::createRef(\"OMPTileDirective\");\n  case CXCursor_OMPForDirective:\n    return cxstring::createRef(\"OMPForDirective\");\n  case CXCursor_OMPForSimdDirective:\n    return cxstring::createRef(\"OMPForSimdDirective\");\n  case CXCursor_OMPSectionsDirective:\n    return cxstring::createRef(\"OMPSectionsDirective\");\n  case CXCursor_OMPSectionDirective:\n    return cxstring::createRef(\"OMPSectionDirective\");\n  case CXCursor_OMPSingleDirective:\n    return cxstring::createRef(\"OMPSingleDirective\");\n  case CXCursor_OMPMasterDirective:\n    return cxstring::createRef(\"OMPMasterDirective\");\n  case CXCursor_OMPCriticalDirective:\n    return cxstring::createRef(\"OMPCriticalDirective\");\n  case CXCursor_OMPParallelForDirective:\n    return cxstring::createRef(\"OMPParallelForDirective\");\n  case CXCursor_OMPParallelForSimdDirective:\n    return cxstring::createRef(\"OMPParallelForSimdDirective\");\n  case CXCursor_OMPParallelMasterDirective:\n    return cxstring::createRef(\"OMPParallelMasterDirective\");\n  case CXCursor_OMPParallelSectionsDirective:\n    return cxstring::createRef(\"OMPParallelSectionsDirective\");\n  case CXCursor_OMPTaskDirective:\n    return cxstring::createRef(\"OMPTaskDirective\");\n  case CXCursor_OMPTaskyieldDirective:\n    return cxstring::createRef(\"OMPTaskyieldDirective\");\n  case CXCursor_OMPBarrierDirective:\n    return cxstring::createRef(\"OMPBarrierDirective\");\n  case CXCursor_OMPTaskwaitDirective:\n    return cxstring::createRef(\"OMPTaskwaitDirective\");\n  case CXCursor_OMPTaskgroupDirective:\n    return cxstring::createRef(\"OMPTaskgroupDirective\");\n  case CXCursor_OMPFlushDirective:\n    return cxstring::createRef(\"OMPFlushDirective\");\n  case CXCursor_OMPDepobjDirective:\n    return cxstring::createRef(\"OMPDepobjDirective\");\n  case CXCursor_OMPScanDirective:\n    return cxstring::createRef(\"OMPScanDirective\");\n  case CXCursor_OMPOrderedDirective:\n    return cxstring::createRef(\"OMPOrderedDirective\");\n  case CXCursor_OMPAtomicDirective:\n    return cxstring::createRef(\"OMPAtomicDirective\");\n  case CXCursor_OMPTargetDirective:\n    return cxstring::createRef(\"OMPTargetDirective\");\n  case CXCursor_OMPTargetDataDirective:\n    return cxstring::createRef(\"OMPTargetDataDirective\");\n  case CXCursor_OMPTargetEnterDataDirective:\n    return cxstring::createRef(\"OMPTargetEnterDataDirective\");\n  case CXCursor_OMPTargetExitDataDirective:\n    return cxstring::createRef(\"OMPTargetExitDataDirective\");\n  case CXCursor_OMPTargetParallelDirective:\n    return cxstring::createRef(\"OMPTargetParallelDirective\");\n  case CXCursor_OMPTargetParallelForDirective:\n    return cxstring::createRef(\"OMPTargetParallelForDirective\");\n  case CXCursor_OMPTargetUpdateDirective:\n    return cxstring::createRef(\"OMPTargetUpdateDirective\");\n  case CXCursor_OMPTeamsDirective:\n    return cxstring::createRef(\"OMPTeamsDirective\");\n  case CXCursor_OMPCancellationPointDirective:\n    return cxstring::createRef(\"OMPCancellationPointDirective\");\n  case CXCursor_OMPCancelDirective:\n    return cxstring::createRef(\"OMPCancelDirective\");\n  case CXCursor_OMPTaskLoopDirective:\n    return cxstring::createRef(\"OMPTaskLoopDirective\");\n  case CXCursor_OMPTaskLoopSimdDirective:\n    return cxstring::createRef(\"OMPTaskLoopSimdDirective\");\n  case CXCursor_OMPMasterTaskLoopDirective:\n    return cxstring::createRef(\"OMPMasterTaskLoopDirective\");\n  case CXCursor_OMPMasterTaskLoopSimdDirective:\n    return cxstring::createRef(\"OMPMasterTaskLoopSimdDirective\");\n  case CXCursor_OMPParallelMasterTaskLoopDirective:\n    return cxstring::createRef(\"OMPParallelMasterTaskLoopDirective\");\n  case CXCursor_OMPParallelMasterTaskLoopSimdDirective:\n    return cxstring::createRef(\"OMPParallelMasterTaskLoopSimdDirective\");\n  case CXCursor_OMPDistributeDirective:\n    return cxstring::createRef(\"OMPDistributeDirective\");\n  case CXCursor_OMPDistributeParallelForDirective:\n    return cxstring::createRef(\"OMPDistributeParallelForDirective\");\n  case CXCursor_OMPDistributeParallelForSimdDirective:\n    return cxstring::createRef(\"OMPDistributeParallelForSimdDirective\");\n  case CXCursor_OMPDistributeSimdDirective:\n    return cxstring::createRef(\"OMPDistributeSimdDirective\");\n  case CXCursor_OMPTargetParallelForSimdDirective:\n    return cxstring::createRef(\"OMPTargetParallelForSimdDirective\");\n  case CXCursor_OMPTargetSimdDirective:\n    return cxstring::createRef(\"OMPTargetSimdDirective\");\n  case CXCursor_OMPTeamsDistributeDirective:\n    return cxstring::createRef(\"OMPTeamsDistributeDirective\");\n  case CXCursor_OMPTeamsDistributeSimdDirective:\n    return cxstring::createRef(\"OMPTeamsDistributeSimdDirective\");\n  case CXCursor_OMPTeamsDistributeParallelForSimdDirective:\n    return cxstring::createRef(\"OMPTeamsDistributeParallelForSimdDirective\");\n  case CXCursor_OMPTeamsDistributeParallelForDirective:\n    return cxstring::createRef(\"OMPTeamsDistributeParallelForDirective\");\n  case CXCursor_OMPTargetTeamsDirective:\n    return cxstring::createRef(\"OMPTargetTeamsDirective\");\n  case CXCursor_OMPTargetTeamsDistributeDirective:\n    return cxstring::createRef(\"OMPTargetTeamsDistributeDirective\");\n  case CXCursor_OMPTargetTeamsDistributeParallelForDirective:\n    return cxstring::createRef(\"OMPTargetTeamsDistributeParallelForDirective\");\n  case CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective:\n    return cxstring::createRef(\n        \"OMPTargetTeamsDistributeParallelForSimdDirective\");\n  case CXCursor_OMPTargetTeamsDistributeSimdDirective:\n    return cxstring::createRef(\"OMPTargetTeamsDistributeSimdDirective\");\n  case CXCursor_OverloadCandidate:\n    return cxstring::createRef(\"OverloadCandidate\");\n  case CXCursor_TypeAliasTemplateDecl:\n    return cxstring::createRef(\"TypeAliasTemplateDecl\");\n  case CXCursor_StaticAssert:\n    return cxstring::createRef(\"StaticAssert\");\n  case CXCursor_FriendDecl:\n    return cxstring::createRef(\"FriendDecl\");\n  case CXCursor_ConvergentAttr:\n    return cxstring::createRef(\"attribute(convergent)\");\n  case CXCursor_WarnUnusedAttr:\n    return cxstring::createRef(\"attribute(warn_unused)\");\n  case CXCursor_WarnUnusedResultAttr:\n    return cxstring::createRef(\"attribute(warn_unused_result)\");\n  case CXCursor_AlignedAttr:\n    return cxstring::createRef(\"attribute(aligned)\");\n  }\n\n  llvm_unreachable(\"Unhandled CXCursorKind\");\n}\n\nstruct GetCursorData {\n  SourceLocation TokenBeginLoc;\n  bool PointsAtMacroArgExpansion;\n  bool VisitedObjCPropertyImplDecl;\n  SourceLocation VisitedDeclaratorDeclStartLoc;\n  CXCursor &BestCursor;\n\n  GetCursorData(SourceManager &SM, SourceLocation tokenBegin,\n                CXCursor &outputCursor)\n      : TokenBeginLoc(tokenBegin), BestCursor(outputCursor) {\n    PointsAtMacroArgExpansion = SM.isMacroArgExpansion(tokenBegin);\n    VisitedObjCPropertyImplDecl = false;\n  }\n};\n\nstatic enum CXChildVisitResult\nGetCursorVisitor(CXCursor cursor, CXCursor parent, CXClientData client_data) {\n  GetCursorData *Data = static_cast<GetCursorData *>(client_data);\n  CXCursor *BestCursor = &Data->BestCursor;\n\n  // If we point inside a macro argument we should provide info of what the\n  // token is so use the actual cursor, don't replace it with a macro expansion\n  // cursor.\n  if (cursor.kind == CXCursor_MacroExpansion && Data->PointsAtMacroArgExpansion)\n    return CXChildVisit_Recurse;\n\n  if (clang_isDeclaration(cursor.kind)) {\n    // Avoid having the implicit methods override the property decls.\n    if (const ObjCMethodDecl *MD =\n            dyn_cast_or_null<ObjCMethodDecl>(getCursorDecl(cursor))) {\n      if (MD->isImplicit())\n        return CXChildVisit_Break;\n\n    } else if (const ObjCInterfaceDecl *ID =\n                   dyn_cast_or_null<ObjCInterfaceDecl>(getCursorDecl(cursor))) {\n      // Check that when we have multiple @class references in the same line,\n      // that later ones do not override the previous ones.\n      // If we have:\n      // @class Foo, Bar;\n      // source ranges for both start at '@', so 'Bar' will end up overriding\n      // 'Foo' even though the cursor location was at 'Foo'.\n      if (BestCursor->kind == CXCursor_ObjCInterfaceDecl ||\n          BestCursor->kind == CXCursor_ObjCClassRef)\n        if (const ObjCInterfaceDecl *PrevID =\n                dyn_cast_or_null<ObjCInterfaceDecl>(\n                    getCursorDecl(*BestCursor))) {\n          if (PrevID != ID && !PrevID->isThisDeclarationADefinition() &&\n              !ID->isThisDeclarationADefinition())\n            return CXChildVisit_Break;\n        }\n\n    } else if (const DeclaratorDecl *DD =\n                   dyn_cast_or_null<DeclaratorDecl>(getCursorDecl(cursor))) {\n      SourceLocation StartLoc = DD->getSourceRange().getBegin();\n      // Check that when we have multiple declarators in the same line,\n      // that later ones do not override the previous ones.\n      // If we have:\n      // int Foo, Bar;\n      // source ranges for both start at 'int', so 'Bar' will end up overriding\n      // 'Foo' even though the cursor location was at 'Foo'.\n      if (Data->VisitedDeclaratorDeclStartLoc == StartLoc)\n        return CXChildVisit_Break;\n      Data->VisitedDeclaratorDeclStartLoc = StartLoc;\n\n    } else if (const ObjCPropertyImplDecl *PropImp =\n                   dyn_cast_or_null<ObjCPropertyImplDecl>(\n                       getCursorDecl(cursor))) {\n      (void)PropImp;\n      // Check that when we have multiple @synthesize in the same line,\n      // that later ones do not override the previous ones.\n      // If we have:\n      // @synthesize Foo, Bar;\n      // source ranges for both start at '@', so 'Bar' will end up overriding\n      // 'Foo' even though the cursor location was at 'Foo'.\n      if (Data->VisitedObjCPropertyImplDecl)\n        return CXChildVisit_Break;\n      Data->VisitedObjCPropertyImplDecl = true;\n    }\n  }\n\n  if (clang_isExpression(cursor.kind) &&\n      clang_isDeclaration(BestCursor->kind)) {\n    if (const Decl *D = getCursorDecl(*BestCursor)) {\n      // Avoid having the cursor of an expression replace the declaration cursor\n      // when the expression source range overlaps the declaration range.\n      // This can happen for C++ constructor expressions whose range generally\n      // include the variable declaration, e.g.:\n      //  MyCXXClass foo; // Make sure pointing at 'foo' returns a VarDecl\n      //  cursor.\n      if (D->getLocation().isValid() && Data->TokenBeginLoc.isValid() &&\n          D->getLocation() == Data->TokenBeginLoc)\n        return CXChildVisit_Break;\n    }\n  }\n\n  // If our current best cursor is the construction of a temporary object,\n  // don't replace that cursor with a type reference, because we want\n  // clang_getCursor() to point at the constructor.\n  if (clang_isExpression(BestCursor->kind) &&\n      isa<CXXTemporaryObjectExpr>(getCursorExpr(*BestCursor)) &&\n      cursor.kind == CXCursor_TypeRef) {\n    // Keep the cursor pointing at CXXTemporaryObjectExpr but also mark it\n    // as having the actual point on the type reference.\n    *BestCursor = getTypeRefedCallExprCursor(*BestCursor);\n    return CXChildVisit_Recurse;\n  }\n\n  // If we already have an Objective-C superclass reference, don't\n  // update it further.\n  if (BestCursor->kind == CXCursor_ObjCSuperClassRef)\n    return CXChildVisit_Break;\n\n  *BestCursor = cursor;\n  return CXChildVisit_Recurse;\n}\n\nCXCursor clang_getCursor(CXTranslationUnit TU, CXSourceLocation Loc) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return clang_getNullCursor();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n\n  SourceLocation SLoc = cxloc::translateSourceLocation(Loc);\n  CXCursor Result = cxcursor::getCursor(TU, SLoc);\n\n  LOG_FUNC_SECTION {\n    CXFile SearchFile;\n    unsigned SearchLine, SearchColumn;\n    CXFile ResultFile;\n    unsigned ResultLine, ResultColumn;\n    CXString SearchFileName, ResultFileName, KindSpelling, USR;\n    const char *IsDef = clang_isCursorDefinition(Result) ? \" (Definition)\" : \"\";\n    CXSourceLocation ResultLoc = clang_getCursorLocation(Result);\n\n    clang_getFileLocation(Loc, &SearchFile, &SearchLine, &SearchColumn,\n                          nullptr);\n    clang_getFileLocation(ResultLoc, &ResultFile, &ResultLine, &ResultColumn,\n                          nullptr);\n    SearchFileName = clang_getFileName(SearchFile);\n    ResultFileName = clang_getFileName(ResultFile);\n    KindSpelling = clang_getCursorKindSpelling(Result.kind);\n    USR = clang_getCursorUSR(Result);\n    *Log << llvm::format(\"(%s:%d:%d) = %s\", clang_getCString(SearchFileName),\n                         SearchLine, SearchColumn,\n                         clang_getCString(KindSpelling))\n         << llvm::format(\"(%s:%d:%d):%s%s\", clang_getCString(ResultFileName),\n                         ResultLine, ResultColumn, clang_getCString(USR),\n                         IsDef);\n    clang_disposeString(SearchFileName);\n    clang_disposeString(ResultFileName);\n    clang_disposeString(KindSpelling);\n    clang_disposeString(USR);\n\n    CXCursor Definition = clang_getCursorDefinition(Result);\n    if (!clang_equalCursors(Definition, clang_getNullCursor())) {\n      CXSourceLocation DefinitionLoc = clang_getCursorLocation(Definition);\n      CXString DefinitionKindSpelling =\n          clang_getCursorKindSpelling(Definition.kind);\n      CXFile DefinitionFile;\n      unsigned DefinitionLine, DefinitionColumn;\n      clang_getFileLocation(DefinitionLoc, &DefinitionFile, &DefinitionLine,\n                            &DefinitionColumn, nullptr);\n      CXString DefinitionFileName = clang_getFileName(DefinitionFile);\n      *Log << llvm::format(\"  -> %s(%s:%d:%d)\",\n                           clang_getCString(DefinitionKindSpelling),\n                           clang_getCString(DefinitionFileName), DefinitionLine,\n                           DefinitionColumn);\n      clang_disposeString(DefinitionFileName);\n      clang_disposeString(DefinitionKindSpelling);\n    }\n  }\n\n  return Result;\n}\n\nCXCursor clang_getNullCursor(void) {\n  return MakeCXCursorInvalid(CXCursor_InvalidFile);\n}\n\nunsigned clang_equalCursors(CXCursor X, CXCursor Y) {\n  // Clear out the \"FirstInDeclGroup\" part in a declaration cursor, since we\n  // can't set consistently. For example, when visiting a DeclStmt we will set\n  // it but we don't set it on the result of clang_getCursorDefinition for\n  // a reference of the same declaration.\n  // FIXME: Setting \"FirstInDeclGroup\" in CXCursors is a hack that only works\n  // when visiting a DeclStmt currently, the AST should be enhanced to be able\n  // to provide that kind of info.\n  if (clang_isDeclaration(X.kind))\n    X.data[1] = nullptr;\n  if (clang_isDeclaration(Y.kind))\n    Y.data[1] = nullptr;\n\n  return X == Y;\n}\n\nunsigned clang_hashCursor(CXCursor C) {\n  unsigned Index = 0;\n  if (clang_isExpression(C.kind) || clang_isStatement(C.kind))\n    Index = 1;\n\n  return llvm::DenseMapInfo<std::pair<unsigned, const void *>>::getHashValue(\n      std::make_pair(C.kind, C.data[Index]));\n}\n\nunsigned clang_isInvalid(enum CXCursorKind K) {\n  return K >= CXCursor_FirstInvalid && K <= CXCursor_LastInvalid;\n}\n\nunsigned clang_isDeclaration(enum CXCursorKind K) {\n  return (K >= CXCursor_FirstDecl && K <= CXCursor_LastDecl) ||\n         (K >= CXCursor_FirstExtraDecl && K <= CXCursor_LastExtraDecl);\n}\n\nunsigned clang_isInvalidDeclaration(CXCursor C) {\n  if (clang_isDeclaration(C.kind)) {\n    if (const Decl *D = getCursorDecl(C))\n      return D->isInvalidDecl();\n  }\n\n  return 0;\n}\n\nunsigned clang_isReference(enum CXCursorKind K) {\n  return K >= CXCursor_FirstRef && K <= CXCursor_LastRef;\n}\n\nunsigned clang_isExpression(enum CXCursorKind K) {\n  return K >= CXCursor_FirstExpr && K <= CXCursor_LastExpr;\n}\n\nunsigned clang_isStatement(enum CXCursorKind K) {\n  return K >= CXCursor_FirstStmt && K <= CXCursor_LastStmt;\n}\n\nunsigned clang_isAttribute(enum CXCursorKind K) {\n  return K >= CXCursor_FirstAttr && K <= CXCursor_LastAttr;\n}\n\nunsigned clang_isTranslationUnit(enum CXCursorKind K) {\n  return K == CXCursor_TranslationUnit;\n}\n\nunsigned clang_isPreprocessing(enum CXCursorKind K) {\n  return K >= CXCursor_FirstPreprocessing && K <= CXCursor_LastPreprocessing;\n}\n\nunsigned clang_isUnexposed(enum CXCursorKind K) {\n  switch (K) {\n  case CXCursor_UnexposedDecl:\n  case CXCursor_UnexposedExpr:\n  case CXCursor_UnexposedStmt:\n  case CXCursor_UnexposedAttr:\n    return true;\n  default:\n    return false;\n  }\n}\n\nCXCursorKind clang_getCursorKind(CXCursor C) { return C.kind; }\n\nCXSourceLocation clang_getCursorLocation(CXCursor C) {\n  if (clang_isReference(C.kind)) {\n    switch (C.kind) {\n    case CXCursor_ObjCSuperClassRef: {\n      std::pair<const ObjCInterfaceDecl *, SourceLocation> P =\n          getCursorObjCSuperClassRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_ObjCProtocolRef: {\n      std::pair<const ObjCProtocolDecl *, SourceLocation> P =\n          getCursorObjCProtocolRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_ObjCClassRef: {\n      std::pair<const ObjCInterfaceDecl *, SourceLocation> P =\n          getCursorObjCClassRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_TypeRef: {\n      std::pair<const TypeDecl *, SourceLocation> P = getCursorTypeRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_TemplateRef: {\n      std::pair<const TemplateDecl *, SourceLocation> P =\n          getCursorTemplateRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_NamespaceRef: {\n      std::pair<const NamedDecl *, SourceLocation> P = getCursorNamespaceRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_MemberRef: {\n      std::pair<const FieldDecl *, SourceLocation> P = getCursorMemberRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_VariableRef: {\n      std::pair<const VarDecl *, SourceLocation> P = getCursorVariableRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_CXXBaseSpecifier: {\n      const CXXBaseSpecifier *BaseSpec = getCursorCXXBaseSpecifier(C);\n      if (!BaseSpec)\n        return clang_getNullLocation();\n\n      if (TypeSourceInfo *TSInfo = BaseSpec->getTypeSourceInfo())\n        return cxloc::translateSourceLocation(\n            getCursorContext(C), TSInfo->getTypeLoc().getBeginLoc());\n\n      return cxloc::translateSourceLocation(getCursorContext(C),\n                                            BaseSpec->getBeginLoc());\n    }\n\n    case CXCursor_LabelRef: {\n      std::pair<const LabelStmt *, SourceLocation> P = getCursorLabelRef(C);\n      return cxloc::translateSourceLocation(getCursorContext(C), P.second);\n    }\n\n    case CXCursor_OverloadedDeclRef:\n      return cxloc::translateSourceLocation(\n          getCursorContext(C), getCursorOverloadedDeclRef(C).second);\n\n    default:\n      // FIXME: Need a way to enumerate all non-reference cases.\n      llvm_unreachable(\"Missed a reference kind\");\n    }\n  }\n\n  if (clang_isExpression(C.kind))\n    return cxloc::translateSourceLocation(\n        getCursorContext(C), getLocationFromExpr(getCursorExpr(C)));\n\n  if (clang_isStatement(C.kind))\n    return cxloc::translateSourceLocation(getCursorContext(C),\n                                          getCursorStmt(C)->getBeginLoc());\n\n  if (C.kind == CXCursor_PreprocessingDirective) {\n    SourceLocation L = cxcursor::getCursorPreprocessingDirective(C).getBegin();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (C.kind == CXCursor_MacroExpansion) {\n    SourceLocation L =\n        cxcursor::getCursorMacroExpansion(C).getSourceRange().getBegin();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (C.kind == CXCursor_MacroDefinition) {\n    SourceLocation L = cxcursor::getCursorMacroDefinition(C)->getLocation();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (C.kind == CXCursor_InclusionDirective) {\n    SourceLocation L =\n        cxcursor::getCursorInclusionDirective(C)->getSourceRange().getBegin();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (clang_isAttribute(C.kind)) {\n    SourceLocation L = cxcursor::getCursorAttr(C)->getLocation();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (!clang_isDeclaration(C.kind))\n    return clang_getNullLocation();\n\n  const Decl *D = getCursorDecl(C);\n  if (!D)\n    return clang_getNullLocation();\n\n  SourceLocation Loc = D->getLocation();\n  // FIXME: Multiple variables declared in a single declaration\n  // currently lack the information needed to correctly determine their\n  // ranges when accounting for the type-specifier.  We use context\n  // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,\n  // and if so, whether it is the first decl.\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    if (!cxcursor::isFirstInDeclGroup(C))\n      Loc = VD->getLocation();\n  }\n\n  // For ObjC methods, give the start location of the method name.\n  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D))\n    Loc = MD->getSelectorStartLoc();\n\n  return cxloc::translateSourceLocation(getCursorContext(C), Loc);\n}\n\n} // end extern \"C\"\n\nCXCursor cxcursor::getCursor(CXTranslationUnit TU, SourceLocation SLoc) {\n  assert(TU);\n\n  // Guard against an invalid SourceLocation, or we may assert in one\n  // of the following calls.\n  if (SLoc.isInvalid())\n    return clang_getNullCursor();\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n\n  // Translate the given source location to make it point at the beginning of\n  // the token under the cursor.\n  SLoc = Lexer::GetBeginningOfToken(SLoc, CXXUnit->getSourceManager(),\n                                    CXXUnit->getASTContext().getLangOpts());\n\n  CXCursor Result = MakeCXCursorInvalid(CXCursor_NoDeclFound);\n  if (SLoc.isValid()) {\n    GetCursorData ResultData(CXXUnit->getSourceManager(), SLoc, Result);\n    CursorVisitor CursorVis(TU, GetCursorVisitor, &ResultData,\n                            /*VisitPreprocessorLast=*/true,\n                            /*VisitIncludedEntities=*/false,\n                            SourceLocation(SLoc));\n    CursorVis.visitFileRegion();\n  }\n\n  return Result;\n}\n\nstatic SourceRange getRawCursorExtent(CXCursor C) {\n  if (clang_isReference(C.kind)) {\n    switch (C.kind) {\n    case CXCursor_ObjCSuperClassRef:\n      return getCursorObjCSuperClassRef(C).second;\n\n    case CXCursor_ObjCProtocolRef:\n      return getCursorObjCProtocolRef(C).second;\n\n    case CXCursor_ObjCClassRef:\n      return getCursorObjCClassRef(C).second;\n\n    case CXCursor_TypeRef:\n      return getCursorTypeRef(C).second;\n\n    case CXCursor_TemplateRef:\n      return getCursorTemplateRef(C).second;\n\n    case CXCursor_NamespaceRef:\n      return getCursorNamespaceRef(C).second;\n\n    case CXCursor_MemberRef:\n      return getCursorMemberRef(C).second;\n\n    case CXCursor_CXXBaseSpecifier:\n      return getCursorCXXBaseSpecifier(C)->getSourceRange();\n\n    case CXCursor_LabelRef:\n      return getCursorLabelRef(C).second;\n\n    case CXCursor_OverloadedDeclRef:\n      return getCursorOverloadedDeclRef(C).second;\n\n    case CXCursor_VariableRef:\n      return getCursorVariableRef(C).second;\n\n    default:\n      // FIXME: Need a way to enumerate all non-reference cases.\n      llvm_unreachable(\"Missed a reference kind\");\n    }\n  }\n\n  if (clang_isExpression(C.kind))\n    return getCursorExpr(C)->getSourceRange();\n\n  if (clang_isStatement(C.kind))\n    return getCursorStmt(C)->getSourceRange();\n\n  if (clang_isAttribute(C.kind))\n    return getCursorAttr(C)->getRange();\n\n  if (C.kind == CXCursor_PreprocessingDirective)\n    return cxcursor::getCursorPreprocessingDirective(C);\n\n  if (C.kind == CXCursor_MacroExpansion) {\n    ASTUnit *TU = getCursorASTUnit(C);\n    SourceRange Range = cxcursor::getCursorMacroExpansion(C).getSourceRange();\n    return TU->mapRangeFromPreamble(Range);\n  }\n\n  if (C.kind == CXCursor_MacroDefinition) {\n    ASTUnit *TU = getCursorASTUnit(C);\n    SourceRange Range = cxcursor::getCursorMacroDefinition(C)->getSourceRange();\n    return TU->mapRangeFromPreamble(Range);\n  }\n\n  if (C.kind == CXCursor_InclusionDirective) {\n    ASTUnit *TU = getCursorASTUnit(C);\n    SourceRange Range =\n        cxcursor::getCursorInclusionDirective(C)->getSourceRange();\n    return TU->mapRangeFromPreamble(Range);\n  }\n\n  if (C.kind == CXCursor_TranslationUnit) {\n    ASTUnit *TU = getCursorASTUnit(C);\n    FileID MainID = TU->getSourceManager().getMainFileID();\n    SourceLocation Start = TU->getSourceManager().getLocForStartOfFile(MainID);\n    SourceLocation End = TU->getSourceManager().getLocForEndOfFile(MainID);\n    return SourceRange(Start, End);\n  }\n\n  if (clang_isDeclaration(C.kind)) {\n    const Decl *D = cxcursor::getCursorDecl(C);\n    if (!D)\n      return SourceRange();\n\n    SourceRange R = D->getSourceRange();\n    // FIXME: Multiple variables declared in a single declaration\n    // currently lack the information needed to correctly determine their\n    // ranges when accounting for the type-specifier.  We use context\n    // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,\n    // and if so, whether it is the first decl.\n    if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n      if (!cxcursor::isFirstInDeclGroup(C))\n        R.setBegin(VD->getLocation());\n    }\n    return R;\n  }\n  return SourceRange();\n}\n\n/// Retrieves the \"raw\" cursor extent, which is then extended to include\n/// the decl-specifier-seq for declarations.\nstatic SourceRange getFullCursorExtent(CXCursor C, SourceManager &SrcMgr) {\n  if (clang_isDeclaration(C.kind)) {\n    const Decl *D = cxcursor::getCursorDecl(C);\n    if (!D)\n      return SourceRange();\n\n    SourceRange R = D->getSourceRange();\n\n    // Adjust the start of the location for declarations preceded by\n    // declaration specifiers.\n    SourceLocation StartLoc;\n    if (const DeclaratorDecl *DD = dyn_cast<DeclaratorDecl>(D)) {\n      if (TypeSourceInfo *TI = DD->getTypeSourceInfo())\n        StartLoc = TI->getTypeLoc().getBeginLoc();\n    } else if (const TypedefDecl *Typedef = dyn_cast<TypedefDecl>(D)) {\n      if (TypeSourceInfo *TI = Typedef->getTypeSourceInfo())\n        StartLoc = TI->getTypeLoc().getBeginLoc();\n    }\n\n    if (StartLoc.isValid() && R.getBegin().isValid() &&\n        SrcMgr.isBeforeInTranslationUnit(StartLoc, R.getBegin()))\n      R.setBegin(StartLoc);\n\n    // FIXME: Multiple variables declared in a single declaration\n    // currently lack the information needed to correctly determine their\n    // ranges when accounting for the type-specifier.  We use context\n    // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,\n    // and if so, whether it is the first decl.\n    if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n      if (!cxcursor::isFirstInDeclGroup(C))\n        R.setBegin(VD->getLocation());\n    }\n\n    return R;\n  }\n\n  return getRawCursorExtent(C);\n}\n\nCXSourceRange clang_getCursorExtent(CXCursor C) {\n  SourceRange R = getRawCursorExtent(C);\n  if (R.isInvalid())\n    return clang_getNullRange();\n\n  return cxloc::translateSourceRange(getCursorContext(C), R);\n}\n\nCXCursor clang_getCursorReferenced(CXCursor C) {\n  if (clang_isInvalid(C.kind))\n    return clang_getNullCursor();\n\n  CXTranslationUnit tu = getCursorTU(C);\n  if (clang_isDeclaration(C.kind)) {\n    const Decl *D = getCursorDecl(C);\n    if (!D)\n      return clang_getNullCursor();\n    if (const UsingDecl *Using = dyn_cast<UsingDecl>(D))\n      return MakeCursorOverloadedDeclRef(Using, D->getLocation(), tu);\n    if (const ObjCPropertyImplDecl *PropImpl =\n            dyn_cast<ObjCPropertyImplDecl>(D))\n      if (ObjCPropertyDecl *Property = PropImpl->getPropertyDecl())\n        return MakeCXCursor(Property, tu);\n\n    return C;\n  }\n\n  if (clang_isExpression(C.kind)) {\n    const Expr *E = getCursorExpr(C);\n    const Decl *D = getDeclFromExpr(E);\n    if (D) {\n      CXCursor declCursor = MakeCXCursor(D, tu);\n      declCursor = getSelectorIdentifierCursor(getSelectorIdentifierIndex(C),\n                                               declCursor);\n      return declCursor;\n    }\n\n    if (const OverloadExpr *Ovl = dyn_cast_or_null<OverloadExpr>(E))\n      return MakeCursorOverloadedDeclRef(Ovl, tu);\n\n    return clang_getNullCursor();\n  }\n\n  if (clang_isStatement(C.kind)) {\n    const Stmt *S = getCursorStmt(C);\n    if (const GotoStmt *Goto = dyn_cast_or_null<GotoStmt>(S))\n      if (LabelDecl *label = Goto->getLabel())\n        if (LabelStmt *labelS = label->getStmt())\n          return MakeCXCursor(labelS, getCursorDecl(C), tu);\n\n    return clang_getNullCursor();\n  }\n\n  if (C.kind == CXCursor_MacroExpansion) {\n    if (const MacroDefinitionRecord *Def =\n            getCursorMacroExpansion(C).getDefinition())\n      return MakeMacroDefinitionCursor(Def, tu);\n  }\n\n  if (!clang_isReference(C.kind))\n    return clang_getNullCursor();\n\n  switch (C.kind) {\n  case CXCursor_ObjCSuperClassRef:\n    return MakeCXCursor(getCursorObjCSuperClassRef(C).first, tu);\n\n  case CXCursor_ObjCProtocolRef: {\n    const ObjCProtocolDecl *Prot = getCursorObjCProtocolRef(C).first;\n    if (const ObjCProtocolDecl *Def = Prot->getDefinition())\n      return MakeCXCursor(Def, tu);\n\n    return MakeCXCursor(Prot, tu);\n  }\n\n  case CXCursor_ObjCClassRef: {\n    const ObjCInterfaceDecl *Class = getCursorObjCClassRef(C).first;\n    if (const ObjCInterfaceDecl *Def = Class->getDefinition())\n      return MakeCXCursor(Def, tu);\n\n    return MakeCXCursor(Class, tu);\n  }\n\n  case CXCursor_TypeRef:\n    return MakeCXCursor(getCursorTypeRef(C).first, tu);\n\n  case CXCursor_TemplateRef:\n    return MakeCXCursor(getCursorTemplateRef(C).first, tu);\n\n  case CXCursor_NamespaceRef:\n    return MakeCXCursor(getCursorNamespaceRef(C).first, tu);\n\n  case CXCursor_MemberRef:\n    return MakeCXCursor(getCursorMemberRef(C).first, tu);\n\n  case CXCursor_CXXBaseSpecifier: {\n    const CXXBaseSpecifier *B = cxcursor::getCursorCXXBaseSpecifier(C);\n    return clang_getTypeDeclaration(cxtype::MakeCXType(B->getType(), tu));\n  }\n\n  case CXCursor_LabelRef:\n    // FIXME: We end up faking the \"parent\" declaration here because we\n    // don't want to make CXCursor larger.\n    return MakeCXCursor(\n        getCursorLabelRef(C).first,\n        cxtu::getASTUnit(tu)->getASTContext().getTranslationUnitDecl(), tu);\n\n  case CXCursor_OverloadedDeclRef:\n    return C;\n\n  case CXCursor_VariableRef:\n    return MakeCXCursor(getCursorVariableRef(C).first, tu);\n\n  default:\n    // We would prefer to enumerate all non-reference cursor kinds here.\n    llvm_unreachable(\"Unhandled reference cursor kind\");\n  }\n}\n\nCXCursor clang_getCursorDefinition(CXCursor C) {\n  if (clang_isInvalid(C.kind))\n    return clang_getNullCursor();\n\n  CXTranslationUnit TU = getCursorTU(C);\n\n  bool WasReference = false;\n  if (clang_isReference(C.kind) || clang_isExpression(C.kind)) {\n    C = clang_getCursorReferenced(C);\n    WasReference = true;\n  }\n\n  if (C.kind == CXCursor_MacroExpansion)\n    return clang_getCursorReferenced(C);\n\n  if (!clang_isDeclaration(C.kind))\n    return clang_getNullCursor();\n\n  const Decl *D = getCursorDecl(C);\n  if (!D)\n    return clang_getNullCursor();\n\n  switch (D->getKind()) {\n  // Declaration kinds that don't really separate the notions of\n  // declaration and definition.\n  case Decl::Namespace:\n  case Decl::Typedef:\n  case Decl::TypeAlias:\n  case Decl::TypeAliasTemplate:\n  case Decl::TemplateTypeParm:\n  case Decl::EnumConstant:\n  case Decl::Field:\n  case Decl::Binding:\n  case Decl::MSProperty:\n  case Decl::MSGuid:\n  case Decl::TemplateParamObject:\n  case Decl::IndirectField:\n  case Decl::ObjCIvar:\n  case Decl::ObjCAtDefsField:\n  case Decl::ImplicitParam:\n  case Decl::ParmVar:\n  case Decl::NonTypeTemplateParm:\n  case Decl::TemplateTemplateParm:\n  case Decl::ObjCCategoryImpl:\n  case Decl::ObjCImplementation:\n  case Decl::AccessSpec:\n  case Decl::LinkageSpec:\n  case Decl::Export:\n  case Decl::ObjCPropertyImpl:\n  case Decl::FileScopeAsm:\n  case Decl::StaticAssert:\n  case Decl::Block:\n  case Decl::Captured:\n  case Decl::OMPCapturedExpr:\n  case Decl::Label: // FIXME: Is this right??\n  case Decl::ClassScopeFunctionSpecialization:\n  case Decl::CXXDeductionGuide:\n  case Decl::Import:\n  case Decl::OMPThreadPrivate:\n  case Decl::OMPAllocate:\n  case Decl::OMPDeclareReduction:\n  case Decl::OMPDeclareMapper:\n  case Decl::OMPRequires:\n  case Decl::ObjCTypeParam:\n  case Decl::BuiltinTemplate:\n  case Decl::PragmaComment:\n  case Decl::PragmaDetectMismatch:\n  case Decl::UsingPack:\n  case Decl::Concept:\n  case Decl::LifetimeExtendedTemporary:\n  case Decl::RequiresExprBody:\n    return C;\n\n  // Declaration kinds that don't make any sense here, but are\n  // nonetheless harmless.\n  case Decl::Empty:\n  case Decl::TranslationUnit:\n  case Decl::ExternCContext:\n    break;\n\n  // Declaration kinds for which the definition is not resolvable.\n  case Decl::UnresolvedUsingTypename:\n  case Decl::UnresolvedUsingValue:\n    break;\n\n  case Decl::UsingDirective:\n    return MakeCXCursor(cast<UsingDirectiveDecl>(D)->getNominatedNamespace(),\n                        TU);\n\n  case Decl::NamespaceAlias:\n    return MakeCXCursor(cast<NamespaceAliasDecl>(D)->getNamespace(), TU);\n\n  case Decl::Enum:\n  case Decl::Record:\n  case Decl::CXXRecord:\n  case Decl::ClassTemplateSpecialization:\n  case Decl::ClassTemplatePartialSpecialization:\n    if (TagDecl *Def = cast<TagDecl>(D)->getDefinition())\n      return MakeCXCursor(Def, TU);\n    return clang_getNullCursor();\n\n  case Decl::Function:\n  case Decl::CXXMethod:\n  case Decl::CXXConstructor:\n  case Decl::CXXDestructor:\n  case Decl::CXXConversion: {\n    const FunctionDecl *Def = nullptr;\n    if (cast<FunctionDecl>(D)->getBody(Def))\n      return MakeCXCursor(Def, TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::Var:\n  case Decl::VarTemplateSpecialization:\n  case Decl::VarTemplatePartialSpecialization:\n  case Decl::Decomposition: {\n    // Ask the variable if it has a definition.\n    if (const VarDecl *Def = cast<VarDecl>(D)->getDefinition())\n      return MakeCXCursor(Def, TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::FunctionTemplate: {\n    const FunctionDecl *Def = nullptr;\n    if (cast<FunctionTemplateDecl>(D)->getTemplatedDecl()->getBody(Def))\n      return MakeCXCursor(Def->getDescribedFunctionTemplate(), TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::ClassTemplate: {\n    if (RecordDecl *Def =\n            cast<ClassTemplateDecl>(D)->getTemplatedDecl()->getDefinition())\n      return MakeCXCursor(cast<CXXRecordDecl>(Def)->getDescribedClassTemplate(),\n                          TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::VarTemplate: {\n    if (VarDecl *Def =\n            cast<VarTemplateDecl>(D)->getTemplatedDecl()->getDefinition())\n      return MakeCXCursor(cast<VarDecl>(Def)->getDescribedVarTemplate(), TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::Using:\n    return MakeCursorOverloadedDeclRef(cast<UsingDecl>(D), D->getLocation(),\n                                       TU);\n\n  case Decl::UsingShadow:\n  case Decl::ConstructorUsingShadow:\n    return clang_getCursorDefinition(\n        MakeCXCursor(cast<UsingShadowDecl>(D)->getTargetDecl(), TU));\n\n  case Decl::ObjCMethod: {\n    const ObjCMethodDecl *Method = cast<ObjCMethodDecl>(D);\n    if (Method->isThisDeclarationADefinition())\n      return C;\n\n    // Dig out the method definition in the associated\n    // @implementation, if we have it.\n    // FIXME: The ASTs should make finding the definition easier.\n    if (const ObjCInterfaceDecl *Class =\n            dyn_cast<ObjCInterfaceDecl>(Method->getDeclContext()))\n      if (ObjCImplementationDecl *ClassImpl = Class->getImplementation())\n        if (ObjCMethodDecl *Def = ClassImpl->getMethod(\n                Method->getSelector(), Method->isInstanceMethod()))\n          if (Def->isThisDeclarationADefinition())\n            return MakeCXCursor(Def, TU);\n\n    return clang_getNullCursor();\n  }\n\n  case Decl::ObjCCategory:\n    if (ObjCCategoryImplDecl *Impl =\n            cast<ObjCCategoryDecl>(D)->getImplementation())\n      return MakeCXCursor(Impl, TU);\n    return clang_getNullCursor();\n\n  case Decl::ObjCProtocol:\n    if (const ObjCProtocolDecl *Def =\n            cast<ObjCProtocolDecl>(D)->getDefinition())\n      return MakeCXCursor(Def, TU);\n    return clang_getNullCursor();\n\n  case Decl::ObjCInterface: {\n    // There are two notions of a \"definition\" for an Objective-C\n    // class: the interface and its implementation. When we resolved a\n    // reference to an Objective-C class, produce the @interface as\n    // the definition; when we were provided with the interface,\n    // produce the @implementation as the definition.\n    const ObjCInterfaceDecl *IFace = cast<ObjCInterfaceDecl>(D);\n    if (WasReference) {\n      if (const ObjCInterfaceDecl *Def = IFace->getDefinition())\n        return MakeCXCursor(Def, TU);\n    } else if (ObjCImplementationDecl *Impl = IFace->getImplementation())\n      return MakeCXCursor(Impl, TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::ObjCProperty:\n    // FIXME: We don't really know where to find the\n    // ObjCPropertyImplDecls that implement this property.\n    return clang_getNullCursor();\n\n  case Decl::ObjCCompatibleAlias:\n    if (const ObjCInterfaceDecl *Class =\n            cast<ObjCCompatibleAliasDecl>(D)->getClassInterface())\n      if (const ObjCInterfaceDecl *Def = Class->getDefinition())\n        return MakeCXCursor(Def, TU);\n\n    return clang_getNullCursor();\n\n  case Decl::Friend:\n    if (NamedDecl *Friend = cast<FriendDecl>(D)->getFriendDecl())\n      return clang_getCursorDefinition(MakeCXCursor(Friend, TU));\n    return clang_getNullCursor();\n\n  case Decl::FriendTemplate:\n    if (NamedDecl *Friend = cast<FriendTemplateDecl>(D)->getFriendDecl())\n      return clang_getCursorDefinition(MakeCXCursor(Friend, TU));\n    return clang_getNullCursor();\n  }\n\n  return clang_getNullCursor();\n}\n\nunsigned clang_isCursorDefinition(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  return clang_getCursorDefinition(C) == C;\n}\n\nCXCursor clang_getCanonicalCursor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return C;\n\n  if (const Decl *D = getCursorDecl(C)) {\n    if (const ObjCCategoryImplDecl *CatImplD =\n            dyn_cast<ObjCCategoryImplDecl>(D))\n      if (ObjCCategoryDecl *CatD = CatImplD->getCategoryDecl())\n        return MakeCXCursor(CatD, getCursorTU(C));\n\n    if (const ObjCImplDecl *ImplD = dyn_cast<ObjCImplDecl>(D))\n      if (const ObjCInterfaceDecl *IFD = ImplD->getClassInterface())\n        return MakeCXCursor(IFD, getCursorTU(C));\n\n    return MakeCXCursor(D->getCanonicalDecl(), getCursorTU(C));\n  }\n\n  return C;\n}\n\nint clang_Cursor_getObjCSelectorIndex(CXCursor cursor) {\n  return cxcursor::getSelectorIdentifierIndexAndLoc(cursor).first;\n}\n\nunsigned clang_getNumOverloadedDecls(CXCursor C) {\n  if (C.kind != CXCursor_OverloadedDeclRef)\n    return 0;\n\n  OverloadedDeclRefStorage Storage = getCursorOverloadedDeclRef(C).first;\n  if (const OverloadExpr *E = Storage.dyn_cast<const OverloadExpr *>())\n    return E->getNumDecls();\n\n  if (OverloadedTemplateStorage *S =\n          Storage.dyn_cast<OverloadedTemplateStorage *>())\n    return S->size();\n\n  const Decl *D = Storage.get<const Decl *>();\n  if (const UsingDecl *Using = dyn_cast<UsingDecl>(D))\n    return Using->shadow_size();\n\n  return 0;\n}\n\nCXCursor clang_getOverloadedDecl(CXCursor cursor, unsigned index) {\n  if (cursor.kind != CXCursor_OverloadedDeclRef)\n    return clang_getNullCursor();\n\n  if (index >= clang_getNumOverloadedDecls(cursor))\n    return clang_getNullCursor();\n\n  CXTranslationUnit TU = getCursorTU(cursor);\n  OverloadedDeclRefStorage Storage = getCursorOverloadedDeclRef(cursor).first;\n  if (const OverloadExpr *E = Storage.dyn_cast<const OverloadExpr *>())\n    return MakeCXCursor(E->decls_begin()[index], TU);\n\n  if (OverloadedTemplateStorage *S =\n          Storage.dyn_cast<OverloadedTemplateStorage *>())\n    return MakeCXCursor(S->begin()[index], TU);\n\n  const Decl *D = Storage.get<const Decl *>();\n  if (const UsingDecl *Using = dyn_cast<UsingDecl>(D)) {\n    // FIXME: This is, unfortunately, linear time.\n    UsingDecl::shadow_iterator Pos = Using->shadow_begin();\n    std::advance(Pos, index);\n    return MakeCXCursor(cast<UsingShadowDecl>(*Pos)->getTargetDecl(), TU);\n  }\n\n  return clang_getNullCursor();\n}\n\nvoid clang_getDefinitionSpellingAndExtent(\n    CXCursor C, const char **startBuf, const char **endBuf, unsigned *startLine,\n    unsigned *startColumn, unsigned *endLine, unsigned *endColumn) {\n  assert(getCursorDecl(C) && \"CXCursor has null decl\");\n  const FunctionDecl *FD = dyn_cast<FunctionDecl>(getCursorDecl(C));\n  CompoundStmt *Body = dyn_cast<CompoundStmt>(FD->getBody());\n\n  SourceManager &SM = FD->getASTContext().getSourceManager();\n  *startBuf = SM.getCharacterData(Body->getLBracLoc());\n  *endBuf = SM.getCharacterData(Body->getRBracLoc());\n  *startLine = SM.getSpellingLineNumber(Body->getLBracLoc());\n  *startColumn = SM.getSpellingColumnNumber(Body->getLBracLoc());\n  *endLine = SM.getSpellingLineNumber(Body->getRBracLoc());\n  *endColumn = SM.getSpellingColumnNumber(Body->getRBracLoc());\n}\n\nCXSourceRange clang_getCursorReferenceNameRange(CXCursor C, unsigned NameFlags,\n                                                unsigned PieceIndex) {\n  RefNamePieces Pieces;\n\n  switch (C.kind) {\n  case CXCursor_MemberRefExpr:\n    if (const MemberExpr *E = dyn_cast<MemberExpr>(getCursorExpr(C)))\n      Pieces = buildPieces(NameFlags, true, E->getMemberNameInfo(),\n                           E->getQualifierLoc().getSourceRange());\n    break;\n\n  case CXCursor_DeclRefExpr:\n    if (const DeclRefExpr *E = dyn_cast<DeclRefExpr>(getCursorExpr(C))) {\n      SourceRange TemplateArgLoc(E->getLAngleLoc(), E->getRAngleLoc());\n      Pieces =\n          buildPieces(NameFlags, false, E->getNameInfo(),\n                      E->getQualifierLoc().getSourceRange(), &TemplateArgLoc);\n    }\n    break;\n\n  case CXCursor_CallExpr:\n    if (const CXXOperatorCallExpr *OCE =\n            dyn_cast<CXXOperatorCallExpr>(getCursorExpr(C))) {\n      const Expr *Callee = OCE->getCallee();\n      if (const ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(Callee))\n        Callee = ICE->getSubExpr();\n\n      if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Callee))\n        Pieces = buildPieces(NameFlags, false, DRE->getNameInfo(),\n                             DRE->getQualifierLoc().getSourceRange());\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  if (Pieces.empty()) {\n    if (PieceIndex == 0)\n      return clang_getCursorExtent(C);\n  } else if (PieceIndex < Pieces.size()) {\n    SourceRange R = Pieces[PieceIndex];\n    if (R.isValid())\n      return cxloc::translateSourceRange(getCursorContext(C), R);\n  }\n\n  return clang_getNullRange();\n}\n\nvoid clang_enableStackTraces(void) {\n  // FIXME: Provide an argv0 here so we can find llvm-symbolizer.\n  llvm::sys::PrintStackTraceOnErrorSignal(StringRef());\n}\n\nvoid clang_executeOnThread(void (*fn)(void *), void *user_data,\n                           unsigned stack_size) {\n  llvm::llvm_execute_on_thread(fn, user_data,\n                               stack_size == 0\n                                   ? clang::DesiredStackSize\n                                   : llvm::Optional<unsigned>(stack_size));\n}\n\n//===----------------------------------------------------------------------===//\n// Token-based Operations.\n//===----------------------------------------------------------------------===//\n\n/* CXToken layout:\n *   int_data[0]: a CXTokenKind\n *   int_data[1]: starting token location\n *   int_data[2]: token length\n *   int_data[3]: reserved\n *   ptr_data: for identifiers and keywords, an IdentifierInfo*.\n *   otherwise unused.\n */\nCXTokenKind clang_getTokenKind(CXToken CXTok) {\n  return static_cast<CXTokenKind>(CXTok.int_data[0]);\n}\n\nCXString clang_getTokenSpelling(CXTranslationUnit TU, CXToken CXTok) {\n  switch (clang_getTokenKind(CXTok)) {\n  case CXToken_Identifier:\n  case CXToken_Keyword:\n    // We know we have an IdentifierInfo*, so use that.\n    return cxstring::createRef(\n        static_cast<IdentifierInfo *>(CXTok.ptr_data)->getNameStart());\n\n  case CXToken_Literal: {\n    // We have stashed the starting pointer in the ptr_data field. Use it.\n    const char *Text = static_cast<const char *>(CXTok.ptr_data);\n    return cxstring::createDup(StringRef(Text, CXTok.int_data[2]));\n  }\n\n  case CXToken_Punctuation:\n  case CXToken_Comment:\n    break;\n  }\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return cxstring::createEmpty();\n  }\n\n  // We have to find the starting buffer pointer the hard way, by\n  // deconstructing the source location.\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return cxstring::createEmpty();\n\n  SourceLocation Loc = SourceLocation::getFromRawEncoding(CXTok.int_data[1]);\n  std::pair<FileID, unsigned> LocInfo =\n      CXXUnit->getSourceManager().getDecomposedSpellingLoc(Loc);\n  bool Invalid = false;\n  StringRef Buffer =\n      CXXUnit->getSourceManager().getBufferData(LocInfo.first, &Invalid);\n  if (Invalid)\n    return cxstring::createEmpty();\n\n  return cxstring::createDup(Buffer.substr(LocInfo.second, CXTok.int_data[2]));\n}\n\nCXSourceLocation clang_getTokenLocation(CXTranslationUnit TU, CXToken CXTok) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return clang_getNullLocation();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return clang_getNullLocation();\n\n  return cxloc::translateSourceLocation(\n      CXXUnit->getASTContext(),\n      SourceLocation::getFromRawEncoding(CXTok.int_data[1]));\n}\n\nCXSourceRange clang_getTokenExtent(CXTranslationUnit TU, CXToken CXTok) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return clang_getNullRange();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return clang_getNullRange();\n\n  return cxloc::translateSourceRange(\n      CXXUnit->getASTContext(),\n      SourceLocation::getFromRawEncoding(CXTok.int_data[1]));\n}\n\nstatic void getTokens(ASTUnit *CXXUnit, SourceRange Range,\n                      SmallVectorImpl<CXToken> &CXTokens) {\n  SourceManager &SourceMgr = CXXUnit->getSourceManager();\n  std::pair<FileID, unsigned> BeginLocInfo =\n      SourceMgr.getDecomposedSpellingLoc(Range.getBegin());\n  std::pair<FileID, unsigned> EndLocInfo =\n      SourceMgr.getDecomposedSpellingLoc(Range.getEnd());\n\n  // Cannot tokenize across files.\n  if (BeginLocInfo.first != EndLocInfo.first)\n    return;\n\n  // Create a lexer\n  bool Invalid = false;\n  StringRef Buffer = SourceMgr.getBufferData(BeginLocInfo.first, &Invalid);\n  if (Invalid)\n    return;\n\n  Lexer Lex(SourceMgr.getLocForStartOfFile(BeginLocInfo.first),\n            CXXUnit->getASTContext().getLangOpts(), Buffer.begin(),\n            Buffer.data() + BeginLocInfo.second, Buffer.end());\n  Lex.SetCommentRetentionState(true);\n\n  // Lex tokens until we hit the end of the range.\n  const char *EffectiveBufferEnd = Buffer.data() + EndLocInfo.second;\n  Token Tok;\n  bool previousWasAt = false;\n  do {\n    // Lex the next token\n    Lex.LexFromRawLexer(Tok);\n    if (Tok.is(tok::eof))\n      break;\n\n    // Initialize the CXToken.\n    CXToken CXTok;\n\n    //   - Common fields\n    CXTok.int_data[1] = Tok.getLocation().getRawEncoding();\n    CXTok.int_data[2] = Tok.getLength();\n    CXTok.int_data[3] = 0;\n\n    //   - Kind-specific fields\n    if (Tok.isLiteral()) {\n      CXTok.int_data[0] = CXToken_Literal;\n      CXTok.ptr_data = const_cast<char *>(Tok.getLiteralData());\n    } else if (Tok.is(tok::raw_identifier)) {\n      // Lookup the identifier to determine whether we have a keyword.\n      IdentifierInfo *II = CXXUnit->getPreprocessor().LookUpIdentifierInfo(Tok);\n\n      if ((II->getObjCKeywordID() != tok::objc_not_keyword) && previousWasAt) {\n        CXTok.int_data[0] = CXToken_Keyword;\n      } else {\n        CXTok.int_data[0] =\n            Tok.is(tok::identifier) ? CXToken_Identifier : CXToken_Keyword;\n      }\n      CXTok.ptr_data = II;\n    } else if (Tok.is(tok::comment)) {\n      CXTok.int_data[0] = CXToken_Comment;\n      CXTok.ptr_data = nullptr;\n    } else {\n      CXTok.int_data[0] = CXToken_Punctuation;\n      CXTok.ptr_data = nullptr;\n    }\n    CXTokens.push_back(CXTok);\n    previousWasAt = Tok.is(tok::at);\n  } while (Lex.getBufferLocation() < EffectiveBufferEnd);\n}\n\nCXToken *clang_getToken(CXTranslationUnit TU, CXSourceLocation Location) {\n  LOG_FUNC_SECTION { *Log << TU << ' ' << Location; }\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return NULL;\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return NULL;\n\n  SourceLocation Begin = cxloc::translateSourceLocation(Location);\n  if (Begin.isInvalid())\n    return NULL;\n  SourceManager &SM = CXXUnit->getSourceManager();\n  std::pair<FileID, unsigned> DecomposedEnd = SM.getDecomposedLoc(Begin);\n  DecomposedEnd.second +=\n      Lexer::MeasureTokenLength(Begin, SM, CXXUnit->getLangOpts());\n\n  SourceLocation End =\n      SM.getComposedLoc(DecomposedEnd.first, DecomposedEnd.second);\n\n  SmallVector<CXToken, 32> CXTokens;\n  getTokens(CXXUnit, SourceRange(Begin, End), CXTokens);\n\n  if (CXTokens.empty())\n    return NULL;\n\n  CXTokens.resize(1);\n  CXToken *Token = static_cast<CXToken *>(llvm::safe_malloc(sizeof(CXToken)));\n\n  memmove(Token, CXTokens.data(), sizeof(CXToken));\n  return Token;\n}\n\nvoid clang_tokenize(CXTranslationUnit TU, CXSourceRange Range, CXToken **Tokens,\n                    unsigned *NumTokens) {\n  LOG_FUNC_SECTION { *Log << TU << ' ' << Range; }\n\n  if (Tokens)\n    *Tokens = nullptr;\n  if (NumTokens)\n    *NumTokens = 0;\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return;\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit || !Tokens || !NumTokens)\n    return;\n\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n\n  SourceRange R = cxloc::translateCXSourceRange(Range);\n  if (R.isInvalid())\n    return;\n\n  SmallVector<CXToken, 32> CXTokens;\n  getTokens(CXXUnit, R, CXTokens);\n\n  if (CXTokens.empty())\n    return;\n\n  *Tokens = static_cast<CXToken *>(\n      llvm::safe_malloc(sizeof(CXToken) * CXTokens.size()));\n  memmove(*Tokens, CXTokens.data(), sizeof(CXToken) * CXTokens.size());\n  *NumTokens = CXTokens.size();\n}\n\nvoid clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens,\n                         unsigned NumTokens) {\n  free(Tokens);\n}\n\n//===----------------------------------------------------------------------===//\n// Token annotation APIs.\n//===----------------------------------------------------------------------===//\n\nstatic enum CXChildVisitResult AnnotateTokensVisitor(CXCursor cursor,\n                                                     CXCursor parent,\n                                                     CXClientData client_data);\nstatic bool AnnotateTokensPostChildrenVisitor(CXCursor cursor,\n                                              CXClientData client_data);\n\nnamespace {\nclass AnnotateTokensWorker {\n  CXToken *Tokens;\n  CXCursor *Cursors;\n  unsigned NumTokens;\n  unsigned TokIdx;\n  unsigned PreprocessingTokIdx;\n  CursorVisitor AnnotateVis;\n  SourceManager &SrcMgr;\n  bool HasContextSensitiveKeywords;\n\n  struct PostChildrenAction {\n    CXCursor cursor;\n    enum Action { Invalid, Ignore, Postpone } action;\n  };\n  using PostChildrenActions = SmallVector<PostChildrenAction, 0>;\n\n  struct PostChildrenInfo {\n    CXCursor Cursor;\n    SourceRange CursorRange;\n    unsigned BeforeReachingCursorIdx;\n    unsigned BeforeChildrenTokenIdx;\n    PostChildrenActions ChildActions;\n  };\n  SmallVector<PostChildrenInfo, 8> PostChildrenInfos;\n\n  CXToken &getTok(unsigned Idx) {\n    assert(Idx < NumTokens);\n    return Tokens[Idx];\n  }\n  const CXToken &getTok(unsigned Idx) const {\n    assert(Idx < NumTokens);\n    return Tokens[Idx];\n  }\n  bool MoreTokens() const { return TokIdx < NumTokens; }\n  unsigned NextToken() const { return TokIdx; }\n  void AdvanceToken() { ++TokIdx; }\n  SourceLocation GetTokenLoc(unsigned tokI) {\n    return SourceLocation::getFromRawEncoding(getTok(tokI).int_data[1]);\n  }\n  bool isFunctionMacroToken(unsigned tokI) const {\n    return getTok(tokI).int_data[3] != 0;\n  }\n  SourceLocation getFunctionMacroTokenLoc(unsigned tokI) const {\n    return SourceLocation::getFromRawEncoding(getTok(tokI).int_data[3]);\n  }\n\n  void annotateAndAdvanceTokens(CXCursor, RangeComparisonResult, SourceRange);\n  bool annotateAndAdvanceFunctionMacroTokens(CXCursor, RangeComparisonResult,\n                                             SourceRange);\n\npublic:\n  AnnotateTokensWorker(CXToken *tokens, CXCursor *cursors, unsigned numTokens,\n                       CXTranslationUnit TU, SourceRange RegionOfInterest)\n      : Tokens(tokens), Cursors(cursors), NumTokens(numTokens), TokIdx(0),\n        PreprocessingTokIdx(0),\n        AnnotateVis(TU, AnnotateTokensVisitor, this,\n                    /*VisitPreprocessorLast=*/true,\n                    /*VisitIncludedEntities=*/false, RegionOfInterest,\n                    /*VisitDeclsOnly=*/false,\n                    AnnotateTokensPostChildrenVisitor),\n        SrcMgr(cxtu::getASTUnit(TU)->getSourceManager()),\n        HasContextSensitiveKeywords(false) {}\n\n  void VisitChildren(CXCursor C) { AnnotateVis.VisitChildren(C); }\n  enum CXChildVisitResult Visit(CXCursor cursor, CXCursor parent);\n  bool IsIgnoredChildCursor(CXCursor cursor) const;\n  PostChildrenActions DetermineChildActions(CXCursor Cursor) const;\n\n  bool postVisitChildren(CXCursor cursor);\n  void HandlePostPonedChildCursors(const PostChildrenInfo &Info);\n  void HandlePostPonedChildCursor(CXCursor Cursor, unsigned StartTokenIndex);\n\n  void AnnotateTokens();\n\n  /// Determine whether the annotator saw any cursors that have\n  /// context-sensitive keywords.\n  bool hasContextSensitiveKeywords() const {\n    return HasContextSensitiveKeywords;\n  }\n\n  ~AnnotateTokensWorker() { assert(PostChildrenInfos.empty()); }\n};\n} // namespace\n\nvoid AnnotateTokensWorker::AnnotateTokens() {\n  // Walk the AST within the region of interest, annotating tokens\n  // along the way.\n  AnnotateVis.visitFileRegion();\n}\n\nbool AnnotateTokensWorker::IsIgnoredChildCursor(CXCursor cursor) const {\n  if (PostChildrenInfos.empty())\n    return false;\n\n  for (const auto &ChildAction : PostChildrenInfos.back().ChildActions) {\n    if (ChildAction.cursor == cursor &&\n        ChildAction.action == PostChildrenAction::Ignore) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst CXXOperatorCallExpr *GetSubscriptOrCallOperator(CXCursor Cursor) {\n  if (!clang_isExpression(Cursor.kind))\n    return nullptr;\n\n  const Expr *E = getCursorExpr(Cursor);\n  if (const auto *OCE = dyn_cast<CXXOperatorCallExpr>(E)) {\n    const OverloadedOperatorKind Kind = OCE->getOperator();\n    if (Kind == OO_Call || Kind == OO_Subscript)\n      return OCE;\n  }\n\n  return nullptr;\n}\n\nAnnotateTokensWorker::PostChildrenActions\nAnnotateTokensWorker::DetermineChildActions(CXCursor Cursor) const {\n  PostChildrenActions actions;\n\n  // The DeclRefExpr of CXXOperatorCallExpr refering to the custom operator is\n  // visited before the arguments to the operator call. For the Call and\n  // Subscript operator the range of this DeclRefExpr includes the whole call\n  // expression, so that all tokens in that range would be mapped to the\n  // operator function, including the tokens of the arguments. To avoid that,\n  // ensure to visit this DeclRefExpr as last node.\n  if (const auto *OCE = GetSubscriptOrCallOperator(Cursor)) {\n    const Expr *Callee = OCE->getCallee();\n    if (const ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(Callee)) {\n      const Expr *SubExpr = ICE->getSubExpr();\n      if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(SubExpr)) {\n        const Decl *parentDecl = getCursorDecl(Cursor);\n        CXTranslationUnit TU = clang_Cursor_getTranslationUnit(Cursor);\n\n        // Visit the DeclRefExpr as last.\n        CXCursor cxChild = MakeCXCursor(DRE, parentDecl, TU);\n        actions.push_back({cxChild, PostChildrenAction::Postpone});\n\n        // The parent of the DeclRefExpr, an ImplicitCastExpr, has an equally\n        // wide range as the DeclRefExpr. We can skip visiting this entirely.\n        cxChild = MakeCXCursor(ICE, parentDecl, TU);\n        actions.push_back({cxChild, PostChildrenAction::Ignore});\n      }\n    }\n  }\n\n  return actions;\n}\n\nstatic inline void updateCursorAnnotation(CXCursor &Cursor,\n                                          const CXCursor &updateC) {\n  if (clang_isInvalid(updateC.kind) || !clang_isInvalid(Cursor.kind))\n    return;\n  Cursor = updateC;\n}\n\n/// It annotates and advances tokens with a cursor until the comparison\n//// between the cursor location and the source range is the same as\n/// \\arg compResult.\n///\n/// Pass RangeBefore to annotate tokens with a cursor until a range is reached.\n/// Pass RangeOverlap to annotate tokens inside a range.\nvoid AnnotateTokensWorker::annotateAndAdvanceTokens(\n    CXCursor updateC, RangeComparisonResult compResult, SourceRange range) {\n  while (MoreTokens()) {\n    const unsigned I = NextToken();\n    if (isFunctionMacroToken(I))\n      if (!annotateAndAdvanceFunctionMacroTokens(updateC, compResult, range))\n        return;\n\n    SourceLocation TokLoc = GetTokenLoc(I);\n    if (LocationCompare(SrcMgr, TokLoc, range) == compResult) {\n      updateCursorAnnotation(Cursors[I], updateC);\n      AdvanceToken();\n      continue;\n    }\n    break;\n  }\n}\n\n/// Special annotation handling for macro argument tokens.\n/// \\returns true if it advanced beyond all macro tokens, false otherwise.\nbool AnnotateTokensWorker::annotateAndAdvanceFunctionMacroTokens(\n    CXCursor updateC, RangeComparisonResult compResult, SourceRange range) {\n  assert(MoreTokens());\n  assert(isFunctionMacroToken(NextToken()) &&\n         \"Should be called only for macro arg tokens\");\n\n  // This works differently than annotateAndAdvanceTokens; because expanded\n  // macro arguments can have arbitrary translation-unit source order, we do not\n  // advance the token index one by one until a token fails the range test.\n  // We only advance once past all of the macro arg tokens if all of them\n  // pass the range test. If one of them fails we keep the token index pointing\n  // at the start of the macro arg tokens so that the failing token will be\n  // annotated by a subsequent annotation try.\n\n  bool atLeastOneCompFail = false;\n\n  unsigned I = NextToken();\n  for (; I < NumTokens && isFunctionMacroToken(I); ++I) {\n    SourceLocation TokLoc = getFunctionMacroTokenLoc(I);\n    if (TokLoc.isFileID())\n      continue; // not macro arg token, it's parens or comma.\n    if (LocationCompare(SrcMgr, TokLoc, range) == compResult) {\n      if (clang_isInvalid(clang_getCursorKind(Cursors[I])))\n        Cursors[I] = updateC;\n    } else\n      atLeastOneCompFail = true;\n  }\n\n  if (atLeastOneCompFail)\n    return false;\n\n  TokIdx = I; // All of the tokens were handled, advance beyond all of them.\n  return true;\n}\n\nenum CXChildVisitResult AnnotateTokensWorker::Visit(CXCursor cursor,\n                                                    CXCursor parent) {\n  SourceRange cursorRange = getRawCursorExtent(cursor);\n  if (cursorRange.isInvalid())\n    return CXChildVisit_Recurse;\n\n  if (IsIgnoredChildCursor(cursor))\n    return CXChildVisit_Continue;\n\n  if (!HasContextSensitiveKeywords) {\n    // Objective-C properties can have context-sensitive keywords.\n    if (cursor.kind == CXCursor_ObjCPropertyDecl) {\n      if (const ObjCPropertyDecl *Property =\n              dyn_cast_or_null<ObjCPropertyDecl>(getCursorDecl(cursor)))\n        HasContextSensitiveKeywords =\n            Property->getPropertyAttributesAsWritten() != 0;\n    }\n    // Objective-C methods can have context-sensitive keywords.\n    else if (cursor.kind == CXCursor_ObjCInstanceMethodDecl ||\n             cursor.kind == CXCursor_ObjCClassMethodDecl) {\n      if (const ObjCMethodDecl *Method =\n              dyn_cast_or_null<ObjCMethodDecl>(getCursorDecl(cursor))) {\n        if (Method->getObjCDeclQualifier())\n          HasContextSensitiveKeywords = true;\n        else {\n          for (const auto *P : Method->parameters()) {\n            if (P->getObjCDeclQualifier()) {\n              HasContextSensitiveKeywords = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n    // C++ methods can have context-sensitive keywords.\n    else if (cursor.kind == CXCursor_CXXMethod) {\n      if (const CXXMethodDecl *Method =\n              dyn_cast_or_null<CXXMethodDecl>(getCursorDecl(cursor))) {\n        if (Method->hasAttr<FinalAttr>() || Method->hasAttr<OverrideAttr>())\n          HasContextSensitiveKeywords = true;\n      }\n    }\n    // C++ classes can have context-sensitive keywords.\n    else if (cursor.kind == CXCursor_StructDecl ||\n             cursor.kind == CXCursor_ClassDecl ||\n             cursor.kind == CXCursor_ClassTemplate ||\n             cursor.kind == CXCursor_ClassTemplatePartialSpecialization) {\n      if (const Decl *D = getCursorDecl(cursor))\n        if (D->hasAttr<FinalAttr>())\n          HasContextSensitiveKeywords = true;\n    }\n  }\n\n  // Don't override a property annotation with its getter/setter method.\n  if (cursor.kind == CXCursor_ObjCInstanceMethodDecl &&\n      parent.kind == CXCursor_ObjCPropertyDecl)\n    return CXChildVisit_Continue;\n\n  if (clang_isPreprocessing(cursor.kind)) {\n    // Items in the preprocessing record are kept separate from items in\n    // declarations, so we keep a separate token index.\n    unsigned SavedTokIdx = TokIdx;\n    TokIdx = PreprocessingTokIdx;\n\n    // Skip tokens up until we catch up to the beginning of the preprocessing\n    // entry.\n    while (MoreTokens()) {\n      const unsigned I = NextToken();\n      SourceLocation TokLoc = GetTokenLoc(I);\n      switch (LocationCompare(SrcMgr, TokLoc, cursorRange)) {\n      case RangeBefore:\n        AdvanceToken();\n        continue;\n      case RangeAfter:\n      case RangeOverlap:\n        break;\n      }\n      break;\n    }\n\n    // Look at all of the tokens within this range.\n    while (MoreTokens()) {\n      const unsigned I = NextToken();\n      SourceLocation TokLoc = GetTokenLoc(I);\n      switch (LocationCompare(SrcMgr, TokLoc, cursorRange)) {\n      case RangeBefore:\n        llvm_unreachable(\"Infeasible\");\n      case RangeAfter:\n        break;\n      case RangeOverlap:\n        // For macro expansions, just note where the beginning of the macro\n        // expansion occurs.\n        if (cursor.kind == CXCursor_MacroExpansion) {\n          if (TokLoc == cursorRange.getBegin())\n            Cursors[I] = cursor;\n          AdvanceToken();\n          break;\n        }\n        // We may have already annotated macro names inside macro definitions.\n        if (Cursors[I].kind != CXCursor_MacroExpansion)\n          Cursors[I] = cursor;\n        AdvanceToken();\n        continue;\n      }\n      break;\n    }\n\n    // Save the preprocessing token index; restore the non-preprocessing\n    // token index.\n    PreprocessingTokIdx = TokIdx;\n    TokIdx = SavedTokIdx;\n    return CXChildVisit_Recurse;\n  }\n\n  if (cursorRange.isInvalid())\n    return CXChildVisit_Continue;\n\n  unsigned BeforeReachingCursorIdx = NextToken();\n  const enum CXCursorKind cursorK = clang_getCursorKind(cursor);\n  const enum CXCursorKind K = clang_getCursorKind(parent);\n  const CXCursor updateC =\n      (clang_isInvalid(K) || K == CXCursor_TranslationUnit ||\n       // Attributes are annotated out-of-order, skip tokens until we reach it.\n       clang_isAttribute(cursor.kind))\n          ? clang_getNullCursor()\n          : parent;\n\n  annotateAndAdvanceTokens(updateC, RangeBefore, cursorRange);\n\n  // Avoid having the cursor of an expression \"overwrite\" the annotation of the\n  // variable declaration that it belongs to.\n  // This can happen for C++ constructor expressions whose range generally\n  // include the variable declaration, e.g.:\n  //  MyCXXClass foo; // Make sure we don't annotate 'foo' as a CallExpr cursor.\n  if (clang_isExpression(cursorK) && MoreTokens()) {\n    const Expr *E = getCursorExpr(cursor);\n    if (const Decl *D = getCursorDecl(cursor)) {\n      const unsigned I = NextToken();\n      if (E->getBeginLoc().isValid() && D->getLocation().isValid() &&\n          E->getBeginLoc() == D->getLocation() &&\n          E->getBeginLoc() == GetTokenLoc(I)) {\n        updateCursorAnnotation(Cursors[I], updateC);\n        AdvanceToken();\n      }\n    }\n  }\n\n  // Before recursing into the children keep some state that we are going\n  // to use in the AnnotateTokensWorker::postVisitChildren callback to do some\n  // extra work after the child nodes are visited.\n  // Note that we don't call VisitChildren here to avoid traversing statements\n  // code-recursively which can blow the stack.\n\n  PostChildrenInfo Info;\n  Info.Cursor = cursor;\n  Info.CursorRange = cursorRange;\n  Info.BeforeReachingCursorIdx = BeforeReachingCursorIdx;\n  Info.BeforeChildrenTokenIdx = NextToken();\n  Info.ChildActions = DetermineChildActions(cursor);\n  PostChildrenInfos.push_back(Info);\n\n  return CXChildVisit_Recurse;\n}\n\nbool AnnotateTokensWorker::postVisitChildren(CXCursor cursor) {\n  if (PostChildrenInfos.empty())\n    return false;\n  const PostChildrenInfo &Info = PostChildrenInfos.back();\n  if (!clang_equalCursors(Info.Cursor, cursor))\n    return false;\n\n  HandlePostPonedChildCursors(Info);\n\n  const unsigned BeforeChildren = Info.BeforeChildrenTokenIdx;\n  const unsigned AfterChildren = NextToken();\n  SourceRange cursorRange = Info.CursorRange;\n\n  // Scan the tokens that are at the end of the cursor, but are not captured\n  // but the child cursors.\n  annotateAndAdvanceTokens(cursor, RangeOverlap, cursorRange);\n\n  // Scan the tokens that are at the beginning of the cursor, but are not\n  // capture by the child cursors.\n  for (unsigned I = BeforeChildren; I != AfterChildren; ++I) {\n    if (!clang_isInvalid(clang_getCursorKind(Cursors[I])))\n      break;\n\n    Cursors[I] = cursor;\n  }\n\n  // Attributes are annotated out-of-order, rewind TokIdx to when we first\n  // encountered the attribute cursor.\n  if (clang_isAttribute(cursor.kind))\n    TokIdx = Info.BeforeReachingCursorIdx;\n\n  PostChildrenInfos.pop_back();\n  return false;\n}\n\nvoid AnnotateTokensWorker::HandlePostPonedChildCursors(\n    const PostChildrenInfo &Info) {\n  for (const auto &ChildAction : Info.ChildActions) {\n    if (ChildAction.action == PostChildrenAction::Postpone) {\n      HandlePostPonedChildCursor(ChildAction.cursor,\n                                 Info.BeforeChildrenTokenIdx);\n    }\n  }\n}\n\nvoid AnnotateTokensWorker::HandlePostPonedChildCursor(\n    CXCursor Cursor, unsigned StartTokenIndex) {\n  unsigned I = StartTokenIndex;\n\n  // The bracket tokens of a Call or Subscript operator are mapped to\n  // CallExpr/CXXOperatorCallExpr because we skipped visiting the corresponding\n  // DeclRefExpr. Remap these tokens to the DeclRefExpr cursors.\n  for (unsigned RefNameRangeNr = 0; I < NumTokens; RefNameRangeNr++) {\n    const CXSourceRange CXRefNameRange = clang_getCursorReferenceNameRange(\n        Cursor, CXNameRange_WantQualifier, RefNameRangeNr);\n    if (clang_Range_isNull(CXRefNameRange))\n      break; // All ranges handled.\n\n    SourceRange RefNameRange = cxloc::translateCXSourceRange(CXRefNameRange);\n    while (I < NumTokens) {\n      const SourceLocation TokenLocation = GetTokenLoc(I);\n      if (!TokenLocation.isValid())\n        break;\n\n      // Adapt the end range, because LocationCompare() reports\n      // RangeOverlap even for the not-inclusive end location.\n      const SourceLocation fixedEnd =\n          RefNameRange.getEnd().getLocWithOffset(-1);\n      RefNameRange = SourceRange(RefNameRange.getBegin(), fixedEnd);\n\n      const RangeComparisonResult ComparisonResult =\n          LocationCompare(SrcMgr, TokenLocation, RefNameRange);\n\n      if (ComparisonResult == RangeOverlap) {\n        Cursors[I++] = Cursor;\n      } else if (ComparisonResult == RangeBefore) {\n        ++I; // Not relevant token, check next one.\n      } else if (ComparisonResult == RangeAfter) {\n        break; // All tokens updated for current range, check next.\n      }\n    }\n  }\n}\n\nstatic enum CXChildVisitResult AnnotateTokensVisitor(CXCursor cursor,\n                                                     CXCursor parent,\n                                                     CXClientData client_data) {\n  return static_cast<AnnotateTokensWorker *>(client_data)\n      ->Visit(cursor, parent);\n}\n\nstatic bool AnnotateTokensPostChildrenVisitor(CXCursor cursor,\n                                              CXClientData client_data) {\n  return static_cast<AnnotateTokensWorker *>(client_data)\n      ->postVisitChildren(cursor);\n}\n\nnamespace {\n\n/// Uses the macro expansions in the preprocessing record to find\n/// and mark tokens that are macro arguments. This info is used by the\n/// AnnotateTokensWorker.\nclass MarkMacroArgTokensVisitor {\n  SourceManager &SM;\n  CXToken *Tokens;\n  unsigned NumTokens;\n  unsigned CurIdx;\n\npublic:\n  MarkMacroArgTokensVisitor(SourceManager &SM, CXToken *tokens,\n                            unsigned numTokens)\n      : SM(SM), Tokens(tokens), NumTokens(numTokens), CurIdx(0) {}\n\n  CXChildVisitResult visit(CXCursor cursor, CXCursor parent) {\n    if (cursor.kind != CXCursor_MacroExpansion)\n      return CXChildVisit_Continue;\n\n    SourceRange macroRange = getCursorMacroExpansion(cursor).getSourceRange();\n    if (macroRange.getBegin() == macroRange.getEnd())\n      return CXChildVisit_Continue; // it's not a function macro.\n\n    for (; CurIdx < NumTokens; ++CurIdx) {\n      if (!SM.isBeforeInTranslationUnit(getTokenLoc(CurIdx),\n                                        macroRange.getBegin()))\n        break;\n    }\n\n    if (CurIdx == NumTokens)\n      return CXChildVisit_Break;\n\n    for (; CurIdx < NumTokens; ++CurIdx) {\n      SourceLocation tokLoc = getTokenLoc(CurIdx);\n      if (!SM.isBeforeInTranslationUnit(tokLoc, macroRange.getEnd()))\n        break;\n\n      setFunctionMacroTokenLoc(CurIdx, SM.getMacroArgExpandedLocation(tokLoc));\n    }\n\n    if (CurIdx == NumTokens)\n      return CXChildVisit_Break;\n\n    return CXChildVisit_Continue;\n  }\n\nprivate:\n  CXToken &getTok(unsigned Idx) {\n    assert(Idx < NumTokens);\n    return Tokens[Idx];\n  }\n  const CXToken &getTok(unsigned Idx) const {\n    assert(Idx < NumTokens);\n    return Tokens[Idx];\n  }\n\n  SourceLocation getTokenLoc(unsigned tokI) {\n    return SourceLocation::getFromRawEncoding(getTok(tokI).int_data[1]);\n  }\n\n  void setFunctionMacroTokenLoc(unsigned tokI, SourceLocation loc) {\n    // The third field is reserved and currently not used. Use it here\n    // to mark macro arg expanded tokens with their expanded locations.\n    getTok(tokI).int_data[3] = loc.getRawEncoding();\n  }\n};\n\n} // end anonymous namespace\n\nstatic CXChildVisitResult\nMarkMacroArgTokensVisitorDelegate(CXCursor cursor, CXCursor parent,\n                                  CXClientData client_data) {\n  return static_cast<MarkMacroArgTokensVisitor *>(client_data)\n      ->visit(cursor, parent);\n}\n\n/// Used by \\c annotatePreprocessorTokens.\n/// \\returns true if lexing was finished, false otherwise.\nstatic bool lexNext(Lexer &Lex, Token &Tok, unsigned &NextIdx,\n                    unsigned NumTokens) {\n  if (NextIdx >= NumTokens)\n    return true;\n\n  ++NextIdx;\n  Lex.LexFromRawLexer(Tok);\n  return Tok.is(tok::eof);\n}\n\nstatic void annotatePreprocessorTokens(CXTranslationUnit TU,\n                                       SourceRange RegionOfInterest,\n                                       CXCursor *Cursors, CXToken *Tokens,\n                                       unsigned NumTokens) {\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n\n  Preprocessor &PP = CXXUnit->getPreprocessor();\n  SourceManager &SourceMgr = CXXUnit->getSourceManager();\n  std::pair<FileID, unsigned> BeginLocInfo =\n      SourceMgr.getDecomposedSpellingLoc(RegionOfInterest.getBegin());\n  std::pair<FileID, unsigned> EndLocInfo =\n      SourceMgr.getDecomposedSpellingLoc(RegionOfInterest.getEnd());\n\n  if (BeginLocInfo.first != EndLocInfo.first)\n    return;\n\n  StringRef Buffer;\n  bool Invalid = false;\n  Buffer = SourceMgr.getBufferData(BeginLocInfo.first, &Invalid);\n  if (Buffer.empty() || Invalid)\n    return;\n\n  Lexer Lex(SourceMgr.getLocForStartOfFile(BeginLocInfo.first),\n            CXXUnit->getASTContext().getLangOpts(), Buffer.begin(),\n            Buffer.data() + BeginLocInfo.second, Buffer.end());\n  Lex.SetCommentRetentionState(true);\n\n  unsigned NextIdx = 0;\n  // Lex tokens in raw mode until we hit the end of the range, to avoid\n  // entering #includes or expanding macros.\n  while (true) {\n    Token Tok;\n    if (lexNext(Lex, Tok, NextIdx, NumTokens))\n      break;\n    unsigned TokIdx = NextIdx - 1;\n    assert(Tok.getLocation() ==\n           SourceLocation::getFromRawEncoding(Tokens[TokIdx].int_data[1]));\n\n  reprocess:\n    if (Tok.is(tok::hash) && Tok.isAtStartOfLine()) {\n      // We have found a preprocessing directive. Annotate the tokens\n      // appropriately.\n      //\n      // FIXME: Some simple tests here could identify macro definitions and\n      // #undefs, to provide specific cursor kinds for those.\n\n      SourceLocation BeginLoc = Tok.getLocation();\n      if (lexNext(Lex, Tok, NextIdx, NumTokens))\n        break;\n\n      MacroInfo *MI = nullptr;\n      if (Tok.is(tok::raw_identifier) && Tok.getRawIdentifier() == \"define\") {\n        if (lexNext(Lex, Tok, NextIdx, NumTokens))\n          break;\n\n        if (Tok.is(tok::raw_identifier)) {\n          IdentifierInfo &II =\n              PP.getIdentifierTable().get(Tok.getRawIdentifier());\n          SourceLocation MappedTokLoc =\n              CXXUnit->mapLocationToPreamble(Tok.getLocation());\n          MI = getMacroInfo(II, MappedTokLoc, TU);\n        }\n      }\n\n      bool finished = false;\n      do {\n        if (lexNext(Lex, Tok, NextIdx, NumTokens)) {\n          finished = true;\n          break;\n        }\n        // If we are in a macro definition, check if the token was ever a\n        // macro name and annotate it if that's the case.\n        if (MI) {\n          SourceLocation SaveLoc = Tok.getLocation();\n          Tok.setLocation(CXXUnit->mapLocationToPreamble(SaveLoc));\n          MacroDefinitionRecord *MacroDef =\n              checkForMacroInMacroDefinition(MI, Tok, TU);\n          Tok.setLocation(SaveLoc);\n          if (MacroDef)\n            Cursors[NextIdx - 1] =\n                MakeMacroExpansionCursor(MacroDef, Tok.getLocation(), TU);\n        }\n      } while (!Tok.isAtStartOfLine());\n\n      unsigned LastIdx = finished ? NextIdx - 1 : NextIdx - 2;\n      assert(TokIdx <= LastIdx);\n      SourceLocation EndLoc =\n          SourceLocation::getFromRawEncoding(Tokens[LastIdx].int_data[1]);\n      CXCursor Cursor =\n          MakePreprocessingDirectiveCursor(SourceRange(BeginLoc, EndLoc), TU);\n\n      for (; TokIdx <= LastIdx; ++TokIdx)\n        updateCursorAnnotation(Cursors[TokIdx], Cursor);\n\n      if (finished)\n        break;\n      goto reprocess;\n    }\n  }\n}\n\n// This gets run a separate thread to avoid stack blowout.\nstatic void clang_annotateTokensImpl(CXTranslationUnit TU, ASTUnit *CXXUnit,\n                                     CXToken *Tokens, unsigned NumTokens,\n                                     CXCursor *Cursors) {\n  CIndexer *CXXIdx = TU->CIdx;\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForEditing))\n    setThreadBackgroundPriority();\n\n  // Determine the region of interest, which contains all of the tokens.\n  SourceRange RegionOfInterest;\n  RegionOfInterest.setBegin(\n      cxloc::translateSourceLocation(clang_getTokenLocation(TU, Tokens[0])));\n  RegionOfInterest.setEnd(cxloc::translateSourceLocation(\n      clang_getTokenLocation(TU, Tokens[NumTokens - 1])));\n\n  // Relex the tokens within the source range to look for preprocessing\n  // directives.\n  annotatePreprocessorTokens(TU, RegionOfInterest, Cursors, Tokens, NumTokens);\n\n  // If begin location points inside a macro argument, set it to the expansion\n  // location so we can have the full context when annotating semantically.\n  {\n    SourceManager &SM = CXXUnit->getSourceManager();\n    SourceLocation Loc =\n        SM.getMacroArgExpandedLocation(RegionOfInterest.getBegin());\n    if (Loc.isMacroID())\n      RegionOfInterest.setBegin(SM.getExpansionLoc(Loc));\n  }\n\n  if (CXXUnit->getPreprocessor().getPreprocessingRecord()) {\n    // Search and mark tokens that are macro argument expansions.\n    MarkMacroArgTokensVisitor Visitor(CXXUnit->getSourceManager(), Tokens,\n                                      NumTokens);\n    CursorVisitor MacroArgMarker(\n        TU, MarkMacroArgTokensVisitorDelegate, &Visitor,\n        /*VisitPreprocessorLast=*/true,\n        /*VisitIncludedEntities=*/false, RegionOfInterest);\n    MacroArgMarker.visitPreprocessedEntitiesInRegion();\n  }\n\n  // Annotate all of the source locations in the region of interest that map to\n  // a specific cursor.\n  AnnotateTokensWorker W(Tokens, Cursors, NumTokens, TU, RegionOfInterest);\n\n  // FIXME: We use a ridiculous stack size here because the data-recursion\n  // algorithm uses a large stack frame than the non-data recursive version,\n  // and AnnotationTokensWorker currently transforms the data-recursion\n  // algorithm back into a traditional recursion by explicitly calling\n  // VisitChildren().  We will need to remove this explicit recursive call.\n  W.AnnotateTokens();\n\n  // If we ran into any entities that involve context-sensitive keywords,\n  // take another pass through the tokens to mark them as such.\n  if (W.hasContextSensitiveKeywords()) {\n    for (unsigned I = 0; I != NumTokens; ++I) {\n      if (clang_getTokenKind(Tokens[I]) != CXToken_Identifier)\n        continue;\n\n      if (Cursors[I].kind == CXCursor_ObjCPropertyDecl) {\n        IdentifierInfo *II = static_cast<IdentifierInfo *>(Tokens[I].ptr_data);\n        if (const ObjCPropertyDecl *Property =\n                dyn_cast_or_null<ObjCPropertyDecl>(getCursorDecl(Cursors[I]))) {\n          if (Property->getPropertyAttributesAsWritten() != 0 &&\n              llvm::StringSwitch<bool>(II->getName())\n                  .Case(\"readonly\", true)\n                  .Case(\"assign\", true)\n                  .Case(\"unsafe_unretained\", true)\n                  .Case(\"readwrite\", true)\n                  .Case(\"retain\", true)\n                  .Case(\"copy\", true)\n                  .Case(\"nonatomic\", true)\n                  .Case(\"atomic\", true)\n                  .Case(\"getter\", true)\n                  .Case(\"setter\", true)\n                  .Case(\"strong\", true)\n                  .Case(\"weak\", true)\n                  .Case(\"class\", true)\n                  .Default(false))\n            Tokens[I].int_data[0] = CXToken_Keyword;\n        }\n        continue;\n      }\n\n      if (Cursors[I].kind == CXCursor_ObjCInstanceMethodDecl ||\n          Cursors[I].kind == CXCursor_ObjCClassMethodDecl) {\n        IdentifierInfo *II = static_cast<IdentifierInfo *>(Tokens[I].ptr_data);\n        if (llvm::StringSwitch<bool>(II->getName())\n                .Case(\"in\", true)\n                .Case(\"out\", true)\n                .Case(\"inout\", true)\n                .Case(\"oneway\", true)\n                .Case(\"bycopy\", true)\n                .Case(\"byref\", true)\n                .Default(false))\n          Tokens[I].int_data[0] = CXToken_Keyword;\n        continue;\n      }\n\n      if (Cursors[I].kind == CXCursor_CXXFinalAttr ||\n          Cursors[I].kind == CXCursor_CXXOverrideAttr) {\n        Tokens[I].int_data[0] = CXToken_Keyword;\n        continue;\n      }\n    }\n  }\n}\n\nvoid clang_annotateTokens(CXTranslationUnit TU, CXToken *Tokens,\n                          unsigned NumTokens, CXCursor *Cursors) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return;\n  }\n  if (NumTokens == 0 || !Tokens || !Cursors) {\n    LOG_FUNC_SECTION { *Log << \"<null input>\"; }\n    return;\n  }\n\n  LOG_FUNC_SECTION {\n    *Log << TU << ' ';\n    CXSourceLocation bloc = clang_getTokenLocation(TU, Tokens[0]);\n    CXSourceLocation eloc = clang_getTokenLocation(TU, Tokens[NumTokens - 1]);\n    *Log << clang_getRange(bloc, eloc);\n  }\n\n  // Any token we don't specifically annotate will have a NULL cursor.\n  CXCursor C = clang_getNullCursor();\n  for (unsigned I = 0; I != NumTokens; ++I)\n    Cursors[I] = C;\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return;\n\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n\n  auto AnnotateTokensImpl = [=]() {\n    clang_annotateTokensImpl(TU, CXXUnit, Tokens, NumTokens, Cursors);\n  };\n  llvm::CrashRecoveryContext CRC;\n  if (!RunSafely(CRC, AnnotateTokensImpl, GetSafetyThreadStackSize() * 2)) {\n    fprintf(stderr, \"libclang: crash detected while annotating tokens\\n\");\n  }\n}\n\n//===----------------------------------------------------------------------===//\n// Operations for querying linkage of a cursor.\n//===----------------------------------------------------------------------===//\n\nCXLinkageKind clang_getCursorLinkage(CXCursor cursor) {\n  if (!clang_isDeclaration(cursor.kind))\n    return CXLinkage_Invalid;\n\n  const Decl *D = cxcursor::getCursorDecl(cursor);\n  if (const NamedDecl *ND = dyn_cast_or_null<NamedDecl>(D))\n    switch (ND->getLinkageInternal()) {\n    case NoLinkage:\n    case VisibleNoLinkage:\n      return CXLinkage_NoLinkage;\n    case ModuleInternalLinkage:\n    case InternalLinkage:\n      return CXLinkage_Internal;\n    case UniqueExternalLinkage:\n      return CXLinkage_UniqueExternal;\n    case ModuleLinkage:\n    case ExternalLinkage:\n      return CXLinkage_External;\n    };\n\n  return CXLinkage_Invalid;\n}\n\n//===----------------------------------------------------------------------===//\n// Operations for querying visibility of a cursor.\n//===----------------------------------------------------------------------===//\n\nCXVisibilityKind clang_getCursorVisibility(CXCursor cursor) {\n  if (!clang_isDeclaration(cursor.kind))\n    return CXVisibility_Invalid;\n\n  const Decl *D = cxcursor::getCursorDecl(cursor);\n  if (const NamedDecl *ND = dyn_cast_or_null<NamedDecl>(D))\n    switch (ND->getVisibility()) {\n    case HiddenVisibility:\n      return CXVisibility_Hidden;\n    case ProtectedVisibility:\n      return CXVisibility_Protected;\n    case DefaultVisibility:\n      return CXVisibility_Default;\n    };\n\n  return CXVisibility_Invalid;\n}\n\n//===----------------------------------------------------------------------===//\n// Operations for querying language of a cursor.\n//===----------------------------------------------------------------------===//\n\nstatic CXLanguageKind getDeclLanguage(const Decl *D) {\n  if (!D)\n    return CXLanguage_C;\n\n  switch (D->getKind()) {\n  default:\n    break;\n  case Decl::ImplicitParam:\n  case Decl::ObjCAtDefsField:\n  case Decl::ObjCCategory:\n  case Decl::ObjCCategoryImpl:\n  case Decl::ObjCCompatibleAlias:\n  case Decl::ObjCImplementation:\n  case Decl::ObjCInterface:\n  case Decl::ObjCIvar:\n  case Decl::ObjCMethod:\n  case Decl::ObjCProperty:\n  case Decl::ObjCPropertyImpl:\n  case Decl::ObjCProtocol:\n  case Decl::ObjCTypeParam:\n    return CXLanguage_ObjC;\n  case Decl::CXXConstructor:\n  case Decl::CXXConversion:\n  case Decl::CXXDestructor:\n  case Decl::CXXMethod:\n  case Decl::CXXRecord:\n  case Decl::ClassTemplate:\n  case Decl::ClassTemplatePartialSpecialization:\n  case Decl::ClassTemplateSpecialization:\n  case Decl::Friend:\n  case Decl::FriendTemplate:\n  case Decl::FunctionTemplate:\n  case Decl::LinkageSpec:\n  case Decl::Namespace:\n  case Decl::NamespaceAlias:\n  case Decl::NonTypeTemplateParm:\n  case Decl::StaticAssert:\n  case Decl::TemplateTemplateParm:\n  case Decl::TemplateTypeParm:\n  case Decl::UnresolvedUsingTypename:\n  case Decl::UnresolvedUsingValue:\n  case Decl::Using:\n  case Decl::UsingDirective:\n  case Decl::UsingShadow:\n    return CXLanguage_CPlusPlus;\n  }\n\n  return CXLanguage_C;\n}\n\nstatic CXAvailabilityKind getCursorAvailabilityForDecl(const Decl *D) {\n  if (isa<FunctionDecl>(D) && cast<FunctionDecl>(D)->isDeleted())\n    return CXAvailability_NotAvailable;\n\n  switch (D->getAvailability()) {\n  case AR_Available:\n  case AR_NotYetIntroduced:\n    if (const EnumConstantDecl *EnumConst = dyn_cast<EnumConstantDecl>(D))\n      return getCursorAvailabilityForDecl(\n          cast<Decl>(EnumConst->getDeclContext()));\n    return CXAvailability_Available;\n\n  case AR_Deprecated:\n    return CXAvailability_Deprecated;\n\n  case AR_Unavailable:\n    return CXAvailability_NotAvailable;\n  }\n\n  llvm_unreachable(\"Unknown availability kind!\");\n}\n\nenum CXAvailabilityKind clang_getCursorAvailability(CXCursor cursor) {\n  if (clang_isDeclaration(cursor.kind))\n    if (const Decl *D = cxcursor::getCursorDecl(cursor))\n      return getCursorAvailabilityForDecl(D);\n\n  return CXAvailability_Available;\n}\n\nstatic CXVersion convertVersion(VersionTuple In) {\n  CXVersion Out = {-1, -1, -1};\n  if (In.empty())\n    return Out;\n\n  Out.Major = In.getMajor();\n\n  Optional<unsigned> Minor = In.getMinor();\n  if (Minor.hasValue())\n    Out.Minor = *Minor;\n  else\n    return Out;\n\n  Optional<unsigned> Subminor = In.getSubminor();\n  if (Subminor.hasValue())\n    Out.Subminor = *Subminor;\n\n  return Out;\n}\n\nstatic void getCursorPlatformAvailabilityForDecl(\n    const Decl *D, int *always_deprecated, CXString *deprecated_message,\n    int *always_unavailable, CXString *unavailable_message,\n    SmallVectorImpl<AvailabilityAttr *> &AvailabilityAttrs) {\n  bool HadAvailAttr = false;\n  for (auto A : D->attrs()) {\n    if (DeprecatedAttr *Deprecated = dyn_cast<DeprecatedAttr>(A)) {\n      HadAvailAttr = true;\n      if (always_deprecated)\n        *always_deprecated = 1;\n      if (deprecated_message) {\n        clang_disposeString(*deprecated_message);\n        *deprecated_message = cxstring::createDup(Deprecated->getMessage());\n      }\n      continue;\n    }\n\n    if (UnavailableAttr *Unavailable = dyn_cast<UnavailableAttr>(A)) {\n      HadAvailAttr = true;\n      if (always_unavailable)\n        *always_unavailable = 1;\n      if (unavailable_message) {\n        clang_disposeString(*unavailable_message);\n        *unavailable_message = cxstring::createDup(Unavailable->getMessage());\n      }\n      continue;\n    }\n\n    if (AvailabilityAttr *Avail = dyn_cast<AvailabilityAttr>(A)) {\n      AvailabilityAttrs.push_back(Avail);\n      HadAvailAttr = true;\n    }\n  }\n\n  if (!HadAvailAttr)\n    if (const EnumConstantDecl *EnumConst = dyn_cast<EnumConstantDecl>(D))\n      return getCursorPlatformAvailabilityForDecl(\n          cast<Decl>(EnumConst->getDeclContext()), always_deprecated,\n          deprecated_message, always_unavailable, unavailable_message,\n          AvailabilityAttrs);\n\n  if (AvailabilityAttrs.empty())\n    return;\n\n  llvm::sort(\n      AvailabilityAttrs, [](AvailabilityAttr *LHS, AvailabilityAttr *RHS) {\n        return LHS->getPlatform()->getName() < RHS->getPlatform()->getName();\n      });\n  ASTContext &Ctx = D->getASTContext();\n  auto It = std::unique(\n      AvailabilityAttrs.begin(), AvailabilityAttrs.end(),\n      [&Ctx](AvailabilityAttr *LHS, AvailabilityAttr *RHS) {\n        if (LHS->getPlatform() != RHS->getPlatform())\n          return false;\n\n        if (LHS->getIntroduced() == RHS->getIntroduced() &&\n            LHS->getDeprecated() == RHS->getDeprecated() &&\n            LHS->getObsoleted() == RHS->getObsoleted() &&\n            LHS->getMessage() == RHS->getMessage() &&\n            LHS->getReplacement() == RHS->getReplacement())\n          return true;\n\n        if ((!LHS->getIntroduced().empty() && !RHS->getIntroduced().empty()) ||\n            (!LHS->getDeprecated().empty() && !RHS->getDeprecated().empty()) ||\n            (!LHS->getObsoleted().empty() && !RHS->getObsoleted().empty()))\n          return false;\n\n        if (LHS->getIntroduced().empty() && !RHS->getIntroduced().empty())\n          LHS->setIntroduced(Ctx, RHS->getIntroduced());\n\n        if (LHS->getDeprecated().empty() && !RHS->getDeprecated().empty()) {\n          LHS->setDeprecated(Ctx, RHS->getDeprecated());\n          if (LHS->getMessage().empty())\n            LHS->setMessage(Ctx, RHS->getMessage());\n          if (LHS->getReplacement().empty())\n            LHS->setReplacement(Ctx, RHS->getReplacement());\n        }\n\n        if (LHS->getObsoleted().empty() && !RHS->getObsoleted().empty()) {\n          LHS->setObsoleted(Ctx, RHS->getObsoleted());\n          if (LHS->getMessage().empty())\n            LHS->setMessage(Ctx, RHS->getMessage());\n          if (LHS->getReplacement().empty())\n            LHS->setReplacement(Ctx, RHS->getReplacement());\n        }\n\n        return true;\n      });\n  AvailabilityAttrs.erase(It, AvailabilityAttrs.end());\n}\n\nint clang_getCursorPlatformAvailability(CXCursor cursor, int *always_deprecated,\n                                        CXString *deprecated_message,\n                                        int *always_unavailable,\n                                        CXString *unavailable_message,\n                                        CXPlatformAvailability *availability,\n                                        int availability_size) {\n  if (always_deprecated)\n    *always_deprecated = 0;\n  if (deprecated_message)\n    *deprecated_message = cxstring::createEmpty();\n  if (always_unavailable)\n    *always_unavailable = 0;\n  if (unavailable_message)\n    *unavailable_message = cxstring::createEmpty();\n\n  if (!clang_isDeclaration(cursor.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(cursor);\n  if (!D)\n    return 0;\n\n  SmallVector<AvailabilityAttr *, 8> AvailabilityAttrs;\n  getCursorPlatformAvailabilityForDecl(D, always_deprecated, deprecated_message,\n                                       always_unavailable, unavailable_message,\n                                       AvailabilityAttrs);\n  for (const auto &Avail :\n       llvm::enumerate(llvm::makeArrayRef(AvailabilityAttrs)\n                           .take_front(availability_size))) {\n    availability[Avail.index()].Platform =\n        cxstring::createDup(Avail.value()->getPlatform()->getName());\n    availability[Avail.index()].Introduced =\n        convertVersion(Avail.value()->getIntroduced());\n    availability[Avail.index()].Deprecated =\n        convertVersion(Avail.value()->getDeprecated());\n    availability[Avail.index()].Obsoleted =\n        convertVersion(Avail.value()->getObsoleted());\n    availability[Avail.index()].Unavailable = Avail.value()->getUnavailable();\n    availability[Avail.index()].Message =\n        cxstring::createDup(Avail.value()->getMessage());\n  }\n\n  return AvailabilityAttrs.size();\n}\n\nvoid clang_disposeCXPlatformAvailability(CXPlatformAvailability *availability) {\n  clang_disposeString(availability->Platform);\n  clang_disposeString(availability->Message);\n}\n\nCXLanguageKind clang_getCursorLanguage(CXCursor cursor) {\n  if (clang_isDeclaration(cursor.kind))\n    return getDeclLanguage(cxcursor::getCursorDecl(cursor));\n\n  return CXLanguage_Invalid;\n}\n\nCXTLSKind clang_getCursorTLSKind(CXCursor cursor) {\n  const Decl *D = cxcursor::getCursorDecl(cursor);\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    switch (VD->getTLSKind()) {\n    case VarDecl::TLS_None:\n      return CXTLS_None;\n    case VarDecl::TLS_Dynamic:\n      return CXTLS_Dynamic;\n    case VarDecl::TLS_Static:\n      return CXTLS_Static;\n    }\n  }\n\n  return CXTLS_None;\n}\n\n/// If the given cursor is the \"templated\" declaration\n/// describing a class or function template, return the class or\n/// function template.\nstatic const Decl *maybeGetTemplateCursor(const Decl *D) {\n  if (!D)\n    return nullptr;\n\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D))\n    if (FunctionTemplateDecl *FunTmpl = FD->getDescribedFunctionTemplate())\n      return FunTmpl;\n\n  if (const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(D))\n    if (ClassTemplateDecl *ClassTmpl = RD->getDescribedClassTemplate())\n      return ClassTmpl;\n\n  return D;\n}\n\nenum CX_StorageClass clang_Cursor_getStorageClass(CXCursor C) {\n  StorageClass sc = SC_None;\n  const Decl *D = getCursorDecl(C);\n  if (D) {\n    if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n      sc = FD->getStorageClass();\n    } else if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n      sc = VD->getStorageClass();\n    } else {\n      return CX_SC_Invalid;\n    }\n  } else {\n    return CX_SC_Invalid;\n  }\n  switch (sc) {\n  case SC_None:\n    return CX_SC_None;\n  case SC_Extern:\n    return CX_SC_Extern;\n  case SC_Static:\n    return CX_SC_Static;\n  case SC_PrivateExtern:\n    return CX_SC_PrivateExtern;\n  case SC_Auto:\n    return CX_SC_Auto;\n  case SC_Register:\n    return CX_SC_Register;\n  }\n  llvm_unreachable(\"Unhandled storage class!\");\n}\n\nCXCursor clang_getCursorSemanticParent(CXCursor cursor) {\n  if (clang_isDeclaration(cursor.kind)) {\n    if (const Decl *D = getCursorDecl(cursor)) {\n      const DeclContext *DC = D->getDeclContext();\n      if (!DC)\n        return clang_getNullCursor();\n\n      return MakeCXCursor(maybeGetTemplateCursor(cast<Decl>(DC)),\n                          getCursorTU(cursor));\n    }\n  }\n\n  if (clang_isStatement(cursor.kind) || clang_isExpression(cursor.kind)) {\n    if (const Decl *D = getCursorDecl(cursor))\n      return MakeCXCursor(D, getCursorTU(cursor));\n  }\n\n  return clang_getNullCursor();\n}\n\nCXCursor clang_getCursorLexicalParent(CXCursor cursor) {\n  if (clang_isDeclaration(cursor.kind)) {\n    if (const Decl *D = getCursorDecl(cursor)) {\n      const DeclContext *DC = D->getLexicalDeclContext();\n      if (!DC)\n        return clang_getNullCursor();\n\n      return MakeCXCursor(maybeGetTemplateCursor(cast<Decl>(DC)),\n                          getCursorTU(cursor));\n    }\n  }\n\n  // FIXME: Note that we can't easily compute the lexical context of a\n  // statement or expression, so we return nothing.\n  return clang_getNullCursor();\n}\n\nCXFile clang_getIncludedFile(CXCursor cursor) {\n  if (cursor.kind != CXCursor_InclusionDirective)\n    return nullptr;\n\n  const InclusionDirective *ID = getCursorInclusionDirective(cursor);\n  return const_cast<FileEntry *>(ID->getFile());\n}\n\nunsigned clang_Cursor_getObjCPropertyAttributes(CXCursor C, unsigned reserved) {\n  if (C.kind != CXCursor_ObjCPropertyDecl)\n    return CXObjCPropertyAttr_noattr;\n\n  unsigned Result = CXObjCPropertyAttr_noattr;\n  const ObjCPropertyDecl *PD = dyn_cast<ObjCPropertyDecl>(getCursorDecl(C));\n  ObjCPropertyAttribute::Kind Attr = PD->getPropertyAttributesAsWritten();\n\n#define SET_CXOBJCPROP_ATTR(A)                                                 \\\n  if (Attr & ObjCPropertyAttribute::kind_##A)                                  \\\n  Result |= CXObjCPropertyAttr_##A\n  SET_CXOBJCPROP_ATTR(readonly);\n  SET_CXOBJCPROP_ATTR(getter);\n  SET_CXOBJCPROP_ATTR(assign);\n  SET_CXOBJCPROP_ATTR(readwrite);\n  SET_CXOBJCPROP_ATTR(retain);\n  SET_CXOBJCPROP_ATTR(copy);\n  SET_CXOBJCPROP_ATTR(nonatomic);\n  SET_CXOBJCPROP_ATTR(setter);\n  SET_CXOBJCPROP_ATTR(atomic);\n  SET_CXOBJCPROP_ATTR(weak);\n  SET_CXOBJCPROP_ATTR(strong);\n  SET_CXOBJCPROP_ATTR(unsafe_unretained);\n  SET_CXOBJCPROP_ATTR(class);\n#undef SET_CXOBJCPROP_ATTR\n\n  return Result;\n}\n\nCXString clang_Cursor_getObjCPropertyGetterName(CXCursor C) {\n  if (C.kind != CXCursor_ObjCPropertyDecl)\n    return cxstring::createNull();\n\n  const ObjCPropertyDecl *PD = dyn_cast<ObjCPropertyDecl>(getCursorDecl(C));\n  Selector sel = PD->getGetterName();\n  if (sel.isNull())\n    return cxstring::createNull();\n\n  return cxstring::createDup(sel.getAsString());\n}\n\nCXString clang_Cursor_getObjCPropertySetterName(CXCursor C) {\n  if (C.kind != CXCursor_ObjCPropertyDecl)\n    return cxstring::createNull();\n\n  const ObjCPropertyDecl *PD = dyn_cast<ObjCPropertyDecl>(getCursorDecl(C));\n  Selector sel = PD->getSetterName();\n  if (sel.isNull())\n    return cxstring::createNull();\n\n  return cxstring::createDup(sel.getAsString());\n}\n\nunsigned clang_Cursor_getObjCDeclQualifiers(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return CXObjCDeclQualifier_None;\n\n  Decl::ObjCDeclQualifier QT = Decl::OBJC_TQ_None;\n  const Decl *D = getCursorDecl(C);\n  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D))\n    QT = MD->getObjCDeclQualifier();\n  else if (const ParmVarDecl *PD = dyn_cast<ParmVarDecl>(D))\n    QT = PD->getObjCDeclQualifier();\n  if (QT == Decl::OBJC_TQ_None)\n    return CXObjCDeclQualifier_None;\n\n  unsigned Result = CXObjCDeclQualifier_None;\n  if (QT & Decl::OBJC_TQ_In)\n    Result |= CXObjCDeclQualifier_In;\n  if (QT & Decl::OBJC_TQ_Inout)\n    Result |= CXObjCDeclQualifier_Inout;\n  if (QT & Decl::OBJC_TQ_Out)\n    Result |= CXObjCDeclQualifier_Out;\n  if (QT & Decl::OBJC_TQ_Bycopy)\n    Result |= CXObjCDeclQualifier_Bycopy;\n  if (QT & Decl::OBJC_TQ_Byref)\n    Result |= CXObjCDeclQualifier_Byref;\n  if (QT & Decl::OBJC_TQ_Oneway)\n    Result |= CXObjCDeclQualifier_Oneway;\n\n  return Result;\n}\n\nunsigned clang_Cursor_isObjCOptional(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = getCursorDecl(C);\n  if (const ObjCPropertyDecl *PD = dyn_cast<ObjCPropertyDecl>(D))\n    return PD->getPropertyImplementation() == ObjCPropertyDecl::Optional;\n  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D))\n    return MD->getImplementationControl() == ObjCMethodDecl::Optional;\n\n  return 0;\n}\n\nunsigned clang_Cursor_isVariadic(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = getCursorDecl(C);\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D))\n    return FD->isVariadic();\n  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D))\n    return MD->isVariadic();\n\n  return 0;\n}\n\nunsigned clang_Cursor_isExternalSymbol(CXCursor C, CXString *language,\n                                       CXString *definedIn,\n                                       unsigned *isGenerated) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = getCursorDecl(C);\n\n  if (auto *attr = D->getExternalSourceSymbolAttr()) {\n    if (language)\n      *language = cxstring::createDup(attr->getLanguage());\n    if (definedIn)\n      *definedIn = cxstring::createDup(attr->getDefinedIn());\n    if (isGenerated)\n      *isGenerated = attr->getGeneratedDeclaration();\n    return 1;\n  }\n  return 0;\n}\n\nCXSourceRange clang_Cursor_getCommentRange(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return clang_getNullRange();\n\n  const Decl *D = getCursorDecl(C);\n  ASTContext &Context = getCursorContext(C);\n  const RawComment *RC = Context.getRawCommentForAnyRedecl(D);\n  if (!RC)\n    return clang_getNullRange();\n\n  return cxloc::translateSourceRange(Context, RC->getSourceRange());\n}\n\nCXString clang_Cursor_getRawCommentText(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return cxstring::createNull();\n\n  const Decl *D = getCursorDecl(C);\n  ASTContext &Context = getCursorContext(C);\n  const RawComment *RC = Context.getRawCommentForAnyRedecl(D);\n  StringRef RawText =\n      RC ? RC->getRawText(Context.getSourceManager()) : StringRef();\n\n  // Don't duplicate the string because RawText points directly into source\n  // code.\n  return cxstring::createRef(RawText);\n}\n\nCXString clang_Cursor_getBriefCommentText(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return cxstring::createNull();\n\n  const Decl *D = getCursorDecl(C);\n  const ASTContext &Context = getCursorContext(C);\n  const RawComment *RC = Context.getRawCommentForAnyRedecl(D);\n\n  if (RC) {\n    StringRef BriefText = RC->getBriefText(Context);\n\n    // Don't duplicate the string because RawComment ensures that this memory\n    // will not go away.\n    return cxstring::createRef(BriefText);\n  }\n\n  return cxstring::createNull();\n}\n\nCXModule clang_Cursor_getModule(CXCursor C) {\n  if (C.kind == CXCursor_ModuleImportDecl) {\n    if (const ImportDecl *ImportD =\n            dyn_cast_or_null<ImportDecl>(getCursorDecl(C)))\n      return ImportD->getImportedModule();\n  }\n\n  return nullptr;\n}\n\nCXModule clang_getModuleForFile(CXTranslationUnit TU, CXFile File) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n  if (!File)\n    return nullptr;\n  FileEntry *FE = static_cast<FileEntry *>(File);\n\n  ASTUnit &Unit = *cxtu::getASTUnit(TU);\n  HeaderSearch &HS = Unit.getPreprocessor().getHeaderSearchInfo();\n  ModuleMap::KnownHeader Header = HS.findModuleForHeader(FE);\n\n  return Header.getModule();\n}\n\nCXFile clang_Module_getASTFile(CXModule CXMod) {\n  if (!CXMod)\n    return nullptr;\n  Module *Mod = static_cast<Module *>(CXMod);\n  if (auto File = Mod->getASTFile())\n    return const_cast<FileEntry *>(&File->getFileEntry());\n  return nullptr;\n}\n\nCXModule clang_Module_getParent(CXModule CXMod) {\n  if (!CXMod)\n    return nullptr;\n  Module *Mod = static_cast<Module *>(CXMod);\n  return Mod->Parent;\n}\n\nCXString clang_Module_getName(CXModule CXMod) {\n  if (!CXMod)\n    return cxstring::createEmpty();\n  Module *Mod = static_cast<Module *>(CXMod);\n  return cxstring::createDup(Mod->Name);\n}\n\nCXString clang_Module_getFullName(CXModule CXMod) {\n  if (!CXMod)\n    return cxstring::createEmpty();\n  Module *Mod = static_cast<Module *>(CXMod);\n  return cxstring::createDup(Mod->getFullModuleName());\n}\n\nint clang_Module_isSystem(CXModule CXMod) {\n  if (!CXMod)\n    return 0;\n  Module *Mod = static_cast<Module *>(CXMod);\n  return Mod->IsSystem;\n}\n\nunsigned clang_Module_getNumTopLevelHeaders(CXTranslationUnit TU,\n                                            CXModule CXMod) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return 0;\n  }\n  if (!CXMod)\n    return 0;\n  Module *Mod = static_cast<Module *>(CXMod);\n  FileManager &FileMgr = cxtu::getASTUnit(TU)->getFileManager();\n  ArrayRef<const FileEntry *> TopHeaders = Mod->getTopHeaders(FileMgr);\n  return TopHeaders.size();\n}\n\nCXFile clang_Module_getTopLevelHeader(CXTranslationUnit TU, CXModule CXMod,\n                                      unsigned Index) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n  if (!CXMod)\n    return nullptr;\n  Module *Mod = static_cast<Module *>(CXMod);\n  FileManager &FileMgr = cxtu::getASTUnit(TU)->getFileManager();\n\n  ArrayRef<const FileEntry *> TopHeaders = Mod->getTopHeaders(FileMgr);\n  if (Index < TopHeaders.size())\n    return const_cast<FileEntry *>(TopHeaders[Index]);\n\n  return nullptr;\n}\n\n//===----------------------------------------------------------------------===//\n// C++ AST instrospection.\n//===----------------------------------------------------------------------===//\n\nunsigned clang_CXXConstructor_isDefaultConstructor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXConstructorDecl *Constructor =\n      D ? dyn_cast_or_null<CXXConstructorDecl>(D->getAsFunction()) : nullptr;\n  return (Constructor && Constructor->isDefaultConstructor()) ? 1 : 0;\n}\n\nunsigned clang_CXXConstructor_isCopyConstructor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXConstructorDecl *Constructor =\n      D ? dyn_cast_or_null<CXXConstructorDecl>(D->getAsFunction()) : nullptr;\n  return (Constructor && Constructor->isCopyConstructor()) ? 1 : 0;\n}\n\nunsigned clang_CXXConstructor_isMoveConstructor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXConstructorDecl *Constructor =\n      D ? dyn_cast_or_null<CXXConstructorDecl>(D->getAsFunction()) : nullptr;\n  return (Constructor && Constructor->isMoveConstructor()) ? 1 : 0;\n}\n\nunsigned clang_CXXConstructor_isConvertingConstructor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXConstructorDecl *Constructor =\n      D ? dyn_cast_or_null<CXXConstructorDecl>(D->getAsFunction()) : nullptr;\n  // Passing 'false' excludes constructors marked 'explicit'.\n  return (Constructor && Constructor->isConvertingConstructor(false)) ? 1 : 0;\n}\n\nunsigned clang_CXXField_isMutable(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  if (const auto D = cxcursor::getCursorDecl(C))\n    if (const auto FD = dyn_cast_or_null<FieldDecl>(D))\n      return FD->isMutable() ? 1 : 0;\n  return 0;\n}\n\nunsigned clang_CXXMethod_isPureVirtual(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->isVirtual() && Method->isPure()) ? 1 : 0;\n}\n\nunsigned clang_CXXMethod_isConst(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->getMethodQualifiers().hasConst()) ? 1 : 0;\n}\n\nunsigned clang_CXXMethod_isDefaulted(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->isDefaulted()) ? 1 : 0;\n}\n\nunsigned clang_CXXMethod_isStatic(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->isStatic()) ? 1 : 0;\n}\n\nunsigned clang_CXXMethod_isVirtual(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->isVirtual()) ? 1 : 0;\n}\n\nunsigned clang_CXXRecord_isAbstract(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const auto *D = cxcursor::getCursorDecl(C);\n  const auto *RD = dyn_cast_or_null<CXXRecordDecl>(D);\n  if (RD)\n    RD = RD->getDefinition();\n  return (RD && RD->isAbstract()) ? 1 : 0;\n}\n\nunsigned clang_EnumDecl_isScoped(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  auto *Enum = dyn_cast_or_null<EnumDecl>(D);\n  return (Enum && Enum->isScoped()) ? 1 : 0;\n}\n\n//===----------------------------------------------------------------------===//\n// Attribute introspection.\n//===----------------------------------------------------------------------===//\n\nCXType clang_getIBOutletCollectionType(CXCursor C) {\n  if (C.kind != CXCursor_IBOutletCollectionAttr)\n    return cxtype::MakeCXType(QualType(), cxcursor::getCursorTU(C));\n\n  const IBOutletCollectionAttr *A =\n      cast<IBOutletCollectionAttr>(cxcursor::getCursorAttr(C));\n\n  return cxtype::MakeCXType(A->getInterface(), cxcursor::getCursorTU(C));\n}\n\n//===----------------------------------------------------------------------===//\n// Inspecting memory usage.\n//===----------------------------------------------------------------------===//\n\ntypedef std::vector<CXTUResourceUsageEntry> MemUsageEntries;\n\nstatic inline void createCXTUResourceUsageEntry(MemUsageEntries &entries,\n                                                enum CXTUResourceUsageKind k,\n                                                unsigned long amount) {\n  CXTUResourceUsageEntry entry = {k, amount};\n  entries.push_back(entry);\n}\n\nconst char *clang_getTUResourceUsageName(CXTUResourceUsageKind kind) {\n  const char *str = \"\";\n  switch (kind) {\n  case CXTUResourceUsage_AST:\n    str = \"ASTContext: expressions, declarations, and types\";\n    break;\n  case CXTUResourceUsage_Identifiers:\n    str = \"ASTContext: identifiers\";\n    break;\n  case CXTUResourceUsage_Selectors:\n    str = \"ASTContext: selectors\";\n    break;\n  case CXTUResourceUsage_GlobalCompletionResults:\n    str = \"Code completion: cached global results\";\n    break;\n  case CXTUResourceUsage_SourceManagerContentCache:\n    str = \"SourceManager: content cache allocator\";\n    break;\n  case CXTUResourceUsage_AST_SideTables:\n    str = \"ASTContext: side tables\";\n    break;\n  case CXTUResourceUsage_SourceManager_Membuffer_Malloc:\n    str = \"SourceManager: malloc'ed memory buffers\";\n    break;\n  case CXTUResourceUsage_SourceManager_Membuffer_MMap:\n    str = \"SourceManager: mmap'ed memory buffers\";\n    break;\n  case CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc:\n    str = \"ExternalASTSource: malloc'ed memory buffers\";\n    break;\n  case CXTUResourceUsage_ExternalASTSource_Membuffer_MMap:\n    str = \"ExternalASTSource: mmap'ed memory buffers\";\n    break;\n  case CXTUResourceUsage_Preprocessor:\n    str = \"Preprocessor: malloc'ed memory\";\n    break;\n  case CXTUResourceUsage_PreprocessingRecord:\n    str = \"Preprocessor: PreprocessingRecord\";\n    break;\n  case CXTUResourceUsage_SourceManager_DataStructures:\n    str = \"SourceManager: data structures and tables\";\n    break;\n  case CXTUResourceUsage_Preprocessor_HeaderSearch:\n    str = \"Preprocessor: header search tables\";\n    break;\n  }\n  return str;\n}\n\nCXTUResourceUsage clang_getCXTUResourceUsage(CXTranslationUnit TU) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    CXTUResourceUsage usage = {(void *)nullptr, 0, nullptr};\n    return usage;\n  }\n\n  ASTUnit *astUnit = cxtu::getASTUnit(TU);\n  std::unique_ptr<MemUsageEntries> entries(new MemUsageEntries());\n  ASTContext &astContext = astUnit->getASTContext();\n\n  // How much memory is used by AST nodes and types?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_AST,\n      (unsigned long)astContext.getASTAllocatedMemory());\n\n  // How much memory is used by identifiers?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_Identifiers,\n      (unsigned long)astContext.Idents.getAllocator().getTotalMemory());\n\n  // How much memory is used for selectors?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_Selectors,\n      (unsigned long)astContext.Selectors.getTotalMemory());\n\n  // How much memory is used by ASTContext's side tables?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_AST_SideTables,\n      (unsigned long)astContext.getSideTableAllocatedMemory());\n\n  // How much memory is used for caching global code completion results?\n  unsigned long completionBytes = 0;\n  if (GlobalCodeCompletionAllocator *completionAllocator =\n          astUnit->getCachedCompletionAllocator().get()) {\n    completionBytes = completionAllocator->getTotalMemory();\n  }\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_GlobalCompletionResults, completionBytes);\n\n  // How much memory is being used by SourceManager's content cache?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_SourceManagerContentCache,\n      (unsigned long)astContext.getSourceManager().getContentCacheSize());\n\n  // How much memory is being used by the MemoryBuffer's in SourceManager?\n  const SourceManager::MemoryBufferSizes &srcBufs =\n      astUnit->getSourceManager().getMemoryBufferSizes();\n\n  createCXTUResourceUsageEntry(*entries,\n                               CXTUResourceUsage_SourceManager_Membuffer_Malloc,\n                               (unsigned long)srcBufs.malloc_bytes);\n  createCXTUResourceUsageEntry(*entries,\n                               CXTUResourceUsage_SourceManager_Membuffer_MMap,\n                               (unsigned long)srcBufs.mmap_bytes);\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_SourceManager_DataStructures,\n      (unsigned long)astContext.getSourceManager().getDataStructureSizes());\n\n  // How much memory is being used by the ExternalASTSource?\n  if (ExternalASTSource *esrc = astContext.getExternalSource()) {\n    const ExternalASTSource::MemoryBufferSizes &sizes =\n        esrc->getMemoryBufferSizes();\n\n    createCXTUResourceUsageEntry(\n        *entries, CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc,\n        (unsigned long)sizes.malloc_bytes);\n    createCXTUResourceUsageEntry(\n        *entries, CXTUResourceUsage_ExternalASTSource_Membuffer_MMap,\n        (unsigned long)sizes.mmap_bytes);\n  }\n\n  // How much memory is being used by the Preprocessor?\n  Preprocessor &pp = astUnit->getPreprocessor();\n  createCXTUResourceUsageEntry(*entries, CXTUResourceUsage_Preprocessor,\n                               pp.getTotalMemory());\n\n  if (PreprocessingRecord *pRec = pp.getPreprocessingRecord()) {\n    createCXTUResourceUsageEntry(*entries,\n                                 CXTUResourceUsage_PreprocessingRecord,\n                                 pRec->getTotalMemory());\n  }\n\n  createCXTUResourceUsageEntry(*entries,\n                               CXTUResourceUsage_Preprocessor_HeaderSearch,\n                               pp.getHeaderSearchInfo().getTotalMemory());\n\n  CXTUResourceUsage usage = {(void *)entries.get(), (unsigned)entries->size(),\n                             !entries->empty() ? &(*entries)[0] : nullptr};\n  (void)entries.release();\n  return usage;\n}\n\nvoid clang_disposeCXTUResourceUsage(CXTUResourceUsage usage) {\n  if (usage.data)\n    delete (MemUsageEntries *)usage.data;\n}\n\nCXSourceRangeList *clang_getSkippedRanges(CXTranslationUnit TU, CXFile file) {\n  CXSourceRangeList *skipped = new CXSourceRangeList;\n  skipped->count = 0;\n  skipped->ranges = nullptr;\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return skipped;\n  }\n\n  if (!file)\n    return skipped;\n\n  ASTUnit *astUnit = cxtu::getASTUnit(TU);\n  PreprocessingRecord *ppRec =\n      astUnit->getPreprocessor().getPreprocessingRecord();\n  if (!ppRec)\n    return skipped;\n\n  ASTContext &Ctx = astUnit->getASTContext();\n  SourceManager &sm = Ctx.getSourceManager();\n  FileEntry *fileEntry = static_cast<FileEntry *>(file);\n  FileID wantedFileID = sm.translateFile(fileEntry);\n  bool isMainFile = wantedFileID == sm.getMainFileID();\n\n  const std::vector<SourceRange> &SkippedRanges = ppRec->getSkippedRanges();\n  std::vector<SourceRange> wantedRanges;\n  for (std::vector<SourceRange>::const_iterator i = SkippedRanges.begin(),\n                                                ei = SkippedRanges.end();\n       i != ei; ++i) {\n    if (sm.getFileID(i->getBegin()) == wantedFileID ||\n        sm.getFileID(i->getEnd()) == wantedFileID)\n      wantedRanges.push_back(*i);\n    else if (isMainFile && (astUnit->isInPreambleFileID(i->getBegin()) ||\n                            astUnit->isInPreambleFileID(i->getEnd())))\n      wantedRanges.push_back(*i);\n  }\n\n  skipped->count = wantedRanges.size();\n  skipped->ranges = new CXSourceRange[skipped->count];\n  for (unsigned i = 0, ei = skipped->count; i != ei; ++i)\n    skipped->ranges[i] = cxloc::translateSourceRange(Ctx, wantedRanges[i]);\n\n  return skipped;\n}\n\nCXSourceRangeList *clang_getAllSkippedRanges(CXTranslationUnit TU) {\n  CXSourceRangeList *skipped = new CXSourceRangeList;\n  skipped->count = 0;\n  skipped->ranges = nullptr;\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return skipped;\n  }\n\n  ASTUnit *astUnit = cxtu::getASTUnit(TU);\n  PreprocessingRecord *ppRec =\n      astUnit->getPreprocessor().getPreprocessingRecord();\n  if (!ppRec)\n    return skipped;\n\n  ASTContext &Ctx = astUnit->getASTContext();\n\n  const std::vector<SourceRange> &SkippedRanges = ppRec->getSkippedRanges();\n\n  skipped->count = SkippedRanges.size();\n  skipped->ranges = new CXSourceRange[skipped->count];\n  for (unsigned i = 0, ei = skipped->count; i != ei; ++i)\n    skipped->ranges[i] = cxloc::translateSourceRange(Ctx, SkippedRanges[i]);\n\n  return skipped;\n}\n\nvoid clang_disposeSourceRangeList(CXSourceRangeList *ranges) {\n  if (ranges) {\n    delete[] ranges->ranges;\n    delete ranges;\n  }\n}\n\nvoid clang::PrintLibclangResourceUsage(CXTranslationUnit TU) {\n  CXTUResourceUsage Usage = clang_getCXTUResourceUsage(TU);\n  for (unsigned I = 0; I != Usage.numEntries; ++I)\n    fprintf(stderr, \"  %s: %lu\\n\",\n            clang_getTUResourceUsageName(Usage.entries[I].kind),\n            Usage.entries[I].amount);\n\n  clang_disposeCXTUResourceUsage(Usage);\n}\n\nCXCursor clang_Cursor_getVarDeclInitializer(CXCursor cursor) {\n  const Decl *const D = getCursorDecl(cursor);\n  if (!D)\n    return clang_getNullCursor();\n  const auto *const VD = dyn_cast<VarDecl>(D);\n  if (!VD)\n    return clang_getNullCursor();\n  const Expr *const Init = VD->getInit();\n  if (!Init)\n    return clang_getNullCursor();\n\n  return cxcursor::MakeCXCursor(Init, VD, cxcursor::getCursorTU(cursor));\n}\n\nint clang_Cursor_hasVarDeclGlobalStorage(CXCursor cursor) {\n  const Decl *const D = getCursorDecl(cursor);\n  if (!D)\n    return -1;\n  const auto *const VD = dyn_cast<VarDecl>(D);\n  if (!VD)\n    return -1;\n\n  return VD->hasGlobalStorage();\n}\n\nint clang_Cursor_hasVarDeclExternalStorage(CXCursor cursor) {\n  const Decl *const D = getCursorDecl(cursor);\n  if (!D)\n    return -1;\n  const auto *const VD = dyn_cast<VarDecl>(D);\n  if (!VD)\n    return -1;\n\n  return VD->hasExternalStorage();\n}\n\n//===----------------------------------------------------------------------===//\n// Misc. utility functions.\n//===----------------------------------------------------------------------===//\n\n/// Default to using our desired 8 MB stack size on \"safety\" threads.\nstatic unsigned SafetyStackThreadSize = DesiredStackSize;\n\nnamespace clang {\n\nbool RunSafely(llvm::CrashRecoveryContext &CRC, llvm::function_ref<void()> Fn,\n               unsigned Size) {\n  if (!Size)\n    Size = GetSafetyThreadStackSize();\n  if (Size && !getenv(\"LIBCLANG_NOTHREADS\"))\n    return CRC.RunSafelyOnThread(Fn, Size);\n  return CRC.RunSafely(Fn);\n}\n\nunsigned GetSafetyThreadStackSize() { return SafetyStackThreadSize; }\n\nvoid SetSafetyThreadStackSize(unsigned Value) { SafetyStackThreadSize = Value; }\n\n} // namespace clang\n\nvoid clang::setThreadBackgroundPriority() {\n  if (getenv(\"LIBCLANG_BGPRIO_DISABLE\"))\n    return;\n\n#if LLVM_ENABLE_THREADS\n  llvm::set_thread_priority(llvm::ThreadPriority::Background);\n#endif\n}\n\nvoid cxindex::printDiagsToStderr(ASTUnit *Unit) {\n  if (!Unit)\n    return;\n\n  for (ASTUnit::stored_diag_iterator D = Unit->stored_diag_begin(),\n                                     DEnd = Unit->stored_diag_end();\n       D != DEnd; ++D) {\n    CXStoredDiagnostic Diag(*D, Unit->getLangOpts());\n    CXString Msg =\n        clang_formatDiagnostic(&Diag, clang_defaultDiagnosticDisplayOptions());\n    fprintf(stderr, \"%s\\n\", clang_getCString(Msg));\n    clang_disposeString(Msg);\n  }\n#ifdef _WIN32\n  // On Windows, force a flush, since there may be multiple copies of\n  // stderr and stdout in the file system, all with different buffers\n  // but writing to the same device.\n  fflush(stderr);\n#endif\n}\n\nMacroInfo *cxindex::getMacroInfo(const IdentifierInfo &II,\n                                 SourceLocation MacroDefLoc,\n                                 CXTranslationUnit TU) {\n  if (MacroDefLoc.isInvalid() || !TU)\n    return nullptr;\n  if (!II.hadMacroDefinition())\n    return nullptr;\n\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n  Preprocessor &PP = Unit->getPreprocessor();\n  MacroDirective *MD = PP.getLocalMacroDirectiveHistory(&II);\n  if (MD) {\n    for (MacroDirective::DefInfo Def = MD->getDefinition(); Def;\n         Def = Def.getPreviousDefinition()) {\n      if (MacroDefLoc == Def.getMacroInfo()->getDefinitionLoc())\n        return Def.getMacroInfo();\n    }\n  }\n\n  return nullptr;\n}\n\nconst MacroInfo *cxindex::getMacroInfo(const MacroDefinitionRecord *MacroDef,\n                                       CXTranslationUnit TU) {\n  if (!MacroDef || !TU)\n    return nullptr;\n  const IdentifierInfo *II = MacroDef->getName();\n  if (!II)\n    return nullptr;\n\n  return getMacroInfo(*II, MacroDef->getLocation(), TU);\n}\n\nMacroDefinitionRecord *\ncxindex::checkForMacroInMacroDefinition(const MacroInfo *MI, const Token &Tok,\n                                        CXTranslationUnit TU) {\n  if (!MI || !TU)\n    return nullptr;\n  if (Tok.isNot(tok::raw_identifier))\n    return nullptr;\n\n  if (MI->getNumTokens() == 0)\n    return nullptr;\n  SourceRange DefRange(MI->getReplacementToken(0).getLocation(),\n                       MI->getDefinitionEndLoc());\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n\n  // Check that the token is inside the definition and not its argument list.\n  SourceManager &SM = Unit->getSourceManager();\n  if (SM.isBeforeInTranslationUnit(Tok.getLocation(), DefRange.getBegin()))\n    return nullptr;\n  if (SM.isBeforeInTranslationUnit(DefRange.getEnd(), Tok.getLocation()))\n    return nullptr;\n\n  Preprocessor &PP = Unit->getPreprocessor();\n  PreprocessingRecord *PPRec = PP.getPreprocessingRecord();\n  if (!PPRec)\n    return nullptr;\n\n  IdentifierInfo &II = PP.getIdentifierTable().get(Tok.getRawIdentifier());\n  if (!II.hadMacroDefinition())\n    return nullptr;\n\n  // Check that the identifier is not one of the macro arguments.\n  if (std::find(MI->param_begin(), MI->param_end(), &II) != MI->param_end())\n    return nullptr;\n\n  MacroDirective *InnerMD = PP.getLocalMacroDirectiveHistory(&II);\n  if (!InnerMD)\n    return nullptr;\n\n  return PPRec->findMacroDefinition(InnerMD->getMacroInfo());\n}\n\nMacroDefinitionRecord *\ncxindex::checkForMacroInMacroDefinition(const MacroInfo *MI, SourceLocation Loc,\n                                        CXTranslationUnit TU) {\n  if (Loc.isInvalid() || !MI || !TU)\n    return nullptr;\n\n  if (MI->getNumTokens() == 0)\n    return nullptr;\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n  Preprocessor &PP = Unit->getPreprocessor();\n  if (!PP.getPreprocessingRecord())\n    return nullptr;\n  Loc = Unit->getSourceManager().getSpellingLoc(Loc);\n  Token Tok;\n  if (PP.getRawToken(Loc, Tok))\n    return nullptr;\n\n  return checkForMacroInMacroDefinition(MI, Tok, TU);\n}\n\nCXString clang_getClangVersion() {\n  return cxstring::createDup(getClangFullVersion());\n}\n\nLogger &cxindex::Logger::operator<<(CXTranslationUnit TU) {\n  if (TU) {\n    if (ASTUnit *Unit = cxtu::getASTUnit(TU)) {\n      LogOS << '<' << Unit->getMainFileName() << '>';\n      if (Unit->isMainFileAST())\n        LogOS << \" (\" << Unit->getASTFileName() << ')';\n      return *this;\n    }\n  } else {\n    LogOS << \"<NULL TU>\";\n  }\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(const FileEntry *FE) {\n  *this << FE->getName();\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(CXCursor cursor) {\n  CXString cursorName = clang_getCursorDisplayName(cursor);\n  *this << cursorName << \"@\" << clang_getCursorLocation(cursor);\n  clang_disposeString(cursorName);\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(CXSourceLocation Loc) {\n  CXFile File;\n  unsigned Line, Column;\n  clang_getFileLocation(Loc, &File, &Line, &Column, nullptr);\n  CXString FileName = clang_getFileName(File);\n  *this << llvm::format(\"(%s:%d:%d)\", clang_getCString(FileName), Line, Column);\n  clang_disposeString(FileName);\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(CXSourceRange range) {\n  CXSourceLocation BLoc = clang_getRangeStart(range);\n  CXSourceLocation ELoc = clang_getRangeEnd(range);\n\n  CXFile BFile;\n  unsigned BLine, BColumn;\n  clang_getFileLocation(BLoc, &BFile, &BLine, &BColumn, nullptr);\n\n  CXFile EFile;\n  unsigned ELine, EColumn;\n  clang_getFileLocation(ELoc, &EFile, &ELine, &EColumn, nullptr);\n\n  CXString BFileName = clang_getFileName(BFile);\n  if (BFile == EFile) {\n    *this << llvm::format(\"[%s %d:%d-%d:%d]\", clang_getCString(BFileName),\n                          BLine, BColumn, ELine, EColumn);\n  } else {\n    CXString EFileName = clang_getFileName(EFile);\n    *this << llvm::format(\"[%s:%d:%d - \", clang_getCString(BFileName), BLine,\n                          BColumn)\n          << llvm::format(\"%s:%d:%d]\", clang_getCString(EFileName), ELine,\n                          EColumn);\n    clang_disposeString(EFileName);\n  }\n  clang_disposeString(BFileName);\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(CXString Str) {\n  *this << clang_getCString(Str);\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(const llvm::format_object_base &Fmt) {\n  LogOS << Fmt;\n  return *this;\n}\n\nstatic llvm::ManagedStatic<std::mutex> LoggingMutex;\n\ncxindex::Logger::~Logger() {\n  std::lock_guard<std::mutex> L(*LoggingMutex);\n\n  static llvm::TimeRecord sBeginTR = llvm::TimeRecord::getCurrentTime();\n\n  raw_ostream &OS = llvm::errs();\n  OS << \"[libclang:\" << Name << ':';\n\n#ifdef USE_DARWIN_THREADS\n  // TODO: Portability.\n  mach_port_t tid = pthread_mach_thread_np(pthread_self());\n  OS << tid << ':';\n#endif\n\n  llvm::TimeRecord TR = llvm::TimeRecord::getCurrentTime();\n  OS << llvm::format(\"%7.4f] \", TR.getWallTime() - sBeginTR.getWallTime());\n  OS << Msg << '\\n';\n\n  if (Trace) {\n    llvm::sys::PrintStackTrace(OS);\n    OS << \"--------------------------------------------------\\n\";\n  }\n}\n\n#ifdef CLANG_TOOL_EXTRA_BUILD\n// This anchor is used to force the linker to link the clang-tidy plugin.\nextern volatile int ClangTidyPluginAnchorSource;\nstatic int LLVM_ATTRIBUTE_UNUSED ClangTidyPluginAnchorDestination =\n    ClangTidyPluginAnchorSource;\n\n// This anchor is used to force the linker to link the clang-include-fixer\n// plugin.\nextern volatile int ClangIncludeFixerPluginAnchorSource;\nstatic int LLVM_ATTRIBUTE_UNUSED ClangIncludeFixerPluginAnchorDestination =\n    ClangIncludeFixerPluginAnchorSource;\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CursorVisitor.h", "content": "//===- CursorVisitor.h - CursorVisitor interface ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_LIBCLANG_CURSORVISITOR_H\n#define LLVM_CLANG_TOOLS_LIBCLANG_CURSORVISITOR_H\n\n#include \"CXCursor.h\"\n#include \"CXTranslationUnit.h\"\n#include \"Index_Internal.h\"\n#include \"clang/AST/DeclVisitor.h\"\n#include \"clang/AST/TypeLocVisitor.h\"\n\nnamespace clang {\nclass PreprocessingRecord;\nclass ASTUnit;\n\nnamespace cxcursor {\n\nclass VisitorJob {\npublic:\n  enum Kind {\n    DeclVisitKind,\n    StmtVisitKind,\n    MemberExprPartsKind,\n    TypeLocVisitKind,\n    OverloadExprPartsKind,\n    DeclRefExprPartsKind,\n    LabelRefVisitKind,\n    ExplicitTemplateArgsVisitKind,\n    NestedNameSpecifierLocVisitKind,\n    DeclarationNameInfoVisitKind,\n    MemberRefVisitKind,\n    SizeOfPackExprPartsKind,\n    LambdaExprPartsKind,\n    PostChildrenVisitKind\n  };\n\nprotected:\n  const void *data[3];\n  CXCursor parent;\n  Kind K;\n  VisitorJob(CXCursor C, Kind k, const void *d1, const void *d2 = nullptr,\n             const void *d3 = nullptr)\n      : parent(C), K(k) {\n    data[0] = d1;\n    data[1] = d2;\n    data[2] = d3;\n  }\n\npublic:\n  Kind getKind() const { return K; }\n  const CXCursor &getParent() const { return parent; }\n};\n\ntypedef SmallVector<VisitorJob, 10> VisitorWorkList;\n\n// Cursor visitor.\nclass CursorVisitor : public DeclVisitor<CursorVisitor, bool>,\n                      public TypeLocVisitor<CursorVisitor, bool> {\npublic:\n  /// Callback called after child nodes of a cursor have been visited.\n  /// Return true to break visitation or false to continue.\n  typedef bool (*PostChildrenVisitorTy)(CXCursor cursor,\n                                        CXClientData client_data);\n\nprivate:\n  /// The translation unit we are traversing.\n  CXTranslationUnit TU;\n  ASTUnit *AU;\n\n  /// The parent cursor whose children we are traversing.\n  CXCursor Parent;\n\n  /// The declaration that serves at the parent of any statement or\n  /// expression nodes.\n  const Decl *StmtParent;\n\n  /// The visitor function.\n  CXCursorVisitor Visitor;\n\n  PostChildrenVisitorTy PostChildrenVisitor;\n\n  /// The opaque client data, to be passed along to the visitor.\n  CXClientData ClientData;\n\n  /// Whether we should visit the preprocessing record entries last,\n  /// after visiting other declarations.\n  bool VisitPreprocessorLast;\n\n  /// Whether we should visit declarations or preprocessing record\n  /// entries that are #included inside the \\arg RegionOfInterest.\n  bool VisitIncludedEntities;\n\n  /// When valid, a source range to which the cursor should restrict\n  /// its search.\n  SourceRange RegionOfInterest;\n\n  /// Whether we should only visit declarations and not preprocessing\n  /// record entries.\n  bool VisitDeclsOnly;\n\n  // FIXME: Eventually remove.  This part of a hack to support proper\n  // iteration over all Decls contained lexically within an ObjC container.\n  DeclContext::decl_iterator *DI_current;\n  DeclContext::decl_iterator DE_current;\n  SmallVectorImpl<Decl *>::iterator *FileDI_current;\n  SmallVectorImpl<Decl *>::iterator FileDE_current;\n\n  // Cache of pre-allocated worklists for data-recursion walk of Stmts.\n  SmallVector<VisitorWorkList *, 5> WorkListFreeList;\n  SmallVector<VisitorWorkList *, 5> WorkListCache;\n\n  using DeclVisitor<CursorVisitor, bool>::Visit;\n  using TypeLocVisitor<CursorVisitor, bool>::Visit;\n\n  /// Determine whether this particular source range comes before, comes\n  /// after, or overlaps the region of interest.\n  ///\n  /// \\param R a half-open source range retrieved from the abstract syntax tree.\n  RangeComparisonResult CompareRegionOfInterest(SourceRange R);\n\n  bool visitDeclsFromFileRegion(FileID File, unsigned Offset, unsigned Length);\n\n  class SetParentRAII {\n    CXCursor &Parent;\n    const Decl *&StmtParent;\n    CXCursor OldParent;\n\n  public:\n    SetParentRAII(CXCursor &Parent, const Decl *&StmtParent, CXCursor NewParent)\n        : Parent(Parent), StmtParent(StmtParent), OldParent(Parent) {\n      Parent = NewParent;\n      if (clang_isDeclaration(Parent.kind))\n        StmtParent = getCursorDecl(Parent);\n    }\n\n    ~SetParentRAII() {\n      Parent = OldParent;\n      if (clang_isDeclaration(Parent.kind))\n        StmtParent = getCursorDecl(Parent);\n    }\n  };\n\npublic:\n  CursorVisitor(CXTranslationUnit TU, CXCursorVisitor Visitor,\n                CXClientData ClientData, bool VisitPreprocessorLast,\n                bool VisitIncludedPreprocessingEntries = false,\n                SourceRange RegionOfInterest = SourceRange(),\n                bool VisitDeclsOnly = false,\n                PostChildrenVisitorTy PostChildrenVisitor = nullptr)\n      : TU(TU), AU(cxtu::getASTUnit(TU)), Visitor(Visitor),\n        PostChildrenVisitor(PostChildrenVisitor), ClientData(ClientData),\n        VisitPreprocessorLast(VisitPreprocessorLast),\n        VisitIncludedEntities(VisitIncludedPreprocessingEntries),\n        RegionOfInterest(RegionOfInterest), VisitDeclsOnly(VisitDeclsOnly),\n        DI_current(nullptr), FileDI_current(nullptr) {\n    Parent.kind = CXCursor_NoDeclFound;\n    Parent.data[0] = nullptr;\n    Parent.data[1] = nullptr;\n    Parent.data[2] = nullptr;\n    StmtParent = nullptr;\n  }\n\n  ~CursorVisitor() {\n    // Free the pre-allocated worklists for data-recursion.\n    for (SmallVectorImpl<VisitorWorkList *>::iterator I = WorkListCache.begin(),\n                                                      E = WorkListCache.end();\n         I != E; ++I) {\n      delete *I;\n    }\n  }\n\n  ASTUnit *getASTUnit() const { return AU; }\n  CXTranslationUnit getTU() const { return TU; }\n\n  bool Visit(CXCursor Cursor, bool CheckedRegionOfInterest = false);\n\n  /// Visit declarations and preprocessed entities for the file region\n  /// designated by \\see RegionOfInterest.\n  bool visitFileRegion();\n\n  bool visitPreprocessedEntitiesInRegion();\n\n  bool shouldVisitIncludedEntities() const { return VisitIncludedEntities; }\n\n  template <typename InputIterator>\n  bool visitPreprocessedEntities(InputIterator First, InputIterator Last,\n                                 PreprocessingRecord &PPRec,\n                                 FileID FID = FileID());\n\n  bool VisitChildren(CXCursor Parent);\n\n  // Declaration visitors\n  bool VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D);\n  bool VisitTypeAliasDecl(TypeAliasDecl *D);\n  bool VisitAttributes(Decl *D);\n  bool VisitBlockDecl(BlockDecl *B);\n  bool VisitCXXRecordDecl(CXXRecordDecl *D);\n  Optional<bool> shouldVisitCursor(CXCursor C);\n  bool VisitDeclContext(DeclContext *DC);\n  bool VisitTranslationUnitDecl(TranslationUnitDecl *D);\n  bool VisitTypedefDecl(TypedefDecl *D);\n  bool VisitTagDecl(TagDecl *D);\n  bool VisitClassTemplateSpecializationDecl(ClassTemplateSpecializationDecl *D);\n  bool VisitClassTemplatePartialSpecializationDecl(\n      ClassTemplatePartialSpecializationDecl *D);\n  bool VisitTemplateTypeParmDecl(TemplateTypeParmDecl *D);\n  bool VisitEnumConstantDecl(EnumConstantDecl *D);\n  bool VisitDeclaratorDecl(DeclaratorDecl *DD);\n  bool VisitFunctionDecl(FunctionDecl *ND);\n  bool VisitFieldDecl(FieldDecl *D);\n  bool VisitVarDecl(VarDecl *);\n  bool VisitNonTypeTemplateParmDecl(NonTypeTemplateParmDecl *D);\n  bool VisitFunctionTemplateDecl(FunctionTemplateDecl *D);\n  bool VisitClassTemplateDecl(ClassTemplateDecl *D);\n  bool VisitTemplateTemplateParmDecl(TemplateTemplateParmDecl *D);\n  bool VisitObjCTypeParamDecl(ObjCTypeParamDecl *D);\n  bool VisitObjCMethodDecl(ObjCMethodDecl *ND);\n  bool VisitObjCContainerDecl(ObjCContainerDecl *D);\n  bool VisitObjCCategoryDecl(ObjCCategoryDecl *ND);\n  bool VisitObjCProtocolDecl(ObjCProtocolDecl *PID);\n  bool VisitObjCPropertyDecl(ObjCPropertyDecl *PD);\n  bool VisitObjCTypeParamList(ObjCTypeParamList *typeParamList);\n  bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *D);\n  bool VisitObjCImplDecl(ObjCImplDecl *D);\n  bool VisitObjCCategoryImplDecl(ObjCCategoryImplDecl *D);\n  bool VisitObjCImplementationDecl(ObjCImplementationDecl *D);\n  // FIXME: ObjCCompatibleAliasDecl requires aliased-class locations.\n  bool VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *PD);\n  bool VisitLinkageSpecDecl(LinkageSpecDecl *D);\n  bool VisitNamespaceDecl(NamespaceDecl *D);\n  bool VisitNamespaceAliasDecl(NamespaceAliasDecl *D);\n  bool VisitUsingDirectiveDecl(UsingDirectiveDecl *D);\n  bool VisitUsingDecl(UsingDecl *D);\n  bool VisitUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *D);\n  bool VisitUnresolvedUsingTypenameDecl(UnresolvedUsingTypenameDecl *D);\n  bool VisitStaticAssertDecl(StaticAssertDecl *D);\n  bool VisitFriendDecl(FriendDecl *D);\n  bool VisitDecompositionDecl(DecompositionDecl *D);\n\n  // Name visitor\n  bool VisitDeclarationNameInfo(DeclarationNameInfo Name);\n  bool VisitNestedNameSpecifier(NestedNameSpecifier *NNS, SourceRange Range);\n  bool VisitNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS);\n\n  // Template visitors\n  bool VisitTemplateParameters(const TemplateParameterList *Params);\n  bool VisitTemplateName(TemplateName Name, SourceLocation Loc);\n  bool VisitTemplateArgumentLoc(const TemplateArgumentLoc &TAL);\n\n  // Type visitors\n#define ABSTRACT_TYPELOC(CLASS, PARENT)\n#define TYPELOC(CLASS, PARENT) bool Visit##CLASS##TypeLoc(CLASS##TypeLoc TyLoc);\n#include \"clang/AST/TypeLocNodes.def\"\n\n  bool VisitTagTypeLoc(TagTypeLoc TL);\n  bool VisitArrayTypeLoc(ArrayTypeLoc TL);\n  bool VisitFunctionTypeLoc(FunctionTypeLoc TL, bool SkipResultType = false);\n\n  // Data-recursive visitor functions.\n  bool IsInRegionOfInterest(CXCursor C);\n  bool RunVisitorWorkList(VisitorWorkList &WL);\n  void EnqueueWorkList(VisitorWorkList &WL, const Stmt *S);\n  LLVM_ATTRIBUTE_NOINLINE bool Visit(const Stmt *S);\n\nprivate:\n  Optional<bool> handleDeclForVisitation(const Decl *D);\n};\n\n} // namespace cxcursor\n} // namespace clang\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 21, "file": 2, "line": 492}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 196}, "message": "differing parameters are named here: ('Parent'), in definition: ('Cursor')"}, {"location": {"col": 8, "file": 1, "line": 196}, "message": "function 'clang::cxcursor::CursorVisitor::VisitChildren' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CursorVisitor.h", "reportHash": "39f5e7ed7d54bfc781106dbdd451bf41", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 2, "line": 1385}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 249}, "message": "differing parameters are named here: ('NNS'), in definition: ('Qualifier')"}, {"location": {"col": 8, "file": 1, "line": 249}, "message": "function 'clang::cxcursor::CursorVisitor::VisitNestedNameSpecifierLoc' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CursorVisitor.h", "reportHash": "d9a876c3728ac5691d90715465b2944c", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
