<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/IR/AsmWriter.cpp", "content": "//===- AsmWriter.cpp - Printing LLVM as an assembly file ------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This library implements `print` family of functions in classes like\n// Module, Function, Value, etc. In-memory representation of those classes is\n// converted to IR strings.\n//\n// Note that these routines must be extremely tolerant of various errors in the\n// LLVM code, because it can be used for debugging transformations.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/AssemblyAnnotationWriter.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/Comdat.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalAlias.h\"\n#include \"llvm/IR/GlobalIFunc.h\"\n#include \"llvm/IR/GlobalIndirectSymbol.h\"\n#include \"llvm/IR/GlobalObject.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/IRPrintingPasses.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/ModuleSlotTracker.h\"\n#include \"llvm/IR/ModuleSummaryIndex.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/Statepoint.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/TypeFinder.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/UseListOrder.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/FormattedStream.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\n\n// Make virtual table appear in this compilation unit.\nAssemblyAnnotationWriter::~AssemblyAnnotationWriter() = default;\n\n//===----------------------------------------------------------------------===//\n// Helper Functions\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nstruct OrderMap {\n  DenseMap<const Value *, std::pair<unsigned, bool>> IDs;\n\n  unsigned size() const { return IDs.size(); }\n  std::pair<unsigned, bool> &operator[](const Value *V) { return IDs[V]; }\n\n  std::pair<unsigned, bool> lookup(const Value *V) const {\n    return IDs.lookup(V);\n  }\n\n  void index(const Value *V) {\n    // Explicitly sequence get-size and insert-value operations to avoid UB.\n    unsigned ID = IDs.size() + 1;\n    IDs[V].first = ID;\n  }\n};\n\n} // end anonymous namespace\n\n/// Look for a value that might be wrapped as metadata, e.g. a value in a\n/// metadata operand. Returns the input value as-is if it is not wrapped.\nstatic const Value *skipMetadataWrapper(const Value *V) {\n  if (const auto *MAV = dyn_cast<MetadataAsValue>(V))\n    if (const auto *VAM = dyn_cast<ValueAsMetadata>(MAV->getMetadata()))\n      return VAM->getValue();\n  return V;\n}\n\nstatic void orderValue(const Value *V, OrderMap &OM) {\n  if (OM.lookup(V).first)\n    return;\n\n  if (const Constant *C = dyn_cast<Constant>(V))\n    if (C->getNumOperands() && !isa<GlobalValue>(C))\n      for (const Value *Op : C->operands())\n        if (!isa<BasicBlock>(Op) && !isa<GlobalValue>(Op))\n          orderValue(Op, OM);\n\n  // Note: we cannot cache this lookup above, since inserting into the map\n  // changes the map's size, and thus affects the other IDs.\n  OM.index(V);\n}\n\nstatic OrderMap orderModule(const Module *M) {\n  OrderMap OM;\n\n  for (const GlobalVariable &G : M->globals()) {\n    if (G.hasInitializer())\n      if (!isa<GlobalValue>(G.getInitializer()))\n        orderValue(G.getInitializer(), OM);\n    orderValue(&G, OM);\n  }\n  for (const GlobalAlias &A : M->aliases()) {\n    if (!isa<GlobalValue>(A.getAliasee()))\n      orderValue(A.getAliasee(), OM);\n    orderValue(&A, OM);\n  }\n  for (const GlobalIFunc &I : M->ifuncs()) {\n    if (!isa<GlobalValue>(I.getResolver()))\n      orderValue(I.getResolver(), OM);\n    orderValue(&I, OM);\n  }\n  for (const Function &F : *M) {\n    for (const Use &U : F.operands())\n      if (!isa<GlobalValue>(U.get()))\n        orderValue(U.get(), OM);\n\n    orderValue(&F, OM);\n\n    if (F.isDeclaration())\n      continue;\n\n    for (const Argument &A : F.args())\n      orderValue(&A, OM);\n    for (const BasicBlock &BB : F) {\n      orderValue(&BB, OM);\n      for (const Instruction &I : BB) {\n        for (const Value *Op : I.operands()) {\n          Op = skipMetadataWrapper(Op);\n          if ((isa<Constant>(*Op) && !isa<GlobalValue>(*Op)) ||\n              isa<InlineAsm>(*Op))\n            orderValue(Op, OM);\n        }\n        orderValue(&I, OM);\n      }\n    }\n  }\n  return OM;\n}\n\nstatic void predictValueUseListOrderImpl(const Value *V, const Function *F,\n                                         unsigned ID, const OrderMap &OM,\n                                         UseListOrderStack &Stack) {\n  // Predict use-list order for this one.\n  using Entry = std::pair<const Use *, unsigned>;\n  SmallVector<Entry, 64> List;\n  for (const Use &U : V->uses())\n    // Check if this user will be serialized.\n    if (OM.lookup(U.getUser()).first)\n      List.push_back(std::make_pair(&U, List.size()));\n\n  if (List.size() < 2)\n    // We may have lost some users.\n    return;\n\n  bool GetsReversed =\n      !isa<GlobalVariable>(V) && !isa<Function>(V) && !isa<BasicBlock>(V);\n  if (auto *BA = dyn_cast<BlockAddress>(V))\n    ID = OM.lookup(BA->getBasicBlock()).first;\n  llvm::sort(List, [&](const Entry &L, const Entry &R) {\n    const Use *LU = L.first;\n    const Use *RU = R.first;\n    if (LU == RU)\n      return false;\n\n    auto LID = OM.lookup(LU->getUser()).first;\n    auto RID = OM.lookup(RU->getUser()).first;\n\n    // If ID is 4, then expect: 7 6 5 1 2 3.\n    if (LID < RID) {\n      if (GetsReversed)\n        if (RID <= ID)\n          return true;\n      return false;\n    }\n    if (RID < LID) {\n      if (GetsReversed)\n        if (LID <= ID)\n          return false;\n      return true;\n    }\n\n    // LID and RID are equal, so we have different operands of the same user.\n    // Assume operands are added in order for all instructions.\n    if (GetsReversed)\n      if (LID <= ID)\n        return LU->getOperandNo() < RU->getOperandNo();\n    return LU->getOperandNo() > RU->getOperandNo();\n  });\n\n  if (llvm::is_sorted(List, [](const Entry &L, const Entry &R) {\n        return L.second < R.second;\n      }))\n    // Order is already correct.\n    return;\n\n  // Store the shuffle.\n  Stack.emplace_back(V, F, List.size());\n  assert(List.size() == Stack.back().Shuffle.size() && \"Wrong size\");\n  for (size_t I = 0, E = List.size(); I != E; ++I)\n    Stack.back().Shuffle[I] = List[I].second;\n}\n\nstatic void predictValueUseListOrder(const Value *V, const Function *F,\n                                     OrderMap &OM, UseListOrderStack &Stack) {\n  auto &IDPair = OM[V];\n  assert(IDPair.first && \"Unmapped value\");\n  if (IDPair.second)\n    // Already predicted.\n    return;\n\n  // Do the actual prediction.\n  IDPair.second = true;\n  if (!V->use_empty() && std::next(V->use_begin()) != V->use_end())\n    predictValueUseListOrderImpl(V, F, IDPair.first, OM, Stack);\n\n  // Recursive descent into constants.\n  if (const Constant *C = dyn_cast<Constant>(V))\n    if (C->getNumOperands()) // Visit GlobalValues.\n      for (const Value *Op : C->operands())\n        if (isa<Constant>(Op)) // Visit GlobalValues.\n          predictValueUseListOrder(Op, F, OM, Stack);\n}\n\nstatic UseListOrderStack predictUseListOrder(const Module *M) {\n  OrderMap OM = orderModule(M);\n\n  // Use-list orders need to be serialized after all the users have been added\n  // to a value, or else the shuffles will be incomplete.  Store them per\n  // function in a stack.\n  //\n  // Aside from function order, the order of values doesn't matter much here.\n  UseListOrderStack Stack;\n\n  // We want to visit the functions backward now so we can list function-local\n  // constants in the last Function they're used in.  Module-level constants\n  // have already been visited above.\n  for (const Function &F : make_range(M->rbegin(), M->rend())) {\n    if (F.isDeclaration())\n      continue;\n    for (const BasicBlock &BB : F)\n      predictValueUseListOrder(&BB, &F, OM, Stack);\n    for (const Argument &A : F.args())\n      predictValueUseListOrder(&A, &F, OM, Stack);\n    for (const BasicBlock &BB : F)\n      for (const Instruction &I : BB)\n        for (const Value *Op : I.operands()) {\n          Op = skipMetadataWrapper(Op);\n          if (isa<Constant>(*Op) || isa<InlineAsm>(*Op)) // Visit GlobalValues.\n            predictValueUseListOrder(Op, &F, OM, Stack);\n        }\n    for (const BasicBlock &BB : F)\n      for (const Instruction &I : BB)\n        predictValueUseListOrder(&I, &F, OM, Stack);\n  }\n\n  // Visit globals last.\n  for (const GlobalVariable &G : M->globals())\n    predictValueUseListOrder(&G, nullptr, OM, Stack);\n  for (const Function &F : *M)\n    predictValueUseListOrder(&F, nullptr, OM, Stack);\n  for (const GlobalAlias &A : M->aliases())\n    predictValueUseListOrder(&A, nullptr, OM, Stack);\n  for (const GlobalIFunc &I : M->ifuncs())\n    predictValueUseListOrder(&I, nullptr, OM, Stack);\n  for (const GlobalVariable &G : M->globals())\n    if (G.hasInitializer())\n      predictValueUseListOrder(G.getInitializer(), nullptr, OM, Stack);\n  for (const GlobalAlias &A : M->aliases())\n    predictValueUseListOrder(A.getAliasee(), nullptr, OM, Stack);\n  for (const GlobalIFunc &I : M->ifuncs())\n    predictValueUseListOrder(I.getResolver(), nullptr, OM, Stack);\n  for (const Function &F : *M)\n    for (const Use &U : F.operands())\n      predictValueUseListOrder(U.get(), nullptr, OM, Stack);\n\n  return Stack;\n}\n\nstatic const Module *getModuleFromVal(const Value *V) {\n  if (const Argument *MA = dyn_cast<Argument>(V))\n    return MA->getParent() ? MA->getParent()->getParent() : nullptr;\n\n  if (const BasicBlock *BB = dyn_cast<BasicBlock>(V))\n    return BB->getParent() ? BB->getParent()->getParent() : nullptr;\n\n  if (const Instruction *I = dyn_cast<Instruction>(V)) {\n    const Function *M = I->getParent() ? I->getParent()->getParent() : nullptr;\n    return M ? M->getParent() : nullptr;\n  }\n\n  if (const GlobalValue *GV = dyn_cast<GlobalValue>(V))\n    return GV->getParent();\n\n  if (const auto *MAV = dyn_cast<MetadataAsValue>(V)) {\n    for (const User *U : MAV->users())\n      if (isa<Instruction>(U))\n        if (const Module *M = getModuleFromVal(U))\n          return M;\n    return nullptr;\n  }\n\n  return nullptr;\n}\n\nstatic void PrintCallingConv(unsigned cc, raw_ostream &Out) {\n  switch (cc) {\n  default:                         Out << \"cc\" << cc; break;\n  case CallingConv::Fast:          Out << \"fastcc\"; break;\n  case CallingConv::Cold:          Out << \"coldcc\"; break;\n  case CallingConv::WebKit_JS:     Out << \"webkit_jscc\"; break;\n  case CallingConv::AnyReg:        Out << \"anyregcc\"; break;\n  case CallingConv::PreserveMost:  Out << \"preserve_mostcc\"; break;\n  case CallingConv::PreserveAll:   Out << \"preserve_allcc\"; break;\n  case CallingConv::CXX_FAST_TLS:  Out << \"cxx_fast_tlscc\"; break;\n  case CallingConv::GHC:           Out << \"ghccc\"; break;\n  case CallingConv::Tail:          Out << \"tailcc\"; break;\n  case CallingConv::CFGuard_Check: Out << \"cfguard_checkcc\"; break;\n  case CallingConv::X86_StdCall:   Out << \"x86_stdcallcc\"; break;\n  case CallingConv::X86_FastCall:  Out << \"x86_fastcallcc\"; break;\n  case CallingConv::X86_ThisCall:  Out << \"x86_thiscallcc\"; break;\n  case CallingConv::X86_RegCall:   Out << \"x86_regcallcc\"; break;\n  case CallingConv::X86_VectorCall:Out << \"x86_vectorcallcc\"; break;\n  case CallingConv::Intel_OCL_BI:  Out << \"intel_ocl_bicc\"; break;\n  case CallingConv::ARM_APCS:      Out << \"arm_apcscc\"; break;\n  case CallingConv::ARM_AAPCS:     Out << \"arm_aapcscc\"; break;\n  case CallingConv::ARM_AAPCS_VFP: Out << \"arm_aapcs_vfpcc\"; break;\n  case CallingConv::AArch64_VectorCall: Out << \"aarch64_vector_pcs\"; break;\n  case CallingConv::AArch64_SVE_VectorCall:\n    Out << \"aarch64_sve_vector_pcs\";\n    break;\n  case CallingConv::MSP430_INTR:   Out << \"msp430_intrcc\"; break;\n  case CallingConv::AVR_INTR:      Out << \"avr_intrcc \"; break;\n  case CallingConv::AVR_SIGNAL:    Out << \"avr_signalcc \"; break;\n  case CallingConv::PTX_Kernel:    Out << \"ptx_kernel\"; break;\n  case CallingConv::PTX_Device:    Out << \"ptx_device\"; break;\n  case CallingConv::X86_64_SysV:   Out << \"x86_64_sysvcc\"; break;\n  case CallingConv::Win64:         Out << \"win64cc\"; break;\n  case CallingConv::SPIR_FUNC:     Out << \"spir_func\"; break;\n  case CallingConv::SPIR_KERNEL:   Out << \"spir_kernel\"; break;\n  case CallingConv::Swift:         Out << \"swiftcc\"; break;\n  case CallingConv::X86_INTR:      Out << \"x86_intrcc\"; break;\n  case CallingConv::HHVM:          Out << \"hhvmcc\"; break;\n  case CallingConv::HHVM_C:        Out << \"hhvm_ccc\"; break;\n  case CallingConv::AMDGPU_VS:     Out << \"amdgpu_vs\"; break;\n  case CallingConv::AMDGPU_LS:     Out << \"amdgpu_ls\"; break;\n  case CallingConv::AMDGPU_HS:     Out << \"amdgpu_hs\"; break;\n  case CallingConv::AMDGPU_ES:     Out << \"amdgpu_es\"; break;\n  case CallingConv::AMDGPU_GS:     Out << \"amdgpu_gs\"; break;\n  case CallingConv::AMDGPU_PS:     Out << \"amdgpu_ps\"; break;\n  case CallingConv::AMDGPU_CS:     Out << \"amdgpu_cs\"; break;\n  case CallingConv::AMDGPU_KERNEL: Out << \"amdgpu_kernel\"; break;\n  case CallingConv::AMDGPU_Gfx:    Out << \"amdgpu_gfx\"; break;\n  }\n}\n\nenum PrefixType {\n  GlobalPrefix,\n  ComdatPrefix,\n  LabelPrefix,\n  LocalPrefix,\n  NoPrefix\n};\n\nvoid llvm::printLLVMNameWithoutPrefix(raw_ostream &OS, StringRef Name) {\n  assert(!Name.empty() && \"Cannot get empty name!\");\n\n  // Scan the name to see if it needs quotes first.\n  bool NeedsQuotes = isdigit(static_cast<unsigned char>(Name[0]));\n  if (!NeedsQuotes) {\n    for (unsigned i = 0, e = Name.size(); i != e; ++i) {\n      // By making this unsigned, the value passed in to isalnum will always be\n      // in the range 0-255.  This is important when building with MSVC because\n      // its implementation will assert.  This situation can arise when dealing\n      // with UTF-8 multibyte characters.\n      unsigned char C = Name[i];\n      if (!isalnum(static_cast<unsigned char>(C)) && C != '-' && C != '.' &&\n          C != '_') {\n        NeedsQuotes = true;\n        break;\n      }\n    }\n  }\n\n  // If we didn't need any quotes, just write out the name in one blast.\n  if (!NeedsQuotes) {\n    OS << Name;\n    return;\n  }\n\n  // Okay, we need quotes.  Output the quotes and escape any scary characters as\n  // needed.\n  OS << '\"';\n  printEscapedString(Name, OS);\n  OS << '\"';\n}\n\n/// Turn the specified name into an 'LLVM name', which is either prefixed with %\n/// (if the string only contains simple characters) or is surrounded with \"\"'s\n/// (if it has special chars in it). Print it out.\nstatic void PrintLLVMName(raw_ostream &OS, StringRef Name, PrefixType Prefix) {\n  switch (Prefix) {\n  case NoPrefix:\n    break;\n  case GlobalPrefix:\n    OS << '@';\n    break;\n  case ComdatPrefix:\n    OS << '$';\n    break;\n  case LabelPrefix:\n    break;\n  case LocalPrefix:\n    OS << '%';\n    break;\n  }\n  printLLVMNameWithoutPrefix(OS, Name);\n}\n\n/// Turn the specified name into an 'LLVM name', which is either prefixed with %\n/// (if the string only contains simple characters) or is surrounded with \"\"'s\n/// (if it has special chars in it). Print it out.\nstatic void PrintLLVMName(raw_ostream &OS, const Value *V) {\n  PrintLLVMName(OS, V->getName(),\n                isa<GlobalValue>(V) ? GlobalPrefix : LocalPrefix);\n}\n\nstatic void PrintShuffleMask(raw_ostream &Out, Type *Ty, ArrayRef<int> Mask) {\n  Out << \", <\";\n  if (isa<ScalableVectorType>(Ty))\n    Out << \"vscale x \";\n  Out << Mask.size() << \" x i32> \";\n  bool FirstElt = true;\n  if (all_of(Mask, [](int Elt) { return Elt == 0; })) {\n    Out << \"zeroinitializer\";\n  } else if (all_of(Mask, [](int Elt) { return Elt == UndefMaskElem; })) {\n    Out << \"undef\";\n  } else {\n    Out << \"<\";\n    for (int Elt : Mask) {\n      if (FirstElt)\n        FirstElt = false;\n      else\n        Out << \", \";\n      Out << \"i32 \";\n      if (Elt == UndefMaskElem)\n        Out << \"undef\";\n      else\n        Out << Elt;\n    }\n    Out << \">\";\n  }\n}\n\nnamespace {\n\nclass TypePrinting {\npublic:\n  TypePrinting(const Module *M = nullptr) : DeferredM(M) {}\n\n  TypePrinting(const TypePrinting &) = delete;\n  TypePrinting &operator=(const TypePrinting &) = delete;\n\n  /// The named types that are used by the current module.\n  TypeFinder &getNamedTypes();\n\n  /// The numbered types, number to type mapping.\n  std::vector<StructType *> &getNumberedTypes();\n\n  bool empty();\n\n  void print(Type *Ty, raw_ostream &OS);\n\n  void printStructBody(StructType *Ty, raw_ostream &OS);\n\nprivate:\n  void incorporateTypes();\n\n  /// A module to process lazily when needed. Set to nullptr as soon as used.\n  const Module *DeferredM;\n\n  TypeFinder NamedTypes;\n\n  // The numbered types, along with their value.\n  DenseMap<StructType *, unsigned> Type2Number;\n\n  std::vector<StructType *> NumberedTypes;\n};\n\n} // end anonymous namespace\n\nTypeFinder &TypePrinting::getNamedTypes() {\n  incorporateTypes();\n  return NamedTypes;\n}\n\nstd::vector<StructType *> &TypePrinting::getNumberedTypes() {\n  incorporateTypes();\n\n  // We know all the numbers that each type is used and we know that it is a\n  // dense assignment. Convert the map to an index table, if it's not done\n  // already (judging from the sizes):\n  if (NumberedTypes.size() == Type2Number.size())\n    return NumberedTypes;\n\n  NumberedTypes.resize(Type2Number.size());\n  for (const auto &P : Type2Number) {\n    assert(P.second < NumberedTypes.size() && \"Didn't get a dense numbering?\");\n    assert(!NumberedTypes[P.second] && \"Didn't get a unique numbering?\");\n    NumberedTypes[P.second] = P.first;\n  }\n  return NumberedTypes;\n}\n\nbool TypePrinting::empty() {\n  incorporateTypes();\n  return NamedTypes.empty() && Type2Number.empty();\n}\n\nvoid TypePrinting::incorporateTypes() {\n  if (!DeferredM)\n    return;\n\n  NamedTypes.run(*DeferredM, false);\n  DeferredM = nullptr;\n\n  // The list of struct types we got back includes all the struct types, split\n  // the unnamed ones out to a numbering and remove the anonymous structs.\n  unsigned NextNumber = 0;\n\n  std::vector<StructType*>::iterator NextToUse = NamedTypes.begin(), I, E;\n  for (I = NamedTypes.begin(), E = NamedTypes.end(); I != E; ++I) {\n    StructType *STy = *I;\n\n    // Ignore anonymous types.\n    if (STy->isLiteral())\n      continue;\n\n    if (STy->getName().empty())\n      Type2Number[STy] = NextNumber++;\n    else\n      *NextToUse++ = STy;\n  }\n\n  NamedTypes.erase(NextToUse, NamedTypes.end());\n}\n\n/// Write the specified type to the specified raw_ostream, making use of type\n/// names or up references to shorten the type name where possible.\nvoid TypePrinting::print(Type *Ty, raw_ostream &OS) {\n  switch (Ty->getTypeID()) {\n  case Type::VoidTyID:      OS << \"void\"; return;\n  case Type::HalfTyID:      OS << \"half\"; return;\n  case Type::BFloatTyID:    OS << \"bfloat\"; return;\n  case Type::FloatTyID:     OS << \"float\"; return;\n  case Type::DoubleTyID:    OS << \"double\"; return;\n  case Type::X86_FP80TyID:  OS << \"x86_fp80\"; return;\n  case Type::FP128TyID:     OS << \"fp128\"; return;\n  case Type::PPC_FP128TyID: OS << \"ppc_fp128\"; return;\n  case Type::LabelTyID:     OS << \"label\"; return;\n  case Type::MetadataTyID:  OS << \"metadata\"; return;\n  case Type::X86_MMXTyID:   OS << \"x86_mmx\"; return;\n  case Type::X86_AMXTyID:   OS << \"x86_amx\"; return;\n  case Type::TokenTyID:     OS << \"token\"; return;\n  case Type::IntegerTyID:\n    OS << 'i' << cast<IntegerType>(Ty)->getBitWidth();\n    return;\n\n  case Type::FunctionTyID: {\n    FunctionType *FTy = cast<FunctionType>(Ty);\n    print(FTy->getReturnType(), OS);\n    OS << \" (\";\n    for (FunctionType::param_iterator I = FTy->param_begin(),\n         E = FTy->param_end(); I != E; ++I) {\n      if (I != FTy->param_begin())\n        OS << \", \";\n      print(*I, OS);\n    }\n    if (FTy->isVarArg()) {\n      if (FTy->getNumParams()) OS << \", \";\n      OS << \"...\";\n    }\n    OS << ')';\n    return;\n  }\n  case Type::StructTyID: {\n    StructType *STy = cast<StructType>(Ty);\n\n    if (STy->isLiteral())\n      return printStructBody(STy, OS);\n\n    if (!STy->getName().empty())\n      return PrintLLVMName(OS, STy->getName(), LocalPrefix);\n\n    incorporateTypes();\n    const auto I = Type2Number.find(STy);\n    if (I != Type2Number.end())\n      OS << '%' << I->second;\n    else  // Not enumerated, print the hex address.\n      OS << \"%\\\"type \" << STy << '\\\"';\n    return;\n  }\n  case Type::PointerTyID: {\n    PointerType *PTy = cast<PointerType>(Ty);\n    print(PTy->getElementType(), OS);\n    if (unsigned AddressSpace = PTy->getAddressSpace())\n      OS << \" addrspace(\" << AddressSpace << ')';\n    OS << '*';\n    return;\n  }\n  case Type::ArrayTyID: {\n    ArrayType *ATy = cast<ArrayType>(Ty);\n    OS << '[' << ATy->getNumElements() << \" x \";\n    print(ATy->getElementType(), OS);\n    OS << ']';\n    return;\n  }\n  case Type::FixedVectorTyID:\n  case Type::ScalableVectorTyID: {\n    VectorType *PTy = cast<VectorType>(Ty);\n    ElementCount EC = PTy->getElementCount();\n    OS << \"<\";\n    if (EC.isScalable())\n      OS << \"vscale x \";\n    OS << EC.getKnownMinValue() << \" x \";\n    print(PTy->getElementType(), OS);\n    OS << '>';\n    return;\n  }\n  }\n  llvm_unreachable(\"Invalid TypeID\");\n}\n\nvoid TypePrinting::printStructBody(StructType *STy, raw_ostream &OS) {\n  if (STy->isOpaque()) {\n    OS << \"opaque\";\n    return;\n  }\n\n  if (STy->isPacked())\n    OS << '<';\n\n  if (STy->getNumElements() == 0) {\n    OS << \"{}\";\n  } else {\n    StructType::element_iterator I = STy->element_begin();\n    OS << \"{ \";\n    print(*I++, OS);\n    for (StructType::element_iterator E = STy->element_end(); I != E; ++I) {\n      OS << \", \";\n      print(*I, OS);\n    }\n\n    OS << \" }\";\n  }\n  if (STy->isPacked())\n    OS << '>';\n}\n\nnamespace llvm {\n\n//===----------------------------------------------------------------------===//\n// SlotTracker Class: Enumerate slot numbers for unnamed values\n//===----------------------------------------------------------------------===//\n/// This class provides computation of slot numbers for LLVM Assembly writing.\n///\nclass SlotTracker {\npublic:\n  /// ValueMap - A mapping of Values to slot numbers.\n  using ValueMap = DenseMap<const Value *, unsigned>;\n\nprivate:\n  /// TheModule - The module for which we are holding slot numbers.\n  const Module* TheModule;\n\n  /// TheFunction - The function for which we are holding slot numbers.\n  const Function* TheFunction = nullptr;\n  bool FunctionProcessed = false;\n  bool ShouldInitializeAllMetadata;\n\n  /// The summary index for which we are holding slot numbers.\n  const ModuleSummaryIndex *TheIndex = nullptr;\n\n  /// mMap - The slot map for the module level data.\n  ValueMap mMap;\n  unsigned mNext = 0;\n\n  /// fMap - The slot map for the function level data.\n  ValueMap fMap;\n  unsigned fNext = 0;\n\n  /// mdnMap - Map for MDNodes.\n  DenseMap<const MDNode*, unsigned> mdnMap;\n  unsigned mdnNext = 0;\n\n  /// asMap - The slot map for attribute sets.\n  DenseMap<AttributeSet, unsigned> asMap;\n  unsigned asNext = 0;\n\n  /// ModulePathMap - The slot map for Module paths used in the summary index.\n  StringMap<unsigned> ModulePathMap;\n  unsigned ModulePathNext = 0;\n\n  /// GUIDMap - The slot map for GUIDs used in the summary index.\n  DenseMap<GlobalValue::GUID, unsigned> GUIDMap;\n  unsigned GUIDNext = 0;\n\n  /// TypeIdMap - The slot map for type ids used in the summary index.\n  StringMap<unsigned> TypeIdMap;\n  unsigned TypeIdNext = 0;\n\npublic:\n  /// Construct from a module.\n  ///\n  /// If \\c ShouldInitializeAllMetadata, initializes all metadata in all\n  /// functions, giving correct numbering for metadata referenced only from\n  /// within a function (even if no functions have been initialized).\n  explicit SlotTracker(const Module *M,\n                       bool ShouldInitializeAllMetadata = false);\n\n  /// Construct from a function, starting out in incorp state.\n  ///\n  /// If \\c ShouldInitializeAllMetadata, initializes all metadata in all\n  /// functions, giving correct numbering for metadata referenced only from\n  /// within a function (even if no functions have been initialized).\n  explicit SlotTracker(const Function *F,\n                       bool ShouldInitializeAllMetadata = false);\n\n  /// Construct from a module summary index.\n  explicit SlotTracker(const ModuleSummaryIndex *Index);\n\n  SlotTracker(const SlotTracker &) = delete;\n  SlotTracker &operator=(const SlotTracker &) = delete;\n\n  /// Return the slot number of the specified value in it's type\n  /// plane.  If something is not in the SlotTracker, return -1.\n  int getLocalSlot(const Value *V);\n  int getGlobalSlot(const GlobalValue *V);\n  int getMetadataSlot(const MDNode *N);\n  int getAttributeGroupSlot(AttributeSet AS);\n  int getModulePathSlot(StringRef Path);\n  int getGUIDSlot(GlobalValue::GUID GUID);\n  int getTypeIdSlot(StringRef Id);\n\n  /// If you'd like to deal with a function instead of just a module, use\n  /// this method to get its data into the SlotTracker.\n  void incorporateFunction(const Function *F) {\n    TheFunction = F;\n    FunctionProcessed = false;\n  }\n\n  const Function *getFunction() const { return TheFunction; }\n\n  /// After calling incorporateFunction, use this method to remove the\n  /// most recently incorporated function from the SlotTracker. This\n  /// will reset the state of the machine back to just the module contents.\n  void purgeFunction();\n\n  /// MDNode map iterators.\n  using mdn_iterator = DenseMap<const MDNode*, unsigned>::iterator;\n\n  mdn_iterator mdn_begin() { return mdnMap.begin(); }\n  mdn_iterator mdn_end() { return mdnMap.end(); }\n  unsigned mdn_size() const { return mdnMap.size(); }\n  bool mdn_empty() const { return mdnMap.empty(); }\n\n  /// AttributeSet map iterators.\n  using as_iterator = DenseMap<AttributeSet, unsigned>::iterator;\n\n  as_iterator as_begin()   { return asMap.begin(); }\n  as_iterator as_end()     { return asMap.end(); }\n  unsigned as_size() const { return asMap.size(); }\n  bool as_empty() const    { return asMap.empty(); }\n\n  /// GUID map iterators.\n  using guid_iterator = DenseMap<GlobalValue::GUID, unsigned>::iterator;\n\n  /// These functions do the actual initialization.\n  inline void initializeIfNeeded();\n  int initializeIndexIfNeeded();\n\n  // Implementation Details\nprivate:\n  /// CreateModuleSlot - Insert the specified GlobalValue* into the slot table.\n  void CreateModuleSlot(const GlobalValue *V);\n\n  /// CreateMetadataSlot - Insert the specified MDNode* into the slot table.\n  void CreateMetadataSlot(const MDNode *N);\n\n  /// CreateFunctionSlot - Insert the specified Value* into the slot table.\n  void CreateFunctionSlot(const Value *V);\n\n  /// Insert the specified AttributeSet into the slot table.\n  void CreateAttributeSetSlot(AttributeSet AS);\n\n  inline void CreateModulePathSlot(StringRef Path);\n  void CreateGUIDSlot(GlobalValue::GUID GUID);\n  void CreateTypeIdSlot(StringRef Id);\n\n  /// Add all of the module level global variables (and their initializers)\n  /// and function declarations, but not the contents of those functions.\n  void processModule();\n  // Returns number of allocated slots\n  int processIndex();\n\n  /// Add all of the functions arguments, basic blocks, and instructions.\n  void processFunction();\n\n  /// Add the metadata directly attached to a GlobalObject.\n  void processGlobalObjectMetadata(const GlobalObject &GO);\n\n  /// Add all of the metadata from a function.\n  void processFunctionMetadata(const Function &F);\n\n  /// Add all of the metadata from an instruction.\n  void processInstructionMetadata(const Instruction &I);\n};\n\n} // end namespace llvm\n\nModuleSlotTracker::ModuleSlotTracker(SlotTracker &Machine, const Module *M,\n                                     const Function *F)\n    : M(M), F(F), Machine(&Machine) {}\n\nModuleSlotTracker::ModuleSlotTracker(const Module *M,\n                                     bool ShouldInitializeAllMetadata)\n    : ShouldCreateStorage(M),\n      ShouldInitializeAllMetadata(ShouldInitializeAllMetadata), M(M) {}\n\nModuleSlotTracker::~ModuleSlotTracker() = default;\n\nSlotTracker *ModuleSlotTracker::getMachine() {\n  if (!ShouldCreateStorage)\n    return Machine;\n\n  ShouldCreateStorage = false;\n  MachineStorage =\n      std::make_unique<SlotTracker>(M, ShouldInitializeAllMetadata);\n  Machine = MachineStorage.get();\n  return Machine;\n}\n\nvoid ModuleSlotTracker::incorporateFunction(const Function &F) {\n  // Using getMachine() may lazily create the slot tracker.\n  if (!getMachine())\n    return;\n\n  // Nothing to do if this is the right function already.\n  if (this->F == &F)\n    return;\n  if (this->F)\n    Machine->purgeFunction();\n  Machine->incorporateFunction(&F);\n  this->F = &F;\n}\n\nint ModuleSlotTracker::getLocalSlot(const Value *V) {\n  assert(F && \"No function incorporated\");\n  return Machine->getLocalSlot(V);\n}\n\nstatic SlotTracker *createSlotTracker(const Value *V) {\n  if (const Argument *FA = dyn_cast<Argument>(V))\n    return new SlotTracker(FA->getParent());\n\n  if (const Instruction *I = dyn_cast<Instruction>(V))\n    if (I->getParent())\n      return new SlotTracker(I->getParent()->getParent());\n\n  if (const BasicBlock *BB = dyn_cast<BasicBlock>(V))\n    return new SlotTracker(BB->getParent());\n\n  if (const GlobalVariable *GV = dyn_cast<GlobalVariable>(V))\n    return new SlotTracker(GV->getParent());\n\n  if (const GlobalAlias *GA = dyn_cast<GlobalAlias>(V))\n    return new SlotTracker(GA->getParent());\n\n  if (const GlobalIFunc *GIF = dyn_cast<GlobalIFunc>(V))\n    return new SlotTracker(GIF->getParent());\n\n  if (const Function *Func = dyn_cast<Function>(V))\n    return new SlotTracker(Func);\n\n  return nullptr;\n}\n\n#if 0\n#define ST_DEBUG(X) dbgs() << X\n#else\n#define ST_DEBUG(X)\n#endif\n\n// Module level constructor. Causes the contents of the Module (sans functions)\n// to be added to the slot table.\nSlotTracker::SlotTracker(const Module *M, bool ShouldInitializeAllMetadata)\n    : TheModule(M), ShouldInitializeAllMetadata(ShouldInitializeAllMetadata) {}\n\n// Function level constructor. Causes the contents of the Module and the one\n// function provided to be added to the slot table.\nSlotTracker::SlotTracker(const Function *F, bool ShouldInitializeAllMetadata)\n    : TheModule(F ? F->getParent() : nullptr), TheFunction(F),\n      ShouldInitializeAllMetadata(ShouldInitializeAllMetadata) {}\n\nSlotTracker::SlotTracker(const ModuleSummaryIndex *Index)\n    : TheModule(nullptr), ShouldInitializeAllMetadata(false), TheIndex(Index) {}\n\ninline void SlotTracker::initializeIfNeeded() {\n  if (TheModule) {\n    processModule();\n    TheModule = nullptr; ///< Prevent re-processing next time we're called.\n  }\n\n  if (TheFunction && !FunctionProcessed)\n    processFunction();\n}\n\nint SlotTracker::initializeIndexIfNeeded() {\n  if (!TheIndex)\n    return 0;\n  int NumSlots = processIndex();\n  TheIndex = nullptr; ///< Prevent re-processing next time we're called.\n  return NumSlots;\n}\n\n// Iterate through all the global variables, functions, and global\n// variable initializers and create slots for them.\nvoid SlotTracker::processModule() {\n  ST_DEBUG(\"begin processModule!\\n\");\n\n  // Add all of the unnamed global variables to the value table.\n  for (const GlobalVariable &Var : TheModule->globals()) {\n    if (!Var.hasName())\n      CreateModuleSlot(&Var);\n    processGlobalObjectMetadata(Var);\n    auto Attrs = Var.getAttributes();\n    if (Attrs.hasAttributes())\n      CreateAttributeSetSlot(Attrs);\n  }\n\n  for (const GlobalAlias &A : TheModule->aliases()) {\n    if (!A.hasName())\n      CreateModuleSlot(&A);\n  }\n\n  for (const GlobalIFunc &I : TheModule->ifuncs()) {\n    if (!I.hasName())\n      CreateModuleSlot(&I);\n  }\n\n  // Add metadata used by named metadata.\n  for (const NamedMDNode &NMD : TheModule->named_metadata()) {\n    for (unsigned i = 0, e = NMD.getNumOperands(); i != e; ++i)\n      CreateMetadataSlot(NMD.getOperand(i));\n  }\n\n  for (const Function &F : *TheModule) {\n    if (!F.hasName())\n      // Add all the unnamed functions to the table.\n      CreateModuleSlot(&F);\n\n    if (ShouldInitializeAllMetadata)\n      processFunctionMetadata(F);\n\n    // Add all the function attributes to the table.\n    // FIXME: Add attributes of other objects?\n    AttributeSet FnAttrs = F.getAttributes().getFnAttributes();\n    if (FnAttrs.hasAttributes())\n      CreateAttributeSetSlot(FnAttrs);\n  }\n\n  ST_DEBUG(\"end processModule!\\n\");\n}\n\n// Process the arguments, basic blocks, and instructions  of a function.\nvoid SlotTracker::processFunction() {\n  ST_DEBUG(\"begin processFunction!\\n\");\n  fNext = 0;\n\n  // Process function metadata if it wasn't hit at the module-level.\n  if (!ShouldInitializeAllMetadata)\n    processFunctionMetadata(*TheFunction);\n\n  // Add all the function arguments with no names.\n  for(Function::const_arg_iterator AI = TheFunction->arg_begin(),\n      AE = TheFunction->arg_end(); AI != AE; ++AI)\n    if (!AI->hasName())\n      CreateFunctionSlot(&*AI);\n\n  ST_DEBUG(\"Inserting Instructions:\\n\");\n\n  // Add all of the basic blocks and instructions with no names.\n  for (auto &BB : *TheFunction) {\n    if (!BB.hasName())\n      CreateFunctionSlot(&BB);\n\n    for (auto &I : BB) {\n      if (!I.getType()->isVoidTy() && !I.hasName())\n        CreateFunctionSlot(&I);\n\n      // We allow direct calls to any llvm.foo function here, because the\n      // target may not be linked into the optimizer.\n      if (const auto *Call = dyn_cast<CallBase>(&I)) {\n        // Add all the call attributes to the table.\n        AttributeSet Attrs = Call->getAttributes().getFnAttributes();\n        if (Attrs.hasAttributes())\n          CreateAttributeSetSlot(Attrs);\n      }\n    }\n  }\n\n  FunctionProcessed = true;\n\n  ST_DEBUG(\"end processFunction!\\n\");\n}\n\n// Iterate through all the GUID in the index and create slots for them.\nint SlotTracker::processIndex() {\n  ST_DEBUG(\"begin processIndex!\\n\");\n  assert(TheIndex);\n\n  // The first block of slots are just the module ids, which start at 0 and are\n  // assigned consecutively. Since the StringMap iteration order isn't\n  // guaranteed, use a std::map to order by module ID before assigning slots.\n  std::map<uint64_t, StringRef> ModuleIdToPathMap;\n  for (auto &ModPath : TheIndex->modulePaths())\n    ModuleIdToPathMap[ModPath.second.first] = ModPath.first();\n  for (auto &ModPair : ModuleIdToPathMap)\n    CreateModulePathSlot(ModPair.second);\n\n  // Start numbering the GUIDs after the module ids.\n  GUIDNext = ModulePathNext;\n\n  for (auto &GlobalList : *TheIndex)\n    CreateGUIDSlot(GlobalList.first);\n\n  for (auto &TId : TheIndex->typeIdCompatibleVtableMap())\n    CreateGUIDSlot(GlobalValue::getGUID(TId.first));\n\n  // Start numbering the TypeIds after the GUIDs.\n  TypeIdNext = GUIDNext;\n  for (auto TidIter = TheIndex->typeIds().begin();\n       TidIter != TheIndex->typeIds().end(); TidIter++)\n    CreateTypeIdSlot(TidIter->second.first);\n\n  ST_DEBUG(\"end processIndex!\\n\");\n  return TypeIdNext;\n}\n\nvoid SlotTracker::processGlobalObjectMetadata(const GlobalObject &GO) {\n  SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;\n  GO.getAllMetadata(MDs);\n  for (auto &MD : MDs)\n    CreateMetadataSlot(MD.second);\n}\n\nvoid SlotTracker::processFunctionMetadata(const Function &F) {\n  processGlobalObjectMetadata(F);\n  for (auto &BB : F) {\n    for (auto &I : BB)\n      processInstructionMetadata(I);\n  }\n}\n\nvoid SlotTracker::processInstructionMetadata(const Instruction &I) {\n  // Process metadata used directly by intrinsics.\n  if (const CallInst *CI = dyn_cast<CallInst>(&I))\n    if (Function *F = CI->getCalledFunction())\n      if (F->isIntrinsic())\n        for (auto &Op : I.operands())\n          if (auto *V = dyn_cast_or_null<MetadataAsValue>(Op))\n            if (MDNode *N = dyn_cast<MDNode>(V->getMetadata()))\n              CreateMetadataSlot(N);\n\n  // Process metadata attached to this instruction.\n  SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;\n  I.getAllMetadata(MDs);\n  for (auto &MD : MDs)\n    CreateMetadataSlot(MD.second);\n}\n\n/// Clean up after incorporating a function. This is the only way to get out of\n/// the function incorporation state that affects get*Slot/Create*Slot. Function\n/// incorporation state is indicated by TheFunction != 0.\nvoid SlotTracker::purgeFunction() {\n  ST_DEBUG(\"begin purgeFunction!\\n\");\n  fMap.clear(); // Simply discard the function level map\n  TheFunction = nullptr;\n  FunctionProcessed = false;\n  ST_DEBUG(\"end purgeFunction!\\n\");\n}\n\n/// getGlobalSlot - Get the slot number of a global value.\nint SlotTracker::getGlobalSlot(const GlobalValue *V) {\n  // Check for uninitialized state and do lazy initialization.\n  initializeIfNeeded();\n\n  // Find the value in the module map\n  ValueMap::iterator MI = mMap.find(V);\n  return MI == mMap.end() ? -1 : (int)MI->second;\n}\n\n/// getMetadataSlot - Get the slot number of a MDNode.\nint SlotTracker::getMetadataSlot(const MDNode *N) {\n  // Check for uninitialized state and do lazy initialization.\n  initializeIfNeeded();\n\n  // Find the MDNode in the module map\n  mdn_iterator MI = mdnMap.find(N);\n  return MI == mdnMap.end() ? -1 : (int)MI->second;\n}\n\n/// getLocalSlot - Get the slot number for a value that is local to a function.\nint SlotTracker::getLocalSlot(const Value *V) {\n  assert(!isa<Constant>(V) && \"Can't get a constant or global slot with this!\");\n\n  // Check for uninitialized state and do lazy initialization.\n  initializeIfNeeded();\n\n  ValueMap::iterator FI = fMap.find(V);\n  return FI == fMap.end() ? -1 : (int)FI->second;\n}\n\nint SlotTracker::getAttributeGroupSlot(AttributeSet AS) {\n  // Check for uninitialized state and do lazy initialization.\n  initializeIfNeeded();\n\n  // Find the AttributeSet in the module map.\n  as_iterator AI = asMap.find(AS);\n  return AI == asMap.end() ? -1 : (int)AI->second;\n}\n\nint SlotTracker::getModulePathSlot(StringRef Path) {\n  // Check for uninitialized state and do lazy initialization.\n  initializeIndexIfNeeded();\n\n  // Find the Module path in the map\n  auto I = ModulePathMap.find(Path);\n  return I == ModulePathMap.end() ? -1 : (int)I->second;\n}\n\nint SlotTracker::getGUIDSlot(GlobalValue::GUID GUID) {\n  // Check for uninitialized state and do lazy initialization.\n  initializeIndexIfNeeded();\n\n  // Find the GUID in the map\n  guid_iterator I = GUIDMap.find(GUID);\n  return I == GUIDMap.end() ? -1 : (int)I->second;\n}\n\nint SlotTracker::getTypeIdSlot(StringRef Id) {\n  // Check for uninitialized state and do lazy initialization.\n  initializeIndexIfNeeded();\n\n  // Find the TypeId string in the map\n  auto I = TypeIdMap.find(Id);\n  return I == TypeIdMap.end() ? -1 : (int)I->second;\n}\n\n/// CreateModuleSlot - Insert the specified GlobalValue* into the slot table.\nvoid SlotTracker::CreateModuleSlot(const GlobalValue *V) {\n  assert(V && \"Can't insert a null Value into SlotTracker!\");\n  assert(!V->getType()->isVoidTy() && \"Doesn't need a slot!\");\n  assert(!V->hasName() && \"Doesn't need a slot!\");\n\n  unsigned DestSlot = mNext++;\n  mMap[V] = DestSlot;\n\n  ST_DEBUG(\"  Inserting value [\" << V->getType() << \"] = \" << V << \" slot=\" <<\n           DestSlot << \" [\");\n  // G = Global, F = Function, A = Alias, I = IFunc, o = other\n  ST_DEBUG((isa<GlobalVariable>(V) ? 'G' :\n            (isa<Function>(V) ? 'F' :\n             (isa<GlobalAlias>(V) ? 'A' :\n              (isa<GlobalIFunc>(V) ? 'I' : 'o')))) << \"]\\n\");\n}\n\n/// CreateSlot - Create a new slot for the specified value if it has no name.\nvoid SlotTracker::CreateFunctionSlot(const Value *V) {\n  assert(!V->getType()->isVoidTy() && !V->hasName() && \"Doesn't need a slot!\");\n\n  unsigned DestSlot = fNext++;\n  fMap[V] = DestSlot;\n\n  // G = Global, F = Function, o = other\n  ST_DEBUG(\"  Inserting value [\" << V->getType() << \"] = \" << V << \" slot=\" <<\n           DestSlot << \" [o]\\n\");\n}\n\n/// CreateModuleSlot - Insert the specified MDNode* into the slot table.\nvoid SlotTracker::CreateMetadataSlot(const MDNode *N) {\n  assert(N && \"Can't insert a null Value into SlotTracker!\");\n\n  // Don't make slots for DIExpressions. We just print them inline everywhere.\n  if (isa<DIExpression>(N))\n    return;\n\n  unsigned DestSlot = mdnNext;\n  if (!mdnMap.insert(std::make_pair(N, DestSlot)).second)\n    return;\n  ++mdnNext;\n\n  // Recursively add any MDNodes referenced by operands.\n  for (unsigned i = 0, e = N->getNumOperands(); i != e; ++i)\n    if (const MDNode *Op = dyn_cast_or_null<MDNode>(N->getOperand(i)))\n      CreateMetadataSlot(Op);\n}\n\nvoid SlotTracker::CreateAttributeSetSlot(AttributeSet AS) {\n  assert(AS.hasAttributes() && \"Doesn't need a slot!\");\n\n  as_iterator I = asMap.find(AS);\n  if (I != asMap.end())\n    return;\n\n  unsigned DestSlot = asNext++;\n  asMap[AS] = DestSlot;\n}\n\n/// Create a new slot for the specified Module\nvoid SlotTracker::CreateModulePathSlot(StringRef Path) {\n  ModulePathMap[Path] = ModulePathNext++;\n}\n\n/// Create a new slot for the specified GUID\nvoid SlotTracker::CreateGUIDSlot(GlobalValue::GUID GUID) {\n  GUIDMap[GUID] = GUIDNext++;\n}\n\n/// Create a new slot for the specified Id\nvoid SlotTracker::CreateTypeIdSlot(StringRef Id) {\n  TypeIdMap[Id] = TypeIdNext++;\n}\n\n//===----------------------------------------------------------------------===//\n// AsmWriter Implementation\n//===----------------------------------------------------------------------===//\n\nstatic void WriteAsOperandInternal(raw_ostream &Out, const Value *V,\n                                   TypePrinting *TypePrinter,\n                                   SlotTracker *Machine,\n                                   const Module *Context);\n\nstatic void WriteAsOperandInternal(raw_ostream &Out, const Metadata *MD,\n                                   TypePrinting *TypePrinter,\n                                   SlotTracker *Machine, const Module *Context,\n                                   bool FromValue = false);\n\nstatic void WriteOptimizationInfo(raw_ostream &Out, const User *U) {\n  if (const FPMathOperator *FPO = dyn_cast<const FPMathOperator>(U)) {\n    // 'Fast' is an abbreviation for all fast-math-flags.\n    if (FPO->isFast())\n      Out << \" fast\";\n    else {\n      if (FPO->hasAllowReassoc())\n        Out << \" reassoc\";\n      if (FPO->hasNoNaNs())\n        Out << \" nnan\";\n      if (FPO->hasNoInfs())\n        Out << \" ninf\";\n      if (FPO->hasNoSignedZeros())\n        Out << \" nsz\";\n      if (FPO->hasAllowReciprocal())\n        Out << \" arcp\";\n      if (FPO->hasAllowContract())\n        Out << \" contract\";\n      if (FPO->hasApproxFunc())\n        Out << \" afn\";\n    }\n  }\n\n  if (const OverflowingBinaryOperator *OBO =\n        dyn_cast<OverflowingBinaryOperator>(U)) {\n    if (OBO->hasNoUnsignedWrap())\n      Out << \" nuw\";\n    if (OBO->hasNoSignedWrap())\n      Out << \" nsw\";\n  } else if (const PossiblyExactOperator *Div =\n               dyn_cast<PossiblyExactOperator>(U)) {\n    if (Div->isExact())\n      Out << \" exact\";\n  } else if (const GEPOperator *GEP = dyn_cast<GEPOperator>(U)) {\n    if (GEP->isInBounds())\n      Out << \" inbounds\";\n  }\n}\n\nstatic void WriteConstantInternal(raw_ostream &Out, const Constant *CV,\n                                  TypePrinting &TypePrinter,\n                                  SlotTracker *Machine,\n                                  const Module *Context) {\n  if (const ConstantInt *CI = dyn_cast<ConstantInt>(CV)) {\n    if (CI->getType()->isIntegerTy(1)) {\n      Out << (CI->getZExtValue() ? \"true\" : \"false\");\n      return;\n    }\n    Out << CI->getValue();\n    return;\n  }\n\n  if (const ConstantFP *CFP = dyn_cast<ConstantFP>(CV)) {\n    const APFloat &APF = CFP->getValueAPF();\n    if (&APF.getSemantics() == &APFloat::IEEEsingle() ||\n        &APF.getSemantics() == &APFloat::IEEEdouble()) {\n      // We would like to output the FP constant value in exponential notation,\n      // but we cannot do this if doing so will lose precision.  Check here to\n      // make sure that we only output it in exponential format if we can parse\n      // the value back and get the same value.\n      //\n      bool ignored;\n      bool isDouble = &APF.getSemantics() == &APFloat::IEEEdouble();\n      bool isInf = APF.isInfinity();\n      bool isNaN = APF.isNaN();\n      if (!isInf && !isNaN) {\n        double Val = isDouble ? APF.convertToDouble() : APF.convertToFloat();\n        SmallString<128> StrVal;\n        APF.toString(StrVal, 6, 0, false);\n        // Check to make sure that the stringized number is not some string like\n        // \"Inf\" or NaN, that atof will accept, but the lexer will not.  Check\n        // that the string matches the \"[-+]?[0-9]\" regex.\n        //\n        assert((isDigit(StrVal[0]) || ((StrVal[0] == '-' || StrVal[0] == '+') &&\n                                       isDigit(StrVal[1]))) &&\n               \"[-+]?[0-9] regex does not match!\");\n        // Reparse stringized version!\n        if (APFloat(APFloat::IEEEdouble(), StrVal).convertToDouble() == Val) {\n          Out << StrVal;\n          return;\n        }\n      }\n      // Otherwise we could not reparse it to exactly the same value, so we must\n      // output the string in hexadecimal format!  Note that loading and storing\n      // floating point types changes the bits of NaNs on some hosts, notably\n      // x86, so we must not use these types.\n      static_assert(sizeof(double) == sizeof(uint64_t),\n                    \"assuming that double is 64 bits!\");\n      APFloat apf = APF;\n      // Floats are represented in ASCII IR as double, convert.\n      // FIXME: We should allow 32-bit hex float and remove this.\n      if (!isDouble) {\n        // A signaling NaN is quieted on conversion, so we need to recreate the\n        // expected value after convert (quiet bit of the payload is clear).\n        bool IsSNAN = apf.isSignaling();\n        apf.convert(APFloat::IEEEdouble(), APFloat::rmNearestTiesToEven,\n                    &ignored);\n        if (IsSNAN) {\n          APInt Payload = apf.bitcastToAPInt();\n          apf = APFloat::getSNaN(APFloat::IEEEdouble(), apf.isNegative(),\n                                 &Payload);\n        }\n      }\n      Out << format_hex(apf.bitcastToAPInt().getZExtValue(), 0, /*Upper=*/true);\n      return;\n    }\n\n    // Either half, bfloat or some form of long double.\n    // These appear as a magic letter identifying the type, then a\n    // fixed number of hex digits.\n    Out << \"0x\";\n    APInt API = APF.bitcastToAPInt();\n    if (&APF.getSemantics() == &APFloat::x87DoubleExtended()) {\n      Out << 'K';\n      Out << format_hex_no_prefix(API.getHiBits(16).getZExtValue(), 4,\n                                  /*Upper=*/true);\n      Out << format_hex_no_prefix(API.getLoBits(64).getZExtValue(), 16,\n                                  /*Upper=*/true);\n      return;\n    } else if (&APF.getSemantics() == &APFloat::IEEEquad()) {\n      Out << 'L';\n      Out << format_hex_no_prefix(API.getLoBits(64).getZExtValue(), 16,\n                                  /*Upper=*/true);\n      Out << format_hex_no_prefix(API.getHiBits(64).getZExtValue(), 16,\n                                  /*Upper=*/true);\n    } else if (&APF.getSemantics() == &APFloat::PPCDoubleDouble()) {\n      Out << 'M';\n      Out << format_hex_no_prefix(API.getLoBits(64).getZExtValue(), 16,\n                                  /*Upper=*/true);\n      Out << format_hex_no_prefix(API.getHiBits(64).getZExtValue(), 16,\n                                  /*Upper=*/true);\n    } else if (&APF.getSemantics() == &APFloat::IEEEhalf()) {\n      Out << 'H';\n      Out << format_hex_no_prefix(API.getZExtValue(), 4,\n                                  /*Upper=*/true);\n    } else if (&APF.getSemantics() == &APFloat::BFloat()) {\n      Out << 'R';\n      Out << format_hex_no_prefix(API.getZExtValue(), 4,\n                                  /*Upper=*/true);\n    } else\n      llvm_unreachable(\"Unsupported floating point type\");\n    return;\n  }\n\n  if (isa<ConstantAggregateZero>(CV)) {\n    Out << \"zeroinitializer\";\n    return;\n  }\n\n  if (const BlockAddress *BA = dyn_cast<BlockAddress>(CV)) {\n    Out << \"blockaddress(\";\n    WriteAsOperandInternal(Out, BA->getFunction(), &TypePrinter, Machine,\n                           Context);\n    Out << \", \";\n    WriteAsOperandInternal(Out, BA->getBasicBlock(), &TypePrinter, Machine,\n                           Context);\n    Out << \")\";\n    return;\n  }\n\n  if (const auto *Equiv = dyn_cast<DSOLocalEquivalent>(CV)) {\n    Out << \"dso_local_equivalent \";\n    WriteAsOperandInternal(Out, Equiv->getGlobalValue(), &TypePrinter, Machine,\n                           Context);\n    return;\n  }\n\n  if (const ConstantArray *CA = dyn_cast<ConstantArray>(CV)) {\n    Type *ETy = CA->getType()->getElementType();\n    Out << '[';\n    TypePrinter.print(ETy, Out);\n    Out << ' ';\n    WriteAsOperandInternal(Out, CA->getOperand(0),\n                           &TypePrinter, Machine,\n                           Context);\n    for (unsigned i = 1, e = CA->getNumOperands(); i != e; ++i) {\n      Out << \", \";\n      TypePrinter.print(ETy, Out);\n      Out << ' ';\n      WriteAsOperandInternal(Out, CA->getOperand(i), &TypePrinter, Machine,\n                             Context);\n    }\n    Out << ']';\n    return;\n  }\n\n  if (const ConstantDataArray *CA = dyn_cast<ConstantDataArray>(CV)) {\n    // As a special case, print the array as a string if it is an array of\n    // i8 with ConstantInt values.\n    if (CA->isString()) {\n      Out << \"c\\\"\";\n      printEscapedString(CA->getAsString(), Out);\n      Out << '\"';\n      return;\n    }\n\n    Type *ETy = CA->getType()->getElementType();\n    Out << '[';\n    TypePrinter.print(ETy, Out);\n    Out << ' ';\n    WriteAsOperandInternal(Out, CA->getElementAsConstant(0),\n                           &TypePrinter, Machine,\n                           Context);\n    for (unsigned i = 1, e = CA->getNumElements(); i != e; ++i) {\n      Out << \", \";\n      TypePrinter.print(ETy, Out);\n      Out << ' ';\n      WriteAsOperandInternal(Out, CA->getElementAsConstant(i), &TypePrinter,\n                             Machine, Context);\n    }\n    Out << ']';\n    return;\n  }\n\n  if (const ConstantStruct *CS = dyn_cast<ConstantStruct>(CV)) {\n    if (CS->getType()->isPacked())\n      Out << '<';\n    Out << '{';\n    unsigned N = CS->getNumOperands();\n    if (N) {\n      Out << ' ';\n      TypePrinter.print(CS->getOperand(0)->getType(), Out);\n      Out << ' ';\n\n      WriteAsOperandInternal(Out, CS->getOperand(0), &TypePrinter, Machine,\n                             Context);\n\n      for (unsigned i = 1; i < N; i++) {\n        Out << \", \";\n        TypePrinter.print(CS->getOperand(i)->getType(), Out);\n        Out << ' ';\n\n        WriteAsOperandInternal(Out, CS->getOperand(i), &TypePrinter, Machine,\n                               Context);\n      }\n      Out << ' ';\n    }\n\n    Out << '}';\n    if (CS->getType()->isPacked())\n      Out << '>';\n    return;\n  }\n\n  if (isa<ConstantVector>(CV) || isa<ConstantDataVector>(CV)) {\n    auto *CVVTy = cast<FixedVectorType>(CV->getType());\n    Type *ETy = CVVTy->getElementType();\n    Out << '<';\n    TypePrinter.print(ETy, Out);\n    Out << ' ';\n    WriteAsOperandInternal(Out, CV->getAggregateElement(0U), &TypePrinter,\n                           Machine, Context);\n    for (unsigned i = 1, e = CVVTy->getNumElements(); i != e; ++i) {\n      Out << \", \";\n      TypePrinter.print(ETy, Out);\n      Out << ' ';\n      WriteAsOperandInternal(Out, CV->getAggregateElement(i), &TypePrinter,\n                             Machine, Context);\n    }\n    Out << '>';\n    return;\n  }\n\n  if (isa<ConstantPointerNull>(CV)) {\n    Out << \"null\";\n    return;\n  }\n\n  if (isa<ConstantTokenNone>(CV)) {\n    Out << \"none\";\n    return;\n  }\n\n  if (isa<PoisonValue>(CV)) {\n    Out << \"poison\";\n    return;\n  }\n\n  if (isa<UndefValue>(CV)) {\n    Out << \"undef\";\n    return;\n  }\n\n  if (const ConstantExpr *CE = dyn_cast<ConstantExpr>(CV)) {\n    Out << CE->getOpcodeName();\n    WriteOptimizationInfo(Out, CE);\n    if (CE->isCompare())\n      Out << ' ' << CmpInst::getPredicateName(\n                        static_cast<CmpInst::Predicate>(CE->getPredicate()));\n    Out << \" (\";\n\n    Optional<unsigned> InRangeOp;\n    if (const GEPOperator *GEP = dyn_cast<GEPOperator>(CE)) {\n      TypePrinter.print(GEP->getSourceElementType(), Out);\n      Out << \", \";\n      InRangeOp = GEP->getInRangeIndex();\n      if (InRangeOp)\n        ++*InRangeOp;\n    }\n\n    for (User::const_op_iterator OI=CE->op_begin(); OI != CE->op_end(); ++OI) {\n      if (InRangeOp && unsigned(OI - CE->op_begin()) == *InRangeOp)\n        Out << \"inrange \";\n      TypePrinter.print((*OI)->getType(), Out);\n      Out << ' ';\n      WriteAsOperandInternal(Out, *OI, &TypePrinter, Machine, Context);\n      if (OI+1 != CE->op_end())\n        Out << \", \";\n    }\n\n    if (CE->hasIndices()) {\n      ArrayRef<unsigned> Indices = CE->getIndices();\n      for (unsigned i = 0, e = Indices.size(); i != e; ++i)\n        Out << \", \" << Indices[i];\n    }\n\n    if (CE->isCast()) {\n      Out << \" to \";\n      TypePrinter.print(CE->getType(), Out);\n    }\n\n    if (CE->getOpcode() == Instruction::ShuffleVector)\n      PrintShuffleMask(Out, CE->getType(), CE->getShuffleMask());\n\n    Out << ')';\n    return;\n  }\n\n  Out << \"<placeholder or erroneous Constant>\";\n}\n\nstatic void writeMDTuple(raw_ostream &Out, const MDTuple *Node,\n                         TypePrinting *TypePrinter, SlotTracker *Machine,\n                         const Module *Context) {\n  Out << \"!{\";\n  for (unsigned mi = 0, me = Node->getNumOperands(); mi != me; ++mi) {\n    const Metadata *MD = Node->getOperand(mi);\n    if (!MD)\n      Out << \"null\";\n    else if (auto *MDV = dyn_cast<ValueAsMetadata>(MD)) {\n      Value *V = MDV->getValue();\n      TypePrinter->print(V->getType(), Out);\n      Out << ' ';\n      WriteAsOperandInternal(Out, V, TypePrinter, Machine, Context);\n    } else {\n      WriteAsOperandInternal(Out, MD, TypePrinter, Machine, Context);\n    }\n    if (mi + 1 != me)\n      Out << \", \";\n  }\n\n  Out << \"}\";\n}\n\nnamespace {\n\nstruct FieldSeparator {\n  bool Skip = true;\n  const char *Sep;\n\n  FieldSeparator(const char *Sep = \", \") : Sep(Sep) {}\n};\n\nraw_ostream &operator<<(raw_ostream &OS, FieldSeparator &FS) {\n  if (FS.Skip) {\n    FS.Skip = false;\n    return OS;\n  }\n  return OS << FS.Sep;\n}\n\nstruct MDFieldPrinter {\n  raw_ostream &Out;\n  FieldSeparator FS;\n  TypePrinting *TypePrinter = nullptr;\n  SlotTracker *Machine = nullptr;\n  const Module *Context = nullptr;\n\n  explicit MDFieldPrinter(raw_ostream &Out) : Out(Out) {}\n  MDFieldPrinter(raw_ostream &Out, TypePrinting *TypePrinter,\n                 SlotTracker *Machine, const Module *Context)\n      : Out(Out), TypePrinter(TypePrinter), Machine(Machine), Context(Context) {\n  }\n\n  void printTag(const DINode *N);\n  void printMacinfoType(const DIMacroNode *N);\n  void printChecksum(const DIFile::ChecksumInfo<StringRef> &N);\n  void printString(StringRef Name, StringRef Value,\n                   bool ShouldSkipEmpty = true);\n  void printMetadata(StringRef Name, const Metadata *MD,\n                     bool ShouldSkipNull = true);\n  template <class IntTy>\n  void printInt(StringRef Name, IntTy Int, bool ShouldSkipZero = true);\n  void printAPInt(StringRef Name, const APInt &Int, bool IsUnsigned,\n                  bool ShouldSkipZero);\n  void printBool(StringRef Name, bool Value, Optional<bool> Default = None);\n  void printDIFlags(StringRef Name, DINode::DIFlags Flags);\n  void printDISPFlags(StringRef Name, DISubprogram::DISPFlags Flags);\n  template <class IntTy, class Stringifier>\n  void printDwarfEnum(StringRef Name, IntTy Value, Stringifier toString,\n                      bool ShouldSkipZero = true);\n  void printEmissionKind(StringRef Name, DICompileUnit::DebugEmissionKind EK);\n  void printNameTableKind(StringRef Name,\n                          DICompileUnit::DebugNameTableKind NTK);\n};\n\n} // end anonymous namespace\n\nvoid MDFieldPrinter::printTag(const DINode *N) {\n  Out << FS << \"tag: \";\n  auto Tag = dwarf::TagString(N->getTag());\n  if (!Tag.empty())\n    Out << Tag;\n  else\n    Out << N->getTag();\n}\n\nvoid MDFieldPrinter::printMacinfoType(const DIMacroNode *N) {\n  Out << FS << \"type: \";\n  auto Type = dwarf::MacinfoString(N->getMacinfoType());\n  if (!Type.empty())\n    Out << Type;\n  else\n    Out << N->getMacinfoType();\n}\n\nvoid MDFieldPrinter::printChecksum(\n    const DIFile::ChecksumInfo<StringRef> &Checksum) {\n  Out << FS << \"checksumkind: \" << Checksum.getKindAsString();\n  printString(\"checksum\", Checksum.Value, /* ShouldSkipEmpty */ false);\n}\n\nvoid MDFieldPrinter::printString(StringRef Name, StringRef Value,\n                                 bool ShouldSkipEmpty) {\n  if (ShouldSkipEmpty && Value.empty())\n    return;\n\n  Out << FS << Name << \": \\\"\";\n  printEscapedString(Value, Out);\n  Out << \"\\\"\";\n}\n\nstatic void writeMetadataAsOperand(raw_ostream &Out, const Metadata *MD,\n                                   TypePrinting *TypePrinter,\n                                   SlotTracker *Machine,\n                                   const Module *Context) {\n  if (!MD) {\n    Out << \"null\";\n    return;\n  }\n  WriteAsOperandInternal(Out, MD, TypePrinter, Machine, Context);\n}\n\nvoid MDFieldPrinter::printMetadata(StringRef Name, const Metadata *MD,\n                                   bool ShouldSkipNull) {\n  if (ShouldSkipNull && !MD)\n    return;\n\n  Out << FS << Name << \": \";\n  writeMetadataAsOperand(Out, MD, TypePrinter, Machine, Context);\n}\n\ntemplate <class IntTy>\nvoid MDFieldPrinter::printInt(StringRef Name, IntTy Int, bool ShouldSkipZero) {\n  if (ShouldSkipZero && !Int)\n    return;\n\n  Out << FS << Name << \": \" << Int;\n}\n\nvoid MDFieldPrinter::printAPInt(StringRef Name, const APInt &Int,\n                                bool IsUnsigned, bool ShouldSkipZero) {\n  if (ShouldSkipZero && Int.isNullValue())\n    return;\n\n  Out << FS << Name << \": \";\n  Int.print(Out, !IsUnsigned);\n}\n\nvoid MDFieldPrinter::printBool(StringRef Name, bool Value,\n                               Optional<bool> Default) {\n  if (Default && Value == *Default)\n    return;\n  Out << FS << Name << \": \" << (Value ? \"true\" : \"false\");\n}\n\nvoid MDFieldPrinter::printDIFlags(StringRef Name, DINode::DIFlags Flags) {\n  if (!Flags)\n    return;\n\n  Out << FS << Name << \": \";\n\n  SmallVector<DINode::DIFlags, 8> SplitFlags;\n  auto Extra = DINode::splitFlags(Flags, SplitFlags);\n\n  FieldSeparator FlagsFS(\" | \");\n  for (auto F : SplitFlags) {\n    auto StringF = DINode::getFlagString(F);\n    assert(!StringF.empty() && \"Expected valid flag\");\n    Out << FlagsFS << StringF;\n  }\n  if (Extra || SplitFlags.empty())\n    Out << FlagsFS << Extra;\n}\n\nvoid MDFieldPrinter::printDISPFlags(StringRef Name,\n                                    DISubprogram::DISPFlags Flags) {\n  // Always print this field, because no flags in the IR at all will be\n  // interpreted as old-style isDefinition: true.\n  Out << FS << Name << \": \";\n\n  if (!Flags) {\n    Out << 0;\n    return;\n  }\n\n  SmallVector<DISubprogram::DISPFlags, 8> SplitFlags;\n  auto Extra = DISubprogram::splitFlags(Flags, SplitFlags);\n\n  FieldSeparator FlagsFS(\" | \");\n  for (auto F : SplitFlags) {\n    auto StringF = DISubprogram::getFlagString(F);\n    assert(!StringF.empty() && \"Expected valid flag\");\n    Out << FlagsFS << StringF;\n  }\n  if (Extra || SplitFlags.empty())\n    Out << FlagsFS << Extra;\n}\n\nvoid MDFieldPrinter::printEmissionKind(StringRef Name,\n                                       DICompileUnit::DebugEmissionKind EK) {\n  Out << FS << Name << \": \" << DICompileUnit::emissionKindString(EK);\n}\n\nvoid MDFieldPrinter::printNameTableKind(StringRef Name,\n                                        DICompileUnit::DebugNameTableKind NTK) {\n  if (NTK == DICompileUnit::DebugNameTableKind::Default)\n    return;\n  Out << FS << Name << \": \" << DICompileUnit::nameTableKindString(NTK);\n}\n\ntemplate <class IntTy, class Stringifier>\nvoid MDFieldPrinter::printDwarfEnum(StringRef Name, IntTy Value,\n                                    Stringifier toString, bool ShouldSkipZero) {\n  if (!Value)\n    return;\n\n  Out << FS << Name << \": \";\n  auto S = toString(Value);\n  if (!S.empty())\n    Out << S;\n  else\n    Out << Value;\n}\n\nstatic void writeGenericDINode(raw_ostream &Out, const GenericDINode *N,\n                               TypePrinting *TypePrinter, SlotTracker *Machine,\n                               const Module *Context) {\n  Out << \"!GenericDINode(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printTag(N);\n  Printer.printString(\"header\", N->getHeader());\n  if (N->getNumDwarfOperands()) {\n    Out << Printer.FS << \"operands: {\";\n    FieldSeparator IFS;\n    for (auto &I : N->dwarf_operands()) {\n      Out << IFS;\n      writeMetadataAsOperand(Out, I, TypePrinter, Machine, Context);\n    }\n    Out << \"}\";\n  }\n  Out << \")\";\n}\n\nstatic void writeDILocation(raw_ostream &Out, const DILocation *DL,\n                            TypePrinting *TypePrinter, SlotTracker *Machine,\n                            const Module *Context) {\n  Out << \"!DILocation(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  // Always output the line, since 0 is a relevant and important value for it.\n  Printer.printInt(\"line\", DL->getLine(), /* ShouldSkipZero */ false);\n  Printer.printInt(\"column\", DL->getColumn());\n  Printer.printMetadata(\"scope\", DL->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printMetadata(\"inlinedAt\", DL->getRawInlinedAt());\n  Printer.printBool(\"isImplicitCode\", DL->isImplicitCode(),\n                    /* Default */ false);\n  Out << \")\";\n}\n\nstatic void writeDISubrange(raw_ostream &Out, const DISubrange *N,\n                            TypePrinting *TypePrinter, SlotTracker *Machine,\n                            const Module *Context) {\n  Out << \"!DISubrange(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  if (auto *CE = N->getCount().dyn_cast<ConstantInt*>())\n    Printer.printInt(\"count\", CE->getSExtValue(), /* ShouldSkipZero */ false);\n  else\n    Printer.printMetadata(\"count\", N->getCount().dyn_cast<DIVariable *>(),\n                          /*ShouldSkipNull */ true);\n\n  // A lowerBound of constant 0 should not be skipped, since it is different\n  // from an unspecified lower bound (= nullptr).\n  auto *LBound = N->getRawLowerBound();\n  if (auto *LE = dyn_cast_or_null<ConstantAsMetadata>(LBound)) {\n    auto *LV = cast<ConstantInt>(LE->getValue());\n    Printer.printInt(\"lowerBound\", LV->getSExtValue(),\n                     /* ShouldSkipZero */ false);\n  } else\n    Printer.printMetadata(\"lowerBound\", LBound, /*ShouldSkipNull */ true);\n\n  auto *UBound = N->getRawUpperBound();\n  if (auto *UE = dyn_cast_or_null<ConstantAsMetadata>(UBound)) {\n    auto *UV = cast<ConstantInt>(UE->getValue());\n    Printer.printInt(\"upperBound\", UV->getSExtValue(),\n                     /* ShouldSkipZero */ false);\n  } else\n    Printer.printMetadata(\"upperBound\", UBound, /*ShouldSkipNull */ true);\n\n  auto *Stride = N->getRawStride();\n  if (auto *SE = dyn_cast_or_null<ConstantAsMetadata>(Stride)) {\n    auto *SV = cast<ConstantInt>(SE->getValue());\n    Printer.printInt(\"stride\", SV->getSExtValue(), /* ShouldSkipZero */ false);\n  } else\n    Printer.printMetadata(\"stride\", Stride, /*ShouldSkipNull */ true);\n\n  Out << \")\";\n}\n\nstatic void writeDIGenericSubrange(raw_ostream &Out, const DIGenericSubrange *N,\n                                   TypePrinting *TypePrinter,\n                                   SlotTracker *Machine,\n                                   const Module *Context) {\n  Out << \"!DIGenericSubrange(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n\n  auto IsConstant = [&](Metadata *Bound) -> bool {\n    if (auto *BE = dyn_cast_or_null<DIExpression>(Bound)) {\n      return BE->isSignedConstant();\n    }\n    return false;\n  };\n\n  auto GetConstant = [&](Metadata *Bound) -> int64_t {\n    assert(IsConstant(Bound) && \"Expected constant\");\n    auto *BE = dyn_cast_or_null<DIExpression>(Bound);\n    return static_cast<int64_t>(BE->getElement(1));\n  };\n\n  auto *Count = N->getRawCountNode();\n  if (IsConstant(Count))\n    Printer.printInt(\"count\", GetConstant(Count),\n                     /* ShouldSkipZero */ false);\n  else\n    Printer.printMetadata(\"count\", Count, /*ShouldSkipNull */ true);\n\n  auto *LBound = N->getRawLowerBound();\n  if (IsConstant(LBound))\n    Printer.printInt(\"lowerBound\", GetConstant(LBound),\n                     /* ShouldSkipZero */ false);\n  else\n    Printer.printMetadata(\"lowerBound\", LBound, /*ShouldSkipNull */ true);\n\n  auto *UBound = N->getRawUpperBound();\n  if (IsConstant(UBound))\n    Printer.printInt(\"upperBound\", GetConstant(UBound),\n                     /* ShouldSkipZero */ false);\n  else\n    Printer.printMetadata(\"upperBound\", UBound, /*ShouldSkipNull */ true);\n\n  auto *Stride = N->getRawStride();\n  if (IsConstant(Stride))\n    Printer.printInt(\"stride\", GetConstant(Stride),\n                     /* ShouldSkipZero */ false);\n  else\n    Printer.printMetadata(\"stride\", Stride, /*ShouldSkipNull */ true);\n\n  Out << \")\";\n}\n\nstatic void writeDIEnumerator(raw_ostream &Out, const DIEnumerator *N,\n                              TypePrinting *, SlotTracker *, const Module *) {\n  Out << \"!DIEnumerator(\";\n  MDFieldPrinter Printer(Out);\n  Printer.printString(\"name\", N->getName(), /* ShouldSkipEmpty */ false);\n  Printer.printAPInt(\"value\", N->getValue(), N->isUnsigned(),\n                     /*ShouldSkipZero=*/false);\n  if (N->isUnsigned())\n    Printer.printBool(\"isUnsigned\", true);\n  Out << \")\";\n}\n\nstatic void writeDIBasicType(raw_ostream &Out, const DIBasicType *N,\n                             TypePrinting *, SlotTracker *, const Module *) {\n  Out << \"!DIBasicType(\";\n  MDFieldPrinter Printer(Out);\n  if (N->getTag() != dwarf::DW_TAG_base_type)\n    Printer.printTag(N);\n  Printer.printString(\"name\", N->getName());\n  Printer.printInt(\"size\", N->getSizeInBits());\n  Printer.printInt(\"align\", N->getAlignInBits());\n  Printer.printDwarfEnum(\"encoding\", N->getEncoding(),\n                         dwarf::AttributeEncodingString);\n  Printer.printDIFlags(\"flags\", N->getFlags());\n  Out << \")\";\n}\n\nstatic void writeDIStringType(raw_ostream &Out, const DIStringType *N,\n                              TypePrinting *TypePrinter, SlotTracker *Machine,\n                              const Module *Context) {\n  Out << \"!DIStringType(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  if (N->getTag() != dwarf::DW_TAG_string_type)\n    Printer.printTag(N);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"stringLength\", N->getRawStringLength());\n  Printer.printMetadata(\"stringLengthExpression\", N->getRawStringLengthExp());\n  Printer.printInt(\"size\", N->getSizeInBits());\n  Printer.printInt(\"align\", N->getAlignInBits());\n  Printer.printDwarfEnum(\"encoding\", N->getEncoding(),\n                         dwarf::AttributeEncodingString);\n  Out << \")\";\n}\n\nstatic void writeDIDerivedType(raw_ostream &Out, const DIDerivedType *N,\n                               TypePrinting *TypePrinter, SlotTracker *Machine,\n                               const Module *Context) {\n  Out << \"!DIDerivedType(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printTag(N);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"scope\", N->getRawScope());\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printMetadata(\"baseType\", N->getRawBaseType(),\n                        /* ShouldSkipNull */ false);\n  Printer.printInt(\"size\", N->getSizeInBits());\n  Printer.printInt(\"align\", N->getAlignInBits());\n  Printer.printInt(\"offset\", N->getOffsetInBits());\n  Printer.printDIFlags(\"flags\", N->getFlags());\n  Printer.printMetadata(\"extraData\", N->getRawExtraData());\n  if (const auto &DWARFAddressSpace = N->getDWARFAddressSpace())\n    Printer.printInt(\"dwarfAddressSpace\", *DWARFAddressSpace,\n                     /* ShouldSkipZero */ false);\n  Out << \")\";\n}\n\nstatic void writeDICompositeType(raw_ostream &Out, const DICompositeType *N,\n                                 TypePrinting *TypePrinter,\n                                 SlotTracker *Machine, const Module *Context) {\n  Out << \"!DICompositeType(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printTag(N);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"scope\", N->getRawScope());\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printMetadata(\"baseType\", N->getRawBaseType());\n  Printer.printInt(\"size\", N->getSizeInBits());\n  Printer.printInt(\"align\", N->getAlignInBits());\n  Printer.printInt(\"offset\", N->getOffsetInBits());\n  Printer.printDIFlags(\"flags\", N->getFlags());\n  Printer.printMetadata(\"elements\", N->getRawElements());\n  Printer.printDwarfEnum(\"runtimeLang\", N->getRuntimeLang(),\n                         dwarf::LanguageString);\n  Printer.printMetadata(\"vtableHolder\", N->getRawVTableHolder());\n  Printer.printMetadata(\"templateParams\", N->getRawTemplateParams());\n  Printer.printString(\"identifier\", N->getIdentifier());\n  Printer.printMetadata(\"discriminator\", N->getRawDiscriminator());\n  Printer.printMetadata(\"dataLocation\", N->getRawDataLocation());\n  Printer.printMetadata(\"associated\", N->getRawAssociated());\n  Printer.printMetadata(\"allocated\", N->getRawAllocated());\n  if (auto *RankConst = N->getRankConst())\n    Printer.printInt(\"rank\", RankConst->getSExtValue(),\n                     /* ShouldSkipZero */ false);\n  else\n    Printer.printMetadata(\"rank\", N->getRawRank(), /*ShouldSkipNull */ true);\n  Out << \")\";\n}\n\nstatic void writeDISubroutineType(raw_ostream &Out, const DISubroutineType *N,\n                                  TypePrinting *TypePrinter,\n                                  SlotTracker *Machine, const Module *Context) {\n  Out << \"!DISubroutineType(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printDIFlags(\"flags\", N->getFlags());\n  Printer.printDwarfEnum(\"cc\", N->getCC(), dwarf::ConventionString);\n  Printer.printMetadata(\"types\", N->getRawTypeArray(),\n                        /* ShouldSkipNull */ false);\n  Out << \")\";\n}\n\nstatic void writeDIFile(raw_ostream &Out, const DIFile *N, TypePrinting *,\n                        SlotTracker *, const Module *) {\n  Out << \"!DIFile(\";\n  MDFieldPrinter Printer(Out);\n  Printer.printString(\"filename\", N->getFilename(),\n                      /* ShouldSkipEmpty */ false);\n  Printer.printString(\"directory\", N->getDirectory(),\n                      /* ShouldSkipEmpty */ false);\n  // Print all values for checksum together, or not at all.\n  if (N->getChecksum())\n    Printer.printChecksum(*N->getChecksum());\n  Printer.printString(\"source\", N->getSource().getValueOr(StringRef()),\n                      /* ShouldSkipEmpty */ true);\n  Out << \")\";\n}\n\nstatic void writeDICompileUnit(raw_ostream &Out, const DICompileUnit *N,\n                               TypePrinting *TypePrinter, SlotTracker *Machine,\n                               const Module *Context) {\n  Out << \"!DICompileUnit(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printDwarfEnum(\"language\", N->getSourceLanguage(),\n                         dwarf::LanguageString, /* ShouldSkipZero */ false);\n  Printer.printMetadata(\"file\", N->getRawFile(), /* ShouldSkipNull */ false);\n  Printer.printString(\"producer\", N->getProducer());\n  Printer.printBool(\"isOptimized\", N->isOptimized());\n  Printer.printString(\"flags\", N->getFlags());\n  Printer.printInt(\"runtimeVersion\", N->getRuntimeVersion(),\n                   /* ShouldSkipZero */ false);\n  Printer.printString(\"splitDebugFilename\", N->getSplitDebugFilename());\n  Printer.printEmissionKind(\"emissionKind\", N->getEmissionKind());\n  Printer.printMetadata(\"enums\", N->getRawEnumTypes());\n  Printer.printMetadata(\"retainedTypes\", N->getRawRetainedTypes());\n  Printer.printMetadata(\"globals\", N->getRawGlobalVariables());\n  Printer.printMetadata(\"imports\", N->getRawImportedEntities());\n  Printer.printMetadata(\"macros\", N->getRawMacros());\n  Printer.printInt(\"dwoId\", N->getDWOId());\n  Printer.printBool(\"splitDebugInlining\", N->getSplitDebugInlining(), true);\n  Printer.printBool(\"debugInfoForProfiling\", N->getDebugInfoForProfiling(),\n                    false);\n  Printer.printNameTableKind(\"nameTableKind\", N->getNameTableKind());\n  Printer.printBool(\"rangesBaseAddress\", N->getRangesBaseAddress(), false);\n  Printer.printString(\"sysroot\", N->getSysRoot());\n  Printer.printString(\"sdk\", N->getSDK());\n  Out << \")\";\n}\n\nstatic void writeDISubprogram(raw_ostream &Out, const DISubprogram *N,\n                              TypePrinting *TypePrinter, SlotTracker *Machine,\n                              const Module *Context) {\n  Out << \"!DISubprogram(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printString(\"name\", N->getName());\n  Printer.printString(\"linkageName\", N->getLinkageName());\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printMetadata(\"type\", N->getRawType());\n  Printer.printInt(\"scopeLine\", N->getScopeLine());\n  Printer.printMetadata(\"containingType\", N->getRawContainingType());\n  if (N->getVirtuality() != dwarf::DW_VIRTUALITY_none ||\n      N->getVirtualIndex() != 0)\n    Printer.printInt(\"virtualIndex\", N->getVirtualIndex(), false);\n  Printer.printInt(\"thisAdjustment\", N->getThisAdjustment());\n  Printer.printDIFlags(\"flags\", N->getFlags());\n  Printer.printDISPFlags(\"spFlags\", N->getSPFlags());\n  Printer.printMetadata(\"unit\", N->getRawUnit());\n  Printer.printMetadata(\"templateParams\", N->getRawTemplateParams());\n  Printer.printMetadata(\"declaration\", N->getRawDeclaration());\n  Printer.printMetadata(\"retainedNodes\", N->getRawRetainedNodes());\n  Printer.printMetadata(\"thrownTypes\", N->getRawThrownTypes());\n  Out << \")\";\n}\n\nstatic void writeDILexicalBlock(raw_ostream &Out, const DILexicalBlock *N,\n                                TypePrinting *TypePrinter, SlotTracker *Machine,\n                                const Module *Context) {\n  Out << \"!DILexicalBlock(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printInt(\"column\", N->getColumn());\n  Out << \")\";\n}\n\nstatic void writeDILexicalBlockFile(raw_ostream &Out,\n                                    const DILexicalBlockFile *N,\n                                    TypePrinting *TypePrinter,\n                                    SlotTracker *Machine,\n                                    const Module *Context) {\n  Out << \"!DILexicalBlockFile(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"discriminator\", N->getDiscriminator(),\n                   /* ShouldSkipZero */ false);\n  Out << \")\";\n}\n\nstatic void writeDINamespace(raw_ostream &Out, const DINamespace *N,\n                             TypePrinting *TypePrinter, SlotTracker *Machine,\n                             const Module *Context) {\n  Out << \"!DINamespace(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printBool(\"exportSymbols\", N->getExportSymbols(), false);\n  Out << \")\";\n}\n\nstatic void writeDICommonBlock(raw_ostream &Out, const DICommonBlock *N,\n                               TypePrinting *TypePrinter, SlotTracker *Machine,\n                               const Module *Context) {\n  Out << \"!DICommonBlock(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printMetadata(\"scope\", N->getRawScope(), false);\n  Printer.printMetadata(\"declaration\", N->getRawDecl(), false);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLineNo());\n  Out << \")\";\n}\n\nstatic void writeDIMacro(raw_ostream &Out, const DIMacro *N,\n                         TypePrinting *TypePrinter, SlotTracker *Machine,\n                         const Module *Context) {\n  Out << \"!DIMacro(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printMacinfoType(N);\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printString(\"name\", N->getName());\n  Printer.printString(\"value\", N->getValue());\n  Out << \")\";\n}\n\nstatic void writeDIMacroFile(raw_ostream &Out, const DIMacroFile *N,\n                             TypePrinting *TypePrinter, SlotTracker *Machine,\n                             const Module *Context) {\n  Out << \"!DIMacroFile(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printMetadata(\"file\", N->getRawFile(), /* ShouldSkipNull */ false);\n  Printer.printMetadata(\"nodes\", N->getRawElements());\n  Out << \")\";\n}\n\nstatic void writeDIModule(raw_ostream &Out, const DIModule *N,\n                          TypePrinting *TypePrinter, SlotTracker *Machine,\n                          const Module *Context) {\n  Out << \"!DIModule(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printString(\"name\", N->getName());\n  Printer.printString(\"configMacros\", N->getConfigurationMacros());\n  Printer.printString(\"includePath\", N->getIncludePath());\n  Printer.printString(\"apinotes\", N->getAPINotesFile());\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLineNo());\n  Printer.printBool(\"isDecl\", N->getIsDecl(), /* Default */ false);\n  Out << \")\";\n}\n\n\nstatic void writeDITemplateTypeParameter(raw_ostream &Out,\n                                         const DITemplateTypeParameter *N,\n                                         TypePrinting *TypePrinter,\n                                         SlotTracker *Machine,\n                                         const Module *Context) {\n  Out << \"!DITemplateTypeParameter(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"type\", N->getRawType(), /* ShouldSkipNull */ false);\n  Printer.printBool(\"defaulted\", N->isDefault(), /* Default= */ false);\n  Out << \")\";\n}\n\nstatic void writeDITemplateValueParameter(raw_ostream &Out,\n                                          const DITemplateValueParameter *N,\n                                          TypePrinting *TypePrinter,\n                                          SlotTracker *Machine,\n                                          const Module *Context) {\n  Out << \"!DITemplateValueParameter(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  if (N->getTag() != dwarf::DW_TAG_template_value_parameter)\n    Printer.printTag(N);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"type\", N->getRawType());\n  Printer.printBool(\"defaulted\", N->isDefault(), /* Default= */ false);\n  Printer.printMetadata(\"value\", N->getValue(), /* ShouldSkipNull */ false);\n  Out << \")\";\n}\n\nstatic void writeDIGlobalVariable(raw_ostream &Out, const DIGlobalVariable *N,\n                                  TypePrinting *TypePrinter,\n                                  SlotTracker *Machine, const Module *Context) {\n  Out << \"!DIGlobalVariable(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printString(\"name\", N->getName());\n  Printer.printString(\"linkageName\", N->getLinkageName());\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printMetadata(\"type\", N->getRawType());\n  Printer.printBool(\"isLocal\", N->isLocalToUnit());\n  Printer.printBool(\"isDefinition\", N->isDefinition());\n  Printer.printMetadata(\"declaration\", N->getRawStaticDataMemberDeclaration());\n  Printer.printMetadata(\"templateParams\", N->getRawTemplateParams());\n  Printer.printInt(\"align\", N->getAlignInBits());\n  Out << \")\";\n}\n\nstatic void writeDILocalVariable(raw_ostream &Out, const DILocalVariable *N,\n                                 TypePrinting *TypePrinter,\n                                 SlotTracker *Machine, const Module *Context) {\n  Out << \"!DILocalVariable(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printString(\"name\", N->getName());\n  Printer.printInt(\"arg\", N->getArg());\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printMetadata(\"type\", N->getRawType());\n  Printer.printDIFlags(\"flags\", N->getFlags());\n  Printer.printInt(\"align\", N->getAlignInBits());\n  Out << \")\";\n}\n\nstatic void writeDILabel(raw_ostream &Out, const DILabel *N,\n                         TypePrinting *TypePrinter,\n                         SlotTracker *Machine, const Module *Context) {\n  Out << \"!DILabel(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Out << \")\";\n}\n\nstatic void writeDIExpression(raw_ostream &Out, const DIExpression *N,\n                              TypePrinting *TypePrinter, SlotTracker *Machine,\n                              const Module *Context) {\n  Out << \"!DIExpression(\";\n  FieldSeparator FS;\n  if (N->isValid()) {\n    for (auto I = N->expr_op_begin(), E = N->expr_op_end(); I != E; ++I) {\n      auto OpStr = dwarf::OperationEncodingString(I->getOp());\n      assert(!OpStr.empty() && \"Expected valid opcode\");\n\n      Out << FS << OpStr;\n      if (I->getOp() == dwarf::DW_OP_LLVM_convert) {\n        Out << FS << I->getArg(0);\n        Out << FS << dwarf::AttributeEncodingString(I->getArg(1));\n      } else {\n        for (unsigned A = 0, AE = I->getNumArgs(); A != AE; ++A)\n          Out << FS << I->getArg(A);\n      }\n    }\n  } else {\n    for (const auto &I : N->getElements())\n      Out << FS << I;\n  }\n  Out << \")\";\n}\n\nstatic void writeDIGlobalVariableExpression(raw_ostream &Out,\n                                            const DIGlobalVariableExpression *N,\n                                            TypePrinting *TypePrinter,\n                                            SlotTracker *Machine,\n                                            const Module *Context) {\n  Out << \"!DIGlobalVariableExpression(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printMetadata(\"var\", N->getVariable());\n  Printer.printMetadata(\"expr\", N->getExpression());\n  Out << \")\";\n}\n\nstatic void writeDIObjCProperty(raw_ostream &Out, const DIObjCProperty *N,\n                                TypePrinting *TypePrinter, SlotTracker *Machine,\n                                const Module *Context) {\n  Out << \"!DIObjCProperty(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Printer.printString(\"setter\", N->getSetterName());\n  Printer.printString(\"getter\", N->getGetterName());\n  Printer.printInt(\"attributes\", N->getAttributes());\n  Printer.printMetadata(\"type\", N->getRawType());\n  Out << \")\";\n}\n\nstatic void writeDIImportedEntity(raw_ostream &Out, const DIImportedEntity *N,\n                                  TypePrinting *TypePrinter,\n                                  SlotTracker *Machine, const Module *Context) {\n  Out << \"!DIImportedEntity(\";\n  MDFieldPrinter Printer(Out, TypePrinter, Machine, Context);\n  Printer.printTag(N);\n  Printer.printString(\"name\", N->getName());\n  Printer.printMetadata(\"scope\", N->getRawScope(), /* ShouldSkipNull */ false);\n  Printer.printMetadata(\"entity\", N->getRawEntity());\n  Printer.printMetadata(\"file\", N->getRawFile());\n  Printer.printInt(\"line\", N->getLine());\n  Out << \")\";\n}\n\nstatic void WriteMDNodeBodyInternal(raw_ostream &Out, const MDNode *Node,\n                                    TypePrinting *TypePrinter,\n                                    SlotTracker *Machine,\n                                    const Module *Context) {\n  if (Node->isDistinct())\n    Out << \"distinct \";\n  else if (Node->isTemporary())\n    Out << \"<temporary!> \"; // Handle broken code.\n\n  switch (Node->getMetadataID()) {\n  default:\n    llvm_unreachable(\"Expected uniquable MDNode\");\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  case Metadata::CLASS##Kind:                                                  \\\n    write##CLASS(Out, cast<CLASS>(Node), TypePrinter, Machine, Context);       \\\n    break;\n#include \"llvm/IR/Metadata.def\"\n  }\n}\n\n// Full implementation of printing a Value as an operand with support for\n// TypePrinting, etc.\nstatic void WriteAsOperandInternal(raw_ostream &Out, const Value *V,\n                                   TypePrinting *TypePrinter,\n                                   SlotTracker *Machine,\n                                   const Module *Context) {\n  if (V->hasName()) {\n    PrintLLVMName(Out, V);\n    return;\n  }\n\n  const Constant *CV = dyn_cast<Constant>(V);\n  if (CV && !isa<GlobalValue>(CV)) {\n    assert(TypePrinter && \"Constants require TypePrinting!\");\n    WriteConstantInternal(Out, CV, *TypePrinter, Machine, Context);\n    return;\n  }\n\n  if (const InlineAsm *IA = dyn_cast<InlineAsm>(V)) {\n    Out << \"asm \";\n    if (IA->hasSideEffects())\n      Out << \"sideeffect \";\n    if (IA->isAlignStack())\n      Out << \"alignstack \";\n    // We don't emit the AD_ATT dialect as it's the assumed default.\n    if (IA->getDialect() == InlineAsm::AD_Intel)\n      Out << \"inteldialect \";\n    Out << '\"';\n    printEscapedString(IA->getAsmString(), Out);\n    Out << \"\\\", \\\"\";\n    printEscapedString(IA->getConstraintString(), Out);\n    Out << '\"';\n    return;\n  }\n\n  if (auto *MD = dyn_cast<MetadataAsValue>(V)) {\n    WriteAsOperandInternal(Out, MD->getMetadata(), TypePrinter, Machine,\n                           Context, /* FromValue */ true);\n    return;\n  }\n\n  char Prefix = '%';\n  int Slot;\n  // If we have a SlotTracker, use it.\n  if (Machine) {\n    if (const GlobalValue *GV = dyn_cast<GlobalValue>(V)) {\n      Slot = Machine->getGlobalSlot(GV);\n      Prefix = '@';\n    } else {\n      Slot = Machine->getLocalSlot(V);\n\n      // If the local value didn't succeed, then we may be referring to a value\n      // from a different function.  Translate it, as this can happen when using\n      // address of blocks.\n      if (Slot == -1)\n        if ((Machine = createSlotTracker(V))) {\n          Slot = Machine->getLocalSlot(V);\n          delete Machine;\n        }\n    }\n  } else if ((Machine = createSlotTracker(V))) {\n    // Otherwise, create one to get the # and then destroy it.\n    if (const GlobalValue *GV = dyn_cast<GlobalValue>(V)) {\n      Slot = Machine->getGlobalSlot(GV);\n      Prefix = '@';\n    } else {\n      Slot = Machine->getLocalSlot(V);\n    }\n    delete Machine;\n    Machine = nullptr;\n  } else {\n    Slot = -1;\n  }\n\n  if (Slot != -1)\n    Out << Prefix << Slot;\n  else\n    Out << \"<badref>\";\n}\n\nstatic void WriteAsOperandInternal(raw_ostream &Out, const Metadata *MD,\n                                   TypePrinting *TypePrinter,\n                                   SlotTracker *Machine, const Module *Context,\n                                   bool FromValue) {\n  // Write DIExpressions inline when used as a value. Improves readability of\n  // debug info intrinsics.\n  if (const DIExpression *Expr = dyn_cast<DIExpression>(MD)) {\n    writeDIExpression(Out, Expr, TypePrinter, Machine, Context);\n    return;\n  }\n\n  if (const MDNode *N = dyn_cast<MDNode>(MD)) {\n    std::unique_ptr<SlotTracker> MachineStorage;\n    if (!Machine) {\n      MachineStorage = std::make_unique<SlotTracker>(Context);\n      Machine = MachineStorage.get();\n    }\n    int Slot = Machine->getMetadataSlot(N);\n    if (Slot == -1) {\n      if (const DILocation *Loc = dyn_cast<DILocation>(N)) {\n        writeDILocation(Out, Loc, TypePrinter, Machine, Context);\n        return;\n      }\n      // Give the pointer value instead of \"badref\", since this comes up all\n      // the time when debugging.\n      Out << \"<\" << N << \">\";\n    } else\n      Out << '!' << Slot;\n    return;\n  }\n\n  if (const MDString *MDS = dyn_cast<MDString>(MD)) {\n    Out << \"!\\\"\";\n    printEscapedString(MDS->getString(), Out);\n    Out << '\"';\n    return;\n  }\n\n  auto *V = cast<ValueAsMetadata>(MD);\n  assert(TypePrinter && \"TypePrinter required for metadata values\");\n  assert((FromValue || !isa<LocalAsMetadata>(V)) &&\n         \"Unexpected function-local metadata outside of value argument\");\n\n  TypePrinter->print(V->getValue()->getType(), Out);\n  Out << ' ';\n  WriteAsOperandInternal(Out, V->getValue(), TypePrinter, Machine, Context);\n}\n\nnamespace {\n\nclass AssemblyWriter {\n  formatted_raw_ostream &Out;\n  const Module *TheModule = nullptr;\n  const ModuleSummaryIndex *TheIndex = nullptr;\n  std::unique_ptr<SlotTracker> SlotTrackerStorage;\n  SlotTracker &Machine;\n  TypePrinting TypePrinter;\n  AssemblyAnnotationWriter *AnnotationWriter = nullptr;\n  SetVector<const Comdat *> Comdats;\n  bool IsForDebug;\n  bool ShouldPreserveUseListOrder;\n  UseListOrderStack UseListOrders;\n  SmallVector<StringRef, 8> MDNames;\n  /// Synchronization scope names registered with LLVMContext.\n  SmallVector<StringRef, 8> SSNs;\n  DenseMap<const GlobalValueSummary *, GlobalValue::GUID> SummaryToGUIDMap;\n\npublic:\n  /// Construct an AssemblyWriter with an external SlotTracker\n  AssemblyWriter(formatted_raw_ostream &o, SlotTracker &Mac, const Module *M,\n                 AssemblyAnnotationWriter *AAW, bool IsForDebug,\n                 bool ShouldPreserveUseListOrder = false);\n\n  AssemblyWriter(formatted_raw_ostream &o, SlotTracker &Mac,\n                 const ModuleSummaryIndex *Index, bool IsForDebug);\n\n  void printMDNodeBody(const MDNode *MD);\n  void printNamedMDNode(const NamedMDNode *NMD);\n\n  void printModule(const Module *M);\n\n  void writeOperand(const Value *Op, bool PrintType);\n  void writeParamOperand(const Value *Operand, AttributeSet Attrs);\n  void writeOperandBundles(const CallBase *Call);\n  void writeSyncScope(const LLVMContext &Context,\n                      SyncScope::ID SSID);\n  void writeAtomic(const LLVMContext &Context,\n                   AtomicOrdering Ordering,\n                   SyncScope::ID SSID);\n  void writeAtomicCmpXchg(const LLVMContext &Context,\n                          AtomicOrdering SuccessOrdering,\n                          AtomicOrdering FailureOrdering,\n                          SyncScope::ID SSID);\n\n  void writeAllMDNodes();\n  void writeMDNode(unsigned Slot, const MDNode *Node);\n  void writeAttribute(const Attribute &Attr, bool InAttrGroup = false);\n  void writeAttributeSet(const AttributeSet &AttrSet, bool InAttrGroup = false);\n  void writeAllAttributeGroups();\n\n  void printTypeIdentities();\n  void printGlobal(const GlobalVariable *GV);\n  void printIndirectSymbol(const GlobalIndirectSymbol *GIS);\n  void printComdat(const Comdat *C);\n  void printFunction(const Function *F);\n  void printArgument(const Argument *FA, AttributeSet Attrs);\n  void printBasicBlock(const BasicBlock *BB);\n  void printInstructionLine(const Instruction &I);\n  void printInstruction(const Instruction &I);\n\n  void printUseListOrder(const UseListOrder &Order);\n  void printUseLists(const Function *F);\n\n  void printModuleSummaryIndex();\n  void printSummaryInfo(unsigned Slot, const ValueInfo &VI);\n  void printSummary(const GlobalValueSummary &Summary);\n  void printAliasSummary(const AliasSummary *AS);\n  void printGlobalVarSummary(const GlobalVarSummary *GS);\n  void printFunctionSummary(const FunctionSummary *FS);\n  void printTypeIdSummary(const TypeIdSummary &TIS);\n  void printTypeIdCompatibleVtableSummary(const TypeIdCompatibleVtableInfo &TI);\n  void printTypeTestResolution(const TypeTestResolution &TTRes);\n  void printArgs(const std::vector<uint64_t> &Args);\n  void printWPDRes(const WholeProgramDevirtResolution &WPDRes);\n  void printTypeIdInfo(const FunctionSummary::TypeIdInfo &TIDInfo);\n  void printVFuncId(const FunctionSummary::VFuncId VFId);\n  void\n  printNonConstVCalls(const std::vector<FunctionSummary::VFuncId> &VCallList,\n                      const char *Tag);\n  void\n  printConstVCalls(const std::vector<FunctionSummary::ConstVCall> &VCallList,\n                   const char *Tag);\n\nprivate:\n  /// Print out metadata attachments.\n  void printMetadataAttachments(\n      const SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs,\n      StringRef Separator);\n\n  // printInfoComment - Print a little comment after the instruction indicating\n  // which slot it occupies.\n  void printInfoComment(const Value &V);\n\n  // printGCRelocateComment - print comment after call to the gc.relocate\n  // intrinsic indicating base and derived pointer names.\n  void printGCRelocateComment(const GCRelocateInst &Relocate);\n};\n\n} // end anonymous namespace\n\nAssemblyWriter::AssemblyWriter(formatted_raw_ostream &o, SlotTracker &Mac,\n                               const Module *M, AssemblyAnnotationWriter *AAW,\n                               bool IsForDebug, bool ShouldPreserveUseListOrder)\n    : Out(o), TheModule(M), Machine(Mac), TypePrinter(M), AnnotationWriter(AAW),\n      IsForDebug(IsForDebug),\n      ShouldPreserveUseListOrder(ShouldPreserveUseListOrder) {\n  if (!TheModule)\n    return;\n  for (const GlobalObject &GO : TheModule->global_objects())\n    if (const Comdat *C = GO.getComdat())\n      Comdats.insert(C);\n}\n\nAssemblyWriter::AssemblyWriter(formatted_raw_ostream &o, SlotTracker &Mac,\n                               const ModuleSummaryIndex *Index, bool IsForDebug)\n    : Out(o), TheIndex(Index), Machine(Mac), TypePrinter(/*Module=*/nullptr),\n      IsForDebug(IsForDebug), ShouldPreserveUseListOrder(false) {}\n\nvoid AssemblyWriter::writeOperand(const Value *Operand, bool PrintType) {\n  if (!Operand) {\n    Out << \"<null operand!>\";\n    return;\n  }\n  if (PrintType) {\n    TypePrinter.print(Operand->getType(), Out);\n    Out << ' ';\n  }\n  WriteAsOperandInternal(Out, Operand, &TypePrinter, &Machine, TheModule);\n}\n\nvoid AssemblyWriter::writeSyncScope(const LLVMContext &Context,\n                                    SyncScope::ID SSID) {\n  switch (SSID) {\n  case SyncScope::System: {\n    break;\n  }\n  default: {\n    if (SSNs.empty())\n      Context.getSyncScopeNames(SSNs);\n\n    Out << \" syncscope(\\\"\";\n    printEscapedString(SSNs[SSID], Out);\n    Out << \"\\\")\";\n    break;\n  }\n  }\n}\n\nvoid AssemblyWriter::writeAtomic(const LLVMContext &Context,\n                                 AtomicOrdering Ordering,\n                                 SyncScope::ID SSID) {\n  if (Ordering == AtomicOrdering::NotAtomic)\n    return;\n\n  writeSyncScope(Context, SSID);\n  Out << \" \" << toIRString(Ordering);\n}\n\nvoid AssemblyWriter::writeAtomicCmpXchg(const LLVMContext &Context,\n                                        AtomicOrdering SuccessOrdering,\n                                        AtomicOrdering FailureOrdering,\n                                        SyncScope::ID SSID) {\n  assert(SuccessOrdering != AtomicOrdering::NotAtomic &&\n         FailureOrdering != AtomicOrdering::NotAtomic);\n\n  writeSyncScope(Context, SSID);\n  Out << \" \" << toIRString(SuccessOrdering);\n  Out << \" \" << toIRString(FailureOrdering);\n}\n\nvoid AssemblyWriter::writeParamOperand(const Value *Operand,\n                                       AttributeSet Attrs) {\n  if (!Operand) {\n    Out << \"<null operand!>\";\n    return;\n  }\n\n  // Print the type\n  TypePrinter.print(Operand->getType(), Out);\n  // Print parameter attributes list\n  if (Attrs.hasAttributes()) {\n    Out << ' ';\n    writeAttributeSet(Attrs);\n  }\n  Out << ' ';\n  // Print the operand\n  WriteAsOperandInternal(Out, Operand, &TypePrinter, &Machine, TheModule);\n}\n\nvoid AssemblyWriter::writeOperandBundles(const CallBase *Call) {\n  if (!Call->hasOperandBundles())\n    return;\n\n  Out << \" [ \";\n\n  bool FirstBundle = true;\n  for (unsigned i = 0, e = Call->getNumOperandBundles(); i != e; ++i) {\n    OperandBundleUse BU = Call->getOperandBundleAt(i);\n\n    if (!FirstBundle)\n      Out << \", \";\n    FirstBundle = false;\n\n    Out << '\"';\n    printEscapedString(BU.getTagName(), Out);\n    Out << '\"';\n\n    Out << '(';\n\n    bool FirstInput = true;\n    for (const auto &Input : BU.Inputs) {\n      if (!FirstInput)\n        Out << \", \";\n      FirstInput = false;\n\n      TypePrinter.print(Input->getType(), Out);\n      Out << \" \";\n      WriteAsOperandInternal(Out, Input, &TypePrinter, &Machine, TheModule);\n    }\n\n    Out << ')';\n  }\n\n  Out << \" ]\";\n}\n\nvoid AssemblyWriter::printModule(const Module *M) {\n  Machine.initializeIfNeeded();\n\n  if (ShouldPreserveUseListOrder)\n    UseListOrders = predictUseListOrder(M);\n\n  if (!M->getModuleIdentifier().empty() &&\n      // Don't print the ID if it will start a new line (which would\n      // require a comment char before it).\n      M->getModuleIdentifier().find('\\n') == std::string::npos)\n    Out << \"; ModuleID = '\" << M->getModuleIdentifier() << \"'\\n\";\n\n  if (!M->getSourceFileName().empty()) {\n    Out << \"source_filename = \\\"\";\n    printEscapedString(M->getSourceFileName(), Out);\n    Out << \"\\\"\\n\";\n  }\n\n  const std::string &DL = M->getDataLayoutStr();\n  if (!DL.empty())\n    Out << \"target datalayout = \\\"\" << DL << \"\\\"\\n\";\n  if (!M->getTargetTriple().empty())\n    Out << \"target triple = \\\"\" << M->getTargetTriple() << \"\\\"\\n\";\n\n  if (!M->getModuleInlineAsm().empty()) {\n    Out << '\\n';\n\n    // Split the string into lines, to make it easier to read the .ll file.\n    StringRef Asm = M->getModuleInlineAsm();\n    do {\n      StringRef Front;\n      std::tie(Front, Asm) = Asm.split('\\n');\n\n      // We found a newline, print the portion of the asm string from the\n      // last newline up to this newline.\n      Out << \"module asm \\\"\";\n      printEscapedString(Front, Out);\n      Out << \"\\\"\\n\";\n    } while (!Asm.empty());\n  }\n\n  printTypeIdentities();\n\n  // Output all comdats.\n  if (!Comdats.empty())\n    Out << '\\n';\n  for (const Comdat *C : Comdats) {\n    printComdat(C);\n    if (C != Comdats.back())\n      Out << '\\n';\n  }\n\n  // Output all globals.\n  if (!M->global_empty()) Out << '\\n';\n  for (const GlobalVariable &GV : M->globals()) {\n    printGlobal(&GV); Out << '\\n';\n  }\n\n  // Output all aliases.\n  if (!M->alias_empty()) Out << \"\\n\";\n  for (const GlobalAlias &GA : M->aliases())\n    printIndirectSymbol(&GA);\n\n  // Output all ifuncs.\n  if (!M->ifunc_empty()) Out << \"\\n\";\n  for (const GlobalIFunc &GI : M->ifuncs())\n    printIndirectSymbol(&GI);\n\n  // Output global use-lists.\n  printUseLists(nullptr);\n\n  // Output all of the functions.\n  for (const Function &F : *M) {\n    Out << '\\n';\n    printFunction(&F);\n  }\n  assert(UseListOrders.empty() && \"All use-lists should have been consumed\");\n\n  // Output all attribute groups.\n  if (!Machine.as_empty()) {\n    Out << '\\n';\n    writeAllAttributeGroups();\n  }\n\n  // Output named metadata.\n  if (!M->named_metadata_empty()) Out << '\\n';\n\n  for (const NamedMDNode &Node : M->named_metadata())\n    printNamedMDNode(&Node);\n\n  // Output metadata.\n  if (!Machine.mdn_empty()) {\n    Out << '\\n';\n    writeAllMDNodes();\n  }\n}\n\nvoid AssemblyWriter::printModuleSummaryIndex() {\n  assert(TheIndex);\n  int NumSlots = Machine.initializeIndexIfNeeded();\n\n  Out << \"\\n\";\n\n  // Print module path entries. To print in order, add paths to a vector\n  // indexed by module slot.\n  std::vector<std::pair<std::string, ModuleHash>> moduleVec;\n  std::string RegularLTOModuleName =\n      ModuleSummaryIndex::getRegularLTOModuleName();\n  moduleVec.resize(TheIndex->modulePaths().size());\n  for (auto &ModPath : TheIndex->modulePaths())\n    moduleVec[Machine.getModulePathSlot(ModPath.first())] = std::make_pair(\n        // A module id of -1 is a special entry for a regular LTO module created\n        // during the thin link.\n        ModPath.second.first == -1u ? RegularLTOModuleName\n                                    : (std::string)std::string(ModPath.first()),\n        ModPath.second.second);\n\n  unsigned i = 0;\n  for (auto &ModPair : moduleVec) {\n    Out << \"^\" << i++ << \" = module: (\";\n    Out << \"path: \\\"\";\n    printEscapedString(ModPair.first, Out);\n    Out << \"\\\", hash: (\";\n    FieldSeparator FS;\n    for (auto Hash : ModPair.second)\n      Out << FS << Hash;\n    Out << \"))\\n\";\n  }\n\n  // FIXME: Change AliasSummary to hold a ValueInfo instead of summary pointer\n  // for aliasee (then update BitcodeWriter.cpp and remove get/setAliaseeGUID).\n  for (auto &GlobalList : *TheIndex) {\n    auto GUID = GlobalList.first;\n    for (auto &Summary : GlobalList.second.SummaryList)\n      SummaryToGUIDMap[Summary.get()] = GUID;\n  }\n\n  // Print the global value summary entries.\n  for (auto &GlobalList : *TheIndex) {\n    auto GUID = GlobalList.first;\n    auto VI = TheIndex->getValueInfo(GlobalList);\n    printSummaryInfo(Machine.getGUIDSlot(GUID), VI);\n  }\n\n  // Print the TypeIdMap entries.\n  for (auto TidIter = TheIndex->typeIds().begin();\n       TidIter != TheIndex->typeIds().end(); TidIter++) {\n    Out << \"^\" << Machine.getTypeIdSlot(TidIter->second.first)\n        << \" = typeid: (name: \\\"\" << TidIter->second.first << \"\\\"\";\n    printTypeIdSummary(TidIter->second.second);\n    Out << \") ; guid = \" << TidIter->first << \"\\n\";\n  }\n\n  // Print the TypeIdCompatibleVtableMap entries.\n  for (auto &TId : TheIndex->typeIdCompatibleVtableMap()) {\n    auto GUID = GlobalValue::getGUID(TId.first);\n    Out << \"^\" << Machine.getGUIDSlot(GUID)\n        << \" = typeidCompatibleVTable: (name: \\\"\" << TId.first << \"\\\"\";\n    printTypeIdCompatibleVtableSummary(TId.second);\n    Out << \") ; guid = \" << GUID << \"\\n\";\n  }\n\n  // Don't emit flags when it's not really needed (value is zero by default).\n  if (TheIndex->getFlags()) {\n    Out << \"^\" << NumSlots << \" = flags: \" << TheIndex->getFlags() << \"\\n\";\n    ++NumSlots;\n  }\n\n  Out << \"^\" << NumSlots << \" = blockcount: \" << TheIndex->getBlockCount()\n      << \"\\n\";\n}\n\nstatic const char *\ngetWholeProgDevirtResKindName(WholeProgramDevirtResolution::Kind K) {\n  switch (K) {\n  case WholeProgramDevirtResolution::Indir:\n    return \"indir\";\n  case WholeProgramDevirtResolution::SingleImpl:\n    return \"singleImpl\";\n  case WholeProgramDevirtResolution::BranchFunnel:\n    return \"branchFunnel\";\n  }\n  llvm_unreachable(\"invalid WholeProgramDevirtResolution kind\");\n}\n\nstatic const char *getWholeProgDevirtResByArgKindName(\n    WholeProgramDevirtResolution::ByArg::Kind K) {\n  switch (K) {\n  case WholeProgramDevirtResolution::ByArg::Indir:\n    return \"indir\";\n  case WholeProgramDevirtResolution::ByArg::UniformRetVal:\n    return \"uniformRetVal\";\n  case WholeProgramDevirtResolution::ByArg::UniqueRetVal:\n    return \"uniqueRetVal\";\n  case WholeProgramDevirtResolution::ByArg::VirtualConstProp:\n    return \"virtualConstProp\";\n  }\n  llvm_unreachable(\"invalid WholeProgramDevirtResolution::ByArg kind\");\n}\n\nstatic const char *getTTResKindName(TypeTestResolution::Kind K) {\n  switch (K) {\n  case TypeTestResolution::Unknown:\n    return \"unknown\";\n  case TypeTestResolution::Unsat:\n    return \"unsat\";\n  case TypeTestResolution::ByteArray:\n    return \"byteArray\";\n  case TypeTestResolution::Inline:\n    return \"inline\";\n  case TypeTestResolution::Single:\n    return \"single\";\n  case TypeTestResolution::AllOnes:\n    return \"allOnes\";\n  }\n  llvm_unreachable(\"invalid TypeTestResolution kind\");\n}\n\nvoid AssemblyWriter::printTypeTestResolution(const TypeTestResolution &TTRes) {\n  Out << \"typeTestRes: (kind: \" << getTTResKindName(TTRes.TheKind)\n      << \", sizeM1BitWidth: \" << TTRes.SizeM1BitWidth;\n\n  // The following fields are only used if the target does not support the use\n  // of absolute symbols to store constants. Print only if non-zero.\n  if (TTRes.AlignLog2)\n    Out << \", alignLog2: \" << TTRes.AlignLog2;\n  if (TTRes.SizeM1)\n    Out << \", sizeM1: \" << TTRes.SizeM1;\n  if (TTRes.BitMask)\n    // BitMask is uint8_t which causes it to print the corresponding char.\n    Out << \", bitMask: \" << (unsigned)TTRes.BitMask;\n  if (TTRes.InlineBits)\n    Out << \", inlineBits: \" << TTRes.InlineBits;\n\n  Out << \")\";\n}\n\nvoid AssemblyWriter::printTypeIdSummary(const TypeIdSummary &TIS) {\n  Out << \", summary: (\";\n  printTypeTestResolution(TIS.TTRes);\n  if (!TIS.WPDRes.empty()) {\n    Out << \", wpdResolutions: (\";\n    FieldSeparator FS;\n    for (auto &WPDRes : TIS.WPDRes) {\n      Out << FS;\n      Out << \"(offset: \" << WPDRes.first << \", \";\n      printWPDRes(WPDRes.second);\n      Out << \")\";\n    }\n    Out << \")\";\n  }\n  Out << \")\";\n}\n\nvoid AssemblyWriter::printTypeIdCompatibleVtableSummary(\n    const TypeIdCompatibleVtableInfo &TI) {\n  Out << \", summary: (\";\n  FieldSeparator FS;\n  for (auto &P : TI) {\n    Out << FS;\n    Out << \"(offset: \" << P.AddressPointOffset << \", \";\n    Out << \"^\" << Machine.getGUIDSlot(P.VTableVI.getGUID());\n    Out << \")\";\n  }\n  Out << \")\";\n}\n\nvoid AssemblyWriter::printArgs(const std::vector<uint64_t> &Args) {\n  Out << \"args: (\";\n  FieldSeparator FS;\n  for (auto arg : Args) {\n    Out << FS;\n    Out << arg;\n  }\n  Out << \")\";\n}\n\nvoid AssemblyWriter::printWPDRes(const WholeProgramDevirtResolution &WPDRes) {\n  Out << \"wpdRes: (kind: \";\n  Out << getWholeProgDevirtResKindName(WPDRes.TheKind);\n\n  if (WPDRes.TheKind == WholeProgramDevirtResolution::SingleImpl)\n    Out << \", singleImplName: \\\"\" << WPDRes.SingleImplName << \"\\\"\";\n\n  if (!WPDRes.ResByArg.empty()) {\n    Out << \", resByArg: (\";\n    FieldSeparator FS;\n    for (auto &ResByArg : WPDRes.ResByArg) {\n      Out << FS;\n      printArgs(ResByArg.first);\n      Out << \", byArg: (kind: \";\n      Out << getWholeProgDevirtResByArgKindName(ResByArg.second.TheKind);\n      if (ResByArg.second.TheKind ==\n              WholeProgramDevirtResolution::ByArg::UniformRetVal ||\n          ResByArg.second.TheKind ==\n              WholeProgramDevirtResolution::ByArg::UniqueRetVal)\n        Out << \", info: \" << ResByArg.second.Info;\n\n      // The following fields are only used if the target does not support the\n      // use of absolute symbols to store constants. Print only if non-zero.\n      if (ResByArg.second.Byte || ResByArg.second.Bit)\n        Out << \", byte: \" << ResByArg.second.Byte\n            << \", bit: \" << ResByArg.second.Bit;\n\n      Out << \")\";\n    }\n    Out << \")\";\n  }\n  Out << \")\";\n}\n\nstatic const char *getSummaryKindName(GlobalValueSummary::SummaryKind SK) {\n  switch (SK) {\n  case GlobalValueSummary::AliasKind:\n    return \"alias\";\n  case GlobalValueSummary::FunctionKind:\n    return \"function\";\n  case GlobalValueSummary::GlobalVarKind:\n    return \"variable\";\n  }\n  llvm_unreachable(\"invalid summary kind\");\n}\n\nvoid AssemblyWriter::printAliasSummary(const AliasSummary *AS) {\n  Out << \", aliasee: \";\n  // The indexes emitted for distributed backends may not include the\n  // aliasee summary (only if it is being imported directly). Handle\n  // that case by just emitting \"null\" as the aliasee.\n  if (AS->hasAliasee())\n    Out << \"^\" << Machine.getGUIDSlot(SummaryToGUIDMap[&AS->getAliasee()]);\n  else\n    Out << \"null\";\n}\n\nvoid AssemblyWriter::printGlobalVarSummary(const GlobalVarSummary *GS) {\n  auto VTableFuncs = GS->vTableFuncs();\n  Out << \", varFlags: (readonly: \" << GS->VarFlags.MaybeReadOnly << \", \"\n      << \"writeonly: \" << GS->VarFlags.MaybeWriteOnly << \", \"\n      << \"constant: \" << GS->VarFlags.Constant;\n  if (!VTableFuncs.empty())\n    Out << \", \"\n        << \"vcall_visibility: \" << GS->VarFlags.VCallVisibility;\n  Out << \")\";\n\n  if (!VTableFuncs.empty()) {\n    Out << \", vTableFuncs: (\";\n    FieldSeparator FS;\n    for (auto &P : VTableFuncs) {\n      Out << FS;\n      Out << \"(virtFunc: ^\" << Machine.getGUIDSlot(P.FuncVI.getGUID())\n          << \", offset: \" << P.VTableOffset;\n      Out << \")\";\n    }\n    Out << \")\";\n  }\n}\n\nstatic std::string getLinkageName(GlobalValue::LinkageTypes LT) {\n  switch (LT) {\n  case GlobalValue::ExternalLinkage:\n    return \"external\";\n  case GlobalValue::PrivateLinkage:\n    return \"private\";\n  case GlobalValue::InternalLinkage:\n    return \"internal\";\n  case GlobalValue::LinkOnceAnyLinkage:\n    return \"linkonce\";\n  case GlobalValue::LinkOnceODRLinkage:\n    return \"linkonce_odr\";\n  case GlobalValue::WeakAnyLinkage:\n    return \"weak\";\n  case GlobalValue::WeakODRLinkage:\n    return \"weak_odr\";\n  case GlobalValue::CommonLinkage:\n    return \"common\";\n  case GlobalValue::AppendingLinkage:\n    return \"appending\";\n  case GlobalValue::ExternalWeakLinkage:\n    return \"extern_weak\";\n  case GlobalValue::AvailableExternallyLinkage:\n    return \"available_externally\";\n  }\n  llvm_unreachable(\"invalid linkage\");\n}\n\n// When printing the linkage types in IR where the ExternalLinkage is\n// not printed, and other linkage types are expected to be printed with\n// a space after the name.\nstatic std::string getLinkageNameWithSpace(GlobalValue::LinkageTypes LT) {\n  if (LT == GlobalValue::ExternalLinkage)\n    return \"\";\n  return getLinkageName(LT) + \" \";\n}\n\nstatic const char *getVisibilityName(GlobalValue::VisibilityTypes Vis) {\n  switch (Vis) {\n  case GlobalValue::DefaultVisibility:\n    return \"default\";\n  case GlobalValue::HiddenVisibility:\n    return \"hidden\";\n  case GlobalValue::ProtectedVisibility:\n    return \"protected\";\n  }\n  llvm_unreachable(\"invalid visibility\");\n}\n\nvoid AssemblyWriter::printFunctionSummary(const FunctionSummary *FS) {\n  Out << \", insts: \" << FS->instCount();\n\n  FunctionSummary::FFlags FFlags = FS->fflags();\n  if (FFlags.ReadNone | FFlags.ReadOnly | FFlags.NoRecurse |\n      FFlags.ReturnDoesNotAlias | FFlags.NoInline | FFlags.AlwaysInline) {\n    Out << \", funcFlags: (\";\n    Out << \"readNone: \" << FFlags.ReadNone;\n    Out << \", readOnly: \" << FFlags.ReadOnly;\n    Out << \", noRecurse: \" << FFlags.NoRecurse;\n    Out << \", returnDoesNotAlias: \" << FFlags.ReturnDoesNotAlias;\n    Out << \", noInline: \" << FFlags.NoInline;\n    Out << \", alwaysInline: \" << FFlags.AlwaysInline;\n    Out << \")\";\n  }\n  if (!FS->calls().empty()) {\n    Out << \", calls: (\";\n    FieldSeparator IFS;\n    for (auto &Call : FS->calls()) {\n      Out << IFS;\n      Out << \"(callee: ^\" << Machine.getGUIDSlot(Call.first.getGUID());\n      if (Call.second.getHotness() != CalleeInfo::HotnessType::Unknown)\n        Out << \", hotness: \" << getHotnessName(Call.second.getHotness());\n      else if (Call.second.RelBlockFreq)\n        Out << \", relbf: \" << Call.second.RelBlockFreq;\n      Out << \")\";\n    }\n    Out << \")\";\n  }\n\n  if (const auto *TIdInfo = FS->getTypeIdInfo())\n    printTypeIdInfo(*TIdInfo);\n\n  auto PrintRange = [&](const ConstantRange &Range) {\n    Out << \"[\" << Range.getSignedMin() << \", \" << Range.getSignedMax() << \"]\";\n  };\n\n  if (!FS->paramAccesses().empty()) {\n    Out << \", params: (\";\n    FieldSeparator IFS;\n    for (auto &PS : FS->paramAccesses()) {\n      Out << IFS;\n      Out << \"(param: \" << PS.ParamNo;\n      Out << \", offset: \";\n      PrintRange(PS.Use);\n      if (!PS.Calls.empty()) {\n        Out << \", calls: (\";\n        FieldSeparator IFS;\n        for (auto &Call : PS.Calls) {\n          Out << IFS;\n          Out << \"(callee: ^\" << Machine.getGUIDSlot(Call.Callee.getGUID());\n          Out << \", param: \" << Call.ParamNo;\n          Out << \", offset: \";\n          PrintRange(Call.Offsets);\n          Out << \")\";\n        }\n        Out << \")\";\n      }\n      Out << \")\";\n    }\n    Out << \")\";\n  }\n}\n\nvoid AssemblyWriter::printTypeIdInfo(\n    const FunctionSummary::TypeIdInfo &TIDInfo) {\n  Out << \", typeIdInfo: (\";\n  FieldSeparator TIDFS;\n  if (!TIDInfo.TypeTests.empty()) {\n    Out << TIDFS;\n    Out << \"typeTests: (\";\n    FieldSeparator FS;\n    for (auto &GUID : TIDInfo.TypeTests) {\n      auto TidIter = TheIndex->typeIds().equal_range(GUID);\n      if (TidIter.first == TidIter.second) {\n        Out << FS;\n        Out << GUID;\n        continue;\n      }\n      // Print all type id that correspond to this GUID.\n      for (auto It = TidIter.first; It != TidIter.second; ++It) {\n        Out << FS;\n        auto Slot = Machine.getTypeIdSlot(It->second.first);\n        assert(Slot != -1);\n        Out << \"^\" << Slot;\n      }\n    }\n    Out << \")\";\n  }\n  if (!TIDInfo.TypeTestAssumeVCalls.empty()) {\n    Out << TIDFS;\n    printNonConstVCalls(TIDInfo.TypeTestAssumeVCalls, \"typeTestAssumeVCalls\");\n  }\n  if (!TIDInfo.TypeCheckedLoadVCalls.empty()) {\n    Out << TIDFS;\n    printNonConstVCalls(TIDInfo.TypeCheckedLoadVCalls, \"typeCheckedLoadVCalls\");\n  }\n  if (!TIDInfo.TypeTestAssumeConstVCalls.empty()) {\n    Out << TIDFS;\n    printConstVCalls(TIDInfo.TypeTestAssumeConstVCalls,\n                     \"typeTestAssumeConstVCalls\");\n  }\n  if (!TIDInfo.TypeCheckedLoadConstVCalls.empty()) {\n    Out << TIDFS;\n    printConstVCalls(TIDInfo.TypeCheckedLoadConstVCalls,\n                     \"typeCheckedLoadConstVCalls\");\n  }\n  Out << \")\";\n}\n\nvoid AssemblyWriter::printVFuncId(const FunctionSummary::VFuncId VFId) {\n  auto TidIter = TheIndex->typeIds().equal_range(VFId.GUID);\n  if (TidIter.first == TidIter.second) {\n    Out << \"vFuncId: (\";\n    Out << \"guid: \" << VFId.GUID;\n    Out << \", offset: \" << VFId.Offset;\n    Out << \")\";\n    return;\n  }\n  // Print all type id that correspond to this GUID.\n  FieldSeparator FS;\n  for (auto It = TidIter.first; It != TidIter.second; ++It) {\n    Out << FS;\n    Out << \"vFuncId: (\";\n    auto Slot = Machine.getTypeIdSlot(It->second.first);\n    assert(Slot != -1);\n    Out << \"^\" << Slot;\n    Out << \", offset: \" << VFId.Offset;\n    Out << \")\";\n  }\n}\n\nvoid AssemblyWriter::printNonConstVCalls(\n    const std::vector<FunctionSummary::VFuncId> &VCallList, const char *Tag) {\n  Out << Tag << \": (\";\n  FieldSeparator FS;\n  for (auto &VFuncId : VCallList) {\n    Out << FS;\n    printVFuncId(VFuncId);\n  }\n  Out << \")\";\n}\n\nvoid AssemblyWriter::printConstVCalls(\n    const std::vector<FunctionSummary::ConstVCall> &VCallList,\n    const char *Tag) {\n  Out << Tag << \": (\";\n  FieldSeparator FS;\n  for (auto &ConstVCall : VCallList) {\n    Out << FS;\n    Out << \"(\";\n    printVFuncId(ConstVCall.VFunc);\n    if (!ConstVCall.Args.empty()) {\n      Out << \", \";\n      printArgs(ConstVCall.Args);\n    }\n    Out << \")\";\n  }\n  Out << \")\";\n}\n\nvoid AssemblyWriter::printSummary(const GlobalValueSummary &Summary) {\n  GlobalValueSummary::GVFlags GVFlags = Summary.flags();\n  GlobalValue::LinkageTypes LT = (GlobalValue::LinkageTypes)GVFlags.Linkage;\n  Out << getSummaryKindName(Summary.getSummaryKind()) << \": \";\n  Out << \"(module: ^\" << Machine.getModulePathSlot(Summary.modulePath())\n      << \", flags: (\";\n  Out << \"linkage: \" << getLinkageName(LT);\n  Out << \", visibility: \"\n      << getVisibilityName((GlobalValue::VisibilityTypes)GVFlags.Visibility);\n  Out << \", notEligibleToImport: \" << GVFlags.NotEligibleToImport;\n  Out << \", live: \" << GVFlags.Live;\n  Out << \", dsoLocal: \" << GVFlags.DSOLocal;\n  Out << \", canAutoHide: \" << GVFlags.CanAutoHide;\n  Out << \")\";\n\n  if (Summary.getSummaryKind() == GlobalValueSummary::AliasKind)\n    printAliasSummary(cast<AliasSummary>(&Summary));\n  else if (Summary.getSummaryKind() == GlobalValueSummary::FunctionKind)\n    printFunctionSummary(cast<FunctionSummary>(&Summary));\n  else\n    printGlobalVarSummary(cast<GlobalVarSummary>(&Summary));\n\n  auto RefList = Summary.refs();\n  if (!RefList.empty()) {\n    Out << \", refs: (\";\n    FieldSeparator FS;\n    for (auto &Ref : RefList) {\n      Out << FS;\n      if (Ref.isReadOnly())\n        Out << \"readonly \";\n      else if (Ref.isWriteOnly())\n        Out << \"writeonly \";\n      Out << \"^\" << Machine.getGUIDSlot(Ref.getGUID());\n    }\n    Out << \")\";\n  }\n\n  Out << \")\";\n}\n\nvoid AssemblyWriter::printSummaryInfo(unsigned Slot, const ValueInfo &VI) {\n  Out << \"^\" << Slot << \" = gv: (\";\n  if (!VI.name().empty())\n    Out << \"name: \\\"\" << VI.name() << \"\\\"\";\n  else\n    Out << \"guid: \" << VI.getGUID();\n  if (!VI.getSummaryList().empty()) {\n    Out << \", summaries: (\";\n    FieldSeparator FS;\n    for (auto &Summary : VI.getSummaryList()) {\n      Out << FS;\n      printSummary(*Summary);\n    }\n    Out << \")\";\n  }\n  Out << \")\";\n  if (!VI.name().empty())\n    Out << \" ; guid = \" << VI.getGUID();\n  Out << \"\\n\";\n}\n\nstatic void printMetadataIdentifier(StringRef Name,\n                                    formatted_raw_ostream &Out) {\n  if (Name.empty()) {\n    Out << \"<empty name> \";\n  } else {\n    if (isalpha(static_cast<unsigned char>(Name[0])) || Name[0] == '-' ||\n        Name[0] == '$' || Name[0] == '.' || Name[0] == '_')\n      Out << Name[0];\n    else\n      Out << '\\\\' << hexdigit(Name[0] >> 4) << hexdigit(Name[0] & 0x0F);\n    for (unsigned i = 1, e = Name.size(); i != e; ++i) {\n      unsigned char C = Name[i];\n      if (isalnum(static_cast<unsigned char>(C)) || C == '-' || C == '$' ||\n          C == '.' || C == '_')\n        Out << C;\n      else\n        Out << '\\\\' << hexdigit(C >> 4) << hexdigit(C & 0x0F);\n    }\n  }\n}\n\nvoid AssemblyWriter::printNamedMDNode(const NamedMDNode *NMD) {\n  Out << '!';\n  printMetadataIdentifier(NMD->getName(), Out);\n  Out << \" = !{\";\n  for (unsigned i = 0, e = NMD->getNumOperands(); i != e; ++i) {\n    if (i)\n      Out << \", \";\n\n    // Write DIExpressions inline.\n    // FIXME: Ban DIExpressions in NamedMDNodes, they will serve no purpose.\n    MDNode *Op = NMD->getOperand(i);\n    if (auto *Expr = dyn_cast<DIExpression>(Op)) {\n      writeDIExpression(Out, Expr, nullptr, nullptr, nullptr);\n      continue;\n    }\n\n    int Slot = Machine.getMetadataSlot(Op);\n    if (Slot == -1)\n      Out << \"<badref>\";\n    else\n      Out << '!' << Slot;\n  }\n  Out << \"}\\n\";\n}\n\nstatic void PrintVisibility(GlobalValue::VisibilityTypes Vis,\n                            formatted_raw_ostream &Out) {\n  switch (Vis) {\n  case GlobalValue::DefaultVisibility: break;\n  case GlobalValue::HiddenVisibility:    Out << \"hidden \"; break;\n  case GlobalValue::ProtectedVisibility: Out << \"protected \"; break;\n  }\n}\n\nstatic void PrintDSOLocation(const GlobalValue &GV,\n                             formatted_raw_ostream &Out) {\n  if (GV.isDSOLocal() && !GV.isImplicitDSOLocal())\n    Out << \"dso_local \";\n}\n\nstatic void PrintDLLStorageClass(GlobalValue::DLLStorageClassTypes SCT,\n                                 formatted_raw_ostream &Out) {\n  switch (SCT) {\n  case GlobalValue::DefaultStorageClass: break;\n  case GlobalValue::DLLImportStorageClass: Out << \"dllimport \"; break;\n  case GlobalValue::DLLExportStorageClass: Out << \"dllexport \"; break;\n  }\n}\n\nstatic void PrintThreadLocalModel(GlobalVariable::ThreadLocalMode TLM,\n                                  formatted_raw_ostream &Out) {\n  switch (TLM) {\n    case GlobalVariable::NotThreadLocal:\n      break;\n    case GlobalVariable::GeneralDynamicTLSModel:\n      Out << \"thread_local \";\n      break;\n    case GlobalVariable::LocalDynamicTLSModel:\n      Out << \"thread_local(localdynamic) \";\n      break;\n    case GlobalVariable::InitialExecTLSModel:\n      Out << \"thread_local(initialexec) \";\n      break;\n    case GlobalVariable::LocalExecTLSModel:\n      Out << \"thread_local(localexec) \";\n      break;\n  }\n}\n\nstatic StringRef getUnnamedAddrEncoding(GlobalVariable::UnnamedAddr UA) {\n  switch (UA) {\n  case GlobalVariable::UnnamedAddr::None:\n    return \"\";\n  case GlobalVariable::UnnamedAddr::Local:\n    return \"local_unnamed_addr\";\n  case GlobalVariable::UnnamedAddr::Global:\n    return \"unnamed_addr\";\n  }\n  llvm_unreachable(\"Unknown UnnamedAddr\");\n}\n\nstatic void maybePrintComdat(formatted_raw_ostream &Out,\n                             const GlobalObject &GO) {\n  const Comdat *C = GO.getComdat();\n  if (!C)\n    return;\n\n  if (isa<GlobalVariable>(GO))\n    Out << ',';\n  Out << \" comdat\";\n\n  if (GO.getName() == C->getName())\n    return;\n\n  Out << '(';\n  PrintLLVMName(Out, C->getName(), ComdatPrefix);\n  Out << ')';\n}\n\nvoid AssemblyWriter::printGlobal(const GlobalVariable *GV) {\n  if (GV->isMaterializable())\n    Out << \"; Materializable\\n\";\n\n  WriteAsOperandInternal(Out, GV, &TypePrinter, &Machine, GV->getParent());\n  Out << \" = \";\n\n  if (!GV->hasInitializer() && GV->hasExternalLinkage())\n    Out << \"external \";\n\n  Out << getLinkageNameWithSpace(GV->getLinkage());\n  PrintDSOLocation(*GV, Out);\n  PrintVisibility(GV->getVisibility(), Out);\n  PrintDLLStorageClass(GV->getDLLStorageClass(), Out);\n  PrintThreadLocalModel(GV->getThreadLocalMode(), Out);\n  StringRef UA = getUnnamedAddrEncoding(GV->getUnnamedAddr());\n  if (!UA.empty())\n      Out << UA << ' ';\n\n  if (unsigned AddressSpace = GV->getType()->getAddressSpace())\n    Out << \"addrspace(\" << AddressSpace << \") \";\n  if (GV->isExternallyInitialized()) Out << \"externally_initialized \";\n  Out << (GV->isConstant() ? \"constant \" : \"global \");\n  TypePrinter.print(GV->getValueType(), Out);\n\n  if (GV->hasInitializer()) {\n    Out << ' ';\n    writeOperand(GV->getInitializer(), false);\n  }\n\n  if (GV->hasSection()) {\n    Out << \", section \\\"\";\n    printEscapedString(GV->getSection(), Out);\n    Out << '\"';\n  }\n  if (GV->hasPartition()) {\n    Out << \", partition \\\"\";\n    printEscapedString(GV->getPartition(), Out);\n    Out << '\"';\n  }\n\n  maybePrintComdat(Out, *GV);\n  if (GV->getAlignment())\n    Out << \", align \" << GV->getAlignment();\n\n  SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;\n  GV->getAllMetadata(MDs);\n  printMetadataAttachments(MDs, \", \");\n\n  auto Attrs = GV->getAttributes();\n  if (Attrs.hasAttributes())\n    Out << \" #\" << Machine.getAttributeGroupSlot(Attrs);\n\n  printInfoComment(*GV);\n}\n\nvoid AssemblyWriter::printIndirectSymbol(const GlobalIndirectSymbol *GIS) {\n  if (GIS->isMaterializable())\n    Out << \"; Materializable\\n\";\n\n  WriteAsOperandInternal(Out, GIS, &TypePrinter, &Machine, GIS->getParent());\n  Out << \" = \";\n\n  Out << getLinkageNameWithSpace(GIS->getLinkage());\n  PrintDSOLocation(*GIS, Out);\n  PrintVisibility(GIS->getVisibility(), Out);\n  PrintDLLStorageClass(GIS->getDLLStorageClass(), Out);\n  PrintThreadLocalModel(GIS->getThreadLocalMode(), Out);\n  StringRef UA = getUnnamedAddrEncoding(GIS->getUnnamedAddr());\n  if (!UA.empty())\n      Out << UA << ' ';\n\n  if (isa<GlobalAlias>(GIS))\n    Out << \"alias \";\n  else if (isa<GlobalIFunc>(GIS))\n    Out << \"ifunc \";\n  else\n    llvm_unreachable(\"Not an alias or ifunc!\");\n\n  TypePrinter.print(GIS->getValueType(), Out);\n\n  Out << \", \";\n\n  const Constant *IS = GIS->getIndirectSymbol();\n\n  if (!IS) {\n    TypePrinter.print(GIS->getType(), Out);\n    Out << \" <<NULL ALIASEE>>\";\n  } else {\n    writeOperand(IS, !isa<ConstantExpr>(IS));\n  }\n\n  if (GIS->hasPartition()) {\n    Out << \", partition \\\"\";\n    printEscapedString(GIS->getPartition(), Out);\n    Out << '\"';\n  }\n\n  printInfoComment(*GIS);\n  Out << '\\n';\n}\n\nvoid AssemblyWriter::printComdat(const Comdat *C) {\n  C->print(Out);\n}\n\nvoid AssemblyWriter::printTypeIdentities() {\n  if (TypePrinter.empty())\n    return;\n\n  Out << '\\n';\n\n  // Emit all numbered types.\n  auto &NumberedTypes = TypePrinter.getNumberedTypes();\n  for (unsigned I = 0, E = NumberedTypes.size(); I != E; ++I) {\n    Out << '%' << I << \" = type \";\n\n    // Make sure we print out at least one level of the type structure, so\n    // that we do not get %2 = type %2\n    TypePrinter.printStructBody(NumberedTypes[I], Out);\n    Out << '\\n';\n  }\n\n  auto &NamedTypes = TypePrinter.getNamedTypes();\n  for (unsigned I = 0, E = NamedTypes.size(); I != E; ++I) {\n    PrintLLVMName(Out, NamedTypes[I]->getName(), LocalPrefix);\n    Out << \" = type \";\n\n    // Make sure we print out at least one level of the type structure, so\n    // that we do not get %FILE = type %FILE\n    TypePrinter.printStructBody(NamedTypes[I], Out);\n    Out << '\\n';\n  }\n}\n\n/// printFunction - Print all aspects of a function.\nvoid AssemblyWriter::printFunction(const Function *F) {\n  if (AnnotationWriter) AnnotationWriter->emitFunctionAnnot(F, Out);\n\n  if (F->isMaterializable())\n    Out << \"; Materializable\\n\";\n\n  const AttributeList &Attrs = F->getAttributes();\n  if (Attrs.hasAttributes(AttributeList::FunctionIndex)) {\n    AttributeSet AS = Attrs.getFnAttributes();\n    std::string AttrStr;\n\n    for (const Attribute &Attr : AS) {\n      if (!Attr.isStringAttribute()) {\n        if (!AttrStr.empty()) AttrStr += ' ';\n        AttrStr += Attr.getAsString();\n      }\n    }\n\n    if (!AttrStr.empty())\n      Out << \"; Function Attrs: \" << AttrStr << '\\n';\n  }\n\n  Machine.incorporateFunction(F);\n\n  if (F->isDeclaration()) {\n    Out << \"declare\";\n    SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;\n    F->getAllMetadata(MDs);\n    printMetadataAttachments(MDs, \" \");\n    Out << ' ';\n  } else\n    Out << \"define \";\n\n  Out << getLinkageNameWithSpace(F->getLinkage());\n  PrintDSOLocation(*F, Out);\n  PrintVisibility(F->getVisibility(), Out);\n  PrintDLLStorageClass(F->getDLLStorageClass(), Out);\n\n  // Print the calling convention.\n  if (F->getCallingConv() != CallingConv::C) {\n    PrintCallingConv(F->getCallingConv(), Out);\n    Out << \" \";\n  }\n\n  FunctionType *FT = F->getFunctionType();\n  if (Attrs.hasAttributes(AttributeList::ReturnIndex))\n    Out << Attrs.getAsString(AttributeList::ReturnIndex) << ' ';\n  TypePrinter.print(F->getReturnType(), Out);\n  Out << ' ';\n  WriteAsOperandInternal(Out, F, &TypePrinter, &Machine, F->getParent());\n  Out << '(';\n\n  // Loop over the arguments, printing them...\n  if (F->isDeclaration() && !IsForDebug) {\n    // We're only interested in the type here - don't print argument names.\n    for (unsigned I = 0, E = FT->getNumParams(); I != E; ++I) {\n      // Insert commas as we go... the first arg doesn't get a comma\n      if (I)\n        Out << \", \";\n      // Output type...\n      TypePrinter.print(FT->getParamType(I), Out);\n\n      AttributeSet ArgAttrs = Attrs.getParamAttributes(I);\n      if (ArgAttrs.hasAttributes()) {\n        Out << ' ';\n        writeAttributeSet(ArgAttrs);\n      }\n    }\n  } else {\n    // The arguments are meaningful here, print them in detail.\n    for (const Argument &Arg : F->args()) {\n      // Insert commas as we go... the first arg doesn't get a comma\n      if (Arg.getArgNo() != 0)\n        Out << \", \";\n      printArgument(&Arg, Attrs.getParamAttributes(Arg.getArgNo()));\n    }\n  }\n\n  // Finish printing arguments...\n  if (FT->isVarArg()) {\n    if (FT->getNumParams()) Out << \", \";\n    Out << \"...\";  // Output varargs portion of signature!\n  }\n  Out << ')';\n  StringRef UA = getUnnamedAddrEncoding(F->getUnnamedAddr());\n  if (!UA.empty())\n    Out << ' ' << UA;\n  // We print the function address space if it is non-zero or if we are writing\n  // a module with a non-zero program address space or if there is no valid\n  // Module* so that the file can be parsed without the datalayout string.\n  const Module *Mod = F->getParent();\n  if (F->getAddressSpace() != 0 || !Mod ||\n      Mod->getDataLayout().getProgramAddressSpace() != 0)\n    Out << \" addrspace(\" << F->getAddressSpace() << \")\";\n  if (Attrs.hasAttributes(AttributeList::FunctionIndex))\n    Out << \" #\" << Machine.getAttributeGroupSlot(Attrs.getFnAttributes());\n  if (F->hasSection()) {\n    Out << \" section \\\"\";\n    printEscapedString(F->getSection(), Out);\n    Out << '\"';\n  }\n  if (F->hasPartition()) {\n    Out << \" partition \\\"\";\n    printEscapedString(F->getPartition(), Out);\n    Out << '\"';\n  }\n  maybePrintComdat(Out, *F);\n  if (F->getAlignment())\n    Out << \" align \" << F->getAlignment();\n  if (F->hasGC())\n    Out << \" gc \\\"\" << F->getGC() << '\"';\n  if (F->hasPrefixData()) {\n    Out << \" prefix \";\n    writeOperand(F->getPrefixData(), true);\n  }\n  if (F->hasPrologueData()) {\n    Out << \" prologue \";\n    writeOperand(F->getPrologueData(), true);\n  }\n  if (F->hasPersonalityFn()) {\n    Out << \" personality \";\n    writeOperand(F->getPersonalityFn(), /*PrintType=*/true);\n  }\n\n  if (F->isDeclaration()) {\n    Out << '\\n';\n  } else {\n    SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;\n    F->getAllMetadata(MDs);\n    printMetadataAttachments(MDs, \" \");\n\n    Out << \" {\";\n    // Output all of the function's basic blocks.\n    for (const BasicBlock &BB : *F)\n      printBasicBlock(&BB);\n\n    // Output the function's use-lists.\n    printUseLists(F);\n\n    Out << \"}\\n\";\n  }\n\n  Machine.purgeFunction();\n}\n\n/// printArgument - This member is called for every argument that is passed into\n/// the function.  Simply print it out\nvoid AssemblyWriter::printArgument(const Argument *Arg, AttributeSet Attrs) {\n  // Output type...\n  TypePrinter.print(Arg->getType(), Out);\n\n  // Output parameter attributes list\n  if (Attrs.hasAttributes()) {\n    Out << ' ';\n    writeAttributeSet(Attrs);\n  }\n\n  // Output name, if available...\n  if (Arg->hasName()) {\n    Out << ' ';\n    PrintLLVMName(Out, Arg);\n  } else {\n    int Slot = Machine.getLocalSlot(Arg);\n    assert(Slot != -1 && \"expect argument in function here\");\n    Out << \" %\" << Slot;\n  }\n}\n\n/// printBasicBlock - This member is called for each basic block in a method.\nvoid AssemblyWriter::printBasicBlock(const BasicBlock *BB) {\n  assert(BB && BB->getParent() && \"block without parent!\");\n  bool IsEntryBlock = BB == &BB->getParent()->getEntryBlock();\n  if (BB->hasName()) {              // Print out the label if it exists...\n    Out << \"\\n\";\n    PrintLLVMName(Out, BB->getName(), LabelPrefix);\n    Out << ':';\n  } else if (!IsEntryBlock) {\n    Out << \"\\n\";\n    int Slot = Machine.getLocalSlot(BB);\n    if (Slot != -1)\n      Out << Slot << \":\";\n    else\n      Out << \"<badref>:\";\n  }\n\n  if (!IsEntryBlock) {\n    // Output predecessors for the block.\n    Out.PadToColumn(50);\n    Out << \";\";\n    const_pred_iterator PI = pred_begin(BB), PE = pred_end(BB);\n\n    if (PI == PE) {\n      Out << \" No predecessors!\";\n    } else {\n      Out << \" preds = \";\n      writeOperand(*PI, false);\n      for (++PI; PI != PE; ++PI) {\n        Out << \", \";\n        writeOperand(*PI, false);\n      }\n    }\n  }\n\n  Out << \"\\n\";\n\n  if (AnnotationWriter) AnnotationWriter->emitBasicBlockStartAnnot(BB, Out);\n\n  // Output all of the instructions in the basic block...\n  for (const Instruction &I : *BB) {\n    printInstructionLine(I);\n  }\n\n  if (AnnotationWriter) AnnotationWriter->emitBasicBlockEndAnnot(BB, Out);\n}\n\n/// printInstructionLine - Print an instruction and a newline character.\nvoid AssemblyWriter::printInstructionLine(const Instruction &I) {\n  printInstruction(I);\n  Out << '\\n';\n}\n\n/// printGCRelocateComment - print comment after call to the gc.relocate\n/// intrinsic indicating base and derived pointer names.\nvoid AssemblyWriter::printGCRelocateComment(const GCRelocateInst &Relocate) {\n  Out << \" ; (\";\n  writeOperand(Relocate.getBasePtr(), false);\n  Out << \", \";\n  writeOperand(Relocate.getDerivedPtr(), false);\n  Out << \")\";\n}\n\n/// printInfoComment - Print a little comment after the instruction indicating\n/// which slot it occupies.\nvoid AssemblyWriter::printInfoComment(const Value &V) {\n  if (const auto *Relocate = dyn_cast<GCRelocateInst>(&V))\n    printGCRelocateComment(*Relocate);\n\n  if (AnnotationWriter)\n    AnnotationWriter->printInfoComment(V, Out);\n}\n\nstatic void maybePrintCallAddrSpace(const Value *Operand, const Instruction *I,\n                                    raw_ostream &Out) {\n  // We print the address space of the call if it is non-zero.\n  unsigned CallAddrSpace = Operand->getType()->getPointerAddressSpace();\n  bool PrintAddrSpace = CallAddrSpace != 0;\n  if (!PrintAddrSpace) {\n    const Module *Mod = getModuleFromVal(I);\n    // We also print it if it is zero but not equal to the program address space\n    // or if we can't find a valid Module* to make it possible to parse\n    // the resulting file even without a datalayout string.\n    if (!Mod || Mod->getDataLayout().getProgramAddressSpace() != 0)\n      PrintAddrSpace = true;\n  }\n  if (PrintAddrSpace)\n    Out << \" addrspace(\" << CallAddrSpace << \")\";\n}\n\n// This member is called for each Instruction in a function..\nvoid AssemblyWriter::printInstruction(const Instruction &I) {\n  if (AnnotationWriter) AnnotationWriter->emitInstructionAnnot(&I, Out);\n\n  // Print out indentation for an instruction.\n  Out << \"  \";\n\n  // Print out name if it exists...\n  if (I.hasName()) {\n    PrintLLVMName(Out, &I);\n    Out << \" = \";\n  } else if (!I.getType()->isVoidTy()) {\n    // Print out the def slot taken.\n    int SlotNum = Machine.getLocalSlot(&I);\n    if (SlotNum == -1)\n      Out << \"<badref> = \";\n    else\n      Out << '%' << SlotNum << \" = \";\n  }\n\n  if (const CallInst *CI = dyn_cast<CallInst>(&I)) {\n    if (CI->isMustTailCall())\n      Out << \"musttail \";\n    else if (CI->isTailCall())\n      Out << \"tail \";\n    else if (CI->isNoTailCall())\n      Out << \"notail \";\n  }\n\n  // Print out the opcode...\n  Out << I.getOpcodeName();\n\n  // If this is an atomic load or store, print out the atomic marker.\n  if ((isa<LoadInst>(I)  && cast<LoadInst>(I).isAtomic()) ||\n      (isa<StoreInst>(I) && cast<StoreInst>(I).isAtomic()))\n    Out << \" atomic\";\n\n  if (isa<AtomicCmpXchgInst>(I) && cast<AtomicCmpXchgInst>(I).isWeak())\n    Out << \" weak\";\n\n  // If this is a volatile operation, print out the volatile marker.\n  if ((isa<LoadInst>(I)  && cast<LoadInst>(I).isVolatile()) ||\n      (isa<StoreInst>(I) && cast<StoreInst>(I).isVolatile()) ||\n      (isa<AtomicCmpXchgInst>(I) && cast<AtomicCmpXchgInst>(I).isVolatile()) ||\n      (isa<AtomicRMWInst>(I) && cast<AtomicRMWInst>(I).isVolatile()))\n    Out << \" volatile\";\n\n  // Print out optimization information.\n  WriteOptimizationInfo(Out, &I);\n\n  // Print out the compare instruction predicates\n  if (const CmpInst *CI = dyn_cast<CmpInst>(&I))\n    Out << ' ' << CmpInst::getPredicateName(CI->getPredicate());\n\n  // Print out the atomicrmw operation\n  if (const AtomicRMWInst *RMWI = dyn_cast<AtomicRMWInst>(&I))\n    Out << ' ' << AtomicRMWInst::getOperationName(RMWI->getOperation());\n\n  // Print out the type of the operands...\n  const Value *Operand = I.getNumOperands() ? I.getOperand(0) : nullptr;\n\n  // Special case conditional branches to swizzle the condition out to the front\n  if (isa<BranchInst>(I) && cast<BranchInst>(I).isConditional()) {\n    const BranchInst &BI(cast<BranchInst>(I));\n    Out << ' ';\n    writeOperand(BI.getCondition(), true);\n    Out << \", \";\n    writeOperand(BI.getSuccessor(0), true);\n    Out << \", \";\n    writeOperand(BI.getSuccessor(1), true);\n\n  } else if (isa<SwitchInst>(I)) {\n    const SwitchInst& SI(cast<SwitchInst>(I));\n    // Special case switch instruction to get formatting nice and correct.\n    Out << ' ';\n    writeOperand(SI.getCondition(), true);\n    Out << \", \";\n    writeOperand(SI.getDefaultDest(), true);\n    Out << \" [\";\n    for (auto Case : SI.cases()) {\n      Out << \"\\n    \";\n      writeOperand(Case.getCaseValue(), true);\n      Out << \", \";\n      writeOperand(Case.getCaseSuccessor(), true);\n    }\n    Out << \"\\n  ]\";\n  } else if (isa<IndirectBrInst>(I)) {\n    // Special case indirectbr instruction to get formatting nice and correct.\n    Out << ' ';\n    writeOperand(Operand, true);\n    Out << \", [\";\n\n    for (unsigned i = 1, e = I.getNumOperands(); i != e; ++i) {\n      if (i != 1)\n        Out << \", \";\n      writeOperand(I.getOperand(i), true);\n    }\n    Out << ']';\n  } else if (const PHINode *PN = dyn_cast<PHINode>(&I)) {\n    Out << ' ';\n    TypePrinter.print(I.getType(), Out);\n    Out << ' ';\n\n    for (unsigned op = 0, Eop = PN->getNumIncomingValues(); op < Eop; ++op) {\n      if (op) Out << \", \";\n      Out << \"[ \";\n      writeOperand(PN->getIncomingValue(op), false); Out << \", \";\n      writeOperand(PN->getIncomingBlock(op), false); Out << \" ]\";\n    }\n  } else if (const ExtractValueInst *EVI = dyn_cast<ExtractValueInst>(&I)) {\n    Out << ' ';\n    writeOperand(I.getOperand(0), true);\n    for (const unsigned *i = EVI->idx_begin(), *e = EVI->idx_end(); i != e; ++i)\n      Out << \", \" << *i;\n  } else if (const InsertValueInst *IVI = dyn_cast<InsertValueInst>(&I)) {\n    Out << ' ';\n    writeOperand(I.getOperand(0), true); Out << \", \";\n    writeOperand(I.getOperand(1), true);\n    for (const unsigned *i = IVI->idx_begin(), *e = IVI->idx_end(); i != e; ++i)\n      Out << \", \" << *i;\n  } else if (const LandingPadInst *LPI = dyn_cast<LandingPadInst>(&I)) {\n    Out << ' ';\n    TypePrinter.print(I.getType(), Out);\n    if (LPI->isCleanup() || LPI->getNumClauses() != 0)\n      Out << '\\n';\n\n    if (LPI->isCleanup())\n      Out << \"          cleanup\";\n\n    for (unsigned i = 0, e = LPI->getNumClauses(); i != e; ++i) {\n      if (i != 0 || LPI->isCleanup()) Out << \"\\n\";\n      if (LPI->isCatch(i))\n        Out << \"          catch \";\n      else\n        Out << \"          filter \";\n\n      writeOperand(LPI->getClause(i), true);\n    }\n  } else if (const auto *CatchSwitch = dyn_cast<CatchSwitchInst>(&I)) {\n    Out << \" within \";\n    writeOperand(CatchSwitch->getParentPad(), /*PrintType=*/false);\n    Out << \" [\";\n    unsigned Op = 0;\n    for (const BasicBlock *PadBB : CatchSwitch->handlers()) {\n      if (Op > 0)\n        Out << \", \";\n      writeOperand(PadBB, /*PrintType=*/true);\n      ++Op;\n    }\n    Out << \"] unwind \";\n    if (const BasicBlock *UnwindDest = CatchSwitch->getUnwindDest())\n      writeOperand(UnwindDest, /*PrintType=*/true);\n    else\n      Out << \"to caller\";\n  } else if (const auto *FPI = dyn_cast<FuncletPadInst>(&I)) {\n    Out << \" within \";\n    writeOperand(FPI->getParentPad(), /*PrintType=*/false);\n    Out << \" [\";\n    for (unsigned Op = 0, NumOps = FPI->getNumArgOperands(); Op < NumOps;\n         ++Op) {\n      if (Op > 0)\n        Out << \", \";\n      writeOperand(FPI->getArgOperand(Op), /*PrintType=*/true);\n    }\n    Out << ']';\n  } else if (isa<ReturnInst>(I) && !Operand) {\n    Out << \" void\";\n  } else if (const auto *CRI = dyn_cast<CatchReturnInst>(&I)) {\n    Out << \" from \";\n    writeOperand(CRI->getOperand(0), /*PrintType=*/false);\n\n    Out << \" to \";\n    writeOperand(CRI->getOperand(1), /*PrintType=*/true);\n  } else if (const auto *CRI = dyn_cast<CleanupReturnInst>(&I)) {\n    Out << \" from \";\n    writeOperand(CRI->getOperand(0), /*PrintType=*/false);\n\n    Out << \" unwind \";\n    if (CRI->hasUnwindDest())\n      writeOperand(CRI->getOperand(1), /*PrintType=*/true);\n    else\n      Out << \"to caller\";\n  } else if (const CallInst *CI = dyn_cast<CallInst>(&I)) {\n    // Print the calling convention being used.\n    if (CI->getCallingConv() != CallingConv::C) {\n      Out << \" \";\n      PrintCallingConv(CI->getCallingConv(), Out);\n    }\n\n    Operand = CI->getCalledOperand();\n    FunctionType *FTy = CI->getFunctionType();\n    Type *RetTy = FTy->getReturnType();\n    const AttributeList &PAL = CI->getAttributes();\n\n    if (PAL.hasAttributes(AttributeList::ReturnIndex))\n      Out << ' ' << PAL.getAsString(AttributeList::ReturnIndex);\n\n    // Only print addrspace(N) if necessary:\n    maybePrintCallAddrSpace(Operand, &I, Out);\n\n    // If possible, print out the short form of the call instruction.  We can\n    // only do this if the first argument is a pointer to a nonvararg function,\n    // and if the return type is not a pointer to a function.\n    //\n    Out << ' ';\n    TypePrinter.print(FTy->isVarArg() ? FTy : RetTy, Out);\n    Out << ' ';\n    writeOperand(Operand, false);\n    Out << '(';\n    for (unsigned op = 0, Eop = CI->getNumArgOperands(); op < Eop; ++op) {\n      if (op > 0)\n        Out << \", \";\n      writeParamOperand(CI->getArgOperand(op), PAL.getParamAttributes(op));\n    }\n\n    // Emit an ellipsis if this is a musttail call in a vararg function.  This\n    // is only to aid readability, musttail calls forward varargs by default.\n    if (CI->isMustTailCall() && CI->getParent() &&\n        CI->getParent()->getParent() &&\n        CI->getParent()->getParent()->isVarArg())\n      Out << \", ...\";\n\n    Out << ')';\n    if (PAL.hasAttributes(AttributeList::FunctionIndex))\n      Out << \" #\" << Machine.getAttributeGroupSlot(PAL.getFnAttributes());\n\n    writeOperandBundles(CI);\n  } else if (const InvokeInst *II = dyn_cast<InvokeInst>(&I)) {\n    Operand = II->getCalledOperand();\n    FunctionType *FTy = II->getFunctionType();\n    Type *RetTy = FTy->getReturnType();\n    const AttributeList &PAL = II->getAttributes();\n\n    // Print the calling convention being used.\n    if (II->getCallingConv() != CallingConv::C) {\n      Out << \" \";\n      PrintCallingConv(II->getCallingConv(), Out);\n    }\n\n    if (PAL.hasAttributes(AttributeList::ReturnIndex))\n      Out << ' ' << PAL.getAsString(AttributeList::ReturnIndex);\n\n    // Only print addrspace(N) if necessary:\n    maybePrintCallAddrSpace(Operand, &I, Out);\n\n    // If possible, print out the short form of the invoke instruction. We can\n    // only do this if the first argument is a pointer to a nonvararg function,\n    // and if the return type is not a pointer to a function.\n    //\n    Out << ' ';\n    TypePrinter.print(FTy->isVarArg() ? FTy : RetTy, Out);\n    Out << ' ';\n    writeOperand(Operand, false);\n    Out << '(';\n    for (unsigned op = 0, Eop = II->getNumArgOperands(); op < Eop; ++op) {\n      if (op)\n        Out << \", \";\n      writeParamOperand(II->getArgOperand(op), PAL.getParamAttributes(op));\n    }\n\n    Out << ')';\n    if (PAL.hasAttributes(AttributeList::FunctionIndex))\n      Out << \" #\" << Machine.getAttributeGroupSlot(PAL.getFnAttributes());\n\n    writeOperandBundles(II);\n\n    Out << \"\\n          to \";\n    writeOperand(II->getNormalDest(), true);\n    Out << \" unwind \";\n    writeOperand(II->getUnwindDest(), true);\n  } else if (const CallBrInst *CBI = dyn_cast<CallBrInst>(&I)) {\n    Operand = CBI->getCalledOperand();\n    FunctionType *FTy = CBI->getFunctionType();\n    Type *RetTy = FTy->getReturnType();\n    const AttributeList &PAL = CBI->getAttributes();\n\n    // Print the calling convention being used.\n    if (CBI->getCallingConv() != CallingConv::C) {\n      Out << \" \";\n      PrintCallingConv(CBI->getCallingConv(), Out);\n    }\n\n    if (PAL.hasAttributes(AttributeList::ReturnIndex))\n      Out << ' ' << PAL.getAsString(AttributeList::ReturnIndex);\n\n    // If possible, print out the short form of the callbr instruction. We can\n    // only do this if the first argument is a pointer to a nonvararg function,\n    // and if the return type is not a pointer to a function.\n    //\n    Out << ' ';\n    TypePrinter.print(FTy->isVarArg() ? FTy : RetTy, Out);\n    Out << ' ';\n    writeOperand(Operand, false);\n    Out << '(';\n    for (unsigned op = 0, Eop = CBI->getNumArgOperands(); op < Eop; ++op) {\n      if (op)\n        Out << \", \";\n      writeParamOperand(CBI->getArgOperand(op), PAL.getParamAttributes(op));\n    }\n\n    Out << ')';\n    if (PAL.hasAttributes(AttributeList::FunctionIndex))\n      Out << \" #\" << Machine.getAttributeGroupSlot(PAL.getFnAttributes());\n\n    writeOperandBundles(CBI);\n\n    Out << \"\\n          to \";\n    writeOperand(CBI->getDefaultDest(), true);\n    Out << \" [\";\n    for (unsigned i = 0, e = CBI->getNumIndirectDests(); i != e; ++i) {\n      if (i != 0)\n        Out << \", \";\n      writeOperand(CBI->getIndirectDest(i), true);\n    }\n    Out << ']';\n  } else if (const AllocaInst *AI = dyn_cast<AllocaInst>(&I)) {\n    Out << ' ';\n    if (AI->isUsedWithInAlloca())\n      Out << \"inalloca \";\n    if (AI->isSwiftError())\n      Out << \"swifterror \";\n    TypePrinter.print(AI->getAllocatedType(), Out);\n\n    // Explicitly write the array size if the code is broken, if it's an array\n    // allocation, or if the type is not canonical for scalar allocations.  The\n    // latter case prevents the type from mutating when round-tripping through\n    // assembly.\n    if (!AI->getArraySize() || AI->isArrayAllocation() ||\n        !AI->getArraySize()->getType()->isIntegerTy(32)) {\n      Out << \", \";\n      writeOperand(AI->getArraySize(), true);\n    }\n    if (AI->getAlignment()) {\n      Out << \", align \" << AI->getAlignment();\n    }\n\n    unsigned AddrSpace = AI->getType()->getAddressSpace();\n    if (AddrSpace != 0) {\n      Out << \", addrspace(\" << AddrSpace << ')';\n    }\n  } else if (isa<CastInst>(I)) {\n    if (Operand) {\n      Out << ' ';\n      writeOperand(Operand, true);   // Work with broken code\n    }\n    Out << \" to \";\n    TypePrinter.print(I.getType(), Out);\n  } else if (isa<VAArgInst>(I)) {\n    if (Operand) {\n      Out << ' ';\n      writeOperand(Operand, true);   // Work with broken code\n    }\n    Out << \", \";\n    TypePrinter.print(I.getType(), Out);\n  } else if (Operand) {   // Print the normal way.\n    if (const auto *GEP = dyn_cast<GetElementPtrInst>(&I)) {\n      Out << ' ';\n      TypePrinter.print(GEP->getSourceElementType(), Out);\n      Out << ',';\n    } else if (const auto *LI = dyn_cast<LoadInst>(&I)) {\n      Out << ' ';\n      TypePrinter.print(LI->getType(), Out);\n      Out << ',';\n    }\n\n    // PrintAllTypes - Instructions who have operands of all the same type\n    // omit the type from all but the first operand.  If the instruction has\n    // different type operands (for example br), then they are all printed.\n    bool PrintAllTypes = false;\n    Type *TheType = Operand->getType();\n\n    // Select, Store and ShuffleVector always print all types.\n    if (isa<SelectInst>(I) || isa<StoreInst>(I) || isa<ShuffleVectorInst>(I)\n        || isa<ReturnInst>(I)) {\n      PrintAllTypes = true;\n    } else {\n      for (unsigned i = 1, E = I.getNumOperands(); i != E; ++i) {\n        Operand = I.getOperand(i);\n        // note that Operand shouldn't be null, but the test helps make dump()\n        // more tolerant of malformed IR\n        if (Operand && Operand->getType() != TheType) {\n          PrintAllTypes = true;    // We have differing types!  Print them all!\n          break;\n        }\n      }\n    }\n\n    if (!PrintAllTypes) {\n      Out << ' ';\n      TypePrinter.print(TheType, Out);\n    }\n\n    Out << ' ';\n    for (unsigned i = 0, E = I.getNumOperands(); i != E; ++i) {\n      if (i) Out << \", \";\n      writeOperand(I.getOperand(i), PrintAllTypes);\n    }\n  }\n\n  // Print atomic ordering/alignment for memory operations\n  if (const LoadInst *LI = dyn_cast<LoadInst>(&I)) {\n    if (LI->isAtomic())\n      writeAtomic(LI->getContext(), LI->getOrdering(), LI->getSyncScopeID());\n    if (LI->getAlignment())\n      Out << \", align \" << LI->getAlignment();\n  } else if (const StoreInst *SI = dyn_cast<StoreInst>(&I)) {\n    if (SI->isAtomic())\n      writeAtomic(SI->getContext(), SI->getOrdering(), SI->getSyncScopeID());\n    if (SI->getAlignment())\n      Out << \", align \" << SI->getAlignment();\n  } else if (const AtomicCmpXchgInst *CXI = dyn_cast<AtomicCmpXchgInst>(&I)) {\n    writeAtomicCmpXchg(CXI->getContext(), CXI->getSuccessOrdering(),\n                       CXI->getFailureOrdering(), CXI->getSyncScopeID());\n  } else if (const AtomicRMWInst *RMWI = dyn_cast<AtomicRMWInst>(&I)) {\n    writeAtomic(RMWI->getContext(), RMWI->getOrdering(),\n                RMWI->getSyncScopeID());\n  } else if (const FenceInst *FI = dyn_cast<FenceInst>(&I)) {\n    writeAtomic(FI->getContext(), FI->getOrdering(), FI->getSyncScopeID());\n  } else if (const ShuffleVectorInst *SVI = dyn_cast<ShuffleVectorInst>(&I)) {\n    PrintShuffleMask(Out, SVI->getType(), SVI->getShuffleMask());\n  }\n\n  // Print Metadata info.\n  SmallVector<std::pair<unsigned, MDNode *>, 4> InstMD;\n  I.getAllMetadata(InstMD);\n  printMetadataAttachments(InstMD, \", \");\n\n  // Print a nice comment.\n  printInfoComment(I);\n}\n\nvoid AssemblyWriter::printMetadataAttachments(\n    const SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs,\n    StringRef Separator) {\n  if (MDs.empty())\n    return;\n\n  if (MDNames.empty())\n    MDs[0].second->getContext().getMDKindNames(MDNames);\n\n  for (const auto &I : MDs) {\n    unsigned Kind = I.first;\n    Out << Separator;\n    if (Kind < MDNames.size()) {\n      Out << \"!\";\n      printMetadataIdentifier(MDNames[Kind], Out);\n    } else\n      Out << \"!<unknown kind #\" << Kind << \">\";\n    Out << ' ';\n    WriteAsOperandInternal(Out, I.second, &TypePrinter, &Machine, TheModule);\n  }\n}\n\nvoid AssemblyWriter::writeMDNode(unsigned Slot, const MDNode *Node) {\n  Out << '!' << Slot << \" = \";\n  printMDNodeBody(Node);\n  Out << \"\\n\";\n}\n\nvoid AssemblyWriter::writeAllMDNodes() {\n  SmallVector<const MDNode *, 16> Nodes;\n  Nodes.resize(Machine.mdn_size());\n  for (SlotTracker::mdn_iterator I = Machine.mdn_begin(), E = Machine.mdn_end();\n       I != E; ++I)\n    Nodes[I->second] = cast<MDNode>(I->first);\n\n  for (unsigned i = 0, e = Nodes.size(); i != e; ++i) {\n    writeMDNode(i, Nodes[i]);\n  }\n}\n\nvoid AssemblyWriter::printMDNodeBody(const MDNode *Node) {\n  WriteMDNodeBodyInternal(Out, Node, &TypePrinter, &Machine, TheModule);\n}\n\nvoid AssemblyWriter::writeAttribute(const Attribute &Attr, bool InAttrGroup) {\n  if (!Attr.isTypeAttribute()) {\n    Out << Attr.getAsString(InAttrGroup);\n    return;\n  }\n\n  assert((Attr.hasAttribute(Attribute::ByVal) ||\n          Attr.hasAttribute(Attribute::StructRet) ||\n          Attr.hasAttribute(Attribute::ByRef) ||\n          Attr.hasAttribute(Attribute::Preallocated)) &&\n         \"unexpected type attr\");\n\n  if (Attr.hasAttribute(Attribute::ByVal)) {\n    Out << \"byval\";\n  } else if (Attr.hasAttribute(Attribute::StructRet)) {\n    Out << \"sret\";\n  } else if (Attr.hasAttribute(Attribute::ByRef)) {\n    Out << \"byref\";\n  } else {\n    Out << \"preallocated\";\n  }\n\n  if (Type *Ty = Attr.getValueAsType()) {\n    Out << '(';\n    TypePrinter.print(Ty, Out);\n    Out << ')';\n  }\n}\n\nvoid AssemblyWriter::writeAttributeSet(const AttributeSet &AttrSet,\n                                       bool InAttrGroup) {\n  bool FirstAttr = true;\n  for (const auto &Attr : AttrSet) {\n    if (!FirstAttr)\n      Out << ' ';\n    writeAttribute(Attr, InAttrGroup);\n    FirstAttr = false;\n  }\n}\n\nvoid AssemblyWriter::writeAllAttributeGroups() {\n  std::vector<std::pair<AttributeSet, unsigned>> asVec;\n  asVec.resize(Machine.as_size());\n\n  for (SlotTracker::as_iterator I = Machine.as_begin(), E = Machine.as_end();\n       I != E; ++I)\n    asVec[I->second] = *I;\n\n  for (const auto &I : asVec)\n    Out << \"attributes #\" << I.second << \" = { \"\n        << I.first.getAsString(true) << \" }\\n\";\n}\n\nvoid AssemblyWriter::printUseListOrder(const UseListOrder &Order) {\n  bool IsInFunction = Machine.getFunction();\n  if (IsInFunction)\n    Out << \"  \";\n\n  Out << \"uselistorder\";\n  if (const BasicBlock *BB =\n          IsInFunction ? nullptr : dyn_cast<BasicBlock>(Order.V)) {\n    Out << \"_bb \";\n    writeOperand(BB->getParent(), false);\n    Out << \", \";\n    writeOperand(BB, false);\n  } else {\n    Out << \" \";\n    writeOperand(Order.V, true);\n  }\n  Out << \", { \";\n\n  assert(Order.Shuffle.size() >= 2 && \"Shuffle too small\");\n  Out << Order.Shuffle[0];\n  for (unsigned I = 1, E = Order.Shuffle.size(); I != E; ++I)\n    Out << \", \" << Order.Shuffle[I];\n  Out << \" }\\n\";\n}\n\nvoid AssemblyWriter::printUseLists(const Function *F) {\n  auto hasMore =\n      [&]() { return !UseListOrders.empty() && UseListOrders.back().F == F; };\n  if (!hasMore())\n    // Nothing to do.\n    return;\n\n  Out << \"\\n; uselistorder directives\\n\";\n  while (hasMore()) {\n    printUseListOrder(UseListOrders.back());\n    UseListOrders.pop_back();\n  }\n}\n\n//===----------------------------------------------------------------------===//\n//                       External Interface declarations\n//===----------------------------------------------------------------------===//\n\nvoid Function::print(raw_ostream &ROS, AssemblyAnnotationWriter *AAW,\n                     bool ShouldPreserveUseListOrder,\n                     bool IsForDebug) const {\n  SlotTracker SlotTable(this->getParent());\n  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, SlotTable, this->getParent(), AAW,\n                   IsForDebug,\n                   ShouldPreserveUseListOrder);\n  W.printFunction(this);\n}\n\nvoid BasicBlock::print(raw_ostream &ROS, AssemblyAnnotationWriter *AAW,\n                     bool ShouldPreserveUseListOrder,\n                     bool IsForDebug) const {\n  SlotTracker SlotTable(this->getParent());\n  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, SlotTable, this->getModule(), AAW,\n                   IsForDebug,\n                   ShouldPreserveUseListOrder);\n  W.printBasicBlock(this);\n}\n\nvoid Module::print(raw_ostream &ROS, AssemblyAnnotationWriter *AAW,\n                   bool ShouldPreserveUseListOrder, bool IsForDebug) const {\n  SlotTracker SlotTable(this);\n  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, SlotTable, this, AAW, IsForDebug,\n                   ShouldPreserveUseListOrder);\n  W.printModule(this);\n}\n\nvoid NamedMDNode::print(raw_ostream &ROS, bool IsForDebug) const {\n  SlotTracker SlotTable(getParent());\n  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, SlotTable, getParent(), nullptr, IsForDebug);\n  W.printNamedMDNode(this);\n}\n\nvoid NamedMDNode::print(raw_ostream &ROS, ModuleSlotTracker &MST,\n                        bool IsForDebug) const {\n  Optional<SlotTracker> LocalST;\n  SlotTracker *SlotTable;\n  if (auto *ST = MST.getMachine())\n    SlotTable = ST;\n  else {\n    LocalST.emplace(getParent());\n    SlotTable = &*LocalST;\n  }\n\n  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, *SlotTable, getParent(), nullptr, IsForDebug);\n  W.printNamedMDNode(this);\n}\n\nvoid Comdat::print(raw_ostream &ROS, bool /*IsForDebug*/) const {\n  PrintLLVMName(ROS, getName(), ComdatPrefix);\n  ROS << \" = comdat \";\n\n  switch (getSelectionKind()) {\n  case Comdat::Any:\n    ROS << \"any\";\n    break;\n  case Comdat::ExactMatch:\n    ROS << \"exactmatch\";\n    break;\n  case Comdat::Largest:\n    ROS << \"largest\";\n    break;\n  case Comdat::NoDuplicates:\n    ROS << \"noduplicates\";\n    break;\n  case Comdat::SameSize:\n    ROS << \"samesize\";\n    break;\n  }\n\n  ROS << '\\n';\n}\n\nvoid Type::print(raw_ostream &OS, bool /*IsForDebug*/, bool NoDetails) const {\n  TypePrinting TP;\n  TP.print(const_cast<Type*>(this), OS);\n\n  if (NoDetails)\n    return;\n\n  // If the type is a named struct type, print the body as well.\n  if (StructType *STy = dyn_cast<StructType>(const_cast<Type*>(this)))\n    if (!STy->isLiteral()) {\n      OS << \" = type \";\n      TP.printStructBody(STy, OS);\n    }\n}\n\nstatic bool isReferencingMDNode(const Instruction &I) {\n  if (const auto *CI = dyn_cast<CallInst>(&I))\n    if (Function *F = CI->getCalledFunction())\n      if (F->isIntrinsic())\n        for (auto &Op : I.operands())\n          if (auto *V = dyn_cast_or_null<MetadataAsValue>(Op))\n            if (isa<MDNode>(V->getMetadata()))\n              return true;\n  return false;\n}\n\nvoid Value::print(raw_ostream &ROS, bool IsForDebug) const {\n  bool ShouldInitializeAllMetadata = false;\n  if (auto *I = dyn_cast<Instruction>(this))\n    ShouldInitializeAllMetadata = isReferencingMDNode(*I);\n  else if (isa<Function>(this) || isa<MetadataAsValue>(this))\n    ShouldInitializeAllMetadata = true;\n\n  ModuleSlotTracker MST(getModuleFromVal(this), ShouldInitializeAllMetadata);\n  print(ROS, MST, IsForDebug);\n}\n\nvoid Value::print(raw_ostream &ROS, ModuleSlotTracker &MST,\n                  bool IsForDebug) const {\n  formatted_raw_ostream OS(ROS);\n  SlotTracker EmptySlotTable(static_cast<const Module *>(nullptr));\n  SlotTracker &SlotTable =\n      MST.getMachine() ? *MST.getMachine() : EmptySlotTable;\n  auto incorporateFunction = [&](const Function *F) {\n    if (F)\n      MST.incorporateFunction(*F);\n  };\n\n  if (const Instruction *I = dyn_cast<Instruction>(this)) {\n    incorporateFunction(I->getParent() ? I->getParent()->getParent() : nullptr);\n    AssemblyWriter W(OS, SlotTable, getModuleFromVal(I), nullptr, IsForDebug);\n    W.printInstruction(*I);\n  } else if (const BasicBlock *BB = dyn_cast<BasicBlock>(this)) {\n    incorporateFunction(BB->getParent());\n    AssemblyWriter W(OS, SlotTable, getModuleFromVal(BB), nullptr, IsForDebug);\n    W.printBasicBlock(BB);\n  } else if (const GlobalValue *GV = dyn_cast<GlobalValue>(this)) {\n    AssemblyWriter W(OS, SlotTable, GV->getParent(), nullptr, IsForDebug);\n    if (const GlobalVariable *V = dyn_cast<GlobalVariable>(GV))\n      W.printGlobal(V);\n    else if (const Function *F = dyn_cast<Function>(GV))\n      W.printFunction(F);\n    else\n      W.printIndirectSymbol(cast<GlobalIndirectSymbol>(GV));\n  } else if (const MetadataAsValue *V = dyn_cast<MetadataAsValue>(this)) {\n    V->getMetadata()->print(ROS, MST, getModuleFromVal(V));\n  } else if (const Constant *C = dyn_cast<Constant>(this)) {\n    TypePrinting TypePrinter;\n    TypePrinter.print(C->getType(), OS);\n    OS << ' ';\n    WriteConstantInternal(OS, C, TypePrinter, MST.getMachine(), nullptr);\n  } else if (isa<InlineAsm>(this) || isa<Argument>(this)) {\n    this->printAsOperand(OS, /* PrintType */ true, MST);\n  } else {\n    llvm_unreachable(\"Unknown value to print out!\");\n  }\n}\n\n/// Print without a type, skipping the TypePrinting object.\n///\n/// \\return \\c true iff printing was successful.\nstatic bool printWithoutType(const Value &V, raw_ostream &O,\n                             SlotTracker *Machine, const Module *M) {\n  if (V.hasName() || isa<GlobalValue>(V) ||\n      (!isa<Constant>(V) && !isa<MetadataAsValue>(V))) {\n    WriteAsOperandInternal(O, &V, nullptr, Machine, M);\n    return true;\n  }\n  return false;\n}\n\nstatic void printAsOperandImpl(const Value &V, raw_ostream &O, bool PrintType,\n                               ModuleSlotTracker &MST) {\n  TypePrinting TypePrinter(MST.getModule());\n  if (PrintType) {\n    TypePrinter.print(V.getType(), O);\n    O << ' ';\n  }\n\n  WriteAsOperandInternal(O, &V, &TypePrinter, MST.getMachine(),\n                         MST.getModule());\n}\n\nvoid Value::printAsOperand(raw_ostream &O, bool PrintType,\n                           const Module *M) const {\n  if (!M)\n    M = getModuleFromVal(this);\n\n  if (!PrintType)\n    if (printWithoutType(*this, O, nullptr, M))\n      return;\n\n  SlotTracker Machine(\n      M, /* ShouldInitializeAllMetadata */ isa<MetadataAsValue>(this));\n  ModuleSlotTracker MST(Machine, M);\n  printAsOperandImpl(*this, O, PrintType, MST);\n}\n\nvoid Value::printAsOperand(raw_ostream &O, bool PrintType,\n                           ModuleSlotTracker &MST) const {\n  if (!PrintType)\n    if (printWithoutType(*this, O, MST.getMachine(), MST.getModule()))\n      return;\n\n  printAsOperandImpl(*this, O, PrintType, MST);\n}\n\nstatic void printMetadataImpl(raw_ostream &ROS, const Metadata &MD,\n                              ModuleSlotTracker &MST, const Module *M,\n                              bool OnlyAsOperand) {\n  formatted_raw_ostream OS(ROS);\n\n  TypePrinting TypePrinter(M);\n\n  WriteAsOperandInternal(OS, &MD, &TypePrinter, MST.getMachine(), M,\n                         /* FromValue */ true);\n\n  auto *N = dyn_cast<MDNode>(&MD);\n  if (OnlyAsOperand || !N || isa<DIExpression>(MD))\n    return;\n\n  OS << \" = \";\n  WriteMDNodeBodyInternal(OS, N, &TypePrinter, MST.getMachine(), M);\n}\n\nvoid Metadata::printAsOperand(raw_ostream &OS, const Module *M) const {\n  ModuleSlotTracker MST(M, isa<MDNode>(this));\n  printMetadataImpl(OS, *this, MST, M, /* OnlyAsOperand */ true);\n}\n\nvoid Metadata::printAsOperand(raw_ostream &OS, ModuleSlotTracker &MST,\n                              const Module *M) const {\n  printMetadataImpl(OS, *this, MST, M, /* OnlyAsOperand */ true);\n}\n\nvoid Metadata::print(raw_ostream &OS, const Module *M,\n                     bool /*IsForDebug*/) const {\n  ModuleSlotTracker MST(M, isa<MDNode>(this));\n  printMetadataImpl(OS, *this, MST, M, /* OnlyAsOperand */ false);\n}\n\nvoid Metadata::print(raw_ostream &OS, ModuleSlotTracker &MST,\n                     const Module *M, bool /*IsForDebug*/) const {\n  printMetadataImpl(OS, *this, MST, M, /* OnlyAsOperand */ false);\n}\n\nvoid ModuleSummaryIndex::print(raw_ostream &ROS, bool IsForDebug) const {\n  SlotTracker SlotTable(this);\n  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, SlotTable, this, IsForDebug);\n  W.printModuleSummaryIndex();\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n// Value::dump - allow easy printing of Values from the debugger.\nLLVM_DUMP_METHOD\nvoid Value::dump() const { print(dbgs(), /*IsForDebug=*/true); dbgs() << '\\n'; }\n\n// Type::dump - allow easy printing of Types from the debugger.\nLLVM_DUMP_METHOD\nvoid Type::dump() const { print(dbgs(), /*IsForDebug=*/true); dbgs() << '\\n'; }\n\n// Module::dump() - Allow printing of Modules from the debugger.\nLLVM_DUMP_METHOD\nvoid Module::dump() const {\n  print(dbgs(), nullptr,\n        /*ShouldPreserveUseListOrder=*/false, /*IsForDebug=*/true);\n}\n\n// Allow printing of Comdats from the debugger.\nLLVM_DUMP_METHOD\nvoid Comdat::dump() const { print(dbgs(), /*IsForDebug=*/true); }\n\n// NamedMDNode::dump() - Allow printing of NamedMDNodes from the debugger.\nLLVM_DUMP_METHOD\nvoid NamedMDNode::dump() const { print(dbgs(), /*IsForDebug=*/true); }\n\nLLVM_DUMP_METHOD\nvoid Metadata::dump() const { dump(nullptr); }\n\nLLVM_DUMP_METHOD\nvoid Metadata::dump(const Module *M) const {\n  print(dbgs(), M, /*IsForDebug=*/true);\n  dbgs() << '\\n';\n}\n\n// Allow printing of ModuleSummaryIndex from the debugger.\nLLVM_DUMP_METHOD\nvoid ModuleSummaryIndex::dump() const { print(dbgs(), /*IsForDebug=*/true); }\n#endif\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "content": "//===- llvm/Value.h - Definition of the Value class -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Value class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUE_H\n#define LLVM_IR_VALUE_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <iterator>\n#include <memory>\n\nnamespace llvm {\n\nclass APInt;\nclass Argument;\nclass BasicBlock;\nclass Constant;\nclass ConstantData;\nclass ConstantAggregate;\nclass DataLayout;\nclass Function;\nclass GlobalAlias;\nclass GlobalIFunc;\nclass GlobalIndirectSymbol;\nclass GlobalObject;\nclass GlobalValue;\nclass GlobalVariable;\nclass InlineAsm;\nclass Instruction;\nclass LLVMContext;\nclass MDNode;\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\ntemplate<typename ValueTy> class StringMapEntry;\nclass Twine;\nclass Type;\nclass User;\n\nusing ValueName = StringMapEntry<Value *>;\n\n//===----------------------------------------------------------------------===//\n//                                 Value Class\n//===----------------------------------------------------------------------===//\n\n/// LLVM Value Representation\n///\n/// This is a very important LLVM class. It is the base class of all values\n/// computed by a program that may be used as operands to other values. Value is\n/// the super class of other important classes such as Instruction and Function.\n/// All Values have a Type. Type is not a subclass of Value. Some values can\n/// have a name and they belong to some Module.  Setting the name on the Value\n/// automatically updates the module's symbol table.\n///\n/// Every value has a \"use list\" that keeps track of which other Values are\n/// using this Value.  A Value can also have an arbitrary number of ValueHandle\n/// objects that watch it and listen to RAUW and Destroy events.  See\n/// llvm/IR/ValueHandle.h for details.\nclass Value {\n  Type *VTy;\n  Use *UseList;\n\n  friend class ValueAsMetadata; // Allow access to IsUsedByMD.\n  friend class ValueHandleBase;\n\n  const unsigned char SubclassID;   // Subclass identifier (for isa/dyn_cast)\n  unsigned char HasValueHandle : 1; // Has a ValueHandle pointing to this?\n\nprotected:\n  /// Hold subclass data that can be dropped.\n  ///\n  /// This member is similar to SubclassData, however it is for holding\n  /// information which may be used to aid optimization, but which may be\n  /// cleared to zero without affecting conservative interpretation.\n  unsigned char SubclassOptionalData : 7;\n\nprivate:\n  /// Hold arbitrary subclass data.\n  ///\n  /// This member is defined by this class, but is not used for anything.\n  /// Subclasses can use it to hold whatever state they find useful.  This\n  /// field is initialized to zero by the ctor.\n  unsigned short SubclassData;\n\nprotected:\n  /// The number of operands in the subclass.\n  ///\n  /// This member is defined by this class, but not used for anything.\n  /// Subclasses can use it to store their number of operands, if they have\n  /// any.\n  ///\n  /// This is stored here to save space in User on 64-bit hosts.  Since most\n  /// instances of Value have operands, 32-bit hosts aren't significantly\n  /// affected.\n  ///\n  /// Note, this should *NOT* be used directly by any class other than User.\n  /// User uses this value to find the Use list.\n  enum : unsigned { NumUserOperandsBits = 27 };\n  unsigned NumUserOperands : NumUserOperandsBits;\n\n  // Use the same type as the bitfield above so that MSVC will pack them.\n  unsigned IsUsedByMD : 1;\n  unsigned HasName : 1;\n  unsigned HasMetadata : 1; // Has metadata attached to this?\n  unsigned HasHungOffUses : 1;\n  unsigned HasDescriptor : 1;\n\nprivate:\n  template <typename UseT> // UseT == 'Use' or 'const Use'\n  class use_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UseT *> {\n    friend class Value;\n\n    UseT *U;\n\n    explicit use_iterator_impl(UseT *u) : U(u) {}\n\n  public:\n    use_iterator_impl() : U() {}\n\n    bool operator==(const use_iterator_impl &x) const { return U == x.U; }\n    bool operator!=(const use_iterator_impl &x) const { return !operator==(x); }\n\n    use_iterator_impl &operator++() { // Preincrement\n      assert(U && \"Cannot increment end iterator!\");\n      U = U->getNext();\n      return *this;\n    }\n\n    use_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    UseT &operator*() const {\n      assert(U && \"Cannot dereference end iterator!\");\n      return *U;\n    }\n\n    UseT *operator->() const { return &operator*(); }\n\n    operator use_iterator_impl<const UseT>() const {\n      return use_iterator_impl<const UseT>(U);\n    }\n  };\n\n  template <typename UserTy> // UserTy == 'User' or 'const User'\n  class user_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UserTy *> {\n    use_iterator_impl<Use> UI;\n    explicit user_iterator_impl(Use *U) : UI(U) {}\n    friend class Value;\n\n  public:\n    user_iterator_impl() = default;\n\n    bool operator==(const user_iterator_impl &x) const { return UI == x.UI; }\n    bool operator!=(const user_iterator_impl &x) const { return !operator==(x); }\n\n    /// Returns true if this iterator is equal to user_end() on the value.\n    bool atEnd() const { return *this == user_iterator_impl(); }\n\n    user_iterator_impl &operator++() { // Preincrement\n      ++UI;\n      return *this;\n    }\n\n    user_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Retrieve a pointer to the current User.\n    UserTy *operator*() const {\n      return UI->getUser();\n    }\n\n    UserTy *operator->() const { return operator*(); }\n\n    operator user_iterator_impl<const UserTy>() const {\n      return user_iterator_impl<const UserTy>(*UI);\n    }\n\n    Use &getUse() const { return *UI; }\n  };\n\nprotected:\n  Value(Type *Ty, unsigned scid);\n\n  /// Value's destructor should be virtual by design, but that would require\n  /// that Value and all of its subclasses have a vtable that effectively\n  /// duplicates the information in the value ID. As a size optimization, the\n  /// destructor has been protected, and the caller should manually call\n  /// deleteValue.\n  ~Value(); // Use deleteValue() to delete a generic Value.\n\npublic:\n  Value(const Value &) = delete;\n  Value &operator=(const Value &) = delete;\n\n  /// Delete a pointer to a generic Value.\n  void deleteValue();\n\n  /// Support for debugging, callable in GDB: V->dump()\n  void dump() const;\n\n  /// Implement operator<< on Value.\n  /// @{\n  void print(raw_ostream &O, bool IsForDebug = false) const;\n  void print(raw_ostream &O, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print the name of this Value out to the specified raw_ostream.\n  ///\n  /// This is useful when you just want to print 'int %reg126', not the\n  /// instruction that generated it. If you specify a Module for context, then\n  /// even constanst get pretty-printed; for example, the type of a null\n  /// pointer is printed symbolically.\n  /// @{\n  void printAsOperand(raw_ostream &O, bool PrintType = true,\n                      const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &O, bool PrintType,\n                      ModuleSlotTracker &MST) const;\n  /// @}\n\n  /// All values are typed, get the type of this value.\n  Type *getType() const { return VTy; }\n\n  /// All values hold a context through their type.\n  LLVMContext &getContext() const;\n\n  // All values can potentially be named.\n  bool hasName() const { return HasName; }\n  ValueName *getValueName() const;\n  void setValueName(ValueName *VN);\n\nprivate:\n  void destroyValueName();\n  enum class ReplaceMetadataUses { No, Yes };\n  void doRAUW(Value *New, ReplaceMetadataUses);\n  void setNameImpl(const Twine &Name);\n\npublic:\n  /// Return a constant reference to the value's name.\n  ///\n  /// This guaranteed to return the same reference as long as the value is not\n  /// modified.  If the value has a name, this does a hashtable lookup, so it's\n  /// not free.\n  StringRef getName() const;\n\n  /// Change the name of the value.\n  ///\n  /// Choose a new unique name if the provided name is taken.\n  ///\n  /// \\param Name The new name; or \"\" if the value's name should be removed.\n  void setName(const Twine &Name);\n\n  /// Transfer the name from V to this value.\n  ///\n  /// After taking V's name, sets V's name to empty.\n  ///\n  /// \\note It is an error to call V->takeName(V).\n  void takeName(Value *V);\n\n#ifndef NDEBUG\n  std::string getNameOrAsOperand() const;\n#endif\n\n  /// Change all uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\".  After this completes, 'this's use list is\n  /// guaranteed to be empty.\n  void replaceAllUsesWith(Value *V);\n\n  /// Change non-metadata uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\". This function skips metadata entries in the list.\n  void replaceNonMetadataUsesWith(Value *V);\n\n  /// Go through the uses list for this definition and make each use point\n  /// to \"V\" if the callback ShouldReplace returns true for the given Use.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesWithIf(Value *New,\n                         llvm::function_ref<bool(Use &U)> ShouldReplace) {\n    assert(New && \"Value::replaceUsesWithIf(<null>) is invalid!\");\n    assert(New->getType() == getType() &&\n           \"replaceUses of value with new value of different type!\");\n\n    for (use_iterator UI = use_begin(), E = use_end(); UI != E;) {\n      Use &U = *UI;\n      ++UI;\n      if (!ShouldReplace(U))\n        continue;\n      U.set(New);\n    }\n  }\n\n  /// replaceUsesOutsideBlock - Go through the uses list for this definition and\n  /// make each use point to \"V\" instead of \"this\" when the use is outside the\n  /// block. 'This's use list is expected to have at least one element.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesOutsideBlock(Value *V, BasicBlock *BB);\n\n  //----------------------------------------------------------------------\n  // Methods for handling the chain of uses of this Value.\n  //\n  // Materializing a function can introduce new uses, so these methods come in\n  // two variants:\n  // The methods that start with materialized_ check the uses that are\n  // currently known given which functions are materialized. Be very careful\n  // when using them since you might not get all uses.\n  // The methods that don't start with materialized_ assert that modules is\n  // fully materialized.\n  void assertModuleIsMaterializedImpl() const;\n  // This indirection exists so we can keep assertModuleIsMaterializedImpl()\n  // around in release builds of Value.cpp to be linked with other code built\n  // in debug mode. But this avoids calling it in any of the release built code.\n  void assertModuleIsMaterialized() const {\n#ifndef NDEBUG\n    assertModuleIsMaterializedImpl();\n#endif\n  }\n\n  bool use_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  bool materialized_use_empty() const {\n    return UseList == nullptr;\n  }\n\n  using use_iterator = use_iterator_impl<Use>;\n  using const_use_iterator = use_iterator_impl<const Use>;\n\n  use_iterator materialized_use_begin() { return use_iterator(UseList); }\n  const_use_iterator materialized_use_begin() const {\n    return const_use_iterator(UseList);\n  }\n  use_iterator use_begin() {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  const_use_iterator use_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  use_iterator use_end() { return use_iterator(); }\n  const_use_iterator use_end() const { return const_use_iterator(); }\n  iterator_range<use_iterator> materialized_uses() {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<const_use_iterator> materialized_uses() const {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<use_iterator> uses() {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n  iterator_range<const_use_iterator> uses() const {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n\n  bool user_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  using user_iterator = user_iterator_impl<User>;\n  using const_user_iterator = user_iterator_impl<const User>;\n\n  user_iterator materialized_user_begin() { return user_iterator(UseList); }\n  const_user_iterator materialized_user_begin() const {\n    return const_user_iterator(UseList);\n  }\n  user_iterator user_begin() {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  const_user_iterator user_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  user_iterator user_end() { return user_iterator(); }\n  const_user_iterator user_end() const { return const_user_iterator(); }\n  User *user_back() {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  const User *user_back() const {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  iterator_range<user_iterator> materialized_users() {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<const_user_iterator> materialized_users() const {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<user_iterator> users() {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n  iterator_range<const_user_iterator> users() const {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n\n  /// Return true if there is exactly one use of this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasOneUse() const { return hasSingleElement(uses()); }\n\n  /// Return true if this Value has exactly N uses.\n  bool hasNUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUsesOrMore(unsigned N) const;\n\n  /// Return true if there is exactly one user of this value.\n  ///\n  /// Note that this is not the same as \"has one use\". If a value has one use,\n  /// then there certainly is a single user. But if value has several uses,\n  /// it is possible that all uses are in a single user, or not.\n  ///\n  /// This check is potentially costly, since it requires traversing,\n  /// in the worst case, the whole use list of a value.\n  bool hasOneUser() const;\n\n  /// Return true if there is exactly one use of this value that cannot be\n  /// dropped.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  Use *getSingleUndroppableUse();\n\n  /// Return true if there this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasNUndroppableUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUndroppableUsesOrMore(unsigned N) const;\n\n  /// Remove every uses that can safely be removed.\n  ///\n  /// This will remove for example uses in llvm.assume.\n  /// This should be used when performing want to perform a tranformation but\n  /// some Droppable uses pervent it.\n  /// This function optionally takes a filter to only remove some droppable\n  /// uses.\n  void dropDroppableUses(llvm::function_ref<bool(const Use *)> ShouldDrop =\n                             [](const Use *) { return true; });\n\n  /// Remove every use of this value in \\p User that can safely be removed.\n  void dropDroppableUsesIn(User &Usr);\n\n  /// Remove the droppable use \\p U.\n  static void dropDroppableUse(Use &U);\n\n  /// Check if this value is used in the specified basic block.\n  bool isUsedInBasicBlock(const BasicBlock *BB) const;\n\n  /// This method computes the number of uses of this Value.\n  ///\n  /// This is a linear time operation.  Use hasOneUse, hasNUses, or\n  /// hasNUsesOrMore to check for specific values.\n  unsigned getNumUses() const;\n\n  /// This method should only be used by the Use class.\n  void addUse(Use &U) { U.addToList(&UseList); }\n\n  /// Concrete subclass of this.\n  ///\n  /// An enumeration for keeping track of the concrete subclass of Value that\n  /// is actually instantiated. Values of this enumeration are kept in the\n  /// Value classes SubclassID field. They are used for concrete type\n  /// identification.\n  enum ValueTy {\n#define HANDLE_VALUE(Name) Name##Val,\n#include \"llvm/IR/Value.def\"\n\n    // Markers:\n#define HANDLE_CONSTANT_MARKER(Marker, Constant) Marker = Constant##Val,\n#include \"llvm/IR/Value.def\"\n  };\n\n  /// Return an ID for the concrete type of this object.\n  ///\n  /// This is used to implement the classof checks.  This should not be used\n  /// for any other purpose, as the values may change as LLVM evolves.  Also,\n  /// note that for instructions, the Instruction's opcode is added to\n  /// InstructionVal. So this means three things:\n  /// # there is no value with code InstructionVal (no opcode==0).\n  /// # there are more possible values for the value type than in ValueTy enum.\n  /// # the InstructionVal enumerator must be the highest valued enumerator in\n  ///   the ValueTy enum.\n  unsigned getValueID() const {\n    return SubclassID;\n  }\n\n  /// Return the raw optional flags value contained in this value.\n  ///\n  /// This should only be used when testing two Values for equivalence.\n  unsigned getRawSubclassOptionalData() const {\n    return SubclassOptionalData;\n  }\n\n  /// Clear the optional flags contained in this value.\n  void clearSubclassOptionalData() {\n    SubclassOptionalData = 0;\n  }\n\n  /// Check the optional flags for equality.\n  bool hasSameSubclassOptionalData(const Value *V) const {\n    return SubclassOptionalData == V->SubclassOptionalData;\n  }\n\n  /// Return true if there is a value handle associated with this value.\n  bool hasValueHandle() const { return HasValueHandle; }\n\n  /// Return true if there is metadata referencing this value.\n  bool isUsedByMetadata() const { return IsUsedByMD; }\n\nprotected:\n  /// Get the current metadata attachments for the given kind, if any.\n  ///\n  /// These functions require that the value have at most a single attachment\n  /// of the given kind, and return \\c nullptr if such an attachment is missing.\n  /// @{\n  MDNode *getMetadata(unsigned KindID) const;\n  MDNode *getMetadata(StringRef Kind) const;\n  /// @}\n\n  /// Appends all attachments with the given ID to \\c MDs in insertion order.\n  /// If the Value has no attachments with the given ID, or if ID is invalid,\n  /// leaves MDs unchanged.\n  /// @{\n  void getMetadata(unsigned KindID, SmallVectorImpl<MDNode *> &MDs) const;\n  void getMetadata(StringRef Kind, SmallVectorImpl<MDNode *> &MDs) const;\n  /// @}\n\n  /// Appends all metadata attached to this value to \\c MDs, sorting by\n  /// KindID. The first element of each pair returned is the KindID, the second\n  /// element is the metadata value. Attachments with the same ID appear in\n  /// insertion order.\n  void\n  getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const;\n\n  /// Return true if this value has any metadata attached to it.\n  bool hasMetadata() const { return (bool)HasMetadata; }\n\n  /// Return true if this value has the given type of metadata attached.\n  /// @{\n  bool hasMetadata(unsigned KindID) const {\n    return getMetadata(KindID) != nullptr;\n  }\n  bool hasMetadata(StringRef Kind) const {\n    return getMetadata(Kind) != nullptr;\n  }\n  /// @}\n\n  /// Set a particular kind of metadata attachment.\n  ///\n  /// Sets the given attachment to \\c MD, erasing it if \\c MD is \\c nullptr or\n  /// replacing it if it already exists.\n  /// @{\n  void setMetadata(unsigned KindID, MDNode *Node);\n  void setMetadata(StringRef Kind, MDNode *Node);\n  /// @}\n\n  /// Add a metadata attachment.\n  /// @{\n  void addMetadata(unsigned KindID, MDNode &MD);\n  void addMetadata(StringRef Kind, MDNode &MD);\n  /// @}\n\n  /// Erase all metadata attachments with the given kind.\n  ///\n  /// \\returns true if any metadata was removed.\n  bool eraseMetadata(unsigned KindID);\n\n  /// Erase all metadata attached to this Value.\n  void clearMetadata();\n\npublic:\n  /// Return true if this value is a swifterror value.\n  ///\n  /// swifterror values can be either a function argument or an alloca with a\n  /// swifterror attribute.\n  bool isSwiftError() const;\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCasts() const;\n  Value *stripPointerCasts() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCasts());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, address space casts, and aliases.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCastsAndAliases() const;\n  Value *stripPointerCastsAndAliases() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCastsAndAliases());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts\n  /// but ensures the representation of the result stays the same.\n  ///\n  /// Returns the original uncasted value with the same representation. If this\n  /// is called on a non-pointer value, it returns 'this'.\n  const Value *stripPointerCastsSameRepresentation() const;\n  Value *stripPointerCastsSameRepresentation() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsSameRepresentation());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs and invariant group info.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'. This function should be used only in\n  /// Alias analysis.\n  const Value *stripPointerCastsAndInvariantGroups() const;\n  Value *stripPointerCastsAndInvariantGroups() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsAndInvariantGroups());\n  }\n\n  /// Strip off pointer casts and all-constant inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsConstantOffsets() const;\n  Value *stripInBoundsConstantOffsets() {\n    return const_cast<Value *>(\n              static_cast<const Value *>(this)->stripInBoundsConstantOffsets());\n  }\n\n  /// Accumulate the constant offset this value has compared to a base pointer.\n  /// Only 'getelementptr' instructions (GEPs) are accumulated but other\n  /// instructions, e.g., casts, are stripped away as well.\n  /// The accumulated constant offset is added to \\p Offset and the base\n  /// pointer is returned.\n  ///\n  /// The APInt \\p Offset has to have a bit-width equal to the IntPtr type for\n  /// the address space of 'this' pointer value, e.g., use\n  /// DataLayout::getIndexTypeSizeInBits(Ty).\n  ///\n  /// If \\p AllowNonInbounds is true, offsets in GEPs are stripped and\n  /// accumulated even if the GEP is not \"inbounds\".\n  ///\n  /// If \\p ExternalAnalysis is provided it will be used to calculate a offset\n  /// when a operand of GEP is not constant.\n  /// For example, for a value \\p ExternalAnalysis might try to calculate a\n  /// lower bound. If \\p ExternalAnalysis is successful, it should return true.\n  ///\n  /// If this is called on a non-pointer value, it returns 'this' and the\n  /// \\p Offset is not modified.\n  ///\n  /// Note that this function will never return a nullptr. It will also never\n  /// manipulate the \\p Offset in a way that would not match the difference\n  /// between the underlying value and the returned one. Thus, if no constant\n  /// offset was found, the returned value is the underlying one and \\p Offset\n  /// is unchanged.\n  const Value *stripAndAccumulateConstantOffsets(\n      const DataLayout &DL, APInt &Offset, bool AllowNonInbounds,\n      function_ref<bool(Value &Value, APInt &Offset)> ExternalAnalysis =\n          nullptr) const;\n  Value *stripAndAccumulateConstantOffsets(const DataLayout &DL, APInt &Offset,\n                                           bool AllowNonInbounds) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripAndAccumulateConstantOffsets(\n            DL, Offset, AllowNonInbounds));\n  }\n\n  /// This is a wrapper around stripAndAccumulateConstantOffsets with the\n  /// in-bounds requirement set to false.\n  const Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                         APInt &Offset) const {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n  Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                   APInt &Offset) {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n\n  /// Strip off pointer casts and inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                        [](const Value *) {}) const;\n  inline Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                  [](const Value *) {}) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripInBoundsOffsets(Func));\n  }\n\n  /// Returns the number of bytes known to be dereferenceable for the\n  /// pointer value.\n  ///\n  /// If CanBeNull is set by this function the pointer can either be null or be\n  /// dereferenceable up to the returned number of bytes.\n  uint64_t getPointerDereferenceableBytes(const DataLayout &DL,\n                                          bool &CanBeNull) const;\n\n  /// Returns an alignment of the pointer value.\n  ///\n  /// Returns an alignment which is either specified explicitly, e.g. via\n  /// align attribute of a function argument, or guaranteed by DataLayout.\n  Align getPointerAlignment(const DataLayout &DL) const;\n\n  /// Translate PHI node to its predecessor from the given basic block.\n  ///\n  /// If this value is a PHI node with CurBB as its parent, return the value in\n  /// the PHI node corresponding to PredBB.  If not, return ourself.  This is\n  /// useful if you want to know the value something has in a predecessor\n  /// block.\n  const Value *DoPHITranslation(const BasicBlock *CurBB,\n                                const BasicBlock *PredBB) const;\n  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB) {\n    return const_cast<Value *>(\n             static_cast<const Value *>(this)->DoPHITranslation(CurBB, PredBB));\n  }\n\n  /// The maximum alignment for instructions.\n  ///\n  /// This is the greatest alignment value supported by load, store, and alloca\n  /// instructions, and global values.\n  static const unsigned MaxAlignmentExponent = 29;\n  static const unsigned MaximumAlignment = 1u << MaxAlignmentExponent;\n\n  /// Mutate the type of this Value to be of the specified type.\n  ///\n  /// Note that this is an extremely dangerous operation which can create\n  /// completely invalid IR very easily.  It is strongly recommended that you\n  /// recreate IR objects with the right types instead of mutating them in\n  /// place.\n  void mutateType(Type *Ty) {\n    VTy = Ty;\n  }\n\n  /// Sort the use-list.\n  ///\n  /// Sorts the Value's use-list by Cmp using a stable mergesort.  Cmp is\n  /// expected to compare two \\a Use references.\n  template <class Compare> void sortUseList(Compare Cmp);\n\n  /// Reverse the use-list.\n  void reverseUseList();\n\nprivate:\n  /// Merge two lists together.\n  ///\n  /// Merges \\c L and \\c R using \\c Cmp.  To enable stable sorts, always pushes\n  /// \"equal\" items from L before items from R.\n  ///\n  /// \\return the first element in the list.\n  ///\n  /// \\note Completely ignores \\a Use::Prev (doesn't read, doesn't update).\n  template <class Compare>\n  static Use *mergeUseLists(Use *L, Use *R, Compare Cmp) {\n    Use *Merged;\n    Use **Next = &Merged;\n\n    while (true) {\n      if (!L) {\n        *Next = R;\n        break;\n      }\n      if (!R) {\n        *Next = L;\n        break;\n      }\n      if (Cmp(*R, *L)) {\n        *Next = R;\n        Next = &R->Next;\n        R = R->Next;\n      } else {\n        *Next = L;\n        Next = &L->Next;\n        L = L->Next;\n      }\n    }\n\n    return Merged;\n  }\n\nprotected:\n  unsigned short getSubclassDataFromValue() const { return SubclassData; }\n  void setValueSubclassData(unsigned short D) { SubclassData = D; }\n};\n\nstruct ValueDeleter { void operator()(Value *V) { V->deleteValue(); } };\n\n/// Use this instead of std::unique_ptr<Value> or std::unique_ptr<Instruction>.\n/// Those don't work because Value and Instruction's destructors are protected,\n/// aren't virtual, and won't destroy the complete object.\nusing unique_value = std::unique_ptr<Value, ValueDeleter>;\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {\n  V.print(OS);\n  return OS;\n}\n\nvoid Use::set(Value *V) {\n  if (Val) removeFromList();\n  Val = V;\n  if (V) V->addUse(*this);\n}\n\nValue *Use::operator=(Value *RHS) {\n  set(RHS);\n  return RHS;\n}\n\nconst Use &Use::operator=(const Use &RHS) {\n  set(RHS.Val);\n  return *this;\n}\n\ntemplate <class Compare> void Value::sortUseList(Compare Cmp) {\n  if (!UseList || !UseList->Next)\n    // No need to sort 0 or 1 uses.\n    return;\n\n  // Note: this function completely ignores Prev pointers until the end when\n  // they're fixed en masse.\n\n  // Create a binomial vector of sorted lists, visiting uses one at a time and\n  // merging lists as necessary.\n  const unsigned MaxSlots = 32;\n  Use *Slots[MaxSlots];\n\n  // Collect the first use, turning it into a single-item list.\n  Use *Next = UseList->Next;\n  UseList->Next = nullptr;\n  unsigned NumSlots = 1;\n  Slots[0] = UseList;\n\n  // Collect all but the last use.\n  while (Next->Next) {\n    Use *Current = Next;\n    Next = Current->Next;\n\n    // Turn Current into a single-item list.\n    Current->Next = nullptr;\n\n    // Save Current in the first available slot, merging on collisions.\n    unsigned I;\n    for (I = 0; I < NumSlots; ++I) {\n      if (!Slots[I])\n        break;\n\n      // Merge two lists, doubling the size of Current and emptying slot I.\n      //\n      // Since the uses in Slots[I] originally preceded those in Current, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      Current = mergeUseLists(Slots[I], Current, Cmp);\n      Slots[I] = nullptr;\n    }\n    // Check if this is a new slot.\n    if (I == NumSlots) {\n      ++NumSlots;\n      assert(NumSlots <= MaxSlots && \"Use list bigger than 2^32\");\n    }\n\n    // Found an open slot.\n    Slots[I] = Current;\n  }\n\n  // Merge all the lists together.\n  assert(Next && \"Expected one more Use\");\n  assert(!Next->Next && \"Expected only one Use\");\n  UseList = Next;\n  for (unsigned I = 0; I < NumSlots; ++I)\n    if (Slots[I])\n      // Since the uses in Slots[I] originally preceded those in UseList, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      UseList = mergeUseLists(Slots[I], UseList, Cmp);\n\n  // Fix the Prev pointers.\n  for (Use *I = UseList, **Prev = &UseList; I; I = I->Next) {\n    I->Prev = Prev;\n    Prev = &I->Next;\n  }\n}\n\n// isa - Provide some specializations of isa so that we don't have to include\n// the subtype header files to test to see if the value is a subclass...\n//\ntemplate <> struct isa_impl<Constant, Value> {\n  static inline bool doit(const Value &Val) {\n    static_assert(Value::ConstantFirstVal == 0, \"Val.getValueID() >= Value::ConstantFirstVal\");\n    return Val.getValueID() <= Value::ConstantLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantData, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantDataFirstVal &&\n           Val.getValueID() <= Value::ConstantDataLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantAggregate, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantAggregateFirstVal &&\n           Val.getValueID() <= Value::ConstantAggregateLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<Argument, Value> {\n  static inline bool doit (const Value &Val) {\n    return Val.getValueID() == Value::ArgumentVal;\n  }\n};\n\ntemplate <> struct isa_impl<InlineAsm, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::InlineAsmVal;\n  }\n};\n\ntemplate <> struct isa_impl<Instruction, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::InstructionVal;\n  }\n};\n\ntemplate <> struct isa_impl<BasicBlock, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::BasicBlockVal;\n  }\n};\n\ntemplate <> struct isa_impl<Function, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::FunctionVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalVariable, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalVariableVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalAlias, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalAliasVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIFunc, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalIFuncVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIndirectSymbol, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalAlias>(Val) || isa<GlobalIFunc>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalValue, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalObject>(Val) || isa<GlobalIndirectSymbol>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalObject, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalVariable>(Val) || isa<Function>(Val);\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Value, LLVMValueRef)\n\n// Specialized opaque value conversions.\ninline Value **unwrap(LLVMValueRef *Vals) {\n  return reinterpret_cast<Value**>(Vals);\n}\n\ntemplate<typename T>\ninline T **unwrap(LLVMValueRef *Vals, unsigned Length) {\n#ifndef NDEBUG\n  for (LLVMValueRef *I = Vals, *E = Vals + Length; I != E; ++I)\n    unwrap<T>(*I); // For side effect of calling assert on invalid usage.\n#endif\n  (void)Length;\n  return reinterpret_cast<T**>(Vals);\n}\n\ninline LLVMValueRef *wrap(const Value **Vals) {\n  return reinterpret_cast<LLVMValueRef*>(const_cast<Value**>(Vals));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUE_H\n"}}, "reports": [{"events": [{"location": {"col": 13, "file": 3, "line": 4590}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 2, "line": 227}, "message": "differing parameters are named here: ('O'), in definition: ('ROS')"}, {"location": {"col": 8, "file": 2, "line": 227}, "message": "function 'llvm::Value::print' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "fee85d78c803d450e56f7e10325fd5dc", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 3, "line": 4601}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 2, "line": 228}, "message": "differing parameters are named here: ('O'), in definition: ('ROS')"}, {"location": {"col": 8, "file": 2, "line": 228}, "message": "function 'llvm::Value::print' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "5bea0b00ebfbe7178b3d7152d236399e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 3, "line": 1724}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 1684}, "message": "differing parameters are named here: ('N'), in definition: ('Checksum')"}, {"location": {"col": 8, "file": 3, "line": 1684}, "message": "function '(anonymous namespace)::MDFieldPrinter::printChecksum' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/IR/AsmWriter.cpp", "reportHash": "b34beb7853ff77921d3f24a157c05ec1", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 3, "line": 4385}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 2572}, "message": "differing parameters are named here: ('MD'), in definition: ('Node')"}, {"location": {"col": 8, "file": 3, "line": 2572}, "message": "function '(anonymous namespace)::AssemblyWriter::printMDNodeBody' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/IR/AsmWriter.cpp", "reportHash": "1cc55d3ceaa1b1bd00101fd2049c5ec2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 3, "line": 3803}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 2601}, "message": "differing parameters are named here: ('FA'), in definition: ('Arg')"}, {"location": {"col": 8, "file": 3, "line": 2601}, "message": "function '(anonymous namespace)::AssemblyWriter::printArgument' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/IR/AsmWriter.cpp", "reportHash": "246cfa51482017e4030a6cca82ba0431", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
