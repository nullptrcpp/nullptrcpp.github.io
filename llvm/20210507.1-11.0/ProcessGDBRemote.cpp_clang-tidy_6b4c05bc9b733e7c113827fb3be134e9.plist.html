<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Process/Utility/GDBRemoteSignals.h", "content": "//===-- GDBRemoteSignals.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_PROCESS_UTILITY_GDBREMOTESIGNALS_H\n#define LLDB_SOURCE_PLUGINS_PROCESS_UTILITY_GDBREMOTESIGNALS_H\n\n#include \"lldb/Target/UnixSignals.h\"\n\nnamespace lldb_private {\n\n/// Empty set of Unix signals to be filled by PlatformRemoteGDBServer\nclass GDBRemoteSignals : public UnixSignals {\npublic:\n  GDBRemoteSignals();\n\n  GDBRemoteSignals(const lldb::UnixSignalsSP &rhs);\n\nprivate:\n  void Reset() override;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_PROCESS_UTILITY_GDBREMOTESIGNALS_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Process/Utility/InferiorCallPOSIX.h", "content": "//===-- InferiorCallPOSIX.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_PROCESS_UTILITY_INFERIORCALLPOSIX_H\n#define LLDB_SOURCE_PLUGINS_PROCESS_UTILITY_INFERIORCALLPOSIX_H\n\n// Inferior execution of POSIX functions.\n\n#include \"lldb/lldb-types.h\"\n\nnamespace lldb_private {\n\nclass Process;\n\nenum MmapProt {\n  eMmapProtNone = 0,\n  eMmapProtExec = 1,\n  eMmapProtRead = 2,\n  eMmapProtWrite = 4\n};\n\nbool InferiorCallMmap(Process *proc, lldb::addr_t &allocated_addr,\n                      lldb::addr_t addr, lldb::addr_t length, unsigned prot,\n                      unsigned flags, lldb::addr_t fd, lldb::addr_t offset);\n\nbool InferiorCallMunmap(Process *proc, lldb::addr_t addr, lldb::addr_t length);\n\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_PROCESS_UTILITY_INFERIORCALLPOSIX_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp", "content": "//===-- ProcessGDBRemote.cpp ----------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"lldb/Host/Config.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#if LLDB_ENABLE_POSIX\n#include <netinet/in.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#endif\n#include <sys/stat.h>\n#if defined(__APPLE__)\n#include <sys/sysctl.h>\n#endif\n#include <sys/types.h>\n#include <time.h>\n\n#include <algorithm>\n#include <csignal>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <sstream>\n\n#include \"lldb/Breakpoint/Watchpoint.h\"\n#include \"lldb/Core/Debugger.h\"\n#include \"lldb/Core/Module.h\"\n#include \"lldb/Core/ModuleSpec.h\"\n#include \"lldb/Core/PluginManager.h\"\n#include \"lldb/Core/StreamFile.h\"\n#include \"lldb/Core/Value.h\"\n#include \"lldb/DataFormatters/FormatManager.h\"\n#include \"lldb/Host/ConnectionFileDescriptor.h\"\n#include \"lldb/Host/FileSystem.h\"\n#include \"lldb/Host/HostThread.h\"\n#include \"lldb/Host/PosixApi.h\"\n#include \"lldb/Host/PseudoTerminal.h\"\n#include \"lldb/Host/StringConvert.h\"\n#include \"lldb/Host/ThreadLauncher.h\"\n#include \"lldb/Host/XML.h\"\n#include \"lldb/Interpreter/CommandInterpreter.h\"\n#include \"lldb/Interpreter/CommandObject.h\"\n#include \"lldb/Interpreter/CommandObjectMultiword.h\"\n#include \"lldb/Interpreter/CommandReturnObject.h\"\n#include \"lldb/Interpreter/OptionArgParser.h\"\n#include \"lldb/Interpreter/OptionGroupBoolean.h\"\n#include \"lldb/Interpreter/OptionGroupUInt64.h\"\n#include \"lldb/Interpreter/OptionValueProperties.h\"\n#include \"lldb/Interpreter/Options.h\"\n#include \"lldb/Interpreter/Property.h\"\n#include \"lldb/Symbol/LocateSymbolFile.h\"\n#include \"lldb/Symbol/ObjectFile.h\"\n#include \"lldb/Target/ABI.h\"\n#include \"lldb/Target/DynamicLoader.h\"\n#include \"lldb/Target/MemoryRegionInfo.h\"\n#include \"lldb/Target/SystemRuntime.h\"\n#include \"lldb/Target/Target.h\"\n#include \"lldb/Target/TargetList.h\"\n#include \"lldb/Target/ThreadPlanCallFunction.h\"\n#include \"lldb/Utility/Args.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Reproducer.h\"\n#include \"lldb/Utility/State.h\"\n#include \"lldb/Utility/StreamString.h\"\n#include \"lldb/Utility/Timer.h\"\n\n#include \"GDBRemoteRegisterContext.h\"\n#include \"Plugins/Platform/MacOSX/PlatformRemoteiOS.h\"\n#include \"Plugins/Process/Utility/GDBRemoteSignals.h\"\n#include \"Plugins/Process/Utility/InferiorCallPOSIX.h\"\n#include \"Plugins/Process/Utility/StopInfoMachException.h\"\n#include \"ProcessGDBRemote.h\"\n#include \"ProcessGDBRemoteLog.h\"\n#include \"ThreadGDBRemote.h\"\n#include \"lldb/Host/Host.h\"\n#include \"lldb/Utility/StringExtractorGDBRemote.h\"\n\n#include \"llvm/ADT/ScopeExit.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Support/Threading.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#define DEBUGSERVER_BASENAME \"debugserver\"\nusing namespace lldb;\nusing namespace lldb_private;\nusing namespace lldb_private::process_gdb_remote;\n\nLLDB_PLUGIN_DEFINE(ProcessGDBRemote)\n\nnamespace lldb {\n// Provide a function that can easily dump the packet history if we know a\n// ProcessGDBRemote * value (which we can get from logs or from debugging). We\n// need the function in the lldb namespace so it makes it into the final\n// executable since the LLDB shared library only exports stuff in the lldb\n// namespace. This allows you to attach with a debugger and call this function\n// and get the packet history dumped to a file.\nvoid DumpProcessGDBRemotePacketHistory(void *p, const char *path) {\n  auto file = FileSystem::Instance().Open(\n      FileSpec(path), File::eOpenOptionWrite | File::eOpenOptionCanCreate);\n  if (!file) {\n    llvm::consumeError(file.takeError());\n    return;\n  }\n  StreamFile stream(std::move(file.get()));\n  ((ProcessGDBRemote *)p)->GetGDBRemote().DumpHistory(stream);\n}\n} // namespace lldb\n\nnamespace {\n\n#define LLDB_PROPERTIES_processgdbremote\n#include \"ProcessGDBRemoteProperties.inc\"\n\nenum {\n#define LLDB_PROPERTIES_processgdbremote\n#include \"ProcessGDBRemotePropertiesEnum.inc\"\n};\n\nclass PluginProperties : public Properties {\npublic:\n  static ConstString GetSettingName() {\n    return ProcessGDBRemote::GetPluginNameStatic();\n  }\n\n  PluginProperties() : Properties() {\n    m_collection_sp = std::make_shared<OptionValueProperties>(GetSettingName());\n    m_collection_sp->Initialize(g_processgdbremote_properties);\n  }\n\n  ~PluginProperties() override {}\n\n  uint64_t GetPacketTimeout() {\n    const uint32_t idx = ePropertyPacketTimeout;\n    return m_collection_sp->GetPropertyAtIndexAsUInt64(\n        nullptr, idx, g_processgdbremote_properties[idx].default_uint_value);\n  }\n\n  bool SetPacketTimeout(uint64_t timeout) {\n    const uint32_t idx = ePropertyPacketTimeout;\n    return m_collection_sp->SetPropertyAtIndexAsUInt64(nullptr, idx, timeout);\n  }\n\n  FileSpec GetTargetDefinitionFile() const {\n    const uint32_t idx = ePropertyTargetDefinitionFile;\n    return m_collection_sp->GetPropertyAtIndexAsFileSpec(nullptr, idx);\n  }\n\n  bool GetUseSVR4() const {\n    const uint32_t idx = ePropertyUseSVR4;\n    return m_collection_sp->GetPropertyAtIndexAsBoolean(\n        nullptr, idx,\n        g_processgdbremote_properties[idx].default_uint_value != 0);\n  }\n\n  bool GetUseGPacketForReading() const {\n    const uint32_t idx = ePropertyUseGPacketForReading;\n    return m_collection_sp->GetPropertyAtIndexAsBoolean(nullptr, idx, true);\n  }\n};\n\ntypedef std::shared_ptr<PluginProperties> ProcessKDPPropertiesSP;\n\nstatic const ProcessKDPPropertiesSP &GetGlobalPluginProperties() {\n  static ProcessKDPPropertiesSP g_settings_sp;\n  if (!g_settings_sp)\n    g_settings_sp = std::make_shared<PluginProperties>();\n  return g_settings_sp;\n}\n\n} // namespace\n\n// TODO Randomly assigning a port is unsafe.  We should get an unused\n// ephemeral port from the kernel and make sure we reserve it before passing it\n// to debugserver.\n\n#if defined(__APPLE__)\n#define LOW_PORT (IPPORT_RESERVED)\n#define HIGH_PORT (IPPORT_HIFIRSTAUTO)\n#else\n#define LOW_PORT (1024u)\n#define HIGH_PORT (49151u)\n#endif\n\nConstString ProcessGDBRemote::GetPluginNameStatic() {\n  static ConstString g_name(\"gdb-remote\");\n  return g_name;\n}\n\nconst char *ProcessGDBRemote::GetPluginDescriptionStatic() {\n  return \"GDB Remote protocol based debugging plug-in.\";\n}\n\nvoid ProcessGDBRemote::Terminate() {\n  PluginManager::UnregisterPlugin(ProcessGDBRemote::CreateInstance);\n}\n\nlldb::ProcessSP\nProcessGDBRemote::CreateInstance(lldb::TargetSP target_sp,\n                                 ListenerSP listener_sp,\n                                 const FileSpec *crash_file_path,\n                                 bool can_connect) {\n  lldb::ProcessSP process_sp;\n  if (crash_file_path == nullptr)\n    process_sp = std::make_shared<ProcessGDBRemote>(target_sp, listener_sp);\n  return process_sp;\n}\n\nstd::chrono::seconds ProcessGDBRemote::GetPacketTimeout() {\n  return std::chrono::seconds(GetGlobalPluginProperties()->GetPacketTimeout());\n}\n\nbool ProcessGDBRemote::CanDebug(lldb::TargetSP target_sp,\n                                bool plugin_specified_by_name) {\n  if (plugin_specified_by_name)\n    return true;\n\n  // For now we are just making sure the file exists for a given module\n  Module *exe_module = target_sp->GetExecutableModulePointer();\n  if (exe_module) {\n    ObjectFile *exe_objfile = exe_module->GetObjectFile();\n    // We can't debug core files...\n    switch (exe_objfile->GetType()) {\n    case ObjectFile::eTypeInvalid:\n    case ObjectFile::eTypeCoreFile:\n    case ObjectFile::eTypeDebugInfo:\n    case ObjectFile::eTypeObjectFile:\n    case ObjectFile::eTypeSharedLibrary:\n    case ObjectFile::eTypeStubLibrary:\n    case ObjectFile::eTypeJIT:\n      return false;\n    case ObjectFile::eTypeExecutable:\n    case ObjectFile::eTypeDynamicLinker:\n    case ObjectFile::eTypeUnknown:\n      break;\n    }\n    return FileSystem::Instance().Exists(exe_module->GetFileSpec());\n  }\n  // However, if there is no executable module, we return true since we might\n  // be preparing to attach.\n  return true;\n}\n\n// ProcessGDBRemote constructor\nProcessGDBRemote::ProcessGDBRemote(lldb::TargetSP target_sp,\n                                   ListenerSP listener_sp)\n    : Process(target_sp, listener_sp),\n      m_debugserver_pid(LLDB_INVALID_PROCESS_ID), m_last_stop_packet_mutex(),\n      m_register_info_sp(nullptr),\n      m_async_broadcaster(nullptr, \"lldb.process.gdb-remote.async-broadcaster\"),\n      m_async_listener_sp(\n          Listener::MakeListener(\"lldb.process.gdb-remote.async-listener\")),\n      m_async_thread_state_mutex(), m_thread_ids(), m_thread_pcs(),\n      m_jstopinfo_sp(), m_jthreadsinfo_sp(), m_continue_c_tids(),\n      m_continue_C_tids(), m_continue_s_tids(), m_continue_S_tids(),\n      m_max_memory_size(0), m_remote_stub_max_memory_size(0),\n      m_addr_to_mmap_size(), m_thread_create_bp_sp(),\n      m_waiting_for_attach(false), m_destroy_tried_resuming(false),\n      m_command_sp(), m_breakpoint_pc_offset(0),\n      m_initial_tid(LLDB_INVALID_THREAD_ID), m_replay_mode(false),\n      m_allow_flash_writes(false), m_erased_flash_ranges() {\n  m_async_broadcaster.SetEventName(eBroadcastBitAsyncThreadShouldExit,\n                                   \"async thread should exit\");\n  m_async_broadcaster.SetEventName(eBroadcastBitAsyncContinue,\n                                   \"async thread continue\");\n  m_async_broadcaster.SetEventName(eBroadcastBitAsyncThreadDidExit,\n                                   \"async thread did exit\");\n\n  if (repro::Generator *g = repro::Reproducer::Instance().GetGenerator()) {\n    repro::GDBRemoteProvider &provider =\n        g->GetOrCreate<repro::GDBRemoteProvider>();\n    m_gdb_comm.SetPacketRecorder(provider.GetNewPacketRecorder());\n  }\n\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_ASYNC));\n\n  const uint32_t async_event_mask =\n      eBroadcastBitAsyncContinue | eBroadcastBitAsyncThreadShouldExit;\n\n  if (m_async_listener_sp->StartListeningForEvents(\n          &m_async_broadcaster, async_event_mask) != async_event_mask) {\n    LLDB_LOGF(log,\n              \"ProcessGDBRemote::%s failed to listen for \"\n              \"m_async_broadcaster events\",\n              __FUNCTION__);\n  }\n\n  const uint32_t gdb_event_mask =\n      Communication::eBroadcastBitReadThreadDidExit |\n      GDBRemoteCommunication::eBroadcastBitGdbReadThreadGotNotify;\n  if (m_async_listener_sp->StartListeningForEvents(\n          &m_gdb_comm, gdb_event_mask) != gdb_event_mask) {\n    LLDB_LOGF(log,\n              \"ProcessGDBRemote::%s failed to listen for m_gdb_comm events\",\n              __FUNCTION__);\n  }\n\n  const uint64_t timeout_seconds =\n      GetGlobalPluginProperties()->GetPacketTimeout();\n  if (timeout_seconds > 0)\n    m_gdb_comm.SetPacketTimeout(std::chrono::seconds(timeout_seconds));\n\n  m_use_g_packet_for_reading =\n      GetGlobalPluginProperties()->GetUseGPacketForReading();\n}\n\n// Destructor\nProcessGDBRemote::~ProcessGDBRemote() {\n  //  m_mach_process.UnregisterNotificationCallbacks (this);\n  Clear();\n  // We need to call finalize on the process before destroying ourselves to\n  // make sure all of the broadcaster cleanup goes as planned. If we destruct\n  // this class, then Process::~Process() might have problems trying to fully\n  // destroy the broadcaster.\n  Finalize();\n\n  // The general Finalize is going to try to destroy the process and that\n  // SHOULD shut down the async thread.  However, if we don't kill it it will\n  // get stranded and its connection will go away so when it wakes up it will\n  // crash.  So kill it for sure here.\n  StopAsyncThread();\n  KillDebugserverProcess();\n}\n\n// PluginInterface\nConstString ProcessGDBRemote::GetPluginName() { return GetPluginNameStatic(); }\n\nuint32_t ProcessGDBRemote::GetPluginVersion() { return 1; }\n\nbool ProcessGDBRemote::ParsePythonTargetDefinition(\n    const FileSpec &target_definition_fspec) {\n  ScriptInterpreter *interpreter =\n      GetTarget().GetDebugger().GetScriptInterpreter();\n  Status error;\n  StructuredData::ObjectSP module_object_sp(\n      interpreter->LoadPluginModule(target_definition_fspec, error));\n  if (module_object_sp) {\n    StructuredData::DictionarySP target_definition_sp(\n        interpreter->GetDynamicSettings(module_object_sp, &GetTarget(),\n                                        \"gdb-server-target-definition\", error));\n\n    if (target_definition_sp) {\n      StructuredData::ObjectSP target_object(\n          target_definition_sp->GetValueForKey(\"host-info\"));\n      if (target_object) {\n        if (auto host_info_dict = target_object->GetAsDictionary()) {\n          StructuredData::ObjectSP triple_value =\n              host_info_dict->GetValueForKey(\"triple\");\n          if (auto triple_string_value = triple_value->GetAsString()) {\n            std::string triple_string =\n                std::string(triple_string_value->GetValue());\n            ArchSpec host_arch(triple_string.c_str());\n            if (!host_arch.IsCompatibleMatch(GetTarget().GetArchitecture())) {\n              GetTarget().SetArchitecture(host_arch);\n            }\n          }\n        }\n      }\n      m_breakpoint_pc_offset = 0;\n      StructuredData::ObjectSP breakpoint_pc_offset_value =\n          target_definition_sp->GetValueForKey(\"breakpoint-pc-offset\");\n      if (breakpoint_pc_offset_value) {\n        if (auto breakpoint_pc_int_value =\n                breakpoint_pc_offset_value->GetAsInteger())\n          m_breakpoint_pc_offset = breakpoint_pc_int_value->GetValue();\n      }\n\n      if (m_register_info_sp->SetRegisterInfo(\n              *target_definition_sp, GetTarget().GetArchitecture()) > 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nstatic size_t SplitCommaSeparatedRegisterNumberString(\n    const llvm::StringRef &comma_separated_regiter_numbers,\n    std::vector<uint32_t> &regnums, int base) {\n  regnums.clear();\n  std::pair<llvm::StringRef, llvm::StringRef> value_pair;\n  value_pair.second = comma_separated_regiter_numbers;\n  do {\n    value_pair = value_pair.second.split(',');\n    if (!value_pair.first.empty()) {\n      uint32_t reg = StringConvert::ToUInt32(value_pair.first.str().c_str(),\n                                             LLDB_INVALID_REGNUM, base);\n      if (reg != LLDB_INVALID_REGNUM)\n        regnums.push_back(reg);\n    }\n  } while (!value_pair.second.empty());\n  return regnums.size();\n}\n\nvoid ProcessGDBRemote::BuildDynamicRegisterInfo(bool force) {\n  if (!force && m_register_info_sp)\n    return;\n\n  m_register_info_sp = std::make_shared<GDBRemoteDynamicRegisterInfo>();\n\n  // Check if qHostInfo specified a specific packet timeout for this\n  // connection. If so then lets update our setting so the user knows what the\n  // timeout is and can see it.\n  const auto host_packet_timeout = m_gdb_comm.GetHostDefaultPacketTimeout();\n  if (host_packet_timeout > std::chrono::seconds(0)) {\n    GetGlobalPluginProperties()->SetPacketTimeout(host_packet_timeout.count());\n  }\n\n  // Register info search order:\n  //     1 - Use the target definition python file if one is specified.\n  //     2 - If the target definition doesn't have any of the info from the\n  //     target.xml (registers) then proceed to read the target.xml.\n  //     3 - Fall back on the qRegisterInfo packets.\n\n  FileSpec target_definition_fspec =\n      GetGlobalPluginProperties()->GetTargetDefinitionFile();\n  if (!FileSystem::Instance().Exists(target_definition_fspec)) {\n    // If the filename doesn't exist, it may be a ~ not having been expanded -\n    // try to resolve it.\n    FileSystem::Instance().Resolve(target_definition_fspec);\n  }\n  if (target_definition_fspec) {\n    // See if we can get register definitions from a python file\n    if (ParsePythonTargetDefinition(target_definition_fspec)) {\n      return;\n    } else {\n      StreamSP stream_sp = GetTarget().GetDebugger().GetAsyncOutputStream();\n      stream_sp->Printf(\"ERROR: target description file %s failed to parse.\\n\",\n                        target_definition_fspec.GetPath().c_str());\n    }\n  }\n\n  const ArchSpec &target_arch = GetTarget().GetArchitecture();\n  const ArchSpec &remote_host_arch = m_gdb_comm.GetHostArchitecture();\n  const ArchSpec &remote_process_arch = m_gdb_comm.GetProcessArchitecture();\n\n  // Use the process' architecture instead of the host arch, if available\n  ArchSpec arch_to_use;\n  if (remote_process_arch.IsValid())\n    arch_to_use = remote_process_arch;\n  else\n    arch_to_use = remote_host_arch;\n\n  if (!arch_to_use.IsValid())\n    arch_to_use = target_arch;\n\n  if (GetGDBServerRegisterInfo(arch_to_use))\n    return;\n\n  char packet[128];\n  uint32_t reg_offset = LLDB_INVALID_INDEX32;\n  uint32_t reg_num = 0;\n  for (StringExtractorGDBRemote::ResponseType response_type =\n           StringExtractorGDBRemote::eResponse;\n       response_type == StringExtractorGDBRemote::eResponse; ++reg_num) {\n    const int packet_len =\n        ::snprintf(packet, sizeof(packet), \"qRegisterInfo%x\", reg_num);\n    assert(packet_len < (int)sizeof(packet));\n    UNUSED_IF_ASSERT_DISABLED(packet_len);\n    StringExtractorGDBRemote response;\n    if (m_gdb_comm.SendPacketAndWaitForResponse(packet, response, false) ==\n        GDBRemoteCommunication::PacketResult::Success) {\n      response_type = response.GetResponseType();\n      if (response_type == StringExtractorGDBRemote::eResponse) {\n        llvm::StringRef name;\n        llvm::StringRef value;\n        ConstString reg_name;\n        ConstString alt_name;\n        ConstString set_name;\n        std::vector<uint32_t> value_regs;\n        std::vector<uint32_t> invalidate_regs;\n        std::vector<uint8_t> dwarf_opcode_bytes;\n        RegisterInfo reg_info = {\n            nullptr,       // Name\n            nullptr,       // Alt name\n            0,             // byte size\n            reg_offset,    // offset\n            eEncodingUint, // encoding\n            eFormatHex,    // format\n            {\n                LLDB_INVALID_REGNUM, // eh_frame reg num\n                LLDB_INVALID_REGNUM, // DWARF reg num\n                LLDB_INVALID_REGNUM, // generic reg num\n                reg_num,             // process plugin reg num\n                reg_num              // native register number\n            },\n            nullptr,\n            nullptr,\n            nullptr, // Dwarf expression opcode bytes pointer\n            0        // Dwarf expression opcode bytes length\n        };\n\n        while (response.GetNameColonValue(name, value)) {\n          if (name.equals(\"name\")) {\n            reg_name.SetString(value);\n          } else if (name.equals(\"alt-name\")) {\n            alt_name.SetString(value);\n          } else if (name.equals(\"bitsize\")) {\n            value.getAsInteger(0, reg_info.byte_size);\n            reg_info.byte_size /= CHAR_BIT;\n          } else if (name.equals(\"offset\")) {\n            if (value.getAsInteger(0, reg_offset))\n              reg_offset = UINT32_MAX;\n          } else if (name.equals(\"encoding\")) {\n            const Encoding encoding = Args::StringToEncoding(value);\n            if (encoding != eEncodingInvalid)\n              reg_info.encoding = encoding;\n          } else if (name.equals(\"format\")) {\n            Format format = eFormatInvalid;\n            if (OptionArgParser::ToFormat(value.str().c_str(), format, nullptr)\n                    .Success())\n              reg_info.format = format;\n            else {\n              reg_info.format =\n                  llvm::StringSwitch<Format>(value)\n                      .Case(\"binary\", eFormatBinary)\n                      .Case(\"decimal\", eFormatDecimal)\n                      .Case(\"hex\", eFormatHex)\n                      .Case(\"float\", eFormatFloat)\n                      .Case(\"vector-sint8\", eFormatVectorOfSInt8)\n                      .Case(\"vector-uint8\", eFormatVectorOfUInt8)\n                      .Case(\"vector-sint16\", eFormatVectorOfSInt16)\n                      .Case(\"vector-uint16\", eFormatVectorOfUInt16)\n                      .Case(\"vector-sint32\", eFormatVectorOfSInt32)\n                      .Case(\"vector-uint32\", eFormatVectorOfUInt32)\n                      .Case(\"vector-float32\", eFormatVectorOfFloat32)\n                      .Case(\"vector-uint64\", eFormatVectorOfUInt64)\n                      .Case(\"vector-uint128\", eFormatVectorOfUInt128)\n                      .Default(eFormatInvalid);\n            }\n          } else if (name.equals(\"set\")) {\n            set_name.SetString(value);\n          } else if (name.equals(\"gcc\") || name.equals(\"ehframe\")) {\n            if (value.getAsInteger(0, reg_info.kinds[eRegisterKindEHFrame]))\n              reg_info.kinds[eRegisterKindEHFrame] = LLDB_INVALID_REGNUM;\n          } else if (name.equals(\"dwarf\")) {\n            if (value.getAsInteger(0, reg_info.kinds[eRegisterKindDWARF]))\n              reg_info.kinds[eRegisterKindDWARF] = LLDB_INVALID_REGNUM;\n          } else if (name.equals(\"generic\")) {\n            reg_info.kinds[eRegisterKindGeneric] =\n                Args::StringToGenericRegister(value);\n          } else if (name.equals(\"container-regs\")) {\n            SplitCommaSeparatedRegisterNumberString(value, value_regs, 16);\n          } else if (name.equals(\"invalidate-regs\")) {\n            SplitCommaSeparatedRegisterNumberString(value, invalidate_regs, 16);\n          } else if (name.equals(\"dynamic_size_dwarf_expr_bytes\")) {\n            size_t dwarf_opcode_len = value.size() / 2;\n            assert(dwarf_opcode_len > 0);\n\n            dwarf_opcode_bytes.resize(dwarf_opcode_len);\n            reg_info.dynamic_size_dwarf_len = dwarf_opcode_len;\n\n            StringExtractor opcode_extractor(value);\n            uint32_t ret_val =\n                opcode_extractor.GetHexBytesAvail(dwarf_opcode_bytes);\n            assert(dwarf_opcode_len == ret_val);\n            UNUSED_IF_ASSERT_DISABLED(ret_val);\n            reg_info.dynamic_size_dwarf_expr_bytes = dwarf_opcode_bytes.data();\n          }\n        }\n\n        reg_info.byte_offset = reg_offset;\n        assert(reg_info.byte_size != 0);\n        reg_offset = LLDB_INVALID_INDEX32;\n        if (!value_regs.empty()) {\n          value_regs.push_back(LLDB_INVALID_REGNUM);\n          reg_info.value_regs = value_regs.data();\n        }\n        if (!invalidate_regs.empty()) {\n          invalidate_regs.push_back(LLDB_INVALID_REGNUM);\n          reg_info.invalidate_regs = invalidate_regs.data();\n        }\n\n        reg_info.name = reg_name.AsCString();\n        // We have to make a temporary ABI here, and not use the GetABI because\n        // this code gets called in DidAttach, when the target architecture\n        // (and consequently the ABI we'll get from the process) may be wrong.\n        if (ABISP abi_sp = ABI::FindPlugin(shared_from_this(), arch_to_use))\n          abi_sp->AugmentRegisterInfo(reg_info);\n\n        m_register_info_sp->AddRegister(reg_info, reg_name, alt_name, set_name);\n      } else {\n        break; // ensure exit before reg_num is incremented\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (m_register_info_sp->GetNumRegisters() > 0) {\n    m_register_info_sp->Finalize(GetTarget().GetArchitecture());\n    return;\n  }\n\n  // We didn't get anything if the accumulated reg_num is zero.  See if we are\n  // debugging ARM and fill with a hard coded register set until we can get an\n  // updated debugserver down on the devices. On the other hand, if the\n  // accumulated reg_num is positive, see if we can add composite registers to\n  // the existing primordial ones.\n  bool from_scratch = (m_register_info_sp->GetNumRegisters() == 0);\n\n  if (!target_arch.IsValid()) {\n    if (arch_to_use.IsValid() &&\n        (arch_to_use.GetMachine() == llvm::Triple::arm ||\n         arch_to_use.GetMachine() == llvm::Triple::thumb) &&\n        arch_to_use.GetTriple().getVendor() == llvm::Triple::Apple)\n      m_register_info_sp->HardcodeARMRegisters(from_scratch);\n  } else if (target_arch.GetMachine() == llvm::Triple::arm ||\n             target_arch.GetMachine() == llvm::Triple::thumb) {\n    m_register_info_sp->HardcodeARMRegisters(from_scratch);\n  }\n\n  // At this point, we can finalize our register info.\n  m_register_info_sp->Finalize(GetTarget().GetArchitecture());\n}\n\nStatus ProcessGDBRemote::WillLaunch(lldb_private::Module *module) {\n  return WillLaunchOrAttach();\n}\n\nStatus ProcessGDBRemote::WillAttachToProcessWithID(lldb::pid_t pid) {\n  return WillLaunchOrAttach();\n}\n\nStatus ProcessGDBRemote::WillAttachToProcessWithName(const char *process_name,\n                                                     bool wait_for_launch) {\n  return WillLaunchOrAttach();\n}\n\nStatus ProcessGDBRemote::DoConnectRemote(llvm::StringRef remote_url) {\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  Status error(WillLaunchOrAttach());\n\n  if (error.Fail())\n    return error;\n\n  if (repro::Reproducer::Instance().IsReplaying())\n    error = ConnectToReplayServer();\n  else\n    error = ConnectToDebugserver(remote_url);\n\n  if (error.Fail())\n    return error;\n  StartAsyncThread();\n\n  lldb::pid_t pid = m_gdb_comm.GetCurrentProcessID();\n  if (pid == LLDB_INVALID_PROCESS_ID) {\n    // We don't have a valid process ID, so note that we are connected and\n    // could now request to launch or attach, or get remote process listings...\n    SetPrivateState(eStateConnected);\n  } else {\n    // We have a valid process\n    SetID(pid);\n    GetThreadList();\n    StringExtractorGDBRemote response;\n    if (m_gdb_comm.GetStopReply(response)) {\n      SetLastStopPacket(response);\n\n      // '?' Packets must be handled differently in non-stop mode\n      if (GetTarget().GetNonStopModeEnabled())\n        HandleStopReplySequence();\n\n      Target &target = GetTarget();\n      if (!target.GetArchitecture().IsValid()) {\n        if (m_gdb_comm.GetProcessArchitecture().IsValid()) {\n          target.SetArchitecture(m_gdb_comm.GetProcessArchitecture());\n        } else {\n          if (m_gdb_comm.GetHostArchitecture().IsValid()) {\n            target.SetArchitecture(m_gdb_comm.GetHostArchitecture());\n          }\n        }\n      }\n\n      const StateType state = SetThreadStopInfo(response);\n      if (state != eStateInvalid) {\n        SetPrivateState(state);\n      } else\n        error.SetErrorStringWithFormat(\n            \"Process %\" PRIu64 \" was reported after connecting to \"\n            \"'%s', but state was not stopped: %s\",\n            pid, remote_url.str().c_str(), StateAsCString(state));\n    } else\n      error.SetErrorStringWithFormat(\"Process %\" PRIu64\n                                     \" was reported after connecting to '%s', \"\n                                     \"but no stop reply packet was received\",\n                                     pid, remote_url.str().c_str());\n  }\n\n  LLDB_LOGF(log,\n            \"ProcessGDBRemote::%s pid %\" PRIu64\n            \": normalizing target architecture initial triple: %s \"\n            \"(GetTarget().GetArchitecture().IsValid() %s, \"\n            \"m_gdb_comm.GetHostArchitecture().IsValid(): %s)\",\n            __FUNCTION__, GetID(),\n            GetTarget().GetArchitecture().GetTriple().getTriple().c_str(),\n            GetTarget().GetArchitecture().IsValid() ? \"true\" : \"false\",\n            m_gdb_comm.GetHostArchitecture().IsValid() ? \"true\" : \"false\");\n\n  if (error.Success() && !GetTarget().GetArchitecture().IsValid() &&\n      m_gdb_comm.GetHostArchitecture().IsValid()) {\n    // Prefer the *process'* architecture over that of the *host*, if\n    // available.\n    if (m_gdb_comm.GetProcessArchitecture().IsValid())\n      GetTarget().SetArchitecture(m_gdb_comm.GetProcessArchitecture());\n    else\n      GetTarget().SetArchitecture(m_gdb_comm.GetHostArchitecture());\n  }\n\n  LLDB_LOGF(log,\n            \"ProcessGDBRemote::%s pid %\" PRIu64\n            \": normalized target architecture triple: %s\",\n            __FUNCTION__, GetID(),\n            GetTarget().GetArchitecture().GetTriple().getTriple().c_str());\n\n  if (error.Success()) {\n    PlatformSP platform_sp = GetTarget().GetPlatform();\n    if (platform_sp && platform_sp->IsConnected())\n      SetUnixSignals(platform_sp->GetUnixSignals());\n    else\n      SetUnixSignals(UnixSignals::Create(GetTarget().GetArchitecture()));\n  }\n\n  return error;\n}\n\nStatus ProcessGDBRemote::WillLaunchOrAttach() {\n  Status error;\n  m_stdio_communication.Clear();\n  return error;\n}\n\n// Process Control\nStatus ProcessGDBRemote::DoLaunch(lldb_private::Module *exe_module,\n                                  ProcessLaunchInfo &launch_info) {\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  Status error;\n\n  LLDB_LOGF(log, \"ProcessGDBRemote::%s() entered\", __FUNCTION__);\n\n  uint32_t launch_flags = launch_info.GetFlags().Get();\n  FileSpec stdin_file_spec{};\n  FileSpec stdout_file_spec{};\n  FileSpec stderr_file_spec{};\n  FileSpec working_dir = launch_info.GetWorkingDirectory();\n\n  const FileAction *file_action;\n  file_action = launch_info.GetFileActionForFD(STDIN_FILENO);\n  if (file_action) {\n    if (file_action->GetAction() == FileAction::eFileActionOpen)\n      stdin_file_spec = file_action->GetFileSpec();\n  }\n  file_action = launch_info.GetFileActionForFD(STDOUT_FILENO);\n  if (file_action) {\n    if (file_action->GetAction() == FileAction::eFileActionOpen)\n      stdout_file_spec = file_action->GetFileSpec();\n  }\n  file_action = launch_info.GetFileActionForFD(STDERR_FILENO);\n  if (file_action) {\n    if (file_action->GetAction() == FileAction::eFileActionOpen)\n      stderr_file_spec = file_action->GetFileSpec();\n  }\n\n  if (log) {\n    if (stdin_file_spec || stdout_file_spec || stderr_file_spec)\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::%s provided with STDIO paths via \"\n                \"launch_info: stdin=%s, stdout=%s, stderr=%s\",\n                __FUNCTION__,\n                stdin_file_spec ? stdin_file_spec.GetCString() : \"<null>\",\n                stdout_file_spec ? stdout_file_spec.GetCString() : \"<null>\",\n                stderr_file_spec ? stderr_file_spec.GetCString() : \"<null>\");\n    else\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::%s no STDIO paths given via launch_info\",\n                __FUNCTION__);\n  }\n\n  const bool disable_stdio = (launch_flags & eLaunchFlagDisableSTDIO) != 0;\n  if (stdin_file_spec || disable_stdio) {\n    // the inferior will be reading stdin from the specified file or stdio is\n    // completely disabled\n    m_stdin_forward = false;\n  } else {\n    m_stdin_forward = true;\n  }\n\n  //  ::LogSetBitMask (GDBR_LOG_DEFAULT);\n  //  ::LogSetOptions (LLDB_LOG_OPTION_THREADSAFE |\n  //  LLDB_LOG_OPTION_PREPEND_TIMESTAMP |\n  //  LLDB_LOG_OPTION_PREPEND_PROC_AND_THREAD);\n  //  ::LogSetLogFile (\"/dev/stdout\");\n\n  ObjectFile *object_file = exe_module->GetObjectFile();\n  if (object_file) {\n    error = EstablishConnectionIfNeeded(launch_info);\n    if (error.Success()) {\n      PseudoTerminal pty;\n      const bool disable_stdio = (launch_flags & eLaunchFlagDisableSTDIO) != 0;\n\n      PlatformSP platform_sp(GetTarget().GetPlatform());\n      if (disable_stdio) {\n        // set to /dev/null unless redirected to a file above\n        if (!stdin_file_spec)\n          stdin_file_spec.SetFile(FileSystem::DEV_NULL,\n                                  FileSpec::Style::native);\n        if (!stdout_file_spec)\n          stdout_file_spec.SetFile(FileSystem::DEV_NULL,\n                                   FileSpec::Style::native);\n        if (!stderr_file_spec)\n          stderr_file_spec.SetFile(FileSystem::DEV_NULL,\n                                   FileSpec::Style::native);\n      } else if (platform_sp && platform_sp->IsHost()) {\n        // If the debugserver is local and we aren't disabling STDIO, lets use\n        // a pseudo terminal to instead of relying on the 'O' packets for stdio\n        // since 'O' packets can really slow down debugging if the inferior\n        // does a lot of output.\n        if ((!stdin_file_spec || !stdout_file_spec || !stderr_file_spec) &&\n            !errorToBool(pty.OpenFirstAvailablePrimary(O_RDWR | O_NOCTTY))) {\n          FileSpec secondary_name(pty.GetSecondaryName());\n\n          if (!stdin_file_spec)\n            stdin_file_spec = secondary_name;\n\n          if (!stdout_file_spec)\n            stdout_file_spec = secondary_name;\n\n          if (!stderr_file_spec)\n            stderr_file_spec = secondary_name;\n        }\n        LLDB_LOGF(\n            log,\n            \"ProcessGDBRemote::%s adjusted STDIO paths for local platform \"\n            \"(IsHost() is true) using secondary: stdin=%s, stdout=%s, \"\n            \"stderr=%s\",\n            __FUNCTION__,\n            stdin_file_spec ? stdin_file_spec.GetCString() : \"<null>\",\n            stdout_file_spec ? stdout_file_spec.GetCString() : \"<null>\",\n            stderr_file_spec ? stderr_file_spec.GetCString() : \"<null>\");\n      }\n\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::%s final STDIO paths after all \"\n                \"adjustments: stdin=%s, stdout=%s, stderr=%s\",\n                __FUNCTION__,\n                stdin_file_spec ? stdin_file_spec.GetCString() : \"<null>\",\n                stdout_file_spec ? stdout_file_spec.GetCString() : \"<null>\",\n                stderr_file_spec ? stderr_file_spec.GetCString() : \"<null>\");\n\n      if (stdin_file_spec)\n        m_gdb_comm.SetSTDIN(stdin_file_spec);\n      if (stdout_file_spec)\n        m_gdb_comm.SetSTDOUT(stdout_file_spec);\n      if (stderr_file_spec)\n        m_gdb_comm.SetSTDERR(stderr_file_spec);\n\n      m_gdb_comm.SetDisableASLR(launch_flags & eLaunchFlagDisableASLR);\n      m_gdb_comm.SetDetachOnError(launch_flags & eLaunchFlagDetachOnError);\n\n      m_gdb_comm.SendLaunchArchPacket(\n          GetTarget().GetArchitecture().GetArchitectureName());\n\n      const char *launch_event_data = launch_info.GetLaunchEventData();\n      if (launch_event_data != nullptr && *launch_event_data != '\\0')\n        m_gdb_comm.SendLaunchEventDataPacket(launch_event_data);\n\n      if (working_dir) {\n        m_gdb_comm.SetWorkingDir(working_dir);\n      }\n\n      // Send the environment and the program + arguments after we connect\n      m_gdb_comm.SendEnvironment(launch_info.GetEnvironment());\n\n      {\n        // Scope for the scoped timeout object\n        GDBRemoteCommunication::ScopedTimeout timeout(m_gdb_comm,\n                                                      std::chrono::seconds(10));\n\n        int arg_packet_err = m_gdb_comm.SendArgumentsPacket(launch_info);\n        if (arg_packet_err == 0) {\n          std::string error_str;\n          if (m_gdb_comm.GetLaunchSuccess(error_str)) {\n            SetID(m_gdb_comm.GetCurrentProcessID());\n          } else {\n            error.SetErrorString(error_str.c_str());\n          }\n        } else {\n          error.SetErrorStringWithFormat(\"'A' packet returned an error: %i\",\n                                         arg_packet_err);\n        }\n      }\n\n      if (GetID() == LLDB_INVALID_PROCESS_ID) {\n        LLDB_LOGF(log, \"failed to connect to debugserver: %s\",\n                  error.AsCString());\n        KillDebugserverProcess();\n        return error;\n      }\n\n      StringExtractorGDBRemote response;\n      if (m_gdb_comm.GetStopReply(response)) {\n        SetLastStopPacket(response);\n        // '?' Packets must be handled differently in non-stop mode\n        if (GetTarget().GetNonStopModeEnabled())\n          HandleStopReplySequence();\n\n        const ArchSpec &process_arch = m_gdb_comm.GetProcessArchitecture();\n\n        if (process_arch.IsValid()) {\n          GetTarget().MergeArchitecture(process_arch);\n        } else {\n          const ArchSpec &host_arch = m_gdb_comm.GetHostArchitecture();\n          if (host_arch.IsValid())\n            GetTarget().MergeArchitecture(host_arch);\n        }\n\n        SetPrivateState(SetThreadStopInfo(response));\n\n        if (!disable_stdio) {\n          if (pty.GetPrimaryFileDescriptor() != PseudoTerminal::invalid_fd)\n            SetSTDIOFileDescriptor(pty.ReleasePrimaryFileDescriptor());\n        }\n      }\n    } else {\n      LLDB_LOGF(log, \"failed to connect to debugserver: %s\", error.AsCString());\n    }\n  } else {\n    // Set our user ID to an invalid process ID.\n    SetID(LLDB_INVALID_PROCESS_ID);\n    error.SetErrorStringWithFormat(\n        \"failed to get object file from '%s' for arch %s\",\n        exe_module->GetFileSpec().GetFilename().AsCString(),\n        exe_module->GetArchitecture().GetArchitectureName());\n  }\n  return error;\n}\n\nStatus ProcessGDBRemote::ConnectToDebugserver(llvm::StringRef connect_url) {\n  Status error;\n  // Only connect if we have a valid connect URL\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n\n  if (!connect_url.empty()) {\n    LLDB_LOGF(log, \"ProcessGDBRemote::%s Connecting to %s\", __FUNCTION__,\n              connect_url.str().c_str());\n    std::unique_ptr<ConnectionFileDescriptor> conn_up(\n        new ConnectionFileDescriptor());\n    if (conn_up) {\n      const uint32_t max_retry_count = 50;\n      uint32_t retry_count = 0;\n      while (!m_gdb_comm.IsConnected()) {\n        if (conn_up->Connect(connect_url, &error) == eConnectionStatusSuccess) {\n          m_gdb_comm.SetConnection(std::move(conn_up));\n          break;\n        } else if (error.WasInterrupted()) {\n          // If we were interrupted, don't keep retrying.\n          break;\n        }\n\n        retry_count++;\n\n        if (retry_count >= max_retry_count)\n          break;\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n      }\n    }\n  }\n\n  if (!m_gdb_comm.IsConnected()) {\n    if (error.Success())\n      error.SetErrorString(\"not connected to remote gdb server\");\n    return error;\n  }\n\n  // Start the communications read thread so all incoming data can be parsed\n  // into packets and queued as they arrive.\n  if (GetTarget().GetNonStopModeEnabled())\n    m_gdb_comm.StartReadThread();\n\n  // We always seem to be able to open a connection to a local port so we need\n  // to make sure we can then send data to it. If we can't then we aren't\n  // actually connected to anything, so try and do the handshake with the\n  // remote GDB server and make sure that goes alright.\n  if (!m_gdb_comm.HandshakeWithServer(&error)) {\n    m_gdb_comm.Disconnect();\n    if (error.Success())\n      error.SetErrorString(\"not connected to remote gdb server\");\n    return error;\n  }\n\n  // Send $QNonStop:1 packet on startup if required\n  if (GetTarget().GetNonStopModeEnabled())\n    GetTarget().SetNonStopModeEnabled(m_gdb_comm.SetNonStopMode(true));\n\n  m_gdb_comm.GetEchoSupported();\n  m_gdb_comm.GetThreadSuffixSupported();\n  m_gdb_comm.GetListThreadsInStopReplySupported();\n  m_gdb_comm.GetHostInfo();\n  m_gdb_comm.GetVContSupported('c');\n  m_gdb_comm.GetVAttachOrWaitSupported();\n  m_gdb_comm.EnableErrorStringInPacket();\n\n  // Ask the remote server for the default thread id\n  if (GetTarget().GetNonStopModeEnabled())\n    m_gdb_comm.GetDefaultThreadId(m_initial_tid);\n\n  size_t num_cmds = GetExtraStartupCommands().GetArgumentCount();\n  for (size_t idx = 0; idx < num_cmds; idx++) {\n    StringExtractorGDBRemote response;\n    m_gdb_comm.SendPacketAndWaitForResponse(\n        GetExtraStartupCommands().GetArgumentAtIndex(idx), response, false);\n  }\n  return error;\n}\n\nvoid ProcessGDBRemote::DidLaunchOrAttach(ArchSpec &process_arch) {\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  BuildDynamicRegisterInfo(false);\n\n  // See if the GDB server supports qHostInfo or qProcessInfo packets. Prefer\n  // qProcessInfo as it will be more specific to our process.\n\n  const ArchSpec &remote_process_arch = m_gdb_comm.GetProcessArchitecture();\n  if (remote_process_arch.IsValid()) {\n    process_arch = remote_process_arch;\n    LLDB_LOG(log, \"gdb-remote had process architecture, using {0} {1}\",\n             process_arch.GetArchitectureName(),\n             process_arch.GetTriple().getTriple());\n  } else {\n    process_arch = m_gdb_comm.GetHostArchitecture();\n    LLDB_LOG(log,\n             \"gdb-remote did not have process architecture, using gdb-remote \"\n             \"host architecture {0} {1}\",\n             process_arch.GetArchitectureName(),\n             process_arch.GetTriple().getTriple());\n  }\n\n  if (int addresssable_bits = m_gdb_comm.GetAddressingBits()) {\n    lldb::addr_t address_mask = ~((1ULL << addresssable_bits) - 1);\n    SetCodeAddressMask(address_mask);\n    SetDataAddressMask(address_mask);\n  }\n\n  if (process_arch.IsValid()) {\n    const ArchSpec &target_arch = GetTarget().GetArchitecture();\n    if (target_arch.IsValid()) {\n      LLDB_LOG(log, \"analyzing target arch, currently {0} {1}\",\n               target_arch.GetArchitectureName(),\n               target_arch.GetTriple().getTriple());\n\n      // If the remote host is ARM and we have apple as the vendor, then\n      // ARM executables and shared libraries can have mixed ARM\n      // architectures.\n      // You can have an armv6 executable, and if the host is armv7, then the\n      // system will load the best possible architecture for all shared\n      // libraries it has, so we really need to take the remote host\n      // architecture as our defacto architecture in this case.\n\n      if ((process_arch.GetMachine() == llvm::Triple::arm ||\n           process_arch.GetMachine() == llvm::Triple::thumb) &&\n          process_arch.GetTriple().getVendor() == llvm::Triple::Apple) {\n        GetTarget().SetArchitecture(process_arch);\n        LLDB_LOG(log,\n                 \"remote process is ARM/Apple, \"\n                 \"setting target arch to {0} {1}\",\n                 process_arch.GetArchitectureName(),\n                 process_arch.GetTriple().getTriple());\n      } else {\n        // Fill in what is missing in the triple\n        const llvm::Triple &remote_triple = process_arch.GetTriple();\n        llvm::Triple new_target_triple = target_arch.GetTriple();\n        if (new_target_triple.getVendorName().size() == 0) {\n          new_target_triple.setVendor(remote_triple.getVendor());\n\n          if (new_target_triple.getOSName().size() == 0) {\n            new_target_triple.setOS(remote_triple.getOS());\n\n            if (new_target_triple.getEnvironmentName().size() == 0)\n              new_target_triple.setEnvironment(remote_triple.getEnvironment());\n          }\n\n          ArchSpec new_target_arch = target_arch;\n          new_target_arch.SetTriple(new_target_triple);\n          GetTarget().SetArchitecture(new_target_arch);\n        }\n      }\n\n      LLDB_LOG(log,\n               \"final target arch after adjustments for remote architecture: \"\n               \"{0} {1}\",\n               target_arch.GetArchitectureName(),\n               target_arch.GetTriple().getTriple());\n    } else {\n      // The target doesn't have a valid architecture yet, set it from the\n      // architecture we got from the remote GDB server\n      GetTarget().SetArchitecture(process_arch);\n    }\n  }\n\n  MaybeLoadExecutableModule();\n\n  // Find out which StructuredDataPlugins are supported by the debug monitor.\n  // These plugins transmit data over async $J packets.\n  if (StructuredData::Array *supported_packets =\n          m_gdb_comm.GetSupportedStructuredDataPlugins())\n    MapSupportedStructuredDataPlugins(*supported_packets);\n}\n\nvoid ProcessGDBRemote::MaybeLoadExecutableModule() {\n  ModuleSP module_sp = GetTarget().GetExecutableModule();\n  if (!module_sp)\n    return;\n\n  llvm::Optional<QOffsets> offsets = m_gdb_comm.GetQOffsets();\n  if (!offsets)\n    return;\n\n  bool is_uniform =\n      size_t(llvm::count(offsets->offsets, offsets->offsets[0])) ==\n      offsets->offsets.size();\n  if (!is_uniform)\n    return; // TODO: Handle non-uniform responses.\n\n  bool changed = false;\n  module_sp->SetLoadAddress(GetTarget(), offsets->offsets[0],\n                            /*value_is_offset=*/true, changed);\n  if (changed) {\n    ModuleList list;\n    list.Append(module_sp);\n    m_process->GetTarget().ModulesDidLoad(list);\n  }\n}\n\nvoid ProcessGDBRemote::DidLaunch() {\n  ArchSpec process_arch;\n  DidLaunchOrAttach(process_arch);\n}\n\nStatus ProcessGDBRemote::DoAttachToProcessWithID(\n    lldb::pid_t attach_pid, const ProcessAttachInfo &attach_info) {\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  Status error;\n\n  LLDB_LOGF(log, \"ProcessGDBRemote::%s()\", __FUNCTION__);\n\n  // Clear out and clean up from any current state\n  Clear();\n  if (attach_pid != LLDB_INVALID_PROCESS_ID) {\n    error = EstablishConnectionIfNeeded(attach_info);\n    if (error.Success()) {\n      m_gdb_comm.SetDetachOnError(attach_info.GetDetachOnError());\n\n      char packet[64];\n      const int packet_len =\n          ::snprintf(packet, sizeof(packet), \"vAttach;%\" PRIx64, attach_pid);\n      SetID(attach_pid);\n      m_async_broadcaster.BroadcastEvent(\n          eBroadcastBitAsyncContinue, new EventDataBytes(packet, packet_len));\n    } else\n      SetExitStatus(-1, error.AsCString());\n  }\n\n  return error;\n}\n\nStatus ProcessGDBRemote::DoAttachToProcessWithName(\n    const char *process_name, const ProcessAttachInfo &attach_info) {\n  Status error;\n  // Clear out and clean up from any current state\n  Clear();\n\n  if (process_name && process_name[0]) {\n    error = EstablishConnectionIfNeeded(attach_info);\n    if (error.Success()) {\n      StreamString packet;\n\n      m_gdb_comm.SetDetachOnError(attach_info.GetDetachOnError());\n\n      if (attach_info.GetWaitForLaunch()) {\n        if (!m_gdb_comm.GetVAttachOrWaitSupported()) {\n          packet.PutCString(\"vAttachWait\");\n        } else {\n          if (attach_info.GetIgnoreExisting())\n            packet.PutCString(\"vAttachWait\");\n          else\n            packet.PutCString(\"vAttachOrWait\");\n        }\n      } else\n        packet.PutCString(\"vAttachName\");\n      packet.PutChar(';');\n      packet.PutBytesAsRawHex8(process_name, strlen(process_name),\n                               endian::InlHostByteOrder(),\n                               endian::InlHostByteOrder());\n\n      m_async_broadcaster.BroadcastEvent(\n          eBroadcastBitAsyncContinue,\n          new EventDataBytes(packet.GetString().data(), packet.GetSize()));\n\n    } else\n      SetExitStatus(-1, error.AsCString());\n  }\n  return error;\n}\n\nllvm::Expected<TraceSupportedResponse> ProcessGDBRemote::TraceSupported() {\n  return m_gdb_comm.SendTraceSupported();\n}\n\nllvm::Error ProcessGDBRemote::TraceStop(const TraceStopRequest &request) {\n  return m_gdb_comm.SendTraceStop(request);\n}\n\nllvm::Error ProcessGDBRemote::TraceStart(const llvm::json::Value &request) {\n  return m_gdb_comm.SendTraceStart(request);\n}\n\nllvm::Expected<std::string>\nProcessGDBRemote::TraceGetState(llvm::StringRef type) {\n  return m_gdb_comm.SendTraceGetState(type);\n}\n\nllvm::Expected<std::vector<uint8_t>>\nProcessGDBRemote::TraceGetBinaryData(const TraceGetBinaryDataRequest &request) {\n  return m_gdb_comm.SendTraceGetBinaryData(request);\n}\n\nvoid ProcessGDBRemote::DidExit() {\n  // When we exit, disconnect from the GDB server communications\n  m_gdb_comm.Disconnect();\n}\n\nvoid ProcessGDBRemote::DidAttach(ArchSpec &process_arch) {\n  // If you can figure out what the architecture is, fill it in here.\n  process_arch.Clear();\n  DidLaunchOrAttach(process_arch);\n}\n\nStatus ProcessGDBRemote::WillResume() {\n  m_continue_c_tids.clear();\n  m_continue_C_tids.clear();\n  m_continue_s_tids.clear();\n  m_continue_S_tids.clear();\n  m_jstopinfo_sp.reset();\n  m_jthreadsinfo_sp.reset();\n  return Status();\n}\n\nStatus ProcessGDBRemote::DoResume() {\n  Status error;\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  LLDB_LOGF(log, \"ProcessGDBRemote::Resume()\");\n\n  ListenerSP listener_sp(\n      Listener::MakeListener(\"gdb-remote.resume-packet-sent\"));\n  if (listener_sp->StartListeningForEvents(\n          &m_gdb_comm, GDBRemoteCommunication::eBroadcastBitRunPacketSent)) {\n    listener_sp->StartListeningForEvents(\n        &m_async_broadcaster,\n        ProcessGDBRemote::eBroadcastBitAsyncThreadDidExit);\n\n    const size_t num_threads = GetThreadList().GetSize();\n\n    StreamString continue_packet;\n    bool continue_packet_error = false;\n    if (m_gdb_comm.HasAnyVContSupport()) {\n      if (!GetTarget().GetNonStopModeEnabled() &&\n          (m_continue_c_tids.size() == num_threads ||\n           (m_continue_c_tids.empty() && m_continue_C_tids.empty() &&\n            m_continue_s_tids.empty() && m_continue_S_tids.empty()))) {\n        // All threads are continuing, just send a \"c\" packet\n        continue_packet.PutCString(\"c\");\n      } else {\n        continue_packet.PutCString(\"vCont\");\n\n        if (!m_continue_c_tids.empty()) {\n          if (m_gdb_comm.GetVContSupported('c')) {\n            for (tid_collection::const_iterator\n                     t_pos = m_continue_c_tids.begin(),\n                     t_end = m_continue_c_tids.end();\n                 t_pos != t_end; ++t_pos)\n              continue_packet.Printf(\";c:%4.4\" PRIx64, *t_pos);\n          } else\n            continue_packet_error = true;\n        }\n\n        if (!continue_packet_error && !m_continue_C_tids.empty()) {\n          if (m_gdb_comm.GetVContSupported('C')) {\n            for (tid_sig_collection::const_iterator\n                     s_pos = m_continue_C_tids.begin(),\n                     s_end = m_continue_C_tids.end();\n                 s_pos != s_end; ++s_pos)\n              continue_packet.Printf(\";C%2.2x:%4.4\" PRIx64, s_pos->second,\n                                     s_pos->first);\n          } else\n            continue_packet_error = true;\n        }\n\n        if (!continue_packet_error && !m_continue_s_tids.empty()) {\n          if (m_gdb_comm.GetVContSupported('s')) {\n            for (tid_collection::const_iterator\n                     t_pos = m_continue_s_tids.begin(),\n                     t_end = m_continue_s_tids.end();\n                 t_pos != t_end; ++t_pos)\n              continue_packet.Printf(\";s:%4.4\" PRIx64, *t_pos);\n          } else\n            continue_packet_error = true;\n        }\n\n        if (!continue_packet_error && !m_continue_S_tids.empty()) {\n          if (m_gdb_comm.GetVContSupported('S')) {\n            for (tid_sig_collection::const_iterator\n                     s_pos = m_continue_S_tids.begin(),\n                     s_end = m_continue_S_tids.end();\n                 s_pos != s_end; ++s_pos)\n              continue_packet.Printf(\";S%2.2x:%4.4\" PRIx64, s_pos->second,\n                                     s_pos->first);\n          } else\n            continue_packet_error = true;\n        }\n\n        if (continue_packet_error)\n          continue_packet.Clear();\n      }\n    } else\n      continue_packet_error = true;\n\n    if (continue_packet_error) {\n      // Either no vCont support, or we tried to use part of the vCont packet\n      // that wasn't supported by the remote GDB server. We need to try and\n      // make a simple packet that can do our continue\n      const size_t num_continue_c_tids = m_continue_c_tids.size();\n      const size_t num_continue_C_tids = m_continue_C_tids.size();\n      const size_t num_continue_s_tids = m_continue_s_tids.size();\n      const size_t num_continue_S_tids = m_continue_S_tids.size();\n      if (num_continue_c_tids > 0) {\n        if (num_continue_c_tids == num_threads) {\n          // All threads are resuming...\n          m_gdb_comm.SetCurrentThreadForRun(-1);\n          continue_packet.PutChar('c');\n          continue_packet_error = false;\n        } else if (num_continue_c_tids == 1 && num_continue_C_tids == 0 &&\n                   num_continue_s_tids == 0 && num_continue_S_tids == 0) {\n          // Only one thread is continuing\n          m_gdb_comm.SetCurrentThreadForRun(m_continue_c_tids.front());\n          continue_packet.PutChar('c');\n          continue_packet_error = false;\n        }\n      }\n\n      if (continue_packet_error && num_continue_C_tids > 0) {\n        if ((num_continue_C_tids + num_continue_c_tids) == num_threads &&\n            num_continue_C_tids > 0 && num_continue_s_tids == 0 &&\n            num_continue_S_tids == 0) {\n          const int continue_signo = m_continue_C_tids.front().second;\n          // Only one thread is continuing\n          if (num_continue_C_tids > 1) {\n            // More that one thread with a signal, yet we don't have vCont\n            // support and we are being asked to resume each thread with a\n            // signal, we need to make sure they are all the same signal, or we\n            // can't issue the continue accurately with the current support...\n            if (num_continue_C_tids > 1) {\n              continue_packet_error = false;\n              for (size_t i = 1; i < m_continue_C_tids.size(); ++i) {\n                if (m_continue_C_tids[i].second != continue_signo)\n                  continue_packet_error = true;\n              }\n            }\n            if (!continue_packet_error)\n              m_gdb_comm.SetCurrentThreadForRun(-1);\n          } else {\n            // Set the continue thread ID\n            continue_packet_error = false;\n            m_gdb_comm.SetCurrentThreadForRun(m_continue_C_tids.front().first);\n          }\n          if (!continue_packet_error) {\n            // Add threads continuing with the same signo...\n            continue_packet.Printf(\"C%2.2x\", continue_signo);\n          }\n        }\n      }\n\n      if (continue_packet_error && num_continue_s_tids > 0) {\n        if (num_continue_s_tids == num_threads) {\n          // All threads are resuming...\n          m_gdb_comm.SetCurrentThreadForRun(-1);\n\n          // If in Non-Stop-Mode use vCont when stepping\n          if (GetTarget().GetNonStopModeEnabled()) {\n            if (m_gdb_comm.GetVContSupported('s'))\n              continue_packet.PutCString(\"vCont;s\");\n            else\n              continue_packet.PutChar('s');\n          } else\n            continue_packet.PutChar('s');\n\n          continue_packet_error = false;\n        } else if (num_continue_c_tids == 0 && num_continue_C_tids == 0 &&\n                   num_continue_s_tids == 1 && num_continue_S_tids == 0) {\n          // Only one thread is stepping\n          m_gdb_comm.SetCurrentThreadForRun(m_continue_s_tids.front());\n          continue_packet.PutChar('s');\n          continue_packet_error = false;\n        }\n      }\n\n      if (!continue_packet_error && num_continue_S_tids > 0) {\n        if (num_continue_S_tids == num_threads) {\n          const int step_signo = m_continue_S_tids.front().second;\n          // Are all threads trying to step with the same signal?\n          continue_packet_error = false;\n          if (num_continue_S_tids > 1) {\n            for (size_t i = 1; i < num_threads; ++i) {\n              if (m_continue_S_tids[i].second != step_signo)\n                continue_packet_error = true;\n            }\n          }\n          if (!continue_packet_error) {\n            // Add threads stepping with the same signo...\n            m_gdb_comm.SetCurrentThreadForRun(-1);\n            continue_packet.Printf(\"S%2.2x\", step_signo);\n          }\n        } else if (num_continue_c_tids == 0 && num_continue_C_tids == 0 &&\n                   num_continue_s_tids == 0 && num_continue_S_tids == 1) {\n          // Only one thread is stepping with signal\n          m_gdb_comm.SetCurrentThreadForRun(m_continue_S_tids.front().first);\n          continue_packet.Printf(\"S%2.2x\", m_continue_S_tids.front().second);\n          continue_packet_error = false;\n        }\n      }\n    }\n\n    if (continue_packet_error) {\n      error.SetErrorString(\"can't make continue packet for this resume\");\n    } else {\n      EventSP event_sp;\n      if (!m_async_thread.IsJoinable()) {\n        error.SetErrorString(\"Trying to resume but the async thread is dead.\");\n        LLDB_LOGF(log, \"ProcessGDBRemote::DoResume: Trying to resume but the \"\n                       \"async thread is dead.\");\n        return error;\n      }\n\n      m_async_broadcaster.BroadcastEvent(\n          eBroadcastBitAsyncContinue,\n          new EventDataBytes(continue_packet.GetString().data(),\n                             continue_packet.GetSize()));\n\n      if (!listener_sp->GetEvent(event_sp, std::chrono::seconds(5))) {\n        error.SetErrorString(\"Resume timed out.\");\n        LLDB_LOGF(log, \"ProcessGDBRemote::DoResume: Resume timed out.\");\n      } else if (event_sp->BroadcasterIs(&m_async_broadcaster)) {\n        error.SetErrorString(\"Broadcast continue, but the async thread was \"\n                             \"killed before we got an ack back.\");\n        LLDB_LOGF(log,\n                  \"ProcessGDBRemote::DoResume: Broadcast continue, but the \"\n                  \"async thread was killed before we got an ack back.\");\n        return error;\n      }\n    }\n  }\n\n  return error;\n}\n\nvoid ProcessGDBRemote::HandleStopReplySequence() {\n  while (true) {\n    // Send vStopped\n    StringExtractorGDBRemote response;\n    m_gdb_comm.SendPacketAndWaitForResponse(\"vStopped\", response, false);\n\n    // OK represents end of signal list\n    if (response.IsOKResponse())\n      break;\n\n    // If not OK or a normal packet we have a problem\n    if (!response.IsNormalResponse())\n      break;\n\n    SetLastStopPacket(response);\n  }\n}\n\nvoid ProcessGDBRemote::ClearThreadIDList() {\n  std::lock_guard<std::recursive_mutex> guard(m_thread_list_real.GetMutex());\n  m_thread_ids.clear();\n  m_thread_pcs.clear();\n}\n\nsize_t ProcessGDBRemote::UpdateThreadIDsFromStopReplyThreadsValue(\n    llvm::StringRef value) {\n  m_thread_ids.clear();\n  lldb::pid_t pid = m_gdb_comm.GetCurrentProcessID();\n  StringExtractorGDBRemote thread_ids{value};\n\n  do {\n    auto pid_tid = thread_ids.GetPidTid(pid);\n    if (pid_tid && pid_tid->first == pid) {\n      lldb::tid_t tid = pid_tid->second;\n      if (tid != LLDB_INVALID_THREAD_ID &&\n          tid != StringExtractorGDBRemote::AllProcesses)\n        m_thread_ids.push_back(tid);\n    }\n  } while (thread_ids.GetChar() == ',');\n\n  return m_thread_ids.size();\n}\n\nsize_t\nProcessGDBRemote::UpdateThreadPCsFromStopReplyThreadsValue(std::string &value) {\n  m_thread_pcs.clear();\n  size_t comma_pos;\n  lldb::addr_t pc;\n  while ((comma_pos = value.find(',')) != std::string::npos) {\n    value[comma_pos] = '\\0';\n    pc = StringConvert::ToUInt64(value.c_str(), LLDB_INVALID_ADDRESS, 16);\n    if (pc != LLDB_INVALID_ADDRESS)\n      m_thread_pcs.push_back(pc);\n    value.erase(0, comma_pos + 1);\n  }\n  pc = StringConvert::ToUInt64(value.c_str(), LLDB_INVALID_ADDRESS, 16);\n  if (pc != LLDB_INVALID_ADDRESS)\n    m_thread_pcs.push_back(pc);\n  return m_thread_pcs.size();\n}\n\nbool ProcessGDBRemote::UpdateThreadIDList() {\n  std::lock_guard<std::recursive_mutex> guard(m_thread_list_real.GetMutex());\n\n  if (m_jthreadsinfo_sp) {\n    // If we have the JSON threads info, we can get the thread list from that\n    StructuredData::Array *thread_infos = m_jthreadsinfo_sp->GetAsArray();\n    if (thread_infos && thread_infos->GetSize() > 0) {\n      m_thread_ids.clear();\n      m_thread_pcs.clear();\n      thread_infos->ForEach([this](StructuredData::Object *object) -> bool {\n        StructuredData::Dictionary *thread_dict = object->GetAsDictionary();\n        if (thread_dict) {\n          // Set the thread stop info from the JSON dictionary\n          SetThreadStopInfo(thread_dict);\n          lldb::tid_t tid = LLDB_INVALID_THREAD_ID;\n          if (thread_dict->GetValueForKeyAsInteger<lldb::tid_t>(\"tid\", tid))\n            m_thread_ids.push_back(tid);\n        }\n        return true; // Keep iterating through all thread_info objects\n      });\n    }\n    if (!m_thread_ids.empty())\n      return true;\n  } else {\n    // See if we can get the thread IDs from the current stop reply packets\n    // that might contain a \"threads\" key/value pair\n\n    // Lock the thread stack while we access it\n    // Mutex::Locker stop_stack_lock(m_last_stop_packet_mutex);\n    std::unique_lock<std::recursive_mutex> stop_stack_lock(\n        m_last_stop_packet_mutex, std::defer_lock);\n    if (stop_stack_lock.try_lock()) {\n      // Get the number of stop packets on the stack\n      int nItems = m_stop_packet_stack.size();\n      // Iterate over them\n      for (int i = 0; i < nItems; i++) {\n        // Get the thread stop info\n        StringExtractorGDBRemote &stop_info = m_stop_packet_stack[i];\n        const std::string &stop_info_str =\n            std::string(stop_info.GetStringRef());\n\n        m_thread_pcs.clear();\n        const size_t thread_pcs_pos = stop_info_str.find(\";thread-pcs:\");\n        if (thread_pcs_pos != std::string::npos) {\n          const size_t start = thread_pcs_pos + strlen(\";thread-pcs:\");\n          const size_t end = stop_info_str.find(';', start);\n          if (end != std::string::npos) {\n            std::string value = stop_info_str.substr(start, end - start);\n            UpdateThreadPCsFromStopReplyThreadsValue(value);\n          }\n        }\n\n        const size_t threads_pos = stop_info_str.find(\";threads:\");\n        if (threads_pos != std::string::npos) {\n          const size_t start = threads_pos + strlen(\";threads:\");\n          const size_t end = stop_info_str.find(';', start);\n          if (end != std::string::npos) {\n            std::string value = stop_info_str.substr(start, end - start);\n            if (UpdateThreadIDsFromStopReplyThreadsValue(value))\n              return true;\n          }\n        }\n      }\n    }\n  }\n\n  bool sequence_mutex_unavailable = false;\n  m_gdb_comm.GetCurrentThreadIDs(m_thread_ids, sequence_mutex_unavailable);\n  if (sequence_mutex_unavailable) {\n    return false; // We just didn't get the list\n  }\n  return true;\n}\n\nbool ProcessGDBRemote::DoUpdateThreadList(ThreadList &old_thread_list,\n                                          ThreadList &new_thread_list) {\n  // locker will keep a mutex locked until it goes out of scope\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_THREAD));\n  LLDB_LOGV(log, \"pid = {0}\", GetID());\n\n  size_t num_thread_ids = m_thread_ids.size();\n  // The \"m_thread_ids\" thread ID list should always be updated after each stop\n  // reply packet, but in case it isn't, update it here.\n  if (num_thread_ids == 0) {\n    if (!UpdateThreadIDList())\n      return false;\n    num_thread_ids = m_thread_ids.size();\n  }\n\n  ThreadList old_thread_list_copy(old_thread_list);\n  if (num_thread_ids > 0) {\n    for (size_t i = 0; i < num_thread_ids; ++i) {\n      tid_t tid = m_thread_ids[i];\n      ThreadSP thread_sp(\n          old_thread_list_copy.RemoveThreadByProtocolID(tid, false));\n      if (!thread_sp) {\n        thread_sp = std::make_shared<ThreadGDBRemote>(*this, tid);\n        LLDB_LOGV(log, \"Making new thread: {0} for thread ID: {1:x}.\",\n                  thread_sp.get(), thread_sp->GetID());\n      } else {\n        LLDB_LOGV(log, \"Found old thread: {0} for thread ID: {1:x}.\",\n                  thread_sp.get(), thread_sp->GetID());\n      }\n\n      SetThreadPc(thread_sp, i);\n      new_thread_list.AddThreadSortedByIndexID(thread_sp);\n    }\n  }\n\n  // Whatever that is left in old_thread_list_copy are not present in\n  // new_thread_list. Remove non-existent threads from internal id table.\n  size_t old_num_thread_ids = old_thread_list_copy.GetSize(false);\n  for (size_t i = 0; i < old_num_thread_ids; i++) {\n    ThreadSP old_thread_sp(old_thread_list_copy.GetThreadAtIndex(i, false));\n    if (old_thread_sp) {\n      lldb::tid_t old_thread_id = old_thread_sp->GetProtocolID();\n      m_thread_id_to_index_id_map.erase(old_thread_id);\n    }\n  }\n\n  return true;\n}\n\nvoid ProcessGDBRemote::SetThreadPc(const ThreadSP &thread_sp, uint64_t index) {\n  if (m_thread_ids.size() == m_thread_pcs.size() && thread_sp.get() &&\n      GetByteOrder() != eByteOrderInvalid) {\n    ThreadGDBRemote *gdb_thread =\n        static_cast<ThreadGDBRemote *>(thread_sp.get());\n    RegisterContextSP reg_ctx_sp(thread_sp->GetRegisterContext());\n    if (reg_ctx_sp) {\n      uint32_t pc_regnum = reg_ctx_sp->ConvertRegisterKindToRegisterNumber(\n          eRegisterKindGeneric, LLDB_REGNUM_GENERIC_PC);\n      if (pc_regnum != LLDB_INVALID_REGNUM) {\n        gdb_thread->PrivateSetRegisterValue(pc_regnum, m_thread_pcs[index]);\n      }\n    }\n  }\n}\n\nbool ProcessGDBRemote::GetThreadStopInfoFromJSON(\n    ThreadGDBRemote *thread, const StructuredData::ObjectSP &thread_infos_sp) {\n  // See if we got thread stop infos for all threads via the \"jThreadsInfo\"\n  // packet\n  if (thread_infos_sp) {\n    StructuredData::Array *thread_infos = thread_infos_sp->GetAsArray();\n    if (thread_infos) {\n      lldb::tid_t tid;\n      const size_t n = thread_infos->GetSize();\n      for (size_t i = 0; i < n; ++i) {\n        StructuredData::Dictionary *thread_dict =\n            thread_infos->GetItemAtIndex(i)->GetAsDictionary();\n        if (thread_dict) {\n          if (thread_dict->GetValueForKeyAsInteger<lldb::tid_t>(\n                  \"tid\", tid, LLDB_INVALID_THREAD_ID)) {\n            if (tid == thread->GetID())\n              return (bool)SetThreadStopInfo(thread_dict);\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\nbool ProcessGDBRemote::CalculateThreadStopInfo(ThreadGDBRemote *thread) {\n  // See if we got thread stop infos for all threads via the \"jThreadsInfo\"\n  // packet\n  if (GetThreadStopInfoFromJSON(thread, m_jthreadsinfo_sp))\n    return true;\n\n  // See if we got thread stop info for any threads valid stop info reasons\n  // threads via the \"jstopinfo\" packet stop reply packet key/value pair?\n  if (m_jstopinfo_sp) {\n    // If we have \"jstopinfo\" then we have stop descriptions for all threads\n    // that have stop reasons, and if there is no entry for a thread, then it\n    // has no stop reason.\n    thread->GetRegisterContext()->InvalidateIfNeeded(true);\n    if (!GetThreadStopInfoFromJSON(thread, m_jstopinfo_sp)) {\n      thread->SetStopInfo(StopInfoSP());\n    }\n    return true;\n  }\n\n  // Fall back to using the qThreadStopInfo packet\n  StringExtractorGDBRemote stop_packet;\n  if (GetGDBRemote().GetThreadStopInfo(thread->GetProtocolID(), stop_packet))\n    return SetThreadStopInfo(stop_packet) == eStateStopped;\n  return false;\n}\n\nThreadSP ProcessGDBRemote::SetThreadStopInfo(\n    lldb::tid_t tid, ExpeditedRegisterMap &expedited_register_map,\n    uint8_t signo, const std::string &thread_name, const std::string &reason,\n    const std::string &description, uint32_t exc_type,\n    const std::vector<addr_t> &exc_data, addr_t thread_dispatch_qaddr,\n    bool queue_vars_valid, // Set to true if queue_name, queue_kind and\n                           // queue_serial are valid\n    LazyBool associated_with_dispatch_queue, addr_t dispatch_queue_t,\n    std::string &queue_name, QueueKind queue_kind, uint64_t queue_serial) {\n  ThreadSP thread_sp;\n  if (tid != LLDB_INVALID_THREAD_ID) {\n    // Scope for \"locker\" below\n    {\n      // m_thread_list_real does have its own mutex, but we need to hold onto\n      // the mutex between the call to m_thread_list_real.FindThreadByID(...)\n      // and the m_thread_list_real.AddThread(...) so it doesn't change on us\n      std::lock_guard<std::recursive_mutex> guard(\n          m_thread_list_real.GetMutex());\n      thread_sp = m_thread_list_real.FindThreadByProtocolID(tid, false);\n\n      if (!thread_sp) {\n        // Create the thread if we need to\n        thread_sp = std::make_shared<ThreadGDBRemote>(*this, tid);\n        m_thread_list_real.AddThread(thread_sp);\n      }\n    }\n\n    if (thread_sp) {\n      ThreadGDBRemote *gdb_thread =\n          static_cast<ThreadGDBRemote *>(thread_sp.get());\n      RegisterContextSP gdb_reg_ctx_sp(gdb_thread->GetRegisterContext());\n\n      gdb_reg_ctx_sp->InvalidateIfNeeded(true);\n\n      auto iter = std::find(m_thread_ids.begin(), m_thread_ids.end(), tid);\n      if (iter != m_thread_ids.end()) {\n        SetThreadPc(thread_sp, iter - m_thread_ids.begin());\n      }\n\n      for (const auto &pair : expedited_register_map) {\n        StringExtractor reg_value_extractor(pair.second);\n        DataBufferSP buffer_sp(new DataBufferHeap(\n            reg_value_extractor.GetStringRef().size() / 2, 0));\n        reg_value_extractor.GetHexBytes(buffer_sp->GetData(), '\\xcc');\n        uint32_t lldb_regnum =\n            gdb_reg_ctx_sp->ConvertRegisterKindToRegisterNumber(\n                eRegisterKindProcessPlugin, pair.first);\n        gdb_thread->PrivateSetRegisterValue(lldb_regnum, buffer_sp->GetData());\n      }\n\n      // AArch64 SVE specific code below calls AArch64SVEReconfigure to update\n      // SVE register sizes and offsets if value of VG register has changed\n      // since last stop.\n      const ArchSpec &arch = GetTarget().GetArchitecture();\n      if (arch.IsValid() && arch.GetTriple().isAArch64()) {\n        GDBRemoteRegisterContext *reg_ctx_sp =\n            static_cast<GDBRemoteRegisterContext *>(\n                gdb_thread->GetRegisterContext().get());\n\n        if (reg_ctx_sp)\n          reg_ctx_sp->AArch64SVEReconfigure();\n      }\n\n      thread_sp->SetName(thread_name.empty() ? nullptr : thread_name.c_str());\n\n      gdb_thread->SetThreadDispatchQAddr(thread_dispatch_qaddr);\n      // Check if the GDB server was able to provide the queue name, kind and\n      // serial number\n      if (queue_vars_valid)\n        gdb_thread->SetQueueInfo(std::move(queue_name), queue_kind,\n                                 queue_serial, dispatch_queue_t,\n                                 associated_with_dispatch_queue);\n      else\n        gdb_thread->ClearQueueInfo();\n\n      gdb_thread->SetAssociatedWithLibdispatchQueue(\n          associated_with_dispatch_queue);\n\n      if (dispatch_queue_t != LLDB_INVALID_ADDRESS)\n        gdb_thread->SetQueueLibdispatchQueueAddress(dispatch_queue_t);\n\n      // Make sure we update our thread stop reason just once\n      if (!thread_sp->StopInfoIsUpToDate()) {\n        thread_sp->SetStopInfo(StopInfoSP());\n        // If there's a memory thread backed by this thread, we need to use it\n        // to calculate StopInfo.\n        if (ThreadSP memory_thread_sp =\n                m_thread_list.GetBackingThread(thread_sp))\n          thread_sp = memory_thread_sp;\n\n        if (exc_type != 0) {\n          const size_t exc_data_size = exc_data.size();\n\n          thread_sp->SetStopInfo(\n              StopInfoMachException::CreateStopReasonWithMachException(\n                  *thread_sp, exc_type, exc_data_size,\n                  exc_data_size >= 1 ? exc_data[0] : 0,\n                  exc_data_size >= 2 ? exc_data[1] : 0,\n                  exc_data_size >= 3 ? exc_data[2] : 0));\n        } else {\n          bool handled = false;\n          bool did_exec = false;\n          if (!reason.empty()) {\n            if (reason == \"trace\") {\n              addr_t pc = thread_sp->GetRegisterContext()->GetPC();\n              lldb::BreakpointSiteSP bp_site_sp = thread_sp->GetProcess()\n                                                      ->GetBreakpointSiteList()\n                                                      .FindByAddress(pc);\n\n              // If the current pc is a breakpoint site then the StopInfo\n              // should be set to Breakpoint Otherwise, it will be set to\n              // Trace.\n              if (bp_site_sp &&\n                  bp_site_sp->ValidForThisThread(thread_sp.get())) {\n                thread_sp->SetStopInfo(\n                    StopInfo::CreateStopReasonWithBreakpointSiteID(\n                        *thread_sp, bp_site_sp->GetID()));\n              } else\n                thread_sp->SetStopInfo(\n                    StopInfo::CreateStopReasonToTrace(*thread_sp));\n              handled = true;\n            } else if (reason == \"breakpoint\") {\n              addr_t pc = thread_sp->GetRegisterContext()->GetPC();\n              lldb::BreakpointSiteSP bp_site_sp = thread_sp->GetProcess()\n                                                      ->GetBreakpointSiteList()\n                                                      .FindByAddress(pc);\n              if (bp_site_sp) {\n                // If the breakpoint is for this thread, then we'll report the\n                // hit, but if it is for another thread, we can just report no\n                // reason.  We don't need to worry about stepping over the\n                // breakpoint here, that will be taken care of when the thread\n                // resumes and notices that there's a breakpoint under the pc.\n                handled = true;\n                if (bp_site_sp->ValidForThisThread(thread_sp.get())) {\n                  thread_sp->SetStopInfo(\n                      StopInfo::CreateStopReasonWithBreakpointSiteID(\n                          *thread_sp, bp_site_sp->GetID()));\n                } else {\n                  StopInfoSP invalid_stop_info_sp;\n                  thread_sp->SetStopInfo(invalid_stop_info_sp);\n                }\n              }\n            } else if (reason == \"trap\") {\n              // Let the trap just use the standard signal stop reason below...\n            } else if (reason == \"watchpoint\") {\n              StringExtractor desc_extractor(description.c_str());\n              addr_t wp_addr = desc_extractor.GetU64(LLDB_INVALID_ADDRESS);\n              uint32_t wp_index = desc_extractor.GetU32(LLDB_INVALID_INDEX32);\n              addr_t wp_hit_addr = desc_extractor.GetU64(LLDB_INVALID_ADDRESS);\n              watch_id_t watch_id = LLDB_INVALID_WATCH_ID;\n              if (wp_addr != LLDB_INVALID_ADDRESS) {\n                WatchpointSP wp_sp;\n                ArchSpec::Core core = GetTarget().GetArchitecture().GetCore();\n                if ((core >= ArchSpec::kCore_mips_first &&\n                     core <= ArchSpec::kCore_mips_last) ||\n                    (core >= ArchSpec::eCore_arm_generic &&\n                     core <= ArchSpec::eCore_arm_aarch64))\n                  wp_sp = GetTarget().GetWatchpointList().FindByAddress(\n                      wp_hit_addr);\n                if (!wp_sp)\n                  wp_sp =\n                      GetTarget().GetWatchpointList().FindByAddress(wp_addr);\n                if (wp_sp) {\n                  wp_sp->SetHardwareIndex(wp_index);\n                  watch_id = wp_sp->GetID();\n                }\n              }\n              if (watch_id == LLDB_INVALID_WATCH_ID) {\n                Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(\n                    GDBR_LOG_WATCHPOINTS));\n                LLDB_LOGF(log, \"failed to find watchpoint\");\n              }\n              thread_sp->SetStopInfo(StopInfo::CreateStopReasonWithWatchpointID(\n                  *thread_sp, watch_id, wp_hit_addr));\n              handled = true;\n            } else if (reason == \"exception\") {\n              thread_sp->SetStopInfo(StopInfo::CreateStopReasonWithException(\n                  *thread_sp, description.c_str()));\n              handled = true;\n            } else if (reason == \"exec\") {\n              did_exec = true;\n              thread_sp->SetStopInfo(\n                  StopInfo::CreateStopReasonWithExec(*thread_sp));\n              handled = true;\n            } else if (reason == \"processor trace\") {\n              thread_sp->SetStopInfo(StopInfo::CreateStopReasonProcessorTrace(\n                  *thread_sp, description.c_str()));\n            }\n          } else if (!signo) {\n            addr_t pc = thread_sp->GetRegisterContext()->GetPC();\n            lldb::BreakpointSiteSP bp_site_sp =\n                thread_sp->GetProcess()->GetBreakpointSiteList().FindByAddress(\n                    pc);\n\n            // If the current pc is a breakpoint site then the StopInfo should\n            // be set to Breakpoint even though the remote stub did not set it\n            // as such. This can happen when the thread is involuntarily\n            // interrupted (e.g. due to stops on other threads) just as it is\n            // about to execute the breakpoint instruction.\n            if (bp_site_sp && bp_site_sp->ValidForThisThread(thread_sp.get())) {\n              thread_sp->SetStopInfo(\n                  StopInfo::CreateStopReasonWithBreakpointSiteID(\n                      *thread_sp, bp_site_sp->GetID()));\n              handled = true;\n            }\n          }\n\n          if (!handled && signo && !did_exec) {\n            if (signo == SIGTRAP) {\n              // Currently we are going to assume SIGTRAP means we are either\n              // hitting a breakpoint or hardware single stepping.\n              handled = true;\n              addr_t pc = thread_sp->GetRegisterContext()->GetPC() +\n                          m_breakpoint_pc_offset;\n              lldb::BreakpointSiteSP bp_site_sp = thread_sp->GetProcess()\n                                                      ->GetBreakpointSiteList()\n                                                      .FindByAddress(pc);\n\n              if (bp_site_sp) {\n                // If the breakpoint is for this thread, then we'll report the\n                // hit, but if it is for another thread, we can just report no\n                // reason.  We don't need to worry about stepping over the\n                // breakpoint here, that will be taken care of when the thread\n                // resumes and notices that there's a breakpoint under the pc.\n                if (bp_site_sp->ValidForThisThread(thread_sp.get())) {\n                  if (m_breakpoint_pc_offset != 0)\n                    thread_sp->GetRegisterContext()->SetPC(pc);\n                  thread_sp->SetStopInfo(\n                      StopInfo::CreateStopReasonWithBreakpointSiteID(\n                          *thread_sp, bp_site_sp->GetID()));\n                } else {\n                  StopInfoSP invalid_stop_info_sp;\n                  thread_sp->SetStopInfo(invalid_stop_info_sp);\n                }\n              } else {\n                // If we were stepping then assume the stop was the result of\n                // the trace.  If we were not stepping then report the SIGTRAP.\n                // FIXME: We are still missing the case where we single step\n                // over a trap instruction.\n                if (thread_sp->GetTemporaryResumeState() == eStateStepping)\n                  thread_sp->SetStopInfo(\n                      StopInfo::CreateStopReasonToTrace(*thread_sp));\n                else\n                  thread_sp->SetStopInfo(StopInfo::CreateStopReasonWithSignal(\n                      *thread_sp, signo, description.c_str()));\n              }\n            }\n            if (!handled)\n              thread_sp->SetStopInfo(StopInfo::CreateStopReasonWithSignal(\n                  *thread_sp, signo, description.c_str()));\n          }\n\n          if (!description.empty()) {\n            lldb::StopInfoSP stop_info_sp(thread_sp->GetStopInfo());\n            if (stop_info_sp) {\n              const char *stop_info_desc = stop_info_sp->GetDescription();\n              if (!stop_info_desc || !stop_info_desc[0])\n                stop_info_sp->SetDescription(description.c_str());\n            } else {\n              thread_sp->SetStopInfo(StopInfo::CreateStopReasonWithException(\n                  *thread_sp, description.c_str()));\n            }\n          }\n        }\n      }\n    }\n  }\n  return thread_sp;\n}\n\nlldb::ThreadSP\nProcessGDBRemote::SetThreadStopInfo(StructuredData::Dictionary *thread_dict) {\n  static ConstString g_key_tid(\"tid\");\n  static ConstString g_key_name(\"name\");\n  static ConstString g_key_reason(\"reason\");\n  static ConstString g_key_metype(\"metype\");\n  static ConstString g_key_medata(\"medata\");\n  static ConstString g_key_qaddr(\"qaddr\");\n  static ConstString g_key_dispatch_queue_t(\"dispatch_queue_t\");\n  static ConstString g_key_associated_with_dispatch_queue(\n      \"associated_with_dispatch_queue\");\n  static ConstString g_key_queue_name(\"qname\");\n  static ConstString g_key_queue_kind(\"qkind\");\n  static ConstString g_key_queue_serial_number(\"qserialnum\");\n  static ConstString g_key_registers(\"registers\");\n  static ConstString g_key_memory(\"memory\");\n  static ConstString g_key_address(\"address\");\n  static ConstString g_key_bytes(\"bytes\");\n  static ConstString g_key_description(\"description\");\n  static ConstString g_key_signal(\"signal\");\n\n  // Stop with signal and thread info\n  lldb::tid_t tid = LLDB_INVALID_THREAD_ID;\n  uint8_t signo = 0;\n  std::string value;\n  std::string thread_name;\n  std::string reason;\n  std::string description;\n  uint32_t exc_type = 0;\n  std::vector<addr_t> exc_data;\n  addr_t thread_dispatch_qaddr = LLDB_INVALID_ADDRESS;\n  ExpeditedRegisterMap expedited_register_map;\n  bool queue_vars_valid = false;\n  addr_t dispatch_queue_t = LLDB_INVALID_ADDRESS;\n  LazyBool associated_with_dispatch_queue = eLazyBoolCalculate;\n  std::string queue_name;\n  QueueKind queue_kind = eQueueKindUnknown;\n  uint64_t queue_serial_number = 0;\n  // Iterate through all of the thread dictionary key/value pairs from the\n  // structured data dictionary\n\n  thread_dict->ForEach([this, &tid, &expedited_register_map, &thread_name,\n                        &signo, &reason, &description, &exc_type, &exc_data,\n                        &thread_dispatch_qaddr, &queue_vars_valid,\n                        &associated_with_dispatch_queue, &dispatch_queue_t,\n                        &queue_name, &queue_kind, &queue_serial_number](\n                           ConstString key,\n                           StructuredData::Object *object) -> bool {\n    if (key == g_key_tid) {\n      // thread in big endian hex\n      tid = object->GetIntegerValue(LLDB_INVALID_THREAD_ID);\n    } else if (key == g_key_metype) {\n      // exception type in big endian hex\n      exc_type = object->GetIntegerValue(0);\n    } else if (key == g_key_medata) {\n      // exception data in big endian hex\n      StructuredData::Array *array = object->GetAsArray();\n      if (array) {\n        array->ForEach([&exc_data](StructuredData::Object *object) -> bool {\n          exc_data.push_back(object->GetIntegerValue());\n          return true; // Keep iterating through all array items\n        });\n      }\n    } else if (key == g_key_name) {\n      thread_name = std::string(object->GetStringValue());\n    } else if (key == g_key_qaddr) {\n      thread_dispatch_qaddr = object->GetIntegerValue(LLDB_INVALID_ADDRESS);\n    } else if (key == g_key_queue_name) {\n      queue_vars_valid = true;\n      queue_name = std::string(object->GetStringValue());\n    } else if (key == g_key_queue_kind) {\n      std::string queue_kind_str = std::string(object->GetStringValue());\n      if (queue_kind_str == \"serial\") {\n        queue_vars_valid = true;\n        queue_kind = eQueueKindSerial;\n      } else if (queue_kind_str == \"concurrent\") {\n        queue_vars_valid = true;\n        queue_kind = eQueueKindConcurrent;\n      }\n    } else if (key == g_key_queue_serial_number) {\n      queue_serial_number = object->GetIntegerValue(0);\n      if (queue_serial_number != 0)\n        queue_vars_valid = true;\n    } else if (key == g_key_dispatch_queue_t) {\n      dispatch_queue_t = object->GetIntegerValue(0);\n      if (dispatch_queue_t != 0 && dispatch_queue_t != LLDB_INVALID_ADDRESS)\n        queue_vars_valid = true;\n    } else if (key == g_key_associated_with_dispatch_queue) {\n      queue_vars_valid = true;\n      bool associated = object->GetBooleanValue();\n      if (associated)\n        associated_with_dispatch_queue = eLazyBoolYes;\n      else\n        associated_with_dispatch_queue = eLazyBoolNo;\n    } else if (key == g_key_reason) {\n      reason = std::string(object->GetStringValue());\n    } else if (key == g_key_description) {\n      description = std::string(object->GetStringValue());\n    } else if (key == g_key_registers) {\n      StructuredData::Dictionary *registers_dict = object->GetAsDictionary();\n\n      if (registers_dict) {\n        registers_dict->ForEach(\n            [&expedited_register_map](ConstString key,\n                                      StructuredData::Object *object) -> bool {\n              const uint32_t reg =\n                  StringConvert::ToUInt32(key.GetCString(), UINT32_MAX, 10);\n              if (reg != UINT32_MAX)\n                expedited_register_map[reg] =\n                    std::string(object->GetStringValue());\n              return true; // Keep iterating through all array items\n            });\n      }\n    } else if (key == g_key_memory) {\n      StructuredData::Array *array = object->GetAsArray();\n      if (array) {\n        array->ForEach([this](StructuredData::Object *object) -> bool {\n          StructuredData::Dictionary *mem_cache_dict =\n              object->GetAsDictionary();\n          if (mem_cache_dict) {\n            lldb::addr_t mem_cache_addr = LLDB_INVALID_ADDRESS;\n            if (mem_cache_dict->GetValueForKeyAsInteger<lldb::addr_t>(\n                    \"address\", mem_cache_addr)) {\n              if (mem_cache_addr != LLDB_INVALID_ADDRESS) {\n                llvm::StringRef str;\n                if (mem_cache_dict->GetValueForKeyAsString(\"bytes\", str)) {\n                  StringExtractor bytes(str);\n                  bytes.SetFilePos(0);\n\n                  const size_t byte_size = bytes.GetStringRef().size() / 2;\n                  DataBufferSP data_buffer_sp(new DataBufferHeap(byte_size, 0));\n                  const size_t bytes_copied =\n                      bytes.GetHexBytes(data_buffer_sp->GetData(), 0);\n                  if (bytes_copied == byte_size)\n                    m_memory_cache.AddL1CacheData(mem_cache_addr,\n                                                  data_buffer_sp);\n                }\n              }\n            }\n          }\n          return true; // Keep iterating through all array items\n        });\n      }\n\n    } else if (key == g_key_signal)\n      signo = object->GetIntegerValue(LLDB_INVALID_SIGNAL_NUMBER);\n    return true; // Keep iterating through all dictionary key/value pairs\n  });\n\n  return SetThreadStopInfo(tid, expedited_register_map, signo, thread_name,\n                           reason, description, exc_type, exc_data,\n                           thread_dispatch_qaddr, queue_vars_valid,\n                           associated_with_dispatch_queue, dispatch_queue_t,\n                           queue_name, queue_kind, queue_serial_number);\n}\n\nStateType ProcessGDBRemote::SetThreadStopInfo(StringExtractor &stop_packet) {\n  lldb::pid_t pid = m_gdb_comm.GetCurrentProcessID();\n  stop_packet.SetFilePos(0);\n  const char stop_type = stop_packet.GetChar();\n  switch (stop_type) {\n  case 'T':\n  case 'S': {\n    // This is a bit of a hack, but is is required. If we did exec, we need to\n    // clear our thread lists and also know to rebuild our dynamic register\n    // info before we lookup and threads and populate the expedited register\n    // values so we need to know this right away so we can cleanup and update\n    // our registers.\n    const uint32_t stop_id = GetStopID();\n    if (stop_id == 0) {\n      // Our first stop, make sure we have a process ID, and also make sure we\n      // know about our registers\n      if (GetID() == LLDB_INVALID_PROCESS_ID && pid != LLDB_INVALID_PROCESS_ID)\n        SetID(pid);\n      BuildDynamicRegisterInfo(true);\n    }\n    // Stop with signal and thread info\n    lldb::pid_t stop_pid = LLDB_INVALID_PROCESS_ID;\n    lldb::tid_t tid = LLDB_INVALID_THREAD_ID;\n    const uint8_t signo = stop_packet.GetHexU8();\n    llvm::StringRef key;\n    llvm::StringRef value;\n    std::string thread_name;\n    std::string reason;\n    std::string description;\n    uint32_t exc_type = 0;\n    std::vector<addr_t> exc_data;\n    addr_t thread_dispatch_qaddr = LLDB_INVALID_ADDRESS;\n    bool queue_vars_valid =\n        false; // says if locals below that start with \"queue_\" are valid\n    addr_t dispatch_queue_t = LLDB_INVALID_ADDRESS;\n    LazyBool associated_with_dispatch_queue = eLazyBoolCalculate;\n    std::string queue_name;\n    QueueKind queue_kind = eQueueKindUnknown;\n    uint64_t queue_serial_number = 0;\n    ExpeditedRegisterMap expedited_register_map;\n    while (stop_packet.GetNameColonValue(key, value)) {\n      if (key.compare(\"metype\") == 0) {\n        // exception type in big endian hex\n        value.getAsInteger(16, exc_type);\n      } else if (key.compare(\"medata\") == 0) {\n        // exception data in big endian hex\n        uint64_t x;\n        value.getAsInteger(16, x);\n        exc_data.push_back(x);\n      } else if (key.compare(\"thread\") == 0) {\n        // thread-id\n        StringExtractorGDBRemote thread_id{value};\n        auto pid_tid = thread_id.GetPidTid(pid);\n        if (pid_tid) {\n          stop_pid = pid_tid->first;\n          tid = pid_tid->second;\n        } else\n          tid = LLDB_INVALID_THREAD_ID;\n      } else if (key.compare(\"threads\") == 0) {\n        std::lock_guard<std::recursive_mutex> guard(\n            m_thread_list_real.GetMutex());\n        UpdateThreadIDsFromStopReplyThreadsValue(value);\n      } else if (key.compare(\"thread-pcs\") == 0) {\n        m_thread_pcs.clear();\n        // A comma separated list of all threads in the current\n        // process that includes the thread for this stop reply packet\n        lldb::addr_t pc;\n        while (!value.empty()) {\n          llvm::StringRef pc_str;\n          std::tie(pc_str, value) = value.split(',');\n          if (pc_str.getAsInteger(16, pc))\n            pc = LLDB_INVALID_ADDRESS;\n          m_thread_pcs.push_back(pc);\n        }\n      } else if (key.compare(\"jstopinfo\") == 0) {\n        StringExtractor json_extractor(value);\n        std::string json;\n        // Now convert the HEX bytes into a string value\n        json_extractor.GetHexByteString(json);\n\n        // This JSON contains thread IDs and thread stop info for all threads.\n        // It doesn't contain expedited registers, memory or queue info.\n        m_jstopinfo_sp = StructuredData::ParseJSON(json);\n      } else if (key.compare(\"hexname\") == 0) {\n        StringExtractor name_extractor(value);\n        std::string name;\n        // Now convert the HEX bytes into a string value\n        name_extractor.GetHexByteString(thread_name);\n      } else if (key.compare(\"name\") == 0) {\n        thread_name = std::string(value);\n      } else if (key.compare(\"qaddr\") == 0) {\n        value.getAsInteger(16, thread_dispatch_qaddr);\n      } else if (key.compare(\"dispatch_queue_t\") == 0) {\n        queue_vars_valid = true;\n        value.getAsInteger(16, dispatch_queue_t);\n      } else if (key.compare(\"qname\") == 0) {\n        queue_vars_valid = true;\n        StringExtractor name_extractor(value);\n        // Now convert the HEX bytes into a string value\n        name_extractor.GetHexByteString(queue_name);\n      } else if (key.compare(\"qkind\") == 0) {\n        queue_kind = llvm::StringSwitch<QueueKind>(value)\n                         .Case(\"serial\", eQueueKindSerial)\n                         .Case(\"concurrent\", eQueueKindConcurrent)\n                         .Default(eQueueKindUnknown);\n        queue_vars_valid = queue_kind != eQueueKindUnknown;\n      } else if (key.compare(\"qserialnum\") == 0) {\n        if (!value.getAsInteger(0, queue_serial_number))\n          queue_vars_valid = true;\n      } else if (key.compare(\"reason\") == 0) {\n        reason = std::string(value);\n      } else if (key.compare(\"description\") == 0) {\n        StringExtractor desc_extractor(value);\n        // Now convert the HEX bytes into a string value\n        desc_extractor.GetHexByteString(description);\n      } else if (key.compare(\"memory\") == 0) {\n        // Expedited memory. GDB servers can choose to send back expedited\n        // memory that can populate the L1 memory cache in the process so that\n        // things like the frame pointer backchain can be expedited. This will\n        // help stack backtracing be more efficient by not having to send as\n        // many memory read requests down the remote GDB server.\n\n        // Key/value pair format: memory:<addr>=<bytes>;\n        // <addr> is a number whose base will be interpreted by the prefix:\n        //      \"0x[0-9a-fA-F]+\" for hex\n        //      \"0[0-7]+\" for octal\n        //      \"[1-9]+\" for decimal\n        // <bytes> is native endian ASCII hex bytes just like the register\n        // values\n        llvm::StringRef addr_str, bytes_str;\n        std::tie(addr_str, bytes_str) = value.split('=');\n        if (!addr_str.empty() && !bytes_str.empty()) {\n          lldb::addr_t mem_cache_addr = LLDB_INVALID_ADDRESS;\n          if (!addr_str.getAsInteger(0, mem_cache_addr)) {\n            StringExtractor bytes(bytes_str);\n            const size_t byte_size = bytes.GetBytesLeft() / 2;\n            DataBufferSP data_buffer_sp(new DataBufferHeap(byte_size, 0));\n            const size_t bytes_copied =\n                bytes.GetHexBytes(data_buffer_sp->GetData(), 0);\n            if (bytes_copied == byte_size)\n              m_memory_cache.AddL1CacheData(mem_cache_addr, data_buffer_sp);\n          }\n        }\n      } else if (key.compare(\"watch\") == 0 || key.compare(\"rwatch\") == 0 ||\n                 key.compare(\"awatch\") == 0) {\n        // Support standard GDB remote stop reply packet 'TAAwatch:addr'\n        lldb::addr_t wp_addr = LLDB_INVALID_ADDRESS;\n        value.getAsInteger(16, wp_addr);\n\n        WatchpointSP wp_sp =\n            GetTarget().GetWatchpointList().FindByAddress(wp_addr);\n        uint32_t wp_index = LLDB_INVALID_INDEX32;\n\n        if (wp_sp)\n          wp_index = wp_sp->GetHardwareIndex();\n\n        reason = \"watchpoint\";\n        StreamString ostr;\n        ostr.Printf(\"%\" PRIu64 \" %\" PRIu32, wp_addr, wp_index);\n        description = std::string(ostr.GetString());\n      } else if (key.compare(\"library\") == 0) {\n        auto error = LoadModules();\n        if (error) {\n          Log *log(\n              ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n          LLDB_LOG_ERROR(log, std::move(error), \"Failed to load modules: {0}\");\n        }\n      } else if (key.size() == 2 && ::isxdigit(key[0]) && ::isxdigit(key[1])) {\n        uint32_t reg = UINT32_MAX;\n        if (!key.getAsInteger(16, reg))\n          expedited_register_map[reg] = std::string(std::move(value));\n      }\n    }\n\n    if (stop_pid != LLDB_INVALID_PROCESS_ID && stop_pid != pid) {\n      Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n      LLDB_LOG(log,\n               \"Received stop for incorrect PID = {0} (inferior PID = {1})\",\n               stop_pid, pid);\n      return eStateInvalid;\n    }\n\n    if (tid == LLDB_INVALID_THREAD_ID) {\n      // A thread id may be invalid if the response is old style 'S' packet\n      // which does not provide the\n      // thread information. So update the thread list and choose the first\n      // one.\n      UpdateThreadIDList();\n\n      if (!m_thread_ids.empty()) {\n        tid = m_thread_ids.front();\n      }\n    }\n\n    ThreadSP thread_sp = SetThreadStopInfo(\n        tid, expedited_register_map, signo, thread_name, reason, description,\n        exc_type, exc_data, thread_dispatch_qaddr, queue_vars_valid,\n        associated_with_dispatch_queue, dispatch_queue_t, queue_name,\n        queue_kind, queue_serial_number);\n\n    return eStateStopped;\n  } break;\n\n  case 'W':\n  case 'X':\n    // process exited\n    return eStateExited;\n\n  default:\n    break;\n  }\n  return eStateInvalid;\n}\n\nvoid ProcessGDBRemote::RefreshStateAfterStop() {\n  std::lock_guard<std::recursive_mutex> guard(m_thread_list_real.GetMutex());\n\n  m_thread_ids.clear();\n  m_thread_pcs.clear();\n\n  // Set the thread stop info. It might have a \"threads\" key whose value is a\n  // list of all thread IDs in the current process, so m_thread_ids might get\n  // set.\n  // Check to see if SetThreadStopInfo() filled in m_thread_ids?\n  if (m_thread_ids.empty()) {\n      // No, we need to fetch the thread list manually\n      UpdateThreadIDList();\n  }\n\n  // We might set some stop info's so make sure the thread list is up to\n  // date before we do that or we might overwrite what was computed here.\n  UpdateThreadListIfNeeded();\n\n  // Scope for the lock\n  {\n    // Lock the thread stack while we access it\n    std::lock_guard<std::recursive_mutex> guard(m_last_stop_packet_mutex);\n    // Get the number of stop packets on the stack\n    int nItems = m_stop_packet_stack.size();\n    // Iterate over them\n    for (int i = 0; i < nItems; i++) {\n      // Get the thread stop info\n      StringExtractorGDBRemote stop_info = m_stop_packet_stack[i];\n      // Process thread stop info\n      SetThreadStopInfo(stop_info);\n    }\n    // Clear the thread stop stack\n    m_stop_packet_stack.clear();\n  }\n\n  // If we have queried for a default thread id\n  if (m_initial_tid != LLDB_INVALID_THREAD_ID) {\n    m_thread_list.SetSelectedThreadByID(m_initial_tid);\n    m_initial_tid = LLDB_INVALID_THREAD_ID;\n  }\n\n  // Let all threads recover from stopping and do any clean up based on the\n  // previous thread state (if any).\n  m_thread_list_real.RefreshStateAfterStop();\n}\n\nStatus ProcessGDBRemote::DoHalt(bool &caused_stop) {\n  Status error;\n\n  if (m_public_state.GetValue() == eStateAttaching) {\n    // We are being asked to halt during an attach. We need to just close our\n    // file handle and debugserver will go away, and we can be done...\n    m_gdb_comm.Disconnect();\n  } else\n    caused_stop = m_gdb_comm.Interrupt();\n  return error;\n}\n\nStatus ProcessGDBRemote::DoDetach(bool keep_stopped) {\n  Status error;\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  LLDB_LOGF(log, \"ProcessGDBRemote::DoDetach(keep_stopped: %i)\", keep_stopped);\n\n  error = m_gdb_comm.Detach(keep_stopped);\n  if (log) {\n    if (error.Success())\n      log->PutCString(\n          \"ProcessGDBRemote::DoDetach() detach packet sent successfully\");\n    else\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::DoDetach() detach packet send failed: %s\",\n                error.AsCString() ? error.AsCString() : \"<unknown error>\");\n  }\n\n  if (!error.Success())\n    return error;\n\n  // Sleep for one second to let the process get all detached...\n  StopAsyncThread();\n\n  SetPrivateState(eStateDetached);\n  ResumePrivateStateThread();\n\n  // KillDebugserverProcess ();\n  return error;\n}\n\nStatus ProcessGDBRemote::DoDestroy() {\n  Status error;\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  LLDB_LOGF(log, \"ProcessGDBRemote::DoDestroy()\");\n\n  // There is a bug in older iOS debugservers where they don't shut down the\n  // process they are debugging properly.  If the process is sitting at a\n  // breakpoint or an exception, this can cause problems with restarting.  So\n  // we check to see if any of our threads are stopped at a breakpoint, and if\n  // so we remove all the breakpoints, resume the process, and THEN destroy it\n  // again.\n  //\n  // Note, we don't have a good way to test the version of debugserver, but I\n  // happen to know that the set of all the iOS debugservers which don't\n  // support GetThreadSuffixSupported() and that of the debugservers with this\n  // bug are equal.  There really should be a better way to test this!\n  //\n  // We also use m_destroy_tried_resuming to make sure we only do this once, if\n  // we resume and then halt and get called here to destroy again and we're\n  // still at a breakpoint or exception, then we should just do the straight-\n  // forward kill.\n  //\n  // And of course, if we weren't able to stop the process by the time we get\n  // here, it isn't necessary (or helpful) to do any of this.\n\n  if (!m_gdb_comm.GetThreadSuffixSupported() &&\n      m_public_state.GetValue() != eStateRunning) {\n    PlatformSP platform_sp = GetTarget().GetPlatform();\n\n    // FIXME: These should be ConstStrings so we aren't doing strcmp'ing.\n    if (platform_sp && platform_sp->GetName() &&\n        platform_sp->GetName() == PlatformRemoteiOS::GetPluginNameStatic()) {\n      if (m_destroy_tried_resuming) {\n        if (log)\n          log->PutCString(\"ProcessGDBRemote::DoDestroy() - Tried resuming to \"\n                          \"destroy once already, not doing it again.\");\n      } else {\n        // At present, the plans are discarded and the breakpoints disabled\n        // Process::Destroy, but we really need it to happen here and it\n        // doesn't matter if we do it twice.\n        m_thread_list.DiscardThreadPlans();\n        DisableAllBreakpointSites();\n\n        bool stop_looks_like_crash = false;\n        ThreadList &threads = GetThreadList();\n\n        {\n          std::lock_guard<std::recursive_mutex> guard(threads.GetMutex());\n\n          size_t num_threads = threads.GetSize();\n          for (size_t i = 0; i < num_threads; i++) {\n            ThreadSP thread_sp = threads.GetThreadAtIndex(i);\n            StopInfoSP stop_info_sp = thread_sp->GetPrivateStopInfo();\n            StopReason reason = eStopReasonInvalid;\n            if (stop_info_sp)\n              reason = stop_info_sp->GetStopReason();\n            if (reason == eStopReasonBreakpoint ||\n                reason == eStopReasonException) {\n              LLDB_LOGF(log,\n                        \"ProcessGDBRemote::DoDestroy() - thread: 0x%4.4\" PRIx64\n                        \" stopped with reason: %s.\",\n                        thread_sp->GetProtocolID(),\n                        stop_info_sp->GetDescription());\n              stop_looks_like_crash = true;\n              break;\n            }\n          }\n        }\n\n        if (stop_looks_like_crash) {\n          if (log)\n            log->PutCString(\"ProcessGDBRemote::DoDestroy() - Stopped at a \"\n                            \"breakpoint, continue and then kill.\");\n          m_destroy_tried_resuming = true;\n\n          // If we are going to run again before killing, it would be good to\n          // suspend all the threads before resuming so they won't get into\n          // more trouble.  Sadly, for the threads stopped with the breakpoint\n          // or exception, the exception doesn't get cleared if it is\n          // suspended, so we do have to run the risk of letting those threads\n          // proceed a bit.\n\n          {\n            std::lock_guard<std::recursive_mutex> guard(threads.GetMutex());\n\n            size_t num_threads = threads.GetSize();\n            for (size_t i = 0; i < num_threads; i++) {\n              ThreadSP thread_sp = threads.GetThreadAtIndex(i);\n              StopInfoSP stop_info_sp = thread_sp->GetPrivateStopInfo();\n              StopReason reason = eStopReasonInvalid;\n              if (stop_info_sp)\n                reason = stop_info_sp->GetStopReason();\n              if (reason != eStopReasonBreakpoint &&\n                  reason != eStopReasonException) {\n                LLDB_LOGF(log,\n                          \"ProcessGDBRemote::DoDestroy() - Suspending \"\n                          \"thread: 0x%4.4\" PRIx64 \" before running.\",\n                          thread_sp->GetProtocolID());\n                thread_sp->SetResumeState(eStateSuspended);\n              }\n            }\n          }\n          Resume();\n          return Destroy(false);\n        }\n      }\n    }\n  }\n\n  // Interrupt if our inferior is running...\n  int exit_status = SIGABRT;\n  std::string exit_string;\n\n  if (m_gdb_comm.IsConnected()) {\n    if (m_public_state.GetValue() != eStateAttaching) {\n      StringExtractorGDBRemote response;\n      bool send_async = true;\n      GDBRemoteCommunication::ScopedTimeout(m_gdb_comm,\n                                            std::chrono::seconds(3));\n\n      if (m_gdb_comm.SendPacketAndWaitForResponse(\"k\", response, send_async) ==\n          GDBRemoteCommunication::PacketResult::Success) {\n        char packet_cmd = response.GetChar(0);\n\n        if (packet_cmd == 'W' || packet_cmd == 'X') {\n#if defined(__APPLE__)\n          // For Native processes on Mac OS X, we launch through the Host\n          // Platform, then hand the process off to debugserver, which becomes\n          // the parent process through \"PT_ATTACH\".  Then when we go to kill\n          // the process on Mac OS X we call ptrace(PT_KILL) to kill it, then\n          // we call waitpid which returns with no error and the correct\n          // status.  But amusingly enough that doesn't seem to actually reap\n          // the process, but instead it is left around as a Zombie.  Probably\n          // the kernel is in the process of switching ownership back to lldb\n          // which was the original parent, and gets confused in the handoff.\n          // Anyway, so call waitpid here to finally reap it.\n          PlatformSP platform_sp(GetTarget().GetPlatform());\n          if (platform_sp && platform_sp->IsHost()) {\n            int status;\n            ::pid_t reap_pid;\n            reap_pid = waitpid(GetID(), &status, WNOHANG);\n            LLDB_LOGF(log, \"Reaped pid: %d, status: %d.\\n\", reap_pid, status);\n          }\n#endif\n          SetLastStopPacket(response);\n          ClearThreadIDList();\n          exit_status = response.GetHexU8();\n        } else {\n          LLDB_LOGF(log,\n                    \"ProcessGDBRemote::DoDestroy - got unexpected response \"\n                    \"to k packet: %s\",\n                    response.GetStringRef().data());\n          exit_string.assign(\"got unexpected response to k packet: \");\n          exit_string.append(std::string(response.GetStringRef()));\n        }\n      } else {\n        LLDB_LOGF(log, \"ProcessGDBRemote::DoDestroy - failed to send k packet\");\n        exit_string.assign(\"failed to send the k packet\");\n      }\n    } else {\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::DoDestroy - killed or interrupted while \"\n                \"attaching\");\n      exit_string.assign(\"killed or interrupted while attaching.\");\n    }\n  } else {\n    // If we missed setting the exit status on the way out, do it here.\n    // NB set exit status can be called multiple times, the first one sets the\n    // status.\n    exit_string.assign(\"destroying when not connected to debugserver\");\n  }\n\n  SetExitStatus(exit_status, exit_string.c_str());\n\n  StopAsyncThread();\n  KillDebugserverProcess();\n  return error;\n}\n\nvoid ProcessGDBRemote::SetLastStopPacket(\n    const StringExtractorGDBRemote &response) {\n  const bool did_exec =\n      response.GetStringRef().find(\";reason:exec;\") != std::string::npos;\n  if (did_exec) {\n    Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n    LLDB_LOGF(log, \"ProcessGDBRemote::SetLastStopPacket () - detected exec\");\n\n    m_thread_list_real.Clear();\n    m_thread_list.Clear();\n    BuildDynamicRegisterInfo(true);\n    m_gdb_comm.ResetDiscoverableSettings(did_exec);\n  }\n\n  // Scope the lock\n  {\n    // Lock the thread stack while we access it\n    std::lock_guard<std::recursive_mutex> guard(m_last_stop_packet_mutex);\n\n    // We are are not using non-stop mode, there can only be one last stop\n    // reply packet, so clear the list.\n    if (!GetTarget().GetNonStopModeEnabled())\n      m_stop_packet_stack.clear();\n\n    // Add this stop packet to the stop packet stack This stack will get popped\n    // and examined when we switch to the Stopped state\n    m_stop_packet_stack.push_back(response);\n  }\n}\n\nvoid ProcessGDBRemote::SetUnixSignals(const UnixSignalsSP &signals_sp) {\n  Process::SetUnixSignals(std::make_shared<GDBRemoteSignals>(signals_sp));\n}\n\n// Process Queries\n\nbool ProcessGDBRemote::IsAlive() {\n  return m_gdb_comm.IsConnected() && Process::IsAlive();\n}\n\naddr_t ProcessGDBRemote::GetImageInfoAddress() {\n  // request the link map address via the $qShlibInfoAddr packet\n  lldb::addr_t addr = m_gdb_comm.GetShlibInfoAddr();\n\n  // the loaded module list can also provides a link map address\n  if (addr == LLDB_INVALID_ADDRESS) {\n    llvm::Expected<LoadedModuleInfoList> list = GetLoadedModuleList();\n    if (!list) {\n      Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n      LLDB_LOG_ERROR(log, list.takeError(), \"Failed to read module list: {0}.\");\n    } else {\n      addr = list->m_link_map;\n    }\n  }\n\n  return addr;\n}\n\nvoid ProcessGDBRemote::WillPublicStop() {\n  // See if the GDB remote client supports the JSON threads info. If so, we\n  // gather stop info for all threads, expedited registers, expedited memory,\n  // runtime queue information (iOS and MacOSX only), and more. Expediting\n  // memory will help stack backtracing be much faster. Expediting registers\n  // will make sure we don't have to read the thread registers for GPRs.\n  m_jthreadsinfo_sp = m_gdb_comm.GetThreadsInfo();\n\n  if (m_jthreadsinfo_sp) {\n    // Now set the stop info for each thread and also expedite any registers\n    // and memory that was in the jThreadsInfo response.\n    StructuredData::Array *thread_infos = m_jthreadsinfo_sp->GetAsArray();\n    if (thread_infos) {\n      const size_t n = thread_infos->GetSize();\n      for (size_t i = 0; i < n; ++i) {\n        StructuredData::Dictionary *thread_dict =\n            thread_infos->GetItemAtIndex(i)->GetAsDictionary();\n        if (thread_dict)\n          SetThreadStopInfo(thread_dict);\n      }\n    }\n  }\n}\n\n// Process Memory\nsize_t ProcessGDBRemote::DoReadMemory(addr_t addr, void *buf, size_t size,\n                                      Status &error) {\n  GetMaxMemorySize();\n  bool binary_memory_read = m_gdb_comm.GetxPacketSupported();\n  // M and m packets take 2 bytes for 1 byte of memory\n  size_t max_memory_size =\n      binary_memory_read ? m_max_memory_size : m_max_memory_size / 2;\n  if (size > max_memory_size) {\n    // Keep memory read sizes down to a sane limit. This function will be\n    // called multiple times in order to complete the task by\n    // lldb_private::Process so it is ok to do this.\n    size = max_memory_size;\n  }\n\n  char packet[64];\n  int packet_len;\n  packet_len = ::snprintf(packet, sizeof(packet), \"%c%\" PRIx64 \",%\" PRIx64,\n                          binary_memory_read ? 'x' : 'm', (uint64_t)addr,\n                          (uint64_t)size);\n  assert(packet_len + 1 < (int)sizeof(packet));\n  UNUSED_IF_ASSERT_DISABLED(packet_len);\n  StringExtractorGDBRemote response;\n  if (m_gdb_comm.SendPacketAndWaitForResponse(packet, response, true) ==\n      GDBRemoteCommunication::PacketResult::Success) {\n    if (response.IsNormalResponse()) {\n      error.Clear();\n      if (binary_memory_read) {\n        // The lower level GDBRemoteCommunication packet receive layer has\n        // already de-quoted any 0x7d character escaping that was present in\n        // the packet\n\n        size_t data_received_size = response.GetBytesLeft();\n        if (data_received_size > size) {\n          // Don't write past the end of BUF if the remote debug server gave us\n          // too much data for some reason.\n          data_received_size = size;\n        }\n        memcpy(buf, response.GetStringRef().data(), data_received_size);\n        return data_received_size;\n      } else {\n        return response.GetHexBytes(\n            llvm::MutableArrayRef<uint8_t>((uint8_t *)buf, size), '\\xdd');\n      }\n    } else if (response.IsErrorResponse())\n      error.SetErrorStringWithFormat(\"memory read failed for 0x%\" PRIx64, addr);\n    else if (response.IsUnsupportedResponse())\n      error.SetErrorStringWithFormat(\n          \"GDB server does not support reading memory\");\n    else\n      error.SetErrorStringWithFormat(\n          \"unexpected response to GDB server memory read packet '%s': '%s'\",\n          packet, response.GetStringRef().data());\n  } else {\n    error.SetErrorStringWithFormat(\"failed to send packet: '%s'\", packet);\n  }\n  return 0;\n}\n\nStatus ProcessGDBRemote::WriteObjectFile(\n    std::vector<ObjectFile::LoadableData> entries) {\n  Status error;\n  // Sort the entries by address because some writes, like those to flash\n  // memory, must happen in order of increasing address.\n  std::stable_sort(\n      std::begin(entries), std::end(entries),\n      [](const ObjectFile::LoadableData a, const ObjectFile::LoadableData b) {\n        return a.Dest < b.Dest;\n      });\n  m_allow_flash_writes = true;\n  error = Process::WriteObjectFile(entries);\n  if (error.Success())\n    error = FlashDone();\n  else\n    // Even though some of the writing failed, try to send a flash done if some\n    // of the writing succeeded so the flash state is reset to normal, but\n    // don't stomp on the error status that was set in the write failure since\n    // that's the one we want to report back.\n    FlashDone();\n  m_allow_flash_writes = false;\n  return error;\n}\n\nbool ProcessGDBRemote::HasErased(FlashRange range) {\n  auto size = m_erased_flash_ranges.GetSize();\n  for (size_t i = 0; i < size; ++i)\n    if (m_erased_flash_ranges.GetEntryAtIndex(i)->Contains(range))\n      return true;\n  return false;\n}\n\nStatus ProcessGDBRemote::FlashErase(lldb::addr_t addr, size_t size) {\n  Status status;\n\n  MemoryRegionInfo region;\n  status = GetMemoryRegionInfo(addr, region);\n  if (!status.Success())\n    return status;\n\n  // The gdb spec doesn't say if erasures are allowed across multiple regions,\n  // but we'll disallow it to be safe and to keep the logic simple by worring\n  // about only one region's block size.  DoMemoryWrite is this function's\n  // primary user, and it can easily keep writes within a single memory region\n  if (addr + size > region.GetRange().GetRangeEnd()) {\n    status.SetErrorString(\"Unable to erase flash in multiple regions\");\n    return status;\n  }\n\n  uint64_t blocksize = region.GetBlocksize();\n  if (blocksize == 0) {\n    status.SetErrorString(\"Unable to erase flash because blocksize is 0\");\n    return status;\n  }\n\n  // Erasures can only be done on block boundary adresses, so round down addr\n  // and round up size\n  lldb::addr_t block_start_addr = addr - (addr % blocksize);\n  size += (addr - block_start_addr);\n  if ((size % blocksize) != 0)\n    size += (blocksize - size % blocksize);\n\n  FlashRange range(block_start_addr, size);\n\n  if (HasErased(range))\n    return status;\n\n  // We haven't erased the entire range, but we may have erased part of it.\n  // (e.g., block A is already erased and range starts in A and ends in B). So,\n  // adjust range if necessary to exclude already erased blocks.\n  if (!m_erased_flash_ranges.IsEmpty()) {\n    // Assuming that writes and erasures are done in increasing addr order,\n    // because that is a requirement of the vFlashWrite command.  Therefore, we\n    // only need to look at the last range in the list for overlap.\n    const auto &last_range = *m_erased_flash_ranges.Back();\n    if (range.GetRangeBase() < last_range.GetRangeEnd()) {\n      auto overlap = last_range.GetRangeEnd() - range.GetRangeBase();\n      // overlap will be less than range.GetByteSize() or else HasErased()\n      // would have been true\n      range.SetByteSize(range.GetByteSize() - overlap);\n      range.SetRangeBase(range.GetRangeBase() + overlap);\n    }\n  }\n\n  StreamString packet;\n  packet.Printf(\"vFlashErase:%\" PRIx64 \",%\" PRIx64, range.GetRangeBase(),\n                (uint64_t)range.GetByteSize());\n\n  StringExtractorGDBRemote response;\n  if (m_gdb_comm.SendPacketAndWaitForResponse(packet.GetString(), response,\n                                              true) ==\n      GDBRemoteCommunication::PacketResult::Success) {\n    if (response.IsOKResponse()) {\n      m_erased_flash_ranges.Insert(range, true);\n    } else {\n      if (response.IsErrorResponse())\n        status.SetErrorStringWithFormat(\"flash erase failed for 0x%\" PRIx64,\n                                        addr);\n      else if (response.IsUnsupportedResponse())\n        status.SetErrorStringWithFormat(\"GDB server does not support flashing\");\n      else\n        status.SetErrorStringWithFormat(\n            \"unexpected response to GDB server flash erase packet '%s': '%s'\",\n            packet.GetData(), response.GetStringRef().data());\n    }\n  } else {\n    status.SetErrorStringWithFormat(\"failed to send packet: '%s'\",\n                                    packet.GetData());\n  }\n  return status;\n}\n\nStatus ProcessGDBRemote::FlashDone() {\n  Status status;\n  // If we haven't erased any blocks, then we must not have written anything\n  // either, so there is no need to actually send a vFlashDone command\n  if (m_erased_flash_ranges.IsEmpty())\n    return status;\n  StringExtractorGDBRemote response;\n  if (m_gdb_comm.SendPacketAndWaitForResponse(\"vFlashDone\", response, true) ==\n      GDBRemoteCommunication::PacketResult::Success) {\n    if (response.IsOKResponse()) {\n      m_erased_flash_ranges.Clear();\n    } else {\n      if (response.IsErrorResponse())\n        status.SetErrorStringWithFormat(\"flash done failed\");\n      else if (response.IsUnsupportedResponse())\n        status.SetErrorStringWithFormat(\"GDB server does not support flashing\");\n      else\n        status.SetErrorStringWithFormat(\n            \"unexpected response to GDB server flash done packet: '%s'\",\n            response.GetStringRef().data());\n    }\n  } else {\n    status.SetErrorStringWithFormat(\"failed to send flash done packet\");\n  }\n  return status;\n}\n\nsize_t ProcessGDBRemote::DoWriteMemory(addr_t addr, const void *buf,\n                                       size_t size, Status &error) {\n  GetMaxMemorySize();\n  // M and m packets take 2 bytes for 1 byte of memory\n  size_t max_memory_size = m_max_memory_size / 2;\n  if (size > max_memory_size) {\n    // Keep memory read sizes down to a sane limit. This function will be\n    // called multiple times in order to complete the task by\n    // lldb_private::Process so it is ok to do this.\n    size = max_memory_size;\n  }\n\n  StreamGDBRemote packet;\n\n  MemoryRegionInfo region;\n  Status region_status = GetMemoryRegionInfo(addr, region);\n\n  bool is_flash =\n      region_status.Success() && region.GetFlash() == MemoryRegionInfo::eYes;\n\n  if (is_flash) {\n    if (!m_allow_flash_writes) {\n      error.SetErrorString(\"Writing to flash memory is not allowed\");\n      return 0;\n    }\n    // Keep the write within a flash memory region\n    if (addr + size > region.GetRange().GetRangeEnd())\n      size = region.GetRange().GetRangeEnd() - addr;\n    // Flash memory must be erased before it can be written\n    error = FlashErase(addr, size);\n    if (!error.Success())\n      return 0;\n    packet.Printf(\"vFlashWrite:%\" PRIx64 \":\", addr);\n    packet.PutEscapedBytes(buf, size);\n  } else {\n    packet.Printf(\"M%\" PRIx64 \",%\" PRIx64 \":\", addr, (uint64_t)size);\n    packet.PutBytesAsRawHex8(buf, size, endian::InlHostByteOrder(),\n                             endian::InlHostByteOrder());\n  }\n  StringExtractorGDBRemote response;\n  if (m_gdb_comm.SendPacketAndWaitForResponse(packet.GetString(), response,\n                                              true) ==\n      GDBRemoteCommunication::PacketResult::Success) {\n    if (response.IsOKResponse()) {\n      error.Clear();\n      return size;\n    } else if (response.IsErrorResponse())\n      error.SetErrorStringWithFormat(\"memory write failed for 0x%\" PRIx64,\n                                     addr);\n    else if (response.IsUnsupportedResponse())\n      error.SetErrorStringWithFormat(\n          \"GDB server does not support writing memory\");\n    else\n      error.SetErrorStringWithFormat(\n          \"unexpected response to GDB server memory write packet '%s': '%s'\",\n          packet.GetData(), response.GetStringRef().data());\n  } else {\n    error.SetErrorStringWithFormat(\"failed to send packet: '%s'\",\n                                   packet.GetData());\n  }\n  return 0;\n}\n\nlldb::addr_t ProcessGDBRemote::DoAllocateMemory(size_t size,\n                                                uint32_t permissions,\n                                                Status &error) {\n  Log *log(\n      GetLogIfAnyCategoriesSet(LIBLLDB_LOG_PROCESS | LIBLLDB_LOG_EXPRESSIONS));\n  addr_t allocated_addr = LLDB_INVALID_ADDRESS;\n\n  if (m_gdb_comm.SupportsAllocDeallocMemory() != eLazyBoolNo) {\n    allocated_addr = m_gdb_comm.AllocateMemory(size, permissions);\n    if (allocated_addr != LLDB_INVALID_ADDRESS ||\n        m_gdb_comm.SupportsAllocDeallocMemory() == eLazyBoolYes)\n      return allocated_addr;\n  }\n\n  if (m_gdb_comm.SupportsAllocDeallocMemory() == eLazyBoolNo) {\n    // Call mmap() to create memory in the inferior..\n    unsigned prot = 0;\n    if (permissions & lldb::ePermissionsReadable)\n      prot |= eMmapProtRead;\n    if (permissions & lldb::ePermissionsWritable)\n      prot |= eMmapProtWrite;\n    if (permissions & lldb::ePermissionsExecutable)\n      prot |= eMmapProtExec;\n\n    if (InferiorCallMmap(this, allocated_addr, 0, size, prot,\n                         eMmapFlagsAnon | eMmapFlagsPrivate, -1, 0))\n      m_addr_to_mmap_size[allocated_addr] = size;\n    else {\n      allocated_addr = LLDB_INVALID_ADDRESS;\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::%s no direct stub support for memory \"\n                \"allocation, and InferiorCallMmap also failed - is stub \"\n                \"missing register context save/restore capability?\",\n                __FUNCTION__);\n    }\n  }\n\n  if (allocated_addr == LLDB_INVALID_ADDRESS)\n    error.SetErrorStringWithFormat(\n        \"unable to allocate %\" PRIu64 \" bytes of memory with permissions %s\",\n        (uint64_t)size, GetPermissionsAsCString(permissions));\n  else\n    error.Clear();\n  return allocated_addr;\n}\n\nStatus ProcessGDBRemote::GetMemoryRegionInfo(addr_t load_addr,\n                                             MemoryRegionInfo &region_info) {\n\n  Status error(m_gdb_comm.GetMemoryRegionInfo(load_addr, region_info));\n  return error;\n}\n\nStatus ProcessGDBRemote::GetWatchpointSupportInfo(uint32_t &num) {\n\n  Status error(m_gdb_comm.GetWatchpointSupportInfo(num));\n  return error;\n}\n\nStatus ProcessGDBRemote::GetWatchpointSupportInfo(uint32_t &num, bool &after) {\n  Status error(m_gdb_comm.GetWatchpointSupportInfo(\n      num, after, GetTarget().GetArchitecture()));\n  return error;\n}\n\nStatus ProcessGDBRemote::DoDeallocateMemory(lldb::addr_t addr) {\n  Status error;\n  LazyBool supported = m_gdb_comm.SupportsAllocDeallocMemory();\n\n  switch (supported) {\n  case eLazyBoolCalculate:\n    // We should never be deallocating memory without allocating memory first\n    // so we should never get eLazyBoolCalculate\n    error.SetErrorString(\n        \"tried to deallocate memory without ever allocating memory\");\n    break;\n\n  case eLazyBoolYes:\n    if (!m_gdb_comm.DeallocateMemory(addr))\n      error.SetErrorStringWithFormat(\n          \"unable to deallocate memory at 0x%\" PRIx64, addr);\n    break;\n\n  case eLazyBoolNo:\n    // Call munmap() to deallocate memory in the inferior..\n    {\n      MMapMap::iterator pos = m_addr_to_mmap_size.find(addr);\n      if (pos != m_addr_to_mmap_size.end() &&\n          InferiorCallMunmap(this, addr, pos->second))\n        m_addr_to_mmap_size.erase(pos);\n      else\n        error.SetErrorStringWithFormat(\n            \"unable to deallocate memory at 0x%\" PRIx64, addr);\n    }\n    break;\n  }\n\n  return error;\n}\n\n// Process STDIO\nsize_t ProcessGDBRemote::PutSTDIN(const char *src, size_t src_len,\n                                  Status &error) {\n  if (m_stdio_communication.IsConnected()) {\n    ConnectionStatus status;\n    m_stdio_communication.Write(src, src_len, status, nullptr);\n  } else if (m_stdin_forward) {\n    m_gdb_comm.SendStdinNotification(src, src_len);\n  }\n  return 0;\n}\n\nStatus ProcessGDBRemote::EnableBreakpointSite(BreakpointSite *bp_site) {\n  Status error;\n  assert(bp_site != nullptr);\n\n  // Get logging info\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_BREAKPOINTS));\n  user_id_t site_id = bp_site->GetID();\n\n  // Get the breakpoint address\n  const addr_t addr = bp_site->GetLoadAddress();\n\n  // Log that a breakpoint was requested\n  LLDB_LOGF(log,\n            \"ProcessGDBRemote::EnableBreakpointSite (size_id = %\" PRIu64\n            \") address = 0x%\" PRIx64,\n            site_id, (uint64_t)addr);\n\n  // Breakpoint already exists and is enabled\n  if (bp_site->IsEnabled()) {\n    LLDB_LOGF(log,\n              \"ProcessGDBRemote::EnableBreakpointSite (size_id = %\" PRIu64\n              \") address = 0x%\" PRIx64 \" -- SUCCESS (already enabled)\",\n              site_id, (uint64_t)addr);\n    return error;\n  }\n\n  // Get the software breakpoint trap opcode size\n  const size_t bp_op_size = GetSoftwareBreakpointTrapOpcode(bp_site);\n\n  // SupportsGDBStoppointPacket() simply checks a boolean, indicating if this\n  // breakpoint type is supported by the remote stub. These are set to true by\n  // default, and later set to false only after we receive an unimplemented\n  // response when sending a breakpoint packet. This means initially that\n  // unless we were specifically instructed to use a hardware breakpoint, LLDB\n  // will attempt to set a software breakpoint. HardwareRequired() also queries\n  // a boolean variable which indicates if the user specifically asked for\n  // hardware breakpoints.  If true then we will skip over software\n  // breakpoints.\n  if (m_gdb_comm.SupportsGDBStoppointPacket(eBreakpointSoftware) &&\n      (!bp_site->HardwareRequired())) {\n    // Try to send off a software breakpoint packet ($Z0)\n    uint8_t error_no = m_gdb_comm.SendGDBStoppointTypePacket(\n        eBreakpointSoftware, true, addr, bp_op_size);\n    if (error_no == 0) {\n      // The breakpoint was placed successfully\n      bp_site->SetEnabled(true);\n      bp_site->SetType(BreakpointSite::eExternal);\n      return error;\n    }\n\n    // SendGDBStoppointTypePacket() will return an error if it was unable to\n    // set this breakpoint. We need to differentiate between a error specific\n    // to placing this breakpoint or if we have learned that this breakpoint\n    // type is unsupported. To do this, we must test the support boolean for\n    // this breakpoint type to see if it now indicates that this breakpoint\n    // type is unsupported.  If they are still supported then we should return\n    // with the error code.  If they are now unsupported, then we would like to\n    // fall through and try another form of breakpoint.\n    if (m_gdb_comm.SupportsGDBStoppointPacket(eBreakpointSoftware)) {\n      if (error_no != UINT8_MAX)\n        error.SetErrorStringWithFormat(\n            \"error: %d sending the breakpoint request\", error_no);\n      else\n        error.SetErrorString(\"error sending the breakpoint request\");\n      return error;\n    }\n\n    // We reach here when software breakpoints have been found to be\n    // unsupported. For future calls to set a breakpoint, we will not attempt\n    // to set a breakpoint with a type that is known not to be supported.\n    LLDB_LOGF(log, \"Software breakpoints are unsupported\");\n\n    // So we will fall through and try a hardware breakpoint\n  }\n\n  // The process of setting a hardware breakpoint is much the same as above.\n  // We check the supported boolean for this breakpoint type, and if it is\n  // thought to be supported then we will try to set this breakpoint with a\n  // hardware breakpoint.\n  if (m_gdb_comm.SupportsGDBStoppointPacket(eBreakpointHardware)) {\n    // Try to send off a hardware breakpoint packet ($Z1)\n    uint8_t error_no = m_gdb_comm.SendGDBStoppointTypePacket(\n        eBreakpointHardware, true, addr, bp_op_size);\n    if (error_no == 0) {\n      // The breakpoint was placed successfully\n      bp_site->SetEnabled(true);\n      bp_site->SetType(BreakpointSite::eHardware);\n      return error;\n    }\n\n    // Check if the error was something other then an unsupported breakpoint\n    // type\n    if (m_gdb_comm.SupportsGDBStoppointPacket(eBreakpointHardware)) {\n      // Unable to set this hardware breakpoint\n      if (error_no != UINT8_MAX)\n        error.SetErrorStringWithFormat(\n            \"error: %d sending the hardware breakpoint request \"\n            \"(hardware breakpoint resources might be exhausted or unavailable)\",\n            error_no);\n      else\n        error.SetErrorString(\"error sending the hardware breakpoint request \"\n                             \"(hardware breakpoint resources \"\n                             \"might be exhausted or unavailable)\");\n      return error;\n    }\n\n    // We will reach here when the stub gives an unsupported response to a\n    // hardware breakpoint\n    LLDB_LOGF(log, \"Hardware breakpoints are unsupported\");\n\n    // Finally we will falling through to a #trap style breakpoint\n  }\n\n  // Don't fall through when hardware breakpoints were specifically requested\n  if (bp_site->HardwareRequired()) {\n    error.SetErrorString(\"hardware breakpoints are not supported\");\n    return error;\n  }\n\n  // As a last resort we want to place a manual breakpoint. An instruction is\n  // placed into the process memory using memory write packets.\n  return EnableSoftwareBreakpoint(bp_site);\n}\n\nStatus ProcessGDBRemote::DisableBreakpointSite(BreakpointSite *bp_site) {\n  Status error;\n  assert(bp_site != nullptr);\n  addr_t addr = bp_site->GetLoadAddress();\n  user_id_t site_id = bp_site->GetID();\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_BREAKPOINTS));\n  LLDB_LOGF(log,\n            \"ProcessGDBRemote::DisableBreakpointSite (site_id = %\" PRIu64\n            \") addr = 0x%8.8\" PRIx64,\n            site_id, (uint64_t)addr);\n\n  if (bp_site->IsEnabled()) {\n    const size_t bp_op_size = GetSoftwareBreakpointTrapOpcode(bp_site);\n\n    BreakpointSite::Type bp_type = bp_site->GetType();\n    switch (bp_type) {\n    case BreakpointSite::eSoftware:\n      error = DisableSoftwareBreakpoint(bp_site);\n      break;\n\n    case BreakpointSite::eHardware:\n      if (m_gdb_comm.SendGDBStoppointTypePacket(eBreakpointHardware, false,\n                                                addr, bp_op_size))\n        error.SetErrorToGenericError();\n      break;\n\n    case BreakpointSite::eExternal: {\n      if (m_gdb_comm.SendGDBStoppointTypePacket(eBreakpointSoftware, false,\n                                                addr, bp_op_size))\n        error.SetErrorToGenericError();\n    } break;\n    }\n    if (error.Success())\n      bp_site->SetEnabled(false);\n  } else {\n    LLDB_LOGF(log,\n              \"ProcessGDBRemote::DisableBreakpointSite (site_id = %\" PRIu64\n              \") addr = 0x%8.8\" PRIx64 \" -- SUCCESS (already disabled)\",\n              site_id, (uint64_t)addr);\n    return error;\n  }\n\n  if (error.Success())\n    error.SetErrorToGenericError();\n  return error;\n}\n\n// Pre-requisite: wp != NULL.\nstatic GDBStoppointType GetGDBStoppointType(Watchpoint *wp) {\n  assert(wp);\n  bool watch_read = wp->WatchpointRead();\n  bool watch_write = wp->WatchpointWrite();\n\n  // watch_read and watch_write cannot both be false.\n  assert(watch_read || watch_write);\n  if (watch_read && watch_write)\n    return eWatchpointReadWrite;\n  else if (watch_read)\n    return eWatchpointRead;\n  else // Must be watch_write, then.\n    return eWatchpointWrite;\n}\n\nStatus ProcessGDBRemote::EnableWatchpoint(Watchpoint *wp, bool notify) {\n  Status error;\n  if (wp) {\n    user_id_t watchID = wp->GetID();\n    addr_t addr = wp->GetLoadAddress();\n    Log *log(\n        ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_WATCHPOINTS));\n    LLDB_LOGF(log, \"ProcessGDBRemote::EnableWatchpoint(watchID = %\" PRIu64 \")\",\n              watchID);\n    if (wp->IsEnabled()) {\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::EnableWatchpoint(watchID = %\" PRIu64\n                \") addr = 0x%8.8\" PRIx64 \": watchpoint already enabled.\",\n                watchID, (uint64_t)addr);\n      return error;\n    }\n\n    GDBStoppointType type = GetGDBStoppointType(wp);\n    // Pass down an appropriate z/Z packet...\n    if (m_gdb_comm.SupportsGDBStoppointPacket(type)) {\n      if (m_gdb_comm.SendGDBStoppointTypePacket(type, true, addr,\n                                                wp->GetByteSize()) == 0) {\n        wp->SetEnabled(true, notify);\n        return error;\n      } else\n        error.SetErrorString(\"sending gdb watchpoint packet failed\");\n    } else\n      error.SetErrorString(\"watchpoints not supported\");\n  } else {\n    error.SetErrorString(\"Watchpoint argument was NULL.\");\n  }\n  if (error.Success())\n    error.SetErrorToGenericError();\n  return error;\n}\n\nStatus ProcessGDBRemote::DisableWatchpoint(Watchpoint *wp, bool notify) {\n  Status error;\n  if (wp) {\n    user_id_t watchID = wp->GetID();\n\n    Log *log(\n        ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_WATCHPOINTS));\n\n    addr_t addr = wp->GetLoadAddress();\n\n    LLDB_LOGF(log,\n              \"ProcessGDBRemote::DisableWatchpoint (watchID = %\" PRIu64\n              \") addr = 0x%8.8\" PRIx64,\n              watchID, (uint64_t)addr);\n\n    if (!wp->IsEnabled()) {\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::DisableWatchpoint (watchID = %\" PRIu64\n                \") addr = 0x%8.8\" PRIx64 \" -- SUCCESS (already disabled)\",\n                watchID, (uint64_t)addr);\n      // See also 'class WatchpointSentry' within StopInfo.cpp. This disabling\n      // attempt might come from the user-supplied actions, we'll route it in\n      // order for the watchpoint object to intelligently process this action.\n      wp->SetEnabled(false, notify);\n      return error;\n    }\n\n    if (wp->IsHardware()) {\n      GDBStoppointType type = GetGDBStoppointType(wp);\n      // Pass down an appropriate z/Z packet...\n      if (m_gdb_comm.SendGDBStoppointTypePacket(type, false, addr,\n                                                wp->GetByteSize()) == 0) {\n        wp->SetEnabled(false, notify);\n        return error;\n      } else\n        error.SetErrorString(\"sending gdb watchpoint packet failed\");\n    }\n    // TODO: clear software watchpoints if we implement them\n  } else {\n    error.SetErrorString(\"Watchpoint argument was NULL.\");\n  }\n  if (error.Success())\n    error.SetErrorToGenericError();\n  return error;\n}\n\nvoid ProcessGDBRemote::Clear() {\n  m_thread_list_real.Clear();\n  m_thread_list.Clear();\n}\n\nStatus ProcessGDBRemote::DoSignal(int signo) {\n  Status error;\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  LLDB_LOGF(log, \"ProcessGDBRemote::DoSignal (signal = %d)\", signo);\n\n  if (!m_gdb_comm.SendAsyncSignal(signo))\n    error.SetErrorStringWithFormat(\"failed to send signal %i\", signo);\n  return error;\n}\n\nStatus ProcessGDBRemote::ConnectToReplayServer() {\n  Status status = m_gdb_replay_server.Connect(m_gdb_comm);\n  if (status.Fail())\n    return status;\n\n  // Enable replay mode.\n  m_replay_mode = true;\n\n  // Start server thread.\n  m_gdb_replay_server.StartAsyncThread();\n\n  // Start client thread.\n  StartAsyncThread();\n\n  // Do the usual setup.\n  return ConnectToDebugserver(\"\");\n}\n\nStatus\nProcessGDBRemote::EstablishConnectionIfNeeded(const ProcessInfo &process_info) {\n  // Make sure we aren't already connected?\n  if (m_gdb_comm.IsConnected())\n    return Status();\n\n  PlatformSP platform_sp(GetTarget().GetPlatform());\n  if (platform_sp && !platform_sp->IsHost())\n    return Status(\"Lost debug server connection\");\n\n  if (repro::Reproducer::Instance().IsReplaying())\n    return ConnectToReplayServer();\n\n  auto error = LaunchAndConnectToDebugserver(process_info);\n  if (error.Fail()) {\n    const char *error_string = error.AsCString();\n    if (error_string == nullptr)\n      error_string = \"unable to launch \" DEBUGSERVER_BASENAME;\n  }\n  return error;\n}\n#if !defined(_WIN32)\n#define USE_SOCKETPAIR_FOR_LOCAL_CONNECTION 1\n#endif\n\n#ifdef USE_SOCKETPAIR_FOR_LOCAL_CONNECTION\nstatic bool SetCloexecFlag(int fd) {\n#if defined(FD_CLOEXEC)\n  int flags = ::fcntl(fd, F_GETFD);\n  if (flags == -1)\n    return false;\n  return (::fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == 0);\n#else\n  return false;\n#endif\n}\n#endif\n\nStatus ProcessGDBRemote::LaunchAndConnectToDebugserver(\n    const ProcessInfo &process_info) {\n  using namespace std::placeholders; // For _1, _2, etc.\n\n  Status error;\n  if (m_debugserver_pid == LLDB_INVALID_PROCESS_ID) {\n    // If we locate debugserver, keep that located version around\n    static FileSpec g_debugserver_file_spec;\n\n    ProcessLaunchInfo debugserver_launch_info;\n    // Make debugserver run in its own session so signals generated by special\n    // terminal key sequences (^C) don't affect debugserver.\n    debugserver_launch_info.SetLaunchInSeparateProcessGroup(true);\n\n    const std::weak_ptr<ProcessGDBRemote> this_wp =\n        std::static_pointer_cast<ProcessGDBRemote>(shared_from_this());\n    debugserver_launch_info.SetMonitorProcessCallback(\n        std::bind(MonitorDebugserverProcess, this_wp, _1, _2, _3, _4), false);\n    debugserver_launch_info.SetUserID(process_info.GetUserID());\n\n#if defined(__APPLE__)\n    // On macOS 11, we need to support x86_64 applications translated to\n    // arm64. We check whether a binary is translated and spawn the correct\n    // debugserver accordingly.\n    int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PID,\n                  static_cast<int>(process_info.GetProcessID()) };\n    struct kinfo_proc processInfo;\n    size_t bufsize = sizeof(processInfo);\n    if (sysctl(mib, (unsigned)(sizeof(mib)/sizeof(int)), &processInfo,\n               &bufsize, NULL, 0) == 0 && bufsize > 0) {\n      if (processInfo.kp_proc.p_flag & P_TRANSLATED) {\n        FileSpec rosetta_debugserver(\"/Library/Apple/usr/libexec/oah/debugserver\");\n        debugserver_launch_info.SetExecutableFile(rosetta_debugserver, false);\n      }\n    }\n#endif\n\n    int communication_fd = -1;\n#ifdef USE_SOCKETPAIR_FOR_LOCAL_CONNECTION\n    // Use a socketpair on non-Windows systems for security and performance\n    // reasons.\n    int sockets[2]; /* the pair of socket descriptors */\n    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets) == -1) {\n      error.SetErrorToErrno();\n      return error;\n    }\n\n    int our_socket = sockets[0];\n    int gdb_socket = sockets[1];\n    auto cleanup_our = llvm::make_scope_exit([&]() { close(our_socket); });\n    auto cleanup_gdb = llvm::make_scope_exit([&]() { close(gdb_socket); });\n\n    // Don't let any child processes inherit our communication socket\n    SetCloexecFlag(our_socket);\n    communication_fd = gdb_socket;\n#endif\n\n    error = m_gdb_comm.StartDebugserverProcess(\n        nullptr, GetTarget().GetPlatform().get(), debugserver_launch_info,\n        nullptr, nullptr, communication_fd);\n\n    if (error.Success())\n      m_debugserver_pid = debugserver_launch_info.GetProcessID();\n    else\n      m_debugserver_pid = LLDB_INVALID_PROCESS_ID;\n\n    if (m_debugserver_pid != LLDB_INVALID_PROCESS_ID) {\n#ifdef USE_SOCKETPAIR_FOR_LOCAL_CONNECTION\n      // Our process spawned correctly, we can now set our connection to use\n      // our end of the socket pair\n      cleanup_our.release();\n      m_gdb_comm.SetConnection(\n          std::make_unique<ConnectionFileDescriptor>(our_socket, true));\n#endif\n      StartAsyncThread();\n    }\n\n    if (error.Fail()) {\n      Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n\n      LLDB_LOGF(log, \"failed to start debugserver process: %s\",\n                error.AsCString());\n      return error;\n    }\n\n    if (m_gdb_comm.IsConnected()) {\n      // Finish the connection process by doing the handshake without\n      // connecting (send NULL URL)\n      error = ConnectToDebugserver(\"\");\n    } else {\n      error.SetErrorString(\"connection failed\");\n    }\n  }\n  return error;\n}\n\nbool ProcessGDBRemote::MonitorDebugserverProcess(\n    std::weak_ptr<ProcessGDBRemote> process_wp, lldb::pid_t debugserver_pid,\n    bool exited,    // True if the process did exit\n    int signo,      // Zero for no signal\n    int exit_status // Exit value of process if signal is zero\n) {\n  // \"debugserver_pid\" argument passed in is the process ID for debugserver\n  // that we are tracking...\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  const bool handled = true;\n\n  LLDB_LOGF(log,\n            \"ProcessGDBRemote::%s(process_wp, pid=%\" PRIu64\n            \", signo=%i (0x%x), exit_status=%i)\",\n            __FUNCTION__, debugserver_pid, signo, signo, exit_status);\n\n  std::shared_ptr<ProcessGDBRemote> process_sp = process_wp.lock();\n  LLDB_LOGF(log, \"ProcessGDBRemote::%s(process = %p)\", __FUNCTION__,\n            static_cast<void *>(process_sp.get()));\n  if (!process_sp || process_sp->m_debugserver_pid != debugserver_pid)\n    return handled;\n\n  // Sleep for a half a second to make sure our inferior process has time to\n  // set its exit status before we set it incorrectly when both the debugserver\n  // and the inferior process shut down.\n  std::this_thread::sleep_for(std::chrono::milliseconds(500));\n\n  // If our process hasn't yet exited, debugserver might have died. If the\n  // process did exit, then we are reaping it.\n  const StateType state = process_sp->GetState();\n\n  if (state != eStateInvalid && state != eStateUnloaded &&\n      state != eStateExited && state != eStateDetached) {\n    char error_str[1024];\n    if (signo) {\n      const char *signal_cstr =\n          process_sp->GetUnixSignals()->GetSignalAsCString(signo);\n      if (signal_cstr)\n        ::snprintf(error_str, sizeof(error_str),\n                   DEBUGSERVER_BASENAME \" died with signal %s\", signal_cstr);\n      else\n        ::snprintf(error_str, sizeof(error_str),\n                   DEBUGSERVER_BASENAME \" died with signal %i\", signo);\n    } else {\n      ::snprintf(error_str, sizeof(error_str),\n                 DEBUGSERVER_BASENAME \" died with an exit status of 0x%8.8x\",\n                 exit_status);\n    }\n\n    process_sp->SetExitStatus(-1, error_str);\n  }\n  // Debugserver has exited we need to let our ProcessGDBRemote know that it no\n  // longer has a debugserver instance\n  process_sp->m_debugserver_pid = LLDB_INVALID_PROCESS_ID;\n  return handled;\n}\n\nvoid ProcessGDBRemote::KillDebugserverProcess() {\n  m_gdb_comm.Disconnect();\n  if (m_debugserver_pid != LLDB_INVALID_PROCESS_ID) {\n    Host::Kill(m_debugserver_pid, SIGINT);\n    m_debugserver_pid = LLDB_INVALID_PROCESS_ID;\n  }\n}\n\nvoid ProcessGDBRemote::Initialize() {\n  static llvm::once_flag g_once_flag;\n\n  llvm::call_once(g_once_flag, []() {\n    PluginManager::RegisterPlugin(GetPluginNameStatic(),\n                                  GetPluginDescriptionStatic(), CreateInstance,\n                                  DebuggerInitialize);\n  });\n}\n\nvoid ProcessGDBRemote::DebuggerInitialize(Debugger &debugger) {\n  if (!PluginManager::GetSettingForProcessPlugin(\n          debugger, PluginProperties::GetSettingName())) {\n    const bool is_global_setting = true;\n    PluginManager::CreateSettingForProcessPlugin(\n        debugger, GetGlobalPluginProperties()->GetValueProperties(),\n        ConstString(\"Properties for the gdb-remote process plug-in.\"),\n        is_global_setting);\n  }\n}\n\nbool ProcessGDBRemote::StartAsyncThread() {\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n\n  LLDB_LOGF(log, \"ProcessGDBRemote::%s ()\", __FUNCTION__);\n\n  std::lock_guard<std::recursive_mutex> guard(m_async_thread_state_mutex);\n  if (!m_async_thread.IsJoinable()) {\n    // Create a thread that watches our internal state and controls which\n    // events make it to clients (into the DCProcess event queue).\n\n    llvm::Expected<HostThread> async_thread = ThreadLauncher::LaunchThread(\n        \"<lldb.process.gdb-remote.async>\", ProcessGDBRemote::AsyncThread, this);\n    if (!async_thread) {\n      LLDB_LOG_ERROR(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_HOST),\n                     async_thread.takeError(),\n                     \"failed to launch host thread: {}\");\n      return false;\n    }\n    m_async_thread = *async_thread;\n  } else\n    LLDB_LOGF(log,\n              \"ProcessGDBRemote::%s () - Called when Async thread was \"\n              \"already running.\",\n              __FUNCTION__);\n\n  return m_async_thread.IsJoinable();\n}\n\nvoid ProcessGDBRemote::StopAsyncThread() {\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n\n  LLDB_LOGF(log, \"ProcessGDBRemote::%s ()\", __FUNCTION__);\n\n  std::lock_guard<std::recursive_mutex> guard(m_async_thread_state_mutex);\n  if (m_async_thread.IsJoinable()) {\n    m_async_broadcaster.BroadcastEvent(eBroadcastBitAsyncThreadShouldExit);\n\n    //  This will shut down the async thread.\n    m_gdb_comm.Disconnect(); // Disconnect from the debug server.\n\n    // Stop the stdio thread\n    m_async_thread.Join(nullptr);\n    m_async_thread.Reset();\n  } else\n    LLDB_LOGF(\n        log,\n        \"ProcessGDBRemote::%s () - Called when Async thread was not running.\",\n        __FUNCTION__);\n}\n\nbool ProcessGDBRemote::HandleNotifyPacket(StringExtractorGDBRemote &packet) {\n  // get the packet at a string\n  const std::string &pkt = std::string(packet.GetStringRef());\n  // skip %stop:\n  StringExtractorGDBRemote stop_info(pkt.c_str() + 5);\n\n  // pass as a thread stop info packet\n  SetLastStopPacket(stop_info);\n\n  // check for more stop reasons\n  HandleStopReplySequence();\n\n  // if the process is stopped then we need to fake a resume so that we can\n  // stop properly with the new break. This is possible due to\n  // SetPrivateState() broadcasting the state change as a side effect.\n  if (GetPrivateState() == lldb::StateType::eStateStopped) {\n    SetPrivateState(lldb::StateType::eStateRunning);\n  }\n\n  // since we have some stopped packets we can halt the process\n  SetPrivateState(lldb::StateType::eStateStopped);\n\n  return true;\n}\n\nthread_result_t ProcessGDBRemote::AsyncThread(void *arg) {\n  ProcessGDBRemote *process = (ProcessGDBRemote *)arg;\n\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  LLDB_LOGF(log,\n            \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n            \") thread starting...\",\n            __FUNCTION__, arg, process->GetID());\n\n  EventSP event_sp;\n\n  // We need to ignore any packets that come in after we have\n  // have decided the process has exited.  There are some\n  // situations, for instance when we try to interrupt a running\n  // process and the interrupt fails, where another packet might\n  // get delivered after we've decided to give up on the process.\n  // But once we've decided we are done with the process we will\n  // not be in a state to do anything useful with new packets.\n  // So it is safer to simply ignore any remaining packets by\n  // explicitly checking for eStateExited before reentering the\n  // fetch loop.\n  \n  bool done = false;\n  while (!done && process->GetPrivateState() != eStateExited) {\n    LLDB_LOGF(log,\n              \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n              \") listener.WaitForEvent (NULL, event_sp)...\",\n              __FUNCTION__, arg, process->GetID());\n\n    if (process->m_async_listener_sp->GetEvent(event_sp, llvm::None)) {\n      const uint32_t event_type = event_sp->GetType();\n      if (event_sp->BroadcasterIs(&process->m_async_broadcaster)) {\n        LLDB_LOGF(log,\n                  \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n                  \") Got an event of type: %d...\",\n                  __FUNCTION__, arg, process->GetID(), event_type);\n\n        switch (event_type) {\n        case eBroadcastBitAsyncContinue: {\n          const EventDataBytes *continue_packet =\n              EventDataBytes::GetEventDataFromEvent(event_sp.get());\n\n          if (continue_packet) {\n            const char *continue_cstr =\n                (const char *)continue_packet->GetBytes();\n            const size_t continue_cstr_len = continue_packet->GetByteSize();\n            LLDB_LOGF(log,\n                      \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n                      \") got eBroadcastBitAsyncContinue: %s\",\n                      __FUNCTION__, arg, process->GetID(), continue_cstr);\n\n            if (::strstr(continue_cstr, \"vAttach\") == nullptr)\n              process->SetPrivateState(eStateRunning);\n            StringExtractorGDBRemote response;\n\n            // If in Non-Stop-Mode\n            if (process->GetTarget().GetNonStopModeEnabled()) {\n              // send the vCont packet\n              if (!process->GetGDBRemote().SendvContPacket(\n                      llvm::StringRef(continue_cstr, continue_cstr_len),\n                      response)) {\n                // Something went wrong\n                done = true;\n                break;\n              }\n            }\n            // If in All-Stop-Mode\n            else {\n              StateType stop_state =\n                  process->GetGDBRemote().SendContinuePacketAndWaitForResponse(\n                      *process, *process->GetUnixSignals(),\n                      llvm::StringRef(continue_cstr, continue_cstr_len),\n                      response);\n\n              // We need to immediately clear the thread ID list so we are sure\n              // to get a valid list of threads. The thread ID list might be\n              // contained within the \"response\", or the stop reply packet that\n              // caused the stop. So clear it now before we give the stop reply\n              // packet to the process using the\n              // process->SetLastStopPacket()...\n              process->ClearThreadIDList();\n\n              switch (stop_state) {\n              case eStateStopped:\n              case eStateCrashed:\n              case eStateSuspended:\n                process->SetLastStopPacket(response);\n                process->SetPrivateState(stop_state);\n                break;\n\n              case eStateExited: {\n                process->SetLastStopPacket(response);\n                process->ClearThreadIDList();\n                response.SetFilePos(1);\n\n                int exit_status = response.GetHexU8();\n                std::string desc_string;\n                if (response.GetBytesLeft() > 0 &&\n                    response.GetChar('-') == ';') {\n                  llvm::StringRef desc_str;\n                  llvm::StringRef desc_token;\n                  while (response.GetNameColonValue(desc_token, desc_str)) {\n                    if (desc_token != \"description\")\n                      continue;\n                    StringExtractor extractor(desc_str);\n                    extractor.GetHexByteString(desc_string);\n                  }\n                }\n                process->SetExitStatus(exit_status, desc_string.c_str());\n                done = true;\n                break;\n              }\n              case eStateInvalid: {\n                // Check to see if we were trying to attach and if we got back\n                // the \"E87\" error code from debugserver -- this indicates that\n                // the process is not debuggable.  Return a slightly more\n                // helpful error message about why the attach failed.\n                if (::strstr(continue_cstr, \"vAttach\") != nullptr &&\n                    response.GetError() == 0x87) {\n                  process->SetExitStatus(-1, \"cannot attach to process due to \"\n                                             \"System Integrity Protection\");\n                } else if (::strstr(continue_cstr, \"vAttach\") != nullptr &&\n                           response.GetStatus().Fail()) {\n                  process->SetExitStatus(-1, response.GetStatus().AsCString());\n                } else {\n                  process->SetExitStatus(-1, \"lost connection\");\n                }\n                done = true;\n                break;\n              }\n\n              default:\n                process->SetPrivateState(stop_state);\n                break;\n              } // switch(stop_state)\n            }   // else // if in All-stop-mode\n          }     // if (continue_packet)\n        }       // case eBroadcastBitAsyncContinue\n        break;\n\n        case eBroadcastBitAsyncThreadShouldExit:\n          LLDB_LOGF(log,\n                    \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n                    \") got eBroadcastBitAsyncThreadShouldExit...\",\n                    __FUNCTION__, arg, process->GetID());\n          done = true;\n          break;\n\n        default:\n          LLDB_LOGF(log,\n                    \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n                    \") got unknown event 0x%8.8x\",\n                    __FUNCTION__, arg, process->GetID(), event_type);\n          done = true;\n          break;\n        }\n      } else if (event_sp->BroadcasterIs(&process->m_gdb_comm)) {\n        switch (event_type) {\n        case Communication::eBroadcastBitReadThreadDidExit:\n          process->SetExitStatus(-1, \"lost connection\");\n          done = true;\n          break;\n\n        case GDBRemoteCommunication::eBroadcastBitGdbReadThreadGotNotify: {\n          lldb_private::Event *event = event_sp.get();\n          const EventDataBytes *continue_packet =\n              EventDataBytes::GetEventDataFromEvent(event);\n          StringExtractorGDBRemote notify(\n              (const char *)continue_packet->GetBytes());\n          // Hand this over to the process to handle\n          process->HandleNotifyPacket(notify);\n          break;\n        }\n\n        default:\n          LLDB_LOGF(log,\n                    \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n                    \") got unknown event 0x%8.8x\",\n                    __FUNCTION__, arg, process->GetID(), event_type);\n          done = true;\n          break;\n        }\n      }\n    } else {\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n                \") listener.WaitForEvent (NULL, event_sp) => false\",\n                __FUNCTION__, arg, process->GetID());\n      done = true;\n    }\n  }\n\n  LLDB_LOGF(log,\n            \"ProcessGDBRemote::%s (arg = %p, pid = %\" PRIu64\n            \") thread exiting...\",\n            __FUNCTION__, arg, process->GetID());\n\n  return {};\n}\n\n// uint32_t\n// ProcessGDBRemote::ListProcessesMatchingName (const char *name, StringList\n// &matches, std::vector<lldb::pid_t> &pids)\n//{\n//    // If we are planning to launch the debugserver remotely, then we need to\n//    fire up a debugserver\n//    // process and ask it for the list of processes. But if we are local, we\n//    can let the Host do it.\n//    if (m_local_debugserver)\n//    {\n//        return Host::ListProcessesMatchingName (name, matches, pids);\n//    }\n//    else\n//    {\n//        // FIXME: Implement talking to the remote debugserver.\n//        return 0;\n//    }\n//\n//}\n//\nbool ProcessGDBRemote::NewThreadNotifyBreakpointHit(\n    void *baton, StoppointCallbackContext *context, lldb::user_id_t break_id,\n    lldb::user_id_t break_loc_id) {\n  // I don't think I have to do anything here, just make sure I notice the new\n  // thread when it starts to\n  // run so I can stop it if that's what I want to do.\n  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));\n  LLDB_LOGF(log, \"Hit New Thread Notification breakpoint.\");\n  return false;\n}\n\nStatus ProcessGDBRemote::UpdateAutomaticSignalFiltering() {\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n  LLDB_LOG(log, \"Check if need to update ignored signals\");\n\n  // QPassSignals package is not supported by the server, there is no way we\n  // can ignore any signals on server side.\n  if (!m_gdb_comm.GetQPassSignalsSupported())\n    return Status();\n\n  // No signals, nothing to send.\n  if (m_unix_signals_sp == nullptr)\n    return Status();\n\n  // Signals' version hasn't changed, no need to send anything.\n  uint64_t new_signals_version = m_unix_signals_sp->GetVersion();\n  if (new_signals_version == m_last_signals_version) {\n    LLDB_LOG(log, \"Signals' version hasn't changed. version={0}\",\n             m_last_signals_version);\n    return Status();\n  }\n\n  auto signals_to_ignore =\n      m_unix_signals_sp->GetFilteredSignals(false, false, false);\n  Status error = m_gdb_comm.SendSignalsToIgnore(signals_to_ignore);\n\n  LLDB_LOG(log,\n           \"Signals' version changed. old version={0}, new version={1}, \"\n           \"signals ignored={2}, update result={3}\",\n           m_last_signals_version, new_signals_version,\n           signals_to_ignore.size(), error);\n\n  if (error.Success())\n    m_last_signals_version = new_signals_version;\n\n  return error;\n}\n\nbool ProcessGDBRemote::StartNoticingNewThreads() {\n  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));\n  if (m_thread_create_bp_sp) {\n    if (log && log->GetVerbose())\n      LLDB_LOGF(log, \"Enabled noticing new thread breakpoint.\");\n    m_thread_create_bp_sp->SetEnabled(true);\n  } else {\n    PlatformSP platform_sp(GetTarget().GetPlatform());\n    if (platform_sp) {\n      m_thread_create_bp_sp =\n          platform_sp->SetThreadCreationBreakpoint(GetTarget());\n      if (m_thread_create_bp_sp) {\n        if (log && log->GetVerbose())\n          LLDB_LOGF(\n              log, \"Successfully created new thread notification breakpoint %i\",\n              m_thread_create_bp_sp->GetID());\n        m_thread_create_bp_sp->SetCallback(\n            ProcessGDBRemote::NewThreadNotifyBreakpointHit, this, true);\n      } else {\n        LLDB_LOGF(log, \"Failed to create new thread notification breakpoint.\");\n      }\n    }\n  }\n  return m_thread_create_bp_sp.get() != nullptr;\n}\n\nbool ProcessGDBRemote::StopNoticingNewThreads() {\n  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));\n  if (log && log->GetVerbose())\n    LLDB_LOGF(log, \"Disabling new thread notification breakpoint.\");\n\n  if (m_thread_create_bp_sp)\n    m_thread_create_bp_sp->SetEnabled(false);\n\n  return true;\n}\n\nDynamicLoader *ProcessGDBRemote::GetDynamicLoader() {\n  if (m_dyld_up.get() == nullptr)\n    m_dyld_up.reset(DynamicLoader::FindPlugin(this, nullptr));\n  return m_dyld_up.get();\n}\n\nStatus ProcessGDBRemote::SendEventData(const char *data) {\n  int return_value;\n  bool was_supported;\n\n  Status error;\n\n  return_value = m_gdb_comm.SendLaunchEventDataPacket(data, &was_supported);\n  if (return_value != 0) {\n    if (!was_supported)\n      error.SetErrorString(\"Sending events is not supported for this process.\");\n    else\n      error.SetErrorStringWithFormat(\"Error sending event data: %d.\",\n                                     return_value);\n  }\n  return error;\n}\n\nDataExtractor ProcessGDBRemote::GetAuxvData() {\n  DataBufferSP buf;\n  if (m_gdb_comm.GetQXferAuxvReadSupported()) {\n    std::string response_string;\n    if (m_gdb_comm.SendPacketsAndConcatenateResponses(\"qXfer:auxv:read::\",\n                                                      response_string) ==\n        GDBRemoteCommunication::PacketResult::Success)\n      buf = std::make_shared<DataBufferHeap>(response_string.c_str(),\n                                             response_string.length());\n  }\n  return DataExtractor(buf, GetByteOrder(), GetAddressByteSize());\n}\n\nStructuredData::ObjectSP\nProcessGDBRemote::GetExtendedInfoForThread(lldb::tid_t tid) {\n  StructuredData::ObjectSP object_sp;\n\n  if (m_gdb_comm.GetThreadExtendedInfoSupported()) {\n    StructuredData::ObjectSP args_dict(new StructuredData::Dictionary());\n    SystemRuntime *runtime = GetSystemRuntime();\n    if (runtime) {\n      runtime->AddThreadExtendedInfoPacketHints(args_dict);\n    }\n    args_dict->GetAsDictionary()->AddIntegerItem(\"thread\", tid);\n\n    StreamString packet;\n    packet << \"jThreadExtendedInfo:\";\n    args_dict->Dump(packet, false);\n\n    // FIXME the final character of a JSON dictionary, '}', is the escape\n    // character in gdb-remote binary mode.  lldb currently doesn't escape\n    // these characters in its packet output -- so we add the quoted version of\n    // the } character here manually in case we talk to a debugserver which un-\n    // escapes the characters at packet read time.\n    packet << (char)(0x7d ^ 0x20);\n\n    StringExtractorGDBRemote response;\n    response.SetResponseValidatorToJSON();\n    if (m_gdb_comm.SendPacketAndWaitForResponse(packet.GetString(), response,\n                                                false) ==\n        GDBRemoteCommunication::PacketResult::Success) {\n      StringExtractorGDBRemote::ResponseType response_type =\n          response.GetResponseType();\n      if (response_type == StringExtractorGDBRemote::eResponse) {\n        if (!response.Empty()) {\n          object_sp =\n              StructuredData::ParseJSON(std::string(response.GetStringRef()));\n        }\n      }\n    }\n  }\n  return object_sp;\n}\n\nStructuredData::ObjectSP ProcessGDBRemote::GetLoadedDynamicLibrariesInfos(\n    lldb::addr_t image_list_address, lldb::addr_t image_count) {\n\n  StructuredData::ObjectSP args_dict(new StructuredData::Dictionary());\n  args_dict->GetAsDictionary()->AddIntegerItem(\"image_list_address\",\n                                               image_list_address);\n  args_dict->GetAsDictionary()->AddIntegerItem(\"image_count\", image_count);\n\n  return GetLoadedDynamicLibrariesInfos_sender(args_dict);\n}\n\nStructuredData::ObjectSP ProcessGDBRemote::GetLoadedDynamicLibrariesInfos() {\n  StructuredData::ObjectSP args_dict(new StructuredData::Dictionary());\n\n  args_dict->GetAsDictionary()->AddBooleanItem(\"fetch_all_solibs\", true);\n\n  return GetLoadedDynamicLibrariesInfos_sender(args_dict);\n}\n\nStructuredData::ObjectSP ProcessGDBRemote::GetLoadedDynamicLibrariesInfos(\n    const std::vector<lldb::addr_t> &load_addresses) {\n  StructuredData::ObjectSP args_dict(new StructuredData::Dictionary());\n  StructuredData::ArraySP addresses(new StructuredData::Array);\n\n  for (auto addr : load_addresses) {\n    StructuredData::ObjectSP addr_sp(new StructuredData::Integer(addr));\n    addresses->AddItem(addr_sp);\n  }\n\n  args_dict->GetAsDictionary()->AddItem(\"solib_addresses\", addresses);\n\n  return GetLoadedDynamicLibrariesInfos_sender(args_dict);\n}\n\nStructuredData::ObjectSP\nProcessGDBRemote::GetLoadedDynamicLibrariesInfos_sender(\n    StructuredData::ObjectSP args_dict) {\n  StructuredData::ObjectSP object_sp;\n\n  if (m_gdb_comm.GetLoadedDynamicLibrariesInfosSupported()) {\n    // Scope for the scoped timeout object\n    GDBRemoteCommunication::ScopedTimeout timeout(m_gdb_comm,\n                                                  std::chrono::seconds(10));\n\n    StreamString packet;\n    packet << \"jGetLoadedDynamicLibrariesInfos:\";\n    args_dict->Dump(packet, false);\n\n    // FIXME the final character of a JSON dictionary, '}', is the escape\n    // character in gdb-remote binary mode.  lldb currently doesn't escape\n    // these characters in its packet output -- so we add the quoted version of\n    // the } character here manually in case we talk to a debugserver which un-\n    // escapes the characters at packet read time.\n    packet << (char)(0x7d ^ 0x20);\n\n    StringExtractorGDBRemote response;\n    response.SetResponseValidatorToJSON();\n    if (m_gdb_comm.SendPacketAndWaitForResponse(packet.GetString(), response,\n                                                false) ==\n        GDBRemoteCommunication::PacketResult::Success) {\n      StringExtractorGDBRemote::ResponseType response_type =\n          response.GetResponseType();\n      if (response_type == StringExtractorGDBRemote::eResponse) {\n        if (!response.Empty()) {\n          object_sp =\n              StructuredData::ParseJSON(std::string(response.GetStringRef()));\n        }\n      }\n    }\n  }\n  return object_sp;\n}\n\nStructuredData::ObjectSP ProcessGDBRemote::GetSharedCacheInfo() {\n  StructuredData::ObjectSP object_sp;\n  StructuredData::ObjectSP args_dict(new StructuredData::Dictionary());\n\n  if (m_gdb_comm.GetSharedCacheInfoSupported()) {\n    StreamString packet;\n    packet << \"jGetSharedCacheInfo:\";\n    args_dict->Dump(packet, false);\n\n    // FIXME the final character of a JSON dictionary, '}', is the escape\n    // character in gdb-remote binary mode.  lldb currently doesn't escape\n    // these characters in its packet output -- so we add the quoted version of\n    // the } character here manually in case we talk to a debugserver which un-\n    // escapes the characters at packet read time.\n    packet << (char)(0x7d ^ 0x20);\n\n    StringExtractorGDBRemote response;\n    response.SetResponseValidatorToJSON();\n    if (m_gdb_comm.SendPacketAndWaitForResponse(packet.GetString(), response,\n                                                false) ==\n        GDBRemoteCommunication::PacketResult::Success) {\n      StringExtractorGDBRemote::ResponseType response_type =\n          response.GetResponseType();\n      if (response_type == StringExtractorGDBRemote::eResponse) {\n        if (!response.Empty()) {\n          object_sp =\n              StructuredData::ParseJSON(std::string(response.GetStringRef()));\n        }\n      }\n    }\n  }\n  return object_sp;\n}\n\nStatus ProcessGDBRemote::ConfigureStructuredData(\n    ConstString type_name, const StructuredData::ObjectSP &config_sp) {\n  return m_gdb_comm.ConfigureRemoteStructuredData(type_name, config_sp);\n}\n\n// Establish the largest memory read/write payloads we should use. If the\n// remote stub has a max packet size, stay under that size.\n//\n// If the remote stub's max packet size is crazy large, use a reasonable\n// largeish default.\n//\n// If the remote stub doesn't advertise a max packet size, use a conservative\n// default.\n\nvoid ProcessGDBRemote::GetMaxMemorySize() {\n  const uint64_t reasonable_largeish_default = 128 * 1024;\n  const uint64_t conservative_default = 512;\n\n  if (m_max_memory_size == 0) {\n    uint64_t stub_max_size = m_gdb_comm.GetRemoteMaxPacketSize();\n    if (stub_max_size != UINT64_MAX && stub_max_size != 0) {\n      // Save the stub's claimed maximum packet size\n      m_remote_stub_max_memory_size = stub_max_size;\n\n      // Even if the stub says it can support ginormous packets, don't exceed\n      // our reasonable largeish default packet size.\n      if (stub_max_size > reasonable_largeish_default) {\n        stub_max_size = reasonable_largeish_default;\n      }\n\n      // Memory packet have other overheads too like Maddr,size:#NN Instead of\n      // calculating the bytes taken by size and addr every time, we take a\n      // maximum guess here.\n      if (stub_max_size > 70)\n        stub_max_size -= 32 + 32 + 6;\n      else {\n        // In unlikely scenario that max packet size is less then 70, we will\n        // hope that data being written is small enough to fit.\n        Log *log(ProcessGDBRemoteLog::GetLogIfAnyCategoryIsSet(\n            GDBR_LOG_COMM | GDBR_LOG_MEMORY));\n        if (log)\n          log->Warning(\"Packet size is too small. \"\n                       \"LLDB may face problems while writing memory\");\n      }\n\n      m_max_memory_size = stub_max_size;\n    } else {\n      m_max_memory_size = conservative_default;\n    }\n  }\n}\n\nvoid ProcessGDBRemote::SetUserSpecifiedMaxMemoryTransferSize(\n    uint64_t user_specified_max) {\n  if (user_specified_max != 0) {\n    GetMaxMemorySize();\n\n    if (m_remote_stub_max_memory_size != 0) {\n      if (m_remote_stub_max_memory_size < user_specified_max) {\n        m_max_memory_size = m_remote_stub_max_memory_size; // user specified a\n                                                           // packet size too\n                                                           // big, go as big\n        // as the remote stub says we can go.\n      } else {\n        m_max_memory_size = user_specified_max; // user's packet size is good\n      }\n    } else {\n      m_max_memory_size =\n          user_specified_max; // user's packet size is probably fine\n    }\n  }\n}\n\nbool ProcessGDBRemote::GetModuleSpec(const FileSpec &module_file_spec,\n                                     const ArchSpec &arch,\n                                     ModuleSpec &module_spec) {\n  Log *log = GetLogIfAnyCategoriesSet(LIBLLDB_LOG_PLATFORM);\n\n  const ModuleCacheKey key(module_file_spec.GetPath(),\n                           arch.GetTriple().getTriple());\n  auto cached = m_cached_module_specs.find(key);\n  if (cached != m_cached_module_specs.end()) {\n    module_spec = cached->second;\n    return bool(module_spec);\n  }\n\n  if (!m_gdb_comm.GetModuleInfo(module_file_spec, arch, module_spec)) {\n    LLDB_LOGF(log, \"ProcessGDBRemote::%s - failed to get module info for %s:%s\",\n              __FUNCTION__, module_file_spec.GetPath().c_str(),\n              arch.GetTriple().getTriple().c_str());\n    return false;\n  }\n\n  if (log) {\n    StreamString stream;\n    module_spec.Dump(stream);\n    LLDB_LOGF(log, \"ProcessGDBRemote::%s - got module info for (%s:%s) : %s\",\n              __FUNCTION__, module_file_spec.GetPath().c_str(),\n              arch.GetTriple().getTriple().c_str(), stream.GetData());\n  }\n\n  m_cached_module_specs[key] = module_spec;\n  return true;\n}\n\nvoid ProcessGDBRemote::PrefetchModuleSpecs(\n    llvm::ArrayRef<FileSpec> module_file_specs, const llvm::Triple &triple) {\n  auto module_specs = m_gdb_comm.GetModulesInfo(module_file_specs, triple);\n  if (module_specs) {\n    for (const FileSpec &spec : module_file_specs)\n      m_cached_module_specs[ModuleCacheKey(spec.GetPath(),\n                                           triple.getTriple())] = ModuleSpec();\n    for (const ModuleSpec &spec : *module_specs)\n      m_cached_module_specs[ModuleCacheKey(spec.GetFileSpec().GetPath(),\n                                           triple.getTriple())] = spec;\n  }\n}\n\nllvm::VersionTuple ProcessGDBRemote::GetHostOSVersion() {\n  return m_gdb_comm.GetOSVersion();\n}\n\nllvm::VersionTuple ProcessGDBRemote::GetHostMacCatalystVersion() {\n  return m_gdb_comm.GetMacCatalystVersion();\n}\n\nnamespace {\n\ntypedef std::vector<std::string> stringVec;\n\ntypedef std::vector<struct GdbServerRegisterInfo> GDBServerRegisterVec;\nstruct RegisterSetInfo {\n  ConstString name;\n};\n\ntypedef std::map<uint32_t, RegisterSetInfo> RegisterSetMap;\n\nstruct GdbServerTargetInfo {\n  std::string arch;\n  std::string osabi;\n  stringVec includes;\n  RegisterSetMap reg_set_map;\n};\n\nbool ParseRegisters(XMLNode feature_node, GdbServerTargetInfo &target_info,\n                    GDBRemoteDynamicRegisterInfo &dyn_reg_info, ABISP abi_sp,\n                    uint32_t &reg_num_remote, uint32_t &reg_num_local) {\n  if (!feature_node)\n    return false;\n\n  uint32_t reg_offset = LLDB_INVALID_INDEX32;\n  feature_node.ForEachChildElementWithName(\n      \"reg\", [&target_info, &dyn_reg_info, &reg_num_remote, &reg_num_local,\n              &reg_offset, &abi_sp](const XMLNode &reg_node) -> bool {\n        std::string gdb_group;\n        std::string gdb_type;\n        ConstString reg_name;\n        ConstString alt_name;\n        ConstString set_name;\n        std::vector<uint32_t> value_regs;\n        std::vector<uint32_t> invalidate_regs;\n        std::vector<uint8_t> dwarf_opcode_bytes;\n        bool encoding_set = false;\n        bool format_set = false;\n        RegisterInfo reg_info = {\n            nullptr,       // Name\n            nullptr,       // Alt name\n            0,             // byte size\n            reg_offset,    // offset\n            eEncodingUint, // encoding\n            eFormatHex,    // format\n            {\n                LLDB_INVALID_REGNUM, // eh_frame reg num\n                LLDB_INVALID_REGNUM, // DWARF reg num\n                LLDB_INVALID_REGNUM, // generic reg num\n                reg_num_remote,      // process plugin reg num\n                reg_num_local        // native register number\n            },\n            nullptr,\n            nullptr,\n            nullptr, // Dwarf Expression opcode bytes pointer\n            0        // Dwarf Expression opcode bytes length\n        };\n\n        reg_node.ForEachAttribute([&target_info, &gdb_group, &gdb_type,\n                                   &reg_name, &alt_name, &set_name, &value_regs,\n                                   &invalidate_regs, &encoding_set, &format_set,\n                                   &reg_info, &reg_offset, &dwarf_opcode_bytes](\n                                      const llvm::StringRef &name,\n                                      const llvm::StringRef &value) -> bool {\n          if (name == \"name\") {\n            reg_name.SetString(value);\n          } else if (name == \"bitsize\") {\n            reg_info.byte_size =\n                StringConvert::ToUInt32(value.data(), 0, 0) / CHAR_BIT;\n          } else if (name == \"type\") {\n            gdb_type = value.str();\n          } else if (name == \"group\") {\n            gdb_group = value.str();\n          } else if (name == \"regnum\") {\n            const uint32_t regnum =\n                StringConvert::ToUInt32(value.data(), LLDB_INVALID_REGNUM, 0);\n            if (regnum != LLDB_INVALID_REGNUM) {\n              reg_info.kinds[eRegisterKindProcessPlugin] = regnum;\n            }\n          } else if (name == \"offset\") {\n            reg_offset = StringConvert::ToUInt32(value.data(), UINT32_MAX, 0);\n          } else if (name == \"altname\") {\n            alt_name.SetString(value);\n          } else if (name == \"encoding\") {\n            encoding_set = true;\n            reg_info.encoding = Args::StringToEncoding(value, eEncodingUint);\n          } else if (name == \"format\") {\n            format_set = true;\n            Format format = eFormatInvalid;\n            if (OptionArgParser::ToFormat(value.data(), format, nullptr)\n                    .Success())\n              reg_info.format = format;\n            else if (value == \"vector-sint8\")\n              reg_info.format = eFormatVectorOfSInt8;\n            else if (value == \"vector-uint8\")\n              reg_info.format = eFormatVectorOfUInt8;\n            else if (value == \"vector-sint16\")\n              reg_info.format = eFormatVectorOfSInt16;\n            else if (value == \"vector-uint16\")\n              reg_info.format = eFormatVectorOfUInt16;\n            else if (value == \"vector-sint32\")\n              reg_info.format = eFormatVectorOfSInt32;\n            else if (value == \"vector-uint32\")\n              reg_info.format = eFormatVectorOfUInt32;\n            else if (value == \"vector-float32\")\n              reg_info.format = eFormatVectorOfFloat32;\n            else if (value == \"vector-uint64\")\n              reg_info.format = eFormatVectorOfUInt64;\n            else if (value == \"vector-uint128\")\n              reg_info.format = eFormatVectorOfUInt128;\n          } else if (name == \"group_id\") {\n            const uint32_t set_id =\n                StringConvert::ToUInt32(value.data(), UINT32_MAX, 0);\n            RegisterSetMap::const_iterator pos =\n                target_info.reg_set_map.find(set_id);\n            if (pos != target_info.reg_set_map.end())\n              set_name = pos->second.name;\n          } else if (name == \"gcc_regnum\" || name == \"ehframe_regnum\") {\n            reg_info.kinds[eRegisterKindEHFrame] =\n                StringConvert::ToUInt32(value.data(), LLDB_INVALID_REGNUM, 0);\n          } else if (name == \"dwarf_regnum\") {\n            reg_info.kinds[eRegisterKindDWARF] =\n                StringConvert::ToUInt32(value.data(), LLDB_INVALID_REGNUM, 0);\n          } else if (name == \"generic\") {\n            reg_info.kinds[eRegisterKindGeneric] =\n                Args::StringToGenericRegister(value);\n          } else if (name == \"value_regnums\") {\n            SplitCommaSeparatedRegisterNumberString(value, value_regs, 0);\n          } else if (name == \"invalidate_regnums\") {\n            SplitCommaSeparatedRegisterNumberString(value, invalidate_regs, 0);\n          } else if (name == \"dynamic_size_dwarf_expr_bytes\") {\n            std::string opcode_string = value.str();\n            size_t dwarf_opcode_len = opcode_string.length() / 2;\n            assert(dwarf_opcode_len > 0);\n\n            dwarf_opcode_bytes.resize(dwarf_opcode_len);\n            reg_info.dynamic_size_dwarf_len = dwarf_opcode_len;\n            StringExtractor opcode_extractor(opcode_string);\n            uint32_t ret_val =\n                opcode_extractor.GetHexBytesAvail(dwarf_opcode_bytes);\n            assert(dwarf_opcode_len == ret_val);\n            UNUSED_IF_ASSERT_DISABLED(ret_val);\n            reg_info.dynamic_size_dwarf_expr_bytes = dwarf_opcode_bytes.data();\n          } else {\n            printf(\"unhandled attribute %s = %s\\n\", name.data(), value.data());\n          }\n          return true; // Keep iterating through all attributes\n        });\n\n        if (!gdb_type.empty() && !(encoding_set || format_set)) {\n          if (llvm::StringRef(gdb_type).startswith(\"int\")) {\n            reg_info.format = eFormatHex;\n            reg_info.encoding = eEncodingUint;\n          } else if (gdb_type == \"data_ptr\" || gdb_type == \"code_ptr\") {\n            reg_info.format = eFormatAddressInfo;\n            reg_info.encoding = eEncodingUint;\n          } else if (gdb_type == \"i387_ext\" || gdb_type == \"float\") {\n            reg_info.format = eFormatFloat;\n            reg_info.encoding = eEncodingIEEE754;\n          }\n        }\n\n        // Only update the register set name if we didn't get a \"reg_set\"\n        // attribute. \"set_name\" will be empty if we didn't have a \"reg_set\"\n        // attribute.\n        if (!set_name) {\n          if (!gdb_group.empty()) {\n            set_name.SetCString(gdb_group.c_str());\n          } else {\n            // If no register group name provided anywhere,\n            // we'll create a 'general' register set\n            set_name.SetCString(\"general\");\n          }\n        }\n\n        reg_info.byte_offset = reg_offset;\n        assert(reg_info.byte_size != 0);\n        reg_offset = LLDB_INVALID_INDEX32;\n        if (!value_regs.empty()) {\n          value_regs.push_back(LLDB_INVALID_REGNUM);\n          reg_info.value_regs = value_regs.data();\n        }\n        if (!invalidate_regs.empty()) {\n          invalidate_regs.push_back(LLDB_INVALID_REGNUM);\n          reg_info.invalidate_regs = invalidate_regs.data();\n        }\n\n        reg_num_remote = reg_info.kinds[eRegisterKindProcessPlugin] + 1;\n        ++reg_num_local;\n        reg_info.name = reg_name.AsCString();\n        if (abi_sp)\n          abi_sp->AugmentRegisterInfo(reg_info);\n        dyn_reg_info.AddRegister(reg_info, reg_name, alt_name, set_name);\n\n        return true; // Keep iterating through all \"reg\" elements\n      });\n  return true;\n}\n\n} // namespace\n\n// This method fetches a register description feature xml file from\n// the remote stub and adds registers/register groupsets/architecture\n// information to the current process.  It will call itself recursively\n// for nested register definition files.  It returns true if it was able\n// to fetch and parse an xml file.\nbool ProcessGDBRemote::GetGDBServerRegisterInfoXMLAndProcess(\n    ArchSpec &arch_to_use, std::string xml_filename, uint32_t &reg_num_remote,\n    uint32_t &reg_num_local) {\n  // request the target xml file\n  std::string raw;\n  lldb_private::Status lldberr;\n  if (!m_gdb_comm.ReadExtFeature(ConstString(\"features\"),\n                                 ConstString(xml_filename.c_str()), raw,\n                                 lldberr)) {\n    return false;\n  }\n\n  XMLDocument xml_document;\n\n  if (xml_document.ParseMemory(raw.c_str(), raw.size(), xml_filename.c_str())) {\n    GdbServerTargetInfo target_info;\n    std::vector<XMLNode> feature_nodes;\n\n    // The top level feature XML file will start with a <target> tag.\n    XMLNode target_node = xml_document.GetRootElement(\"target\");\n    if (target_node) {\n      target_node.ForEachChildElement([&target_info, &feature_nodes](\n                                          const XMLNode &node) -> bool {\n        llvm::StringRef name = node.GetName();\n        if (name == \"architecture\") {\n          node.GetElementText(target_info.arch);\n        } else if (name == \"osabi\") {\n          node.GetElementText(target_info.osabi);\n        } else if (name == \"xi:include\" || name == \"include\") {\n          llvm::StringRef href = node.GetAttributeValue(\"href\");\n          if (!href.empty())\n            target_info.includes.push_back(href.str());\n        } else if (name == \"feature\") {\n          feature_nodes.push_back(node);\n        } else if (name == \"groups\") {\n          node.ForEachChildElementWithName(\n              \"group\", [&target_info](const XMLNode &node) -> bool {\n                uint32_t set_id = UINT32_MAX;\n                RegisterSetInfo set_info;\n\n                node.ForEachAttribute(\n                    [&set_id, &set_info](const llvm::StringRef &name,\n                                         const llvm::StringRef &value) -> bool {\n                      if (name == \"id\")\n                        set_id = StringConvert::ToUInt32(value.data(),\n                                                         UINT32_MAX, 0);\n                      if (name == \"name\")\n                        set_info.name = ConstString(value);\n                      return true; // Keep iterating through all attributes\n                    });\n\n                if (set_id != UINT32_MAX)\n                  target_info.reg_set_map[set_id] = set_info;\n                return true; // Keep iterating through all \"group\" elements\n              });\n        }\n        return true; // Keep iterating through all children of the target_node\n      });\n    } else {\n      // In an included XML feature file, we're already \"inside\" the <target>\n      // tag of the initial XML file; this included file will likely only have\n      // a <feature> tag.  Need to check for any more included files in this\n      // <feature> element.\n      XMLNode feature_node = xml_document.GetRootElement(\"feature\");\n      if (feature_node) {\n        feature_nodes.push_back(feature_node);\n        feature_node.ForEachChildElement([&target_info](\n                                        const XMLNode &node) -> bool {\n          llvm::StringRef name = node.GetName();\n          if (name == \"xi:include\" || name == \"include\") {\n            llvm::StringRef href = node.GetAttributeValue(\"href\");\n            if (!href.empty())\n              target_info.includes.push_back(href.str());\n            }\n            return true;\n          });\n      }\n    }\n\n    // If the target.xml includes an architecture entry like\n    //   <architecture>i386:x86-64</architecture> (seen from VMWare ESXi)\n    //   <architecture>arm</architecture> (seen from Segger JLink on unspecified arm board)\n    // use that if we don't have anything better.\n    if (!arch_to_use.IsValid() && !target_info.arch.empty()) {\n      if (target_info.arch == \"i386:x86-64\") {\n        // We don't have any information about vendor or OS.\n        arch_to_use.SetTriple(\"x86_64--\");\n        GetTarget().MergeArchitecture(arch_to_use);\n      }\n\n      // SEGGER J-Link jtag boards send this very-generic arch name,\n      // we'll need to use this if we have absolutely nothing better\n      // to work with or the register definitions won't be accepted.\n      if (target_info.arch == \"arm\") {\n        arch_to_use.SetTriple(\"arm--\");\n        GetTarget().MergeArchitecture(arch_to_use);\n      }\n    }\n\n    if (arch_to_use.IsValid()) {\n      // Don't use Process::GetABI, this code gets called from DidAttach, and\n      // in that context we haven't set the Target's architecture yet, so the\n      // ABI is also potentially incorrect.\n      ABISP abi_to_use_sp = ABI::FindPlugin(shared_from_this(), arch_to_use);\n      for (auto &feature_node : feature_nodes) {\n        ParseRegisters(feature_node, target_info, *this->m_register_info_sp,\n                       abi_to_use_sp, reg_num_remote, reg_num_local);\n      }\n\n      for (const auto &include : target_info.includes) {\n        GetGDBServerRegisterInfoXMLAndProcess(arch_to_use, include,\n                                              reg_num_remote, reg_num_local);\n      }\n    }\n  } else {\n    return false;\n  }\n  return true;\n}\n\n// query the target of gdb-remote for extended target information returns\n// true on success (got register definitions), false on failure (did not).\nbool ProcessGDBRemote::GetGDBServerRegisterInfo(ArchSpec &arch_to_use) {\n  // Make sure LLDB has an XML parser it can use first\n  if (!XMLDocument::XMLEnabled())\n    return false;\n\n  // check that we have extended feature read support\n  if (!m_gdb_comm.GetQXferFeaturesReadSupported())\n    return false;\n\n  uint32_t reg_num_remote = 0;\n  uint32_t reg_num_local = 0;\n  if (GetGDBServerRegisterInfoXMLAndProcess(arch_to_use, \"target.xml\",\n                                            reg_num_remote, reg_num_local))\n    this->m_register_info_sp->Finalize(arch_to_use);\n\n  return m_register_info_sp->GetNumRegisters() > 0;\n}\n\nllvm::Expected<LoadedModuleInfoList> ProcessGDBRemote::GetLoadedModuleList() {\n  // Make sure LLDB has an XML parser it can use first\n  if (!XMLDocument::XMLEnabled())\n    return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                   \"XML parsing not available\");\n\n  Log *log = GetLogIfAnyCategoriesSet(LIBLLDB_LOG_PROCESS);\n  LLDB_LOGF(log, \"ProcessGDBRemote::%s\", __FUNCTION__);\n\n  LoadedModuleInfoList list;\n  GDBRemoteCommunicationClient &comm = m_gdb_comm;\n  bool can_use_svr4 = GetGlobalPluginProperties()->GetUseSVR4();\n\n  // check that we have extended feature read support\n  if (can_use_svr4 && comm.GetQXferLibrariesSVR4ReadSupported()) {\n    // request the loaded library list\n    std::string raw;\n    lldb_private::Status lldberr;\n\n    if (!comm.ReadExtFeature(ConstString(\"libraries-svr4\"), ConstString(\"\"),\n                             raw, lldberr))\n      return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                     \"Error in libraries-svr4 packet\");\n\n    // parse the xml file in memory\n    LLDB_LOGF(log, \"parsing: %s\", raw.c_str());\n    XMLDocument doc;\n\n    if (!doc.ParseMemory(raw.c_str(), raw.size(), \"noname.xml\"))\n      return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                     \"Error reading noname.xml\");\n\n    XMLNode root_element = doc.GetRootElement(\"library-list-svr4\");\n    if (!root_element)\n      return llvm::createStringError(\n          llvm::inconvertibleErrorCode(),\n          \"Error finding library-list-svr4 xml element\");\n\n    // main link map structure\n    llvm::StringRef main_lm = root_element.GetAttributeValue(\"main-lm\");\n    if (!main_lm.empty()) {\n      list.m_link_map =\n          StringConvert::ToUInt64(main_lm.data(), LLDB_INVALID_ADDRESS, 0);\n    }\n\n    root_element.ForEachChildElementWithName(\n        \"library\", [log, &list](const XMLNode &library) -> bool {\n\n          LoadedModuleInfoList::LoadedModuleInfo module;\n\n          library.ForEachAttribute(\n              [&module](const llvm::StringRef &name,\n                        const llvm::StringRef &value) -> bool {\n\n                if (name == \"name\")\n                  module.set_name(value.str());\n                else if (name == \"lm\") {\n                  // the address of the link_map struct.\n                  module.set_link_map(StringConvert::ToUInt64(\n                      value.data(), LLDB_INVALID_ADDRESS, 0));\n                } else if (name == \"l_addr\") {\n                  // the displacement as read from the field 'l_addr' of the\n                  // link_map struct.\n                  module.set_base(StringConvert::ToUInt64(\n                      value.data(), LLDB_INVALID_ADDRESS, 0));\n                  // base address is always a displacement, not an absolute\n                  // value.\n                  module.set_base_is_offset(true);\n                } else if (name == \"l_ld\") {\n                  // the memory address of the libraries PT_DYNAMIC section.\n                  module.set_dynamic(StringConvert::ToUInt64(\n                      value.data(), LLDB_INVALID_ADDRESS, 0));\n                }\n\n                return true; // Keep iterating over all properties of \"library\"\n              });\n\n          if (log) {\n            std::string name;\n            lldb::addr_t lm = 0, base = 0, ld = 0;\n            bool base_is_offset;\n\n            module.get_name(name);\n            module.get_link_map(lm);\n            module.get_base(base);\n            module.get_base_is_offset(base_is_offset);\n            module.get_dynamic(ld);\n\n            LLDB_LOGF(log,\n                      \"found (link_map:0x%08\" PRIx64 \", base:0x%08\" PRIx64\n                      \"[%s], ld:0x%08\" PRIx64 \", name:'%s')\",\n                      lm, base, (base_is_offset ? \"offset\" : \"absolute\"), ld,\n                      name.c_str());\n          }\n\n          list.add(module);\n          return true; // Keep iterating over all \"library\" elements in the root\n                       // node\n        });\n\n    if (log)\n      LLDB_LOGF(log, \"found %\" PRId32 \" modules in total\",\n                (int)list.m_list.size());\n    return list;\n  } else if (comm.GetQXferLibrariesReadSupported()) {\n    // request the loaded library list\n    std::string raw;\n    lldb_private::Status lldberr;\n\n    if (!comm.ReadExtFeature(ConstString(\"libraries\"), ConstString(\"\"), raw,\n                             lldberr))\n      return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                     \"Error in libraries packet\");\n\n    LLDB_LOGF(log, \"parsing: %s\", raw.c_str());\n    XMLDocument doc;\n\n    if (!doc.ParseMemory(raw.c_str(), raw.size(), \"noname.xml\"))\n      return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                     \"Error reading noname.xml\");\n\n    XMLNode root_element = doc.GetRootElement(\"library-list\");\n    if (!root_element)\n      return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                     \"Error finding library-list xml element\");\n\n    root_element.ForEachChildElementWithName(\n        \"library\", [log, &list](const XMLNode &library) -> bool {\n          LoadedModuleInfoList::LoadedModuleInfo module;\n\n          llvm::StringRef name = library.GetAttributeValue(\"name\");\n          module.set_name(name.str());\n\n          // The base address of a given library will be the address of its\n          // first section. Most remotes send only one section for Windows\n          // targets for example.\n          const XMLNode &section =\n              library.FindFirstChildElementWithName(\"section\");\n          llvm::StringRef address = section.GetAttributeValue(\"address\");\n          module.set_base(\n              StringConvert::ToUInt64(address.data(), LLDB_INVALID_ADDRESS, 0));\n          // These addresses are absolute values.\n          module.set_base_is_offset(false);\n\n          if (log) {\n            std::string name;\n            lldb::addr_t base = 0;\n            bool base_is_offset;\n            module.get_name(name);\n            module.get_base(base);\n            module.get_base_is_offset(base_is_offset);\n\n            LLDB_LOGF(log, \"found (base:0x%08\" PRIx64 \"[%s], name:'%s')\", base,\n                      (base_is_offset ? \"offset\" : \"absolute\"), name.c_str());\n          }\n\n          list.add(module);\n          return true; // Keep iterating over all \"library\" elements in the root\n                       // node\n        });\n\n    if (log)\n      LLDB_LOGF(log, \"found %\" PRId32 \" modules in total\",\n                (int)list.m_list.size());\n    return list;\n  } else {\n    return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                   \"Remote libraries not supported\");\n  }\n}\n\nlldb::ModuleSP ProcessGDBRemote::LoadModuleAtAddress(const FileSpec &file,\n                                                     lldb::addr_t link_map,\n                                                     lldb::addr_t base_addr,\n                                                     bool value_is_offset) {\n  DynamicLoader *loader = GetDynamicLoader();\n  if (!loader)\n    return nullptr;\n\n  return loader->LoadModuleAtAddress(file, link_map, base_addr,\n                                     value_is_offset);\n}\n\nllvm::Error ProcessGDBRemote::LoadModules() {\n  using lldb_private::process_gdb_remote::ProcessGDBRemote;\n\n  // request a list of loaded libraries from GDBServer\n  llvm::Expected<LoadedModuleInfoList> module_list = GetLoadedModuleList();\n  if (!module_list)\n    return module_list.takeError();\n\n  // get a list of all the modules\n  ModuleList new_modules;\n\n  for (LoadedModuleInfoList::LoadedModuleInfo &modInfo : module_list->m_list) {\n    std::string mod_name;\n    lldb::addr_t mod_base;\n    lldb::addr_t link_map;\n    bool mod_base_is_offset;\n\n    bool valid = true;\n    valid &= modInfo.get_name(mod_name);\n    valid &= modInfo.get_base(mod_base);\n    valid &= modInfo.get_base_is_offset(mod_base_is_offset);\n    if (!valid)\n      continue;\n\n    if (!modInfo.get_link_map(link_map))\n      link_map = LLDB_INVALID_ADDRESS;\n\n    FileSpec file(mod_name);\n    FileSystem::Instance().Resolve(file);\n    lldb::ModuleSP module_sp =\n        LoadModuleAtAddress(file, link_map, mod_base, mod_base_is_offset);\n\n    if (module_sp.get())\n      new_modules.Append(module_sp);\n  }\n\n  if (new_modules.GetSize() > 0) {\n    ModuleList removed_modules;\n    Target &target = GetTarget();\n    ModuleList &loaded_modules = m_process->GetTarget().GetImages();\n\n    for (size_t i = 0; i < loaded_modules.GetSize(); ++i) {\n      const lldb::ModuleSP loaded_module = loaded_modules.GetModuleAtIndex(i);\n\n      bool found = false;\n      for (size_t j = 0; j < new_modules.GetSize(); ++j) {\n        if (new_modules.GetModuleAtIndex(j).get() == loaded_module.get())\n          found = true;\n      }\n\n      // The main executable will never be included in libraries-svr4, don't\n      // remove it\n      if (!found &&\n          loaded_module.get() != target.GetExecutableModulePointer()) {\n        removed_modules.Append(loaded_module);\n      }\n    }\n\n    loaded_modules.Remove(removed_modules);\n    m_process->GetTarget().ModulesDidUnload(removed_modules, false);\n\n    new_modules.ForEach([&target](const lldb::ModuleSP module_sp) -> bool {\n      lldb_private::ObjectFile *obj = module_sp->GetObjectFile();\n      if (!obj)\n        return true;\n\n      if (obj->GetType() != ObjectFile::Type::eTypeExecutable)\n        return true;\n\n      lldb::ModuleSP module_copy_sp = module_sp;\n      target.SetExecutableModule(module_copy_sp, eLoadDependentsNo);\n      return false;\n    });\n\n    loaded_modules.AppendIfNeeded(new_modules);\n    m_process->GetTarget().ModulesDidLoad(new_modules);\n  }\n\n  return llvm::ErrorSuccess();\n}\n\nStatus ProcessGDBRemote::GetFileLoadAddress(const FileSpec &file,\n                                            bool &is_loaded,\n                                            lldb::addr_t &load_addr) {\n  is_loaded = false;\n  load_addr = LLDB_INVALID_ADDRESS;\n\n  std::string file_path = file.GetPath(false);\n  if (file_path.empty())\n    return Status(\"Empty file name specified\");\n\n  StreamString packet;\n  packet.PutCString(\"qFileLoadAddress:\");\n  packet.PutStringAsRawHex8(file_path);\n\n  StringExtractorGDBRemote response;\n  if (m_gdb_comm.SendPacketAndWaitForResponse(packet.GetString(), response,\n                                              false) !=\n      GDBRemoteCommunication::PacketResult::Success)\n    return Status(\"Sending qFileLoadAddress packet failed\");\n\n  if (response.IsErrorResponse()) {\n    if (response.GetError() == 1) {\n      // The file is not loaded into the inferior\n      is_loaded = false;\n      load_addr = LLDB_INVALID_ADDRESS;\n      return Status();\n    }\n\n    return Status(\n        \"Fetching file load address from remote server returned an error\");\n  }\n\n  if (response.IsNormalResponse()) {\n    is_loaded = true;\n    load_addr = response.GetHexMaxU64(false, LLDB_INVALID_ADDRESS);\n    return Status();\n  }\n\n  return Status(\n      \"Unknown error happened during sending the load address packet\");\n}\n\nvoid ProcessGDBRemote::ModulesDidLoad(ModuleList &module_list) {\n  // We must call the lldb_private::Process::ModulesDidLoad () first before we\n  // do anything\n  Process::ModulesDidLoad(module_list);\n\n  // After loading shared libraries, we can ask our remote GDB server if it\n  // needs any symbols.\n  m_gdb_comm.ServeSymbolLookups(this);\n}\n\nvoid ProcessGDBRemote::HandleAsyncStdout(llvm::StringRef out) {\n  AppendSTDOUT(out.data(), out.size());\n}\n\nstatic const char *end_delimiter = \"--end--;\";\nstatic const int end_delimiter_len = 8;\n\nvoid ProcessGDBRemote::HandleAsyncMisc(llvm::StringRef data) {\n  std::string input = data.str(); // '1' to move beyond 'A'\n  if (m_partial_profile_data.length() > 0) {\n    m_partial_profile_data.append(input);\n    input = m_partial_profile_data;\n    m_partial_profile_data.clear();\n  }\n\n  size_t found, pos = 0, len = input.length();\n  while ((found = input.find(end_delimiter, pos)) != std::string::npos) {\n    StringExtractorGDBRemote profileDataExtractor(\n        input.substr(pos, found).c_str());\n    std::string profile_data =\n        HarmonizeThreadIdsForProfileData(profileDataExtractor);\n    BroadcastAsyncProfileData(profile_data);\n\n    pos = found + end_delimiter_len;\n  }\n\n  if (pos < len) {\n    // Last incomplete chunk.\n    m_partial_profile_data = input.substr(pos);\n  }\n}\n\nstd::string ProcessGDBRemote::HarmonizeThreadIdsForProfileData(\n    StringExtractorGDBRemote &profileDataExtractor) {\n  std::map<uint64_t, uint32_t> new_thread_id_to_used_usec_map;\n  std::string output;\n  llvm::raw_string_ostream output_stream(output);\n  llvm::StringRef name, value;\n\n  // Going to assuming thread_used_usec comes first, else bail out.\n  while (profileDataExtractor.GetNameColonValue(name, value)) {\n    if (name.compare(\"thread_used_id\") == 0) {\n      StringExtractor threadIDHexExtractor(value);\n      uint64_t thread_id = threadIDHexExtractor.GetHexMaxU64(false, 0);\n\n      bool has_used_usec = false;\n      uint32_t curr_used_usec = 0;\n      llvm::StringRef usec_name, usec_value;\n      uint32_t input_file_pos = profileDataExtractor.GetFilePos();\n      if (profileDataExtractor.GetNameColonValue(usec_name, usec_value)) {\n        if (usec_name.equals(\"thread_used_usec\")) {\n          has_used_usec = true;\n          usec_value.getAsInteger(0, curr_used_usec);\n        } else {\n          // We didn't find what we want, it is probably an older version. Bail\n          // out.\n          profileDataExtractor.SetFilePos(input_file_pos);\n        }\n      }\n\n      if (has_used_usec) {\n        uint32_t prev_used_usec = 0;\n        std::map<uint64_t, uint32_t>::iterator iterator =\n            m_thread_id_to_used_usec_map.find(thread_id);\n        if (iterator != m_thread_id_to_used_usec_map.end()) {\n          prev_used_usec = m_thread_id_to_used_usec_map[thread_id];\n        }\n\n        uint32_t real_used_usec = curr_used_usec - prev_used_usec;\n        // A good first time record is one that runs for at least 0.25 sec\n        bool good_first_time =\n            (prev_used_usec == 0) && (real_used_usec > 250000);\n        bool good_subsequent_time =\n            (prev_used_usec > 0) &&\n            ((real_used_usec > 0) || (HasAssignedIndexIDToThread(thread_id)));\n\n        if (good_first_time || good_subsequent_time) {\n          // We try to avoid doing too many index id reservation, resulting in\n          // fast increase of index ids.\n\n          output_stream << name << \":\";\n          int32_t index_id = AssignIndexIDToThread(thread_id);\n          output_stream << index_id << \";\";\n\n          output_stream << usec_name << \":\" << usec_value << \";\";\n        } else {\n          // Skip past 'thread_used_name'.\n          llvm::StringRef local_name, local_value;\n          profileDataExtractor.GetNameColonValue(local_name, local_value);\n        }\n\n        // Store current time as previous time so that they can be compared\n        // later.\n        new_thread_id_to_used_usec_map[thread_id] = curr_used_usec;\n      } else {\n        // Bail out and use old string.\n        output_stream << name << \":\" << value << \";\";\n      }\n    } else {\n      output_stream << name << \":\" << value << \";\";\n    }\n  }\n  output_stream << end_delimiter;\n  m_thread_id_to_used_usec_map = new_thread_id_to_used_usec_map;\n\n  return output_stream.str();\n}\n\nvoid ProcessGDBRemote::HandleStopReply() {\n  if (GetStopID() != 0)\n    return;\n\n  if (GetID() == LLDB_INVALID_PROCESS_ID) {\n    lldb::pid_t pid = m_gdb_comm.GetCurrentProcessID();\n    if (pid != LLDB_INVALID_PROCESS_ID)\n      SetID(pid);\n  }\n  BuildDynamicRegisterInfo(true);\n}\n\nstatic const char *const s_async_json_packet_prefix = \"JSON-async:\";\n\nstatic StructuredData::ObjectSP\nParseStructuredDataPacket(llvm::StringRef packet) {\n  Log *log(ProcessGDBRemoteLog::GetLogIfAllCategoriesSet(GDBR_LOG_PROCESS));\n\n  if (!packet.consume_front(s_async_json_packet_prefix)) {\n    if (log) {\n      LLDB_LOGF(\n          log,\n          \"GDBRemoteCommunicationClientBase::%s() received $J packet \"\n          \"but was not a StructuredData packet: packet starts with \"\n          \"%s\",\n          __FUNCTION__,\n          packet.slice(0, strlen(s_async_json_packet_prefix)).str().c_str());\n    }\n    return StructuredData::ObjectSP();\n  }\n\n  // This is an asynchronous JSON packet, destined for a StructuredDataPlugin.\n  StructuredData::ObjectSP json_sp =\n      StructuredData::ParseJSON(std::string(packet));\n  if (log) {\n    if (json_sp) {\n      StreamString json_str;\n      json_sp->Dump(json_str, true);\n      json_str.Flush();\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::%s() \"\n                \"received Async StructuredData packet: %s\",\n                __FUNCTION__, json_str.GetData());\n    } else {\n      LLDB_LOGF(log,\n                \"ProcessGDBRemote::%s\"\n                \"() received StructuredData packet:\"\n                \" parse failure\",\n                __FUNCTION__);\n    }\n  }\n  return json_sp;\n}\n\nvoid ProcessGDBRemote::HandleAsyncStructuredDataPacket(llvm::StringRef data) {\n  auto structured_data_sp = ParseStructuredDataPacket(data);\n  if (structured_data_sp)\n    RouteAsyncStructuredData(structured_data_sp);\n}\n\nclass CommandObjectProcessGDBRemoteSpeedTest : public CommandObjectParsed {\npublic:\n  CommandObjectProcessGDBRemoteSpeedTest(CommandInterpreter &interpreter)\n      : CommandObjectParsed(interpreter, \"process plugin packet speed-test\",\n                            \"Tests packet speeds of various sizes to determine \"\n                            \"the performance characteristics of the GDB remote \"\n                            \"connection. \",\n                            nullptr),\n        m_option_group(),\n        m_num_packets(LLDB_OPT_SET_1, false, \"count\", 'c', 0, eArgTypeCount,\n                      \"The number of packets to send of each varying size \"\n                      \"(default is 1000).\",\n                      1000),\n        m_max_send(LLDB_OPT_SET_1, false, \"max-send\", 's', 0, eArgTypeCount,\n                   \"The maximum number of bytes to send in a packet. Sizes \"\n                   \"increase in powers of 2 while the size is less than or \"\n                   \"equal to this option value. (default 1024).\",\n                   1024),\n        m_max_recv(LLDB_OPT_SET_1, false, \"max-receive\", 'r', 0, eArgTypeCount,\n                   \"The maximum number of bytes to receive in a packet. Sizes \"\n                   \"increase in powers of 2 while the size is less than or \"\n                   \"equal to this option value. (default 1024).\",\n                   1024),\n        m_json(LLDB_OPT_SET_1, false, \"json\", 'j',\n               \"Print the output as JSON data for easy parsing.\", false, true) {\n    m_option_group.Append(&m_num_packets, LLDB_OPT_SET_ALL, LLDB_OPT_SET_1);\n    m_option_group.Append(&m_max_send, LLDB_OPT_SET_ALL, LLDB_OPT_SET_1);\n    m_option_group.Append(&m_max_recv, LLDB_OPT_SET_ALL, LLDB_OPT_SET_1);\n    m_option_group.Append(&m_json, LLDB_OPT_SET_ALL, LLDB_OPT_SET_1);\n    m_option_group.Finalize();\n  }\n\n  ~CommandObjectProcessGDBRemoteSpeedTest() override {}\n\n  Options *GetOptions() override { return &m_option_group; }\n\n  bool DoExecute(Args &command, CommandReturnObject &result) override {\n    const size_t argc = command.GetArgumentCount();\n    if (argc == 0) {\n      ProcessGDBRemote *process =\n          (ProcessGDBRemote *)m_interpreter.GetExecutionContext()\n              .GetProcessPtr();\n      if (process) {\n        StreamSP output_stream_sp(\n            m_interpreter.GetDebugger().GetAsyncOutputStream());\n        result.SetImmediateOutputStream(output_stream_sp);\n\n        const uint32_t num_packets =\n            (uint32_t)m_num_packets.GetOptionValue().GetCurrentValue();\n        const uint64_t max_send = m_max_send.GetOptionValue().GetCurrentValue();\n        const uint64_t max_recv = m_max_recv.GetOptionValue().GetCurrentValue();\n        const bool json = m_json.GetOptionValue().GetCurrentValue();\n        const uint64_t k_recv_amount =\n            4 * 1024 * 1024; // Receive amount in bytes\n        process->GetGDBRemote().TestPacketSpeed(\n            num_packets, max_send, max_recv, k_recv_amount, json,\n            output_stream_sp ? *output_stream_sp : result.GetOutputStream());\n        result.SetStatus(eReturnStatusSuccessFinishResult);\n        return true;\n      }\n    } else {\n      result.AppendErrorWithFormat(\"'%s' takes no arguments\",\n                                   m_cmd_name.c_str());\n    }\n    result.SetStatus(eReturnStatusFailed);\n    return false;\n  }\n\nprotected:\n  OptionGroupOptions m_option_group;\n  OptionGroupUInt64 m_num_packets;\n  OptionGroupUInt64 m_max_send;\n  OptionGroupUInt64 m_max_recv;\n  OptionGroupBoolean m_json;\n};\n\nclass CommandObjectProcessGDBRemotePacketHistory : public CommandObjectParsed {\nprivate:\npublic:\n  CommandObjectProcessGDBRemotePacketHistory(CommandInterpreter &interpreter)\n      : CommandObjectParsed(interpreter, \"process plugin packet history\",\n                            \"Dumps the packet history buffer. \", nullptr) {}\n\n  ~CommandObjectProcessGDBRemotePacketHistory() override {}\n\n  bool DoExecute(Args &command, CommandReturnObject &result) override {\n    const size_t argc = command.GetArgumentCount();\n    if (argc == 0) {\n      ProcessGDBRemote *process =\n          (ProcessGDBRemote *)m_interpreter.GetExecutionContext()\n              .GetProcessPtr();\n      if (process) {\n        process->GetGDBRemote().DumpHistory(result.GetOutputStream());\n        result.SetStatus(eReturnStatusSuccessFinishResult);\n        return true;\n      }\n    } else {\n      result.AppendErrorWithFormat(\"'%s' takes no arguments\",\n                                   m_cmd_name.c_str());\n    }\n    result.SetStatus(eReturnStatusFailed);\n    return false;\n  }\n};\n\nclass CommandObjectProcessGDBRemotePacketXferSize : public CommandObjectParsed {\nprivate:\npublic:\n  CommandObjectProcessGDBRemotePacketXferSize(CommandInterpreter &interpreter)\n      : CommandObjectParsed(\n            interpreter, \"process plugin packet xfer-size\",\n            \"Maximum size that lldb will try to read/write one one chunk.\",\n            nullptr) {}\n\n  ~CommandObjectProcessGDBRemotePacketXferSize() override {}\n\n  bool DoExecute(Args &command, CommandReturnObject &result) override {\n    const size_t argc = command.GetArgumentCount();\n    if (argc == 0) {\n      result.AppendErrorWithFormat(\"'%s' takes an argument to specify the max \"\n                                   \"amount to be transferred when \"\n                                   \"reading/writing\",\n                                   m_cmd_name.c_str());\n      result.SetStatus(eReturnStatusFailed);\n      return false;\n    }\n\n    ProcessGDBRemote *process =\n        (ProcessGDBRemote *)m_interpreter.GetExecutionContext().GetProcessPtr();\n    if (process) {\n      const char *packet_size = command.GetArgumentAtIndex(0);\n      errno = 0;\n      uint64_t user_specified_max = strtoul(packet_size, nullptr, 10);\n      if (errno == 0 && user_specified_max != 0) {\n        process->SetUserSpecifiedMaxMemoryTransferSize(user_specified_max);\n        result.SetStatus(eReturnStatusSuccessFinishResult);\n        return true;\n      }\n    }\n    result.SetStatus(eReturnStatusFailed);\n    return false;\n  }\n};\n\nclass CommandObjectProcessGDBRemotePacketSend : public CommandObjectParsed {\nprivate:\npublic:\n  CommandObjectProcessGDBRemotePacketSend(CommandInterpreter &interpreter)\n      : CommandObjectParsed(interpreter, \"process plugin packet send\",\n                            \"Send a custom packet through the GDB remote \"\n                            \"protocol and print the answer. \"\n                            \"The packet header and footer will automatically \"\n                            \"be added to the packet prior to sending and \"\n                            \"stripped from the result.\",\n                            nullptr) {}\n\n  ~CommandObjectProcessGDBRemotePacketSend() override {}\n\n  bool DoExecute(Args &command, CommandReturnObject &result) override {\n    const size_t argc = command.GetArgumentCount();\n    if (argc == 0) {\n      result.AppendErrorWithFormat(\n          \"'%s' takes a one or more packet content arguments\",\n          m_cmd_name.c_str());\n      result.SetStatus(eReturnStatusFailed);\n      return false;\n    }\n\n    ProcessGDBRemote *process =\n        (ProcessGDBRemote *)m_interpreter.GetExecutionContext().GetProcessPtr();\n    if (process) {\n      for (size_t i = 0; i < argc; ++i) {\n        const char *packet_cstr = command.GetArgumentAtIndex(0);\n        bool send_async = true;\n        StringExtractorGDBRemote response;\n        process->GetGDBRemote().SendPacketAndWaitForResponse(\n            packet_cstr, response, send_async);\n        result.SetStatus(eReturnStatusSuccessFinishResult);\n        Stream &output_strm = result.GetOutputStream();\n        output_strm.Printf(\"  packet: %s\\n\", packet_cstr);\n        std::string response_str = std::string(response.GetStringRef());\n\n        if (strstr(packet_cstr, \"qGetProfileData\") != nullptr) {\n          response_str = process->HarmonizeThreadIdsForProfileData(response);\n        }\n\n        if (response_str.empty())\n          output_strm.PutCString(\"response: \\nerror: UNIMPLEMENTED\\n\");\n        else\n          output_strm.Printf(\"response: %s\\n\", response.GetStringRef().data());\n      }\n    }\n    return true;\n  }\n};\n\nclass CommandObjectProcessGDBRemotePacketMonitor : public CommandObjectRaw {\nprivate:\npublic:\n  CommandObjectProcessGDBRemotePacketMonitor(CommandInterpreter &interpreter)\n      : CommandObjectRaw(interpreter, \"process plugin packet monitor\",\n                         \"Send a qRcmd packet through the GDB remote protocol \"\n                         \"and print the response.\"\n                         \"The argument passed to this command will be hex \"\n                         \"encoded into a valid 'qRcmd' packet, sent and the \"\n                         \"response will be printed.\") {}\n\n  ~CommandObjectProcessGDBRemotePacketMonitor() override {}\n\n  bool DoExecute(llvm::StringRef command,\n                 CommandReturnObject &result) override {\n    if (command.empty()) {\n      result.AppendErrorWithFormat(\"'%s' takes a command string argument\",\n                                   m_cmd_name.c_str());\n      result.SetStatus(eReturnStatusFailed);\n      return false;\n    }\n\n    ProcessGDBRemote *process =\n        (ProcessGDBRemote *)m_interpreter.GetExecutionContext().GetProcessPtr();\n    if (process) {\n      StreamString packet;\n      packet.PutCString(\"qRcmd,\");\n      packet.PutBytesAsRawHex8(command.data(), command.size());\n\n      bool send_async = true;\n      StringExtractorGDBRemote response;\n      Stream &output_strm = result.GetOutputStream();\n      process->GetGDBRemote().SendPacketAndReceiveResponseWithOutputSupport(\n          packet.GetString(), response, send_async,\n          [&output_strm](llvm::StringRef output) { output_strm << output; });\n      result.SetStatus(eReturnStatusSuccessFinishResult);\n      output_strm.Printf(\"  packet: %s\\n\", packet.GetData());\n      const std::string &response_str = std::string(response.GetStringRef());\n\n      if (response_str.empty())\n        output_strm.PutCString(\"response: \\nerror: UNIMPLEMENTED\\n\");\n      else\n        output_strm.Printf(\"response: %s\\n\", response.GetStringRef().data());\n    }\n    return true;\n  }\n};\n\nclass CommandObjectProcessGDBRemotePacket : public CommandObjectMultiword {\nprivate:\npublic:\n  CommandObjectProcessGDBRemotePacket(CommandInterpreter &interpreter)\n      : CommandObjectMultiword(interpreter, \"process plugin packet\",\n                               \"Commands that deal with GDB remote packets.\",\n                               nullptr) {\n    LoadSubCommand(\n        \"history\",\n        CommandObjectSP(\n            new CommandObjectProcessGDBRemotePacketHistory(interpreter)));\n    LoadSubCommand(\n        \"send\", CommandObjectSP(\n                    new CommandObjectProcessGDBRemotePacketSend(interpreter)));\n    LoadSubCommand(\n        \"monitor\",\n        CommandObjectSP(\n            new CommandObjectProcessGDBRemotePacketMonitor(interpreter)));\n    LoadSubCommand(\n        \"xfer-size\",\n        CommandObjectSP(\n            new CommandObjectProcessGDBRemotePacketXferSize(interpreter)));\n    LoadSubCommand(\"speed-test\",\n                   CommandObjectSP(new CommandObjectProcessGDBRemoteSpeedTest(\n                       interpreter)));\n  }\n\n  ~CommandObjectProcessGDBRemotePacket() override {}\n};\n\nclass CommandObjectMultiwordProcessGDBRemote : public CommandObjectMultiword {\npublic:\n  CommandObjectMultiwordProcessGDBRemote(CommandInterpreter &interpreter)\n      : CommandObjectMultiword(\n            interpreter, \"process plugin\",\n            \"Commands for operating on a ProcessGDBRemote process.\",\n            \"process plugin <subcommand> [<subcommand-options>]\") {\n    LoadSubCommand(\n        \"packet\",\n        CommandObjectSP(new CommandObjectProcessGDBRemotePacket(interpreter)));\n  }\n\n  ~CommandObjectMultiwordProcessGDBRemote() override {}\n};\n\nCommandObject *ProcessGDBRemote::GetPluginCommandObject() {\n  if (!m_command_sp)\n    m_command_sp = std::make_shared<CommandObjectMultiwordProcessGDBRemote>(\n        GetTarget().GetDebugger().GetCommandInterpreter());\n  return m_command_sp.get();\n}\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Process/gdb-remote/ThreadGDBRemote.h", "content": "//===-- ThreadGDBRemote.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_PROCESS_GDB_REMOTE_THREADGDBREMOTE_H\n#define LLDB_SOURCE_PLUGINS_PROCESS_GDB_REMOTE_THREADGDBREMOTE_H\n\n#include <string>\n\n#include \"lldb/Target/Thread.h\"\n#include \"lldb/Utility/StructuredData.h\"\n\n#include \"GDBRemoteRegisterContext.h\"\n\nclass StringExtractor;\n\nnamespace lldb_private {\nclass Process;\n\nnamespace process_gdb_remote {\n\nclass ProcessGDBRemote;\n\nclass ThreadGDBRemote : public Thread {\npublic:\n  ThreadGDBRemote(Process &process, lldb::tid_t tid);\n\n  ~ThreadGDBRemote() override;\n\n  void WillResume(lldb::StateType resume_state) override;\n\n  void RefreshStateAfterStop() override;\n\n  const char *GetName() override;\n\n  const char *GetQueueName() override;\n\n  lldb::QueueKind GetQueueKind() override;\n\n  lldb::queue_id_t GetQueueID() override;\n\n  lldb::QueueSP GetQueue() override;\n\n  lldb::addr_t GetQueueLibdispatchQueueAddress() override;\n\n  void SetQueueLibdispatchQueueAddress(lldb::addr_t dispatch_queue_t) override;\n\n  bool ThreadHasQueueInformation() const override;\n\n  lldb::RegisterContextSP GetRegisterContext() override;\n\n  lldb::RegisterContextSP\n  CreateRegisterContextForFrame(StackFrame *frame) override;\n\n  void Dump(Log *log, uint32_t index);\n\n  static bool ThreadIDIsValid(lldb::tid_t thread);\n\n  bool ShouldStop(bool &step_more);\n\n  const char *GetBasicInfoAsString();\n\n  void SetName(const char *name) override {\n    if (name && name[0])\n      m_thread_name.assign(name);\n    else\n      m_thread_name.clear();\n  }\n\n  lldb::addr_t GetThreadDispatchQAddr() { return m_thread_dispatch_qaddr; }\n\n  void SetThreadDispatchQAddr(lldb::addr_t thread_dispatch_qaddr) {\n    m_thread_dispatch_qaddr = thread_dispatch_qaddr;\n  }\n\n  void ClearQueueInfo();\n\n  void SetQueueInfo(std::string &&queue_name, lldb::QueueKind queue_kind,\n                    uint64_t queue_serial, lldb::addr_t dispatch_queue_t,\n                    lldb_private::LazyBool associated_with_libdispatch_queue);\n\n  lldb_private::LazyBool GetAssociatedWithLibdispatchQueue() override;\n\n  void SetAssociatedWithLibdispatchQueue(\n      lldb_private::LazyBool associated_with_libdispatch_queue) override;\n\n  StructuredData::ObjectSP FetchThreadExtendedInfo() override;\n\nprotected:\n  friend class ProcessGDBRemote;\n\n  std::string m_thread_name;\n  std::string m_dispatch_queue_name;\n  lldb::addr_t m_thread_dispatch_qaddr;\n  lldb::addr_t m_dispatch_queue_t;\n  lldb::QueueKind\n      m_queue_kind; // Queue info from stop reply/stop info for thread\n  uint64_t\n      m_queue_serial_number; // Queue info from stop reply/stop info for thread\n  lldb_private::LazyBool m_associated_with_libdispatch_queue;\n\n  GDBRemoteDynamicRegisterInfoSP m_reg_info_sp;\n\n  bool PrivateSetRegisterValue(uint32_t reg, llvm::ArrayRef<uint8_t> data);\n\n  bool PrivateSetRegisterValue(uint32_t reg, uint64_t regval);\n\n  bool CachedQueueInfoIsValid() const {\n    return m_queue_kind != lldb::eQueueKindUnknown;\n  }\n  void SetStopInfoFromPacket(StringExtractor &stop_packet, uint32_t stop_id);\n\n  bool CalculateStopInfo() override;\n};\n\n} // namespace process_gdb_remote\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_PROCESS_GDB_REMOTE_THREADGDBREMOTE_H\n"}, "27": {"id": 27, "path": "/usr/include/libxml2/libxml/SAX2.h", "content": "/*\n * Summary: SAX2 parser interface used to build the DOM tree\n * Description: those are the default SAX2 interfaces used by\n *              the library when building DOM tree.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n\n#ifndef __XML_SAX2_H__\n#define __XML_SAX2_H__\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <libxml/xmlversion.h>\n#include <libxml/parser.h>\n#include <libxml/xlink.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nXMLPUBFUN const xmlChar * XMLCALL\n\t\txmlSAX2GetPublicId\t\t(void *ctx);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\txmlSAX2GetSystemId\t\t(void *ctx);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2SetDocumentLocator\t(void *ctx,\n\t\t\t\t\t\t xmlSAXLocatorPtr loc);\n\nXMLPUBFUN int XMLCALL\n\t\txmlSAX2GetLineNumber\t\t(void *ctx);\nXMLPUBFUN int XMLCALL\n\t\txmlSAX2GetColumnNumber\t\t(void *ctx);\n\nXMLPUBFUN int XMLCALL\n\t\txmlSAX2IsStandalone\t\t(void *ctx);\nXMLPUBFUN int XMLCALL\n\t\txmlSAX2HasInternalSubset\t(void *ctx);\nXMLPUBFUN int XMLCALL\n\t\txmlSAX2HasExternalSubset\t(void *ctx);\n\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2InternalSubset\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t const xmlChar *ExternalID,\n\t\t\t\t\t\t const xmlChar *SystemID);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2ExternalSubset\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t const xmlChar *ExternalID,\n\t\t\t\t\t\t const xmlChar *SystemID);\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\txmlSAX2GetEntity\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\txmlSAX2GetParameterEntity\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlParserInputPtr XMLCALL\n\t\txmlSAX2ResolveEntity\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *publicId,\n\t\t\t\t\t\t const xmlChar *systemId);\n\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2EntityDecl\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t int type,\n\t\t\t\t\t\t const xmlChar *publicId,\n\t\t\t\t\t\t const xmlChar *systemId,\n\t\t\t\t\t\t xmlChar *content);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2AttributeDecl\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *elem,\n\t\t\t\t\t\t const xmlChar *fullname,\n\t\t\t\t\t\t int type,\n\t\t\t\t\t\t int def,\n\t\t\t\t\t\t const xmlChar *defaultValue,\n\t\t\t\t\t\t xmlEnumerationPtr tree);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2ElementDecl\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t int type,\n\t\t\t\t\t\t xmlElementContentPtr content);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2NotationDecl\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t const xmlChar *publicId,\n\t\t\t\t\t\t const xmlChar *systemId);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2UnparsedEntityDecl\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t const xmlChar *publicId,\n\t\t\t\t\t\t const xmlChar *systemId,\n\t\t\t\t\t\t const xmlChar *notationName);\n\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2StartDocument\t\t(void *ctx);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2EndDocument\t\t(void *ctx);\n#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || \\\n    defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || \\\n    defined(LIBXML_LEGACY_ENABLED)\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2StartElement\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *fullname,\n\t\t\t\t\t\t const xmlChar **atts);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2EndElement\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name);\n#endif /* LIBXML_SAX1_ENABLED or LIBXML_HTML_ENABLED or LIBXML_LEGACY_ENABLED */\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2StartElementNs\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *localname,\n\t\t\t\t\t\t const xmlChar *prefix,\n\t\t\t\t\t\t const xmlChar *URI,\n\t\t\t\t\t\t int nb_namespaces,\n\t\t\t\t\t\t const xmlChar **namespaces,\n\t\t\t\t\t\t int nb_attributes,\n\t\t\t\t\t\t int nb_defaulted,\n\t\t\t\t\t\t const xmlChar **attributes);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2EndElementNs\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *localname,\n\t\t\t\t\t\t const xmlChar *prefix,\n\t\t\t\t\t\t const xmlChar *URI);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2Reference\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2Characters\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *ch,\n\t\t\t\t\t\t int len);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2IgnorableWhitespace\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *ch,\n\t\t\t\t\t\t int len);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2ProcessingInstruction\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *target,\n\t\t\t\t\t\t const xmlChar *data);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2Comment\t\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2CDataBlock\t\t(void *ctx,\n\t\t\t\t\t\t const xmlChar *value,\n\t\t\t\t\t\t int len);\n\n#ifdef LIBXML_SAX1_ENABLED\nXMLPUBFUN int XMLCALL\n\t\txmlSAXDefaultVersion\t\t(int version);\n#endif /* LIBXML_SAX1_ENABLED */\n\nXMLPUBFUN int XMLCALL\n\t\txmlSAXVersion\t\t\t(xmlSAXHandler *hdlr,\n\t\t\t\t\t\t int version);\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2InitDefaultSAXHandler    (xmlSAXHandler *hdlr,\n\t\t\t\t\t\t int warning);\n#ifdef LIBXML_HTML_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr);\nXMLPUBFUN void XMLCALL\n\t\thtmlDefaultSAXHandlerInit\t(void);\n#endif\n#ifdef LIBXML_DOCB_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr);\nXMLPUBFUN void XMLCALL\n\t\tdocbDefaultSAXHandlerInit\t(void);\n#endif\nXMLPUBFUN void XMLCALL\n\t\txmlDefaultSAXHandlerInit\t(void);\n#ifdef __cplusplus\n}\n#endif\n#endif /* __XML_SAX2_H__ */\n"}, "28": {"id": 28, "path": "/usr/include/libxml2/libxml/dict.h", "content": "/*\n * Summary: string dictionary\n * Description: dictionary of reusable strings, just used to avoid allocation\n *         and freeing operations.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_DICT_H__\n#define __XML_DICT_H__\n\n#include <stddef.h>\n#include <libxml/xmlversion.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * The dictionary.\n */\ntypedef struct _xmlDict xmlDict;\ntypedef xmlDict *xmlDictPtr;\n\n/*\n * Initializer\n */\nXMLPUBFUN int XMLCALL  xmlInitializeDict(void);\n\n/*\n * Constructor and destructor.\n */\nXMLPUBFUN xmlDictPtr XMLCALL\n\t\t\txmlDictCreate\t(void);\nXMLPUBFUN size_t XMLCALL\n\t\t\txmlDictSetLimit\t(xmlDictPtr dict,\n                                         size_t limit);\nXMLPUBFUN size_t XMLCALL\n\t\t\txmlDictGetUsage (xmlDictPtr dict);\nXMLPUBFUN xmlDictPtr XMLCALL\n\t\t\txmlDictCreateSub(xmlDictPtr sub);\nXMLPUBFUN int XMLCALL\n\t\t\txmlDictReference(xmlDictPtr dict);\nXMLPUBFUN void XMLCALL\n\t\t\txmlDictFree\t(xmlDictPtr dict);\n\n/*\n * Lookup of entry in the dictionary.\n */\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t\txmlDictLookup\t(xmlDictPtr dict,\n\t\t                         const xmlChar *name,\n\t\t                         int len);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t\txmlDictExists\t(xmlDictPtr dict,\n\t\t                         const xmlChar *name,\n\t\t                         int len);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t\txmlDictQLookup\t(xmlDictPtr dict,\n\t\t                         const xmlChar *prefix,\n\t\t                         const xmlChar *name);\nXMLPUBFUN int XMLCALL\n\t\t\txmlDictOwns\t(xmlDictPtr dict,\n\t\t\t\t\t const xmlChar *str);\nXMLPUBFUN int XMLCALL\n\t\t\txmlDictSize\t(xmlDictPtr dict);\n\n/*\n * Cleanup function\n */\nXMLPUBFUN void XMLCALL\n                        xmlDictCleanup  (void);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* ! __XML_DICT_H__ */\n"}, "29": {"id": 29, "path": "/usr/include/libxml2/libxml/encoding.h", "content": "/*\n * Summary: interface for the encoding conversion functions\n * Description: interface for the encoding conversion functions needed for\n *              XML basic encoding and iconv() support.\n *\n * Related specs are\n * rfc2044        (UTF-8 and UTF-16) F. Yergeau Alis Technologies\n * [ISO-10646]    UTF-8 and UTF-16 in Annexes\n * [ISO-8859-1]   ISO Latin-1 characters codes.\n * [UNICODE]      The Unicode Consortium, \"The Unicode Standard --\n *                Worldwide Character Encoding -- Version 1.0\", Addison-\n *                Wesley, Volume 1, 1991, Volume 2, 1992.  UTF-8 is\n *                described in Unicode Technical Report #4.\n * [US-ASCII]     Coded Character Set--7-bit American Standard Code for\n *                Information Interchange, ANSI X3.4-1986.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_CHAR_ENCODING_H__\n#define __XML_CHAR_ENCODING_H__\n\n#include <libxml/xmlversion.h>\n\n#ifdef LIBXML_ICONV_ENABLED\n#include <iconv.h>\n#endif\n#ifdef LIBXML_ICU_ENABLED\n#include <unicode/ucnv.h>\n#endif\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * xmlCharEncoding:\n *\n * Predefined values for some standard encodings.\n * Libxml does not do beforehand translation on UTF8 and ISOLatinX.\n * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.\n *\n * Anything else would have to be translated to UTF8 before being\n * given to the parser itself. The BOM for UTF16 and the encoding\n * declaration are looked at and a converter is looked for at that\n * point. If not found the parser stops here as asked by the XML REC. A\n * converter can be registered by the user using xmlRegisterCharEncodingHandler\n * but the current form doesn't allow stateful transcoding (a serious\n * problem agreed !). If iconv has been found it will be used\n * automatically and allow stateful transcoding, the simplest is then\n * to be sure to enable iconv and to provide iconv libs for the encoding\n * support needed.\n *\n * Note that the generic \"UTF-16\" is not a predefined value.  Instead, only\n * the specific UTF-16LE and UTF-16BE are present.\n */\ntypedef enum {\n    XML_CHAR_ENCODING_ERROR=   -1, /* No char encoding detected */\n    XML_CHAR_ENCODING_NONE=\t0, /* No char encoding detected */\n    XML_CHAR_ENCODING_UTF8=\t1, /* UTF-8 */\n    XML_CHAR_ENCODING_UTF16LE=\t2, /* UTF-16 little endian */\n    XML_CHAR_ENCODING_UTF16BE=\t3, /* UTF-16 big endian */\n    XML_CHAR_ENCODING_UCS4LE=\t4, /* UCS-4 little endian */\n    XML_CHAR_ENCODING_UCS4BE=\t5, /* UCS-4 big endian */\n    XML_CHAR_ENCODING_EBCDIC=\t6, /* EBCDIC uh! */\n    XML_CHAR_ENCODING_UCS4_2143=7, /* UCS-4 unusual ordering */\n    XML_CHAR_ENCODING_UCS4_3412=8, /* UCS-4 unusual ordering */\n    XML_CHAR_ENCODING_UCS2=\t9, /* UCS-2 */\n    XML_CHAR_ENCODING_8859_1=\t10,/* ISO-8859-1 ISO Latin 1 */\n    XML_CHAR_ENCODING_8859_2=\t11,/* ISO-8859-2 ISO Latin 2 */\n    XML_CHAR_ENCODING_8859_3=\t12,/* ISO-8859-3 */\n    XML_CHAR_ENCODING_8859_4=\t13,/* ISO-8859-4 */\n    XML_CHAR_ENCODING_8859_5=\t14,/* ISO-8859-5 */\n    XML_CHAR_ENCODING_8859_6=\t15,/* ISO-8859-6 */\n    XML_CHAR_ENCODING_8859_7=\t16,/* ISO-8859-7 */\n    XML_CHAR_ENCODING_8859_8=\t17,/* ISO-8859-8 */\n    XML_CHAR_ENCODING_8859_9=\t18,/* ISO-8859-9 */\n    XML_CHAR_ENCODING_2022_JP=  19,/* ISO-2022-JP */\n    XML_CHAR_ENCODING_SHIFT_JIS=20,/* Shift_JIS */\n    XML_CHAR_ENCODING_EUC_JP=   21,/* EUC-JP */\n    XML_CHAR_ENCODING_ASCII=    22 /* pure ASCII */\n} xmlCharEncoding;\n\n/**\n * xmlCharEncodingInputFunc:\n * @out:  a pointer to an array of bytes to store the UTF-8 result\n * @outlen:  the length of @out\n * @in:  a pointer to an array of chars in the original encoding\n * @inlen:  the length of @in\n *\n * Take a block of chars in the original encoding and try to convert\n * it to an UTF-8 block of chars out.\n *\n * Returns the number of bytes written, -1 if lack of space, or -2\n *     if the transcoding failed.\n * The value of @inlen after return is the number of octets consumed\n *     if the return value is positive, else unpredictiable.\n * The value of @outlen after return is the number of octets consumed.\n */\ntypedef int (* xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,\n                                         const unsigned char *in, int *inlen);\n\n\n/**\n * xmlCharEncodingOutputFunc:\n * @out:  a pointer to an array of bytes to store the result\n * @outlen:  the length of @out\n * @in:  a pointer to an array of UTF-8 chars\n * @inlen:  the length of @in\n *\n * Take a block of UTF-8 chars in and try to convert it to another\n * encoding.\n * Note: a first call designed to produce heading info is called with\n * in = NULL. If stateful this should also initialize the encoder state.\n *\n * Returns the number of bytes written, -1 if lack of space, or -2\n *     if the transcoding failed.\n * The value of @inlen after return is the number of octets consumed\n *     if the return value is positive, else unpredictiable.\n * The value of @outlen after return is the number of octets produced.\n */\ntypedef int (* xmlCharEncodingOutputFunc)(unsigned char *out, int *outlen,\n                                          const unsigned char *in, int *inlen);\n\n\n/*\n * Block defining the handlers for non UTF-8 encodings.\n * If iconv is supported, there are two extra fields.\n */\n#ifdef LIBXML_ICU_ENABLED\n/* Size of pivot buffer, same as icu/source/common/ucnv.cpp CHUNK_SIZE */\n#define ICU_PIVOT_BUF_SIZE 1024\nstruct _uconv_t {\n  UConverter *uconv; /* for conversion between an encoding and UTF-16 */\n  UConverter *utf8; /* for conversion between UTF-8 and UTF-16 */\n  UChar      pivot_buf[ICU_PIVOT_BUF_SIZE];\n  UChar      *pivot_source;\n  UChar      *pivot_target;\n};\ntypedef struct _uconv_t uconv_t;\n#endif\n\ntypedef struct _xmlCharEncodingHandler xmlCharEncodingHandler;\ntypedef xmlCharEncodingHandler *xmlCharEncodingHandlerPtr;\nstruct _xmlCharEncodingHandler {\n    char                       *name;\n    xmlCharEncodingInputFunc   input;\n    xmlCharEncodingOutputFunc  output;\n#ifdef LIBXML_ICONV_ENABLED\n    iconv_t                    iconv_in;\n    iconv_t                    iconv_out;\n#endif /* LIBXML_ICONV_ENABLED */\n#ifdef LIBXML_ICU_ENABLED\n    uconv_t                    *uconv_in;\n    uconv_t                    *uconv_out;\n#endif /* LIBXML_ICU_ENABLED */\n};\n\n#ifdef __cplusplus\n}\n#endif\n#include <libxml/tree.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Interfaces for encoding handlers.\n */\nXMLPUBFUN void XMLCALL\n\txmlInitCharEncodingHandlers\t(void);\nXMLPUBFUN void XMLCALL\n\txmlCleanupCharEncodingHandlers\t(void);\nXMLPUBFUN void XMLCALL\n\txmlRegisterCharEncodingHandler\t(xmlCharEncodingHandlerPtr handler);\nXMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL\n\txmlGetCharEncodingHandler\t(xmlCharEncoding enc);\nXMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL\n\txmlFindCharEncodingHandler\t(const char *name);\nXMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL\n\txmlNewCharEncodingHandler\t(const char *name,\n\t\t\t\t\t xmlCharEncodingInputFunc input,\n\t\t\t\t\t xmlCharEncodingOutputFunc output);\n\n/*\n * Interfaces for encoding names and aliases.\n */\nXMLPUBFUN int XMLCALL\n\txmlAddEncodingAlias\t\t(const char *name,\n\t\t\t\t\t const char *alias);\nXMLPUBFUN int XMLCALL\n\txmlDelEncodingAlias\t\t(const char *alias);\nXMLPUBFUN const char * XMLCALL\n\txmlGetEncodingAlias\t\t(const char *alias);\nXMLPUBFUN void XMLCALL\n\txmlCleanupEncodingAliases\t(void);\nXMLPUBFUN xmlCharEncoding XMLCALL\n\txmlParseCharEncoding\t\t(const char *name);\nXMLPUBFUN const char * XMLCALL\n\txmlGetCharEncodingName\t\t(xmlCharEncoding enc);\n\n/*\n * Interfaces directly used by the parsers.\n */\nXMLPUBFUN xmlCharEncoding XMLCALL\n\txmlDetectCharEncoding\t\t(const unsigned char *in,\n\t\t\t\t\t int len);\n\nXMLPUBFUN int XMLCALL\n\txmlCharEncOutFunc\t\t(xmlCharEncodingHandler *handler,\n\t\t\t\t\t xmlBufferPtr out,\n\t\t\t\t\t xmlBufferPtr in);\n\nXMLPUBFUN int XMLCALL\n\txmlCharEncInFunc\t\t(xmlCharEncodingHandler *handler,\n\t\t\t\t\t xmlBufferPtr out,\n\t\t\t\t\t xmlBufferPtr in);\nXMLPUBFUN int XMLCALL\n\txmlCharEncFirstLine\t\t(xmlCharEncodingHandler *handler,\n\t\t\t\t\t xmlBufferPtr out,\n\t\t\t\t\t xmlBufferPtr in);\nXMLPUBFUN int XMLCALL\n\txmlCharEncCloseFunc\t\t(xmlCharEncodingHandler *handler);\n\n/*\n * Export a few useful functions\n */\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN int XMLCALL\n\tUTF8Toisolat1\t\t\t(unsigned char *out,\n\t\t\t\t\t int *outlen,\n\t\t\t\t\t const unsigned char *in,\n\t\t\t\t\t int *inlen);\n#endif /* LIBXML_OUTPUT_ENABLED */\nXMLPUBFUN int XMLCALL\n\tisolat1ToUTF8\t\t\t(unsigned char *out,\n\t\t\t\t\t int *outlen,\n\t\t\t\t\t const unsigned char *in,\n\t\t\t\t\t int *inlen);\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __XML_CHAR_ENCODING_H__ */\n"}, "30": {"id": 30, "path": "/usr/include/libxml2/libxml/entities.h", "content": "/*\n * Summary: interface for the XML entities handling\n * Description: this module provides some of the entity API needed\n *              for the parser and applications.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_ENTITIES_H__\n#define __XML_ENTITIES_H__\n\n#include <libxml/xmlversion.h>\n#include <libxml/tree.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * The different valid entity types.\n */\ntypedef enum {\n    XML_INTERNAL_GENERAL_ENTITY = 1,\n    XML_EXTERNAL_GENERAL_PARSED_ENTITY = 2,\n    XML_EXTERNAL_GENERAL_UNPARSED_ENTITY = 3,\n    XML_INTERNAL_PARAMETER_ENTITY = 4,\n    XML_EXTERNAL_PARAMETER_ENTITY = 5,\n    XML_INTERNAL_PREDEFINED_ENTITY = 6\n} xmlEntityType;\n\n/*\n * An unit of storage for an entity, contains the string, the value\n * and the linkind data needed for the linking in the hash table.\n */\n\nstruct _xmlEntity {\n    void           *_private;\t        /* application data */\n    xmlElementType          type;       /* XML_ENTITY_DECL, must be second ! */\n    const xmlChar          *name;\t/* Entity name */\n    struct _xmlNode    *children;\t/* First child link */\n    struct _xmlNode        *last;\t/* Last child link */\n    struct _xmlDtd       *parent;\t/* -> DTD */\n    struct _xmlNode        *next;\t/* next sibling link  */\n    struct _xmlNode        *prev;\t/* previous sibling link  */\n    struct _xmlDoc          *doc;       /* the containing document */\n\n    xmlChar                *orig;\t/* content without ref substitution */\n    xmlChar             *content;\t/* content or ndata if unparsed */\n    int                   length;\t/* the content length */\n    xmlEntityType          etype;\t/* The entity type */\n    const xmlChar    *ExternalID;\t/* External identifier for PUBLIC */\n    const xmlChar      *SystemID;\t/* URI for a SYSTEM or PUBLIC Entity */\n\n    struct _xmlEntity     *nexte;\t/* unused */\n    const xmlChar           *URI;\t/* the full URI as computed */\n    int                    owner;\t/* does the entity own the childrens */\n    int\t\t\t checked;\t/* was the entity content checked */\n\t\t\t\t\t/* this is also used to count entities\n\t\t\t\t\t * references done from that entity\n\t\t\t\t\t * and if it contains '<' */\n};\n\n/*\n * All entities are stored in an hash table.\n * There is 2 separate hash tables for global and parameter entities.\n */\n\ntypedef struct _xmlHashTable xmlEntitiesTable;\ntypedef xmlEntitiesTable *xmlEntitiesTablePtr;\n\n/*\n * External functions:\n */\n\n#ifdef LIBXML_LEGACY_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlInitializePredefinedEntities\t(void);\n#endif /* LIBXML_LEGACY_ENABLED */\n\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\t\txmlNewEntity\t\t(xmlDocPtr doc,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t int type,\n\t\t\t\t\t\t const xmlChar *ExternalID,\n\t\t\t\t\t\t const xmlChar *SystemID,\n\t\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\t\txmlAddDocEntity\t\t(xmlDocPtr doc,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t int type,\n\t\t\t\t\t\t const xmlChar *ExternalID,\n\t\t\t\t\t\t const xmlChar *SystemID,\n\t\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\t\txmlAddDtdEntity\t\t(xmlDocPtr doc,\n\t\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t\t int type,\n\t\t\t\t\t\t const xmlChar *ExternalID,\n\t\t\t\t\t\t const xmlChar *SystemID,\n\t\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\t\txmlGetPredefinedEntity\t(const xmlChar *name);\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\t\txmlGetDocEntity\t\t(const xmlDoc *doc,\n\t\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\t\txmlGetDtdEntity\t\t(xmlDocPtr doc,\n\t\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlEntityPtr XMLCALL\n\t\t\txmlGetParameterEntity\t(xmlDocPtr doc,\n\t\t\t\t\t\t const xmlChar *name);\n#ifdef LIBXML_LEGACY_ENABLED\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t\txmlEncodeEntities\t(xmlDocPtr doc,\n\t\t\t\t\t\t const xmlChar *input);\n#endif /* LIBXML_LEGACY_ENABLED */\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlEncodeEntitiesReentrant(xmlDocPtr doc,\n\t\t\t\t\t\t const xmlChar *input);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlEncodeSpecialChars\t(const xmlDoc *doc,\n\t\t\t\t\t\t const xmlChar *input);\nXMLPUBFUN xmlEntitiesTablePtr XMLCALL\n\t\t\txmlCreateEntitiesTable\t(void);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN xmlEntitiesTablePtr XMLCALL\n\t\t\txmlCopyEntitiesTable\t(xmlEntitiesTablePtr table);\n#endif /* LIBXML_TREE_ENABLED */\nXMLPUBFUN void XMLCALL\n\t\t\txmlFreeEntitiesTable\t(xmlEntitiesTablePtr table);\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN void XMLCALL\n\t\t\txmlDumpEntitiesTable\t(xmlBufferPtr buf,\n\t\t\t\t\t\t xmlEntitiesTablePtr table);\nXMLPUBFUN void XMLCALL\n\t\t\txmlDumpEntityDecl\t(xmlBufferPtr buf,\n\t\t\t\t\t\t xmlEntityPtr ent);\n#endif /* LIBXML_OUTPUT_ENABLED */\n#ifdef LIBXML_LEGACY_ENABLED\nXMLPUBFUN void XMLCALL\n\t\t\txmlCleanupPredefinedEntities(void);\n#endif /* LIBXML_LEGACY_ENABLED */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n# endif /* __XML_ENTITIES_H__ */\n"}, "31": {"id": 31, "path": "/usr/include/libxml2/libxml/globals.h", "content": "/*\n * Summary: interface for all global variables of the library\n * Description: all the global variables and thread handling for\n *              those variables is handled by this module.\n *\n * The bottom of this file is automatically generated by build_glob.py\n * based on the description file global.data\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard\n */\n\n#ifndef __XML_GLOBALS_H\n#define __XML_GLOBALS_H\n\n#include <libxml/xmlversion.h>\n#include <libxml/parser.h>\n#include <libxml/xmlerror.h>\n#include <libxml/SAX2.h>\n#include <libxml/xmlmemory.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nXMLPUBFUN void XMLCALL xmlInitGlobals(void);\nXMLPUBFUN void XMLCALL xmlCleanupGlobals(void);\n\n/**\n * xmlParserInputBufferCreateFilenameFunc:\n * @URI: the URI to read from\n * @enc: the requested source encoding\n *\n * Signature for the function doing the lookup for a suitable input method\n * corresponding to an URI.\n *\n * Returns the new xmlParserInputBufferPtr in case of success or NULL if no\n *         method was found.\n */\ntypedef xmlParserInputBufferPtr (*xmlParserInputBufferCreateFilenameFunc) (const char *URI,\n\t\t\t\t\t\t\t\t\t   xmlCharEncoding enc);\n\n\n/**\n * xmlOutputBufferCreateFilenameFunc:\n * @URI: the URI to write to\n * @enc: the requested target encoding\n *\n * Signature for the function doing the lookup for a suitable output method\n * corresponding to an URI.\n *\n * Returns the new xmlOutputBufferPtr in case of success or NULL if no\n *         method was found.\n */\ntypedef xmlOutputBufferPtr (*xmlOutputBufferCreateFilenameFunc) (const char *URI,\n\t\t\t\t\t\t\t\t xmlCharEncodingHandlerPtr encoder,\n\t\t\t\t\t\t\t\t int compression);\n\nXMLPUBFUN xmlParserInputBufferCreateFilenameFunc\nXMLCALL xmlParserInputBufferCreateFilenameDefault (xmlParserInputBufferCreateFilenameFunc func);\nXMLPUBFUN xmlOutputBufferCreateFilenameFunc\nXMLCALL xmlOutputBufferCreateFilenameDefault (xmlOutputBufferCreateFilenameFunc func);\n\n/*\n * Externally global symbols which need to be protected for backwards\n * compatibility support.\n */\n\n#undef\tdocbDefaultSAXHandler\n#undef\thtmlDefaultSAXHandler\n#undef\toldXMLWDcompatibility\n#undef\txmlBufferAllocScheme\n#undef\txmlDefaultBufferSize\n#undef\txmlDefaultSAXHandler\n#undef\txmlDefaultSAXLocator\n#undef\txmlDoValidityCheckingDefaultValue\n#undef\txmlFree\n#undef\txmlGenericError\n#undef\txmlStructuredError\n#undef\txmlGenericErrorContext\n#undef\txmlStructuredErrorContext\n#undef\txmlGetWarningsDefaultValue\n#undef\txmlIndentTreeOutput\n#undef  xmlTreeIndentString\n#undef\txmlKeepBlanksDefaultValue\n#undef\txmlLineNumbersDefaultValue\n#undef\txmlLoadExtDtdDefaultValue\n#undef\txmlMalloc\n#undef\txmlMallocAtomic\n#undef\txmlMemStrdup\n#undef\txmlParserDebugEntities\n#undef\txmlParserVersion\n#undef\txmlPedanticParserDefaultValue\n#undef\txmlRealloc\n#undef\txmlSaveNoEmptyTags\n#undef\txmlSubstituteEntitiesDefaultValue\n#undef  xmlRegisterNodeDefaultValue\n#undef  xmlDeregisterNodeDefaultValue\n#undef  xmlLastError\n#undef  xmlParserInputBufferCreateFilenameValue\n#undef  xmlOutputBufferCreateFilenameValue\n\n/**\n * xmlRegisterNodeFunc:\n * @node: the current node\n *\n * Signature for the registration callback of a created node\n */\ntypedef void (*xmlRegisterNodeFunc) (xmlNodePtr node);\n/**\n * xmlDeregisterNodeFunc:\n * @node: the current node\n *\n * Signature for the deregistration callback of a discarded node\n */\ntypedef void (*xmlDeregisterNodeFunc) (xmlNodePtr node);\n\ntypedef struct _xmlGlobalState xmlGlobalState;\ntypedef xmlGlobalState *xmlGlobalStatePtr;\nstruct _xmlGlobalState\n{\n\tconst char *xmlParserVersion;\n\n\txmlSAXLocator xmlDefaultSAXLocator;\n\txmlSAXHandlerV1 xmlDefaultSAXHandler;\n\txmlSAXHandlerV1 docbDefaultSAXHandler;\n\txmlSAXHandlerV1 htmlDefaultSAXHandler;\n\n\txmlFreeFunc xmlFree;\n\txmlMallocFunc xmlMalloc;\n\txmlStrdupFunc xmlMemStrdup;\n\txmlReallocFunc xmlRealloc;\n\n\txmlGenericErrorFunc xmlGenericError;\n\txmlStructuredErrorFunc xmlStructuredError;\n\tvoid *xmlGenericErrorContext;\n\n\tint oldXMLWDcompatibility;\n\n\txmlBufferAllocationScheme xmlBufferAllocScheme;\n\tint xmlDefaultBufferSize;\n\n\tint xmlSubstituteEntitiesDefaultValue;\n\tint xmlDoValidityCheckingDefaultValue;\n\tint xmlGetWarningsDefaultValue;\n\tint xmlKeepBlanksDefaultValue;\n\tint xmlLineNumbersDefaultValue;\n\tint xmlLoadExtDtdDefaultValue;\n\tint xmlParserDebugEntities;\n\tint xmlPedanticParserDefaultValue;\n\n\tint xmlSaveNoEmptyTags;\n\tint xmlIndentTreeOutput;\n\tconst char *xmlTreeIndentString;\n\n\txmlRegisterNodeFunc xmlRegisterNodeDefaultValue;\n\txmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;\n\n\txmlMallocFunc xmlMallocAtomic;\n\txmlError xmlLastError;\n\n\txmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;\n\txmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;\n\n\tvoid *xmlStructuredErrorContext;\n};\n\n#ifdef __cplusplus\n}\n#endif\n#include <libxml/threads.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nXMLPUBFUN void XMLCALL\txmlInitializeGlobalState(xmlGlobalStatePtr gs);\n\nXMLPUBFUN void XMLCALL xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler);\n\nXMLPUBFUN void XMLCALL xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler);\n\nXMLPUBFUN xmlRegisterNodeFunc XMLCALL xmlRegisterNodeDefault(xmlRegisterNodeFunc func);\nXMLPUBFUN xmlRegisterNodeFunc XMLCALL xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func);\nXMLPUBFUN xmlDeregisterNodeFunc XMLCALL xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func);\nXMLPUBFUN xmlDeregisterNodeFunc XMLCALL xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func);\n\nXMLPUBFUN xmlOutputBufferCreateFilenameFunc XMLCALL\n\txmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func);\nXMLPUBFUN xmlParserInputBufferCreateFilenameFunc XMLCALL\n\txmlThrDefParserInputBufferCreateFilenameDefault(\n\t\t\t\txmlParserInputBufferCreateFilenameFunc func);\n\n/** DOC_DISABLE */\n/*\n * In general the memory allocation entry points are not kept\n * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED\n *    - xmlMalloc\n *    - xmlMallocAtomic\n *    - xmlRealloc\n *    - xmlMemStrdup\n *    - xmlFree\n */\n\n#ifdef LIBXML_THREAD_ALLOC_ENABLED\n#ifdef LIBXML_THREAD_ENABLED\nXMLPUBFUN  xmlMallocFunc * XMLCALL __xmlMalloc(void);\n#define xmlMalloc \\\n(*(__xmlMalloc()))\n#else\nXMLPUBVAR xmlMallocFunc xmlMalloc;\n#endif\n\n#ifdef LIBXML_THREAD_ENABLED\nXMLPUBFUN  xmlMallocFunc * XMLCALL __xmlMallocAtomic(void);\n#define xmlMallocAtomic \\\n(*(__xmlMallocAtomic()))\n#else\nXMLPUBVAR xmlMallocFunc xmlMallocAtomic;\n#endif\n\n#ifdef LIBXML_THREAD_ENABLED\nXMLPUBFUN  xmlReallocFunc * XMLCALL __xmlRealloc(void);\n#define xmlRealloc \\\n(*(__xmlRealloc()))\n#else\nXMLPUBVAR xmlReallocFunc xmlRealloc;\n#endif\n\n#ifdef LIBXML_THREAD_ENABLED\nXMLPUBFUN  xmlFreeFunc * XMLCALL __xmlFree(void);\n#define xmlFree \\\n(*(__xmlFree()))\n#else\nXMLPUBVAR xmlFreeFunc xmlFree;\n#endif\n\n#ifdef LIBXML_THREAD_ENABLED\nXMLPUBFUN  xmlStrdupFunc * XMLCALL __xmlMemStrdup(void);\n#define xmlMemStrdup \\\n(*(__xmlMemStrdup()))\n#else\nXMLPUBVAR xmlStrdupFunc xmlMemStrdup;\n#endif\n\n#else /* !LIBXML_THREAD_ALLOC_ENABLED */\nXMLPUBVAR xmlMallocFunc xmlMalloc;\nXMLPUBVAR xmlMallocFunc xmlMallocAtomic;\nXMLPUBVAR xmlReallocFunc xmlRealloc;\nXMLPUBVAR xmlFreeFunc xmlFree;\nXMLPUBVAR xmlStrdupFunc xmlMemStrdup;\n#endif /* LIBXML_THREAD_ALLOC_ENABLED */\n\n#ifdef LIBXML_DOCB_ENABLED\nXMLPUBFUN  xmlSAXHandlerV1 * XMLCALL __docbDefaultSAXHandler(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define docbDefaultSAXHandler \\\n(*(__docbDefaultSAXHandler()))\n#else\nXMLPUBVAR xmlSAXHandlerV1 docbDefaultSAXHandler;\n#endif\n#endif\n\n#ifdef LIBXML_HTML_ENABLED\nXMLPUBFUN xmlSAXHandlerV1 * XMLCALL __htmlDefaultSAXHandler(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define htmlDefaultSAXHandler \\\n(*(__htmlDefaultSAXHandler()))\n#else\nXMLPUBVAR xmlSAXHandlerV1 htmlDefaultSAXHandler;\n#endif\n#endif\n\nXMLPUBFUN xmlError * XMLCALL __xmlLastError(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlLastError \\\n(*(__xmlLastError()))\n#else\nXMLPUBVAR xmlError xmlLastError;\n#endif\n\n/*\n * Everything starting from the line below is\n * Automatically generated by build_glob.py.\n * Do not modify the previous line.\n */\n\n\nXMLPUBFUN int * XMLCALL __oldXMLWDcompatibility(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define oldXMLWDcompatibility \\\n(*(__oldXMLWDcompatibility()))\n#else\nXMLPUBVAR int oldXMLWDcompatibility;\n#endif\n\nXMLPUBFUN xmlBufferAllocationScheme * XMLCALL __xmlBufferAllocScheme(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlBufferAllocScheme \\\n(*(__xmlBufferAllocScheme()))\n#else\nXMLPUBVAR xmlBufferAllocationScheme xmlBufferAllocScheme;\n#endif\nXMLPUBFUN xmlBufferAllocationScheme XMLCALL\n\txmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v);\n\nXMLPUBFUN int * XMLCALL __xmlDefaultBufferSize(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlDefaultBufferSize \\\n(*(__xmlDefaultBufferSize()))\n#else\nXMLPUBVAR int xmlDefaultBufferSize;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefDefaultBufferSize(int v);\n\nXMLPUBFUN xmlSAXHandlerV1 * XMLCALL __xmlDefaultSAXHandler(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlDefaultSAXHandler \\\n(*(__xmlDefaultSAXHandler()))\n#else\nXMLPUBVAR xmlSAXHandlerV1 xmlDefaultSAXHandler;\n#endif\n\nXMLPUBFUN xmlSAXLocator * XMLCALL __xmlDefaultSAXLocator(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlDefaultSAXLocator \\\n(*(__xmlDefaultSAXLocator()))\n#else\nXMLPUBVAR xmlSAXLocator xmlDefaultSAXLocator;\n#endif\n\nXMLPUBFUN int * XMLCALL __xmlDoValidityCheckingDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlDoValidityCheckingDefaultValue \\\n(*(__xmlDoValidityCheckingDefaultValue()))\n#else\nXMLPUBVAR int xmlDoValidityCheckingDefaultValue;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefDoValidityCheckingDefaultValue(int v);\n\nXMLPUBFUN xmlGenericErrorFunc * XMLCALL __xmlGenericError(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlGenericError \\\n(*(__xmlGenericError()))\n#else\nXMLPUBVAR xmlGenericErrorFunc xmlGenericError;\n#endif\n\nXMLPUBFUN xmlStructuredErrorFunc * XMLCALL __xmlStructuredError(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlStructuredError \\\n(*(__xmlStructuredError()))\n#else\nXMLPUBVAR xmlStructuredErrorFunc xmlStructuredError;\n#endif\n\nXMLPUBFUN void * * XMLCALL __xmlGenericErrorContext(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlGenericErrorContext \\\n(*(__xmlGenericErrorContext()))\n#else\nXMLPUBVAR void * xmlGenericErrorContext;\n#endif\n\nXMLPUBFUN void * * XMLCALL __xmlStructuredErrorContext(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlStructuredErrorContext \\\n(*(__xmlStructuredErrorContext()))\n#else\nXMLPUBVAR void * xmlStructuredErrorContext;\n#endif\n\nXMLPUBFUN int * XMLCALL __xmlGetWarningsDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlGetWarningsDefaultValue \\\n(*(__xmlGetWarningsDefaultValue()))\n#else\nXMLPUBVAR int xmlGetWarningsDefaultValue;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefGetWarningsDefaultValue(int v);\n\nXMLPUBFUN int * XMLCALL __xmlIndentTreeOutput(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlIndentTreeOutput \\\n(*(__xmlIndentTreeOutput()))\n#else\nXMLPUBVAR int xmlIndentTreeOutput;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefIndentTreeOutput(int v);\n\nXMLPUBFUN const char * * XMLCALL __xmlTreeIndentString(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlTreeIndentString \\\n(*(__xmlTreeIndentString()))\n#else\nXMLPUBVAR const char * xmlTreeIndentString;\n#endif\nXMLPUBFUN const char * XMLCALL xmlThrDefTreeIndentString(const char * v);\n\nXMLPUBFUN int * XMLCALL __xmlKeepBlanksDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlKeepBlanksDefaultValue \\\n(*(__xmlKeepBlanksDefaultValue()))\n#else\nXMLPUBVAR int xmlKeepBlanksDefaultValue;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefKeepBlanksDefaultValue(int v);\n\nXMLPUBFUN int * XMLCALL __xmlLineNumbersDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlLineNumbersDefaultValue \\\n(*(__xmlLineNumbersDefaultValue()))\n#else\nXMLPUBVAR int xmlLineNumbersDefaultValue;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefLineNumbersDefaultValue(int v);\n\nXMLPUBFUN int * XMLCALL __xmlLoadExtDtdDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlLoadExtDtdDefaultValue \\\n(*(__xmlLoadExtDtdDefaultValue()))\n#else\nXMLPUBVAR int xmlLoadExtDtdDefaultValue;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefLoadExtDtdDefaultValue(int v);\n\nXMLPUBFUN int * XMLCALL __xmlParserDebugEntities(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlParserDebugEntities \\\n(*(__xmlParserDebugEntities()))\n#else\nXMLPUBVAR int xmlParserDebugEntities;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefParserDebugEntities(int v);\n\nXMLPUBFUN const char * * XMLCALL __xmlParserVersion(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlParserVersion \\\n(*(__xmlParserVersion()))\n#else\nXMLPUBVAR const char * xmlParserVersion;\n#endif\n\nXMLPUBFUN int * XMLCALL __xmlPedanticParserDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlPedanticParserDefaultValue \\\n(*(__xmlPedanticParserDefaultValue()))\n#else\nXMLPUBVAR int xmlPedanticParserDefaultValue;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefPedanticParserDefaultValue(int v);\n\nXMLPUBFUN int * XMLCALL __xmlSaveNoEmptyTags(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlSaveNoEmptyTags \\\n(*(__xmlSaveNoEmptyTags()))\n#else\nXMLPUBVAR int xmlSaveNoEmptyTags;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefSaveNoEmptyTags(int v);\n\nXMLPUBFUN int * XMLCALL __xmlSubstituteEntitiesDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlSubstituteEntitiesDefaultValue \\\n(*(__xmlSubstituteEntitiesDefaultValue()))\n#else\nXMLPUBVAR int xmlSubstituteEntitiesDefaultValue;\n#endif\nXMLPUBFUN int XMLCALL xmlThrDefSubstituteEntitiesDefaultValue(int v);\n\nXMLPUBFUN xmlRegisterNodeFunc * XMLCALL __xmlRegisterNodeDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlRegisterNodeDefaultValue \\\n(*(__xmlRegisterNodeDefaultValue()))\n#else\nXMLPUBVAR xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;\n#endif\n\nXMLPUBFUN xmlDeregisterNodeFunc * XMLCALL __xmlDeregisterNodeDefaultValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlDeregisterNodeDefaultValue \\\n(*(__xmlDeregisterNodeDefaultValue()))\n#else\nXMLPUBVAR xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;\n#endif\n\nXMLPUBFUN xmlParserInputBufferCreateFilenameFunc * XMLCALL \\\n\t\t\t\t__xmlParserInputBufferCreateFilenameValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlParserInputBufferCreateFilenameValue \\\n(*(__xmlParserInputBufferCreateFilenameValue()))\n#else\nXMLPUBVAR xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;\n#endif\n\nXMLPUBFUN xmlOutputBufferCreateFilenameFunc * XMLCALL __xmlOutputBufferCreateFilenameValue(void);\n#ifdef LIBXML_THREAD_ENABLED\n#define xmlOutputBufferCreateFilenameValue \\\n(*(__xmlOutputBufferCreateFilenameValue()))\n#else\nXMLPUBVAR xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __XML_GLOBALS_H */\n"}, "32": {"id": 32, "path": "/usr/include/libxml2/libxml/hash.h", "content": "/*\n * Summary: Chained hash tables\n * Description: This module implements the hash table support used in\n *\t\tvarious places in the library.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Bjorn Reese <bjorn.reese@systematic.dk>\n */\n\n#ifndef __XML_HASH_H__\n#define __XML_HASH_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * The hash table.\n */\ntypedef struct _xmlHashTable xmlHashTable;\ntypedef xmlHashTable *xmlHashTablePtr;\n\n#ifdef __cplusplus\n}\n#endif\n\n#include <libxml/xmlversion.h>\n#include <libxml/parser.h>\n#include <libxml/dict.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Recent version of gcc produce a warning when a function pointer is assigned\n * to an object pointer, or vice versa.  The following macro is a dirty hack\n * to allow suppression of the warning.  If your architecture has function\n * pointers which are a different size than a void pointer, there may be some\n * serious trouble within the library.\n */\n/**\n * XML_CAST_FPTR:\n * @fptr:  pointer to a function\n *\n * Macro to do a casting from an object pointer to a\n * function pointer without encountering a warning from\n * gcc\n *\n * #define XML_CAST_FPTR(fptr) (*(void **)(&fptr))\n * This macro violated ISO C aliasing rules (gcc4 on s390 broke)\n * so it is disabled now\n */\n\n#define XML_CAST_FPTR(fptr) fptr\n\n\n/*\n * function types:\n */\n/**\n * xmlHashDeallocator:\n * @payload:  the data in the hash\n * @name:  the name associated\n *\n * Callback to free data from a hash.\n */\ntypedef void (*xmlHashDeallocator)(void *payload, const xmlChar *name);\n/**\n * xmlHashCopier:\n * @payload:  the data in the hash\n * @name:  the name associated\n *\n * Callback to copy data from a hash.\n *\n * Returns a copy of the data or NULL in case of error.\n */\ntypedef void *(*xmlHashCopier)(void *payload, const xmlChar *name);\n/**\n * xmlHashScanner:\n * @payload:  the data in the hash\n * @data:  extra scanner data\n * @name:  the name associated\n *\n * Callback when scanning data in a hash with the simple scanner.\n */\ntypedef void (*xmlHashScanner)(void *payload, void *data, const xmlChar *name);\n/**\n * xmlHashScannerFull:\n * @payload:  the data in the hash\n * @data:  extra scanner data\n * @name:  the name associated\n * @name2:  the second name associated\n * @name3:  the third name associated\n *\n * Callback when scanning data in a hash with the full scanner.\n */\ntypedef void (*xmlHashScannerFull)(void *payload, void *data,\n\t\t\t\t   const xmlChar *name, const xmlChar *name2,\n\t\t\t\t   const xmlChar *name3);\n\n/*\n * Constructor and destructor.\n */\nXMLPUBFUN xmlHashTablePtr XMLCALL\n\t\t\txmlHashCreate\t(int size);\nXMLPUBFUN xmlHashTablePtr XMLCALL\n\t\t\txmlHashCreateDict(int size,\n\t\t\t\t\t xmlDictPtr dict);\nXMLPUBFUN void XMLCALL\n\t\t\txmlHashFree\t(xmlHashTablePtr table,\n\t\t\t\t\t xmlHashDeallocator f);\nXMLPUBFUN void XMLCALL\n\t\t\txmlHashDefaultDeallocator(void *entry,\n\t\t\t\t\t const xmlChar *name);\n\n/*\n * Add a new entry to the hash table.\n */\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashAddEntry\t(xmlHashTablePtr table,\n\t\t                         const xmlChar *name,\n\t\t                         void *userdata);\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashUpdateEntry(xmlHashTablePtr table,\n\t\t                         const xmlChar *name,\n\t\t                         void *userdata,\n\t\t\t\t\t xmlHashDeallocator f);\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashAddEntry2(xmlHashTablePtr table,\n\t\t                         const xmlChar *name,\n\t\t                         const xmlChar *name2,\n\t\t                         void *userdata);\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashUpdateEntry2(xmlHashTablePtr table,\n\t\t                         const xmlChar *name,\n\t\t                         const xmlChar *name2,\n\t\t                         void *userdata,\n\t\t\t\t\t xmlHashDeallocator f);\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashAddEntry3(xmlHashTablePtr table,\n\t\t                         const xmlChar *name,\n\t\t                         const xmlChar *name2,\n\t\t                         const xmlChar *name3,\n\t\t                         void *userdata);\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashUpdateEntry3(xmlHashTablePtr table,\n\t\t                         const xmlChar *name,\n\t\t                         const xmlChar *name2,\n\t\t                         const xmlChar *name3,\n\t\t                         void *userdata,\n\t\t\t\t\t xmlHashDeallocator f);\n\n/*\n * Remove an entry from the hash table.\n */\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name,\n                           xmlHashDeallocator f);\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name,\n                            const xmlChar *name2, xmlHashDeallocator f);\nXMLPUBFUN int  XMLCALL\n\t\t\txmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name,\n                            const xmlChar *name2, const xmlChar *name3,\n                            xmlHashDeallocator f);\n\n/*\n * Retrieve the userdata.\n */\nXMLPUBFUN void * XMLCALL\n\t\t\txmlHashLookup\t(xmlHashTablePtr table,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN void * XMLCALL\n\t\t\txmlHashLookup2\t(xmlHashTablePtr table,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *name2);\nXMLPUBFUN void * XMLCALL\n\t\t\txmlHashLookup3\t(xmlHashTablePtr table,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *name2,\n\t\t\t\t\t const xmlChar *name3);\nXMLPUBFUN void * XMLCALL\n\t\t\txmlHashQLookup\t(xmlHashTablePtr table,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *prefix);\nXMLPUBFUN void * XMLCALL\n\t\t\txmlHashQLookup2\t(xmlHashTablePtr table,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *prefix,\n\t\t\t\t\t const xmlChar *name2,\n\t\t\t\t\t const xmlChar *prefix2);\nXMLPUBFUN void * XMLCALL\n\t\t\txmlHashQLookup3\t(xmlHashTablePtr table,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *prefix,\n\t\t\t\t\t const xmlChar *name2,\n\t\t\t\t\t const xmlChar *prefix2,\n\t\t\t\t\t const xmlChar *name3,\n\t\t\t\t\t const xmlChar *prefix3);\n\n/*\n * Helpers.\n */\nXMLPUBFUN xmlHashTablePtr XMLCALL\n\t\t\txmlHashCopy\t(xmlHashTablePtr table,\n\t\t\t\t\t xmlHashCopier f);\nXMLPUBFUN int XMLCALL\n\t\t\txmlHashSize\t(xmlHashTablePtr table);\nXMLPUBFUN void XMLCALL\n\t\t\txmlHashScan\t(xmlHashTablePtr table,\n\t\t\t\t\t xmlHashScanner f,\n\t\t\t\t\t void *data);\nXMLPUBFUN void XMLCALL\n\t\t\txmlHashScan3\t(xmlHashTablePtr table,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *name2,\n\t\t\t\t\t const xmlChar *name3,\n\t\t\t\t\t xmlHashScanner f,\n\t\t\t\t\t void *data);\nXMLPUBFUN void XMLCALL\n\t\t\txmlHashScanFull\t(xmlHashTablePtr table,\n\t\t\t\t\t xmlHashScannerFull f,\n\t\t\t\t\t void *data);\nXMLPUBFUN void XMLCALL\n\t\t\txmlHashScanFull3(xmlHashTablePtr table,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *name2,\n\t\t\t\t\t const xmlChar *name3,\n\t\t\t\t\t xmlHashScannerFull f,\n\t\t\t\t\t void *data);\n#ifdef __cplusplus\n}\n#endif\n#endif /* ! __XML_HASH_H__ */\n"}, "33": {"id": 33, "path": "/usr/include/libxml2/libxml/list.h", "content": "/*\n * Summary: lists interfaces\n * Description: this module implement the list support used in\n * various place in the library.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Gary Pennington <Gary.Pennington@uk.sun.com>\n */\n\n#ifndef __XML_LINK_INCLUDE__\n#define __XML_LINK_INCLUDE__\n\n#include <libxml/xmlversion.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct _xmlLink xmlLink;\ntypedef xmlLink *xmlLinkPtr;\n\ntypedef struct _xmlList xmlList;\ntypedef xmlList *xmlListPtr;\n\n/**\n * xmlListDeallocator:\n * @lk:  the data to deallocate\n *\n * Callback function used to free data from a list.\n */\ntypedef void (*xmlListDeallocator) (xmlLinkPtr lk);\n/**\n * xmlListDataCompare:\n * @data0: the first data\n * @data1: the second data\n *\n * Callback function used to compare 2 data.\n *\n * Returns 0 is equality, -1 or 1 otherwise depending on the ordering.\n */\ntypedef int  (*xmlListDataCompare) (const void *data0, const void *data1);\n/**\n * xmlListWalker:\n * @data: the data found in the list\n * @user: extra user provided data to the walker\n *\n * Callback function used when walking a list with xmlListWalk().\n *\n * Returns 0 to stop walking the list, 1 otherwise.\n */\ntypedef int (*xmlListWalker) (const void *data, void *user);\n\n/* Creation/Deletion */\nXMLPUBFUN xmlListPtr XMLCALL\n\t\txmlListCreate\t\t(xmlListDeallocator deallocator,\n\t                                 xmlListDataCompare compare);\nXMLPUBFUN void XMLCALL\n\t\txmlListDelete\t\t(xmlListPtr l);\n\n/* Basic Operators */\nXMLPUBFUN void * XMLCALL\n\t\txmlListSearch\t\t(xmlListPtr l,\n\t\t\t\t\t void *data);\nXMLPUBFUN void * XMLCALL\n\t\txmlListReverseSearch\t(xmlListPtr l,\n\t\t\t\t\t void *data);\nXMLPUBFUN int XMLCALL\n\t\txmlListInsert\t\t(xmlListPtr l,\n\t\t\t\t\t void *data) ;\nXMLPUBFUN int XMLCALL\n\t\txmlListAppend\t\t(xmlListPtr l,\n\t\t\t\t\t void *data) ;\nXMLPUBFUN int XMLCALL\n\t\txmlListRemoveFirst\t(xmlListPtr l,\n\t\t\t\t\t void *data);\nXMLPUBFUN int XMLCALL\n\t\txmlListRemoveLast\t(xmlListPtr l,\n\t\t\t\t\t void *data);\nXMLPUBFUN int XMLCALL\n\t\txmlListRemoveAll\t(xmlListPtr l,\n\t\t\t\t\t void *data);\nXMLPUBFUN void XMLCALL\n\t\txmlListClear\t\t(xmlListPtr l);\nXMLPUBFUN int XMLCALL\n\t\txmlListEmpty\t\t(xmlListPtr l);\nXMLPUBFUN xmlLinkPtr XMLCALL\n\t\txmlListFront\t\t(xmlListPtr l);\nXMLPUBFUN xmlLinkPtr XMLCALL\n\t\txmlListEnd\t\t(xmlListPtr l);\nXMLPUBFUN int XMLCALL\n\t\txmlListSize\t\t(xmlListPtr l);\n\nXMLPUBFUN void XMLCALL\n\t\txmlListPopFront\t\t(xmlListPtr l);\nXMLPUBFUN void XMLCALL\n\t\txmlListPopBack\t\t(xmlListPtr l);\nXMLPUBFUN int XMLCALL\n\t\txmlListPushFront\t(xmlListPtr l,\n\t\t\t\t\t void *data);\nXMLPUBFUN int XMLCALL\n\t\txmlListPushBack\t\t(xmlListPtr l,\n\t\t\t\t\t void *data);\n\n/* Advanced Operators */\nXMLPUBFUN void XMLCALL\n\t\txmlListReverse\t\t(xmlListPtr l);\nXMLPUBFUN void XMLCALL\n\t\txmlListSort\t\t(xmlListPtr l);\nXMLPUBFUN void XMLCALL\n\t\txmlListWalk\t\t(xmlListPtr l,\n\t\t\t\t\t xmlListWalker walker,\n\t\t\t\t\t void *user);\nXMLPUBFUN void XMLCALL\n\t\txmlListReverseWalk\t(xmlListPtr l,\n\t\t\t\t\t xmlListWalker walker,\n\t\t\t\t\t void *user);\nXMLPUBFUN void XMLCALL\n\t\txmlListMerge\t\t(xmlListPtr l1,\n\t\t\t\t\t xmlListPtr l2);\nXMLPUBFUN xmlListPtr XMLCALL\n\t\txmlListDup\t\t(const xmlListPtr old);\nXMLPUBFUN int XMLCALL\n\t\txmlListCopy\t\t(xmlListPtr cur,\n\t\t\t\t\t const xmlListPtr old);\n/* Link operators */\nXMLPUBFUN void * XMLCALL\n\t\txmlLinkGetData          (xmlLinkPtr lk);\n\n/* xmlListUnique() */\n/* xmlListSwap */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __XML_LINK_INCLUDE__ */\n"}, "34": {"id": 34, "path": "/usr/include/libxml2/libxml/parser.h", "content": "/*\n * Summary: the core parser module\n * Description: Interfaces, constants and types related to the XML parser\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_PARSER_H__\n#define __XML_PARSER_H__\n\n#include <stdarg.h>\n\n#include <libxml/xmlversion.h>\n#include <libxml/tree.h>\n#include <libxml/dict.h>\n#include <libxml/hash.h>\n#include <libxml/valid.h>\n#include <libxml/entities.h>\n#include <libxml/xmlerror.h>\n#include <libxml/xmlstring.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * XML_DEFAULT_VERSION:\n *\n * The default version of XML used: 1.0\n */\n#define XML_DEFAULT_VERSION\t\"1.0\"\n\n/**\n * xmlParserInput:\n *\n * An xmlParserInput is an input flow for the XML processor.\n * Each entity parsed is associated an xmlParserInput (except the\n * few predefined ones). This is the case both for internal entities\n * - in which case the flow is already completely in memory - or\n * external entities - in which case we use the buf structure for\n * progressive reading and I18N conversions to the internal UTF-8 format.\n */\n\n/**\n * xmlParserInputDeallocate:\n * @str:  the string to deallocate\n *\n * Callback for freeing some parser input allocations.\n */\ntypedef void (* xmlParserInputDeallocate)(xmlChar *str);\n\nstruct _xmlParserInput {\n    /* Input buffer */\n    xmlParserInputBufferPtr buf;      /* UTF-8 encoded buffer */\n\n    const char *filename;             /* The file analyzed, if any */\n    const char *directory;            /* the directory/base of the file */\n    const xmlChar *base;              /* Base of the array to parse */\n    const xmlChar *cur;               /* Current char being parsed */\n    const xmlChar *end;               /* end of the array to parse */\n    int length;                       /* length if known */\n    int line;                         /* Current line */\n    int col;                          /* Current column */\n    /*\n     * NOTE: consumed is only tested for equality in the parser code,\n     *       so even if there is an overflow this should not give troubles\n     *       for parsing very large instances.\n     */\n    unsigned long consumed;           /* How many xmlChars already consumed */\n    xmlParserInputDeallocate free;    /* function to deallocate the base */\n    const xmlChar *encoding;          /* the encoding string for entity */\n    const xmlChar *version;           /* the version string for entity */\n    int standalone;                   /* Was that entity marked standalone */\n    int id;                           /* an unique identifier for the entity */\n};\n\n/**\n * xmlParserNodeInfo:\n *\n * The parser can be asked to collect Node informations, i.e. at what\n * place in the file they were detected.\n * NOTE: This is off by default and not very well tested.\n */\ntypedef struct _xmlParserNodeInfo xmlParserNodeInfo;\ntypedef xmlParserNodeInfo *xmlParserNodeInfoPtr;\n\nstruct _xmlParserNodeInfo {\n  const struct _xmlNode* node;\n  /* Position & line # that text that created the node begins & ends on */\n  unsigned long begin_pos;\n  unsigned long begin_line;\n  unsigned long end_pos;\n  unsigned long end_line;\n};\n\ntypedef struct _xmlParserNodeInfoSeq xmlParserNodeInfoSeq;\ntypedef xmlParserNodeInfoSeq *xmlParserNodeInfoSeqPtr;\nstruct _xmlParserNodeInfoSeq {\n  unsigned long maximum;\n  unsigned long length;\n  xmlParserNodeInfo* buffer;\n};\n\n/**\n * xmlParserInputState:\n *\n * The parser is now working also as a state based parser.\n * The recursive one use the state info for entities processing.\n */\ntypedef enum {\n    XML_PARSER_EOF = -1,\t/* nothing is to be parsed */\n    XML_PARSER_START = 0,\t/* nothing has been parsed */\n    XML_PARSER_MISC,\t\t/* Misc* before int subset */\n    XML_PARSER_PI,\t\t/* Within a processing instruction */\n    XML_PARSER_DTD,\t\t/* within some DTD content */\n    XML_PARSER_PROLOG,\t\t/* Misc* after internal subset */\n    XML_PARSER_COMMENT,\t\t/* within a comment */\n    XML_PARSER_START_TAG,\t/* within a start tag */\n    XML_PARSER_CONTENT,\t\t/* within the content */\n    XML_PARSER_CDATA_SECTION,\t/* within a CDATA section */\n    XML_PARSER_END_TAG,\t\t/* within a closing tag */\n    XML_PARSER_ENTITY_DECL,\t/* within an entity declaration */\n    XML_PARSER_ENTITY_VALUE,\t/* within an entity value in a decl */\n    XML_PARSER_ATTRIBUTE_VALUE,\t/* within an attribute value */\n    XML_PARSER_SYSTEM_LITERAL,\t/* within a SYSTEM value */\n    XML_PARSER_EPILOG,\t\t/* the Misc* after the last end tag */\n    XML_PARSER_IGNORE,\t\t/* within an IGNORED section */\n    XML_PARSER_PUBLIC_LITERAL\t/* within a PUBLIC value */\n} xmlParserInputState;\n\n/**\n * XML_DETECT_IDS:\n *\n * Bit in the loadsubset context field to tell to do ID/REFs lookups.\n * Use it to initialize xmlLoadExtDtdDefaultValue.\n */\n#define XML_DETECT_IDS\t\t2\n\n/**\n * XML_COMPLETE_ATTRS:\n *\n * Bit in the loadsubset context field to tell to do complete the\n * elements attributes lists with the ones defaulted from the DTDs.\n * Use it to initialize xmlLoadExtDtdDefaultValue.\n */\n#define XML_COMPLETE_ATTRS\t4\n\n/**\n * XML_SKIP_IDS:\n *\n * Bit in the loadsubset context field to tell to not do ID/REFs registration.\n * Used to initialize xmlLoadExtDtdDefaultValue in some special cases.\n */\n#define XML_SKIP_IDS\t\t8\n\n/**\n * xmlParserMode:\n *\n * A parser can operate in various modes\n */\ntypedef enum {\n    XML_PARSE_UNKNOWN = 0,\n    XML_PARSE_DOM = 1,\n    XML_PARSE_SAX = 2,\n    XML_PARSE_PUSH_DOM = 3,\n    XML_PARSE_PUSH_SAX = 4,\n    XML_PARSE_READER = 5\n} xmlParserMode;\n\n/**\n * xmlParserCtxt:\n *\n * The parser context.\n * NOTE This doesn't completely define the parser state, the (current ?)\n *      design of the parser uses recursive function calls since this allow\n *      and easy mapping from the production rules of the specification\n *      to the actual code. The drawback is that the actual function call\n *      also reflect the parser state. However most of the parsing routines\n *      takes as the only argument the parser context pointer, so migrating\n *      to a state based parser for progressive parsing shouldn't be too hard.\n */\nstruct _xmlParserCtxt {\n    struct _xmlSAXHandler *sax;       /* The SAX handler */\n    void            *userData;        /* For SAX interface only, used by DOM build */\n    xmlDocPtr           myDoc;        /* the document being built */\n    int            wellFormed;        /* is the document well formed */\n    int       replaceEntities;        /* shall we replace entities ? */\n    const xmlChar    *version;        /* the XML version string */\n    const xmlChar   *encoding;        /* the declared encoding, if any */\n    int            standalone;        /* standalone document */\n    int                  html;        /* an HTML(1)/Docbook(2) document\n                                       * 3 is HTML after <head>\n                                       * 10 is HTML after <body>\n                                       */\n\n    /* Input stream stack */\n    xmlParserInputPtr  input;         /* Current input stream */\n    int                inputNr;       /* Number of current input streams */\n    int                inputMax;      /* Max number of input streams */\n    xmlParserInputPtr *inputTab;      /* stack of inputs */\n\n    /* Node analysis stack only used for DOM building */\n    xmlNodePtr         node;          /* Current parsed Node */\n    int                nodeNr;        /* Depth of the parsing stack */\n    int                nodeMax;       /* Max depth of the parsing stack */\n    xmlNodePtr        *nodeTab;       /* array of nodes */\n\n    int record_info;                  /* Whether node info should be kept */\n    xmlParserNodeInfoSeq node_seq;    /* info about each node parsed */\n\n    int errNo;                        /* error code */\n\n    int     hasExternalSubset;        /* reference and external subset */\n    int             hasPErefs;        /* the internal subset has PE refs */\n    int              external;        /* are we parsing an external entity */\n\n    int                 valid;        /* is the document valid */\n    int              validate;        /* shall we try to validate ? */\n    xmlValidCtxt        vctxt;        /* The validity context */\n\n    xmlParserInputState instate;      /* current type of input */\n    int                 token;        /* next char look-ahead */\n\n    char           *directory;        /* the data directory */\n\n    /* Node name stack */\n    const xmlChar     *name;          /* Current parsed Node */\n    int                nameNr;        /* Depth of the parsing stack */\n    int                nameMax;       /* Max depth of the parsing stack */\n    const xmlChar *   *nameTab;       /* array of nodes */\n\n    long               nbChars;       /* number of xmlChar processed */\n    long            checkIndex;       /* used by progressive parsing lookup */\n    int             keepBlanks;       /* ugly but ... */\n    int             disableSAX;       /* SAX callbacks are disabled */\n    int               inSubset;       /* Parsing is in int 1/ext 2 subset */\n    const xmlChar *    intSubName;    /* name of subset */\n    xmlChar *          extSubURI;     /* URI of external subset */\n    xmlChar *          extSubSystem;  /* SYSTEM ID of external subset */\n\n    /* xml:space values */\n    int *              space;         /* Should the parser preserve spaces */\n    int                spaceNr;       /* Depth of the parsing stack */\n    int                spaceMax;      /* Max depth of the parsing stack */\n    int *              spaceTab;      /* array of space infos */\n\n    int                depth;         /* to prevent entity substitution loops */\n    xmlParserInputPtr  entity;        /* used to check entities boundaries */\n    int                charset;       /* encoding of the in-memory content\n\t\t\t\t         actually an xmlCharEncoding */\n    int                nodelen;       /* Those two fields are there to */\n    int                nodemem;       /* Speed up large node parsing */\n    int                pedantic;      /* signal pedantic warnings */\n    void              *_private;      /* For user data, libxml won't touch it */\n\n    int                loadsubset;    /* should the external subset be loaded */\n    int                linenumbers;   /* set line number in element content */\n    void              *catalogs;      /* document's own catalog */\n    int                recovery;      /* run in recovery mode */\n    int                progressive;   /* is this a progressive parsing */\n    xmlDictPtr         dict;          /* dictionary for the parser */\n    const xmlChar *   *atts;          /* array for the attributes callbacks */\n    int                maxatts;       /* the size of the array */\n    int                docdict;       /* use strings from dict to build tree */\n\n    /*\n     * pre-interned strings\n     */\n    const xmlChar *str_xml;\n    const xmlChar *str_xmlns;\n    const xmlChar *str_xml_ns;\n\n    /*\n     * Everything below is used only by the new SAX mode\n     */\n    int                sax2;          /* operating in the new SAX mode */\n    int                nsNr;          /* the number of inherited namespaces */\n    int                nsMax;         /* the size of the arrays */\n    const xmlChar *   *nsTab;         /* the array of prefix/namespace name */\n    int               *attallocs;     /* which attribute were allocated */\n    void *            *pushTab;       /* array of data for push */\n    xmlHashTablePtr    attsDefault;   /* defaulted attributes if any */\n    xmlHashTablePtr    attsSpecial;   /* non-CDATA attributes if any */\n    int                nsWellFormed;  /* is the document XML Namespace okay */\n    int                options;       /* Extra options */\n\n    /*\n     * Those fields are needed only for streaming parsing so far\n     */\n    int               dictNames;    /* Use dictionary names for the tree */\n    int               freeElemsNr;  /* number of freed element nodes */\n    xmlNodePtr        freeElems;    /* List of freed element nodes */\n    int               freeAttrsNr;  /* number of freed attributes nodes */\n    xmlAttrPtr        freeAttrs;    /* List of freed attributes nodes */\n\n    /*\n     * the complete error informations for the last error.\n     */\n    xmlError          lastError;\n    xmlParserMode     parseMode;    /* the parser mode */\n    unsigned long    nbentities;    /* number of entities references */\n    unsigned long  sizeentities;    /* size of parsed entities */\n\n    /* for use by HTML non-recursive parser */\n    xmlParserNodeInfo *nodeInfo;      /* Current NodeInfo */\n    int                nodeInfoNr;    /* Depth of the parsing stack */\n    int                nodeInfoMax;   /* Max depth of the parsing stack */\n    xmlParserNodeInfo *nodeInfoTab;   /* array of nodeInfos */\n\n    int                input_id;      /* we need to label inputs */\n    unsigned long      sizeentcopy;   /* volume of entity copy */\n};\n\n/**\n * xmlSAXLocator:\n *\n * A SAX Locator.\n */\nstruct _xmlSAXLocator {\n    const xmlChar *(*getPublicId)(void *ctx);\n    const xmlChar *(*getSystemId)(void *ctx);\n    int (*getLineNumber)(void *ctx);\n    int (*getColumnNumber)(void *ctx);\n};\n\n/**\n * xmlSAXHandler:\n *\n * A SAX handler is bunch of callbacks called by the parser when processing\n * of the input generate data or structure informations.\n */\n\n/**\n * resolveEntitySAXFunc:\n * @ctx:  the user data (XML parser context)\n * @publicId: The public ID of the entity\n * @systemId: The system ID of the entity\n *\n * Callback:\n * The entity loader, to control the loading of external entities,\n * the application can either:\n *    - override this resolveEntity() callback in the SAX block\n *    - or better use the xmlSetExternalEntityLoader() function to\n *      set up it's own entity resolution routine\n *\n * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.\n */\ntypedef xmlParserInputPtr (*resolveEntitySAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *publicId,\n\t\t\t\tconst xmlChar *systemId);\n/**\n * internalSubsetSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name:  the root element name\n * @ExternalID:  the external ID\n * @SystemID:  the SYSTEM ID (e.g. filename or URL)\n *\n * Callback on internal subset declaration.\n */\ntypedef void (*internalSubsetSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name,\n\t\t\t\tconst xmlChar *ExternalID,\n\t\t\t\tconst xmlChar *SystemID);\n/**\n * externalSubsetSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name:  the root element name\n * @ExternalID:  the external ID\n * @SystemID:  the SYSTEM ID (e.g. filename or URL)\n *\n * Callback on external subset declaration.\n */\ntypedef void (*externalSubsetSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name,\n\t\t\t\tconst xmlChar *ExternalID,\n\t\t\t\tconst xmlChar *SystemID);\n/**\n * getEntitySAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name: The entity name\n *\n * Get an entity by name.\n *\n * Returns the xmlEntityPtr if found.\n */\ntypedef xmlEntityPtr (*getEntitySAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name);\n/**\n * getParameterEntitySAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name: The entity name\n *\n * Get a parameter entity by name.\n *\n * Returns the xmlEntityPtr if found.\n */\ntypedef xmlEntityPtr (*getParameterEntitySAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name);\n/**\n * entityDeclSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name:  the entity name\n * @type:  the entity type\n * @publicId: The public ID of the entity\n * @systemId: The system ID of the entity\n * @content: the entity value (without processing).\n *\n * An entity definition has been parsed.\n */\ntypedef void (*entityDeclSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name,\n\t\t\t\tint type,\n\t\t\t\tconst xmlChar *publicId,\n\t\t\t\tconst xmlChar *systemId,\n\t\t\t\txmlChar *content);\n/**\n * notationDeclSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name: The name of the notation\n * @publicId: The public ID of the entity\n * @systemId: The system ID of the entity\n *\n * What to do when a notation declaration has been parsed.\n */\ntypedef void (*notationDeclSAXFunc)(void *ctx,\n\t\t\t\tconst xmlChar *name,\n\t\t\t\tconst xmlChar *publicId,\n\t\t\t\tconst xmlChar *systemId);\n/**\n * attributeDeclSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @elem:  the name of the element\n * @fullname:  the attribute name\n * @type:  the attribute type\n * @def:  the type of default value\n * @defaultValue: the attribute default value\n * @tree:  the tree of enumerated value set\n *\n * An attribute definition has been parsed.\n */\ntypedef void (*attributeDeclSAXFunc)(void *ctx,\n\t\t\t\tconst xmlChar *elem,\n\t\t\t\tconst xmlChar *fullname,\n\t\t\t\tint type,\n\t\t\t\tint def,\n\t\t\t\tconst xmlChar *defaultValue,\n\t\t\t\txmlEnumerationPtr tree);\n/**\n * elementDeclSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name:  the element name\n * @type:  the element type\n * @content: the element value tree\n *\n * An element definition has been parsed.\n */\ntypedef void (*elementDeclSAXFunc)(void *ctx,\n\t\t\t\tconst xmlChar *name,\n\t\t\t\tint type,\n\t\t\t\txmlElementContentPtr content);\n/**\n * unparsedEntityDeclSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name: The name of the entity\n * @publicId: The public ID of the entity\n * @systemId: The system ID of the entity\n * @notationName: the name of the notation\n *\n * What to do when an unparsed entity declaration is parsed.\n */\ntypedef void (*unparsedEntityDeclSAXFunc)(void *ctx,\n\t\t\t\tconst xmlChar *name,\n\t\t\t\tconst xmlChar *publicId,\n\t\t\t\tconst xmlChar *systemId,\n\t\t\t\tconst xmlChar *notationName);\n/**\n * setDocumentLocatorSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @loc: A SAX Locator\n *\n * Receive the document locator at startup, actually xmlDefaultSAXLocator.\n * Everything is available on the context, so this is useless in our case.\n */\ntypedef void (*setDocumentLocatorSAXFunc) (void *ctx,\n\t\t\t\txmlSAXLocatorPtr loc);\n/**\n * startDocumentSAXFunc:\n * @ctx:  the user data (XML parser context)\n *\n * Called when the document start being processed.\n */\ntypedef void (*startDocumentSAXFunc) (void *ctx);\n/**\n * endDocumentSAXFunc:\n * @ctx:  the user data (XML parser context)\n *\n * Called when the document end has been detected.\n */\ntypedef void (*endDocumentSAXFunc) (void *ctx);\n/**\n * startElementSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name:  The element name, including namespace prefix\n * @atts:  An array of name/value attributes pairs, NULL terminated\n *\n * Called when an opening tag has been processed.\n */\ntypedef void (*startElementSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name,\n\t\t\t\tconst xmlChar **atts);\n/**\n * endElementSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name:  The element name\n *\n * Called when the end of an element has been detected.\n */\ntypedef void (*endElementSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name);\n/**\n * attributeSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name:  The attribute name, including namespace prefix\n * @value:  The attribute value\n *\n * Handle an attribute that has been read by the parser.\n * The default handling is to convert the attribute into an\n * DOM subtree and past it in a new xmlAttr element added to\n * the element.\n */\ntypedef void (*attributeSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name,\n\t\t\t\tconst xmlChar *value);\n/**\n * referenceSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @name:  The entity name\n *\n * Called when an entity reference is detected.\n */\ntypedef void (*referenceSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *name);\n/**\n * charactersSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @ch:  a xmlChar string\n * @len: the number of xmlChar\n *\n * Receiving some chars from the parser.\n */\ntypedef void (*charactersSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *ch,\n\t\t\t\tint len);\n/**\n * ignorableWhitespaceSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @ch:  a xmlChar string\n * @len: the number of xmlChar\n *\n * Receiving some ignorable whitespaces from the parser.\n * UNUSED: by default the DOM building will use characters.\n */\ntypedef void (*ignorableWhitespaceSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *ch,\n\t\t\t\tint len);\n/**\n * processingInstructionSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @target:  the target name\n * @data: the PI data's\n *\n * A processing instruction has been parsed.\n */\ntypedef void (*processingInstructionSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *target,\n\t\t\t\tconst xmlChar *data);\n/**\n * commentSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @value:  the comment content\n *\n * A comment has been parsed.\n */\ntypedef void (*commentSAXFunc) (void *ctx,\n\t\t\t\tconst xmlChar *value);\n/**\n * cdataBlockSAXFunc:\n * @ctx:  the user data (XML parser context)\n * @value:  The pcdata content\n * @len:  the block length\n *\n * Called when a pcdata block has been parsed.\n */\ntypedef void (*cdataBlockSAXFunc) (\n\t                        void *ctx,\n\t\t\t\tconst xmlChar *value,\n\t\t\t\tint len);\n/**\n * warningSAXFunc:\n * @ctx:  an XML parser context\n * @msg:  the message to display/transmit\n * @...:  extra parameters for the message display\n *\n * Display and format a warning messages, callback.\n */\ntypedef void (XMLCDECL *warningSAXFunc) (void *ctx,\n\t\t\t\tconst char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n/**\n * errorSAXFunc:\n * @ctx:  an XML parser context\n * @msg:  the message to display/transmit\n * @...:  extra parameters for the message display\n *\n * Display and format an error messages, callback.\n */\ntypedef void (XMLCDECL *errorSAXFunc) (void *ctx,\n\t\t\t\tconst char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n/**\n * fatalErrorSAXFunc:\n * @ctx:  an XML parser context\n * @msg:  the message to display/transmit\n * @...:  extra parameters for the message display\n *\n * Display and format fatal error messages, callback.\n * Note: so far fatalError() SAX callbacks are not used, error()\n *       get all the callbacks for errors.\n */\ntypedef void (XMLCDECL *fatalErrorSAXFunc) (void *ctx,\n\t\t\t\tconst char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n/**\n * isStandaloneSAXFunc:\n * @ctx:  the user data (XML parser context)\n *\n * Is this document tagged standalone?\n *\n * Returns 1 if true\n */\ntypedef int (*isStandaloneSAXFunc) (void *ctx);\n/**\n * hasInternalSubsetSAXFunc:\n * @ctx:  the user data (XML parser context)\n *\n * Does this document has an internal subset.\n *\n * Returns 1 if true\n */\ntypedef int (*hasInternalSubsetSAXFunc) (void *ctx);\n\n/**\n * hasExternalSubsetSAXFunc:\n * @ctx:  the user data (XML parser context)\n *\n * Does this document has an external subset?\n *\n * Returns 1 if true\n */\ntypedef int (*hasExternalSubsetSAXFunc) (void *ctx);\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\tThe SAX version 2 API extensions\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n/**\n * XML_SAX2_MAGIC:\n *\n * Special constant found in SAX2 blocks initialized fields\n */\n#define XML_SAX2_MAGIC 0xDEEDBEAF\n\n/**\n * startElementNsSAX2Func:\n * @ctx:  the user data (XML parser context)\n * @localname:  the local name of the element\n * @prefix:  the element namespace prefix if available\n * @URI:  the element namespace name if available\n * @nb_namespaces:  number of namespace definitions on that node\n * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions\n * @nb_attributes:  the number of attributes on that node\n * @nb_defaulted:  the number of defaulted attributes. The defaulted\n *                  ones are at the end of the array\n * @attributes:  pointer to the array of (localname/prefix/URI/value/end)\n *               attribute values.\n *\n * SAX2 callback when an element start has been detected by the parser.\n * It provides the namespace informations for the element, as well as\n * the new namespace declarations on the element.\n */\n\ntypedef void (*startElementNsSAX2Func) (void *ctx,\n\t\t\t\t\tconst xmlChar *localname,\n\t\t\t\t\tconst xmlChar *prefix,\n\t\t\t\t\tconst xmlChar *URI,\n\t\t\t\t\tint nb_namespaces,\n\t\t\t\t\tconst xmlChar **namespaces,\n\t\t\t\t\tint nb_attributes,\n\t\t\t\t\tint nb_defaulted,\n\t\t\t\t\tconst xmlChar **attributes);\n\n/**\n * endElementNsSAX2Func:\n * @ctx:  the user data (XML parser context)\n * @localname:  the local name of the element\n * @prefix:  the element namespace prefix if available\n * @URI:  the element namespace name if available\n *\n * SAX2 callback when an element end has been detected by the parser.\n * It provides the namespace informations for the element.\n */\n\ntypedef void (*endElementNsSAX2Func)   (void *ctx,\n\t\t\t\t\tconst xmlChar *localname,\n\t\t\t\t\tconst xmlChar *prefix,\n\t\t\t\t\tconst xmlChar *URI);\n\n\nstruct _xmlSAXHandler {\n    internalSubsetSAXFunc internalSubset;\n    isStandaloneSAXFunc isStandalone;\n    hasInternalSubsetSAXFunc hasInternalSubset;\n    hasExternalSubsetSAXFunc hasExternalSubset;\n    resolveEntitySAXFunc resolveEntity;\n    getEntitySAXFunc getEntity;\n    entityDeclSAXFunc entityDecl;\n    notationDeclSAXFunc notationDecl;\n    attributeDeclSAXFunc attributeDecl;\n    elementDeclSAXFunc elementDecl;\n    unparsedEntityDeclSAXFunc unparsedEntityDecl;\n    setDocumentLocatorSAXFunc setDocumentLocator;\n    startDocumentSAXFunc startDocument;\n    endDocumentSAXFunc endDocument;\n    startElementSAXFunc startElement;\n    endElementSAXFunc endElement;\n    referenceSAXFunc reference;\n    charactersSAXFunc characters;\n    ignorableWhitespaceSAXFunc ignorableWhitespace;\n    processingInstructionSAXFunc processingInstruction;\n    commentSAXFunc comment;\n    warningSAXFunc warning;\n    errorSAXFunc error;\n    fatalErrorSAXFunc fatalError; /* unused error() get all the errors */\n    getParameterEntitySAXFunc getParameterEntity;\n    cdataBlockSAXFunc cdataBlock;\n    externalSubsetSAXFunc externalSubset;\n    unsigned int initialized;\n    /* The following fields are extensions available only on version 2 */\n    void *_private;\n    startElementNsSAX2Func startElementNs;\n    endElementNsSAX2Func endElementNs;\n    xmlStructuredErrorFunc serror;\n};\n\n/*\n * SAX Version 1\n */\ntypedef struct _xmlSAXHandlerV1 xmlSAXHandlerV1;\ntypedef xmlSAXHandlerV1 *xmlSAXHandlerV1Ptr;\nstruct _xmlSAXHandlerV1 {\n    internalSubsetSAXFunc internalSubset;\n    isStandaloneSAXFunc isStandalone;\n    hasInternalSubsetSAXFunc hasInternalSubset;\n    hasExternalSubsetSAXFunc hasExternalSubset;\n    resolveEntitySAXFunc resolveEntity;\n    getEntitySAXFunc getEntity;\n    entityDeclSAXFunc entityDecl;\n    notationDeclSAXFunc notationDecl;\n    attributeDeclSAXFunc attributeDecl;\n    elementDeclSAXFunc elementDecl;\n    unparsedEntityDeclSAXFunc unparsedEntityDecl;\n    setDocumentLocatorSAXFunc setDocumentLocator;\n    startDocumentSAXFunc startDocument;\n    endDocumentSAXFunc endDocument;\n    startElementSAXFunc startElement;\n    endElementSAXFunc endElement;\n    referenceSAXFunc reference;\n    charactersSAXFunc characters;\n    ignorableWhitespaceSAXFunc ignorableWhitespace;\n    processingInstructionSAXFunc processingInstruction;\n    commentSAXFunc comment;\n    warningSAXFunc warning;\n    errorSAXFunc error;\n    fatalErrorSAXFunc fatalError; /* unused error() get all the errors */\n    getParameterEntitySAXFunc getParameterEntity;\n    cdataBlockSAXFunc cdataBlock;\n    externalSubsetSAXFunc externalSubset;\n    unsigned int initialized;\n};\n\n\n/**\n * xmlExternalEntityLoader:\n * @URL: The System ID of the resource requested\n * @ID: The Public ID of the resource requested\n * @context: the XML parser context\n *\n * External entity loaders types.\n *\n * Returns the entity input parser.\n */\ntypedef xmlParserInputPtr (*xmlExternalEntityLoader) (const char *URL,\n\t\t\t\t\t const char *ID,\n\t\t\t\t\t xmlParserCtxtPtr context);\n\n#ifdef __cplusplus\n}\n#endif\n\n#include <libxml/encoding.h>\n#include <libxml/xmlIO.h>\n#include <libxml/globals.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/*\n * Init/Cleanup\n */\nXMLPUBFUN void XMLCALL\n\t\txmlInitParser\t\t(void);\nXMLPUBFUN void XMLCALL\n\t\txmlCleanupParser\t(void);\n\n/*\n * Input functions\n */\nXMLPUBFUN int XMLCALL\n\t\txmlParserInputRead\t(xmlParserInputPtr in,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\t\txmlParserInputGrow\t(xmlParserInputPtr in,\n\t\t\t\t\t int len);\n\n/*\n * Basic parsing Interfaces\n */\n#ifdef LIBXML_SAX1_ENABLED\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlParseDoc\t\t(const xmlChar *cur);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlParseFile\t\t(const char *filename);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlParseMemory\t\t(const char *buffer,\n\t\t\t\t\t int size);\n#endif /* LIBXML_SAX1_ENABLED */\nXMLPUBFUN int XMLCALL\n\t\txmlSubstituteEntitiesDefault(int val);\nXMLPUBFUN int XMLCALL\n\t\txmlKeepBlanksDefault\t(int val);\nXMLPUBFUN void XMLCALL\n\t\txmlStopParser\t\t(xmlParserCtxtPtr ctxt);\nXMLPUBFUN int XMLCALL\n\t\txmlPedanticParserDefault(int val);\nXMLPUBFUN int XMLCALL\n\t\txmlLineNumbersDefault\t(int val);\n\n#ifdef LIBXML_SAX1_ENABLED\n/*\n * Recovery mode\n */\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlRecoverDoc\t\t(const xmlChar *cur);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlRecoverMemory\t(const char *buffer,\n\t\t\t\t\t int size);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlRecoverFile\t\t(const char *filename);\n#endif /* LIBXML_SAX1_ENABLED */\n\n/*\n * Less common routines and SAX interfaces\n */\nXMLPUBFUN int XMLCALL\n\t\txmlParseDocument\t(xmlParserCtxtPtr ctxt);\nXMLPUBFUN int XMLCALL\n\t\txmlParseExtParsedEnt\t(xmlParserCtxtPtr ctxt);\n#ifdef LIBXML_SAX1_ENABLED\nXMLPUBFUN int XMLCALL\n\t\txmlSAXUserParseFile\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t void *user_data,\n\t\t\t\t\t const char *filename);\nXMLPUBFUN int XMLCALL\n\t\txmlSAXUserParseMemory\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t void *user_data,\n\t\t\t\t\t const char *buffer,\n\t\t\t\t\t int size);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlSAXParseDoc\t\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t const xmlChar *cur,\n\t\t\t\t\t int recovery);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlSAXParseMemory\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t const char *buffer,\n\t\t\t\t\t int size,\n\t\t\t\t\t int recovery);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlSAXParseMemoryWithData (xmlSAXHandlerPtr sax,\n\t\t\t\t\t const char *buffer,\n\t\t\t\t\t int size,\n\t\t\t\t\t int recovery,\n\t\t\t\t\t void *data);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlSAXParseFile\t\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t const char *filename,\n\t\t\t\t\t int recovery);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlSAXParseFileWithData\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t const char *filename,\n\t\t\t\t\t int recovery,\n\t\t\t\t\t void *data);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlSAXParseEntity\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t const char *filename);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlParseEntity\t\t(const char *filename);\n#endif /* LIBXML_SAX1_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\nXMLPUBFUN xmlDtdPtr XMLCALL\n\t\txmlSAXParseDTD\t\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t const xmlChar *ExternalID,\n\t\t\t\t\t const xmlChar *SystemID);\nXMLPUBFUN xmlDtdPtr XMLCALL\n\t\txmlParseDTD\t\t(const xmlChar *ExternalID,\n\t\t\t\t\t const xmlChar *SystemID);\nXMLPUBFUN xmlDtdPtr XMLCALL\n\t\txmlIOParseDTD\t\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t xmlParserInputBufferPtr input,\n\t\t\t\t\t xmlCharEncoding enc);\n#endif /* LIBXML_VALID_ENABLE */\n#ifdef LIBXML_SAX1_ENABLED\nXMLPUBFUN int XMLCALL\n\t\txmlParseBalancedChunkMemory(xmlDocPtr doc,\n\t\t\t\t\t xmlSAXHandlerPtr sax,\n\t\t\t\t\t void *user_data,\n\t\t\t\t\t int depth,\n\t\t\t\t\t const xmlChar *string,\n\t\t\t\t\t xmlNodePtr *lst);\n#endif /* LIBXML_SAX1_ENABLED */\nXMLPUBFUN xmlParserErrors XMLCALL\n\t\txmlParseInNodeContext\t(xmlNodePtr node,\n\t\t\t\t\t const char *data,\n\t\t\t\t\t int datalen,\n\t\t\t\t\t int options,\n\t\t\t\t\t xmlNodePtr *lst);\n#ifdef LIBXML_SAX1_ENABLED\nXMLPUBFUN int XMLCALL\n\t\txmlParseBalancedChunkMemoryRecover(xmlDocPtr doc,\n                     xmlSAXHandlerPtr sax,\n                     void *user_data,\n                     int depth,\n                     const xmlChar *string,\n                     xmlNodePtr *lst,\n                     int recover);\nXMLPUBFUN int XMLCALL\n\t\txmlParseExternalEntity\t(xmlDocPtr doc,\n\t\t\t\t\t xmlSAXHandlerPtr sax,\n\t\t\t\t\t void *user_data,\n\t\t\t\t\t int depth,\n\t\t\t\t\t const xmlChar *URL,\n\t\t\t\t\t const xmlChar *ID,\n\t\t\t\t\t xmlNodePtr *lst);\n#endif /* LIBXML_SAX1_ENABLED */\nXMLPUBFUN int XMLCALL\n\t\txmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx,\n\t\t\t\t\t const xmlChar *URL,\n\t\t\t\t\t const xmlChar *ID,\n\t\t\t\t\t xmlNodePtr *lst);\n\n/*\n * Parser contexts handling.\n */\nXMLPUBFUN xmlParserCtxtPtr XMLCALL\n\t\txmlNewParserCtxt\t(void);\nXMLPUBFUN int XMLCALL\n\t\txmlInitParserCtxt\t(xmlParserCtxtPtr ctxt);\nXMLPUBFUN void XMLCALL\n\t\txmlClearParserCtxt\t(xmlParserCtxtPtr ctxt);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeParserCtxt\t(xmlParserCtxtPtr ctxt);\n#ifdef LIBXML_SAX1_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlSetupParserForBuffer\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const xmlChar* buffer,\n\t\t\t\t\t const char *filename);\n#endif /* LIBXML_SAX1_ENABLED */\nXMLPUBFUN xmlParserCtxtPtr XMLCALL\n\t\txmlCreateDocParserCtxt\t(const xmlChar *cur);\n\n#ifdef LIBXML_LEGACY_ENABLED\n/*\n * Reading/setting optional parsing features.\n */\nXMLPUBFUN int XMLCALL\n\t\txmlGetFeaturesList\t(int *len,\n\t\t\t\t\t const char **result);\nXMLPUBFUN int XMLCALL\n\t\txmlGetFeature\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t void *result);\nXMLPUBFUN int XMLCALL\n\t\txmlSetFeature\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t void *value);\n#endif /* LIBXML_LEGACY_ENABLED */\n\n#ifdef LIBXML_PUSH_ENABLED\n/*\n * Interfaces for the Push mode.\n */\nXMLPUBFUN xmlParserCtxtPtr XMLCALL\n\t\txmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,\n\t\t\t\t\t void *user_data,\n\t\t\t\t\t const char *chunk,\n\t\t\t\t\t int size,\n\t\t\t\t\t const char *filename);\nXMLPUBFUN int XMLCALL\n\t\txmlParseChunk\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const char *chunk,\n\t\t\t\t\t int size,\n\t\t\t\t\t int terminate);\n#endif /* LIBXML_PUSH_ENABLED */\n\n/*\n * Special I/O mode.\n */\n\nXMLPUBFUN xmlParserCtxtPtr XMLCALL\n\t\txmlCreateIOParserCtxt\t(xmlSAXHandlerPtr sax,\n\t\t\t\t\t void *user_data,\n\t\t\t\t\t xmlInputReadCallback   ioread,\n\t\t\t\t\t xmlInputCloseCallback  ioclose,\n\t\t\t\t\t void *ioctx,\n\t\t\t\t\t xmlCharEncoding enc);\n\nXMLPUBFUN xmlParserInputPtr XMLCALL\n\t\txmlNewIOInputStream\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t xmlParserInputBufferPtr input,\n\t\t\t\t\t xmlCharEncoding enc);\n\n/*\n * Node infos.\n */\nXMLPUBFUN const xmlParserNodeInfo* XMLCALL\n\t\txmlParserFindNodeInfo\t(const xmlParserCtxtPtr ctxt,\n\t\t\t\t         const xmlNodePtr node);\nXMLPUBFUN void XMLCALL\n\t\txmlInitNodeInfoSeq\t(xmlParserNodeInfoSeqPtr seq);\nXMLPUBFUN void XMLCALL\n\t\txmlClearNodeInfoSeq\t(xmlParserNodeInfoSeqPtr seq);\nXMLPUBFUN unsigned long XMLCALL\n\t\txmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq,\n                                         const xmlNodePtr node);\nXMLPUBFUN void XMLCALL\n\t\txmlParserAddNodeInfo\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const xmlParserNodeInfoPtr info);\n\n/*\n * External entities handling actually implemented in xmlIO.\n */\n\nXMLPUBFUN void XMLCALL\n\t\txmlSetExternalEntityLoader(xmlExternalEntityLoader f);\nXMLPUBFUN xmlExternalEntityLoader XMLCALL\n\t\txmlGetExternalEntityLoader(void);\nXMLPUBFUN xmlParserInputPtr XMLCALL\n\t\txmlLoadExternalEntity\t(const char *URL,\n\t\t\t\t\t const char *ID,\n\t\t\t\t\t xmlParserCtxtPtr ctxt);\n\n/*\n * Index lookup, actually implemented in the encoding module\n */\nXMLPUBFUN long XMLCALL\n\t\txmlByteConsumed\t\t(xmlParserCtxtPtr ctxt);\n\n/*\n * New set of simpler/more flexible APIs\n */\n/**\n * xmlParserOption:\n *\n * This is the set of XML parser options that can be passed down\n * to the xmlReadDoc() and similar calls.\n */\ntypedef enum {\n    XML_PARSE_RECOVER\t= 1<<0,\t/* recover on errors */\n    XML_PARSE_NOENT\t= 1<<1,\t/* substitute entities */\n    XML_PARSE_DTDLOAD\t= 1<<2,\t/* load the external subset */\n    XML_PARSE_DTDATTR\t= 1<<3,\t/* default DTD attributes */\n    XML_PARSE_DTDVALID\t= 1<<4,\t/* validate with the DTD */\n    XML_PARSE_NOERROR\t= 1<<5,\t/* suppress error reports */\n    XML_PARSE_NOWARNING\t= 1<<6,\t/* suppress warning reports */\n    XML_PARSE_PEDANTIC\t= 1<<7,\t/* pedantic error reporting */\n    XML_PARSE_NOBLANKS\t= 1<<8,\t/* remove blank nodes */\n    XML_PARSE_SAX1\t= 1<<9,\t/* use the SAX1 interface internally */\n    XML_PARSE_XINCLUDE\t= 1<<10,/* Implement XInclude substitution  */\n    XML_PARSE_NONET\t= 1<<11,/* Forbid network access */\n    XML_PARSE_NODICT\t= 1<<12,/* Do not reuse the context dictionary */\n    XML_PARSE_NSCLEAN\t= 1<<13,/* remove redundant namespaces declarations */\n    XML_PARSE_NOCDATA\t= 1<<14,/* merge CDATA as text nodes */\n    XML_PARSE_NOXINCNODE= 1<<15,/* do not generate XINCLUDE START/END nodes */\n    XML_PARSE_COMPACT   = 1<<16,/* compact small text nodes; no modification of\n                                   the tree allowed afterwards (will possibly\n\t\t\t\t   crash if you try to modify the tree) */\n    XML_PARSE_OLD10\t= 1<<17,/* parse using XML-1.0 before update 5 */\n    XML_PARSE_NOBASEFIX = 1<<18,/* do not fixup XINCLUDE xml:base uris */\n    XML_PARSE_HUGE      = 1<<19,/* relax any hardcoded limit from the parser */\n    XML_PARSE_OLDSAX    = 1<<20,/* parse using SAX2 interface before 2.7.0 */\n    XML_PARSE_IGNORE_ENC= 1<<21,/* ignore internal document encoding hint */\n    XML_PARSE_BIG_LINES = 1<<22 /* Store big lines numbers in text PSVI field */\n} xmlParserOption;\n\nXMLPUBFUN void XMLCALL\n\t\txmlCtxtReset\t\t(xmlParserCtxtPtr ctxt);\nXMLPUBFUN int XMLCALL\n\t\txmlCtxtResetPush\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const char *chunk,\n\t\t\t\t\t int size,\n\t\t\t\t\t const char *filename,\n\t\t\t\t\t const char *encoding);\nXMLPUBFUN int XMLCALL\n\t\txmlCtxtUseOptions\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlReadDoc\t\t(const xmlChar *cur,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlReadFile\t\t(const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlReadMemory\t\t(const char *buffer,\n\t\t\t\t\t int size,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlReadFd\t\t(int fd,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlReadIO\t\t(xmlInputReadCallback ioread,\n\t\t\t\t\t xmlInputCloseCallback ioclose,\n\t\t\t\t\t void *ioctx,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlCtxtReadDoc\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const xmlChar *cur,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlCtxtReadFile\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const char *filename,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlCtxtReadMemory\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t const char *buffer,\n\t\t\t\t\t int size,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlCtxtReadFd\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t int fd,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlCtxtReadIO\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t xmlInputReadCallback ioread,\n\t\t\t\t\t xmlInputCloseCallback ioclose,\n\t\t\t\t\t void *ioctx,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\n\n/*\n * Library wide options\n */\n/**\n * xmlFeature:\n *\n * Used to examine the existence of features that can be enabled\n * or disabled at compile-time.\n * They used to be called XML_FEATURE_xxx but this clashed with Expat\n */\ntypedef enum {\n    XML_WITH_THREAD = 1,\n    XML_WITH_TREE = 2,\n    XML_WITH_OUTPUT = 3,\n    XML_WITH_PUSH = 4,\n    XML_WITH_READER = 5,\n    XML_WITH_PATTERN = 6,\n    XML_WITH_WRITER = 7,\n    XML_WITH_SAX1 = 8,\n    XML_WITH_FTP = 9,\n    XML_WITH_HTTP = 10,\n    XML_WITH_VALID = 11,\n    XML_WITH_HTML = 12,\n    XML_WITH_LEGACY = 13,\n    XML_WITH_C14N = 14,\n    XML_WITH_CATALOG = 15,\n    XML_WITH_XPATH = 16,\n    XML_WITH_XPTR = 17,\n    XML_WITH_XINCLUDE = 18,\n    XML_WITH_ICONV = 19,\n    XML_WITH_ISO8859X = 20,\n    XML_WITH_UNICODE = 21,\n    XML_WITH_REGEXP = 22,\n    XML_WITH_AUTOMATA = 23,\n    XML_WITH_EXPR = 24,\n    XML_WITH_SCHEMAS = 25,\n    XML_WITH_SCHEMATRON = 26,\n    XML_WITH_MODULES = 27,\n    XML_WITH_DEBUG = 28,\n    XML_WITH_DEBUG_MEM = 29,\n    XML_WITH_DEBUG_RUN = 30,\n    XML_WITH_ZLIB = 31,\n    XML_WITH_ICU = 32,\n    XML_WITH_LZMA = 33,\n    XML_WITH_NONE = 99999 /* just to be sure of allocation size */\n} xmlFeature;\n\nXMLPUBFUN int XMLCALL\n\t\txmlHasFeature\t\t(xmlFeature feature);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* __XML_PARSER_H__ */\n"}, "35": {"id": 35, "path": "/usr/include/libxml2/libxml/relaxng.h", "content": "/*\n * Summary: implementation of the Relax-NG validation\n * Description: implementation of the Relax-NG validation\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_RELAX_NG__\n#define __XML_RELAX_NG__\n\n#include <libxml/xmlversion.h>\n#include <libxml/hash.h>\n#include <libxml/xmlstring.h>\n\n#ifdef LIBXML_SCHEMAS_ENABLED\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct _xmlRelaxNG xmlRelaxNG;\ntypedef xmlRelaxNG *xmlRelaxNGPtr;\n\n\n/**\n * xmlRelaxNGValidityErrorFunc:\n * @ctx: the validation context\n * @msg: the message\n * @...: extra arguments\n *\n * Signature of an error callback from a Relax-NG validation\n */\ntypedef void (XMLCDECL *xmlRelaxNGValidityErrorFunc) (void *ctx,\n\t\t\t\t\t\t      const char *msg,\n\t\t\t\t\t\t      ...) LIBXML_ATTR_FORMAT(2,3);\n\n/**\n * xmlRelaxNGValidityWarningFunc:\n * @ctx: the validation context\n * @msg: the message\n * @...: extra arguments\n *\n * Signature of a warning callback from a Relax-NG validation\n */\ntypedef void (XMLCDECL *xmlRelaxNGValidityWarningFunc) (void *ctx,\n\t\t\t\t\t\t\tconst char *msg,\n\t\t\t\t\t\t\t...) LIBXML_ATTR_FORMAT(2,3);\n\n/**\n * A schemas validation context\n */\ntypedef struct _xmlRelaxNGParserCtxt xmlRelaxNGParserCtxt;\ntypedef xmlRelaxNGParserCtxt *xmlRelaxNGParserCtxtPtr;\n\ntypedef struct _xmlRelaxNGValidCtxt xmlRelaxNGValidCtxt;\ntypedef xmlRelaxNGValidCtxt *xmlRelaxNGValidCtxtPtr;\n\n/*\n * xmlRelaxNGValidErr:\n *\n * List of possible Relax NG validation errors\n */\ntypedef enum {\n    XML_RELAXNG_OK = 0,\n    XML_RELAXNG_ERR_MEMORY,\n    XML_RELAXNG_ERR_TYPE,\n    XML_RELAXNG_ERR_TYPEVAL,\n    XML_RELAXNG_ERR_DUPID,\n    XML_RELAXNG_ERR_TYPECMP,\n    XML_RELAXNG_ERR_NOSTATE,\n    XML_RELAXNG_ERR_NODEFINE,\n    XML_RELAXNG_ERR_LISTEXTRA,\n    XML_RELAXNG_ERR_LISTEMPTY,\n    XML_RELAXNG_ERR_INTERNODATA,\n    XML_RELAXNG_ERR_INTERSEQ,\n    XML_RELAXNG_ERR_INTEREXTRA,\n    XML_RELAXNG_ERR_ELEMNAME,\n    XML_RELAXNG_ERR_ATTRNAME,\n    XML_RELAXNG_ERR_ELEMNONS,\n    XML_RELAXNG_ERR_ATTRNONS,\n    XML_RELAXNG_ERR_ELEMWRONGNS,\n    XML_RELAXNG_ERR_ATTRWRONGNS,\n    XML_RELAXNG_ERR_ELEMEXTRANS,\n    XML_RELAXNG_ERR_ATTREXTRANS,\n    XML_RELAXNG_ERR_ELEMNOTEMPTY,\n    XML_RELAXNG_ERR_NOELEM,\n    XML_RELAXNG_ERR_NOTELEM,\n    XML_RELAXNG_ERR_ATTRVALID,\n    XML_RELAXNG_ERR_CONTENTVALID,\n    XML_RELAXNG_ERR_EXTRACONTENT,\n    XML_RELAXNG_ERR_INVALIDATTR,\n    XML_RELAXNG_ERR_DATAELEM,\n    XML_RELAXNG_ERR_VALELEM,\n    XML_RELAXNG_ERR_LISTELEM,\n    XML_RELAXNG_ERR_DATATYPE,\n    XML_RELAXNG_ERR_VALUE,\n    XML_RELAXNG_ERR_LIST,\n    XML_RELAXNG_ERR_NOGRAMMAR,\n    XML_RELAXNG_ERR_EXTRADATA,\n    XML_RELAXNG_ERR_LACKDATA,\n    XML_RELAXNG_ERR_INTERNAL,\n    XML_RELAXNG_ERR_ELEMWRONG,\n    XML_RELAXNG_ERR_TEXTWRONG\n} xmlRelaxNGValidErr;\n\n/*\n * xmlRelaxNGParserFlags:\n *\n * List of possible Relax NG Parser flags\n */\ntypedef enum {\n    XML_RELAXNGP_NONE = 0,\n    XML_RELAXNGP_FREE_DOC = 1,\n    XML_RELAXNGP_CRNG = 2\n} xmlRelaxNGParserFlag;\n\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxNGInitTypes\t\t(void);\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGCleanupTypes\t(void);\n\n/*\n * Interfaces for parsing.\n */\nXMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL\n\t\t    xmlRelaxNGNewParserCtxt\t(const char *URL);\nXMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL\n\t\t    xmlRelaxNGNewMemParserCtxt\t(const char *buffer,\n\t\t\t\t\t\t int size);\nXMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL\n\t\t    xmlRelaxNGNewDocParserCtxt\t(xmlDocPtr doc);\n\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxParserSetFlag\t(xmlRelaxNGParserCtxtPtr ctxt,\n\t\t\t\t\t\t int flag);\n\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGFreeParserCtxt\t(xmlRelaxNGParserCtxtPtr ctxt);\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n\t\t\t\t\t xmlRelaxNGValidityErrorFunc err,\n\t\t\t\t\t xmlRelaxNGValidityWarningFunc warn,\n\t\t\t\t\t void *ctx);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n\t\t\t\t\t xmlRelaxNGValidityErrorFunc *err,\n\t\t\t\t\t xmlRelaxNGValidityWarningFunc *warn,\n\t\t\t\t\t void **ctx);\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGSetParserStructuredErrors(\n\t\t\t\t\t xmlRelaxNGParserCtxtPtr ctxt,\n\t\t\t\t\t xmlStructuredErrorFunc serror,\n\t\t\t\t\t void *ctx);\nXMLPUBFUN xmlRelaxNGPtr XMLCALL\n\t\t    xmlRelaxNGParse\t\t(xmlRelaxNGParserCtxtPtr ctxt);\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGFree\t\t(xmlRelaxNGPtr schema);\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGDump\t\t(FILE *output,\n\t\t\t\t\t xmlRelaxNGPtr schema);\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGDumpTree\t(FILE * output,\n\t\t\t\t\t xmlRelaxNGPtr schema);\n#endif /* LIBXML_OUTPUT_ENABLED */\n/*\n * Interfaces for validating\n */\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t xmlRelaxNGValidityErrorFunc err,\n\t\t\t\t\t xmlRelaxNGValidityWarningFunc warn,\n\t\t\t\t\t void *ctx);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t xmlRelaxNGValidityErrorFunc *err,\n\t\t\t\t\t xmlRelaxNGValidityWarningFunc *warn,\n\t\t\t\t\t void **ctx);\nXMLPUBFUN void XMLCALL\n\t\t\txmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t  xmlStructuredErrorFunc serror, void *ctx);\nXMLPUBFUN xmlRelaxNGValidCtxtPtr XMLCALL\n\t\t    xmlRelaxNGNewValidCtxt\t(xmlRelaxNGPtr schema);\nXMLPUBFUN void XMLCALL\n\t\t    xmlRelaxNGFreeValidCtxt\t(xmlRelaxNGValidCtxtPtr ctxt);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxNGValidateDoc\t(xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t\t xmlDocPtr doc);\n/*\n * Interfaces for progressive validation when possible\n */\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxNGValidatePushElement\t(xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxNGValidatePushCData\t(xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t const xmlChar *data,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxNGValidatePopElement\t(xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRelaxNGValidateFullElement\t(xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* LIBXML_SCHEMAS_ENABLED */\n\n#endif /* __XML_RELAX_NG__ */\n"}, "36": {"id": 36, "path": "/usr/include/libxml2/libxml/threads.h", "content": "/**\n * Summary: interfaces for thread handling\n * Description: set of generic threading related routines\n *              should work with pthreads, Windows native or TLS threads\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_THREADS_H__\n#define __XML_THREADS_H__\n\n#include <libxml/xmlversion.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * xmlMutex are a simple mutual exception locks.\n */\ntypedef struct _xmlMutex xmlMutex;\ntypedef xmlMutex *xmlMutexPtr;\n\n/*\n * xmlRMutex are reentrant mutual exception locks.\n */\ntypedef struct _xmlRMutex xmlRMutex;\ntypedef xmlRMutex *xmlRMutexPtr;\n\n#ifdef __cplusplus\n}\n#endif\n#include <libxml/globals.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nXMLPUBFUN xmlMutexPtr XMLCALL\n\t\t\txmlNewMutex\t(void);\nXMLPUBFUN void XMLCALL\n\t\t\txmlMutexLock\t(xmlMutexPtr tok);\nXMLPUBFUN void XMLCALL\n\t\t\txmlMutexUnlock\t(xmlMutexPtr tok);\nXMLPUBFUN void XMLCALL\n\t\t\txmlFreeMutex\t(xmlMutexPtr tok);\n\nXMLPUBFUN xmlRMutexPtr XMLCALL\n\t\t\txmlNewRMutex\t(void);\nXMLPUBFUN void XMLCALL\n\t\t\txmlRMutexLock\t(xmlRMutexPtr tok);\nXMLPUBFUN void XMLCALL\n\t\t\txmlRMutexUnlock\t(xmlRMutexPtr tok);\nXMLPUBFUN void XMLCALL\n\t\t\txmlFreeRMutex\t(xmlRMutexPtr tok);\n\n/*\n * Library wide APIs.\n */\nXMLPUBFUN void XMLCALL\n\t\t\txmlInitThreads\t(void);\nXMLPUBFUN void XMLCALL\n\t\t\txmlLockLibrary\t(void);\nXMLPUBFUN void XMLCALL\n\t\t\txmlUnlockLibrary(void);\nXMLPUBFUN int XMLCALL\n\t\t\txmlGetThreadId\t(void);\nXMLPUBFUN int XMLCALL\n\t\t\txmlIsMainThread\t(void);\nXMLPUBFUN void XMLCALL\n\t\t\txmlCleanupThreads(void);\nXMLPUBFUN xmlGlobalStatePtr XMLCALL\n\t\t\txmlGetGlobalState(void);\n\n#ifdef HAVE_PTHREAD_H\n#elif defined(HAVE_WIN32_THREADS) && !defined(HAVE_COMPILER_TLS) && (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n#if defined(LIBXML_STATIC_FOR_DLL)\nint XMLCALL\nxmlDllMain(void *hinstDLL, unsigned long fdwReason,\n           void *lpvReserved);\n#endif\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif /* __XML_THREADS_H__ */\n"}, "37": {"id": 37, "path": "/usr/include/libxml2/libxml/tree.h", "content": "/*\n * Summary: interfaces for tree manipulation\n * Description: this module describes the structures found in an tree resulting\n *              from an XML or HTML parsing, as well as the API provided for\n *              various processing on that tree\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_TREE_H__\n#define __XML_TREE_H__\n\n#include <stdio.h>\n#include <limits.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlstring.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Some of the basic types pointer to structures:\n */\n/* xmlIO.h */\ntypedef struct _xmlParserInputBuffer xmlParserInputBuffer;\ntypedef xmlParserInputBuffer *xmlParserInputBufferPtr;\n\ntypedef struct _xmlOutputBuffer xmlOutputBuffer;\ntypedef xmlOutputBuffer *xmlOutputBufferPtr;\n\n/* parser.h */\ntypedef struct _xmlParserInput xmlParserInput;\ntypedef xmlParserInput *xmlParserInputPtr;\n\ntypedef struct _xmlParserCtxt xmlParserCtxt;\ntypedef xmlParserCtxt *xmlParserCtxtPtr;\n\ntypedef struct _xmlSAXLocator xmlSAXLocator;\ntypedef xmlSAXLocator *xmlSAXLocatorPtr;\n\ntypedef struct _xmlSAXHandler xmlSAXHandler;\ntypedef xmlSAXHandler *xmlSAXHandlerPtr;\n\n/* entities.h */\ntypedef struct _xmlEntity xmlEntity;\ntypedef xmlEntity *xmlEntityPtr;\n\n/**\n * BASE_BUFFER_SIZE:\n *\n * default buffer size 4000.\n */\n#define BASE_BUFFER_SIZE 4096\n\n/**\n * LIBXML_NAMESPACE_DICT:\n *\n * Defines experimental behaviour:\n * 1) xmlNs gets an additional field @context (a xmlDoc)\n * 2) when creating a tree, xmlNs->href is stored in the dict of xmlDoc.\n */\n/* #define LIBXML_NAMESPACE_DICT */\n\n/**\n * xmlBufferAllocationScheme:\n *\n * A buffer allocation scheme can be defined to either match exactly the\n * need or double it's allocated size each time it is found too small.\n */\n\ntypedef enum {\n    XML_BUFFER_ALLOC_DOUBLEIT,\t/* double each time one need to grow */\n    XML_BUFFER_ALLOC_EXACT,\t/* grow only to the minimal size */\n    XML_BUFFER_ALLOC_IMMUTABLE, /* immutable buffer */\n    XML_BUFFER_ALLOC_IO,\t/* special allocation scheme used for I/O */\n    XML_BUFFER_ALLOC_HYBRID,\t/* exact up to a threshold, and doubleit thereafter */\n    XML_BUFFER_ALLOC_BOUNDED\t/* limit the upper size of the buffer */\n} xmlBufferAllocationScheme;\n\n/**\n * xmlBuffer:\n *\n * A buffer structure, this old construct is limited to 2GB and\n * is being deprecated, use API with xmlBuf instead\n */\ntypedef struct _xmlBuffer xmlBuffer;\ntypedef xmlBuffer *xmlBufferPtr;\nstruct _xmlBuffer {\n    xmlChar *content;\t\t/* The buffer content UTF8 */\n    unsigned int use;\t\t/* The buffer size used */\n    unsigned int size;\t\t/* The buffer size */\n    xmlBufferAllocationScheme alloc; /* The realloc method */\n    xmlChar *contentIO;\t\t/* in IO mode we may have a different base */\n};\n\n/**\n * xmlBuf:\n *\n * A buffer structure, new one, the actual structure internals are not public\n */\n\ntypedef struct _xmlBuf xmlBuf;\n\n/**\n * xmlBufPtr:\n *\n * A pointer to a buffer structure, the actual structure internals are not\n * public\n */\n\ntypedef xmlBuf *xmlBufPtr;\n\n/*\n * A few public routines for xmlBuf. As those are expected to be used\n * mostly internally the bulk of the routines are internal in buf.h\n */\nXMLPUBFUN xmlChar* XMLCALL       xmlBufContent\t(const xmlBuf* buf);\nXMLPUBFUN xmlChar* XMLCALL       xmlBufEnd      (xmlBufPtr buf);\nXMLPUBFUN size_t XMLCALL         xmlBufUse      (const xmlBufPtr buf);\nXMLPUBFUN size_t XMLCALL         xmlBufShrink\t(xmlBufPtr buf, size_t len);\n\n/*\n * LIBXML2_NEW_BUFFER:\n *\n * Macro used to express that the API use the new buffers for\n * xmlParserInputBuffer and xmlOutputBuffer. The change was\n * introduced in 2.9.0.\n */\n#define LIBXML2_NEW_BUFFER\n\n/**\n * XML_XML_NAMESPACE:\n *\n * This is the namespace for the special xml: prefix predefined in the\n * XML Namespace specification.\n */\n#define XML_XML_NAMESPACE \\\n    (const xmlChar *) \"http://www.w3.org/XML/1998/namespace\"\n\n/**\n * XML_XML_ID:\n *\n * This is the name for the special xml:id attribute\n */\n#define XML_XML_ID (const xmlChar *) \"xml:id\"\n\n/*\n * The different element types carried by an XML tree.\n *\n * NOTE: This is synchronized with DOM Level1 values\n *       See http://www.w3.org/TR/REC-DOM-Level-1/\n *\n * Actually this had diverged a bit, and now XML_DOCUMENT_TYPE_NODE should\n * be deprecated to use an XML_DTD_NODE.\n */\ntypedef enum {\n    XML_ELEMENT_NODE=\t\t1,\n    XML_ATTRIBUTE_NODE=\t\t2,\n    XML_TEXT_NODE=\t\t3,\n    XML_CDATA_SECTION_NODE=\t4,\n    XML_ENTITY_REF_NODE=\t5,\n    XML_ENTITY_NODE=\t\t6,\n    XML_PI_NODE=\t\t7,\n    XML_COMMENT_NODE=\t\t8,\n    XML_DOCUMENT_NODE=\t\t9,\n    XML_DOCUMENT_TYPE_NODE=\t10,\n    XML_DOCUMENT_FRAG_NODE=\t11,\n    XML_NOTATION_NODE=\t\t12,\n    XML_HTML_DOCUMENT_NODE=\t13,\n    XML_DTD_NODE=\t\t14,\n    XML_ELEMENT_DECL=\t\t15,\n    XML_ATTRIBUTE_DECL=\t\t16,\n    XML_ENTITY_DECL=\t\t17,\n    XML_NAMESPACE_DECL=\t\t18,\n    XML_XINCLUDE_START=\t\t19,\n    XML_XINCLUDE_END=\t\t20\n#ifdef LIBXML_DOCB_ENABLED\n   ,XML_DOCB_DOCUMENT_NODE=\t21\n#endif\n} xmlElementType;\n\n\n/**\n * xmlNotation:\n *\n * A DTD Notation definition.\n */\n\ntypedef struct _xmlNotation xmlNotation;\ntypedef xmlNotation *xmlNotationPtr;\nstruct _xmlNotation {\n    const xmlChar               *name;\t        /* Notation name */\n    const xmlChar               *PublicID;\t/* Public identifier, if any */\n    const xmlChar               *SystemID;\t/* System identifier, if any */\n};\n\n/**\n * xmlAttributeType:\n *\n * A DTD Attribute type definition.\n */\n\ntypedef enum {\n    XML_ATTRIBUTE_CDATA = 1,\n    XML_ATTRIBUTE_ID,\n    XML_ATTRIBUTE_IDREF\t,\n    XML_ATTRIBUTE_IDREFS,\n    XML_ATTRIBUTE_ENTITY,\n    XML_ATTRIBUTE_ENTITIES,\n    XML_ATTRIBUTE_NMTOKEN,\n    XML_ATTRIBUTE_NMTOKENS,\n    XML_ATTRIBUTE_ENUMERATION,\n    XML_ATTRIBUTE_NOTATION\n} xmlAttributeType;\n\n/**\n * xmlAttributeDefault:\n *\n * A DTD Attribute default definition.\n */\n\ntypedef enum {\n    XML_ATTRIBUTE_NONE = 1,\n    XML_ATTRIBUTE_REQUIRED,\n    XML_ATTRIBUTE_IMPLIED,\n    XML_ATTRIBUTE_FIXED\n} xmlAttributeDefault;\n\n/**\n * xmlEnumeration:\n *\n * List structure used when there is an enumeration in DTDs.\n */\n\ntypedef struct _xmlEnumeration xmlEnumeration;\ntypedef xmlEnumeration *xmlEnumerationPtr;\nstruct _xmlEnumeration {\n    struct _xmlEnumeration    *next;\t/* next one */\n    const xmlChar            *name;\t/* Enumeration name */\n};\n\n/**\n * xmlAttribute:\n *\n * An Attribute declaration in a DTD.\n */\n\ntypedef struct _xmlAttribute xmlAttribute;\ntypedef xmlAttribute *xmlAttributePtr;\nstruct _xmlAttribute {\n    void           *_private;\t        /* application data */\n    xmlElementType          type;       /* XML_ATTRIBUTE_DECL, must be second ! */\n    const xmlChar          *name;\t/* Attribute name */\n    struct _xmlNode    *children;\t/* NULL */\n    struct _xmlNode        *last;\t/* NULL */\n    struct _xmlDtd       *parent;\t/* -> DTD */\n    struct _xmlNode        *next;\t/* next sibling link  */\n    struct _xmlNode        *prev;\t/* previous sibling link  */\n    struct _xmlDoc          *doc;       /* the containing document */\n\n    struct _xmlAttribute  *nexth;\t/* next in hash table */\n    xmlAttributeType       atype;\t/* The attribute type */\n    xmlAttributeDefault      def;\t/* the default */\n    const xmlChar  *defaultValue;\t/* or the default value */\n    xmlEnumerationPtr       tree;       /* or the enumeration tree if any */\n    const xmlChar        *prefix;\t/* the namespace prefix if any */\n    const xmlChar          *elem;\t/* Element holding the attribute */\n};\n\n/**\n * xmlElementContentType:\n *\n * Possible definitions of element content types.\n */\ntypedef enum {\n    XML_ELEMENT_CONTENT_PCDATA = 1,\n    XML_ELEMENT_CONTENT_ELEMENT,\n    XML_ELEMENT_CONTENT_SEQ,\n    XML_ELEMENT_CONTENT_OR\n} xmlElementContentType;\n\n/**\n * xmlElementContentOccur:\n *\n * Possible definitions of element content occurrences.\n */\ntypedef enum {\n    XML_ELEMENT_CONTENT_ONCE = 1,\n    XML_ELEMENT_CONTENT_OPT,\n    XML_ELEMENT_CONTENT_MULT,\n    XML_ELEMENT_CONTENT_PLUS\n} xmlElementContentOccur;\n\n/**\n * xmlElementContent:\n *\n * An XML Element content as stored after parsing an element definition\n * in a DTD.\n */\n\ntypedef struct _xmlElementContent xmlElementContent;\ntypedef xmlElementContent *xmlElementContentPtr;\nstruct _xmlElementContent {\n    xmlElementContentType     type;\t/* PCDATA, ELEMENT, SEQ or OR */\n    xmlElementContentOccur    ocur;\t/* ONCE, OPT, MULT or PLUS */\n    const xmlChar             *name;\t/* Element name */\n    struct _xmlElementContent *c1;\t/* first child */\n    struct _xmlElementContent *c2;\t/* second child */\n    struct _xmlElementContent *parent;\t/* parent */\n    const xmlChar             *prefix;\t/* Namespace prefix */\n};\n\n/**\n * xmlElementTypeVal:\n *\n * The different possibilities for an element content type.\n */\n\ntypedef enum {\n    XML_ELEMENT_TYPE_UNDEFINED = 0,\n    XML_ELEMENT_TYPE_EMPTY = 1,\n    XML_ELEMENT_TYPE_ANY,\n    XML_ELEMENT_TYPE_MIXED,\n    XML_ELEMENT_TYPE_ELEMENT\n} xmlElementTypeVal;\n\n#ifdef __cplusplus\n}\n#endif\n#include <libxml/xmlregexp.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * xmlElement:\n *\n * An XML Element declaration from a DTD.\n */\n\ntypedef struct _xmlElement xmlElement;\ntypedef xmlElement *xmlElementPtr;\nstruct _xmlElement {\n    void           *_private;\t        /* application data */\n    xmlElementType          type;       /* XML_ELEMENT_DECL, must be second ! */\n    const xmlChar          *name;\t/* Element name */\n    struct _xmlNode    *children;\t/* NULL */\n    struct _xmlNode        *last;\t/* NULL */\n    struct _xmlDtd       *parent;\t/* -> DTD */\n    struct _xmlNode        *next;\t/* next sibling link  */\n    struct _xmlNode        *prev;\t/* previous sibling link  */\n    struct _xmlDoc          *doc;       /* the containing document */\n\n    xmlElementTypeVal      etype;\t/* The type */\n    xmlElementContentPtr content;\t/* the allowed element content */\n    xmlAttributePtr   attributes;\t/* List of the declared attributes */\n    const xmlChar        *prefix;\t/* the namespace prefix if any */\n#ifdef LIBXML_REGEXP_ENABLED\n    xmlRegexpPtr       contModel;\t/* the validating regexp */\n#else\n    void\t      *contModel;\n#endif\n};\n\n\n/**\n * XML_LOCAL_NAMESPACE:\n *\n * A namespace declaration node.\n */\n#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL\ntypedef xmlElementType xmlNsType;\n\n/**\n * xmlNs:\n *\n * An XML namespace.\n * Note that prefix == NULL is valid, it defines the default namespace\n * within the subtree (until overridden).\n *\n * xmlNsType is unified with xmlElementType.\n */\n\ntypedef struct _xmlNs xmlNs;\ntypedef xmlNs *xmlNsPtr;\nstruct _xmlNs {\n    struct _xmlNs  *next;\t/* next Ns link for this node  */\n    xmlNsType      type;\t/* global or local */\n    const xmlChar *href;\t/* URL for the namespace */\n    const xmlChar *prefix;\t/* prefix for the namespace */\n    void           *_private;   /* application data */\n    struct _xmlDoc *context;\t\t/* normally an xmlDoc */\n};\n\n/**\n * xmlDtd:\n *\n * An XML DTD, as defined by <!DOCTYPE ... There is actually one for\n * the internal subset and for the external subset.\n */\ntypedef struct _xmlDtd xmlDtd;\ntypedef xmlDtd *xmlDtdPtr;\nstruct _xmlDtd {\n    void           *_private;\t/* application data */\n    xmlElementType  type;       /* XML_DTD_NODE, must be second ! */\n    const xmlChar *name;\t/* Name of the DTD */\n    struct _xmlNode *children;\t/* the value of the property link */\n    struct _xmlNode *last;\t/* last child link */\n    struct _xmlDoc  *parent;\t/* child->parent link */\n    struct _xmlNode *next;\t/* next sibling link  */\n    struct _xmlNode *prev;\t/* previous sibling link  */\n    struct _xmlDoc  *doc;\t/* the containing document */\n\n    /* End of common part */\n    void          *notations;   /* Hash table for notations if any */\n    void          *elements;    /* Hash table for elements if any */\n    void          *attributes;  /* Hash table for attributes if any */\n    void          *entities;    /* Hash table for entities if any */\n    const xmlChar *ExternalID;\t/* External identifier for PUBLIC DTD */\n    const xmlChar *SystemID;\t/* URI for a SYSTEM or PUBLIC DTD */\n    void          *pentities;   /* Hash table for param entities if any */\n};\n\n/**\n * xmlAttr:\n *\n * An attribute on an XML node.\n */\ntypedef struct _xmlAttr xmlAttr;\ntypedef xmlAttr *xmlAttrPtr;\nstruct _xmlAttr {\n    void           *_private;\t/* application data */\n    xmlElementType   type;      /* XML_ATTRIBUTE_NODE, must be second ! */\n    const xmlChar   *name;      /* the name of the property */\n    struct _xmlNode *children;\t/* the value of the property */\n    struct _xmlNode *last;\t/* NULL */\n    struct _xmlNode *parent;\t/* child->parent link */\n    struct _xmlAttr *next;\t/* next sibling link  */\n    struct _xmlAttr *prev;\t/* previous sibling link  */\n    struct _xmlDoc  *doc;\t/* the containing document */\n    xmlNs           *ns;        /* pointer to the associated namespace */\n    xmlAttributeType atype;     /* the attribute type if validating */\n    void            *psvi;\t/* for type/PSVI informations */\n};\n\n/**\n * xmlID:\n *\n * An XML ID instance.\n */\n\ntypedef struct _xmlID xmlID;\ntypedef xmlID *xmlIDPtr;\nstruct _xmlID {\n    struct _xmlID    *next;\t/* next ID */\n    const xmlChar    *value;\t/* The ID name */\n    xmlAttrPtr        attr;\t/* The attribute holding it */\n    const xmlChar    *name;\t/* The attribute if attr is not available */\n    int               lineno;\t/* The line number if attr is not available */\n    struct _xmlDoc   *doc;\t/* The document holding the ID */\n};\n\n/**\n * xmlRef:\n *\n * An XML IDREF instance.\n */\n\ntypedef struct _xmlRef xmlRef;\ntypedef xmlRef *xmlRefPtr;\nstruct _xmlRef {\n    struct _xmlRef    *next;\t/* next Ref */\n    const xmlChar     *value;\t/* The Ref name */\n    xmlAttrPtr        attr;\t/* The attribute holding it */\n    const xmlChar    *name;\t/* The attribute if attr is not available */\n    int               lineno;\t/* The line number if attr is not available */\n};\n\n/**\n * xmlNode:\n *\n * A node in an XML tree.\n */\ntypedef struct _xmlNode xmlNode;\ntypedef xmlNode *xmlNodePtr;\nstruct _xmlNode {\n    void           *_private;\t/* application data */\n    xmlElementType   type;\t/* type number, must be second ! */\n    const xmlChar   *name;      /* the name of the node, or the entity */\n    struct _xmlNode *children;\t/* parent->childs link */\n    struct _xmlNode *last;\t/* last child link */\n    struct _xmlNode *parent;\t/* child->parent link */\n    struct _xmlNode *next;\t/* next sibling link  */\n    struct _xmlNode *prev;\t/* previous sibling link  */\n    struct _xmlDoc  *doc;\t/* the containing document */\n\n    /* End of common part */\n    xmlNs           *ns;        /* pointer to the associated namespace */\n    xmlChar         *content;   /* the content */\n    struct _xmlAttr *properties;/* properties list */\n    xmlNs           *nsDef;     /* namespace definitions on this node */\n    void            *psvi;\t/* for type/PSVI informations */\n    unsigned short   line;\t/* line number */\n    unsigned short   extra;\t/* extra data for XPath/XSLT */\n};\n\n/**\n * XML_GET_CONTENT:\n *\n * Macro to extract the content pointer of a node.\n */\n#define XML_GET_CONTENT(n)\t\t\t\t\t\\\n    ((n)->type == XML_ELEMENT_NODE ? NULL : (n)->content)\n\n/**\n * XML_GET_LINE:\n *\n * Macro to extract the line number of an element node.\n */\n#define XML_GET_LINE(n)\t\t\t\t\t\t\\\n    (xmlGetLineNo(n))\n\n/**\n * xmlDocProperty\n *\n * Set of properties of the document as found by the parser\n * Some of them are linked to similarly named xmlParserOption\n */\ntypedef enum {\n    XML_DOC_WELLFORMED\t\t= 1<<0, /* document is XML well formed */\n    XML_DOC_NSVALID\t\t= 1<<1, /* document is Namespace valid */\n    XML_DOC_OLD10\t\t= 1<<2, /* parsed with old XML-1.0 parser */\n    XML_DOC_DTDVALID\t\t= 1<<3, /* DTD validation was successful */\n    XML_DOC_XINCLUDE\t\t= 1<<4, /* XInclude substitution was done */\n    XML_DOC_USERBUILT\t\t= 1<<5, /* Document was built using the API\n                                           and not by parsing an instance */\n    XML_DOC_INTERNAL\t\t= 1<<6, /* built for internal processing */\n    XML_DOC_HTML\t\t= 1<<7  /* parsed or built HTML document */\n} xmlDocProperties;\n\n/**\n * xmlDoc:\n *\n * An XML document.\n */\ntypedef struct _xmlDoc xmlDoc;\ntypedef xmlDoc *xmlDocPtr;\nstruct _xmlDoc {\n    void           *_private;\t/* application data */\n    xmlElementType  type;       /* XML_DOCUMENT_NODE, must be second ! */\n    char           *name;\t/* name/filename/URI of the document */\n    struct _xmlNode *children;\t/* the document tree */\n    struct _xmlNode *last;\t/* last child link */\n    struct _xmlNode *parent;\t/* child->parent link */\n    struct _xmlNode *next;\t/* next sibling link  */\n    struct _xmlNode *prev;\t/* previous sibling link  */\n    struct _xmlDoc  *doc;\t/* autoreference to itself */\n\n    /* End of common part */\n    int             compression;/* level of zlib compression */\n    int             standalone; /* standalone document (no external refs)\n\t\t\t\t     1 if standalone=\"yes\"\n\t\t\t\t     0 if standalone=\"no\"\n\t\t\t\t    -1 if there is no XML declaration\n\t\t\t\t    -2 if there is an XML declaration, but no\n\t\t\t\t\tstandalone attribute was specified */\n    struct _xmlDtd  *intSubset;\t/* the document internal subset */\n    struct _xmlDtd  *extSubset;\t/* the document external subset */\n    struct _xmlNs   *oldNs;\t/* Global namespace, the old way */\n    const xmlChar  *version;\t/* the XML version string */\n    const xmlChar  *encoding;   /* external initial encoding, if any */\n    void           *ids;        /* Hash table for ID attributes if any */\n    void           *refs;       /* Hash table for IDREFs attributes if any */\n    const xmlChar  *URL;\t/* The URI for that document */\n    int             charset;    /* Internal flag for charset handling,\n\t\t\t\t   actually an xmlCharEncoding */\n    struct _xmlDict *dict;      /* dict used to allocate names or NULL */\n    void           *psvi;\t/* for type/PSVI informations */\n    int             parseFlags;\t/* set of xmlParserOption used to parse the\n\t\t\t\t   document */\n    int             properties;\t/* set of xmlDocProperties for this document\n\t\t\t\t   set at the end of parsing */\n};\n\n\ntypedef struct _xmlDOMWrapCtxt xmlDOMWrapCtxt;\ntypedef xmlDOMWrapCtxt *xmlDOMWrapCtxtPtr;\n\n/**\n * xmlDOMWrapAcquireNsFunction:\n * @ctxt:  a DOM wrapper context\n * @node:  the context node (element or attribute)\n * @nsName:  the requested namespace name\n * @nsPrefix:  the requested namespace prefix\n *\n * A function called to acquire namespaces (xmlNs) from the wrapper.\n *\n * Returns an xmlNsPtr or NULL in case of an error.\n */\ntypedef xmlNsPtr (*xmlDOMWrapAcquireNsFunction) (xmlDOMWrapCtxtPtr ctxt,\n\t\t\t\t\t\t xmlNodePtr node,\n\t\t\t\t\t\t const xmlChar *nsName,\n\t\t\t\t\t\t const xmlChar *nsPrefix);\n\n/**\n * xmlDOMWrapCtxt:\n *\n * Context for DOM wrapper-operations.\n */\nstruct _xmlDOMWrapCtxt {\n    void * _private;\n    /*\n    * The type of this context, just in case we need specialized\n    * contexts in the future.\n    */\n    int type;\n    /*\n    * Internal namespace map used for various operations.\n    */\n    void * namespaceMap;\n    /*\n    * Use this one to acquire an xmlNsPtr intended for node->ns.\n    * (Note that this is not intended for elem->nsDef).\n    */\n    xmlDOMWrapAcquireNsFunction getNsForNodeFunc;\n};\n\n/**\n * xmlChildrenNode:\n *\n * Macro for compatibility naming layer with libxml1. Maps\n * to \"children.\"\n */\n#ifndef xmlChildrenNode\n#define xmlChildrenNode children\n#endif\n\n/**\n * xmlRootNode:\n *\n * Macro for compatibility naming layer with libxml1. Maps\n * to \"children\".\n */\n#ifndef xmlRootNode\n#define xmlRootNode children\n#endif\n\n/*\n * Variables.\n */\n\n/*\n * Some helper functions\n */\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || \\\n    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || \\\n    defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || \\\n    defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || \\\n    defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)\nXMLPUBFUN int XMLCALL\n\t\txmlValidateNCName\t(const xmlChar *value,\n\t\t\t\t\t int space);\n#endif\n\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\nXMLPUBFUN int XMLCALL\n\t\txmlValidateQName\t(const xmlChar *value,\n\t\t\t\t\t int space);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateName\t\t(const xmlChar *value,\n\t\t\t\t\t int space);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateNMToken\t(const xmlChar *value,\n\t\t\t\t\t int space);\n#endif\n\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlBuildQName\t\t(const xmlChar *ncname,\n\t\t\t\t\t const xmlChar *prefix,\n\t\t\t\t\t xmlChar *memory,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlSplitQName2\t\t(const xmlChar *name,\n\t\t\t\t\t xmlChar **prefix);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\txmlSplitQName3\t\t(const xmlChar *name,\n\t\t\t\t\t int *len);\n\n/*\n * Handling Buffers, the old ones see @xmlBuf for the new ones.\n */\n\nXMLPUBFUN void XMLCALL\n\t\txmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);\nXMLPUBFUN xmlBufferAllocationScheme XMLCALL\n\t\txmlGetBufferAllocationScheme(void);\n\nXMLPUBFUN xmlBufferPtr XMLCALL\n\t\txmlBufferCreate\t\t(void);\nXMLPUBFUN xmlBufferPtr XMLCALL\n\t\txmlBufferCreateSize\t(size_t size);\nXMLPUBFUN xmlBufferPtr XMLCALL\n\t\txmlBufferCreateStatic\t(void *mem,\n\t\t\t\t\t size_t size);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferResize\t\t(xmlBufferPtr buf,\n\t\t\t\t\t unsigned int size);\nXMLPUBFUN void XMLCALL\n\t\txmlBufferFree\t\t(xmlBufferPtr buf);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferDump\t\t(FILE *file,\n\t\t\t\t\t xmlBufferPtr buf);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferAdd\t\t(xmlBufferPtr buf,\n\t\t\t\t\t const xmlChar *str,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferAddHead\t(xmlBufferPtr buf,\n\t\t\t\t\t const xmlChar *str,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferCat\t\t(xmlBufferPtr buf,\n\t\t\t\t\t const xmlChar *str);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferCCat\t\t(xmlBufferPtr buf,\n\t\t\t\t\t const char *str);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferShrink\t\t(xmlBufferPtr buf,\n\t\t\t\t\t unsigned int len);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferGrow\t\t(xmlBufferPtr buf,\n\t\t\t\t\t unsigned int len);\nXMLPUBFUN void XMLCALL\n\t\txmlBufferEmpty\t\t(xmlBufferPtr buf);\nXMLPUBFUN const xmlChar* XMLCALL\n\t\txmlBufferContent\t(const xmlBuffer *buf);\nXMLPUBFUN xmlChar* XMLCALL\n\t\txmlBufferDetach         (xmlBufferPtr buf);\nXMLPUBFUN void XMLCALL\n\t\txmlBufferSetAllocationScheme(xmlBufferPtr buf,\n\t\t\t\t\t xmlBufferAllocationScheme scheme);\nXMLPUBFUN int XMLCALL\n\t\txmlBufferLength\t\t(const xmlBuffer *buf);\n\n/*\n * Creating/freeing new structures.\n */\nXMLPUBFUN xmlDtdPtr XMLCALL\n\t\txmlCreateIntSubset\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *ExternalID,\n\t\t\t\t\t const xmlChar *SystemID);\nXMLPUBFUN xmlDtdPtr XMLCALL\n\t\txmlNewDtd\t\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *ExternalID,\n\t\t\t\t\t const xmlChar *SystemID);\nXMLPUBFUN xmlDtdPtr XMLCALL\n\t\txmlGetIntSubset\t\t(const xmlDoc *doc);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeDtd\t\t(xmlDtdPtr cur);\n#ifdef LIBXML_LEGACY_ENABLED\nXMLPUBFUN xmlNsPtr XMLCALL\n\t\txmlNewGlobalNs\t\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *href,\n\t\t\t\t\t const xmlChar *prefix);\n#endif /* LIBXML_LEGACY_ENABLED */\nXMLPUBFUN xmlNsPtr XMLCALL\n\t\txmlNewNs\t\t(xmlNodePtr node,\n\t\t\t\t\t const xmlChar *href,\n\t\t\t\t\t const xmlChar *prefix);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeNs\t\t(xmlNsPtr cur);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeNsList\t\t(xmlNsPtr cur);\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlNewDoc\t\t(const xmlChar *version);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeDoc\t\t(xmlDocPtr cur);\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlNewDocProp\t\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *value);\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \\\n    defined(LIBXML_SCHEMAS_ENABLED)\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlNewProp\t\t(xmlNodePtr node,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *value);\n#endif\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlNewNsProp\t\t(xmlNodePtr node,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlNewNsPropEatName\t(xmlNodePtr node,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t xmlChar *name,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN void XMLCALL\n\t\txmlFreePropList\t\t(xmlAttrPtr cur);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeProp\t\t(xmlAttrPtr cur);\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlCopyProp\t\t(xmlNodePtr target,\n\t\t\t\t\t xmlAttrPtr cur);\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlCopyPropList\t\t(xmlNodePtr target,\n\t\t\t\t\t xmlAttrPtr cur);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN xmlDtdPtr XMLCALL\n\t\txmlCopyDtd\t\t(xmlDtdPtr dtd);\n#endif /* LIBXML_TREE_ENABLED */\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\txmlCopyDoc\t\t(xmlDocPtr doc,\n\t\t\t\t\t int recursive);\n#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */\n/*\n * Creating new nodes.\n */\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewDocNode\t\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewDocNodeEatName\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t xmlChar *name,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewNode\t\t(xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewNodeEatName\t(xmlNsPtr ns,\n\t\t\t\t\t xmlChar *name);\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewChild\t\t(xmlNodePtr parent,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *content);\n#endif\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewDocText\t\t(const xmlDoc *doc,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewText\t\t(const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewDocPI\t\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewPI\t\t(const xmlChar *name,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewDocTextLen\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *content,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewTextLen\t\t(const xmlChar *content,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewDocComment\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewComment\t\t(const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewCDataBlock\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *content,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewCharRef\t\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewReference\t\t(const xmlDoc *doc,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlCopyNode\t\t(xmlNodePtr node,\n\t\t\t\t\t int recursive);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlDocCopyNode\t\t(xmlNodePtr node,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t int recursive);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlDocCopyNodeList\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr node);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlCopyNodeList\t\t(xmlNodePtr node);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewTextChild\t\t(xmlNodePtr parent,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewDocRawNode\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlNewDocFragment\t(xmlDocPtr doc);\n#endif /* LIBXML_TREE_ENABLED */\n\n/*\n * Navigating.\n */\nXMLPUBFUN long XMLCALL\n\t\txmlGetLineNo\t\t(const xmlNode *node);\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlGetNodePath\t\t(const xmlNode *node);\n#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlDocGetRootElement\t(const xmlDoc *doc);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlGetLastChild\t\t(const xmlNode *parent);\nXMLPUBFUN int XMLCALL\n\t\txmlNodeIsText\t\t(const xmlNode *node);\nXMLPUBFUN int XMLCALL\n\t\txmlIsBlankNode\t\t(const xmlNode *node);\n\n/*\n * Changing the structure.\n */\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlDocSetRootElement\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr root);\n#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlNodeSetName\t\t(xmlNodePtr cur,\n\t\t\t\t\t const xmlChar *name);\n#endif /* LIBXML_TREE_ENABLED */\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlAddChild\t\t(xmlNodePtr parent,\n\t\t\t\t\t xmlNodePtr cur);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlAddChildList\t\t(xmlNodePtr parent,\n\t\t\t\t\t xmlNodePtr cur);\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlReplaceNode\t\t(xmlNodePtr old,\n\t\t\t\t\t xmlNodePtr cur);\n#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \\\n    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlAddPrevSibling\t(xmlNodePtr cur,\n\t\t\t\t\t xmlNodePtr elem);\n#endif /* LIBXML_TREE_ENABLED || LIBXML_HTML_ENABLED || LIBXML_SCHEMAS_ENABLED */\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlAddSibling\t\t(xmlNodePtr cur,\n\t\t\t\t\t xmlNodePtr elem);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlAddNextSibling\t(xmlNodePtr cur,\n\t\t\t\t\t xmlNodePtr elem);\nXMLPUBFUN void XMLCALL\n\t\txmlUnlinkNode\t\t(xmlNodePtr cur);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlTextMerge\t\t(xmlNodePtr first,\n\t\t\t\t\t xmlNodePtr second);\nXMLPUBFUN int XMLCALL\n\t\txmlTextConcat\t\t(xmlNodePtr node,\n\t\t\t\t\t const xmlChar *content,\n\t\t\t\t\t int len);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeNodeList\t\t(xmlNodePtr cur);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeNode\t\t(xmlNodePtr cur);\nXMLPUBFUN void XMLCALL\n\t\txmlSetTreeDoc\t\t(xmlNodePtr tree,\n\t\t\t\t\t xmlDocPtr doc);\nXMLPUBFUN void XMLCALL\n\t\txmlSetListDoc\t\t(xmlNodePtr list,\n\t\t\t\t\t xmlDocPtr doc);\n/*\n * Namespaces.\n */\nXMLPUBFUN xmlNsPtr XMLCALL\n\t\txmlSearchNs\t\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr node,\n\t\t\t\t\t const xmlChar *nameSpace);\nXMLPUBFUN xmlNsPtr XMLCALL\n\t\txmlSearchNsByHref\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr node,\n\t\t\t\t\t const xmlChar *href);\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || \\\n    defined(LIBXML_SCHEMAS_ENABLED)\nXMLPUBFUN xmlNsPtr * XMLCALL\n\t\txmlGetNsList\t\t(const xmlDoc *doc,\n\t\t\t\t\t const xmlNode *node);\n#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) */\n\nXMLPUBFUN void XMLCALL\n\t\txmlSetNs\t\t(xmlNodePtr node,\n\t\t\t\t\t xmlNsPtr ns);\nXMLPUBFUN xmlNsPtr XMLCALL\n\t\txmlCopyNamespace\t(xmlNsPtr cur);\nXMLPUBFUN xmlNsPtr XMLCALL\n\t\txmlCopyNamespaceList\t(xmlNsPtr cur);\n\n/*\n * Changing the content.\n */\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \\\n    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlSetProp\t\t(xmlNodePtr node,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlSetNsProp\t\t(xmlNodePtr node,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *value);\n#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \\\n\t  defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlGetNoNsProp\t\t(const xmlNode *node,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlGetProp\t\t(const xmlNode *node,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlHasProp\t\t(const xmlNode *node,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlHasNsProp\t\t(const xmlNode *node,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *nameSpace);\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlGetNsProp\t\t(const xmlNode *node,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *nameSpace);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlStringGetNodeList\t(const xmlDoc *doc,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\txmlStringLenGetNodeList\t(const xmlDoc *doc,\n\t\t\t\t\t const xmlChar *value,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlNodeListGetString\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlNode *list,\n\t\t\t\t\t int inLine);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlNodeListGetRawString\t(const xmlDoc *doc,\n\t\t\t\t\t const xmlNode *list,\n\t\t\t\t\t int inLine);\n#endif /* LIBXML_TREE_ENABLED */\nXMLPUBFUN void XMLCALL\n\t\txmlNodeSetContent\t(xmlNodePtr cur,\n\t\t\t\t\t const xmlChar *content);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlNodeSetContentLen\t(xmlNodePtr cur,\n\t\t\t\t\t const xmlChar *content,\n\t\t\t\t\t int len);\n#endif /* LIBXML_TREE_ENABLED */\nXMLPUBFUN void XMLCALL\n\t\txmlNodeAddContent\t(xmlNodePtr cur,\n\t\t\t\t\t const xmlChar *content);\nXMLPUBFUN void XMLCALL\n\t\txmlNodeAddContentLen\t(xmlNodePtr cur,\n\t\t\t\t\t const xmlChar *content,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlNodeGetContent\t(const xmlNode *cur);\n\nXMLPUBFUN int XMLCALL\n\t\txmlNodeBufGetContent\t(xmlBufferPtr buffer,\n\t\t\t\t\t const xmlNode *cur);\nXMLPUBFUN int XMLCALL\n\t\txmlBufGetNodeContent\t(xmlBufPtr buf,\n\t\t\t\t\t const xmlNode *cur);\n\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlNodeGetLang\t\t(const xmlNode *cur);\nXMLPUBFUN int XMLCALL\n\t\txmlNodeGetSpacePreserve\t(const xmlNode *cur);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlNodeSetLang\t\t(xmlNodePtr cur,\n\t\t\t\t\t const xmlChar *lang);\nXMLPUBFUN void XMLCALL\n\t\txmlNodeSetSpacePreserve (xmlNodePtr cur,\n\t\t\t\t\t int val);\n#endif /* LIBXML_TREE_ENABLED */\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlNodeGetBase\t\t(const xmlDoc *doc,\n\t\t\t\t\t const xmlNode *cur);\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)\nXMLPUBFUN void XMLCALL\n\t\txmlNodeSetBase\t\t(xmlNodePtr cur,\n\t\t\t\t\t const xmlChar *uri);\n#endif\n\n/*\n * Removing content.\n */\nXMLPUBFUN int XMLCALL\n\t\txmlRemoveProp\t\t(xmlAttrPtr cur);\n#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\nXMLPUBFUN int XMLCALL\n\t\txmlUnsetNsProp\t\t(xmlNodePtr node,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN int XMLCALL\n\t\txmlUnsetProp\t\t(xmlNodePtr node,\n\t\t\t\t\t const xmlChar *name);\n#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */\n\n/*\n * Internal, don't use.\n */\nXMLPUBFUN void XMLCALL\n\t\txmlBufferWriteCHAR\t(xmlBufferPtr buf,\n\t\t\t\t\t const xmlChar *string);\nXMLPUBFUN void XMLCALL\n\t\txmlBufferWriteChar\t(xmlBufferPtr buf,\n\t\t\t\t\t const char *string);\nXMLPUBFUN void XMLCALL\n\t\txmlBufferWriteQuotedString(xmlBufferPtr buf,\n\t\t\t\t\t const xmlChar *string);\n\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN void xmlAttrSerializeTxtContent(xmlBufferPtr buf,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlAttrPtr attr,\n\t\t\t\t\t const xmlChar *string);\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n#ifdef LIBXML_TREE_ENABLED\n/*\n * Namespace handling.\n */\nXMLPUBFUN int XMLCALL\n\t\txmlReconciliateNs\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr tree);\n#endif\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/*\n * Saving.\n */\nXMLPUBFUN void XMLCALL\n\t\txmlDocDumpFormatMemory\t(xmlDocPtr cur,\n\t\t\t\t\t xmlChar **mem,\n\t\t\t\t\t int *size,\n\t\t\t\t\t int format);\nXMLPUBFUN void XMLCALL\n\t\txmlDocDumpMemory\t(xmlDocPtr cur,\n\t\t\t\t\t xmlChar **mem,\n\t\t\t\t\t int *size);\nXMLPUBFUN void XMLCALL\n\t\txmlDocDumpMemoryEnc\t(xmlDocPtr out_doc,\n\t\t\t\t\t xmlChar **doc_txt_ptr,\n\t\t\t\t\t int * doc_txt_len,\n\t\t\t\t\t const char *txt_encoding);\nXMLPUBFUN void XMLCALL\n\t\txmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,\n\t\t\t\t\t xmlChar **doc_txt_ptr,\n\t\t\t\t\t int * doc_txt_len,\n\t\t\t\t\t const char *txt_encoding,\n\t\t\t\t\t int format);\nXMLPUBFUN int XMLCALL\n\t\txmlDocFormatDump\t(FILE *f,\n\t\t\t\t\t xmlDocPtr cur,\n\t\t\t\t\t int format);\nXMLPUBFUN int XMLCALL\n\t\txmlDocDump\t\t(FILE *f,\n\t\t\t\t\t xmlDocPtr cur);\nXMLPUBFUN void XMLCALL\n\t\txmlElemDump\t\t(FILE *f,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr cur);\nXMLPUBFUN int XMLCALL\n\t\txmlSaveFile\t\t(const char *filename,\n\t\t\t\t\t xmlDocPtr cur);\nXMLPUBFUN int XMLCALL\n\t\txmlSaveFormatFile\t(const char *filename,\n\t\t\t\t\t xmlDocPtr cur,\n\t\t\t\t\t int format);\nXMLPUBFUN size_t XMLCALL\n\t\txmlBufNodeDump\t\t(xmlBufPtr buf,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr cur,\n\t\t\t\t\t int level,\n\t\t\t\t\t int format);\nXMLPUBFUN int XMLCALL\n\t\txmlNodeDump\t\t(xmlBufferPtr buf,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr cur,\n\t\t\t\t\t int level,\n\t\t\t\t\t int format);\n\nXMLPUBFUN int XMLCALL\n\t\txmlSaveFileTo\t\t(xmlOutputBufferPtr buf,\n\t\t\t\t\t xmlDocPtr cur,\n\t\t\t\t\t const char *encoding);\nXMLPUBFUN int XMLCALL\n\t\txmlSaveFormatFileTo     (xmlOutputBufferPtr buf,\n\t\t\t\t\t xmlDocPtr cur,\n\t\t\t\t         const char *encoding,\n\t\t\t\t         int format);\nXMLPUBFUN void XMLCALL\n\t\txmlNodeDumpOutput\t(xmlOutputBufferPtr buf,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr cur,\n\t\t\t\t\t int level,\n\t\t\t\t\t int format,\n\t\t\t\t\t const char *encoding);\n\nXMLPUBFUN int XMLCALL\n\t\txmlSaveFormatFileEnc    (const char *filename,\n\t\t\t\t\t xmlDocPtr cur,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int format);\n\nXMLPUBFUN int XMLCALL\n\t\txmlSaveFileEnc\t\t(const char *filename,\n\t\t\t\t\t xmlDocPtr cur,\n\t\t\t\t\t const char *encoding);\n\n#endif /* LIBXML_OUTPUT_ENABLED */\n/*\n * XHTML\n */\nXMLPUBFUN int XMLCALL\n\t\txmlIsXHTML\t\t(const xmlChar *systemID,\n\t\t\t\t\t const xmlChar *publicID);\n\n/*\n * Compression.\n */\nXMLPUBFUN int XMLCALL\n\t\txmlGetDocCompressMode\t(const xmlDoc *doc);\nXMLPUBFUN void XMLCALL\n\t\txmlSetDocCompressMode\t(xmlDocPtr doc,\n\t\t\t\t\t int mode);\nXMLPUBFUN int XMLCALL\n\t\txmlGetCompressMode\t(void);\nXMLPUBFUN void XMLCALL\n\t\txmlSetCompressMode\t(int mode);\n\n/*\n* DOM-wrapper helper functions.\n*/\nXMLPUBFUN xmlDOMWrapCtxtPtr XMLCALL\n\t\txmlDOMWrapNewCtxt\t(void);\nXMLPUBFUN void XMLCALL\n\t\txmlDOMWrapFreeCtxt\t(xmlDOMWrapCtxtPtr ctxt);\nXMLPUBFUN int XMLCALL\n\t    xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,\n\t\t\t\t\t xmlNodePtr elem,\n\t\t\t\t\t int options);\nXMLPUBFUN int XMLCALL\n\t    xmlDOMWrapAdoptNode\t\t(xmlDOMWrapCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr sourceDoc,\n\t\t\t\t\t xmlNodePtr node,\n\t\t\t\t\t xmlDocPtr destDoc,\n\t\t\t\t\t xmlNodePtr destParent,\n\t\t\t\t\t int options);\nXMLPUBFUN int XMLCALL\n\t    xmlDOMWrapRemoveNode\t(xmlDOMWrapCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr node,\n\t\t\t\t\t int options);\nXMLPUBFUN int XMLCALL\n\t    xmlDOMWrapCloneNode\t\t(xmlDOMWrapCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr sourceDoc,\n\t\t\t\t\t xmlNodePtr node,\n\t\t\t\t\t xmlNodePtr *clonedNode,\n\t\t\t\t\t xmlDocPtr destDoc,\n\t\t\t\t\t xmlNodePtr destParent,\n\t\t\t\t\t int deep,\n\t\t\t\t\t int options);\n\n#ifdef LIBXML_TREE_ENABLED\n/*\n * 5 interfaces from DOM ElementTraversal, but different in entities\n * traversal.\n */\nXMLPUBFUN unsigned long XMLCALL\n            xmlChildElementCount        (xmlNodePtr parent);\nXMLPUBFUN xmlNodePtr XMLCALL\n            xmlNextElementSibling       (xmlNodePtr node);\nXMLPUBFUN xmlNodePtr XMLCALL\n            xmlFirstElementChild        (xmlNodePtr parent);\nXMLPUBFUN xmlNodePtr XMLCALL\n            xmlLastElementChild         (xmlNodePtr parent);\nXMLPUBFUN xmlNodePtr XMLCALL\n            xmlPreviousElementSibling   (xmlNodePtr node);\n#endif\n#ifdef __cplusplus\n}\n#endif\n#ifndef __XML_PARSER_H__\n#include <libxml/xmlmemory.h>\n#endif\n\n#endif /* __XML_TREE_H__ */\n\n"}, "38": {"id": 38, "path": "/usr/include/libxml2/libxml/valid.h", "content": "/*\n * Summary: The DTD validation\n * Description: API for the DTD handling and the validity checking\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n\n#ifndef __XML_VALID_H__\n#define __XML_VALID_H__\n\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/tree.h>\n#include <libxml/list.h>\n#include <libxml/xmlautomata.h>\n#include <libxml/xmlregexp.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Validation state added for non-determinist content model.\n */\ntypedef struct _xmlValidState xmlValidState;\ntypedef xmlValidState *xmlValidStatePtr;\n\n/**\n * xmlValidityErrorFunc:\n * @ctx:  usually an xmlValidCtxtPtr to a validity error context,\n *        but comes from ctxt->userData (which normally contains such\n *        a pointer); ctxt->userData can be changed by the user.\n * @msg:  the string to format *printf like vararg\n * @...:  remaining arguments to the format\n *\n * Callback called when a validity error is found. This is a message\n * oriented function similar to an *printf function.\n */\ntypedef void (XMLCDECL *xmlValidityErrorFunc) (void *ctx,\n\t\t\t     const char *msg,\n\t\t\t     ...) LIBXML_ATTR_FORMAT(2,3);\n\n/**\n * xmlValidityWarningFunc:\n * @ctx:  usually an xmlValidCtxtPtr to a validity error context,\n *        but comes from ctxt->userData (which normally contains such\n *        a pointer); ctxt->userData can be changed by the user.\n * @msg:  the string to format *printf like vararg\n * @...:  remaining arguments to the format\n *\n * Callback called when a validity warning is found. This is a message\n * oriented function similar to an *printf function.\n */\ntypedef void (XMLCDECL *xmlValidityWarningFunc) (void *ctx,\n\t\t\t       const char *msg,\n\t\t\t       ...) LIBXML_ATTR_FORMAT(2,3);\n\n#ifdef IN_LIBXML\n/**\n * XML_CTXT_FINISH_DTD_0:\n *\n * Special value for finishDtd field when embedded in an xmlParserCtxt\n */\n#define XML_CTXT_FINISH_DTD_0 0xabcd1234\n/**\n * XML_CTXT_FINISH_DTD_1:\n *\n * Special value for finishDtd field when embedded in an xmlParserCtxt\n */\n#define XML_CTXT_FINISH_DTD_1 0xabcd1235\n#endif\n\n/*\n * xmlValidCtxt:\n * An xmlValidCtxt is used for error reporting when validating.\n */\ntypedef struct _xmlValidCtxt xmlValidCtxt;\ntypedef xmlValidCtxt *xmlValidCtxtPtr;\nstruct _xmlValidCtxt {\n    void *userData;\t\t\t/* user specific data block */\n    xmlValidityErrorFunc error;\t\t/* the callback in case of errors */\n    xmlValidityWarningFunc warning;\t/* the callback in case of warning */\n\n    /* Node analysis stack used when validating within entities */\n    xmlNodePtr         node;          /* Current parsed Node */\n    int                nodeNr;        /* Depth of the parsing stack */\n    int                nodeMax;       /* Max depth of the parsing stack */\n    xmlNodePtr        *nodeTab;       /* array of nodes */\n\n    unsigned int     finishDtd;       /* finished validating the Dtd ? */\n    xmlDocPtr              doc;       /* the document */\n    int                  valid;       /* temporary validity check result */\n\n    /* state state used for non-determinist content validation */\n    xmlValidState     *vstate;        /* current state */\n    int                vstateNr;      /* Depth of the validation stack */\n    int                vstateMax;     /* Max depth of the validation stack */\n    xmlValidState     *vstateTab;     /* array of validation states */\n\n#ifdef LIBXML_REGEXP_ENABLED\n    xmlAutomataPtr            am;     /* the automata */\n    xmlAutomataStatePtr    state;     /* used to build the automata */\n#else\n    void                     *am;\n    void                  *state;\n#endif\n};\n\n/*\n * ALL notation declarations are stored in a table.\n * There is one table per DTD.\n */\n\ntypedef struct _xmlHashTable xmlNotationTable;\ntypedef xmlNotationTable *xmlNotationTablePtr;\n\n/*\n * ALL element declarations are stored in a table.\n * There is one table per DTD.\n */\n\ntypedef struct _xmlHashTable xmlElementTable;\ntypedef xmlElementTable *xmlElementTablePtr;\n\n/*\n * ALL attribute declarations are stored in a table.\n * There is one table per DTD.\n */\n\ntypedef struct _xmlHashTable xmlAttributeTable;\ntypedef xmlAttributeTable *xmlAttributeTablePtr;\n\n/*\n * ALL IDs attributes are stored in a table.\n * There is one table per document.\n */\n\ntypedef struct _xmlHashTable xmlIDTable;\ntypedef xmlIDTable *xmlIDTablePtr;\n\n/*\n * ALL Refs attributes are stored in a table.\n * There is one table per document.\n */\n\ntypedef struct _xmlHashTable xmlRefTable;\ntypedef xmlRefTable *xmlRefTablePtr;\n\n/* Notation */\nXMLPUBFUN xmlNotationPtr XMLCALL\n\t\txmlAddNotationDecl\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDtdPtr dtd,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *PublicID,\n\t\t\t\t\t const xmlChar *SystemID);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN xmlNotationTablePtr XMLCALL\n\t\txmlCopyNotationTable\t(xmlNotationTablePtr table);\n#endif /* LIBXML_TREE_ENABLED */\nXMLPUBFUN void XMLCALL\n\t\txmlFreeNotationTable\t(xmlNotationTablePtr table);\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlDumpNotationDecl\t(xmlBufferPtr buf,\n\t\t\t\t\t xmlNotationPtr nota);\nXMLPUBFUN void XMLCALL\n\t\txmlDumpNotationTable\t(xmlBufferPtr buf,\n\t\t\t\t\t xmlNotationTablePtr table);\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/* Element Content */\n/* the non Doc version are being deprecated */\nXMLPUBFUN xmlElementContentPtr XMLCALL\n\t\txmlNewElementContent\t(const xmlChar *name,\n\t\t\t\t\t xmlElementContentType type);\nXMLPUBFUN xmlElementContentPtr XMLCALL\n\t\txmlCopyElementContent\t(xmlElementContentPtr content);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeElementContent\t(xmlElementContentPtr cur);\n/* the new versions with doc argument */\nXMLPUBFUN xmlElementContentPtr XMLCALL\n\t\txmlNewDocElementContent\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t xmlElementContentType type);\nXMLPUBFUN xmlElementContentPtr XMLCALL\n\t\txmlCopyDocElementContent(xmlDocPtr doc,\n\t\t\t\t\t xmlElementContentPtr content);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeDocElementContent(xmlDocPtr doc,\n\t\t\t\t\t xmlElementContentPtr cur);\nXMLPUBFUN void XMLCALL\n\t\txmlSnprintfElementContent(char *buf,\n\t\t\t\t\t int size,\n\t                                 xmlElementContentPtr content,\n\t\t\t\t\t int englob);\n#ifdef LIBXML_OUTPUT_ENABLED\n/* DEPRECATED */\nXMLPUBFUN void XMLCALL\n\t\txmlSprintfElementContent(char *buf,\n\t                                 xmlElementContentPtr content,\n\t\t\t\t\t int englob);\n#endif /* LIBXML_OUTPUT_ENABLED */\n/* DEPRECATED */\n\n/* Element */\nXMLPUBFUN xmlElementPtr XMLCALL\n\t\txmlAddElementDecl\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDtdPtr dtd,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t xmlElementTypeVal type,\n\t\t\t\t\t xmlElementContentPtr content);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN xmlElementTablePtr XMLCALL\n\t\txmlCopyElementTable\t(xmlElementTablePtr table);\n#endif /* LIBXML_TREE_ENABLED */\nXMLPUBFUN void XMLCALL\n\t\txmlFreeElementTable\t(xmlElementTablePtr table);\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlDumpElementTable\t(xmlBufferPtr buf,\n\t\t\t\t\t xmlElementTablePtr table);\nXMLPUBFUN void XMLCALL\n\t\txmlDumpElementDecl\t(xmlBufferPtr buf,\n\t\t\t\t\t xmlElementPtr elem);\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/* Enumeration */\nXMLPUBFUN xmlEnumerationPtr XMLCALL\n\t\txmlCreateEnumeration\t(const xmlChar *name);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeEnumeration\t(xmlEnumerationPtr cur);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN xmlEnumerationPtr XMLCALL\n\t\txmlCopyEnumeration\t(xmlEnumerationPtr cur);\n#endif /* LIBXML_TREE_ENABLED */\n\n/* Attribute */\nXMLPUBFUN xmlAttributePtr XMLCALL\n\t\txmlAddAttributeDecl\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDtdPtr dtd,\n\t\t\t\t\t const xmlChar *elem,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *ns,\n\t\t\t\t\t xmlAttributeType type,\n\t\t\t\t\t xmlAttributeDefault def,\n\t\t\t\t\t const xmlChar *defaultValue,\n\t\t\t\t\t xmlEnumerationPtr tree);\n#ifdef LIBXML_TREE_ENABLED\nXMLPUBFUN xmlAttributeTablePtr XMLCALL\n\t\txmlCopyAttributeTable  (xmlAttributeTablePtr table);\n#endif /* LIBXML_TREE_ENABLED */\nXMLPUBFUN void XMLCALL\n\t\txmlFreeAttributeTable  (xmlAttributeTablePtr table);\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN void XMLCALL\n\t\txmlDumpAttributeTable  (xmlBufferPtr buf,\n\t\t\t\t\txmlAttributeTablePtr table);\nXMLPUBFUN void XMLCALL\n\t\txmlDumpAttributeDecl   (xmlBufferPtr buf,\n\t\t\t\t\txmlAttributePtr attr);\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/* IDs */\nXMLPUBFUN xmlIDPtr XMLCALL\n\t\txmlAddID\t       (xmlValidCtxtPtr ctxt,\n\t\t\t\t\txmlDocPtr doc,\n\t\t\t\t\tconst xmlChar *value,\n\t\t\t\t\txmlAttrPtr attr);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeIDTable\t       (xmlIDTablePtr table);\nXMLPUBFUN xmlAttrPtr XMLCALL\n\t\txmlGetID\t       (xmlDocPtr doc,\n\t\t\t\t\tconst xmlChar *ID);\nXMLPUBFUN int XMLCALL\n\t\txmlIsID\t\t       (xmlDocPtr doc,\n\t\t\t\t\txmlNodePtr elem,\n\t\t\t\t\txmlAttrPtr attr);\nXMLPUBFUN int XMLCALL\n\t\txmlRemoveID\t       (xmlDocPtr doc,\n\t\t\t\t\txmlAttrPtr attr);\n\n/* IDREFs */\nXMLPUBFUN xmlRefPtr XMLCALL\n\t\txmlAddRef\t       (xmlValidCtxtPtr ctxt,\n\t\t\t\t\txmlDocPtr doc,\n\t\t\t\t\tconst xmlChar *value,\n\t\t\t\t\txmlAttrPtr attr);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeRefTable\t       (xmlRefTablePtr table);\nXMLPUBFUN int XMLCALL\n\t\txmlIsRef\t       (xmlDocPtr doc,\n\t\t\t\t\txmlNodePtr elem,\n\t\t\t\t\txmlAttrPtr attr);\nXMLPUBFUN int XMLCALL\n\t\txmlRemoveRef\t       (xmlDocPtr doc,\n\t\t\t\t\txmlAttrPtr attr);\nXMLPUBFUN xmlListPtr XMLCALL\n\t\txmlGetRefs\t       (xmlDocPtr doc,\n\t\t\t\t\tconst xmlChar *ID);\n\n/**\n * The public function calls related to validity checking.\n */\n#ifdef LIBXML_VALID_ENABLED\n/* Allocate/Release Validation Contexts */\nXMLPUBFUN xmlValidCtxtPtr XMLCALL\n\t\txmlNewValidCtxt(void);\nXMLPUBFUN void XMLCALL\n\t\txmlFreeValidCtxt(xmlValidCtxtPtr);\n\nXMLPUBFUN int XMLCALL\n\t\txmlValidateRoot\t\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateElementDecl\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t                         xmlElementPtr elem);\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlValidNormalizeAttributeValue(xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN xmlChar * XMLCALL\n\t\txmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateAttributeDecl(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t                         xmlAttributePtr attr);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateAttributeValue(xmlAttributeType type,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateNotationDecl\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t                         xmlNotationPtr nota);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateDtd\t\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlDtdPtr dtd);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateDtdFinal\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateDocument\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateElement\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateOneElement\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t                         xmlNodePtr elem);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateOneAttribute\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr\telem,\n\t\t\t\t\t xmlAttrPtr attr,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateOneNamespace\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem,\n\t\t\t\t\t const xmlChar *prefix,\n\t\t\t\t\t xmlNsPtr ns,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc);\n#endif /* LIBXML_VALID_ENABLED */\n\n#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\nXMLPUBFUN int XMLCALL\n\t\txmlValidateNotationUse\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *notationName);\n#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */\n\nXMLPUBFUN int XMLCALL\n\t\txmlIsMixedElement\t(xmlDocPtr doc,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlAttributePtr XMLCALL\n\t\txmlGetDtdAttrDesc\t(xmlDtdPtr dtd,\n\t\t\t\t\t const xmlChar *elem,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlAttributePtr XMLCALL\n\t\txmlGetDtdQAttrDesc\t(xmlDtdPtr dtd,\n\t\t\t\t\t const xmlChar *elem,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *prefix);\nXMLPUBFUN xmlNotationPtr XMLCALL\n\t\txmlGetDtdNotationDesc\t(xmlDtdPtr dtd,\n\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlElementPtr XMLCALL\n\t\txmlGetDtdQElementDesc\t(xmlDtdPtr dtd,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t const xmlChar *prefix);\nXMLPUBFUN xmlElementPtr XMLCALL\n\t\txmlGetDtdElementDesc\t(xmlDtdPtr dtd,\n\t\t\t\t\t const xmlChar *name);\n\n#ifdef LIBXML_VALID_ENABLED\n\nXMLPUBFUN int XMLCALL\n\t\txmlValidGetPotentialChildren(xmlElementContent *ctree,\n\t\t\t\t\t const xmlChar **names,\n\t\t\t\t\t int *len,\n\t\t\t\t\t int max);\n\nXMLPUBFUN int XMLCALL\n\t\txmlValidGetValidElements(xmlNode *prev,\n\t\t\t\t\t xmlNode *next,\n\t\t\t\t\t const xmlChar **names,\n\t\t\t\t\t int max);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateNameValue\t(const xmlChar *value);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateNamesValue\t(const xmlChar *value);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateNmtokenValue\t(const xmlChar *value);\nXMLPUBFUN int XMLCALL\n\t\txmlValidateNmtokensValue(const xmlChar *value);\n\n#ifdef LIBXML_REGEXP_ENABLED\n/*\n * Validation based on the regexp support\n */\nXMLPUBFUN int XMLCALL\n\t\txmlValidBuildContentModel(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlElementPtr elem);\n\nXMLPUBFUN int XMLCALL\n\t\txmlValidatePushElement\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem,\n\t\t\t\t\t const xmlChar *qname);\nXMLPUBFUN int XMLCALL\n\t\txmlValidatePushCData\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t const xmlChar *data,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\t\txmlValidatePopElement\t(xmlValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr elem,\n\t\t\t\t\t const xmlChar *qname);\n#endif /* LIBXML_REGEXP_ENABLED */\n#endif /* LIBXML_VALID_ENABLED */\n#ifdef __cplusplus\n}\n#endif\n#endif /* __XML_VALID_H__ */\n"}, "39": {"id": 39, "path": "/usr/include/libxml2/libxml/xlink.h", "content": "/*\n * Summary: unfinished XLink detection module\n * Description: unfinished XLink detection module\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_XLINK_H__\n#define __XML_XLINK_H__\n\n#include <libxml/xmlversion.h>\n#include <libxml/tree.h>\n\n#ifdef LIBXML_XPTR_ENABLED\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * Various defines for the various Link properties.\n *\n * NOTE: the link detection layer will try to resolve QName expansion\n *       of namespaces. If \"foo\" is the prefix for \"http://foo.com/\"\n *       then the link detection layer will expand role=\"foo:myrole\"\n *       to \"http://foo.com/:myrole\".\n * NOTE: the link detection layer will expand URI-References found on\n *       href attributes by using the base mechanism if found.\n */\ntypedef xmlChar *xlinkHRef;\ntypedef xmlChar *xlinkRole;\ntypedef xmlChar *xlinkTitle;\n\ntypedef enum {\n    XLINK_TYPE_NONE = 0,\n    XLINK_TYPE_SIMPLE,\n    XLINK_TYPE_EXTENDED,\n    XLINK_TYPE_EXTENDED_SET\n} xlinkType;\n\ntypedef enum {\n    XLINK_SHOW_NONE = 0,\n    XLINK_SHOW_NEW,\n    XLINK_SHOW_EMBED,\n    XLINK_SHOW_REPLACE\n} xlinkShow;\n\ntypedef enum {\n    XLINK_ACTUATE_NONE = 0,\n    XLINK_ACTUATE_AUTO,\n    XLINK_ACTUATE_ONREQUEST\n} xlinkActuate;\n\n/**\n * xlinkNodeDetectFunc:\n * @ctx:  user data pointer\n * @node:  the node to check\n *\n * This is the prototype for the link detection routine.\n * It calls the default link detection callbacks upon link detection.\n */\ntypedef void (*xlinkNodeDetectFunc) (void *ctx, xmlNodePtr node);\n\n/*\n * The link detection module interact with the upper layers using\n * a set of callback registered at parsing time.\n */\n\n/**\n * xlinkSimpleLinkFunk:\n * @ctx:  user data pointer\n * @node:  the node carrying the link\n * @href:  the target of the link\n * @role:  the role string\n * @title:  the link title\n *\n * This is the prototype for a simple link detection callback.\n */\ntypedef void\n(*xlinkSimpleLinkFunk)\t(void *ctx,\n\t\t\t xmlNodePtr node,\n\t\t\t const xlinkHRef href,\n\t\t\t const xlinkRole role,\n\t\t\t const xlinkTitle title);\n\n/**\n * xlinkExtendedLinkFunk:\n * @ctx:  user data pointer\n * @node:  the node carrying the link\n * @nbLocators: the number of locators detected on the link\n * @hrefs:  pointer to the array of locator hrefs\n * @roles:  pointer to the array of locator roles\n * @nbArcs: the number of arcs detected on the link\n * @from:  pointer to the array of source roles found on the arcs\n * @to:  pointer to the array of target roles found on the arcs\n * @show:  array of values for the show attributes found on the arcs\n * @actuate:  array of values for the actuate attributes found on the arcs\n * @nbTitles: the number of titles detected on the link\n * @title:  array of titles detected on the link\n * @langs:  array of xml:lang values for the titles\n *\n * This is the prototype for a extended link detection callback.\n */\ntypedef void\n(*xlinkExtendedLinkFunk)(void *ctx,\n\t\t\t xmlNodePtr node,\n\t\t\t int nbLocators,\n\t\t\t const xlinkHRef *hrefs,\n\t\t\t const xlinkRole *roles,\n\t\t\t int nbArcs,\n\t\t\t const xlinkRole *from,\n\t\t\t const xlinkRole *to,\n\t\t\t xlinkShow *show,\n\t\t\t xlinkActuate *actuate,\n\t\t\t int nbTitles,\n\t\t\t const xlinkTitle *titles,\n\t\t\t const xmlChar **langs);\n\n/**\n * xlinkExtendedLinkSetFunk:\n * @ctx:  user data pointer\n * @node:  the node carrying the link\n * @nbLocators: the number of locators detected on the link\n * @hrefs:  pointer to the array of locator hrefs\n * @roles:  pointer to the array of locator roles\n * @nbTitles: the number of titles detected on the link\n * @title:  array of titles detected on the link\n * @langs:  array of xml:lang values for the titles\n *\n * This is the prototype for a extended link set detection callback.\n */\ntypedef void\n(*xlinkExtendedLinkSetFunk)\t(void *ctx,\n\t\t\t\t xmlNodePtr node,\n\t\t\t\t int nbLocators,\n\t\t\t\t const xlinkHRef *hrefs,\n\t\t\t\t const xlinkRole *roles,\n\t\t\t\t int nbTitles,\n\t\t\t\t const xlinkTitle *titles,\n\t\t\t\t const xmlChar **langs);\n\n/**\n * This is the structure containing a set of Links detection callbacks.\n *\n * There is no default xlink callbacks, if one want to get link\n * recognition activated, those call backs must be provided before parsing.\n */\ntypedef struct _xlinkHandler xlinkHandler;\ntypedef xlinkHandler *xlinkHandlerPtr;\nstruct _xlinkHandler {\n    xlinkSimpleLinkFunk simple;\n    xlinkExtendedLinkFunk extended;\n    xlinkExtendedLinkSetFunk set;\n};\n\n/*\n * The default detection routine, can be overridden, they call the default\n * detection callbacks.\n */\n\nXMLPUBFUN xlinkNodeDetectFunc XMLCALL\n\t\txlinkGetDefaultDetect\t(void);\nXMLPUBFUN void XMLCALL\n\t\txlinkSetDefaultDetect\t(xlinkNodeDetectFunc func);\n\n/*\n * Routines to set/get the default handlers.\n */\nXMLPUBFUN xlinkHandlerPtr XMLCALL\n\t\txlinkGetDefaultHandler\t(void);\nXMLPUBFUN void XMLCALL\n\t\txlinkSetDefaultHandler\t(xlinkHandlerPtr handler);\n\n/*\n * Link detection module itself.\n */\nXMLPUBFUN xlinkType XMLCALL\n\t\txlinkIsLink\t\t(xmlDocPtr doc,\n\t\t\t\t\t xmlNodePtr node);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* LIBXML_XPTR_ENABLED */\n\n#endif /* __XML_XLINK_H__ */\n"}, "40": {"id": 40, "path": "/usr/include/libxml2/libxml/xmlIO.h", "content": "/*\n * Summary: interface for the I/O interfaces used by the parser\n * Description: interface for the I/O interfaces used by the parser\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_IO_H__\n#define __XML_IO_H__\n\n#include <stdio.h>\n#include <libxml/xmlversion.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Those are the functions and datatypes for the parser input\n * I/O structures.\n */\n\n/**\n * xmlInputMatchCallback:\n * @filename: the filename or URI\n *\n * Callback used in the I/O Input API to detect if the current handler\n * can provide input functionality for this resource.\n *\n * Returns 1 if yes and 0 if another Input module should be used\n */\ntypedef int (XMLCALL *xmlInputMatchCallback) (char const *filename);\n/**\n * xmlInputOpenCallback:\n * @filename: the filename or URI\n *\n * Callback used in the I/O Input API to open the resource\n *\n * Returns an Input context or NULL in case or error\n */\ntypedef void * (XMLCALL *xmlInputOpenCallback) (char const *filename);\n/**\n * xmlInputReadCallback:\n * @context:  an Input context\n * @buffer:  the buffer to store data read\n * @len:  the length of the buffer in bytes\n *\n * Callback used in the I/O Input API to read the resource\n *\n * Returns the number of bytes read or -1 in case of error\n */\ntypedef int (XMLCALL *xmlInputReadCallback) (void * context, char * buffer, int len);\n/**\n * xmlInputCloseCallback:\n * @context:  an Input context\n *\n * Callback used in the I/O Input API to close the resource\n *\n * Returns 0 or -1 in case of error\n */\ntypedef int (XMLCALL *xmlInputCloseCallback) (void * context);\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/*\n * Those are the functions and datatypes for the library output\n * I/O structures.\n */\n\n/**\n * xmlOutputMatchCallback:\n * @filename: the filename or URI\n *\n * Callback used in the I/O Output API to detect if the current handler\n * can provide output functionality for this resource.\n *\n * Returns 1 if yes and 0 if another Output module should be used\n */\ntypedef int (XMLCALL *xmlOutputMatchCallback) (char const *filename);\n/**\n * xmlOutputOpenCallback:\n * @filename: the filename or URI\n *\n * Callback used in the I/O Output API to open the resource\n *\n * Returns an Output context or NULL in case or error\n */\ntypedef void * (XMLCALL *xmlOutputOpenCallback) (char const *filename);\n/**\n * xmlOutputWriteCallback:\n * @context:  an Output context\n * @buffer:  the buffer of data to write\n * @len:  the length of the buffer in bytes\n *\n * Callback used in the I/O Output API to write to the resource\n *\n * Returns the number of bytes written or -1 in case of error\n */\ntypedef int (XMLCALL *xmlOutputWriteCallback) (void * context, const char * buffer,\n                                       int len);\n/**\n * xmlOutputCloseCallback:\n * @context:  an Output context\n *\n * Callback used in the I/O Output API to close the resource\n *\n * Returns 0 or -1 in case of error\n */\ntypedef int (XMLCALL *xmlOutputCloseCallback) (void * context);\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n#ifdef __cplusplus\n}\n#endif\n\n#include <libxml/globals.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n#include <libxml/encoding.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nstruct _xmlParserInputBuffer {\n    void*                  context;\n    xmlInputReadCallback   readcallback;\n    xmlInputCloseCallback  closecallback;\n\n    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */\n\n    xmlBufPtr buffer;    /* Local buffer encoded in UTF-8 */\n    xmlBufPtr raw;       /* if encoder != NULL buffer for raw input */\n    int\tcompressed;\t    /* -1=unknown, 0=not compressed, 1=compressed */\n    int error;\n    unsigned long rawconsumed;/* amount consumed from raw */\n};\n\n\n#ifdef LIBXML_OUTPUT_ENABLED\nstruct _xmlOutputBuffer {\n    void*                   context;\n    xmlOutputWriteCallback  writecallback;\n    xmlOutputCloseCallback  closecallback;\n\n    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */\n\n    xmlBufPtr buffer;    /* Local buffer encoded in UTF-8 or ISOLatin */\n    xmlBufPtr conv;      /* if encoder != NULL buffer for output */\n    int written;            /* total number of byte written */\n    int error;\n};\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/*\n * Interfaces for input\n */\nXMLPUBFUN void XMLCALL\n\txmlCleanupInputCallbacks\t\t(void);\n\nXMLPUBFUN int XMLCALL\n\txmlPopInputCallbacks\t\t\t(void);\n\nXMLPUBFUN void XMLCALL\n\txmlRegisterDefaultInputCallbacks\t(void);\nXMLPUBFUN xmlParserInputBufferPtr XMLCALL\n\txmlAllocParserInputBuffer\t\t(xmlCharEncoding enc);\n\nXMLPUBFUN xmlParserInputBufferPtr XMLCALL\n\txmlParserInputBufferCreateFilename\t(const char *URI,\n                                                 xmlCharEncoding enc);\nXMLPUBFUN xmlParserInputBufferPtr XMLCALL\n\txmlParserInputBufferCreateFile\t\t(FILE *file,\n                                                 xmlCharEncoding enc);\nXMLPUBFUN xmlParserInputBufferPtr XMLCALL\n\txmlParserInputBufferCreateFd\t\t(int fd,\n\t                                         xmlCharEncoding enc);\nXMLPUBFUN xmlParserInputBufferPtr XMLCALL\n\txmlParserInputBufferCreateMem\t\t(const char *mem, int size,\n\t                                         xmlCharEncoding enc);\nXMLPUBFUN xmlParserInputBufferPtr XMLCALL\n\txmlParserInputBufferCreateStatic\t(const char *mem, int size,\n\t                                         xmlCharEncoding enc);\nXMLPUBFUN xmlParserInputBufferPtr XMLCALL\n\txmlParserInputBufferCreateIO\t\t(xmlInputReadCallback   ioread,\n\t\t\t\t\t\t xmlInputCloseCallback  ioclose,\n\t\t\t\t\t\t void *ioctx,\n\t                                         xmlCharEncoding enc);\nXMLPUBFUN int XMLCALL\n\txmlParserInputBufferRead\t\t(xmlParserInputBufferPtr in,\n\t\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\txmlParserInputBufferGrow\t\t(xmlParserInputBufferPtr in,\n\t\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\txmlParserInputBufferPush\t\t(xmlParserInputBufferPtr in,\n\t\t\t\t\t\t int len,\n\t\t\t\t\t\t const char *buf);\nXMLPUBFUN void XMLCALL\n\txmlFreeParserInputBuffer\t\t(xmlParserInputBufferPtr in);\nXMLPUBFUN char * XMLCALL\n\txmlParserGetDirectory\t\t\t(const char *filename);\n\nXMLPUBFUN int XMLCALL\n\txmlRegisterInputCallbacks\t\t(xmlInputMatchCallback matchFunc,\n\t\t\t\t\t\t xmlInputOpenCallback openFunc,\n\t\t\t\t\t\t xmlInputReadCallback readFunc,\n\t\t\t\t\t\t xmlInputCloseCallback closeFunc);\n\nxmlParserInputBufferPtr\n\t__xmlParserInputBufferCreateFilename(const char *URI,\n\t\t\t\t\t\txmlCharEncoding enc);\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/*\n * Interfaces for output\n */\nXMLPUBFUN void XMLCALL\n\txmlCleanupOutputCallbacks\t\t(void);\nXMLPUBFUN void XMLCALL\n\txmlRegisterDefaultOutputCallbacks(void);\nXMLPUBFUN xmlOutputBufferPtr XMLCALL\n\txmlAllocOutputBuffer\t\t(xmlCharEncodingHandlerPtr encoder);\n\nXMLPUBFUN xmlOutputBufferPtr XMLCALL\n\txmlOutputBufferCreateFilename\t(const char *URI,\n\t\t\t\t\t xmlCharEncodingHandlerPtr encoder,\n\t\t\t\t\t int compression);\n\nXMLPUBFUN xmlOutputBufferPtr XMLCALL\n\txmlOutputBufferCreateFile\t(FILE *file,\n\t\t\t\t\t xmlCharEncodingHandlerPtr encoder);\n\nXMLPUBFUN xmlOutputBufferPtr XMLCALL\n\txmlOutputBufferCreateBuffer\t(xmlBufferPtr buffer,\n\t\t\t\t\t xmlCharEncodingHandlerPtr encoder);\n\nXMLPUBFUN xmlOutputBufferPtr XMLCALL\n\txmlOutputBufferCreateFd\t\t(int fd,\n\t\t\t\t\t xmlCharEncodingHandlerPtr encoder);\n\nXMLPUBFUN xmlOutputBufferPtr XMLCALL\n\txmlOutputBufferCreateIO\t\t(xmlOutputWriteCallback   iowrite,\n\t\t\t\t\t xmlOutputCloseCallback  ioclose,\n\t\t\t\t\t void *ioctx,\n\t\t\t\t\t xmlCharEncodingHandlerPtr encoder);\n\n/* Couple of APIs to get the output without digging into the buffers */\nXMLPUBFUN const xmlChar * XMLCALL\n        xmlOutputBufferGetContent       (xmlOutputBufferPtr out);\nXMLPUBFUN size_t XMLCALL\n        xmlOutputBufferGetSize          (xmlOutputBufferPtr out);\n\nXMLPUBFUN int XMLCALL\n\txmlOutputBufferWrite\t\t(xmlOutputBufferPtr out,\n\t\t\t\t\t int len,\n\t\t\t\t\t const char *buf);\nXMLPUBFUN int XMLCALL\n\txmlOutputBufferWriteString\t(xmlOutputBufferPtr out,\n\t\t\t\t\t const char *str);\nXMLPUBFUN int XMLCALL\n\txmlOutputBufferWriteEscape\t(xmlOutputBufferPtr out,\n\t\t\t\t\t const xmlChar *str,\n\t\t\t\t\t xmlCharEncodingOutputFunc escaping);\n\nXMLPUBFUN int XMLCALL\n\txmlOutputBufferFlush\t\t(xmlOutputBufferPtr out);\nXMLPUBFUN int XMLCALL\n\txmlOutputBufferClose\t\t(xmlOutputBufferPtr out);\n\nXMLPUBFUN int XMLCALL\n\txmlRegisterOutputCallbacks\t(xmlOutputMatchCallback matchFunc,\n\t\t\t\t\t xmlOutputOpenCallback openFunc,\n\t\t\t\t\t xmlOutputWriteCallback writeFunc,\n\t\t\t\t\t xmlOutputCloseCallback closeFunc);\n\nxmlOutputBufferPtr\n\t__xmlOutputBufferCreateFilename(const char *URI,\n                              xmlCharEncodingHandlerPtr encoder,\n                              int compression);\n\n#ifdef LIBXML_HTTP_ENABLED\n/*  This function only exists if HTTP support built into the library  */\nXMLPUBFUN void XMLCALL\n\txmlRegisterHTTPPostCallbacks\t(void );\n#endif /* LIBXML_HTTP_ENABLED */\n\n#endif /* LIBXML_OUTPUT_ENABLED */\n\nXMLPUBFUN xmlParserInputPtr XMLCALL\n\txmlCheckHTTPInput\t\t(xmlParserCtxtPtr ctxt,\n\t\t\t\t\t xmlParserInputPtr ret);\n\n/*\n * A predefined entity loader disabling network accesses\n */\nXMLPUBFUN xmlParserInputPtr XMLCALL\n\txmlNoNetExternalEntityLoader\t(const char *URL,\n\t\t\t\t\t const char *ID,\n\t\t\t\t\t xmlParserCtxtPtr ctxt);\n\n/*\n * xmlNormalizeWindowsPath is obsolete, don't use it.\n * Check xmlCanonicPath in uri.h for a better alternative.\n */\nXMLPUBFUN xmlChar * XMLCALL\n\txmlNormalizeWindowsPath\t\t(const xmlChar *path);\n\nXMLPUBFUN int XMLCALL\n\txmlCheckFilename\t\t(const char *path);\n/**\n * Default 'file://' protocol callbacks\n */\nXMLPUBFUN int XMLCALL\n\txmlFileMatch\t\t\t(const char *filename);\nXMLPUBFUN void * XMLCALL\n\txmlFileOpen\t\t\t(const char *filename);\nXMLPUBFUN int XMLCALL\n\txmlFileRead\t\t\t(void * context,\n\t\t\t\t\t char * buffer,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\txmlFileClose\t\t\t(void * context);\n\n/**\n * Default 'http://' protocol callbacks\n */\n#ifdef LIBXML_HTTP_ENABLED\nXMLPUBFUN int XMLCALL\n\txmlIOHTTPMatch\t\t\t(const char *filename);\nXMLPUBFUN void * XMLCALL\n\txmlIOHTTPOpen\t\t\t(const char *filename);\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN void * XMLCALL\n\txmlIOHTTPOpenW\t\t\t(const char * post_uri,\n\t\t\t\t\t int   compression );\n#endif /* LIBXML_OUTPUT_ENABLED */\nXMLPUBFUN int XMLCALL\n\txmlIOHTTPRead\t\t\t(void * context,\n\t\t\t\t\t char * buffer,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\txmlIOHTTPClose\t\t\t(void * context);\n#endif /* LIBXML_HTTP_ENABLED */\n\n/**\n * Default 'ftp://' protocol callbacks\n */\n#ifdef LIBXML_FTP_ENABLED\nXMLPUBFUN int XMLCALL\n\txmlIOFTPMatch\t\t\t(const char *filename);\nXMLPUBFUN void * XMLCALL\n\txmlIOFTPOpen\t\t\t(const char *filename);\nXMLPUBFUN int XMLCALL\n\txmlIOFTPRead\t\t\t(void * context,\n\t\t\t\t\t char * buffer,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\txmlIOFTPClose\t\t\t(void * context);\n#endif /* LIBXML_FTP_ENABLED */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __XML_IO_H__ */\n"}, "41": {"id": 41, "path": "/usr/include/libxml2/libxml/xmlautomata.h", "content": "/*\n * Summary: API to build regexp automata\n * Description: the API to build regexp automata\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_AUTOMATA_H__\n#define __XML_AUTOMATA_H__\n\n#include <libxml/xmlversion.h>\n#include <libxml/tree.h>\n\n#ifdef LIBXML_REGEXP_ENABLED\n#ifdef LIBXML_AUTOMATA_ENABLED\n#include <libxml/xmlregexp.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * xmlAutomataPtr:\n *\n * A libxml automata description, It can be compiled into a regexp\n */\ntypedef struct _xmlAutomata xmlAutomata;\ntypedef xmlAutomata *xmlAutomataPtr;\n\n/**\n * xmlAutomataStatePtr:\n *\n * A state int the automata description,\n */\ntypedef struct _xmlAutomataState xmlAutomataState;\ntypedef xmlAutomataState *xmlAutomataStatePtr;\n\n/*\n * Building API\n */\nXMLPUBFUN xmlAutomataPtr XMLCALL\n\t\t    xmlNewAutomata\t\t(void);\nXMLPUBFUN void XMLCALL\n\t\t    xmlFreeAutomata\t\t(xmlAutomataPtr am);\n\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataGetInitState\t(xmlAutomataPtr am);\nXMLPUBFUN int XMLCALL\n\t\t    xmlAutomataSetFinalState\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr state);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewState\t\t(xmlAutomataPtr am);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewTransition\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t const xmlChar *token,\n\t\t\t\t\t\t void *data);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewTransition2\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t const xmlChar *token,\n\t\t\t\t\t\t const xmlChar *token2,\n\t\t\t\t\t\t void *data);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n                    xmlAutomataNewNegTrans\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t const xmlChar *token,\n\t\t\t\t\t\t const xmlChar *token2,\n\t\t\t\t\t\t void *data);\n\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewCountTrans\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t const xmlChar *token,\n\t\t\t\t\t\t int min,\n\t\t\t\t\t\t int max,\n\t\t\t\t\t\t void *data);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewCountTrans2\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t const xmlChar *token,\n\t\t\t\t\t\t const xmlChar *token2,\n\t\t\t\t\t\t int min,\n\t\t\t\t\t\t int max,\n\t\t\t\t\t\t void *data);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewOnceTrans\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t const xmlChar *token,\n\t\t\t\t\t\t int min,\n\t\t\t\t\t\t int max,\n\t\t\t\t\t\t void *data);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewOnceTrans2\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t const xmlChar *token,\n\t\t\t\t\t\t const xmlChar *token2,\n\t\t\t\t\t\t int min,\n\t\t\t\t\t\t int max,\n\t\t\t\t\t\t void *data);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewAllTrans\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t int lax);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewEpsilon\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewCountedTrans\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t int counter);\nXMLPUBFUN xmlAutomataStatePtr XMLCALL\n\t\t    xmlAutomataNewCounterTrans\t(xmlAutomataPtr am,\n\t\t\t\t\t\t xmlAutomataStatePtr from,\n\t\t\t\t\t\t xmlAutomataStatePtr to,\n\t\t\t\t\t\t int counter);\nXMLPUBFUN int XMLCALL\n\t\t    xmlAutomataNewCounter\t(xmlAutomataPtr am,\n\t\t\t\t\t\t int min,\n\t\t\t\t\t\t int max);\n\nXMLPUBFUN xmlRegexpPtr XMLCALL\n\t\t    xmlAutomataCompile\t\t(xmlAutomataPtr am);\nXMLPUBFUN int XMLCALL\n\t\t    xmlAutomataIsDeterminist\t(xmlAutomataPtr am);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* LIBXML_AUTOMATA_ENABLED */\n#endif /* LIBXML_REGEXP_ENABLED */\n\n#endif /* __XML_AUTOMATA_H__ */\n"}, "42": {"id": 42, "path": "/usr/include/libxml2/libxml/xmlerror.h", "content": "/*\n * Summary: error handling\n * Description: the API used to report errors\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#include <libxml/parser.h>\n\n#ifndef __XML_ERROR_H__\n#define __XML_ERROR_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * xmlErrorLevel:\n *\n * Indicates the level of an error\n */\ntypedef enum {\n    XML_ERR_NONE = 0,\n    XML_ERR_WARNING = 1,\t/* A simple warning */\n    XML_ERR_ERROR = 2,\t\t/* A recoverable error */\n    XML_ERR_FATAL = 3\t\t/* A fatal error */\n} xmlErrorLevel;\n\n/**\n * xmlErrorDomain:\n *\n * Indicates where an error may have come from\n */\ntypedef enum {\n    XML_FROM_NONE = 0,\n    XML_FROM_PARSER,\t/* The XML parser */\n    XML_FROM_TREE,\t/* The tree module */\n    XML_FROM_NAMESPACE,\t/* The XML Namespace module */\n    XML_FROM_DTD,\t/* The XML DTD validation with parser context*/\n    XML_FROM_HTML,\t/* The HTML parser */\n    XML_FROM_MEMORY,\t/* The memory allocator */\n    XML_FROM_OUTPUT,\t/* The serialization code */\n    XML_FROM_IO,\t/* The Input/Output stack */\n    XML_FROM_FTP,\t/* The FTP module */\n    XML_FROM_HTTP,\t/* The HTTP module */\n    XML_FROM_XINCLUDE,\t/* The XInclude processing */\n    XML_FROM_XPATH,\t/* The XPath module */\n    XML_FROM_XPOINTER,\t/* The XPointer module */\n    XML_FROM_REGEXP,\t/* The regular expressions module */\n    XML_FROM_DATATYPE,\t/* The W3C XML Schemas Datatype module */\n    XML_FROM_SCHEMASP,\t/* The W3C XML Schemas parser module */\n    XML_FROM_SCHEMASV,\t/* The W3C XML Schemas validation module */\n    XML_FROM_RELAXNGP,\t/* The Relax-NG parser module */\n    XML_FROM_RELAXNGV,\t/* The Relax-NG validator module */\n    XML_FROM_CATALOG,\t/* The Catalog module */\n    XML_FROM_C14N,\t/* The Canonicalization module */\n    XML_FROM_XSLT,\t/* The XSLT engine from libxslt */\n    XML_FROM_VALID,\t/* The XML DTD validation with valid context */\n    XML_FROM_CHECK,\t/* The error checking module */\n    XML_FROM_WRITER,\t/* The xmlwriter module */\n    XML_FROM_MODULE,\t/* The dynamically loaded module module*/\n    XML_FROM_I18N,\t/* The module handling character conversion */\n    XML_FROM_SCHEMATRONV,/* The Schematron validator module */\n    XML_FROM_BUFFER,    /* The buffers module */\n    XML_FROM_URI        /* The URI module */\n} xmlErrorDomain;\n\n/**\n * xmlError:\n *\n * An XML Error instance.\n */\n\ntypedef struct _xmlError xmlError;\ntypedef xmlError *xmlErrorPtr;\nstruct _xmlError {\n    int\t\tdomain;\t/* What part of the library raised this error */\n    int\t\tcode;\t/* The error code, e.g. an xmlParserError */\n    char       *message;/* human-readable informative error message */\n    xmlErrorLevel level;/* how consequent is the error */\n    char       *file;\t/* the filename */\n    int\t\tline;\t/* the line number if available */\n    char       *str1;\t/* extra string information */\n    char       *str2;\t/* extra string information */\n    char       *str3;\t/* extra string information */\n    int\t\tint1;\t/* extra number information */\n    int\t\tint2;\t/* error column # or 0 if N/A (todo: rename field when we would brk ABI) */\n    void       *ctxt;   /* the parser context if available */\n    void       *node;   /* the node in the tree */\n};\n\n/**\n * xmlParserError:\n *\n * This is an error that the XML (or HTML) parser can generate\n */\ntypedef enum {\n    XML_ERR_OK = 0,\n    XML_ERR_INTERNAL_ERROR, /* 1 */\n    XML_ERR_NO_MEMORY, /* 2 */\n    XML_ERR_DOCUMENT_START, /* 3 */\n    XML_ERR_DOCUMENT_EMPTY, /* 4 */\n    XML_ERR_DOCUMENT_END, /* 5 */\n    XML_ERR_INVALID_HEX_CHARREF, /* 6 */\n    XML_ERR_INVALID_DEC_CHARREF, /* 7 */\n    XML_ERR_INVALID_CHARREF, /* 8 */\n    XML_ERR_INVALID_CHAR, /* 9 */\n    XML_ERR_CHARREF_AT_EOF, /* 10 */\n    XML_ERR_CHARREF_IN_PROLOG, /* 11 */\n    XML_ERR_CHARREF_IN_EPILOG, /* 12 */\n    XML_ERR_CHARREF_IN_DTD, /* 13 */\n    XML_ERR_ENTITYREF_AT_EOF, /* 14 */\n    XML_ERR_ENTITYREF_IN_PROLOG, /* 15 */\n    XML_ERR_ENTITYREF_IN_EPILOG, /* 16 */\n    XML_ERR_ENTITYREF_IN_DTD, /* 17 */\n    XML_ERR_PEREF_AT_EOF, /* 18 */\n    XML_ERR_PEREF_IN_PROLOG, /* 19 */\n    XML_ERR_PEREF_IN_EPILOG, /* 20 */\n    XML_ERR_PEREF_IN_INT_SUBSET, /* 21 */\n    XML_ERR_ENTITYREF_NO_NAME, /* 22 */\n    XML_ERR_ENTITYREF_SEMICOL_MISSING, /* 23 */\n    XML_ERR_PEREF_NO_NAME, /* 24 */\n    XML_ERR_PEREF_SEMICOL_MISSING, /* 25 */\n    XML_ERR_UNDECLARED_ENTITY, /* 26 */\n    XML_WAR_UNDECLARED_ENTITY, /* 27 */\n    XML_ERR_UNPARSED_ENTITY, /* 28 */\n    XML_ERR_ENTITY_IS_EXTERNAL, /* 29 */\n    XML_ERR_ENTITY_IS_PARAMETER, /* 30 */\n    XML_ERR_UNKNOWN_ENCODING, /* 31 */\n    XML_ERR_UNSUPPORTED_ENCODING, /* 32 */\n    XML_ERR_STRING_NOT_STARTED, /* 33 */\n    XML_ERR_STRING_NOT_CLOSED, /* 34 */\n    XML_ERR_NS_DECL_ERROR, /* 35 */\n    XML_ERR_ENTITY_NOT_STARTED, /* 36 */\n    XML_ERR_ENTITY_NOT_FINISHED, /* 37 */\n    XML_ERR_LT_IN_ATTRIBUTE, /* 38 */\n    XML_ERR_ATTRIBUTE_NOT_STARTED, /* 39 */\n    XML_ERR_ATTRIBUTE_NOT_FINISHED, /* 40 */\n    XML_ERR_ATTRIBUTE_WITHOUT_VALUE, /* 41 */\n    XML_ERR_ATTRIBUTE_REDEFINED, /* 42 */\n    XML_ERR_LITERAL_NOT_STARTED, /* 43 */\n    XML_ERR_LITERAL_NOT_FINISHED, /* 44 */\n    XML_ERR_COMMENT_NOT_FINISHED, /* 45 */\n    XML_ERR_PI_NOT_STARTED, /* 46 */\n    XML_ERR_PI_NOT_FINISHED, /* 47 */\n    XML_ERR_NOTATION_NOT_STARTED, /* 48 */\n    XML_ERR_NOTATION_NOT_FINISHED, /* 49 */\n    XML_ERR_ATTLIST_NOT_STARTED, /* 50 */\n    XML_ERR_ATTLIST_NOT_FINISHED, /* 51 */\n    XML_ERR_MIXED_NOT_STARTED, /* 52 */\n    XML_ERR_MIXED_NOT_FINISHED, /* 53 */\n    XML_ERR_ELEMCONTENT_NOT_STARTED, /* 54 */\n    XML_ERR_ELEMCONTENT_NOT_FINISHED, /* 55 */\n    XML_ERR_XMLDECL_NOT_STARTED, /* 56 */\n    XML_ERR_XMLDECL_NOT_FINISHED, /* 57 */\n    XML_ERR_CONDSEC_NOT_STARTED, /* 58 */\n    XML_ERR_CONDSEC_NOT_FINISHED, /* 59 */\n    XML_ERR_EXT_SUBSET_NOT_FINISHED, /* 60 */\n    XML_ERR_DOCTYPE_NOT_FINISHED, /* 61 */\n    XML_ERR_MISPLACED_CDATA_END, /* 62 */\n    XML_ERR_CDATA_NOT_FINISHED, /* 63 */\n    XML_ERR_RESERVED_XML_NAME, /* 64 */\n    XML_ERR_SPACE_REQUIRED, /* 65 */\n    XML_ERR_SEPARATOR_REQUIRED, /* 66 */\n    XML_ERR_NMTOKEN_REQUIRED, /* 67 */\n    XML_ERR_NAME_REQUIRED, /* 68 */\n    XML_ERR_PCDATA_REQUIRED, /* 69 */\n    XML_ERR_URI_REQUIRED, /* 70 */\n    XML_ERR_PUBID_REQUIRED, /* 71 */\n    XML_ERR_LT_REQUIRED, /* 72 */\n    XML_ERR_GT_REQUIRED, /* 73 */\n    XML_ERR_LTSLASH_REQUIRED, /* 74 */\n    XML_ERR_EQUAL_REQUIRED, /* 75 */\n    XML_ERR_TAG_NAME_MISMATCH, /* 76 */\n    XML_ERR_TAG_NOT_FINISHED, /* 77 */\n    XML_ERR_STANDALONE_VALUE, /* 78 */\n    XML_ERR_ENCODING_NAME, /* 79 */\n    XML_ERR_HYPHEN_IN_COMMENT, /* 80 */\n    XML_ERR_INVALID_ENCODING, /* 81 */\n    XML_ERR_EXT_ENTITY_STANDALONE, /* 82 */\n    XML_ERR_CONDSEC_INVALID, /* 83 */\n    XML_ERR_VALUE_REQUIRED, /* 84 */\n    XML_ERR_NOT_WELL_BALANCED, /* 85 */\n    XML_ERR_EXTRA_CONTENT, /* 86 */\n    XML_ERR_ENTITY_CHAR_ERROR, /* 87 */\n    XML_ERR_ENTITY_PE_INTERNAL, /* 88 */\n    XML_ERR_ENTITY_LOOP, /* 89 */\n    XML_ERR_ENTITY_BOUNDARY, /* 90 */\n    XML_ERR_INVALID_URI, /* 91 */\n    XML_ERR_URI_FRAGMENT, /* 92 */\n    XML_WAR_CATALOG_PI, /* 93 */\n    XML_ERR_NO_DTD, /* 94 */\n    XML_ERR_CONDSEC_INVALID_KEYWORD, /* 95 */\n    XML_ERR_VERSION_MISSING, /* 96 */\n    XML_WAR_UNKNOWN_VERSION, /* 97 */\n    XML_WAR_LANG_VALUE, /* 98 */\n    XML_WAR_NS_URI, /* 99 */\n    XML_WAR_NS_URI_RELATIVE, /* 100 */\n    XML_ERR_MISSING_ENCODING, /* 101 */\n    XML_WAR_SPACE_VALUE, /* 102 */\n    XML_ERR_NOT_STANDALONE, /* 103 */\n    XML_ERR_ENTITY_PROCESSING, /* 104 */\n    XML_ERR_NOTATION_PROCESSING, /* 105 */\n    XML_WAR_NS_COLUMN, /* 106 */\n    XML_WAR_ENTITY_REDEFINED, /* 107 */\n    XML_ERR_UNKNOWN_VERSION, /* 108 */\n    XML_ERR_VERSION_MISMATCH, /* 109 */\n    XML_ERR_NAME_TOO_LONG, /* 110 */\n    XML_ERR_USER_STOP, /* 111 */\n    XML_NS_ERR_XML_NAMESPACE = 200,\n    XML_NS_ERR_UNDEFINED_NAMESPACE, /* 201 */\n    XML_NS_ERR_QNAME, /* 202 */\n    XML_NS_ERR_ATTRIBUTE_REDEFINED, /* 203 */\n    XML_NS_ERR_EMPTY, /* 204 */\n    XML_NS_ERR_COLON, /* 205 */\n    XML_DTD_ATTRIBUTE_DEFAULT = 500,\n    XML_DTD_ATTRIBUTE_REDEFINED, /* 501 */\n    XML_DTD_ATTRIBUTE_VALUE, /* 502 */\n    XML_DTD_CONTENT_ERROR, /* 503 */\n    XML_DTD_CONTENT_MODEL, /* 504 */\n    XML_DTD_CONTENT_NOT_DETERMINIST, /* 505 */\n    XML_DTD_DIFFERENT_PREFIX, /* 506 */\n    XML_DTD_ELEM_DEFAULT_NAMESPACE, /* 507 */\n    XML_DTD_ELEM_NAMESPACE, /* 508 */\n    XML_DTD_ELEM_REDEFINED, /* 509 */\n    XML_DTD_EMPTY_NOTATION, /* 510 */\n    XML_DTD_ENTITY_TYPE, /* 511 */\n    XML_DTD_ID_FIXED, /* 512 */\n    XML_DTD_ID_REDEFINED, /* 513 */\n    XML_DTD_ID_SUBSET, /* 514 */\n    XML_DTD_INVALID_CHILD, /* 515 */\n    XML_DTD_INVALID_DEFAULT, /* 516 */\n    XML_DTD_LOAD_ERROR, /* 517 */\n    XML_DTD_MISSING_ATTRIBUTE, /* 518 */\n    XML_DTD_MIXED_CORRUPT, /* 519 */\n    XML_DTD_MULTIPLE_ID, /* 520 */\n    XML_DTD_NO_DOC, /* 521 */\n    XML_DTD_NO_DTD, /* 522 */\n    XML_DTD_NO_ELEM_NAME, /* 523 */\n    XML_DTD_NO_PREFIX, /* 524 */\n    XML_DTD_NO_ROOT, /* 525 */\n    XML_DTD_NOTATION_REDEFINED, /* 526 */\n    XML_DTD_NOTATION_VALUE, /* 527 */\n    XML_DTD_NOT_EMPTY, /* 528 */\n    XML_DTD_NOT_PCDATA, /* 529 */\n    XML_DTD_NOT_STANDALONE, /* 530 */\n    XML_DTD_ROOT_NAME, /* 531 */\n    XML_DTD_STANDALONE_WHITE_SPACE, /* 532 */\n    XML_DTD_UNKNOWN_ATTRIBUTE, /* 533 */\n    XML_DTD_UNKNOWN_ELEM, /* 534 */\n    XML_DTD_UNKNOWN_ENTITY, /* 535 */\n    XML_DTD_UNKNOWN_ID, /* 536 */\n    XML_DTD_UNKNOWN_NOTATION, /* 537 */\n    XML_DTD_STANDALONE_DEFAULTED, /* 538 */\n    XML_DTD_XMLID_VALUE, /* 539 */\n    XML_DTD_XMLID_TYPE, /* 540 */\n    XML_DTD_DUP_TOKEN, /* 541 */\n    XML_HTML_STRUCURE_ERROR = 800,\n    XML_HTML_UNKNOWN_TAG, /* 801 */\n    XML_RNGP_ANYNAME_ATTR_ANCESTOR = 1000,\n    XML_RNGP_ATTR_CONFLICT, /* 1001 */\n    XML_RNGP_ATTRIBUTE_CHILDREN, /* 1002 */\n    XML_RNGP_ATTRIBUTE_CONTENT, /* 1003 */\n    XML_RNGP_ATTRIBUTE_EMPTY, /* 1004 */\n    XML_RNGP_ATTRIBUTE_NOOP, /* 1005 */\n    XML_RNGP_CHOICE_CONTENT, /* 1006 */\n    XML_RNGP_CHOICE_EMPTY, /* 1007 */\n    XML_RNGP_CREATE_FAILURE, /* 1008 */\n    XML_RNGP_DATA_CONTENT, /* 1009 */\n    XML_RNGP_DEF_CHOICE_AND_INTERLEAVE, /* 1010 */\n    XML_RNGP_DEFINE_CREATE_FAILED, /* 1011 */\n    XML_RNGP_DEFINE_EMPTY, /* 1012 */\n    XML_RNGP_DEFINE_MISSING, /* 1013 */\n    XML_RNGP_DEFINE_NAME_MISSING, /* 1014 */\n    XML_RNGP_ELEM_CONTENT_EMPTY, /* 1015 */\n    XML_RNGP_ELEM_CONTENT_ERROR, /* 1016 */\n    XML_RNGP_ELEMENT_EMPTY, /* 1017 */\n    XML_RNGP_ELEMENT_CONTENT, /* 1018 */\n    XML_RNGP_ELEMENT_NAME, /* 1019 */\n    XML_RNGP_ELEMENT_NO_CONTENT, /* 1020 */\n    XML_RNGP_ELEM_TEXT_CONFLICT, /* 1021 */\n    XML_RNGP_EMPTY, /* 1022 */\n    XML_RNGP_EMPTY_CONSTRUCT, /* 1023 */\n    XML_RNGP_EMPTY_CONTENT, /* 1024 */\n    XML_RNGP_EMPTY_NOT_EMPTY, /* 1025 */\n    XML_RNGP_ERROR_TYPE_LIB, /* 1026 */\n    XML_RNGP_EXCEPT_EMPTY, /* 1027 */\n    XML_RNGP_EXCEPT_MISSING, /* 1028 */\n    XML_RNGP_EXCEPT_MULTIPLE, /* 1029 */\n    XML_RNGP_EXCEPT_NO_CONTENT, /* 1030 */\n    XML_RNGP_EXTERNALREF_EMTPY, /* 1031 */\n    XML_RNGP_EXTERNAL_REF_FAILURE, /* 1032 */\n    XML_RNGP_EXTERNALREF_RECURSE, /* 1033 */\n    XML_RNGP_FORBIDDEN_ATTRIBUTE, /* 1034 */\n    XML_RNGP_FOREIGN_ELEMENT, /* 1035 */\n    XML_RNGP_GRAMMAR_CONTENT, /* 1036 */\n    XML_RNGP_GRAMMAR_EMPTY, /* 1037 */\n    XML_RNGP_GRAMMAR_MISSING, /* 1038 */\n    XML_RNGP_GRAMMAR_NO_START, /* 1039 */\n    XML_RNGP_GROUP_ATTR_CONFLICT, /* 1040 */\n    XML_RNGP_HREF_ERROR, /* 1041 */\n    XML_RNGP_INCLUDE_EMPTY, /* 1042 */\n    XML_RNGP_INCLUDE_FAILURE, /* 1043 */\n    XML_RNGP_INCLUDE_RECURSE, /* 1044 */\n    XML_RNGP_INTERLEAVE_ADD, /* 1045 */\n    XML_RNGP_INTERLEAVE_CREATE_FAILED, /* 1046 */\n    XML_RNGP_INTERLEAVE_EMPTY, /* 1047 */\n    XML_RNGP_INTERLEAVE_NO_CONTENT, /* 1048 */\n    XML_RNGP_INVALID_DEFINE_NAME, /* 1049 */\n    XML_RNGP_INVALID_URI, /* 1050 */\n    XML_RNGP_INVALID_VALUE, /* 1051 */\n    XML_RNGP_MISSING_HREF, /* 1052 */\n    XML_RNGP_NAME_MISSING, /* 1053 */\n    XML_RNGP_NEED_COMBINE, /* 1054 */\n    XML_RNGP_NOTALLOWED_NOT_EMPTY, /* 1055 */\n    XML_RNGP_NSNAME_ATTR_ANCESTOR, /* 1056 */\n    XML_RNGP_NSNAME_NO_NS, /* 1057 */\n    XML_RNGP_PARAM_FORBIDDEN, /* 1058 */\n    XML_RNGP_PARAM_NAME_MISSING, /* 1059 */\n    XML_RNGP_PARENTREF_CREATE_FAILED, /* 1060 */\n    XML_RNGP_PARENTREF_NAME_INVALID, /* 1061 */\n    XML_RNGP_PARENTREF_NO_NAME, /* 1062 */\n    XML_RNGP_PARENTREF_NO_PARENT, /* 1063 */\n    XML_RNGP_PARENTREF_NOT_EMPTY, /* 1064 */\n    XML_RNGP_PARSE_ERROR, /* 1065 */\n    XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME, /* 1066 */\n    XML_RNGP_PAT_ATTR_ATTR, /* 1067 */\n    XML_RNGP_PAT_ATTR_ELEM, /* 1068 */\n    XML_RNGP_PAT_DATA_EXCEPT_ATTR, /* 1069 */\n    XML_RNGP_PAT_DATA_EXCEPT_ELEM, /* 1070 */\n    XML_RNGP_PAT_DATA_EXCEPT_EMPTY, /* 1071 */\n    XML_RNGP_PAT_DATA_EXCEPT_GROUP, /* 1072 */\n    XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE, /* 1073 */\n    XML_RNGP_PAT_DATA_EXCEPT_LIST, /* 1074 */\n    XML_RNGP_PAT_DATA_EXCEPT_ONEMORE, /* 1075 */\n    XML_RNGP_PAT_DATA_EXCEPT_REF, /* 1076 */\n    XML_RNGP_PAT_DATA_EXCEPT_TEXT, /* 1077 */\n    XML_RNGP_PAT_LIST_ATTR, /* 1078 */\n    XML_RNGP_PAT_LIST_ELEM, /* 1079 */\n    XML_RNGP_PAT_LIST_INTERLEAVE, /* 1080 */\n    XML_RNGP_PAT_LIST_LIST, /* 1081 */\n    XML_RNGP_PAT_LIST_REF, /* 1082 */\n    XML_RNGP_PAT_LIST_TEXT, /* 1083 */\n    XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME, /* 1084 */\n    XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME, /* 1085 */\n    XML_RNGP_PAT_ONEMORE_GROUP_ATTR, /* 1086 */\n    XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR, /* 1087 */\n    XML_RNGP_PAT_START_ATTR, /* 1088 */\n    XML_RNGP_PAT_START_DATA, /* 1089 */\n    XML_RNGP_PAT_START_EMPTY, /* 1090 */\n    XML_RNGP_PAT_START_GROUP, /* 1091 */\n    XML_RNGP_PAT_START_INTERLEAVE, /* 1092 */\n    XML_RNGP_PAT_START_LIST, /* 1093 */\n    XML_RNGP_PAT_START_ONEMORE, /* 1094 */\n    XML_RNGP_PAT_START_TEXT, /* 1095 */\n    XML_RNGP_PAT_START_VALUE, /* 1096 */\n    XML_RNGP_PREFIX_UNDEFINED, /* 1097 */\n    XML_RNGP_REF_CREATE_FAILED, /* 1098 */\n    XML_RNGP_REF_CYCLE, /* 1099 */\n    XML_RNGP_REF_NAME_INVALID, /* 1100 */\n    XML_RNGP_REF_NO_DEF, /* 1101 */\n    XML_RNGP_REF_NO_NAME, /* 1102 */\n    XML_RNGP_REF_NOT_EMPTY, /* 1103 */\n    XML_RNGP_START_CHOICE_AND_INTERLEAVE, /* 1104 */\n    XML_RNGP_START_CONTENT, /* 1105 */\n    XML_RNGP_START_EMPTY, /* 1106 */\n    XML_RNGP_START_MISSING, /* 1107 */\n    XML_RNGP_TEXT_EXPECTED, /* 1108 */\n    XML_RNGP_TEXT_HAS_CHILD, /* 1109 */\n    XML_RNGP_TYPE_MISSING, /* 1110 */\n    XML_RNGP_TYPE_NOT_FOUND, /* 1111 */\n    XML_RNGP_TYPE_VALUE, /* 1112 */\n    XML_RNGP_UNKNOWN_ATTRIBUTE, /* 1113 */\n    XML_RNGP_UNKNOWN_COMBINE, /* 1114 */\n    XML_RNGP_UNKNOWN_CONSTRUCT, /* 1115 */\n    XML_RNGP_UNKNOWN_TYPE_LIB, /* 1116 */\n    XML_RNGP_URI_FRAGMENT, /* 1117 */\n    XML_RNGP_URI_NOT_ABSOLUTE, /* 1118 */\n    XML_RNGP_VALUE_EMPTY, /* 1119 */\n    XML_RNGP_VALUE_NO_CONTENT, /* 1120 */\n    XML_RNGP_XMLNS_NAME, /* 1121 */\n    XML_RNGP_XML_NS, /* 1122 */\n    XML_XPATH_EXPRESSION_OK = 1200,\n    XML_XPATH_NUMBER_ERROR, /* 1201 */\n    XML_XPATH_UNFINISHED_LITERAL_ERROR, /* 1202 */\n    XML_XPATH_START_LITERAL_ERROR, /* 1203 */\n    XML_XPATH_VARIABLE_REF_ERROR, /* 1204 */\n    XML_XPATH_UNDEF_VARIABLE_ERROR, /* 1205 */\n    XML_XPATH_INVALID_PREDICATE_ERROR, /* 1206 */\n    XML_XPATH_EXPR_ERROR, /* 1207 */\n    XML_XPATH_UNCLOSED_ERROR, /* 1208 */\n    XML_XPATH_UNKNOWN_FUNC_ERROR, /* 1209 */\n    XML_XPATH_INVALID_OPERAND, /* 1210 */\n    XML_XPATH_INVALID_TYPE, /* 1211 */\n    XML_XPATH_INVALID_ARITY, /* 1212 */\n    XML_XPATH_INVALID_CTXT_SIZE, /* 1213 */\n    XML_XPATH_INVALID_CTXT_POSITION, /* 1214 */\n    XML_XPATH_MEMORY_ERROR, /* 1215 */\n    XML_XPTR_SYNTAX_ERROR, /* 1216 */\n    XML_XPTR_RESOURCE_ERROR, /* 1217 */\n    XML_XPTR_SUB_RESOURCE_ERROR, /* 1218 */\n    XML_XPATH_UNDEF_PREFIX_ERROR, /* 1219 */\n    XML_XPATH_ENCODING_ERROR, /* 1220 */\n    XML_XPATH_INVALID_CHAR_ERROR, /* 1221 */\n    XML_TREE_INVALID_HEX = 1300,\n    XML_TREE_INVALID_DEC, /* 1301 */\n    XML_TREE_UNTERMINATED_ENTITY, /* 1302 */\n    XML_TREE_NOT_UTF8, /* 1303 */\n    XML_SAVE_NOT_UTF8 = 1400,\n    XML_SAVE_CHAR_INVALID, /* 1401 */\n    XML_SAVE_NO_DOCTYPE, /* 1402 */\n    XML_SAVE_UNKNOWN_ENCODING, /* 1403 */\n    XML_REGEXP_COMPILE_ERROR = 1450,\n    XML_IO_UNKNOWN = 1500,\n    XML_IO_EACCES, /* 1501 */\n    XML_IO_EAGAIN, /* 1502 */\n    XML_IO_EBADF, /* 1503 */\n    XML_IO_EBADMSG, /* 1504 */\n    XML_IO_EBUSY, /* 1505 */\n    XML_IO_ECANCELED, /* 1506 */\n    XML_IO_ECHILD, /* 1507 */\n    XML_IO_EDEADLK, /* 1508 */\n    XML_IO_EDOM, /* 1509 */\n    XML_IO_EEXIST, /* 1510 */\n    XML_IO_EFAULT, /* 1511 */\n    XML_IO_EFBIG, /* 1512 */\n    XML_IO_EINPROGRESS, /* 1513 */\n    XML_IO_EINTR, /* 1514 */\n    XML_IO_EINVAL, /* 1515 */\n    XML_IO_EIO, /* 1516 */\n    XML_IO_EISDIR, /* 1517 */\n    XML_IO_EMFILE, /* 1518 */\n    XML_IO_EMLINK, /* 1519 */\n    XML_IO_EMSGSIZE, /* 1520 */\n    XML_IO_ENAMETOOLONG, /* 1521 */\n    XML_IO_ENFILE, /* 1522 */\n    XML_IO_ENODEV, /* 1523 */\n    XML_IO_ENOENT, /* 1524 */\n    XML_IO_ENOEXEC, /* 1525 */\n    XML_IO_ENOLCK, /* 1526 */\n    XML_IO_ENOMEM, /* 1527 */\n    XML_IO_ENOSPC, /* 1528 */\n    XML_IO_ENOSYS, /* 1529 */\n    XML_IO_ENOTDIR, /* 1530 */\n    XML_IO_ENOTEMPTY, /* 1531 */\n    XML_IO_ENOTSUP, /* 1532 */\n    XML_IO_ENOTTY, /* 1533 */\n    XML_IO_ENXIO, /* 1534 */\n    XML_IO_EPERM, /* 1535 */\n    XML_IO_EPIPE, /* 1536 */\n    XML_IO_ERANGE, /* 1537 */\n    XML_IO_EROFS, /* 1538 */\n    XML_IO_ESPIPE, /* 1539 */\n    XML_IO_ESRCH, /* 1540 */\n    XML_IO_ETIMEDOUT, /* 1541 */\n    XML_IO_EXDEV, /* 1542 */\n    XML_IO_NETWORK_ATTEMPT, /* 1543 */\n    XML_IO_ENCODER, /* 1544 */\n    XML_IO_FLUSH, /* 1545 */\n    XML_IO_WRITE, /* 1546 */\n    XML_IO_NO_INPUT, /* 1547 */\n    XML_IO_BUFFER_FULL, /* 1548 */\n    XML_IO_LOAD_ERROR, /* 1549 */\n    XML_IO_ENOTSOCK, /* 1550 */\n    XML_IO_EISCONN, /* 1551 */\n    XML_IO_ECONNREFUSED, /* 1552 */\n    XML_IO_ENETUNREACH, /* 1553 */\n    XML_IO_EADDRINUSE, /* 1554 */\n    XML_IO_EALREADY, /* 1555 */\n    XML_IO_EAFNOSUPPORT, /* 1556 */\n    XML_XINCLUDE_RECURSION=1600,\n    XML_XINCLUDE_PARSE_VALUE, /* 1601 */\n    XML_XINCLUDE_ENTITY_DEF_MISMATCH, /* 1602 */\n    XML_XINCLUDE_NO_HREF, /* 1603 */\n    XML_XINCLUDE_NO_FALLBACK, /* 1604 */\n    XML_XINCLUDE_HREF_URI, /* 1605 */\n    XML_XINCLUDE_TEXT_FRAGMENT, /* 1606 */\n    XML_XINCLUDE_TEXT_DOCUMENT, /* 1607 */\n    XML_XINCLUDE_INVALID_CHAR, /* 1608 */\n    XML_XINCLUDE_BUILD_FAILED, /* 1609 */\n    XML_XINCLUDE_UNKNOWN_ENCODING, /* 1610 */\n    XML_XINCLUDE_MULTIPLE_ROOT, /* 1611 */\n    XML_XINCLUDE_XPTR_FAILED, /* 1612 */\n    XML_XINCLUDE_XPTR_RESULT, /* 1613 */\n    XML_XINCLUDE_INCLUDE_IN_INCLUDE, /* 1614 */\n    XML_XINCLUDE_FALLBACKS_IN_INCLUDE, /* 1615 */\n    XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE, /* 1616 */\n    XML_XINCLUDE_DEPRECATED_NS, /* 1617 */\n    XML_XINCLUDE_FRAGMENT_ID, /* 1618 */\n    XML_CATALOG_MISSING_ATTR = 1650,\n    XML_CATALOG_ENTRY_BROKEN, /* 1651 */\n    XML_CATALOG_PREFER_VALUE, /* 1652 */\n    XML_CATALOG_NOT_CATALOG, /* 1653 */\n    XML_CATALOG_RECURSION, /* 1654 */\n    XML_SCHEMAP_PREFIX_UNDEFINED = 1700,\n    XML_SCHEMAP_ATTRFORMDEFAULT_VALUE, /* 1701 */\n    XML_SCHEMAP_ATTRGRP_NONAME_NOREF, /* 1702 */\n    XML_SCHEMAP_ATTR_NONAME_NOREF, /* 1703 */\n    XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF, /* 1704 */\n    XML_SCHEMAP_ELEMFORMDEFAULT_VALUE, /* 1705 */\n    XML_SCHEMAP_ELEM_NONAME_NOREF, /* 1706 */\n    XML_SCHEMAP_EXTENSION_NO_BASE, /* 1707 */\n    XML_SCHEMAP_FACET_NO_VALUE, /* 1708 */\n    XML_SCHEMAP_FAILED_BUILD_IMPORT, /* 1709 */\n    XML_SCHEMAP_GROUP_NONAME_NOREF, /* 1710 */\n    XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI, /* 1711 */\n    XML_SCHEMAP_IMPORT_REDEFINE_NSNAME, /* 1712 */\n    XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI, /* 1713 */\n    XML_SCHEMAP_INVALID_BOOLEAN, /* 1714 */\n    XML_SCHEMAP_INVALID_ENUM, /* 1715 */\n    XML_SCHEMAP_INVALID_FACET, /* 1716 */\n    XML_SCHEMAP_INVALID_FACET_VALUE, /* 1717 */\n    XML_SCHEMAP_INVALID_MAXOCCURS, /* 1718 */\n    XML_SCHEMAP_INVALID_MINOCCURS, /* 1719 */\n    XML_SCHEMAP_INVALID_REF_AND_SUBTYPE, /* 1720 */\n    XML_SCHEMAP_INVALID_WHITE_SPACE, /* 1721 */\n    XML_SCHEMAP_NOATTR_NOREF, /* 1722 */\n    XML_SCHEMAP_NOTATION_NO_NAME, /* 1723 */\n    XML_SCHEMAP_NOTYPE_NOREF, /* 1724 */\n    XML_SCHEMAP_REF_AND_SUBTYPE, /* 1725 */\n    XML_SCHEMAP_RESTRICTION_NONAME_NOREF, /* 1726 */\n    XML_SCHEMAP_SIMPLETYPE_NONAME, /* 1727 */\n    XML_SCHEMAP_TYPE_AND_SUBTYPE, /* 1728 */\n    XML_SCHEMAP_UNKNOWN_ALL_CHILD, /* 1729 */\n    XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD, /* 1730 */\n    XML_SCHEMAP_UNKNOWN_ATTR_CHILD, /* 1731 */\n    XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD, /* 1732 */\n    XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP, /* 1733 */\n    XML_SCHEMAP_UNKNOWN_BASE_TYPE, /* 1734 */\n    XML_SCHEMAP_UNKNOWN_CHOICE_CHILD, /* 1735 */\n    XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD, /* 1736 */\n    XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD, /* 1737 */\n    XML_SCHEMAP_UNKNOWN_ELEM_CHILD, /* 1738 */\n    XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD, /* 1739 */\n    XML_SCHEMAP_UNKNOWN_FACET_CHILD, /* 1740 */\n    XML_SCHEMAP_UNKNOWN_FACET_TYPE, /* 1741 */\n    XML_SCHEMAP_UNKNOWN_GROUP_CHILD, /* 1742 */\n    XML_SCHEMAP_UNKNOWN_IMPORT_CHILD, /* 1743 */\n    XML_SCHEMAP_UNKNOWN_LIST_CHILD, /* 1744 */\n    XML_SCHEMAP_UNKNOWN_NOTATION_CHILD, /* 1745 */\n    XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD, /* 1746 */\n    XML_SCHEMAP_UNKNOWN_REF, /* 1747 */\n    XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD, /* 1748 */\n    XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD, /* 1749 */\n    XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD, /* 1750 */\n    XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD, /* 1751 */\n    XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD, /* 1752 */\n    XML_SCHEMAP_UNKNOWN_TYPE, /* 1753 */\n    XML_SCHEMAP_UNKNOWN_UNION_CHILD, /* 1754 */\n    XML_SCHEMAP_ELEM_DEFAULT_FIXED, /* 1755 */\n    XML_SCHEMAP_REGEXP_INVALID, /* 1756 */\n    XML_SCHEMAP_FAILED_LOAD, /* 1757 */\n    XML_SCHEMAP_NOTHING_TO_PARSE, /* 1758 */\n    XML_SCHEMAP_NOROOT, /* 1759 */\n    XML_SCHEMAP_REDEFINED_GROUP, /* 1760 */\n    XML_SCHEMAP_REDEFINED_TYPE, /* 1761 */\n    XML_SCHEMAP_REDEFINED_ELEMENT, /* 1762 */\n    XML_SCHEMAP_REDEFINED_ATTRGROUP, /* 1763 */\n    XML_SCHEMAP_REDEFINED_ATTR, /* 1764 */\n    XML_SCHEMAP_REDEFINED_NOTATION, /* 1765 */\n    XML_SCHEMAP_FAILED_PARSE, /* 1766 */\n    XML_SCHEMAP_UNKNOWN_PREFIX, /* 1767 */\n    XML_SCHEMAP_DEF_AND_PREFIX, /* 1768 */\n    XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD, /* 1769 */\n    XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI, /* 1770 */\n    XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI, /* 1771 */\n    XML_SCHEMAP_NOT_SCHEMA, /* 1772 */\n    XML_SCHEMAP_UNKNOWN_MEMBER_TYPE, /* 1773 */\n    XML_SCHEMAP_INVALID_ATTR_USE, /* 1774 */\n    XML_SCHEMAP_RECURSIVE, /* 1775 */\n    XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE, /* 1776 */\n    XML_SCHEMAP_INVALID_ATTR_COMBINATION, /* 1777 */\n    XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION, /* 1778 */\n    XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD, /* 1779 */\n    XML_SCHEMAP_INVALID_ATTR_NAME, /* 1780 */\n    XML_SCHEMAP_REF_AND_CONTENT, /* 1781 */\n    XML_SCHEMAP_CT_PROPS_CORRECT_1, /* 1782 */\n    XML_SCHEMAP_CT_PROPS_CORRECT_2, /* 1783 */\n    XML_SCHEMAP_CT_PROPS_CORRECT_3, /* 1784 */\n    XML_SCHEMAP_CT_PROPS_CORRECT_4, /* 1785 */\n    XML_SCHEMAP_CT_PROPS_CORRECT_5, /* 1786 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1, /* 1787 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1, /* 1788 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2, /* 1789 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2, /* 1790 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3, /* 1791 */\n    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER, /* 1792 */\n    XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE, /* 1793 */\n    XML_SCHEMAP_UNION_NOT_EXPRESSIBLE, /* 1794 */\n    XML_SCHEMAP_SRC_IMPORT_3_1, /* 1795 */\n    XML_SCHEMAP_SRC_IMPORT_3_2, /* 1796 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1, /* 1797 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2, /* 1798 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3, /* 1799 */\n    XML_SCHEMAP_COS_CT_EXTENDS_1_3, /* 1800 */\n    XML_SCHEMAV_NOROOT = 1801,\n    XML_SCHEMAV_UNDECLAREDELEM, /* 1802 */\n    XML_SCHEMAV_NOTTOPLEVEL, /* 1803 */\n    XML_SCHEMAV_MISSING, /* 1804 */\n    XML_SCHEMAV_WRONGELEM, /* 1805 */\n    XML_SCHEMAV_NOTYPE, /* 1806 */\n    XML_SCHEMAV_NOROLLBACK, /* 1807 */\n    XML_SCHEMAV_ISABSTRACT, /* 1808 */\n    XML_SCHEMAV_NOTEMPTY, /* 1809 */\n    XML_SCHEMAV_ELEMCONT, /* 1810 */\n    XML_SCHEMAV_HAVEDEFAULT, /* 1811 */\n    XML_SCHEMAV_NOTNILLABLE, /* 1812 */\n    XML_SCHEMAV_EXTRACONTENT, /* 1813 */\n    XML_SCHEMAV_INVALIDATTR, /* 1814 */\n    XML_SCHEMAV_INVALIDELEM, /* 1815 */\n    XML_SCHEMAV_NOTDETERMINIST, /* 1816 */\n    XML_SCHEMAV_CONSTRUCT, /* 1817 */\n    XML_SCHEMAV_INTERNAL, /* 1818 */\n    XML_SCHEMAV_NOTSIMPLE, /* 1819 */\n    XML_SCHEMAV_ATTRUNKNOWN, /* 1820 */\n    XML_SCHEMAV_ATTRINVALID, /* 1821 */\n    XML_SCHEMAV_VALUE, /* 1822 */\n    XML_SCHEMAV_FACET, /* 1823 */\n    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1, /* 1824 */\n    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2, /* 1825 */\n    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3, /* 1826 */\n    XML_SCHEMAV_CVC_TYPE_3_1_1, /* 1827 */\n    XML_SCHEMAV_CVC_TYPE_3_1_2, /* 1828 */\n    XML_SCHEMAV_CVC_FACET_VALID, /* 1829 */\n    XML_SCHEMAV_CVC_LENGTH_VALID, /* 1830 */\n    XML_SCHEMAV_CVC_MINLENGTH_VALID, /* 1831 */\n    XML_SCHEMAV_CVC_MAXLENGTH_VALID, /* 1832 */\n    XML_SCHEMAV_CVC_MININCLUSIVE_VALID, /* 1833 */\n    XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID, /* 1834 */\n    XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID, /* 1835 */\n    XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID, /* 1836 */\n    XML_SCHEMAV_CVC_TOTALDIGITS_VALID, /* 1837 */\n    XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID, /* 1838 */\n    XML_SCHEMAV_CVC_PATTERN_VALID, /* 1839 */\n    XML_SCHEMAV_CVC_ENUMERATION_VALID, /* 1840 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1, /* 1841 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2, /* 1842 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3, /* 1843 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4, /* 1844 */\n    XML_SCHEMAV_CVC_ELT_1, /* 1845 */\n    XML_SCHEMAV_CVC_ELT_2, /* 1846 */\n    XML_SCHEMAV_CVC_ELT_3_1, /* 1847 */\n    XML_SCHEMAV_CVC_ELT_3_2_1, /* 1848 */\n    XML_SCHEMAV_CVC_ELT_3_2_2, /* 1849 */\n    XML_SCHEMAV_CVC_ELT_4_1, /* 1850 */\n    XML_SCHEMAV_CVC_ELT_4_2, /* 1851 */\n    XML_SCHEMAV_CVC_ELT_4_3, /* 1852 */\n    XML_SCHEMAV_CVC_ELT_5_1_1, /* 1853 */\n    XML_SCHEMAV_CVC_ELT_5_1_2, /* 1854 */\n    XML_SCHEMAV_CVC_ELT_5_2_1, /* 1855 */\n    XML_SCHEMAV_CVC_ELT_5_2_2_1, /* 1856 */\n    XML_SCHEMAV_CVC_ELT_5_2_2_2_1, /* 1857 */\n    XML_SCHEMAV_CVC_ELT_5_2_2_2_2, /* 1858 */\n    XML_SCHEMAV_CVC_ELT_6, /* 1859 */\n    XML_SCHEMAV_CVC_ELT_7, /* 1860 */\n    XML_SCHEMAV_CVC_ATTRIBUTE_1, /* 1861 */\n    XML_SCHEMAV_CVC_ATTRIBUTE_2, /* 1862 */\n    XML_SCHEMAV_CVC_ATTRIBUTE_3, /* 1863 */\n    XML_SCHEMAV_CVC_ATTRIBUTE_4, /* 1864 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1, /* 1865 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1, /* 1866 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2, /* 1867 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_4, /* 1868 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1, /* 1869 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2, /* 1870 */\n    XML_SCHEMAV_ELEMENT_CONTENT, /* 1871 */\n    XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING, /* 1872 */\n    XML_SCHEMAV_CVC_COMPLEX_TYPE_1, /* 1873 */\n    XML_SCHEMAV_CVC_AU, /* 1874 */\n    XML_SCHEMAV_CVC_TYPE_1, /* 1875 */\n    XML_SCHEMAV_CVC_TYPE_2, /* 1876 */\n    XML_SCHEMAV_CVC_IDC, /* 1877 */\n    XML_SCHEMAV_CVC_WILDCARD, /* 1878 */\n    XML_SCHEMAV_MISC, /* 1879 */\n    XML_XPTR_UNKNOWN_SCHEME = 1900,\n    XML_XPTR_CHILDSEQ_START, /* 1901 */\n    XML_XPTR_EVAL_FAILED, /* 1902 */\n    XML_XPTR_EXTRA_OBJECTS, /* 1903 */\n    XML_C14N_CREATE_CTXT = 1950,\n    XML_C14N_REQUIRES_UTF8, /* 1951 */\n    XML_C14N_CREATE_STACK, /* 1952 */\n    XML_C14N_INVALID_NODE, /* 1953 */\n    XML_C14N_UNKNOW_NODE, /* 1954 */\n    XML_C14N_RELATIVE_NAMESPACE, /* 1955 */\n    XML_FTP_PASV_ANSWER = 2000,\n    XML_FTP_EPSV_ANSWER, /* 2001 */\n    XML_FTP_ACCNT, /* 2002 */\n    XML_FTP_URL_SYNTAX, /* 2003 */\n    XML_HTTP_URL_SYNTAX = 2020,\n    XML_HTTP_USE_IP, /* 2021 */\n    XML_HTTP_UNKNOWN_HOST, /* 2022 */\n    XML_SCHEMAP_SRC_SIMPLE_TYPE_1 = 3000,\n    XML_SCHEMAP_SRC_SIMPLE_TYPE_2, /* 3001 */\n    XML_SCHEMAP_SRC_SIMPLE_TYPE_3, /* 3002 */\n    XML_SCHEMAP_SRC_SIMPLE_TYPE_4, /* 3003 */\n    XML_SCHEMAP_SRC_RESOLVE, /* 3004 */\n    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE, /* 3005 */\n    XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE, /* 3006 */\n    XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES, /* 3007 */\n    XML_SCHEMAP_ST_PROPS_CORRECT_1, /* 3008 */\n    XML_SCHEMAP_ST_PROPS_CORRECT_2, /* 3009 */\n    XML_SCHEMAP_ST_PROPS_CORRECT_3, /* 3010 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_1_1, /* 3011 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_1_2, /* 3012 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1, /* 3013 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2, /* 3014 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_2_1, /* 3015 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1, /* 3016 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2, /* 3017 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1, /* 3018 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2, /* 3019 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3, /* 3020 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4, /* 3021 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5, /* 3022 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_3_1, /* 3023 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1, /* 3024 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2, /* 3025 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2, /* 3026 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1, /* 3027 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3, /* 3028 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4, /* 3029 */\n    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5, /* 3030 */\n    XML_SCHEMAP_COS_ST_DERIVED_OK_2_1, /* 3031 */\n    XML_SCHEMAP_COS_ST_DERIVED_OK_2_2, /* 3032 */\n    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED, /* 3033 */\n    XML_SCHEMAP_S4S_ELEM_MISSING, /* 3034 */\n    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, /* 3035 */\n    XML_SCHEMAP_S4S_ATTR_MISSING, /* 3036 */\n    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE, /* 3037 */\n    XML_SCHEMAP_SRC_ELEMENT_1, /* 3038 */\n    XML_SCHEMAP_SRC_ELEMENT_2_1, /* 3039 */\n    XML_SCHEMAP_SRC_ELEMENT_2_2, /* 3040 */\n    XML_SCHEMAP_SRC_ELEMENT_3, /* 3041 */\n    XML_SCHEMAP_P_PROPS_CORRECT_1, /* 3042 */\n    XML_SCHEMAP_P_PROPS_CORRECT_2_1, /* 3043 */\n    XML_SCHEMAP_P_PROPS_CORRECT_2_2, /* 3044 */\n    XML_SCHEMAP_E_PROPS_CORRECT_2, /* 3045 */\n    XML_SCHEMAP_E_PROPS_CORRECT_3, /* 3046 */\n    XML_SCHEMAP_E_PROPS_CORRECT_4, /* 3047 */\n    XML_SCHEMAP_E_PROPS_CORRECT_5, /* 3048 */\n    XML_SCHEMAP_E_PROPS_CORRECT_6, /* 3049 */\n    XML_SCHEMAP_SRC_INCLUDE, /* 3050 */\n    XML_SCHEMAP_SRC_ATTRIBUTE_1, /* 3051 */\n    XML_SCHEMAP_SRC_ATTRIBUTE_2, /* 3052 */\n    XML_SCHEMAP_SRC_ATTRIBUTE_3_1, /* 3053 */\n    XML_SCHEMAP_SRC_ATTRIBUTE_3_2, /* 3054 */\n    XML_SCHEMAP_SRC_ATTRIBUTE_4, /* 3055 */\n    XML_SCHEMAP_NO_XMLNS, /* 3056 */\n    XML_SCHEMAP_NO_XSI, /* 3057 */\n    XML_SCHEMAP_COS_VALID_DEFAULT_1, /* 3058 */\n    XML_SCHEMAP_COS_VALID_DEFAULT_2_1, /* 3059 */\n    XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1, /* 3060 */\n    XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2, /* 3061 */\n    XML_SCHEMAP_CVC_SIMPLE_TYPE, /* 3062 */\n    XML_SCHEMAP_COS_CT_EXTENDS_1_1, /* 3063 */\n    XML_SCHEMAP_SRC_IMPORT_1_1, /* 3064 */\n    XML_SCHEMAP_SRC_IMPORT_1_2, /* 3065 */\n    XML_SCHEMAP_SRC_IMPORT_2, /* 3066 */\n    XML_SCHEMAP_SRC_IMPORT_2_1, /* 3067 */\n    XML_SCHEMAP_SRC_IMPORT_2_2, /* 3068 */\n    XML_SCHEMAP_INTERNAL, /* 3069 non-W3C */\n    XML_SCHEMAP_NOT_DETERMINISTIC, /* 3070 non-W3C */\n    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1, /* 3071 */\n    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2, /* 3072 */\n    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3, /* 3073 */\n    XML_SCHEMAP_MG_PROPS_CORRECT_1, /* 3074 */\n    XML_SCHEMAP_MG_PROPS_CORRECT_2, /* 3075 */\n    XML_SCHEMAP_SRC_CT_1, /* 3076 */\n    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3, /* 3077 */\n    XML_SCHEMAP_AU_PROPS_CORRECT_2, /* 3078 */\n    XML_SCHEMAP_A_PROPS_CORRECT_2, /* 3079 */\n    XML_SCHEMAP_C_PROPS_CORRECT, /* 3080 */\n    XML_SCHEMAP_SRC_REDEFINE, /* 3081 */\n    XML_SCHEMAP_SRC_IMPORT, /* 3082 */\n    XML_SCHEMAP_WARN_SKIP_SCHEMA, /* 3083 */\n    XML_SCHEMAP_WARN_UNLOCATED_SCHEMA, /* 3084 */\n    XML_SCHEMAP_WARN_ATTR_REDECL_PROH, /* 3085 */\n    XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH, /* 3085 */\n    XML_SCHEMAP_AG_PROPS_CORRECT, /* 3086 */\n    XML_SCHEMAP_COS_CT_EXTENDS_1_2, /* 3087 */\n    XML_SCHEMAP_AU_PROPS_CORRECT, /* 3088 */\n    XML_SCHEMAP_A_PROPS_CORRECT_3, /* 3089 */\n    XML_SCHEMAP_COS_ALL_LIMITED, /* 3090 */\n    XML_SCHEMATRONV_ASSERT = 4000, /* 4000 */\n    XML_SCHEMATRONV_REPORT,\n    XML_MODULE_OPEN = 4900, /* 4900 */\n    XML_MODULE_CLOSE, /* 4901 */\n    XML_CHECK_FOUND_ELEMENT = 5000,\n    XML_CHECK_FOUND_ATTRIBUTE, /* 5001 */\n    XML_CHECK_FOUND_TEXT, /* 5002 */\n    XML_CHECK_FOUND_CDATA, /* 5003 */\n    XML_CHECK_FOUND_ENTITYREF, /* 5004 */\n    XML_CHECK_FOUND_ENTITY, /* 5005 */\n    XML_CHECK_FOUND_PI, /* 5006 */\n    XML_CHECK_FOUND_COMMENT, /* 5007 */\n    XML_CHECK_FOUND_DOCTYPE, /* 5008 */\n    XML_CHECK_FOUND_FRAGMENT, /* 5009 */\n    XML_CHECK_FOUND_NOTATION, /* 5010 */\n    XML_CHECK_UNKNOWN_NODE, /* 5011 */\n    XML_CHECK_ENTITY_TYPE, /* 5012 */\n    XML_CHECK_NO_PARENT, /* 5013 */\n    XML_CHECK_NO_DOC, /* 5014 */\n    XML_CHECK_NO_NAME, /* 5015 */\n    XML_CHECK_NO_ELEM, /* 5016 */\n    XML_CHECK_WRONG_DOC, /* 5017 */\n    XML_CHECK_NO_PREV, /* 5018 */\n    XML_CHECK_WRONG_PREV, /* 5019 */\n    XML_CHECK_NO_NEXT, /* 5020 */\n    XML_CHECK_WRONG_NEXT, /* 5021 */\n    XML_CHECK_NOT_DTD, /* 5022 */\n    XML_CHECK_NOT_ATTR, /* 5023 */\n    XML_CHECK_NOT_ATTR_DECL, /* 5024 */\n    XML_CHECK_NOT_ELEM_DECL, /* 5025 */\n    XML_CHECK_NOT_ENTITY_DECL, /* 5026 */\n    XML_CHECK_NOT_NS_DECL, /* 5027 */\n    XML_CHECK_NO_HREF, /* 5028 */\n    XML_CHECK_WRONG_PARENT,/* 5029 */\n    XML_CHECK_NS_SCOPE, /* 5030 */\n    XML_CHECK_NS_ANCESTOR, /* 5031 */\n    XML_CHECK_NOT_UTF8, /* 5032 */\n    XML_CHECK_NO_DICT, /* 5033 */\n    XML_CHECK_NOT_NCNAME, /* 5034 */\n    XML_CHECK_OUTSIDE_DICT, /* 5035 */\n    XML_CHECK_WRONG_NAME, /* 5036 */\n    XML_CHECK_NAME_NOT_NULL, /* 5037 */\n    XML_I18N_NO_NAME = 6000,\n    XML_I18N_NO_HANDLER, /* 6001 */\n    XML_I18N_EXCESS_HANDLER, /* 6002 */\n    XML_I18N_CONV_FAILED, /* 6003 */\n    XML_I18N_NO_OUTPUT, /* 6004 */\n    XML_BUF_OVERFLOW = 7000\n} xmlParserErrors;\n\n/**\n * xmlGenericErrorFunc:\n * @ctx:  a parsing context\n * @msg:  the message\n * @...:  the extra arguments of the varargs to format the message\n *\n * Signature of the function to use when there is an error and\n * no parsing or validity context available .\n */\ntypedef void (XMLCDECL *xmlGenericErrorFunc) (void *ctx,\n\t\t\t\t const char *msg,\n\t\t\t\t ...) LIBXML_ATTR_FORMAT(2,3);\n/**\n * xmlStructuredErrorFunc:\n * @userData:  user provided data for the error callback\n * @error:  the error being raised.\n *\n * Signature of the function to use when there is an error and\n * the module handles the new error reporting mechanism.\n */\ntypedef void (XMLCALL *xmlStructuredErrorFunc) (void *userData, xmlErrorPtr error);\n\n/*\n * Use the following function to reset the two global variables\n * xmlGenericError and xmlGenericErrorContext.\n */\nXMLPUBFUN void XMLCALL\n    xmlSetGenericErrorFunc\t(void *ctx,\n\t\t\t\t xmlGenericErrorFunc handler);\nXMLPUBFUN void XMLCALL\n    initGenericErrorDefaultFunc\t(xmlGenericErrorFunc *handler);\n\nXMLPUBFUN void XMLCALL\n    xmlSetStructuredErrorFunc\t(void *ctx,\n\t\t\t\t xmlStructuredErrorFunc handler);\n/*\n * Default message routines used by SAX and Valid context for error\n * and warning reporting.\n */\nXMLPUBFUN void XMLCDECL\n    xmlParserError\t\t(void *ctx,\n\t\t\t\t const char *msg,\n\t\t\t\t ...) LIBXML_ATTR_FORMAT(2,3);\nXMLPUBFUN void XMLCDECL\n    xmlParserWarning\t\t(void *ctx,\n\t\t\t\t const char *msg,\n\t\t\t\t ...) LIBXML_ATTR_FORMAT(2,3);\nXMLPUBFUN void XMLCDECL\n    xmlParserValidityError\t(void *ctx,\n\t\t\t\t const char *msg,\n\t\t\t\t ...) LIBXML_ATTR_FORMAT(2,3);\nXMLPUBFUN void XMLCDECL\n    xmlParserValidityWarning\t(void *ctx,\n\t\t\t\t const char *msg,\n\t\t\t\t ...) LIBXML_ATTR_FORMAT(2,3);\nXMLPUBFUN void XMLCALL\n    xmlParserPrintFileInfo\t(xmlParserInputPtr input);\nXMLPUBFUN void XMLCALL\n    xmlParserPrintFileContext\t(xmlParserInputPtr input);\n\n/*\n * Extended error information routines\n */\nXMLPUBFUN xmlErrorPtr XMLCALL\n    xmlGetLastError\t\t(void);\nXMLPUBFUN void XMLCALL\n    xmlResetLastError\t\t(void);\nXMLPUBFUN xmlErrorPtr XMLCALL\n    xmlCtxtGetLastError\t\t(void *ctx);\nXMLPUBFUN void XMLCALL\n    xmlCtxtResetLastError\t(void *ctx);\nXMLPUBFUN void XMLCALL\n    xmlResetError\t\t(xmlErrorPtr err);\nXMLPUBFUN int XMLCALL\n    xmlCopyError\t\t(xmlErrorPtr from,\n\t\t\t\t xmlErrorPtr to);\n\n#ifdef IN_LIBXML\n/*\n * Internal callback reporting routine\n */\nXMLPUBFUN void XMLCALL\n    __xmlRaiseError\t\t(xmlStructuredErrorFunc schannel,\n\t\t\t\t xmlGenericErrorFunc channel,\n\t\t\t\t void *data,\n                                 void *ctx,\n\t\t\t\t void *node,\n\t\t\t\t int domain,\n\t\t\t\t int code,\n\t\t\t\t xmlErrorLevel level,\n\t\t\t\t const char *file,\n\t\t\t\t int line,\n\t\t\t\t const char *str1,\n\t\t\t\t const char *str2,\n\t\t\t\t const char *str3,\n\t\t\t\t int int1,\n\t\t\t\t int col,\n\t\t\t\t const char *msg,\n\t\t\t\t ...) LIBXML_ATTR_FORMAT(16,17);\nXMLPUBFUN void XMLCALL\n    __xmlSimpleError\t\t(int domain,\n\t\t\t\t int code,\n\t\t\t\t xmlNodePtr node,\n\t\t\t\t const char *msg,\n\t\t\t\t const char *extra) LIBXML_ATTR_FORMAT(4,0);\n#endif\n#ifdef __cplusplus\n}\n#endif\n#endif /* __XML_ERROR_H__ */\n"}, "43": {"id": 43, "path": "/usr/include/libxml2/libxml/xmlexports.h", "content": "/*\n * Summary: macros for marking symbols as exportable/importable.\n * Description: macros for marking symbols as exportable/importable.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Igor Zlatovic <igor@zlatkovic.com>\n */\n\n#ifndef __XML_EXPORTS_H__\n#define __XML_EXPORTS_H__\n\n/**\n * XMLPUBFUN, XMLPUBVAR, XMLCALL\n *\n * Macros which declare an exportable function, an exportable variable and\n * the calling convention used for functions.\n *\n * Please use an extra block for every platform/compiler combination when\n * modifying this, rather than overlong #ifdef lines. This helps\n * readability as well as the fact that different compilers on the same\n * platform might need different definitions.\n */\n\n/**\n * XMLPUBFUN:\n *\n * Macros which declare an exportable function\n */\n#define XMLPUBFUN\n/**\n * XMLPUBVAR:\n *\n * Macros which declare an exportable variable\n */\n#define XMLPUBVAR extern\n/**\n * XMLCALL:\n *\n * Macros which declare the called convention for exported functions\n */\n#define XMLCALL\n/**\n * XMLCDECL:\n *\n * Macro which declares the calling convention for exported functions that\n * use '...'.\n */\n#define XMLCDECL\n\n/** DOC_DISABLE */\n\n/* Windows platform with MS compiler */\n#if defined(_WIN32) && defined(_MSC_VER)\n  #undef XMLPUBFUN\n  #undef XMLPUBVAR\n  #undef XMLCALL\n  #undef XMLCDECL\n  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)\n    #define XMLPUBFUN __declspec(dllexport)\n    #define XMLPUBVAR __declspec(dllexport)\n  #else\n    #define XMLPUBFUN\n    #if !defined(LIBXML_STATIC)\n      #define XMLPUBVAR __declspec(dllimport) extern\n    #else\n      #define XMLPUBVAR extern\n    #endif\n  #endif\n  #if defined(LIBXML_FASTCALL)\n    #define XMLCALL __fastcall\n  #else\n    #define XMLCALL __cdecl\n  #endif\n  #define XMLCDECL __cdecl\n#endif\n\n/* Windows platform with Borland compiler */\n#if defined(_WIN32) && defined(__BORLANDC__)\n  #undef XMLPUBFUN\n  #undef XMLPUBVAR\n  #undef XMLCALL\n  #undef XMLCDECL\n  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)\n    #define XMLPUBFUN __declspec(dllexport)\n    #define XMLPUBVAR __declspec(dllexport) extern\n  #else\n    #define XMLPUBFUN\n    #if !defined(LIBXML_STATIC)\n      #define XMLPUBVAR __declspec(dllimport) extern\n    #else\n      #define XMLPUBVAR extern\n    #endif\n  #endif\n  #define XMLCALL __cdecl\n  #define XMLCDECL __cdecl\n#endif\n\n/* Windows platform with GNU compiler (Mingw) */\n#if defined(_WIN32) && defined(__MINGW32__)\n  #undef XMLPUBFUN\n  #undef XMLPUBVAR\n  #undef XMLCALL\n  #undef XMLCDECL\n  /*\n   * if defined(IN_LIBXML) this raises problems on mingw with msys\n   * _imp__xmlFree listed as missing. Try to workaround the problem\n   * by also making that declaration when compiling client code.\n   */\n  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)\n    #define XMLPUBFUN __declspec(dllexport)\n    #define XMLPUBVAR __declspec(dllexport) extern\n  #else\n    #define XMLPUBFUN\n    #if !defined(LIBXML_STATIC)\n      #define XMLPUBVAR __declspec(dllimport) extern\n    #else\n      #define XMLPUBVAR extern\n    #endif\n  #endif\n  #define XMLCALL __cdecl\n  #define XMLCDECL __cdecl\n#endif\n\n/* Cygwin platform (does not define _WIN32), GNU compiler */\n#if defined(__CYGWIN__)\n  #undef XMLPUBFUN\n  #undef XMLPUBVAR\n  #undef XMLCALL\n  #undef XMLCDECL\n  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)\n    #define XMLPUBFUN __declspec(dllexport)\n    #define XMLPUBVAR __declspec(dllexport)\n  #else\n    #define XMLPUBFUN\n    #if !defined(LIBXML_STATIC)\n      #define XMLPUBVAR __declspec(dllimport) extern\n    #else\n      #define XMLPUBVAR extern\n    #endif\n  #endif\n  #define XMLCALL __cdecl\n  #define XMLCDECL __cdecl\n#endif\n\n/* Compatibility */\n#if !defined(LIBXML_DLL_IMPORT)\n#define LIBXML_DLL_IMPORT XMLPUBVAR\n#endif\n\n#endif /* __XML_EXPORTS_H__ */\n\n\n"}, "44": {"id": 44, "path": "/usr/include/libxml2/libxml/xmlmemory.h", "content": "/*\n * Summary: interface for the memory allocator\n * Description: provides interfaces for the memory allocator,\n *              including debugging capabilities.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n\n#ifndef __DEBUG_MEMORY_ALLOC__\n#define __DEBUG_MEMORY_ALLOC__\n\n#include <stdio.h>\n#include <libxml/xmlversion.h>\n\n/**\n * DEBUG_MEMORY:\n *\n * DEBUG_MEMORY replaces the allocator with a collect and debug\n * shell to the libc allocator.\n * DEBUG_MEMORY should only be activated when debugging\n * libxml i.e. if libxml has been configured with --with-debug-mem too.\n */\n/* #define DEBUG_MEMORY_FREED */\n/* #define DEBUG_MEMORY_LOCATION */\n\n#ifdef DEBUG\n#ifndef DEBUG_MEMORY\n#define DEBUG_MEMORY\n#endif\n#endif\n\n/**\n * DEBUG_MEMORY_LOCATION:\n *\n * DEBUG_MEMORY_LOCATION should be activated only when debugging\n * libxml i.e. if libxml has been configured with --with-debug-mem too.\n */\n#ifdef DEBUG_MEMORY_LOCATION\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * The XML memory wrapper support 4 basic overloadable functions.\n */\n/**\n * xmlFreeFunc:\n * @mem: an already allocated block of memory\n *\n * Signature for a free() implementation.\n */\ntypedef void (XMLCALL *xmlFreeFunc)(void *mem);\n/**\n * xmlMallocFunc:\n * @size:  the size requested in bytes\n *\n * Signature for a malloc() implementation.\n *\n * Returns a pointer to the newly allocated block or NULL in case of error.\n */\ntypedef void *(LIBXML_ATTR_ALLOC_SIZE(1) XMLCALL *xmlMallocFunc)(size_t size);\n\n/**\n * xmlReallocFunc:\n * @mem: an already allocated block of memory\n * @size:  the new size requested in bytes\n *\n * Signature for a realloc() implementation.\n *\n * Returns a pointer to the newly reallocated block or NULL in case of error.\n */\ntypedef void *(XMLCALL *xmlReallocFunc)(void *mem, size_t size);\n\n/**\n * xmlStrdupFunc:\n * @str: a zero terminated string\n *\n * Signature for an strdup() implementation.\n *\n * Returns the copy of the string or NULL in case of error.\n */\ntypedef char *(XMLCALL *xmlStrdupFunc)(const char *str);\n\n/*\n * The 4 interfaces used for all memory handling within libxml.\nLIBXML_DLL_IMPORT xmlFreeFunc xmlFree;\nLIBXML_DLL_IMPORT xmlMallocFunc xmlMalloc;\nLIBXML_DLL_IMPORT xmlMallocFunc xmlMallocAtomic;\nLIBXML_DLL_IMPORT xmlReallocFunc xmlRealloc;\nLIBXML_DLL_IMPORT xmlStrdupFunc xmlMemStrdup;\n */\n\n/*\n * The way to overload the existing functions.\n * The xmlGc function have an extra entry for atomic block\n * allocations useful for garbage collected memory allocators\n */\nXMLPUBFUN int XMLCALL\n\txmlMemSetup\t(xmlFreeFunc freeFunc,\n\t\t\t xmlMallocFunc mallocFunc,\n\t\t\t xmlReallocFunc reallocFunc,\n\t\t\t xmlStrdupFunc strdupFunc);\nXMLPUBFUN int XMLCALL\n\txmlMemGet\t(xmlFreeFunc *freeFunc,\n\t\t\t xmlMallocFunc *mallocFunc,\n\t\t\t xmlReallocFunc *reallocFunc,\n\t\t\t xmlStrdupFunc *strdupFunc);\nXMLPUBFUN int XMLCALL\n\txmlGcMemSetup\t(xmlFreeFunc freeFunc,\n\t\t\t xmlMallocFunc mallocFunc,\n\t\t\t xmlMallocFunc mallocAtomicFunc,\n\t\t\t xmlReallocFunc reallocFunc,\n\t\t\t xmlStrdupFunc strdupFunc);\nXMLPUBFUN int XMLCALL\n\txmlGcMemGet\t(xmlFreeFunc *freeFunc,\n\t\t\t xmlMallocFunc *mallocFunc,\n\t\t\t xmlMallocFunc *mallocAtomicFunc,\n\t\t\t xmlReallocFunc *reallocFunc,\n\t\t\t xmlStrdupFunc *strdupFunc);\n\n/*\n * Initialization of the memory layer.\n */\nXMLPUBFUN int XMLCALL\n\txmlInitMemory\t(void);\n\n/*\n * Cleanup of the memory layer.\n */\nXMLPUBFUN void XMLCALL\n                xmlCleanupMemory        (void);\n/*\n * These are specific to the XML debug memory wrapper.\n */\nXMLPUBFUN int XMLCALL\n\txmlMemUsed\t(void);\nXMLPUBFUN int XMLCALL\n\txmlMemBlocks\t(void);\nXMLPUBFUN void XMLCALL\n\txmlMemDisplay\t(FILE *fp);\nXMLPUBFUN void XMLCALL\n\txmlMemDisplayLast(FILE *fp, long nbBytes);\nXMLPUBFUN void XMLCALL\n\txmlMemShow\t(FILE *fp, int nr);\nXMLPUBFUN void XMLCALL\n\txmlMemoryDump\t(void);\nXMLPUBFUN void * XMLCALL\n\txmlMemMalloc\t(size_t size) LIBXML_ATTR_ALLOC_SIZE(1);\nXMLPUBFUN void * XMLCALL\n\txmlMemRealloc\t(void *ptr,size_t size);\nXMLPUBFUN void XMLCALL\n\txmlMemFree\t(void *ptr);\nXMLPUBFUN char * XMLCALL\n\txmlMemoryStrdup\t(const char *str);\nXMLPUBFUN void * XMLCALL\n\txmlMallocLoc\t(size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\nXMLPUBFUN void * XMLCALL\n\txmlReallocLoc\t(void *ptr, size_t size, const char *file, int line);\nXMLPUBFUN void * XMLCALL\n\txmlMallocAtomicLoc (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\nXMLPUBFUN char * XMLCALL\n\txmlMemStrdupLoc\t(const char *str, const char *file, int line);\n\n\n#ifdef DEBUG_MEMORY_LOCATION\n/**\n * xmlMalloc:\n * @size:  number of bytes to allocate\n *\n * Wrapper for the malloc() function used in the XML library.\n *\n * Returns the pointer to the allocated area or NULL in case of error.\n */\n#define xmlMalloc(size) xmlMallocLoc((size), __FILE__, __LINE__)\n/**\n * xmlMallocAtomic:\n * @size:  number of bytes to allocate\n *\n * Wrapper for the malloc() function used in the XML library for allocation\n * of block not containing pointers to other areas.\n *\n * Returns the pointer to the allocated area or NULL in case of error.\n */\n#define xmlMallocAtomic(size) xmlMallocAtomicLoc((size), __FILE__, __LINE__)\n/**\n * xmlRealloc:\n * @ptr:  pointer to the existing allocated area\n * @size:  number of bytes to allocate\n *\n * Wrapper for the realloc() function used in the XML library.\n *\n * Returns the pointer to the allocated area or NULL in case of error.\n */\n#define xmlRealloc(ptr, size) xmlReallocLoc((ptr), (size), __FILE__, __LINE__)\n/**\n * xmlMemStrdup:\n * @str:  pointer to the existing string\n *\n * Wrapper for the strdup() function, xmlStrdup() is usually preferred.\n *\n * Returns the pointer to the allocated area or NULL in case of error.\n */\n#define xmlMemStrdup(str) xmlMemStrdupLoc((str), __FILE__, __LINE__)\n\n#endif /* DEBUG_MEMORY_LOCATION */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#ifndef __XML_GLOBALS_H\n#ifndef __XML_THREADS_H__\n#include <libxml/threads.h>\n#include <libxml/globals.h>\n#endif\n#endif\n\n#endif  /* __DEBUG_MEMORY_ALLOC__ */\n\n"}, "45": {"id": 45, "path": "/usr/include/libxml2/libxml/xmlreader.h", "content": "/*\n * Summary: the XMLReader implementation\n * Description: API of the XML streaming API based on C# interfaces.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_XMLREADER_H__\n#define __XML_XMLREADER_H__\n\n#include <libxml/xmlversion.h>\n#include <libxml/tree.h>\n#include <libxml/xmlIO.h>\n#ifdef LIBXML_SCHEMAS_ENABLED\n#include <libxml/relaxng.h>\n#include <libxml/xmlschemas.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * xmlParserSeverities:\n *\n * How severe an error callback is when the per-reader error callback API\n * is used.\n */\ntypedef enum {\n    XML_PARSER_SEVERITY_VALIDITY_WARNING = 1,\n    XML_PARSER_SEVERITY_VALIDITY_ERROR = 2,\n    XML_PARSER_SEVERITY_WARNING = 3,\n    XML_PARSER_SEVERITY_ERROR = 4\n} xmlParserSeverities;\n\n#ifdef LIBXML_READER_ENABLED\n\n/**\n * xmlTextReaderMode:\n *\n * Internal state values for the reader.\n */\ntypedef enum {\n    XML_TEXTREADER_MODE_INITIAL = 0,\n    XML_TEXTREADER_MODE_INTERACTIVE = 1,\n    XML_TEXTREADER_MODE_ERROR = 2,\n    XML_TEXTREADER_MODE_EOF =3,\n    XML_TEXTREADER_MODE_CLOSED = 4,\n    XML_TEXTREADER_MODE_READING = 5\n} xmlTextReaderMode;\n\n/**\n * xmlParserProperties:\n *\n * Some common options to use with xmlTextReaderSetParserProp, but it\n * is better to use xmlParserOption and the xmlReaderNewxxx and\n * xmlReaderForxxx APIs now.\n */\ntypedef enum {\n    XML_PARSER_LOADDTD = 1,\n    XML_PARSER_DEFAULTATTRS = 2,\n    XML_PARSER_VALIDATE = 3,\n    XML_PARSER_SUBST_ENTITIES = 4\n} xmlParserProperties;\n\n/**\n * xmlReaderTypes:\n *\n * Predefined constants for the different types of nodes.\n */\ntypedef enum {\n    XML_READER_TYPE_NONE = 0,\n    XML_READER_TYPE_ELEMENT = 1,\n    XML_READER_TYPE_ATTRIBUTE = 2,\n    XML_READER_TYPE_TEXT = 3,\n    XML_READER_TYPE_CDATA = 4,\n    XML_READER_TYPE_ENTITY_REFERENCE = 5,\n    XML_READER_TYPE_ENTITY = 6,\n    XML_READER_TYPE_PROCESSING_INSTRUCTION = 7,\n    XML_READER_TYPE_COMMENT = 8,\n    XML_READER_TYPE_DOCUMENT = 9,\n    XML_READER_TYPE_DOCUMENT_TYPE = 10,\n    XML_READER_TYPE_DOCUMENT_FRAGMENT = 11,\n    XML_READER_TYPE_NOTATION = 12,\n    XML_READER_TYPE_WHITESPACE = 13,\n    XML_READER_TYPE_SIGNIFICANT_WHITESPACE = 14,\n    XML_READER_TYPE_END_ELEMENT = 15,\n    XML_READER_TYPE_END_ENTITY = 16,\n    XML_READER_TYPE_XML_DECLARATION = 17\n} xmlReaderTypes;\n\n/**\n * xmlTextReader:\n *\n * Structure for an xmlReader context.\n */\ntypedef struct _xmlTextReader xmlTextReader;\n\n/**\n * xmlTextReaderPtr:\n *\n * Pointer to an xmlReader context.\n */\ntypedef xmlTextReader *xmlTextReaderPtr;\n\n/*\n * Constructors & Destructor\n */\nXMLPUBFUN xmlTextReaderPtr XMLCALL\n\t\t\txmlNewTextReader\t(xmlParserInputBufferPtr input,\n\t                                         const char *URI);\nXMLPUBFUN xmlTextReaderPtr XMLCALL\n\t\t\txmlNewTextReaderFilename(const char *URI);\n\nXMLPUBFUN void XMLCALL\n\t\t\txmlFreeTextReader\t(xmlTextReaderPtr reader);\n\nXMLPUBFUN int XMLCALL\n            xmlTextReaderSetup(xmlTextReaderPtr reader,\n                   xmlParserInputBufferPtr input, const char *URL,\n                   const char *encoding, int options);\n\n/*\n * Iterators\n */\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderRead\t(xmlTextReaderPtr reader);\n\n#ifdef LIBXML_WRITER_ENABLED\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderReadInnerXml(xmlTextReaderPtr reader);\n\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderReadOuterXml(xmlTextReaderPtr reader);\n#endif\n\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderReadString\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderReadAttributeValue(xmlTextReaderPtr reader);\n\n/*\n * Attributes of the node\n */\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderAttributeCount(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderDepth\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderHasAttributes(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderHasValue(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderIsDefault\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderIsEmptyElement(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderNodeType\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderQuoteChar\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t\txmlTextReaderReadState\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n                        xmlTextReaderIsNamespaceDecl(xmlTextReaderPtr reader);\n\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstBaseUri\t(xmlTextReaderPtr reader);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstLocalName\t(xmlTextReaderPtr reader);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstName\t(xmlTextReaderPtr reader);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstPrefix\t(xmlTextReaderPtr reader);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstXmlLang\t(xmlTextReaderPtr reader);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstString\t(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const xmlChar *str);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstValue\t(xmlTextReaderPtr reader);\n\n/*\n * use the Const version of the routine for\n * better performance and simpler code\n */\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderBaseUri\t(xmlTextReaderPtr reader);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderLocalName\t(xmlTextReaderPtr reader);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderName\t(xmlTextReaderPtr reader);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderNamespaceUri(xmlTextReaderPtr reader);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderPrefix\t(xmlTextReaderPtr reader);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderXmlLang\t(xmlTextReaderPtr reader);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t\txmlTextReaderValue\t(xmlTextReaderPtr reader);\n\n/*\n * Methods of the XmlTextReader\n */\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderClose\t\t(xmlTextReaderPtr reader);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t    xmlTextReaderGetAttributeNo\t(xmlTextReaderPtr reader,\n\t\t\t\t\t\t int no);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t    xmlTextReaderGetAttribute\t(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t    xmlTextReaderGetAttributeNs\t(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const xmlChar *localName,\n\t\t\t\t\t\t const xmlChar *namespaceURI);\nXMLPUBFUN xmlParserInputBufferPtr XMLCALL\n\t\t    xmlTextReaderGetRemainder\t(xmlTextReaderPtr reader);\nXMLPUBFUN xmlChar * XMLCALL\n\t\t    xmlTextReaderLookupNamespace(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const xmlChar *prefix);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader,\n\t\t\t\t\t\t int no);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const xmlChar *name);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const xmlChar *localName,\n\t\t\t\t\t\t const xmlChar *namespaceURI);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderMoveToElement\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderNormalization\t(xmlTextReaderPtr reader);\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstEncoding  (xmlTextReaderPtr reader);\n\n/*\n * Extensions\n */\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderSetParserProp\t(xmlTextReaderPtr reader,\n\t\t\t\t\t\t int prop,\n\t\t\t\t\t\t int value);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderGetParserProp\t(xmlTextReaderPtr reader,\n\t\t\t\t\t\t int prop);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\t    xmlTextReaderCurrentNode\t(xmlTextReaderPtr reader);\n\nXMLPUBFUN int XMLCALL\n            xmlTextReaderGetParserLineNumber(xmlTextReaderPtr reader);\n\nXMLPUBFUN int XMLCALL\n            xmlTextReaderGetParserColumnNumber(xmlTextReaderPtr reader);\n\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\t    xmlTextReaderPreserve\t(xmlTextReaderPtr reader);\n#ifdef LIBXML_PATTERN_ENABLED\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderPreservePattern(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const xmlChar *pattern,\n\t\t\t\t\t\t const xmlChar **namespaces);\n#endif /* LIBXML_PATTERN_ENABLED */\nXMLPUBFUN xmlDocPtr XMLCALL\n\t\t    xmlTextReaderCurrentDoc\t(xmlTextReaderPtr reader);\nXMLPUBFUN xmlNodePtr XMLCALL\n\t\t    xmlTextReaderExpand\t\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderNext\t\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderNextSibling\t(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderIsValid\t(xmlTextReaderPtr reader);\n#ifdef LIBXML_SCHEMAS_ENABLED\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const char *rng);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderRelaxNGValidateCtxt(xmlTextReaderPtr reader,\n\t\t\t\t\t\t xmlRelaxNGValidCtxtPtr ctxt,\n\t\t\t\t\t\t int options);\n\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader,\n\t\t\t\t\t\t xmlRelaxNGPtr schema);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderSchemaValidate\t(xmlTextReaderPtr reader,\n\t\t\t\t\t\t const char *xsd);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,\n\t\t\t\t\t\t xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t\t int options);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderSetSchema\t(xmlTextReaderPtr reader,\n\t\t\t\t\t\t xmlSchemaPtr schema);\n#endif\nXMLPUBFUN const xmlChar * XMLCALL\n\t\t    xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader);\nXMLPUBFUN int XMLCALL\n\t\t    xmlTextReaderStandalone     (xmlTextReaderPtr reader);\n\n\n/*\n * Index lookup\n */\nXMLPUBFUN long XMLCALL\n\t\txmlTextReaderByteConsumed\t(xmlTextReaderPtr reader);\n\n/*\n * New more complete APIs for simpler creation and reuse of readers\n */\nXMLPUBFUN xmlTextReaderPtr XMLCALL\n\t\txmlReaderWalker\t\t(xmlDocPtr doc);\nXMLPUBFUN xmlTextReaderPtr XMLCALL\n\t\txmlReaderForDoc\t\t(const xmlChar * cur,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlTextReaderPtr XMLCALL\n\t\txmlReaderForFile\t(const char *filename,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlTextReaderPtr XMLCALL\n\t\txmlReaderForMemory\t(const char *buffer,\n\t\t\t\t\t int size,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlTextReaderPtr XMLCALL\n\t\txmlReaderForFd\t\t(int fd,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN xmlTextReaderPtr XMLCALL\n\t\txmlReaderForIO\t\t(xmlInputReadCallback ioread,\n\t\t\t\t\t xmlInputCloseCallback ioclose,\n\t\t\t\t\t void *ioctx,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\n\nXMLPUBFUN int XMLCALL\n\t\txmlReaderNewWalker\t(xmlTextReaderPtr reader,\n\t\t\t\t\t xmlDocPtr doc);\nXMLPUBFUN int XMLCALL\n\t\txmlReaderNewDoc\t\t(xmlTextReaderPtr reader,\n\t\t\t\t\t const xmlChar * cur,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN int XMLCALL\n\t\txmlReaderNewFile\t(xmlTextReaderPtr reader,\n\t\t\t\t\t const char *filename,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN int XMLCALL\n\t\txmlReaderNewMemory\t(xmlTextReaderPtr reader,\n\t\t\t\t\t const char *buffer,\n\t\t\t\t\t int size,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN int XMLCALL\n\t\txmlReaderNewFd\t\t(xmlTextReaderPtr reader,\n\t\t\t\t\t int fd,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\nXMLPUBFUN int XMLCALL\n\t\txmlReaderNewIO\t\t(xmlTextReaderPtr reader,\n\t\t\t\t\t xmlInputReadCallback ioread,\n\t\t\t\t\t xmlInputCloseCallback ioclose,\n\t\t\t\t\t void *ioctx,\n\t\t\t\t\t const char *URL,\n\t\t\t\t\t const char *encoding,\n\t\t\t\t\t int options);\n/*\n * Error handling extensions\n */\ntypedef void *  xmlTextReaderLocatorPtr;\n\n/**\n * xmlTextReaderErrorFunc:\n * @arg: the user argument\n * @msg: the message\n * @severity: the severity of the error\n * @locator: a locator indicating where the error occurred\n *\n * Signature of an error callback from a reader parser\n */\ntypedef void (XMLCALL *xmlTextReaderErrorFunc)(void *arg,\n\t\t\t\t\t       const char *msg,\n\t\t\t\t\t       xmlParserSeverities severity,\n\t\t\t\t\t       xmlTextReaderLocatorPtr locator);\nXMLPUBFUN int XMLCALL\n\t    xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator);\nXMLPUBFUN xmlChar * XMLCALL\n\t    xmlTextReaderLocatorBaseURI (xmlTextReaderLocatorPtr locator);\nXMLPUBFUN void XMLCALL\n\t    xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader,\n\t\t\t\t\t xmlTextReaderErrorFunc f,\n\t\t\t\t\t void *arg);\nXMLPUBFUN void XMLCALL\n\t    xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,\n\t\t\t\t\t\t   xmlStructuredErrorFunc f,\n\t\t\t\t\t\t   void *arg);\nXMLPUBFUN void XMLCALL\n\t    xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,\n\t\t\t\t\t xmlTextReaderErrorFunc *f,\n\t\t\t\t\t void **arg);\n\n#endif /* LIBXML_READER_ENABLED */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __XML_XMLREADER_H__ */\n\n"}, "46": {"id": 46, "path": "/usr/include/libxml2/libxml/xmlregexp.h", "content": "/*\n * Summary: regular expressions handling\n * Description: basic API for libxml regular expressions handling used\n *              for XML Schemas and validation.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_REGEXP_H__\n#define __XML_REGEXP_H__\n\n#include <libxml/xmlversion.h>\n\n#ifdef LIBXML_REGEXP_ENABLED\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * xmlRegexpPtr:\n *\n * A libxml regular expression, they can actually be far more complex\n * thank the POSIX regex expressions.\n */\ntypedef struct _xmlRegexp xmlRegexp;\ntypedef xmlRegexp *xmlRegexpPtr;\n\n/**\n * xmlRegExecCtxtPtr:\n *\n * A libxml progressive regular expression evaluation context\n */\ntypedef struct _xmlRegExecCtxt xmlRegExecCtxt;\ntypedef xmlRegExecCtxt *xmlRegExecCtxtPtr;\n\n#ifdef __cplusplus\n}\n#endif\n#include <libxml/tree.h>\n#include <libxml/dict.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * The POSIX like API\n */\nXMLPUBFUN xmlRegexpPtr XMLCALL\n\t\t    xmlRegexpCompile\t(const xmlChar *regexp);\nXMLPUBFUN void XMLCALL\t\t\t xmlRegFreeRegexp(xmlRegexpPtr regexp);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRegexpExec\t(xmlRegexpPtr comp,\n\t\t\t\t\t const xmlChar *value);\nXMLPUBFUN void XMLCALL\n\t\t    xmlRegexpPrint\t(FILE *output,\n\t\t\t\t\t xmlRegexpPtr regexp);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRegexpIsDeterminist(xmlRegexpPtr comp);\n\n/**\n * xmlRegExecCallbacks:\n * @exec: the regular expression context\n * @token: the current token string\n * @transdata: transition data\n * @inputdata: input data\n *\n * Callback function when doing a transition in the automata\n */\ntypedef void (*xmlRegExecCallbacks) (xmlRegExecCtxtPtr exec,\n\t                             const xmlChar *token,\n\t\t\t\t     void *transdata,\n\t\t\t\t     void *inputdata);\n\n/*\n * The progressive API\n */\nXMLPUBFUN xmlRegExecCtxtPtr XMLCALL\n\t\t    xmlRegNewExecCtxt\t(xmlRegexpPtr comp,\n\t\t\t\t\t xmlRegExecCallbacks callback,\n\t\t\t\t\t void *data);\nXMLPUBFUN void XMLCALL\n\t\t    xmlRegFreeExecCtxt\t(xmlRegExecCtxtPtr exec);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRegExecPushString(xmlRegExecCtxtPtr exec,\n\t\t\t\t\t const xmlChar *value,\n\t\t\t\t\t void *data);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRegExecPushString2(xmlRegExecCtxtPtr exec,\n\t\t\t\t\t const xmlChar *value,\n\t\t\t\t\t const xmlChar *value2,\n\t\t\t\t\t void *data);\n\nXMLPUBFUN int XMLCALL\n\t\t    xmlRegExecNextValues(xmlRegExecCtxtPtr exec,\n\t\t\t\t\t int *nbval,\n\t\t\t\t\t int *nbneg,\n\t\t\t\t\t xmlChar **values,\n\t\t\t\t\t int *terminal);\nXMLPUBFUN int XMLCALL\n\t\t    xmlRegExecErrInfo\t(xmlRegExecCtxtPtr exec,\n\t\t\t\t\t const xmlChar **string,\n\t\t\t\t\t int *nbval,\n\t\t\t\t\t int *nbneg,\n\t\t\t\t\t xmlChar **values,\n\t\t\t\t\t int *terminal);\n#ifdef LIBXML_EXPR_ENABLED\n/*\n * Formal regular expression handling\n * Its goal is to do some formal work on content models\n */\n\n/* expressions are used within a context */\ntypedef struct _xmlExpCtxt xmlExpCtxt;\ntypedef xmlExpCtxt *xmlExpCtxtPtr;\n\nXMLPUBFUN void XMLCALL\n\t\t\txmlExpFreeCtxt\t(xmlExpCtxtPtr ctxt);\nXMLPUBFUN xmlExpCtxtPtr XMLCALL\n\t\t\txmlExpNewCtxt\t(int maxNodes,\n\t\t\t\t\t xmlDictPtr dict);\n\nXMLPUBFUN int XMLCALL\n\t\t\txmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);\nXMLPUBFUN int XMLCALL\n\t\t\txmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);\n\n/* Expressions are trees but the tree is opaque */\ntypedef struct _xmlExpNode xmlExpNode;\ntypedef xmlExpNode *xmlExpNodePtr;\n\ntypedef enum {\n    XML_EXP_EMPTY = 0,\n    XML_EXP_FORBID = 1,\n    XML_EXP_ATOM = 2,\n    XML_EXP_SEQ = 3,\n    XML_EXP_OR = 4,\n    XML_EXP_COUNT = 5\n} xmlExpNodeType;\n\n/*\n * 2 core expressions shared by all for the empty language set\n * and for the set with just the empty token\n */\nXMLPUBVAR xmlExpNodePtr forbiddenExp;\nXMLPUBVAR xmlExpNodePtr emptyExp;\n\n/*\n * Expressions are reference counted internally\n */\nXMLPUBFUN void XMLCALL\n\t\t\txmlExpFree\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr expr);\nXMLPUBFUN void XMLCALL\n\t\t\txmlExpRef\t(xmlExpNodePtr expr);\n\n/*\n * constructors can be either manual or from a string\n */\nXMLPUBFUN xmlExpNodePtr XMLCALL\n\t\t\txmlExpParse\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t const char *expr);\nXMLPUBFUN xmlExpNodePtr XMLCALL\n\t\t\txmlExpNewAtom\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t const xmlChar *name,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlExpNodePtr XMLCALL\n\t\t\txmlExpNewOr\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr left,\n\t\t\t\t\t xmlExpNodePtr right);\nXMLPUBFUN xmlExpNodePtr XMLCALL\n\t\t\txmlExpNewSeq\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr left,\n\t\t\t\t\t xmlExpNodePtr right);\nXMLPUBFUN xmlExpNodePtr XMLCALL\n\t\t\txmlExpNewRange\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr subset,\n\t\t\t\t\t int min,\n\t\t\t\t\t int max);\n/*\n * The really interesting APIs\n */\nXMLPUBFUN int XMLCALL\n\t\t\txmlExpIsNillable(xmlExpNodePtr expr);\nXMLPUBFUN int XMLCALL\n\t\t\txmlExpMaxToken\t(xmlExpNodePtr expr);\nXMLPUBFUN int XMLCALL\n\t\t\txmlExpGetLanguage(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr expr,\n\t\t\t\t\t const xmlChar**langList,\n\t\t\t\t\t int len);\nXMLPUBFUN int XMLCALL\n\t\t\txmlExpGetStart\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr expr,\n\t\t\t\t\t const xmlChar**tokList,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlExpNodePtr XMLCALL\n\t\t\txmlExpStringDerive(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr expr,\n\t\t\t\t\t const xmlChar *str,\n\t\t\t\t\t int len);\nXMLPUBFUN xmlExpNodePtr XMLCALL\n\t\t\txmlExpExpDerive\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr expr,\n\t\t\t\t\t xmlExpNodePtr sub);\nXMLPUBFUN int XMLCALL\n\t\t\txmlExpSubsume\t(xmlExpCtxtPtr ctxt,\n\t\t\t\t\t xmlExpNodePtr expr,\n\t\t\t\t\t xmlExpNodePtr sub);\nXMLPUBFUN void XMLCALL\n\t\t\txmlExpDump\t(xmlBufferPtr buf,\n\t\t\t\t\t xmlExpNodePtr expr);\n#endif /* LIBXML_EXPR_ENABLED */\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* LIBXML_REGEXP_ENABLED */\n\n#endif /*__XML_REGEXP_H__ */\n"}, "47": {"id": 47, "path": "/usr/include/libxml2/libxml/xmlschemas.h", "content": "/*\n * Summary: incomplete XML Schemas structure implementation\n * Description: interface to the XML Schemas handling and schema validity\n *              checking, it is incomplete right now.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n\n#ifndef __XML_SCHEMA_H__\n#define __XML_SCHEMA_H__\n\n#include <libxml/xmlversion.h>\n\n#ifdef LIBXML_SCHEMAS_ENABLED\n\n#include <libxml/tree.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * This error codes are obsolete; not used any more.\n */\ntypedef enum {\n    XML_SCHEMAS_ERR_OK\t\t= 0,\n    XML_SCHEMAS_ERR_NOROOT\t= 1,\n    XML_SCHEMAS_ERR_UNDECLAREDELEM,\n    XML_SCHEMAS_ERR_NOTTOPLEVEL,\n    XML_SCHEMAS_ERR_MISSING,\n    XML_SCHEMAS_ERR_WRONGELEM,\n    XML_SCHEMAS_ERR_NOTYPE,\n    XML_SCHEMAS_ERR_NOROLLBACK,\n    XML_SCHEMAS_ERR_ISABSTRACT,\n    XML_SCHEMAS_ERR_NOTEMPTY,\n    XML_SCHEMAS_ERR_ELEMCONT,\n    XML_SCHEMAS_ERR_HAVEDEFAULT,\n    XML_SCHEMAS_ERR_NOTNILLABLE,\n    XML_SCHEMAS_ERR_EXTRACONTENT,\n    XML_SCHEMAS_ERR_INVALIDATTR,\n    XML_SCHEMAS_ERR_INVALIDELEM,\n    XML_SCHEMAS_ERR_NOTDETERMINIST,\n    XML_SCHEMAS_ERR_CONSTRUCT,\n    XML_SCHEMAS_ERR_INTERNAL,\n    XML_SCHEMAS_ERR_NOTSIMPLE,\n    XML_SCHEMAS_ERR_ATTRUNKNOWN,\n    XML_SCHEMAS_ERR_ATTRINVALID,\n    XML_SCHEMAS_ERR_VALUE,\n    XML_SCHEMAS_ERR_FACET,\n    XML_SCHEMAS_ERR_,\n    XML_SCHEMAS_ERR_XXX\n} xmlSchemaValidError;\n\n/*\n* ATTENTION: Change xmlSchemaSetValidOptions's check\n* for invalid values, if adding to the validation\n* options below.\n*/\n/**\n * xmlSchemaValidOption:\n *\n * This is the set of XML Schema validation options.\n */\ntypedef enum {\n    XML_SCHEMA_VAL_VC_I_CREATE\t\t\t= 1<<0\n\t/* Default/fixed: create an attribute node\n\t* or an element's text node on the instance.\n\t*/\n} xmlSchemaValidOption;\n\n/*\n    XML_SCHEMA_VAL_XSI_ASSEMBLE\t\t\t= 1<<1,\n\t* assemble schemata using\n\t* xsi:schemaLocation and\n\t* xsi:noNamespaceSchemaLocation\n*/\n\n/**\n * The schemas related types are kept internal\n */\ntypedef struct _xmlSchema xmlSchema;\ntypedef xmlSchema *xmlSchemaPtr;\n\n/**\n * xmlSchemaValidityErrorFunc:\n * @ctx: the validation context\n * @msg: the message\n * @...: extra arguments\n *\n * Signature of an error callback from an XSD validation\n */\ntypedef void (XMLCDECL *xmlSchemaValidityErrorFunc)\n                 (void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n\n/**\n * xmlSchemaValidityWarningFunc:\n * @ctx: the validation context\n * @msg: the message\n * @...: extra arguments\n *\n * Signature of a warning callback from an XSD validation\n */\ntypedef void (XMLCDECL *xmlSchemaValidityWarningFunc)\n                 (void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n\n/**\n * A schemas validation context\n */\ntypedef struct _xmlSchemaParserCtxt xmlSchemaParserCtxt;\ntypedef xmlSchemaParserCtxt *xmlSchemaParserCtxtPtr;\n\ntypedef struct _xmlSchemaValidCtxt xmlSchemaValidCtxt;\ntypedef xmlSchemaValidCtxt *xmlSchemaValidCtxtPtr;\n\n/**\n * xmlSchemaValidityLocatorFunc:\n * @ctx: user provided context\n * @file: returned file information\n * @line: returned line information\n *\n * A schemas validation locator, a callback called by the validator.\n * This is used when file or node informations are not available\n * to find out what file and line number are affected\n *\n * Returns: 0 in case of success and -1 in case of error\n */\n\ntypedef int (XMLCDECL *xmlSchemaValidityLocatorFunc) (void *ctx,\n                           const char **file, unsigned long *line);\n\n/*\n * Interfaces for parsing.\n */\nXMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL\n\t    xmlSchemaNewParserCtxt\t(const char *URL);\nXMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL\n\t    xmlSchemaNewMemParserCtxt\t(const char *buffer,\n\t\t\t\t\t int size);\nXMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL\n\t    xmlSchemaNewDocParserCtxt\t(xmlDocPtr doc);\nXMLPUBFUN void XMLCALL\n\t    xmlSchemaFreeParserCtxt\t(xmlSchemaParserCtxtPtr ctxt);\nXMLPUBFUN void XMLCALL\n\t    xmlSchemaSetParserErrors\t(xmlSchemaParserCtxtPtr ctxt,\n\t\t\t\t\t xmlSchemaValidityErrorFunc err,\n\t\t\t\t\t xmlSchemaValidityWarningFunc warn,\n\t\t\t\t\t void *ctx);\nXMLPUBFUN void XMLCALL\n\t    xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,\n\t\t\t\t\t xmlStructuredErrorFunc serror,\n\t\t\t\t\t void *ctx);\nXMLPUBFUN int XMLCALL\n\t\txmlSchemaGetParserErrors(xmlSchemaParserCtxtPtr ctxt,\n\t\t\t\t\txmlSchemaValidityErrorFunc * err,\n\t\t\t\t\txmlSchemaValidityWarningFunc * warn,\n\t\t\t\t\tvoid **ctx);\nXMLPUBFUN int XMLCALL\n\t\txmlSchemaIsValid\t(xmlSchemaValidCtxtPtr ctxt);\n\nXMLPUBFUN xmlSchemaPtr XMLCALL\n\t    xmlSchemaParse\t\t(xmlSchemaParserCtxtPtr ctxt);\nXMLPUBFUN void XMLCALL\n\t    xmlSchemaFree\t\t(xmlSchemaPtr schema);\n#ifdef LIBXML_OUTPUT_ENABLED\nXMLPUBFUN void XMLCALL\n\t    xmlSchemaDump\t\t(FILE *output,\n\t\t\t\t\t xmlSchemaPtr schema);\n#endif /* LIBXML_OUTPUT_ENABLED */\n/*\n * Interfaces for validating\n */\nXMLPUBFUN void XMLCALL\n\t    xmlSchemaSetValidErrors\t(xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t xmlSchemaValidityErrorFunc err,\n\t\t\t\t\t xmlSchemaValidityWarningFunc warn,\n\t\t\t\t\t void *ctx);\nXMLPUBFUN void XMLCALL\n\t    xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t xmlStructuredErrorFunc serror,\n\t\t\t\t\t void *ctx);\nXMLPUBFUN int XMLCALL\n\t    xmlSchemaGetValidErrors\t(xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t xmlSchemaValidityErrorFunc *err,\n\t\t\t\t\t xmlSchemaValidityWarningFunc *warn,\n\t\t\t\t\t void **ctx);\nXMLPUBFUN int XMLCALL\n\t    xmlSchemaSetValidOptions\t(xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t int options);\nXMLPUBFUN void XMLCALL\n            xmlSchemaValidateSetFilename(xmlSchemaValidCtxtPtr vctxt,\n\t                                 const char *filename);\nXMLPUBFUN int XMLCALL\n\t    xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt);\n\nXMLPUBFUN xmlSchemaValidCtxtPtr XMLCALL\n\t    xmlSchemaNewValidCtxt\t(xmlSchemaPtr schema);\nXMLPUBFUN void XMLCALL\n\t    xmlSchemaFreeValidCtxt\t(xmlSchemaValidCtxtPtr ctxt);\nXMLPUBFUN int XMLCALL\n\t    xmlSchemaValidateDoc\t(xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t xmlDocPtr instance);\nXMLPUBFUN int XMLCALL\n            xmlSchemaValidateOneElement (xmlSchemaValidCtxtPtr ctxt,\n\t\t\t                 xmlNodePtr elem);\nXMLPUBFUN int XMLCALL\n\t    xmlSchemaValidateStream\t(xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t xmlParserInputBufferPtr input,\n\t\t\t\t\t xmlCharEncoding enc,\n\t\t\t\t\t xmlSAXHandlerPtr sax,\n\t\t\t\t\t void *user_data);\nXMLPUBFUN int XMLCALL\n\t    xmlSchemaValidateFile\t(xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t const char * filename,\n\t\t\t\t\t int options);\n\nXMLPUBFUN xmlParserCtxtPtr XMLCALL\n\t    xmlSchemaValidCtxtGetParserCtxt(xmlSchemaValidCtxtPtr ctxt);\n\n/*\n * Interface to insert Schemas SAX validation in a SAX stream\n */\ntypedef struct _xmlSchemaSAXPlug xmlSchemaSAXPlugStruct;\ntypedef xmlSchemaSAXPlugStruct *xmlSchemaSAXPlugPtr;\n\nXMLPUBFUN xmlSchemaSAXPlugPtr XMLCALL\n            xmlSchemaSAXPlug\t\t(xmlSchemaValidCtxtPtr ctxt,\n\t\t\t\t\t xmlSAXHandlerPtr *sax,\n\t\t\t\t\t void **user_data);\nXMLPUBFUN int XMLCALL\n            xmlSchemaSAXUnplug\t\t(xmlSchemaSAXPlugPtr plug);\n\n\nXMLPUBFUN void XMLCALL\n            xmlSchemaValidateSetLocator\t(xmlSchemaValidCtxtPtr vctxt,\n\t\t\t\t\t xmlSchemaValidityLocatorFunc f,\n\t\t\t\t\t void *ctxt);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* LIBXML_SCHEMAS_ENABLED */\n#endif /* __XML_SCHEMA_H__ */\n"}, "48": {"id": 48, "path": "/usr/include/libxml2/libxml/xmlstring.h", "content": "/*\n * Summary: set of routines to process strings\n * Description: type and interfaces needed for the internal string handling\n *              of the library, especially UTF8 processing.\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_STRING_H__\n#define __XML_STRING_H__\n\n#include <stdarg.h>\n#include <libxml/xmlversion.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * xmlChar:\n *\n * This is a basic byte in an UTF-8 encoded string.\n * It's unsigned allowing to pinpoint case where char * are assigned\n * to xmlChar * (possibly making serialization back impossible).\n */\ntypedef unsigned char xmlChar;\n\n/**\n * BAD_CAST:\n *\n * Macro to cast a string to an xmlChar * when one know its safe.\n */\n#define BAD_CAST (xmlChar *)\n\n/*\n * xmlChar handling\n */\nXMLPUBFUN xmlChar * XMLCALL\n                xmlStrdup                (const xmlChar *cur);\nXMLPUBFUN xmlChar * XMLCALL\n                xmlStrndup               (const xmlChar *cur,\n                                         int len);\nXMLPUBFUN xmlChar * XMLCALL\n                xmlCharStrndup           (const char *cur,\n                                         int len);\nXMLPUBFUN xmlChar * XMLCALL\n                xmlCharStrdup            (const char *cur);\nXMLPUBFUN xmlChar * XMLCALL\n                xmlStrsub                (const xmlChar *str,\n                                         int start,\n                                         int len);\nXMLPUBFUN const xmlChar * XMLCALL\n                xmlStrchr                (const xmlChar *str,\n                                         xmlChar val);\nXMLPUBFUN const xmlChar * XMLCALL\n                xmlStrstr                (const xmlChar *str,\n                                         const xmlChar *val);\nXMLPUBFUN const xmlChar * XMLCALL\n                xmlStrcasestr            (const xmlChar *str,\n                                         const xmlChar *val);\nXMLPUBFUN int XMLCALL\n                xmlStrcmp                (const xmlChar *str1,\n                                         const xmlChar *str2);\nXMLPUBFUN int XMLCALL\n                xmlStrncmp               (const xmlChar *str1,\n                                         const xmlChar *str2,\n                                         int len);\nXMLPUBFUN int XMLCALL\n                xmlStrcasecmp            (const xmlChar *str1,\n                                         const xmlChar *str2);\nXMLPUBFUN int XMLCALL\n                xmlStrncasecmp           (const xmlChar *str1,\n                                         const xmlChar *str2,\n                                         int len);\nXMLPUBFUN int XMLCALL\n                xmlStrEqual              (const xmlChar *str1,\n                                         const xmlChar *str2);\nXMLPUBFUN int XMLCALL\n                xmlStrQEqual             (const xmlChar *pref,\n                                         const xmlChar *name,\n                                         const xmlChar *str);\nXMLPUBFUN int XMLCALL\n                xmlStrlen                (const xmlChar *str);\nXMLPUBFUN xmlChar * XMLCALL\n                xmlStrcat                (xmlChar *cur,\n                                         const xmlChar *add);\nXMLPUBFUN xmlChar * XMLCALL\n                xmlStrncat               (xmlChar *cur,\n                                         const xmlChar *add,\n                                         int len);\nXMLPUBFUN xmlChar * XMLCALL\n                xmlStrncatNew            (const xmlChar *str1,\n                                         const xmlChar *str2,\n                                         int len);\nXMLPUBFUN int XMLCALL\n                xmlStrPrintf             (xmlChar *buf,\n                                         int len,\n                                         const char *msg,\n                                         ...) LIBXML_ATTR_FORMAT(3,4);\nXMLPUBFUN int XMLCALL\n                xmlStrVPrintf                (xmlChar *buf,\n                                         int len,\n                                         const char *msg,\n                                         va_list ap) LIBXML_ATTR_FORMAT(3,0);\n\nXMLPUBFUN int XMLCALL\n        xmlGetUTF8Char                   (const unsigned char *utf,\n                                         int *len);\nXMLPUBFUN int XMLCALL\n        xmlCheckUTF8                     (const unsigned char *utf);\nXMLPUBFUN int XMLCALL\n        xmlUTF8Strsize                   (const xmlChar *utf,\n                                         int len);\nXMLPUBFUN xmlChar * XMLCALL\n        xmlUTF8Strndup                   (const xmlChar *utf,\n                                         int len);\nXMLPUBFUN const xmlChar * XMLCALL\n        xmlUTF8Strpos                    (const xmlChar *utf,\n                                         int pos);\nXMLPUBFUN int XMLCALL\n        xmlUTF8Strloc                    (const xmlChar *utf,\n                                         const xmlChar *utfchar);\nXMLPUBFUN xmlChar * XMLCALL\n        xmlUTF8Strsub                    (const xmlChar *utf,\n                                         int start,\n                                         int len);\nXMLPUBFUN int XMLCALL\n        xmlUTF8Strlen                    (const xmlChar *utf);\nXMLPUBFUN int XMLCALL\n        xmlUTF8Size                      (const xmlChar *utf);\nXMLPUBFUN int XMLCALL\n        xmlUTF8Charcmp                   (const xmlChar *utf1,\n                                         const xmlChar *utf2);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* __XML_STRING_H__ */\n"}, "49": {"id": 49, "path": "/usr/include/libxml2/libxml/xmlversion.h", "content": "/*\n * Summary: compile-time version informations\n * Description: compile-time version informations for the XML library\n *\n * Copy: See Copyright for the status of this software.\n *\n * Author: Daniel Veillard\n */\n\n#ifndef __XML_VERSION_H__\n#define __XML_VERSION_H__\n\n#include <libxml/xmlexports.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * use those to be sure nothing nasty will happen if\n * your library and includes mismatch\n */\n#ifndef LIBXML2_COMPILING_MSCCDEF\nXMLPUBFUN void XMLCALL xmlCheckVersion(int version);\n#endif /* LIBXML2_COMPILING_MSCCDEF */\n\n/**\n * LIBXML_DOTTED_VERSION:\n *\n * the version string like \"1.2.3\"\n */\n#define LIBXML_DOTTED_VERSION \"2.9.10\"\n\n/**\n * LIBXML_VERSION:\n *\n * the version number: 1.2.3 value is 10203\n */\n#define LIBXML_VERSION 20910\n\n/**\n * LIBXML_VERSION_STRING:\n *\n * the version number string, 1.2.3 value is \"10203\"\n */\n#define LIBXML_VERSION_STRING \"20910\"\n\n/**\n * LIBXML_VERSION_EXTRA:\n *\n * extra version information, used to show a CVS compilation\n */\n#define LIBXML_VERSION_EXTRA \"\"\n\n/**\n * LIBXML_TEST_VERSION:\n *\n * Macro to check that the libxml version in use is compatible with\n * the version the software has been compiled against\n */\n#define LIBXML_TEST_VERSION xmlCheckVersion(20910);\n\n#ifndef VMS\n#if 0\n/**\n * WITH_TRIO:\n *\n * defined if the trio support need to be configured in\n */\n#define WITH_TRIO\n#else\n/**\n * WITHOUT_TRIO:\n *\n * defined if the trio support should not be configured in\n */\n#define WITHOUT_TRIO\n#endif\n#else /* VMS */\n/**\n * WITH_TRIO:\n *\n * defined if the trio support need to be configured in\n */\n#define WITH_TRIO 1\n#endif /* VMS */\n\n/**\n * LIBXML_THREAD_ENABLED:\n *\n * Whether the thread support is configured in\n */\n#if 1\n#define LIBXML_THREAD_ENABLED\n#endif\n\n/**\n * LIBXML_THREAD_ALLOC_ENABLED:\n *\n * Whether the allocation hooks are per-thread\n */\n#if 0\n#define LIBXML_THREAD_ALLOC_ENABLED\n#endif\n\n/**\n * LIBXML_TREE_ENABLED:\n *\n * Whether the DOM like tree manipulation API support is configured in\n */\n#if 1\n#define LIBXML_TREE_ENABLED\n#endif\n\n/**\n * LIBXML_OUTPUT_ENABLED:\n *\n * Whether the serialization/saving support is configured in\n */\n#if 1\n#define LIBXML_OUTPUT_ENABLED\n#endif\n\n/**\n * LIBXML_PUSH_ENABLED:\n *\n * Whether the push parsing interfaces are configured in\n */\n#if 1\n#define LIBXML_PUSH_ENABLED\n#endif\n\n/**\n * LIBXML_READER_ENABLED:\n *\n * Whether the xmlReader parsing interface is configured in\n */\n#if 1\n#define LIBXML_READER_ENABLED\n#endif\n\n/**\n * LIBXML_PATTERN_ENABLED:\n *\n * Whether the xmlPattern node selection interface is configured in\n */\n#if 1\n#define LIBXML_PATTERN_ENABLED\n#endif\n\n/**\n * LIBXML_WRITER_ENABLED:\n *\n * Whether the xmlWriter saving interface is configured in\n */\n#if 1\n#define LIBXML_WRITER_ENABLED\n#endif\n\n/**\n * LIBXML_SAX1_ENABLED:\n *\n * Whether the older SAX1 interface is configured in\n */\n#if 1\n#define LIBXML_SAX1_ENABLED\n#endif\n\n/**\n * LIBXML_FTP_ENABLED:\n *\n * Whether the FTP support is configured in\n */\n#if 1\n#define LIBXML_FTP_ENABLED\n#endif\n\n/**\n * LIBXML_HTTP_ENABLED:\n *\n * Whether the HTTP support is configured in\n */\n#if 1\n#define LIBXML_HTTP_ENABLED\n#endif\n\n/**\n * LIBXML_VALID_ENABLED:\n *\n * Whether the DTD validation support is configured in\n */\n#if 1\n#define LIBXML_VALID_ENABLED\n#endif\n\n/**\n * LIBXML_HTML_ENABLED:\n *\n * Whether the HTML support is configured in\n */\n#if 1\n#define LIBXML_HTML_ENABLED\n#endif\n\n/**\n * LIBXML_LEGACY_ENABLED:\n *\n * Whether the deprecated APIs are compiled in for compatibility\n */\n#if 1\n#define LIBXML_LEGACY_ENABLED\n#endif\n\n/**\n * LIBXML_C14N_ENABLED:\n *\n * Whether the Canonicalization support is configured in\n */\n#if 1\n#define LIBXML_C14N_ENABLED\n#endif\n\n/**\n * LIBXML_CATALOG_ENABLED:\n *\n * Whether the Catalog support is configured in\n */\n#if 1\n#define LIBXML_CATALOG_ENABLED\n#endif\n\n/**\n * LIBXML_DOCB_ENABLED:\n *\n * Whether the SGML Docbook support is configured in\n */\n#if 1\n#define LIBXML_DOCB_ENABLED\n#endif\n\n/**\n * LIBXML_XPATH_ENABLED:\n *\n * Whether XPath is configured in\n */\n#if 1\n#define LIBXML_XPATH_ENABLED\n#endif\n\n/**\n * LIBXML_XPTR_ENABLED:\n *\n * Whether XPointer is configured in\n */\n#if 1\n#define LIBXML_XPTR_ENABLED\n#endif\n\n/**\n * LIBXML_XINCLUDE_ENABLED:\n *\n * Whether XInclude is configured in\n */\n#if 1\n#define LIBXML_XINCLUDE_ENABLED\n#endif\n\n/**\n * LIBXML_ICONV_ENABLED:\n *\n * Whether iconv support is available\n */\n#if 1\n#define LIBXML_ICONV_ENABLED\n#endif\n\n/**\n * LIBXML_ICU_ENABLED:\n *\n * Whether icu support is available\n */\n#if 1\n#define LIBXML_ICU_ENABLED\n#endif\n\n/**\n * LIBXML_ISO8859X_ENABLED:\n *\n * Whether ISO-8859-* support is made available in case iconv is not\n */\n#if 1\n#define LIBXML_ISO8859X_ENABLED\n#endif\n\n/**\n * LIBXML_DEBUG_ENABLED:\n *\n * Whether Debugging module is configured in\n */\n#if 1\n#define LIBXML_DEBUG_ENABLED\n#endif\n\n/**\n * DEBUG_MEMORY_LOCATION:\n *\n * Whether the memory debugging is configured in\n */\n#if 0\n#define DEBUG_MEMORY_LOCATION\n#endif\n\n/**\n * LIBXML_DEBUG_RUNTIME:\n *\n * Whether the runtime debugging is configured in\n */\n#if 0\n#define LIBXML_DEBUG_RUNTIME\n#endif\n\n/**\n * LIBXML_UNICODE_ENABLED:\n *\n * Whether the Unicode related interfaces are compiled in\n */\n#if 1\n#define LIBXML_UNICODE_ENABLED\n#endif\n\n/**\n * LIBXML_REGEXP_ENABLED:\n *\n * Whether the regular expressions interfaces are compiled in\n */\n#if 1\n#define LIBXML_REGEXP_ENABLED\n#endif\n\n/**\n * LIBXML_AUTOMATA_ENABLED:\n *\n * Whether the automata interfaces are compiled in\n */\n#if 1\n#define LIBXML_AUTOMATA_ENABLED\n#endif\n\n/**\n * LIBXML_EXPR_ENABLED:\n *\n * Whether the formal expressions interfaces are compiled in\n *\n * This code is unused and disabled unconditionally for now.\n */\n#if 0\n#define LIBXML_EXPR_ENABLED\n#endif\n\n/**\n * LIBXML_SCHEMAS_ENABLED:\n *\n * Whether the Schemas validation interfaces are compiled in\n */\n#if 1\n#define LIBXML_SCHEMAS_ENABLED\n#endif\n\n/**\n * LIBXML_SCHEMATRON_ENABLED:\n *\n * Whether the Schematron validation interfaces are compiled in\n */\n#if 1\n#define LIBXML_SCHEMATRON_ENABLED\n#endif\n\n/**\n * LIBXML_MODULES_ENABLED:\n *\n * Whether the module interfaces are compiled in\n */\n#if 1\n#define LIBXML_MODULES_ENABLED\n/**\n * LIBXML_MODULE_EXTENSION:\n *\n * the string suffix used by dynamic modules (usually shared libraries)\n */\n#define LIBXML_MODULE_EXTENSION \".so\" \n#endif\n\n/**\n * LIBXML_ZLIB_ENABLED:\n *\n * Whether the Zlib support is compiled in\n */\n#if 1\n#define LIBXML_ZLIB_ENABLED\n#endif\n\n/**\n * LIBXML_LZMA_ENABLED:\n *\n * Whether the Lzma support is compiled in\n */\n#if 1\n#define LIBXML_LZMA_ENABLED\n#endif\n\n#ifdef __GNUC__\n\n/**\n * ATTRIBUTE_UNUSED:\n *\n * Macro used to signal to GCC unused function parameters\n */\n\n#ifndef ATTRIBUTE_UNUSED\n# if ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >= 7)))\n#  define ATTRIBUTE_UNUSED __attribute__((unused))\n# else\n#  define ATTRIBUTE_UNUSED\n# endif\n#endif\n\n/**\n * LIBXML_ATTR_ALLOC_SIZE:\n *\n * Macro used to indicate to GCC this is an allocator function\n */\n\n#ifndef LIBXML_ATTR_ALLOC_SIZE\n# if (!defined(__clang__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3))))\n#  define LIBXML_ATTR_ALLOC_SIZE(x) __attribute__((alloc_size(x)))\n# else\n#  define LIBXML_ATTR_ALLOC_SIZE(x)\n# endif\n#else\n# define LIBXML_ATTR_ALLOC_SIZE(x)\n#endif\n\n/**\n * LIBXML_ATTR_FORMAT:\n *\n * Macro used to indicate to GCC the parameter are printf like\n */\n\n#ifndef LIBXML_ATTR_FORMAT\n# if ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)))\n#  define LIBXML_ATTR_FORMAT(fmt,args) __attribute__((__format__(__printf__,fmt,args)))\n# else\n#  define LIBXML_ATTR_FORMAT(fmt,args)\n# endif\n#else\n# define LIBXML_ATTR_FORMAT(fmt,args)\n#endif\n\n#else /* ! __GNUC__ */\n/**\n * ATTRIBUTE_UNUSED:\n *\n * Macro used to signal to GCC unused function parameters\n */\n#define ATTRIBUTE_UNUSED\n/**\n * LIBXML_ATTR_ALLOC_SIZE:\n *\n * Macro used to indicate to GCC this is an allocator function\n */\n#define LIBXML_ATTR_ALLOC_SIZE(x)\n/**\n * LIBXML_ATTR_FORMAT:\n *\n * Macro used to indicate to GCC the parameter are printf like\n */\n#define LIBXML_ATTR_FORMAT(fmt,args)\n#endif /* __GNUC__ */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif\n\n\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 14, "line": 9}, "message": "LLVM_LLDB_SOURCE_PLUGINS_PROCESS_UTILITY_GDBREMOTESIGNALS_H (fixit)"}, {"location": {"col": 9, "file": 14, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Process/Utility/GDBRemoteSignals.h", "reportHash": "17eb7d98c4af724312ca52f5b329ec31", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 9}, "message": "LLVM_LLDB_SOURCE_PLUGINS_PROCESS_UTILITY_INFERIORCALLPOSIX_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Process/Utility/InferiorCallPOSIX.h", "reportHash": "c80d690adfb4bc09a98c545441fc98a2", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 23, "line": 120}, "message": "'ProcessGDBRemoteProperties.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp", "reportHash": "63b1a4f7b1cef141dc7b3f73322c449c", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 9, "file": 26, "line": 9}, "message": "LLVM_LLDB_SOURCE_PLUGINS_PROCESS_GDB_REMOTE_THREADGDBREMOTE_H (fixit)"}, {"location": {"col": 9, "file": 26, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Process/gdb-remote/ThreadGDBRemote.h", "reportHash": "abe143ded9c3c12c3175eef8162bcdb6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 12}, "message": "LIBXML2_LIBXML_SAX2_H (fixit)"}, {"location": {"col": 9, "file": 27, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/SAX2.h", "reportHash": "bbd86a635fb0a16f4e4e669d48fba059", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 28, "line": 11}, "message": "LIBXML2_LIBXML_DICT_H (fixit)"}, {"location": {"col": 9, "file": 28, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/dict.h", "reportHash": "a3cf8c13a944e4082c647271683edff6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 29, "line": 22}, "message": "LIBXML2_LIBXML_ENCODING_H (fixit)"}, {"location": {"col": 9, "file": 29, "line": 22}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/encoding.h", "reportHash": "7c043f0ffa4f2eeb1bc796d7944a0aae", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 30, "line": 11}, "message": "LIBXML2_LIBXML_ENTITIES_H (fixit)"}, {"location": {"col": 9, "file": 30, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/entities.h", "reportHash": "6ba850cc6c45126b2a978e67b56255d8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 31, "line": 14}, "message": "LIBXML2_LIBXML_GLOBALS_H (fixit)"}, {"location": {"col": 9, "file": 31, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/globals.h", "reportHash": "f92407618ff23967e8d07eb43c7cd23b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 32, "line": 11}, "message": "LIBXML2_LIBXML_HASH_H (fixit)"}, {"location": {"col": 9, "file": 32, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/hash.h", "reportHash": "2ad558985c4c6ac57db0c9b244e9ce66", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 33, "line": 11}, "message": "LIBXML2_LIBXML_LIST_H (fixit)"}, {"location": {"col": 9, "file": 33, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/list.h", "reportHash": "6158ed52af38c007272962648534b9b4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 34, "line": 10}, "message": "LIBXML2_LIBXML_PARSER_H (fixit)"}, {"location": {"col": 9, "file": 34, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/parser.h", "reportHash": "87e367cb9fd69ce37936fad8722c946a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 35, "line": 10}, "message": "LIBXML2_LIBXML_RELAXNG_H (fixit)"}, {"location": {"col": 9, "file": 35, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/relaxng.h", "reportHash": "3c7fb464978fb73115ed78cd098e268d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 36, "line": 11}, "message": "LIBXML2_LIBXML_THREADS_H (fixit)"}, {"location": {"col": 9, "file": 36, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/threads.h", "reportHash": "3ca127d02c26dfaed10828964b71f50f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 37, "line": 12}, "message": "LIBXML2_LIBXML_TREE_H (fixit)"}, {"location": {"col": 9, "file": 37, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/tree.h", "reportHash": "035ca50a83fb4868b82cf202e57d7146", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 38, "line": 11}, "message": "LIBXML2_LIBXML_VALID_H (fixit)"}, {"location": {"col": 9, "file": 38, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/valid.h", "reportHash": "66b20e26b4e582b6b9d72f3fdbaf7777", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 39, "line": 10}, "message": "LIBXML2_LIBXML_XLINK_H (fixit)"}, {"location": {"col": 9, "file": 39, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xlink.h", "reportHash": "75bdf615b715b8ea86186af6c6ef56dc", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 40, "line": 10}, "message": "LIBXML2_LIBXML_XMLIO_H (fixit)"}, {"location": {"col": 9, "file": 40, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlIO.h", "reportHash": "80802904488886c89f2b8050c0538797", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 41, "line": 10}, "message": "LIBXML2_LIBXML_XMLAUTOMATA_H (fixit)"}, {"location": {"col": 9, "file": 41, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlautomata.h", "reportHash": "71365d33716d4bed1ec4e948a2185654", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 42, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlerror.h", "reportHash": "eca39be93bc92060215fd9b30fb511ac", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 43, "line": 10}, "message": "LIBXML2_LIBXML_XMLEXPORTS_H (fixit)"}, {"location": {"col": 9, "file": 43, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlexports.h", "reportHash": "df634fd9fa13d625c227d0c5d394a626", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 44, "line": 12}, "message": "LIBXML2_LIBXML_XMLMEMORY_H (fixit)"}, {"location": {"col": 9, "file": 44, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlmemory.h", "reportHash": "f6e54b135917e72e98d01f3aea0edc32", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 45, "line": 10}, "message": "LIBXML2_LIBXML_XMLREADER_H (fixit)"}, {"location": {"col": 9, "file": 45, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlreader.h", "reportHash": "15567d60ede6729136c4ba78b481414f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 46, "line": 11}, "message": "LIBXML2_LIBXML_XMLREGEXP_H (fixit)"}, {"location": {"col": 9, "file": 46, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlregexp.h", "reportHash": "c3a62d6ad0bef8b916212eee6c7d1957", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 47, "line": 12}, "message": "LIBXML2_LIBXML_XMLSCHEMAS_H (fixit)"}, {"location": {"col": 9, "file": 47, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlschemas.h", "reportHash": "0ddbdaf87b2e4401b042d950093293ee", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 48, "line": 11}, "message": "LIBXML2_LIBXML_XMLSTRING_H (fixit)"}, {"location": {"col": 9, "file": 48, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlstring.h", "reportHash": "07302ce2b1c3ec47e8ada0e4afcfd4ba", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 49, "line": 10}, "message": "LIBXML2_LIBXML_XMLVERSION_H (fixit)"}, {"location": {"col": 9, "file": 49, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/libxml2/libxml/xmlversion.h", "reportHash": "f2935e749b912102ea8f7a101d34d995", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
