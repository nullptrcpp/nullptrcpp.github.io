<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/IR/Instructions.cpp", "content": "//===- Instructions.cpp - Implement the LLVM instructions -----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements all of the non-inline methods for the LLVM instruction\n// classes.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/IR/Instructions.h\"\n#include \"LLVMContextImpl.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/MDBuilder.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <vector>\n\nusing namespace llvm;\n\n//===----------------------------------------------------------------------===//\n//                            AllocaInst Class\n//===----------------------------------------------------------------------===//\n\nOptional<TypeSize>\nAllocaInst::getAllocationSizeInBits(const DataLayout &DL) const {\n  TypeSize Size = DL.getTypeAllocSizeInBits(getAllocatedType());\n  if (isArrayAllocation()) {\n    auto *C = dyn_cast<ConstantInt>(getArraySize());\n    if (!C)\n      return None;\n    assert(!Size.isScalable() && \"Array elements cannot have a scalable size\");\n    Size *= C->getZExtValue();\n  }\n  return Size;\n}\n\n//===----------------------------------------------------------------------===//\n//                              SelectInst Class\n//===----------------------------------------------------------------------===//\n\n/// areInvalidOperands - Return a string if the specified operands are invalid\n/// for a select operation, otherwise return null.\nconst char *SelectInst::areInvalidOperands(Value *Op0, Value *Op1, Value *Op2) {\n  if (Op1->getType() != Op2->getType())\n    return \"both values to select must have same type\";\n\n  if (Op1->getType()->isTokenTy())\n    return \"select values cannot have token type\";\n\n  if (VectorType *VT = dyn_cast<VectorType>(Op0->getType())) {\n    // Vector select.\n    if (VT->getElementType() != Type::getInt1Ty(Op0->getContext()))\n      return \"vector select condition element type must be i1\";\n    VectorType *ET = dyn_cast<VectorType>(Op1->getType());\n    if (!ET)\n      return \"selected values for vector select must be vectors\";\n    if (ET->getElementCount() != VT->getElementCount())\n      return \"vector select requires selected vectors to have \"\n                   \"the same vector length as select condition\";\n  } else if (Op0->getType() != Type::getInt1Ty(Op0->getContext())) {\n    return \"select condition must be i1 or <n x i1>\";\n  }\n  return nullptr;\n}\n\n//===----------------------------------------------------------------------===//\n//                               PHINode Class\n//===----------------------------------------------------------------------===//\n\nPHINode::PHINode(const PHINode &PN)\n    : Instruction(PN.getType(), Instruction::PHI, nullptr, PN.getNumOperands()),\n      ReservedSpace(PN.getNumOperands()) {\n  allocHungoffUses(PN.getNumOperands());\n  std::copy(PN.op_begin(), PN.op_end(), op_begin());\n  std::copy(PN.block_begin(), PN.block_end(), block_begin());\n  SubclassOptionalData = PN.SubclassOptionalData;\n}\n\n// removeIncomingValue - Remove an incoming value.  This is useful if a\n// predecessor basic block is deleted.\nValue *PHINode::removeIncomingValue(unsigned Idx, bool DeletePHIIfEmpty) {\n  Value *Removed = getIncomingValue(Idx);\n\n  // Move everything after this operand down.\n  //\n  // FIXME: we could just swap with the end of the list, then erase.  However,\n  // clients might not expect this to happen.  The code as it is thrashes the\n  // use/def lists, which is kinda lame.\n  std::copy(op_begin() + Idx + 1, op_end(), op_begin() + Idx);\n  std::copy(block_begin() + Idx + 1, block_end(), block_begin() + Idx);\n\n  // Nuke the last value.\n  Op<-1>().set(nullptr);\n  setNumHungOffUseOperands(getNumOperands() - 1);\n\n  // If the PHI node is dead, because it has zero entries, nuke it now.\n  if (getNumOperands() == 0 && DeletePHIIfEmpty) {\n    // If anyone is using this PHI, make them use a dummy value instead...\n    replaceAllUsesWith(UndefValue::get(getType()));\n    eraseFromParent();\n  }\n  return Removed;\n}\n\n/// growOperands - grow operands - This grows the operand list in response\n/// to a push_back style of operation.  This grows the number of ops by 1.5\n/// times.\n///\nvoid PHINode::growOperands() {\n  unsigned e = getNumOperands();\n  unsigned NumOps = e + e / 2;\n  if (NumOps < 2) NumOps = 2;      // 2 op PHI nodes are VERY common.\n\n  ReservedSpace = NumOps;\n  growHungoffUses(ReservedSpace, /* IsPhi */ true);\n}\n\n/// hasConstantValue - If the specified PHI node always merges together the same\n/// value, return the value, otherwise return null.\nValue *PHINode::hasConstantValue() const {\n  // Exploit the fact that phi nodes always have at least one entry.\n  Value *ConstantValue = getIncomingValue(0);\n  for (unsigned i = 1, e = getNumIncomingValues(); i != e; ++i)\n    if (getIncomingValue(i) != ConstantValue && getIncomingValue(i) != this) {\n      if (ConstantValue != this)\n        return nullptr; // Incoming values not all the same.\n       // The case where the first value is this PHI.\n      ConstantValue = getIncomingValue(i);\n    }\n  if (ConstantValue == this)\n    return UndefValue::get(getType());\n  return ConstantValue;\n}\n\n/// hasConstantOrUndefValue - Whether the specified PHI node always merges\n/// together the same value, assuming that undefs result in the same value as\n/// non-undefs.\n/// Unlike \\ref hasConstantValue, this does not return a value because the\n/// unique non-undef incoming value need not dominate the PHI node.\nbool PHINode::hasConstantOrUndefValue() const {\n  Value *ConstantValue = nullptr;\n  for (unsigned i = 0, e = getNumIncomingValues(); i != e; ++i) {\n    Value *Incoming = getIncomingValue(i);\n    if (Incoming != this && !isa<UndefValue>(Incoming)) {\n      if (ConstantValue && ConstantValue != Incoming)\n        return false;\n      ConstantValue = Incoming;\n    }\n  }\n  return true;\n}\n\n//===----------------------------------------------------------------------===//\n//                       LandingPadInst Implementation\n//===----------------------------------------------------------------------===//\n\nLandingPadInst::LandingPadInst(Type *RetTy, unsigned NumReservedValues,\n                               const Twine &NameStr, Instruction *InsertBefore)\n    : Instruction(RetTy, Instruction::LandingPad, nullptr, 0, InsertBefore) {\n  init(NumReservedValues, NameStr);\n}\n\nLandingPadInst::LandingPadInst(Type *RetTy, unsigned NumReservedValues,\n                               const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : Instruction(RetTy, Instruction::LandingPad, nullptr, 0, InsertAtEnd) {\n  init(NumReservedValues, NameStr);\n}\n\nLandingPadInst::LandingPadInst(const LandingPadInst &LP)\n    : Instruction(LP.getType(), Instruction::LandingPad, nullptr,\n                  LP.getNumOperands()),\n      ReservedSpace(LP.getNumOperands()) {\n  allocHungoffUses(LP.getNumOperands());\n  Use *OL = getOperandList();\n  const Use *InOL = LP.getOperandList();\n  for (unsigned I = 0, E = ReservedSpace; I != E; ++I)\n    OL[I] = InOL[I];\n\n  setCleanup(LP.isCleanup());\n}\n\nLandingPadInst *LandingPadInst::Create(Type *RetTy, unsigned NumReservedClauses,\n                                       const Twine &NameStr,\n                                       Instruction *InsertBefore) {\n  return new LandingPadInst(RetTy, NumReservedClauses, NameStr, InsertBefore);\n}\n\nLandingPadInst *LandingPadInst::Create(Type *RetTy, unsigned NumReservedClauses,\n                                       const Twine &NameStr,\n                                       BasicBlock *InsertAtEnd) {\n  return new LandingPadInst(RetTy, NumReservedClauses, NameStr, InsertAtEnd);\n}\n\nvoid LandingPadInst::init(unsigned NumReservedValues, const Twine &NameStr) {\n  ReservedSpace = NumReservedValues;\n  setNumHungOffUseOperands(0);\n  allocHungoffUses(ReservedSpace);\n  setName(NameStr);\n  setCleanup(false);\n}\n\n/// growOperands - grow operands - This grows the operand list in response to a\n/// push_back style of operation. This grows the number of ops by 2 times.\nvoid LandingPadInst::growOperands(unsigned Size) {\n  unsigned e = getNumOperands();\n  if (ReservedSpace >= e + Size) return;\n  ReservedSpace = (std::max(e, 1U) + Size / 2) * 2;\n  growHungoffUses(ReservedSpace);\n}\n\nvoid LandingPadInst::addClause(Constant *Val) {\n  unsigned OpNo = getNumOperands();\n  growOperands(1);\n  assert(OpNo < ReservedSpace && \"Growing didn't work!\");\n  setNumHungOffUseOperands(getNumOperands() + 1);\n  getOperandList()[OpNo] = Val;\n}\n\n//===----------------------------------------------------------------------===//\n//                        CallBase Implementation\n//===----------------------------------------------------------------------===//\n\nCallBase *CallBase::Create(CallBase *CB, ArrayRef<OperandBundleDef> Bundles,\n                           Instruction *InsertPt) {\n  switch (CB->getOpcode()) {\n  case Instruction::Call:\n    return CallInst::Create(cast<CallInst>(CB), Bundles, InsertPt);\n  case Instruction::Invoke:\n    return InvokeInst::Create(cast<InvokeInst>(CB), Bundles, InsertPt);\n  case Instruction::CallBr:\n    return CallBrInst::Create(cast<CallBrInst>(CB), Bundles, InsertPt);\n  default:\n    llvm_unreachable(\"Unknown CallBase sub-class!\");\n  }\n}\n\nFunction *CallBase::getCaller() { return getParent()->getParent(); }\n\nunsigned CallBase::getNumSubclassExtraOperandsDynamic() const {\n  assert(getOpcode() == Instruction::CallBr && \"Unexpected opcode!\");\n  return cast<CallBrInst>(this)->getNumIndirectDests() + 1;\n}\n\nbool CallBase::isIndirectCall() const {\n  const Value *V = getCalledOperand();\n  if (isa<Function>(V) || isa<Constant>(V))\n    return false;\n  return !isInlineAsm();\n}\n\n/// Tests if this call site must be tail call optimized. Only a CallInst can\n/// be tail call optimized.\nbool CallBase::isMustTailCall() const {\n  if (auto *CI = dyn_cast<CallInst>(this))\n    return CI->isMustTailCall();\n  return false;\n}\n\n/// Tests if this call site is marked as a tail call.\nbool CallBase::isTailCall() const {\n  if (auto *CI = dyn_cast<CallInst>(this))\n    return CI->isTailCall();\n  return false;\n}\n\nIntrinsic::ID CallBase::getIntrinsicID() const {\n  if (auto *F = getCalledFunction())\n    return F->getIntrinsicID();\n  return Intrinsic::not_intrinsic;\n}\n\nbool CallBase::isReturnNonNull() const {\n  if (hasRetAttr(Attribute::NonNull))\n    return true;\n\n  if (getDereferenceableBytes(AttributeList::ReturnIndex) > 0 &&\n           !NullPointerIsDefined(getCaller(),\n                                 getType()->getPointerAddressSpace()))\n    return true;\n\n  return false;\n}\n\nValue *CallBase::getReturnedArgOperand() const {\n  unsigned Index;\n\n  if (Attrs.hasAttrSomewhere(Attribute::Returned, &Index) && Index)\n    return getArgOperand(Index - AttributeList::FirstArgIndex);\n  if (const Function *F = getCalledFunction())\n    if (F->getAttributes().hasAttrSomewhere(Attribute::Returned, &Index) &&\n        Index)\n      return getArgOperand(Index - AttributeList::FirstArgIndex);\n\n  return nullptr;\n}\n\n/// Determine whether the argument or parameter has the given attribute.\nbool CallBase::paramHasAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n  assert(ArgNo < getNumArgOperands() && \"Param index out of bounds!\");\n\n  if (Attrs.hasParamAttribute(ArgNo, Kind))\n    return true;\n  if (const Function *F = getCalledFunction())\n    return F->getAttributes().hasParamAttribute(ArgNo, Kind);\n  return false;\n}\n\nbool CallBase::hasFnAttrOnCalledFunction(Attribute::AttrKind Kind) const {\n  if (const Function *F = getCalledFunction())\n    return F->getAttributes().hasFnAttribute(Kind);\n  return false;\n}\n\nbool CallBase::hasFnAttrOnCalledFunction(StringRef Kind) const {\n  if (const Function *F = getCalledFunction())\n    return F->getAttributes().hasFnAttribute(Kind);\n  return false;\n}\n\nvoid CallBase::getOperandBundlesAsDefs(\n    SmallVectorImpl<OperandBundleDef> &Defs) const {\n  for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)\n    Defs.emplace_back(getOperandBundleAt(i));\n}\n\nCallBase::op_iterator\nCallBase::populateBundleOperandInfos(ArrayRef<OperandBundleDef> Bundles,\n                                     const unsigned BeginIndex) {\n  auto It = op_begin() + BeginIndex;\n  for (auto &B : Bundles)\n    It = std::copy(B.input_begin(), B.input_end(), It);\n\n  auto *ContextImpl = getContext().pImpl;\n  auto BI = Bundles.begin();\n  unsigned CurrentIndex = BeginIndex;\n\n  for (auto &BOI : bundle_op_infos()) {\n    assert(BI != Bundles.end() && \"Incorrect allocation?\");\n\n    BOI.Tag = ContextImpl->getOrInsertBundleTag(BI->getTag());\n    BOI.Begin = CurrentIndex;\n    BOI.End = CurrentIndex + BI->input_size();\n    CurrentIndex = BOI.End;\n    BI++;\n  }\n\n  assert(BI == Bundles.end() && \"Incorrect allocation?\");\n\n  return It;\n}\n\nCallBase::BundleOpInfo &CallBase::getBundleOpInfoForOperand(unsigned OpIdx) {\n  /// When there isn't many bundles, we do a simple linear search.\n  /// Else fallback to a binary-search that use the fact that bundles usually\n  /// have similar number of argument to get faster convergence.\n  if (bundle_op_info_end() - bundle_op_info_begin() < 8) {\n    for (auto &BOI : bundle_op_infos())\n      if (BOI.Begin <= OpIdx && OpIdx < BOI.End)\n        return BOI;\n\n    llvm_unreachable(\"Did not find operand bundle for operand!\");\n  }\n\n  assert(OpIdx >= arg_size() && \"the Idx is not in the operand bundles\");\n  assert(bundle_op_info_end() - bundle_op_info_begin() > 0 &&\n         OpIdx < std::prev(bundle_op_info_end())->End &&\n         \"The Idx isn't in the operand bundle\");\n\n  /// We need a decimal number below and to prevent using floating point numbers\n  /// we use an intergal value multiplied by this constant.\n  constexpr unsigned NumberScaling = 1024;\n\n  bundle_op_iterator Begin = bundle_op_info_begin();\n  bundle_op_iterator End = bundle_op_info_end();\n  bundle_op_iterator Current = Begin;\n\n  while (Begin != End) {\n    unsigned ScaledOperandPerBundle =\n        NumberScaling * (std::prev(End)->End - Begin->Begin) / (End - Begin);\n    Current = Begin + (((OpIdx - Begin->Begin) * NumberScaling) /\n                       ScaledOperandPerBundle);\n    if (Current >= End)\n      Current = std::prev(End);\n    assert(Current < End && Current >= Begin &&\n           \"the operand bundle doesn't cover every value in the range\");\n    if (OpIdx >= Current->Begin && OpIdx < Current->End)\n      break;\n    if (OpIdx >= Current->End)\n      Begin = Current + 1;\n    else\n      End = Current;\n  }\n\n  assert(OpIdx >= Current->Begin && OpIdx < Current->End &&\n         \"the operand bundle doesn't cover every value in the range\");\n  return *Current;\n}\n\nCallBase *CallBase::addOperandBundle(CallBase *CB, uint32_t ID,\n                                     OperandBundleDef OB,\n                                     Instruction *InsertPt) {\n  if (CB->getOperandBundle(ID))\n    return CB;\n\n  SmallVector<OperandBundleDef, 1> Bundles;\n  CB->getOperandBundlesAsDefs(Bundles);\n  Bundles.push_back(OB);\n  return Create(CB, Bundles, InsertPt);\n}\n\nCallBase *CallBase::removeOperandBundle(CallBase *CB, uint32_t ID,\n                                        Instruction *InsertPt) {\n  SmallVector<OperandBundleDef, 1> Bundles;\n  bool CreateNew = false;\n\n  for (unsigned I = 0, E = CB->getNumOperandBundles(); I != E; ++I) {\n    auto Bundle = CB->getOperandBundleAt(I);\n    if (Bundle.getTagID() == ID) {\n      CreateNew = true;\n      continue;\n    }\n    Bundles.emplace_back(Bundle);\n  }\n\n  return CreateNew ? Create(CB, Bundles, InsertPt) : CB;\n}\n\n//===----------------------------------------------------------------------===//\n//                        CallInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid CallInst::init(FunctionType *FTy, Value *Func, ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr) {\n  this->FTy = FTy;\n  assert(getNumOperands() == Args.size() + CountBundleInputs(Bundles) + 1 &&\n         \"NumOperands not set up?\");\n  setCalledOperand(Func);\n\n#ifndef NDEBUG\n  assert((Args.size() == FTy->getNumParams() ||\n          (FTy->isVarArg() && Args.size() > FTy->getNumParams())) &&\n         \"Calling a function with bad signature!\");\n\n  for (unsigned i = 0; i != Args.size(); ++i)\n    assert((i >= FTy->getNumParams() ||\n            FTy->getParamType(i) == Args[i]->getType()) &&\n           \"Calling a function with a bad signature!\");\n#endif\n\n  llvm::copy(Args, op_begin());\n\n  auto It = populateBundleOperandInfos(Bundles, Args.size());\n  (void)It;\n  assert(It + 1 == op_end() && \"Should add up!\");\n\n  setName(NameStr);\n}\n\nvoid CallInst::init(FunctionType *FTy, Value *Func, const Twine &NameStr) {\n  this->FTy = FTy;\n  assert(getNumOperands() == 1 && \"NumOperands not set up?\");\n  setCalledOperand(Func);\n\n  assert(FTy->getNumParams() == 0 && \"Calling a function with bad signature\");\n\n  setName(NameStr);\n}\n\nCallInst::CallInst(FunctionType *Ty, Value *Func, const Twine &Name,\n                   Instruction *InsertBefore)\n    : CallBase(Ty->getReturnType(), Instruction::Call,\n               OperandTraits<CallBase>::op_end(this) - 1, 1, InsertBefore) {\n  init(Ty, Func, Name);\n}\n\nCallInst::CallInst(FunctionType *Ty, Value *Func, const Twine &Name,\n                   BasicBlock *InsertAtEnd)\n    : CallBase(Ty->getReturnType(), Instruction::Call,\n               OperandTraits<CallBase>::op_end(this) - 1, 1, InsertAtEnd) {\n  init(Ty, Func, Name);\n}\n\nCallInst::CallInst(const CallInst &CI)\n    : CallBase(CI.Attrs, CI.FTy, CI.getType(), Instruction::Call,\n               OperandTraits<CallBase>::op_end(this) - CI.getNumOperands(),\n               CI.getNumOperands()) {\n  setTailCallKind(CI.getTailCallKind());\n  setCallingConv(CI.getCallingConv());\n\n  std::copy(CI.op_begin(), CI.op_end(), op_begin());\n  std::copy(CI.bundle_op_info_begin(), CI.bundle_op_info_end(),\n            bundle_op_info_begin());\n  SubclassOptionalData = CI.SubclassOptionalData;\n}\n\nCallInst *CallInst::Create(CallInst *CI, ArrayRef<OperandBundleDef> OpB,\n                           Instruction *InsertPt) {\n  std::vector<Value *> Args(CI->arg_begin(), CI->arg_end());\n\n  auto *NewCI = CallInst::Create(CI->getFunctionType(), CI->getCalledOperand(),\n                                 Args, OpB, CI->getName(), InsertPt);\n  NewCI->setTailCallKind(CI->getTailCallKind());\n  NewCI->setCallingConv(CI->getCallingConv());\n  NewCI->SubclassOptionalData = CI->SubclassOptionalData;\n  NewCI->setAttributes(CI->getAttributes());\n  NewCI->setDebugLoc(CI->getDebugLoc());\n  return NewCI;\n}\n\nCallInst *CallInst::CreateWithReplacedBundle(CallInst *CI, OperandBundleDef OpB,\n                                             Instruction *InsertPt) {\n  SmallVector<OperandBundleDef, 2> OpDefs;\n  for (unsigned i = 0, e = CI->getNumOperandBundles(); i < e; ++i) {\n    auto ChildOB = CI->getOperandBundleAt(i);\n    if (ChildOB.getTagName() != OpB.getTag())\n      OpDefs.emplace_back(ChildOB);\n  }\n  OpDefs.emplace_back(OpB);\n  return CallInst::Create(CI, OpDefs, InsertPt);\n}\n\n// Update profile weight for call instruction by scaling it using the ratio\n// of S/T. The meaning of \"branch_weights\" meta data for call instruction is\n// transfered to represent call count.\nvoid CallInst::updateProfWeight(uint64_t S, uint64_t T) {\n  auto *ProfileData = getMetadata(LLVMContext::MD_prof);\n  if (ProfileData == nullptr)\n    return;\n\n  auto *ProfDataName = dyn_cast<MDString>(ProfileData->getOperand(0));\n  if (!ProfDataName || (!ProfDataName->getString().equals(\"branch_weights\") &&\n                        !ProfDataName->getString().equals(\"VP\")))\n    return;\n\n  if (T == 0) {\n    LLVM_DEBUG(dbgs() << \"Attempting to update profile weights will result in \"\n                         \"div by 0. Ignoring. Likely the function \"\n                      << getParent()->getParent()->getName()\n                      << \" has 0 entry count, and contains call instructions \"\n                         \"with non-zero prof info.\");\n    return;\n  }\n\n  MDBuilder MDB(getContext());\n  SmallVector<Metadata *, 3> Vals;\n  Vals.push_back(ProfileData->getOperand(0));\n  APInt APS(128, S), APT(128, T);\n  if (ProfDataName->getString().equals(\"branch_weights\") &&\n      ProfileData->getNumOperands() > 0) {\n    // Using APInt::div may be expensive, but most cases should fit 64 bits.\n    APInt Val(128, mdconst::dyn_extract<ConstantInt>(ProfileData->getOperand(1))\n                       ->getValue()\n                       .getZExtValue());\n    Val *= APS;\n    Vals.push_back(MDB.createConstant(\n        ConstantInt::get(Type::getInt32Ty(getContext()),\n                         Val.udiv(APT).getLimitedValue(UINT32_MAX))));\n  } else if (ProfDataName->getString().equals(\"VP\"))\n    for (unsigned i = 1; i < ProfileData->getNumOperands(); i += 2) {\n      // The first value is the key of the value profile, which will not change.\n      Vals.push_back(ProfileData->getOperand(i));\n      // Using APInt::div may be expensive, but most cases should fit 64 bits.\n      APInt Val(128,\n                mdconst::dyn_extract<ConstantInt>(ProfileData->getOperand(i + 1))\n                    ->getValue()\n                    .getZExtValue());\n      Val *= APS;\n      Vals.push_back(MDB.createConstant(\n          ConstantInt::get(Type::getInt64Ty(getContext()),\n                           Val.udiv(APT).getLimitedValue())));\n    }\n  setMetadata(LLVMContext::MD_prof, MDNode::get(getContext(), Vals));\n}\n\n/// IsConstantOne - Return true only if val is constant int 1\nstatic bool IsConstantOne(Value *val) {\n  assert(val && \"IsConstantOne does not work with nullptr val\");\n  const ConstantInt *CVal = dyn_cast<ConstantInt>(val);\n  return CVal && CVal->isOne();\n}\n\nstatic Instruction *createMalloc(Instruction *InsertBefore,\n                                 BasicBlock *InsertAtEnd, Type *IntPtrTy,\n                                 Type *AllocTy, Value *AllocSize,\n                                 Value *ArraySize,\n                                 ArrayRef<OperandBundleDef> OpB,\n                                 Function *MallocF, const Twine &Name) {\n  assert(((!InsertBefore && InsertAtEnd) || (InsertBefore && !InsertAtEnd)) &&\n         \"createMalloc needs either InsertBefore or InsertAtEnd\");\n\n  // malloc(type) becomes:\n  //       bitcast (i8* malloc(typeSize)) to type*\n  // malloc(type, arraySize) becomes:\n  //       bitcast (i8* malloc(typeSize*arraySize)) to type*\n  if (!ArraySize)\n    ArraySize = ConstantInt::get(IntPtrTy, 1);\n  else if (ArraySize->getType() != IntPtrTy) {\n    if (InsertBefore)\n      ArraySize = CastInst::CreateIntegerCast(ArraySize, IntPtrTy, false,\n                                              \"\", InsertBefore);\n    else\n      ArraySize = CastInst::CreateIntegerCast(ArraySize, IntPtrTy, false,\n                                              \"\", InsertAtEnd);\n  }\n\n  if (!IsConstantOne(ArraySize)) {\n    if (IsConstantOne(AllocSize)) {\n      AllocSize = ArraySize;         // Operand * 1 = Operand\n    } else if (Constant *CO = dyn_cast<Constant>(ArraySize)) {\n      Constant *Scale = ConstantExpr::getIntegerCast(CO, IntPtrTy,\n                                                     false /*ZExt*/);\n      // Malloc arg is constant product of type size and array size\n      AllocSize = ConstantExpr::getMul(Scale, cast<Constant>(AllocSize));\n    } else {\n      // Multiply type size by the array size...\n      if (InsertBefore)\n        AllocSize = BinaryOperator::CreateMul(ArraySize, AllocSize,\n                                              \"mallocsize\", InsertBefore);\n      else\n        AllocSize = BinaryOperator::CreateMul(ArraySize, AllocSize,\n                                              \"mallocsize\", InsertAtEnd);\n    }\n  }\n\n  assert(AllocSize->getType() == IntPtrTy && \"malloc arg is wrong size\");\n  // Create the call to Malloc.\n  BasicBlock *BB = InsertBefore ? InsertBefore->getParent() : InsertAtEnd;\n  Module *M = BB->getParent()->getParent();\n  Type *BPTy = Type::getInt8PtrTy(BB->getContext());\n  FunctionCallee MallocFunc = MallocF;\n  if (!MallocFunc)\n    // prototype malloc as \"void *malloc(size_t)\"\n    MallocFunc = M->getOrInsertFunction(\"malloc\", BPTy, IntPtrTy);\n  PointerType *AllocPtrType = PointerType::getUnqual(AllocTy);\n  CallInst *MCall = nullptr;\n  Instruction *Result = nullptr;\n  if (InsertBefore) {\n    MCall = CallInst::Create(MallocFunc, AllocSize, OpB, \"malloccall\",\n                             InsertBefore);\n    Result = MCall;\n    if (Result->getType() != AllocPtrType)\n      // Create a cast instruction to convert to the right type...\n      Result = new BitCastInst(MCall, AllocPtrType, Name, InsertBefore);\n  } else {\n    MCall = CallInst::Create(MallocFunc, AllocSize, OpB, \"malloccall\");\n    Result = MCall;\n    if (Result->getType() != AllocPtrType) {\n      InsertAtEnd->getInstList().push_back(MCall);\n      // Create a cast instruction to convert to the right type...\n      Result = new BitCastInst(MCall, AllocPtrType, Name);\n    }\n  }\n  MCall->setTailCall();\n  if (Function *F = dyn_cast<Function>(MallocFunc.getCallee())) {\n    MCall->setCallingConv(F->getCallingConv());\n    if (!F->returnDoesNotAlias())\n      F->setReturnDoesNotAlias();\n  }\n  assert(!MCall->getType()->isVoidTy() && \"Malloc has void return type\");\n\n  return Result;\n}\n\n/// CreateMalloc - Generate the IR for a call to malloc:\n/// 1. Compute the malloc call's argument as the specified type's size,\n///    possibly multiplied by the array size if the array size is not\n///    constant 1.\n/// 2. Call malloc with that argument.\n/// 3. Bitcast the result of the malloc call to the specified type.\nInstruction *CallInst::CreateMalloc(Instruction *InsertBefore,\n                                    Type *IntPtrTy, Type *AllocTy,\n                                    Value *AllocSize, Value *ArraySize,\n                                    Function *MallocF,\n                                    const Twine &Name) {\n  return createMalloc(InsertBefore, nullptr, IntPtrTy, AllocTy, AllocSize,\n                      ArraySize, None, MallocF, Name);\n}\nInstruction *CallInst::CreateMalloc(Instruction *InsertBefore,\n                                    Type *IntPtrTy, Type *AllocTy,\n                                    Value *AllocSize, Value *ArraySize,\n                                    ArrayRef<OperandBundleDef> OpB,\n                                    Function *MallocF,\n                                    const Twine &Name) {\n  return createMalloc(InsertBefore, nullptr, IntPtrTy, AllocTy, AllocSize,\n                      ArraySize, OpB, MallocF, Name);\n}\n\n/// CreateMalloc - Generate the IR for a call to malloc:\n/// 1. Compute the malloc call's argument as the specified type's size,\n///    possibly multiplied by the array size if the array size is not\n///    constant 1.\n/// 2. Call malloc with that argument.\n/// 3. Bitcast the result of the malloc call to the specified type.\n/// Note: This function does not add the bitcast to the basic block, that is the\n/// responsibility of the caller.\nInstruction *CallInst::CreateMalloc(BasicBlock *InsertAtEnd,\n                                    Type *IntPtrTy, Type *AllocTy,\n                                    Value *AllocSize, Value *ArraySize,\n                                    Function *MallocF, const Twine &Name) {\n  return createMalloc(nullptr, InsertAtEnd, IntPtrTy, AllocTy, AllocSize,\n                      ArraySize, None, MallocF, Name);\n}\nInstruction *CallInst::CreateMalloc(BasicBlock *InsertAtEnd,\n                                    Type *IntPtrTy, Type *AllocTy,\n                                    Value *AllocSize, Value *ArraySize,\n                                    ArrayRef<OperandBundleDef> OpB,\n                                    Function *MallocF, const Twine &Name) {\n  return createMalloc(nullptr, InsertAtEnd, IntPtrTy, AllocTy, AllocSize,\n                      ArraySize, OpB, MallocF, Name);\n}\n\nstatic Instruction *createFree(Value *Source,\n                               ArrayRef<OperandBundleDef> Bundles,\n                               Instruction *InsertBefore,\n                               BasicBlock *InsertAtEnd) {\n  assert(((!InsertBefore && InsertAtEnd) || (InsertBefore && !InsertAtEnd)) &&\n         \"createFree needs either InsertBefore or InsertAtEnd\");\n  assert(Source->getType()->isPointerTy() &&\n         \"Can not free something of nonpointer type!\");\n\n  BasicBlock *BB = InsertBefore ? InsertBefore->getParent() : InsertAtEnd;\n  Module *M = BB->getParent()->getParent();\n\n  Type *VoidTy = Type::getVoidTy(M->getContext());\n  Type *IntPtrTy = Type::getInt8PtrTy(M->getContext());\n  // prototype free as \"void free(void*)\"\n  FunctionCallee FreeFunc = M->getOrInsertFunction(\"free\", VoidTy, IntPtrTy);\n  CallInst *Result = nullptr;\n  Value *PtrCast = Source;\n  if (InsertBefore) {\n    if (Source->getType() != IntPtrTy)\n      PtrCast = new BitCastInst(Source, IntPtrTy, \"\", InsertBefore);\n    Result = CallInst::Create(FreeFunc, PtrCast, Bundles, \"\", InsertBefore);\n  } else {\n    if (Source->getType() != IntPtrTy)\n      PtrCast = new BitCastInst(Source, IntPtrTy, \"\", InsertAtEnd);\n    Result = CallInst::Create(FreeFunc, PtrCast, Bundles, \"\");\n  }\n  Result->setTailCall();\n  if (Function *F = dyn_cast<Function>(FreeFunc.getCallee()))\n    Result->setCallingConv(F->getCallingConv());\n\n  return Result;\n}\n\n/// CreateFree - Generate the IR for a call to the builtin free function.\nInstruction *CallInst::CreateFree(Value *Source, Instruction *InsertBefore) {\n  return createFree(Source, None, InsertBefore, nullptr);\n}\nInstruction *CallInst::CreateFree(Value *Source,\n                                  ArrayRef<OperandBundleDef> Bundles,\n                                  Instruction *InsertBefore) {\n  return createFree(Source, Bundles, InsertBefore, nullptr);\n}\n\n/// CreateFree - Generate the IR for a call to the builtin free function.\n/// Note: This function does not add the call to the basic block, that is the\n/// responsibility of the caller.\nInstruction *CallInst::CreateFree(Value *Source, BasicBlock *InsertAtEnd) {\n  Instruction *FreeCall = createFree(Source, None, nullptr, InsertAtEnd);\n  assert(FreeCall && \"CreateFree did not create a CallInst\");\n  return FreeCall;\n}\nInstruction *CallInst::CreateFree(Value *Source,\n                                  ArrayRef<OperandBundleDef> Bundles,\n                                  BasicBlock *InsertAtEnd) {\n  Instruction *FreeCall = createFree(Source, Bundles, nullptr, InsertAtEnd);\n  assert(FreeCall && \"CreateFree did not create a CallInst\");\n  return FreeCall;\n}\n\n//===----------------------------------------------------------------------===//\n//                        InvokeInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid InvokeInst::init(FunctionType *FTy, Value *Fn, BasicBlock *IfNormal,\n                      BasicBlock *IfException, ArrayRef<Value *> Args,\n                      ArrayRef<OperandBundleDef> Bundles,\n                      const Twine &NameStr) {\n  this->FTy = FTy;\n\n  assert((int)getNumOperands() ==\n             ComputeNumOperands(Args.size(), CountBundleInputs(Bundles)) &&\n         \"NumOperands not set up?\");\n  setNormalDest(IfNormal);\n  setUnwindDest(IfException);\n  setCalledOperand(Fn);\n\n#ifndef NDEBUG\n  assert(((Args.size() == FTy->getNumParams()) ||\n          (FTy->isVarArg() && Args.size() > FTy->getNumParams())) &&\n         \"Invoking a function with bad signature\");\n\n  for (unsigned i = 0, e = Args.size(); i != e; i++)\n    assert((i >= FTy->getNumParams() ||\n            FTy->getParamType(i) == Args[i]->getType()) &&\n           \"Invoking a function with a bad signature!\");\n#endif\n\n  llvm::copy(Args, op_begin());\n\n  auto It = populateBundleOperandInfos(Bundles, Args.size());\n  (void)It;\n  assert(It + 3 == op_end() && \"Should add up!\");\n\n  setName(NameStr);\n}\n\nInvokeInst::InvokeInst(const InvokeInst &II)\n    : CallBase(II.Attrs, II.FTy, II.getType(), Instruction::Invoke,\n               OperandTraits<CallBase>::op_end(this) - II.getNumOperands(),\n               II.getNumOperands()) {\n  setCallingConv(II.getCallingConv());\n  std::copy(II.op_begin(), II.op_end(), op_begin());\n  std::copy(II.bundle_op_info_begin(), II.bundle_op_info_end(),\n            bundle_op_info_begin());\n  SubclassOptionalData = II.SubclassOptionalData;\n}\n\nInvokeInst *InvokeInst::Create(InvokeInst *II, ArrayRef<OperandBundleDef> OpB,\n                               Instruction *InsertPt) {\n  std::vector<Value *> Args(II->arg_begin(), II->arg_end());\n\n  auto *NewII = InvokeInst::Create(\n      II->getFunctionType(), II->getCalledOperand(), II->getNormalDest(),\n      II->getUnwindDest(), Args, OpB, II->getName(), InsertPt);\n  NewII->setCallingConv(II->getCallingConv());\n  NewII->SubclassOptionalData = II->SubclassOptionalData;\n  NewII->setAttributes(II->getAttributes());\n  NewII->setDebugLoc(II->getDebugLoc());\n  return NewII;\n}\n\nInvokeInst *InvokeInst::CreateWithReplacedBundle(InvokeInst *II,\n                                                 OperandBundleDef OpB,\n                                                 Instruction *InsertPt) {\n  SmallVector<OperandBundleDef, 2> OpDefs;\n  for (unsigned i = 0, e = II->getNumOperandBundles(); i < e; ++i) {\n    auto ChildOB = II->getOperandBundleAt(i);\n    if (ChildOB.getTagName() != OpB.getTag())\n      OpDefs.emplace_back(ChildOB);\n  }\n  OpDefs.emplace_back(OpB);\n  return InvokeInst::Create(II, OpDefs, InsertPt);\n}\n\nLandingPadInst *InvokeInst::getLandingPadInst() const {\n  return cast<LandingPadInst>(getUnwindDest()->getFirstNonPHI());\n}\n\n//===----------------------------------------------------------------------===//\n//                        CallBrInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid CallBrInst::init(FunctionType *FTy, Value *Fn, BasicBlock *Fallthrough,\n                      ArrayRef<BasicBlock *> IndirectDests,\n                      ArrayRef<Value *> Args,\n                      ArrayRef<OperandBundleDef> Bundles,\n                      const Twine &NameStr) {\n  this->FTy = FTy;\n\n  assert((int)getNumOperands() ==\n             ComputeNumOperands(Args.size(), IndirectDests.size(),\n                                CountBundleInputs(Bundles)) &&\n         \"NumOperands not set up?\");\n  NumIndirectDests = IndirectDests.size();\n  setDefaultDest(Fallthrough);\n  for (unsigned i = 0; i != NumIndirectDests; ++i)\n    setIndirectDest(i, IndirectDests[i]);\n  setCalledOperand(Fn);\n\n#ifndef NDEBUG\n  assert(((Args.size() == FTy->getNumParams()) ||\n          (FTy->isVarArg() && Args.size() > FTy->getNumParams())) &&\n         \"Calling a function with bad signature\");\n\n  for (unsigned i = 0, e = Args.size(); i != e; i++)\n    assert((i >= FTy->getNumParams() ||\n            FTy->getParamType(i) == Args[i]->getType()) &&\n           \"Calling a function with a bad signature!\");\n#endif\n\n  std::copy(Args.begin(), Args.end(), op_begin());\n\n  auto It = populateBundleOperandInfos(Bundles, Args.size());\n  (void)It;\n  assert(It + 2 + IndirectDests.size() == op_end() && \"Should add up!\");\n\n  setName(NameStr);\n}\n\nvoid CallBrInst::updateArgBlockAddresses(unsigned i, BasicBlock *B) {\n  assert(getNumIndirectDests() > i && \"IndirectDest # out of range for callbr\");\n  if (BasicBlock *OldBB = getIndirectDest(i)) {\n    BlockAddress *Old = BlockAddress::get(OldBB);\n    BlockAddress *New = BlockAddress::get(B);\n    for (unsigned ArgNo = 0, e = getNumArgOperands(); ArgNo != e; ++ArgNo)\n      if (dyn_cast<BlockAddress>(getArgOperand(ArgNo)) == Old)\n        setArgOperand(ArgNo, New);\n  }\n}\n\nCallBrInst::CallBrInst(const CallBrInst &CBI)\n    : CallBase(CBI.Attrs, CBI.FTy, CBI.getType(), Instruction::CallBr,\n               OperandTraits<CallBase>::op_end(this) - CBI.getNumOperands(),\n               CBI.getNumOperands()) {\n  setCallingConv(CBI.getCallingConv());\n  std::copy(CBI.op_begin(), CBI.op_end(), op_begin());\n  std::copy(CBI.bundle_op_info_begin(), CBI.bundle_op_info_end(),\n            bundle_op_info_begin());\n  SubclassOptionalData = CBI.SubclassOptionalData;\n  NumIndirectDests = CBI.NumIndirectDests;\n}\n\nCallBrInst *CallBrInst::Create(CallBrInst *CBI, ArrayRef<OperandBundleDef> OpB,\n                               Instruction *InsertPt) {\n  std::vector<Value *> Args(CBI->arg_begin(), CBI->arg_end());\n\n  auto *NewCBI = CallBrInst::Create(\n      CBI->getFunctionType(), CBI->getCalledOperand(), CBI->getDefaultDest(),\n      CBI->getIndirectDests(), Args, OpB, CBI->getName(), InsertPt);\n  NewCBI->setCallingConv(CBI->getCallingConv());\n  NewCBI->SubclassOptionalData = CBI->SubclassOptionalData;\n  NewCBI->setAttributes(CBI->getAttributes());\n  NewCBI->setDebugLoc(CBI->getDebugLoc());\n  NewCBI->NumIndirectDests = CBI->NumIndirectDests;\n  return NewCBI;\n}\n\n//===----------------------------------------------------------------------===//\n//                        ReturnInst Implementation\n//===----------------------------------------------------------------------===//\n\nReturnInst::ReturnInst(const ReturnInst &RI)\n    : Instruction(Type::getVoidTy(RI.getContext()), Instruction::Ret,\n                  OperandTraits<ReturnInst>::op_end(this) - RI.getNumOperands(),\n                  RI.getNumOperands()) {\n  if (RI.getNumOperands())\n    Op<0>() = RI.Op<0>();\n  SubclassOptionalData = RI.SubclassOptionalData;\n}\n\nReturnInst::ReturnInst(LLVMContext &C, Value *retVal, Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(C), Instruction::Ret,\n                  OperandTraits<ReturnInst>::op_end(this) - !!retVal, !!retVal,\n                  InsertBefore) {\n  if (retVal)\n    Op<0>() = retVal;\n}\n\nReturnInst::ReturnInst(LLVMContext &C, Value *retVal, BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(C), Instruction::Ret,\n                  OperandTraits<ReturnInst>::op_end(this) - !!retVal, !!retVal,\n                  InsertAtEnd) {\n  if (retVal)\n    Op<0>() = retVal;\n}\n\nReturnInst::ReturnInst(LLVMContext &Context, BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(Context), Instruction::Ret,\n                  OperandTraits<ReturnInst>::op_end(this), 0, InsertAtEnd) {}\n\n//===----------------------------------------------------------------------===//\n//                        ResumeInst Implementation\n//===----------------------------------------------------------------------===//\n\nResumeInst::ResumeInst(const ResumeInst &RI)\n    : Instruction(Type::getVoidTy(RI.getContext()), Instruction::Resume,\n                  OperandTraits<ResumeInst>::op_begin(this), 1) {\n  Op<0>() = RI.Op<0>();\n}\n\nResumeInst::ResumeInst(Value *Exn, Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(Exn->getContext()), Instruction::Resume,\n                  OperandTraits<ResumeInst>::op_begin(this), 1, InsertBefore) {\n  Op<0>() = Exn;\n}\n\nResumeInst::ResumeInst(Value *Exn, BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(Exn->getContext()), Instruction::Resume,\n                  OperandTraits<ResumeInst>::op_begin(this), 1, InsertAtEnd) {\n  Op<0>() = Exn;\n}\n\n//===----------------------------------------------------------------------===//\n//                        CleanupReturnInst Implementation\n//===----------------------------------------------------------------------===//\n\nCleanupReturnInst::CleanupReturnInst(const CleanupReturnInst &CRI)\n    : Instruction(CRI.getType(), Instruction::CleanupRet,\n                  OperandTraits<CleanupReturnInst>::op_end(this) -\n                      CRI.getNumOperands(),\n                  CRI.getNumOperands()) {\n  setSubclassData<Instruction::OpaqueField>(\n      CRI.getSubclassData<Instruction::OpaqueField>());\n  Op<0>() = CRI.Op<0>();\n  if (CRI.hasUnwindDest())\n    Op<1>() = CRI.Op<1>();\n}\n\nvoid CleanupReturnInst::init(Value *CleanupPad, BasicBlock *UnwindBB) {\n  if (UnwindBB)\n    setSubclassData<UnwindDestField>(true);\n\n  Op<0>() = CleanupPad;\n  if (UnwindBB)\n    Op<1>() = UnwindBB;\n}\n\nCleanupReturnInst::CleanupReturnInst(Value *CleanupPad, BasicBlock *UnwindBB,\n                                     unsigned Values, Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(CleanupPad->getContext()),\n                  Instruction::CleanupRet,\n                  OperandTraits<CleanupReturnInst>::op_end(this) - Values,\n                  Values, InsertBefore) {\n  init(CleanupPad, UnwindBB);\n}\n\nCleanupReturnInst::CleanupReturnInst(Value *CleanupPad, BasicBlock *UnwindBB,\n                                     unsigned Values, BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(CleanupPad->getContext()),\n                  Instruction::CleanupRet,\n                  OperandTraits<CleanupReturnInst>::op_end(this) - Values,\n                  Values, InsertAtEnd) {\n  init(CleanupPad, UnwindBB);\n}\n\n//===----------------------------------------------------------------------===//\n//                        CatchReturnInst Implementation\n//===----------------------------------------------------------------------===//\nvoid CatchReturnInst::init(Value *CatchPad, BasicBlock *BB) {\n  Op<0>() = CatchPad;\n  Op<1>() = BB;\n}\n\nCatchReturnInst::CatchReturnInst(const CatchReturnInst &CRI)\n    : Instruction(Type::getVoidTy(CRI.getContext()), Instruction::CatchRet,\n                  OperandTraits<CatchReturnInst>::op_begin(this), 2) {\n  Op<0>() = CRI.Op<0>();\n  Op<1>() = CRI.Op<1>();\n}\n\nCatchReturnInst::CatchReturnInst(Value *CatchPad, BasicBlock *BB,\n                                 Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(BB->getContext()), Instruction::CatchRet,\n                  OperandTraits<CatchReturnInst>::op_begin(this), 2,\n                  InsertBefore) {\n  init(CatchPad, BB);\n}\n\nCatchReturnInst::CatchReturnInst(Value *CatchPad, BasicBlock *BB,\n                                 BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(BB->getContext()), Instruction::CatchRet,\n                  OperandTraits<CatchReturnInst>::op_begin(this), 2,\n                  InsertAtEnd) {\n  init(CatchPad, BB);\n}\n\n//===----------------------------------------------------------------------===//\n//                       CatchSwitchInst Implementation\n//===----------------------------------------------------------------------===//\n\nCatchSwitchInst::CatchSwitchInst(Value *ParentPad, BasicBlock *UnwindDest,\n                                 unsigned NumReservedValues,\n                                 const Twine &NameStr,\n                                 Instruction *InsertBefore)\n    : Instruction(ParentPad->getType(), Instruction::CatchSwitch, nullptr, 0,\n                  InsertBefore) {\n  if (UnwindDest)\n    ++NumReservedValues;\n  init(ParentPad, UnwindDest, NumReservedValues + 1);\n  setName(NameStr);\n}\n\nCatchSwitchInst::CatchSwitchInst(Value *ParentPad, BasicBlock *UnwindDest,\n                                 unsigned NumReservedValues,\n                                 const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : Instruction(ParentPad->getType(), Instruction::CatchSwitch, nullptr, 0,\n                  InsertAtEnd) {\n  if (UnwindDest)\n    ++NumReservedValues;\n  init(ParentPad, UnwindDest, NumReservedValues + 1);\n  setName(NameStr);\n}\n\nCatchSwitchInst::CatchSwitchInst(const CatchSwitchInst &CSI)\n    : Instruction(CSI.getType(), Instruction::CatchSwitch, nullptr,\n                  CSI.getNumOperands()) {\n  init(CSI.getParentPad(), CSI.getUnwindDest(), CSI.getNumOperands());\n  setNumHungOffUseOperands(ReservedSpace);\n  Use *OL = getOperandList();\n  const Use *InOL = CSI.getOperandList();\n  for (unsigned I = 1, E = ReservedSpace; I != E; ++I)\n    OL[I] = InOL[I];\n}\n\nvoid CatchSwitchInst::init(Value *ParentPad, BasicBlock *UnwindDest,\n                           unsigned NumReservedValues) {\n  assert(ParentPad && NumReservedValues);\n\n  ReservedSpace = NumReservedValues;\n  setNumHungOffUseOperands(UnwindDest ? 2 : 1);\n  allocHungoffUses(ReservedSpace);\n\n  Op<0>() = ParentPad;\n  if (UnwindDest) {\n    setSubclassData<UnwindDestField>(true);\n    setUnwindDest(UnwindDest);\n  }\n}\n\n/// growOperands - grow operands - This grows the operand list in response to a\n/// push_back style of operation. This grows the number of ops by 2 times.\nvoid CatchSwitchInst::growOperands(unsigned Size) {\n  unsigned NumOperands = getNumOperands();\n  assert(NumOperands >= 1);\n  if (ReservedSpace >= NumOperands + Size)\n    return;\n  ReservedSpace = (NumOperands + Size / 2) * 2;\n  growHungoffUses(ReservedSpace);\n}\n\nvoid CatchSwitchInst::addHandler(BasicBlock *Handler) {\n  unsigned OpNo = getNumOperands();\n  growOperands(1);\n  assert(OpNo < ReservedSpace && \"Growing didn't work!\");\n  setNumHungOffUseOperands(getNumOperands() + 1);\n  getOperandList()[OpNo] = Handler;\n}\n\nvoid CatchSwitchInst::removeHandler(handler_iterator HI) {\n  // Move all subsequent handlers up one.\n  Use *EndDst = op_end() - 1;\n  for (Use *CurDst = HI.getCurrent(); CurDst != EndDst; ++CurDst)\n    *CurDst = *(CurDst + 1);\n  // Null out the last handler use.\n  *EndDst = nullptr;\n\n  setNumHungOffUseOperands(getNumOperands() - 1);\n}\n\n//===----------------------------------------------------------------------===//\n//                        FuncletPadInst Implementation\n//===----------------------------------------------------------------------===//\nvoid FuncletPadInst::init(Value *ParentPad, ArrayRef<Value *> Args,\n                          const Twine &NameStr) {\n  assert(getNumOperands() == 1 + Args.size() && \"NumOperands not set up?\");\n  llvm::copy(Args, op_begin());\n  setParentPad(ParentPad);\n  setName(NameStr);\n}\n\nFuncletPadInst::FuncletPadInst(const FuncletPadInst &FPI)\n    : Instruction(FPI.getType(), FPI.getOpcode(),\n                  OperandTraits<FuncletPadInst>::op_end(this) -\n                      FPI.getNumOperands(),\n                  FPI.getNumOperands()) {\n  std::copy(FPI.op_begin(), FPI.op_end(), op_begin());\n  setParentPad(FPI.getParentPad());\n}\n\nFuncletPadInst::FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,\n                               ArrayRef<Value *> Args, unsigned Values,\n                               const Twine &NameStr, Instruction *InsertBefore)\n    : Instruction(ParentPad->getType(), Op,\n                  OperandTraits<FuncletPadInst>::op_end(this) - Values, Values,\n                  InsertBefore) {\n  init(ParentPad, Args, NameStr);\n}\n\nFuncletPadInst::FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,\n                               ArrayRef<Value *> Args, unsigned Values,\n                               const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : Instruction(ParentPad->getType(), Op,\n                  OperandTraits<FuncletPadInst>::op_end(this) - Values, Values,\n                  InsertAtEnd) {\n  init(ParentPad, Args, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                      UnreachableInst Implementation\n//===----------------------------------------------------------------------===//\n\nUnreachableInst::UnreachableInst(LLVMContext &Context,\n                                 Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(Context), Instruction::Unreachable, nullptr,\n                  0, InsertBefore) {}\nUnreachableInst::UnreachableInst(LLVMContext &Context, BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(Context), Instruction::Unreachable, nullptr,\n                  0, InsertAtEnd) {}\n\n//===----------------------------------------------------------------------===//\n//                        BranchInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid BranchInst::AssertOK() {\n  if (isConditional())\n    assert(getCondition()->getType()->isIntegerTy(1) &&\n           \"May only branch on boolean predicates!\");\n}\n\nBranchInst::BranchInst(BasicBlock *IfTrue, Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(IfTrue->getContext()), Instruction::Br,\n                  OperandTraits<BranchInst>::op_end(this) - 1, 1,\n                  InsertBefore) {\n  assert(IfTrue && \"Branch destination may not be null!\");\n  Op<-1>() = IfTrue;\n}\n\nBranchInst::BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,\n                       Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(IfTrue->getContext()), Instruction::Br,\n                  OperandTraits<BranchInst>::op_end(this) - 3, 3,\n                  InsertBefore) {\n  Op<-1>() = IfTrue;\n  Op<-2>() = IfFalse;\n  Op<-3>() = Cond;\n#ifndef NDEBUG\n  AssertOK();\n#endif\n}\n\nBranchInst::BranchInst(BasicBlock *IfTrue, BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(IfTrue->getContext()), Instruction::Br,\n                  OperandTraits<BranchInst>::op_end(this) - 1, 1, InsertAtEnd) {\n  assert(IfTrue && \"Branch destination may not be null!\");\n  Op<-1>() = IfTrue;\n}\n\nBranchInst::BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,\n                       BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(IfTrue->getContext()), Instruction::Br,\n                  OperandTraits<BranchInst>::op_end(this) - 3, 3, InsertAtEnd) {\n  Op<-1>() = IfTrue;\n  Op<-2>() = IfFalse;\n  Op<-3>() = Cond;\n#ifndef NDEBUG\n  AssertOK();\n#endif\n}\n\nBranchInst::BranchInst(const BranchInst &BI)\n    : Instruction(Type::getVoidTy(BI.getContext()), Instruction::Br,\n                  OperandTraits<BranchInst>::op_end(this) - BI.getNumOperands(),\n                  BI.getNumOperands()) {\n  Op<-1>() = BI.Op<-1>();\n  if (BI.getNumOperands() != 1) {\n    assert(BI.getNumOperands() == 3 && \"BR can have 1 or 3 operands!\");\n    Op<-3>() = BI.Op<-3>();\n    Op<-2>() = BI.Op<-2>();\n  }\n  SubclassOptionalData = BI.SubclassOptionalData;\n}\n\nvoid BranchInst::swapSuccessors() {\n  assert(isConditional() &&\n         \"Cannot swap successors of an unconditional branch\");\n  Op<-1>().swap(Op<-2>());\n\n  // Update profile metadata if present and it matches our structural\n  // expectations.\n  swapProfMetadata();\n}\n\n//===----------------------------------------------------------------------===//\n//                        AllocaInst Implementation\n//===----------------------------------------------------------------------===//\n\nstatic Value *getAISize(LLVMContext &Context, Value *Amt) {\n  if (!Amt)\n    Amt = ConstantInt::get(Type::getInt32Ty(Context), 1);\n  else {\n    assert(!isa<BasicBlock>(Amt) &&\n           \"Passed basic block into allocation size parameter! Use other ctor\");\n    assert(Amt->getType()->isIntegerTy() &&\n           \"Allocation array size is not an integer!\");\n  }\n  return Amt;\n}\n\nstatic Align computeAllocaDefaultAlign(Type *Ty, BasicBlock *BB) {\n  assert(BB && \"Insertion BB cannot be null when alignment not provided!\");\n  assert(BB->getParent() &&\n         \"BB must be in a Function when alignment not provided!\");\n  const DataLayout &DL = BB->getModule()->getDataLayout();\n  return DL.getPrefTypeAlign(Ty);\n}\n\nstatic Align computeAllocaDefaultAlign(Type *Ty, Instruction *I) {\n  assert(I && \"Insertion position cannot be null when alignment not provided!\");\n  return computeAllocaDefaultAlign(Ty, I->getParent());\n}\n\nAllocaInst::AllocaInst(Type *Ty, unsigned AddrSpace, const Twine &Name,\n                       Instruction *InsertBefore)\n  : AllocaInst(Ty, AddrSpace, /*ArraySize=*/nullptr, Name, InsertBefore) {}\n\nAllocaInst::AllocaInst(Type *Ty, unsigned AddrSpace, const Twine &Name,\n                       BasicBlock *InsertAtEnd)\n  : AllocaInst(Ty, AddrSpace, /*ArraySize=*/nullptr, Name, InsertAtEnd) {}\n\nAllocaInst::AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize,\n                       const Twine &Name, Instruction *InsertBefore)\n    : AllocaInst(Ty, AddrSpace, ArraySize,\n                 computeAllocaDefaultAlign(Ty, InsertBefore), Name,\n                 InsertBefore) {}\n\nAllocaInst::AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize,\n                       const Twine &Name, BasicBlock *InsertAtEnd)\n    : AllocaInst(Ty, AddrSpace, ArraySize,\n                 computeAllocaDefaultAlign(Ty, InsertAtEnd), Name,\n                 InsertAtEnd) {}\n\nAllocaInst::AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize,\n                       Align Align, const Twine &Name,\n                       Instruction *InsertBefore)\n    : UnaryInstruction(PointerType::get(Ty, AddrSpace), Alloca,\n                       getAISize(Ty->getContext(), ArraySize), InsertBefore),\n      AllocatedType(Ty) {\n  setAlignment(Align);\n  assert(!Ty->isVoidTy() && \"Cannot allocate void!\");\n  setName(Name);\n}\n\nAllocaInst::AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize,\n                       Align Align, const Twine &Name, BasicBlock *InsertAtEnd)\n    : UnaryInstruction(PointerType::get(Ty, AddrSpace), Alloca,\n                       getAISize(Ty->getContext(), ArraySize), InsertAtEnd),\n      AllocatedType(Ty) {\n  setAlignment(Align);\n  assert(!Ty->isVoidTy() && \"Cannot allocate void!\");\n  setName(Name);\n}\n\n\nbool AllocaInst::isArrayAllocation() const {\n  if (ConstantInt *CI = dyn_cast<ConstantInt>(getOperand(0)))\n    return !CI->isOne();\n  return true;\n}\n\n/// isStaticAlloca - Return true if this alloca is in the entry block of the\n/// function and is a constant size.  If so, the code generator will fold it\n/// into the prolog/epilog code, so it is basically free.\nbool AllocaInst::isStaticAlloca() const {\n  // Must be constant size.\n  if (!isa<ConstantInt>(getArraySize())) return false;\n\n  // Must be in the entry block.\n  const BasicBlock *Parent = getParent();\n  return Parent == &Parent->getParent()->front() && !isUsedWithInAlloca();\n}\n\n//===----------------------------------------------------------------------===//\n//                           LoadInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid LoadInst::AssertOK() {\n  assert(getOperand(0)->getType()->isPointerTy() &&\n         \"Ptr must have pointer type.\");\n  assert(!(isAtomic() && getAlignment() == 0) &&\n         \"Alignment required for atomic load\");\n}\n\nstatic Align computeLoadStoreDefaultAlign(Type *Ty, BasicBlock *BB) {\n  assert(BB && \"Insertion BB cannot be null when alignment not provided!\");\n  assert(BB->getParent() &&\n         \"BB must be in a Function when alignment not provided!\");\n  const DataLayout &DL = BB->getModule()->getDataLayout();\n  return DL.getABITypeAlign(Ty);\n}\n\nstatic Align computeLoadStoreDefaultAlign(Type *Ty, Instruction *I) {\n  assert(I && \"Insertion position cannot be null when alignment not provided!\");\n  return computeLoadStoreDefaultAlign(Ty, I->getParent());\n}\n\nLoadInst::LoadInst(Type *Ty, Value *Ptr, const Twine &Name,\n                   Instruction *InsertBef)\n    : LoadInst(Ty, Ptr, Name, /*isVolatile=*/false, InsertBef) {}\n\nLoadInst::LoadInst(Type *Ty, Value *Ptr, const Twine &Name,\n                   BasicBlock *InsertAE)\n    : LoadInst(Ty, Ptr, Name, /*isVolatile=*/false, InsertAE) {}\n\nLoadInst::LoadInst(Type *Ty, Value *Ptr, const Twine &Name, bool isVolatile,\n                   Instruction *InsertBef)\n    : LoadInst(Ty, Ptr, Name, isVolatile,\n               computeLoadStoreDefaultAlign(Ty, InsertBef), InsertBef) {}\n\nLoadInst::LoadInst(Type *Ty, Value *Ptr, const Twine &Name, bool isVolatile,\n                   BasicBlock *InsertAE)\n    : LoadInst(Ty, Ptr, Name, isVolatile,\n               computeLoadStoreDefaultAlign(Ty, InsertAE), InsertAE) {}\n\nLoadInst::LoadInst(Type *Ty, Value *Ptr, const Twine &Name, bool isVolatile,\n                   Align Align, Instruction *InsertBef)\n    : LoadInst(Ty, Ptr, Name, isVolatile, Align, AtomicOrdering::NotAtomic,\n               SyncScope::System, InsertBef) {}\n\nLoadInst::LoadInst(Type *Ty, Value *Ptr, const Twine &Name, bool isVolatile,\n                   Align Align, BasicBlock *InsertAE)\n    : LoadInst(Ty, Ptr, Name, isVolatile, Align, AtomicOrdering::NotAtomic,\n               SyncScope::System, InsertAE) {}\n\nLoadInst::LoadInst(Type *Ty, Value *Ptr, const Twine &Name, bool isVolatile,\n                   Align Align, AtomicOrdering Order, SyncScope::ID SSID,\n                   Instruction *InsertBef)\n    : UnaryInstruction(Ty, Load, Ptr, InsertBef) {\n  assert(Ty == cast<PointerType>(Ptr->getType())->getElementType());\n  setVolatile(isVolatile);\n  setAlignment(Align);\n  setAtomic(Order, SSID);\n  AssertOK();\n  setName(Name);\n}\n\nLoadInst::LoadInst(Type *Ty, Value *Ptr, const Twine &Name, bool isVolatile,\n                   Align Align, AtomicOrdering Order, SyncScope::ID SSID,\n                   BasicBlock *InsertAE)\n    : UnaryInstruction(Ty, Load, Ptr, InsertAE) {\n  assert(Ty == cast<PointerType>(Ptr->getType())->getElementType());\n  setVolatile(isVolatile);\n  setAlignment(Align);\n  setAtomic(Order, SSID);\n  AssertOK();\n  setName(Name);\n}\n\n//===----------------------------------------------------------------------===//\n//                           StoreInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid StoreInst::AssertOK() {\n  assert(getOperand(0) && getOperand(1) && \"Both operands must be non-null!\");\n  assert(getOperand(1)->getType()->isPointerTy() &&\n         \"Ptr must have pointer type!\");\n  assert(getOperand(0)->getType() ==\n                 cast<PointerType>(getOperand(1)->getType())->getElementType()\n         && \"Ptr must be a pointer to Val type!\");\n  assert(!(isAtomic() && getAlignment() == 0) &&\n         \"Alignment required for atomic store\");\n}\n\nStoreInst::StoreInst(Value *val, Value *addr, Instruction *InsertBefore)\n    : StoreInst(val, addr, /*isVolatile=*/false, InsertBefore) {}\n\nStoreInst::StoreInst(Value *val, Value *addr, BasicBlock *InsertAtEnd)\n    : StoreInst(val, addr, /*isVolatile=*/false, InsertAtEnd) {}\n\nStoreInst::StoreInst(Value *val, Value *addr, bool isVolatile,\n                     Instruction *InsertBefore)\n    : StoreInst(val, addr, isVolatile,\n                computeLoadStoreDefaultAlign(val->getType(), InsertBefore),\n                InsertBefore) {}\n\nStoreInst::StoreInst(Value *val, Value *addr, bool isVolatile,\n                     BasicBlock *InsertAtEnd)\n    : StoreInst(val, addr, isVolatile,\n                computeLoadStoreDefaultAlign(val->getType(), InsertAtEnd),\n                InsertAtEnd) {}\n\nStoreInst::StoreInst(Value *val, Value *addr, bool isVolatile, Align Align,\n                     Instruction *InsertBefore)\n    : StoreInst(val, addr, isVolatile, Align, AtomicOrdering::NotAtomic,\n                SyncScope::System, InsertBefore) {}\n\nStoreInst::StoreInst(Value *val, Value *addr, bool isVolatile, Align Align,\n                     BasicBlock *InsertAtEnd)\n    : StoreInst(val, addr, isVolatile, Align, AtomicOrdering::NotAtomic,\n                SyncScope::System, InsertAtEnd) {}\n\nStoreInst::StoreInst(Value *val, Value *addr, bool isVolatile, Align Align,\n                     AtomicOrdering Order, SyncScope::ID SSID,\n                     Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(val->getContext()), Store,\n                  OperandTraits<StoreInst>::op_begin(this),\n                  OperandTraits<StoreInst>::operands(this), InsertBefore) {\n  Op<0>() = val;\n  Op<1>() = addr;\n  setVolatile(isVolatile);\n  setAlignment(Align);\n  setAtomic(Order, SSID);\n  AssertOK();\n}\n\nStoreInst::StoreInst(Value *val, Value *addr, bool isVolatile, Align Align,\n                     AtomicOrdering Order, SyncScope::ID SSID,\n                     BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(val->getContext()), Store,\n                  OperandTraits<StoreInst>::op_begin(this),\n                  OperandTraits<StoreInst>::operands(this), InsertAtEnd) {\n  Op<0>() = val;\n  Op<1>() = addr;\n  setVolatile(isVolatile);\n  setAlignment(Align);\n  setAtomic(Order, SSID);\n  AssertOK();\n}\n\n\n//===----------------------------------------------------------------------===//\n//                       AtomicCmpXchgInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid AtomicCmpXchgInst::Init(Value *Ptr, Value *Cmp, Value *NewVal,\n                             Align Alignment, AtomicOrdering SuccessOrdering,\n                             AtomicOrdering FailureOrdering,\n                             SyncScope::ID SSID) {\n  Op<0>() = Ptr;\n  Op<1>() = Cmp;\n  Op<2>() = NewVal;\n  setSuccessOrdering(SuccessOrdering);\n  setFailureOrdering(FailureOrdering);\n  setSyncScopeID(SSID);\n  setAlignment(Alignment);\n\n  assert(getOperand(0) && getOperand(1) && getOperand(2) &&\n         \"All operands must be non-null!\");\n  assert(getOperand(0)->getType()->isPointerTy() &&\n         \"Ptr must have pointer type!\");\n  assert(getOperand(1)->getType() ==\n                 cast<PointerType>(getOperand(0)->getType())->getElementType()\n         && \"Ptr must be a pointer to Cmp type!\");\n  assert(getOperand(2)->getType() ==\n                 cast<PointerType>(getOperand(0)->getType())->getElementType()\n         && \"Ptr must be a pointer to NewVal type!\");\n  assert(SuccessOrdering != AtomicOrdering::NotAtomic &&\n         \"AtomicCmpXchg instructions must be atomic!\");\n  assert(FailureOrdering != AtomicOrdering::NotAtomic &&\n         \"AtomicCmpXchg instructions must be atomic!\");\n  assert(!isStrongerThan(FailureOrdering, SuccessOrdering) &&\n         \"AtomicCmpXchg failure argument shall be no stronger than the success \"\n         \"argument\");\n  assert(FailureOrdering != AtomicOrdering::Release &&\n         FailureOrdering != AtomicOrdering::AcquireRelease &&\n         \"AtomicCmpXchg failure ordering cannot include release semantics\");\n}\n\nAtomicCmpXchgInst::AtomicCmpXchgInst(Value *Ptr, Value *Cmp, Value *NewVal,\n                                     Align Alignment,\n                                     AtomicOrdering SuccessOrdering,\n                                     AtomicOrdering FailureOrdering,\n                                     SyncScope::ID SSID,\n                                     Instruction *InsertBefore)\n    : Instruction(\n          StructType::get(Cmp->getType(), Type::getInt1Ty(Cmp->getContext())),\n          AtomicCmpXchg, OperandTraits<AtomicCmpXchgInst>::op_begin(this),\n          OperandTraits<AtomicCmpXchgInst>::operands(this), InsertBefore) {\n  Init(Ptr, Cmp, NewVal, Alignment, SuccessOrdering, FailureOrdering, SSID);\n}\n\nAtomicCmpXchgInst::AtomicCmpXchgInst(Value *Ptr, Value *Cmp, Value *NewVal,\n                                     Align Alignment,\n                                     AtomicOrdering SuccessOrdering,\n                                     AtomicOrdering FailureOrdering,\n                                     SyncScope::ID SSID,\n                                     BasicBlock *InsertAtEnd)\n    : Instruction(\n          StructType::get(Cmp->getType(), Type::getInt1Ty(Cmp->getContext())),\n          AtomicCmpXchg, OperandTraits<AtomicCmpXchgInst>::op_begin(this),\n          OperandTraits<AtomicCmpXchgInst>::operands(this), InsertAtEnd) {\n  Init(Ptr, Cmp, NewVal, Alignment, SuccessOrdering, FailureOrdering, SSID);\n}\n\n//===----------------------------------------------------------------------===//\n//                       AtomicRMWInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid AtomicRMWInst::Init(BinOp Operation, Value *Ptr, Value *Val,\n                         Align Alignment, AtomicOrdering Ordering,\n                         SyncScope::ID SSID) {\n  Op<0>() = Ptr;\n  Op<1>() = Val;\n  setOperation(Operation);\n  setOrdering(Ordering);\n  setSyncScopeID(SSID);\n  setAlignment(Alignment);\n\n  assert(getOperand(0) && getOperand(1) &&\n         \"All operands must be non-null!\");\n  assert(getOperand(0)->getType()->isPointerTy() &&\n         \"Ptr must have pointer type!\");\n  assert(getOperand(1)->getType() ==\n         cast<PointerType>(getOperand(0)->getType())->getElementType()\n         && \"Ptr must be a pointer to Val type!\");\n  assert(Ordering != AtomicOrdering::NotAtomic &&\n         \"AtomicRMW instructions must be atomic!\");\n}\n\nAtomicRMWInst::AtomicRMWInst(BinOp Operation, Value *Ptr, Value *Val,\n                             Align Alignment, AtomicOrdering Ordering,\n                             SyncScope::ID SSID, Instruction *InsertBefore)\n    : Instruction(Val->getType(), AtomicRMW,\n                  OperandTraits<AtomicRMWInst>::op_begin(this),\n                  OperandTraits<AtomicRMWInst>::operands(this), InsertBefore) {\n  Init(Operation, Ptr, Val, Alignment, Ordering, SSID);\n}\n\nAtomicRMWInst::AtomicRMWInst(BinOp Operation, Value *Ptr, Value *Val,\n                             Align Alignment, AtomicOrdering Ordering,\n                             SyncScope::ID SSID, BasicBlock *InsertAtEnd)\n    : Instruction(Val->getType(), AtomicRMW,\n                  OperandTraits<AtomicRMWInst>::op_begin(this),\n                  OperandTraits<AtomicRMWInst>::operands(this), InsertAtEnd) {\n  Init(Operation, Ptr, Val, Alignment, Ordering, SSID);\n}\n\nStringRef AtomicRMWInst::getOperationName(BinOp Op) {\n  switch (Op) {\n  case AtomicRMWInst::Xchg:\n    return \"xchg\";\n  case AtomicRMWInst::Add:\n    return \"add\";\n  case AtomicRMWInst::Sub:\n    return \"sub\";\n  case AtomicRMWInst::And:\n    return \"and\";\n  case AtomicRMWInst::Nand:\n    return \"nand\";\n  case AtomicRMWInst::Or:\n    return \"or\";\n  case AtomicRMWInst::Xor:\n    return \"xor\";\n  case AtomicRMWInst::Max:\n    return \"max\";\n  case AtomicRMWInst::Min:\n    return \"min\";\n  case AtomicRMWInst::UMax:\n    return \"umax\";\n  case AtomicRMWInst::UMin:\n    return \"umin\";\n  case AtomicRMWInst::FAdd:\n    return \"fadd\";\n  case AtomicRMWInst::FSub:\n    return \"fsub\";\n  case AtomicRMWInst::BAD_BINOP:\n    return \"<invalid operation>\";\n  }\n\n  llvm_unreachable(\"invalid atomicrmw operation\");\n}\n\n//===----------------------------------------------------------------------===//\n//                       FenceInst Implementation\n//===----------------------------------------------------------------------===//\n\nFenceInst::FenceInst(LLVMContext &C, AtomicOrdering Ordering,\n                     SyncScope::ID SSID,\n                     Instruction *InsertBefore)\n  : Instruction(Type::getVoidTy(C), Fence, nullptr, 0, InsertBefore) {\n  setOrdering(Ordering);\n  setSyncScopeID(SSID);\n}\n\nFenceInst::FenceInst(LLVMContext &C, AtomicOrdering Ordering,\n                     SyncScope::ID SSID,\n                     BasicBlock *InsertAtEnd)\n  : Instruction(Type::getVoidTy(C), Fence, nullptr, 0, InsertAtEnd) {\n  setOrdering(Ordering);\n  setSyncScopeID(SSID);\n}\n\n//===----------------------------------------------------------------------===//\n//                       GetElementPtrInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid GetElementPtrInst::init(Value *Ptr, ArrayRef<Value *> IdxList,\n                             const Twine &Name) {\n  assert(getNumOperands() == 1 + IdxList.size() &&\n         \"NumOperands not initialized?\");\n  Op<0>() = Ptr;\n  llvm::copy(IdxList, op_begin() + 1);\n  setName(Name);\n}\n\nGetElementPtrInst::GetElementPtrInst(const GetElementPtrInst &GEPI)\n    : Instruction(GEPI.getType(), GetElementPtr,\n                  OperandTraits<GetElementPtrInst>::op_end(this) -\n                      GEPI.getNumOperands(),\n                  GEPI.getNumOperands()),\n      SourceElementType(GEPI.SourceElementType),\n      ResultElementType(GEPI.ResultElementType) {\n  std::copy(GEPI.op_begin(), GEPI.op_end(), op_begin());\n  SubclassOptionalData = GEPI.SubclassOptionalData;\n}\n\nType *GetElementPtrInst::getTypeAtIndex(Type *Ty, Value *Idx) {\n  if (auto *Struct = dyn_cast<StructType>(Ty)) {\n    if (!Struct->indexValid(Idx))\n      return nullptr;\n    return Struct->getTypeAtIndex(Idx);\n  }\n  if (!Idx->getType()->isIntOrIntVectorTy())\n    return nullptr;\n  if (auto *Array = dyn_cast<ArrayType>(Ty))\n    return Array->getElementType();\n  if (auto *Vector = dyn_cast<VectorType>(Ty))\n    return Vector->getElementType();\n  return nullptr;\n}\n\nType *GetElementPtrInst::getTypeAtIndex(Type *Ty, uint64_t Idx) {\n  if (auto *Struct = dyn_cast<StructType>(Ty)) {\n    if (Idx >= Struct->getNumElements())\n      return nullptr;\n    return Struct->getElementType(Idx);\n  }\n  if (auto *Array = dyn_cast<ArrayType>(Ty))\n    return Array->getElementType();\n  if (auto *Vector = dyn_cast<VectorType>(Ty))\n    return Vector->getElementType();\n  return nullptr;\n}\n\ntemplate <typename IndexTy>\nstatic Type *getIndexedTypeInternal(Type *Ty, ArrayRef<IndexTy> IdxList) {\n  if (IdxList.empty())\n    return Ty;\n  for (IndexTy V : IdxList.slice(1)) {\n    Ty = GetElementPtrInst::getTypeAtIndex(Ty, V);\n    if (!Ty)\n      return Ty;\n  }\n  return Ty;\n}\n\nType *GetElementPtrInst::getIndexedType(Type *Ty, ArrayRef<Value *> IdxList) {\n  return getIndexedTypeInternal(Ty, IdxList);\n}\n\nType *GetElementPtrInst::getIndexedType(Type *Ty,\n                                        ArrayRef<Constant *> IdxList) {\n  return getIndexedTypeInternal(Ty, IdxList);\n}\n\nType *GetElementPtrInst::getIndexedType(Type *Ty, ArrayRef<uint64_t> IdxList) {\n  return getIndexedTypeInternal(Ty, IdxList);\n}\n\n/// hasAllZeroIndices - Return true if all of the indices of this GEP are\n/// zeros.  If so, the result pointer and the first operand have the same\n/// value, just potentially different types.\nbool GetElementPtrInst::hasAllZeroIndices() const {\n  for (unsigned i = 1, e = getNumOperands(); i != e; ++i) {\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(getOperand(i))) {\n      if (!CI->isZero()) return false;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\n/// hasAllConstantIndices - Return true if all of the indices of this GEP are\n/// constant integers.  If so, the result pointer and the first operand have\n/// a constant offset between them.\nbool GetElementPtrInst::hasAllConstantIndices() const {\n  for (unsigned i = 1, e = getNumOperands(); i != e; ++i) {\n    if (!isa<ConstantInt>(getOperand(i)))\n      return false;\n  }\n  return true;\n}\n\nvoid GetElementPtrInst::setIsInBounds(bool B) {\n  cast<GEPOperator>(this)->setIsInBounds(B);\n}\n\nbool GetElementPtrInst::isInBounds() const {\n  return cast<GEPOperator>(this)->isInBounds();\n}\n\nbool GetElementPtrInst::accumulateConstantOffset(const DataLayout &DL,\n                                                 APInt &Offset) const {\n  // Delegate to the generic GEPOperator implementation.\n  return cast<GEPOperator>(this)->accumulateConstantOffset(DL, Offset);\n}\n\n//===----------------------------------------------------------------------===//\n//                           ExtractElementInst Implementation\n//===----------------------------------------------------------------------===//\n\nExtractElementInst::ExtractElementInst(Value *Val, Value *Index,\n                                       const Twine &Name,\n                                       Instruction *InsertBef)\n  : Instruction(cast<VectorType>(Val->getType())->getElementType(),\n                ExtractElement,\n                OperandTraits<ExtractElementInst>::op_begin(this),\n                2, InsertBef) {\n  assert(isValidOperands(Val, Index) &&\n         \"Invalid extractelement instruction operands!\");\n  Op<0>() = Val;\n  Op<1>() = Index;\n  setName(Name);\n}\n\nExtractElementInst::ExtractElementInst(Value *Val, Value *Index,\n                                       const Twine &Name,\n                                       BasicBlock *InsertAE)\n  : Instruction(cast<VectorType>(Val->getType())->getElementType(),\n                ExtractElement,\n                OperandTraits<ExtractElementInst>::op_begin(this),\n                2, InsertAE) {\n  assert(isValidOperands(Val, Index) &&\n         \"Invalid extractelement instruction operands!\");\n\n  Op<0>() = Val;\n  Op<1>() = Index;\n  setName(Name);\n}\n\nbool ExtractElementInst::isValidOperands(const Value *Val, const Value *Index) {\n  if (!Val->getType()->isVectorTy() || !Index->getType()->isIntegerTy())\n    return false;\n  return true;\n}\n\n//===----------------------------------------------------------------------===//\n//                           InsertElementInst Implementation\n//===----------------------------------------------------------------------===//\n\nInsertElementInst::InsertElementInst(Value *Vec, Value *Elt, Value *Index,\n                                     const Twine &Name,\n                                     Instruction *InsertBef)\n  : Instruction(Vec->getType(), InsertElement,\n                OperandTraits<InsertElementInst>::op_begin(this),\n                3, InsertBef) {\n  assert(isValidOperands(Vec, Elt, Index) &&\n         \"Invalid insertelement instruction operands!\");\n  Op<0>() = Vec;\n  Op<1>() = Elt;\n  Op<2>() = Index;\n  setName(Name);\n}\n\nInsertElementInst::InsertElementInst(Value *Vec, Value *Elt, Value *Index,\n                                     const Twine &Name,\n                                     BasicBlock *InsertAE)\n  : Instruction(Vec->getType(), InsertElement,\n                OperandTraits<InsertElementInst>::op_begin(this),\n                3, InsertAE) {\n  assert(isValidOperands(Vec, Elt, Index) &&\n         \"Invalid insertelement instruction operands!\");\n\n  Op<0>() = Vec;\n  Op<1>() = Elt;\n  Op<2>() = Index;\n  setName(Name);\n}\n\nbool InsertElementInst::isValidOperands(const Value *Vec, const Value *Elt,\n                                        const Value *Index) {\n  if (!Vec->getType()->isVectorTy())\n    return false;   // First operand of insertelement must be vector type.\n\n  if (Elt->getType() != cast<VectorType>(Vec->getType())->getElementType())\n    return false;// Second operand of insertelement must be vector element type.\n\n  if (!Index->getType()->isIntegerTy())\n    return false;  // Third operand of insertelement must be i32.\n  return true;\n}\n\n//===----------------------------------------------------------------------===//\n//                      ShuffleVectorInst Implementation\n//===----------------------------------------------------------------------===//\n\nShuffleVectorInst::ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,\n                                     const Twine &Name,\n                                     Instruction *InsertBefore)\n    : Instruction(\n          VectorType::get(cast<VectorType>(V1->getType())->getElementType(),\n                          cast<VectorType>(Mask->getType())->getElementCount()),\n          ShuffleVector, OperandTraits<ShuffleVectorInst>::op_begin(this),\n          OperandTraits<ShuffleVectorInst>::operands(this), InsertBefore) {\n  assert(isValidOperands(V1, V2, Mask) &&\n         \"Invalid shuffle vector instruction operands!\");\n\n  Op<0>() = V1;\n  Op<1>() = V2;\n  SmallVector<int, 16> MaskArr;\n  getShuffleMask(cast<Constant>(Mask), MaskArr);\n  setShuffleMask(MaskArr);\n  setName(Name);\n}\n\nShuffleVectorInst::ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,\n                                     const Twine &Name, BasicBlock *InsertAtEnd)\n    : Instruction(\n          VectorType::get(cast<VectorType>(V1->getType())->getElementType(),\n                          cast<VectorType>(Mask->getType())->getElementCount()),\n          ShuffleVector, OperandTraits<ShuffleVectorInst>::op_begin(this),\n          OperandTraits<ShuffleVectorInst>::operands(this), InsertAtEnd) {\n  assert(isValidOperands(V1, V2, Mask) &&\n         \"Invalid shuffle vector instruction operands!\");\n\n  Op<0>() = V1;\n  Op<1>() = V2;\n  SmallVector<int, 16> MaskArr;\n  getShuffleMask(cast<Constant>(Mask), MaskArr);\n  setShuffleMask(MaskArr);\n  setName(Name);\n}\n\nShuffleVectorInst::ShuffleVectorInst(Value *V1, Value *V2, ArrayRef<int> Mask,\n                                     const Twine &Name,\n                                     Instruction *InsertBefore)\n    : Instruction(\n          VectorType::get(cast<VectorType>(V1->getType())->getElementType(),\n                          Mask.size(), isa<ScalableVectorType>(V1->getType())),\n          ShuffleVector, OperandTraits<ShuffleVectorInst>::op_begin(this),\n          OperandTraits<ShuffleVectorInst>::operands(this), InsertBefore) {\n  assert(isValidOperands(V1, V2, Mask) &&\n         \"Invalid shuffle vector instruction operands!\");\n  Op<0>() = V1;\n  Op<1>() = V2;\n  setShuffleMask(Mask);\n  setName(Name);\n}\n\nShuffleVectorInst::ShuffleVectorInst(Value *V1, Value *V2, ArrayRef<int> Mask,\n                                     const Twine &Name, BasicBlock *InsertAtEnd)\n    : Instruction(\n          VectorType::get(cast<VectorType>(V1->getType())->getElementType(),\n                          Mask.size(), isa<ScalableVectorType>(V1->getType())),\n          ShuffleVector, OperandTraits<ShuffleVectorInst>::op_begin(this),\n          OperandTraits<ShuffleVectorInst>::operands(this), InsertAtEnd) {\n  assert(isValidOperands(V1, V2, Mask) &&\n         \"Invalid shuffle vector instruction operands!\");\n\n  Op<0>() = V1;\n  Op<1>() = V2;\n  setShuffleMask(Mask);\n  setName(Name);\n}\n\nvoid ShuffleVectorInst::commute() {\n  int NumOpElts = cast<FixedVectorType>(Op<0>()->getType())->getNumElements();\n  int NumMaskElts = ShuffleMask.size();\n  SmallVector<int, 16> NewMask(NumMaskElts);\n  for (int i = 0; i != NumMaskElts; ++i) {\n    int MaskElt = getMaskValue(i);\n    if (MaskElt == UndefMaskElem) {\n      NewMask[i] = UndefMaskElem;\n      continue;\n    }\n    assert(MaskElt >= 0 && MaskElt < 2 * NumOpElts && \"Out-of-range mask\");\n    MaskElt = (MaskElt < NumOpElts) ? MaskElt + NumOpElts : MaskElt - NumOpElts;\n    NewMask[i] = MaskElt;\n  }\n  setShuffleMask(NewMask);\n  Op<0>().swap(Op<1>());\n}\n\nbool ShuffleVectorInst::isValidOperands(const Value *V1, const Value *V2,\n                                        ArrayRef<int> Mask) {\n  // V1 and V2 must be vectors of the same type.\n  if (!isa<VectorType>(V1->getType()) || V1->getType() != V2->getType())\n    return false;\n\n  // Make sure the mask elements make sense.\n  int V1Size =\n      cast<VectorType>(V1->getType())->getElementCount().getKnownMinValue();\n  for (int Elem : Mask)\n    if (Elem != UndefMaskElem && Elem >= V1Size * 2)\n      return false;\n\n  if (isa<ScalableVectorType>(V1->getType()))\n    if ((Mask[0] != 0 && Mask[0] != UndefMaskElem) || !is_splat(Mask))\n      return false;\n\n  return true;\n}\n\nbool ShuffleVectorInst::isValidOperands(const Value *V1, const Value *V2,\n                                        const Value *Mask) {\n  // V1 and V2 must be vectors of the same type.\n  if (!V1->getType()->isVectorTy() || V1->getType() != V2->getType())\n    return false;\n\n  // Mask must be vector of i32, and must be the same kind of vector as the\n  // input vectors\n  auto *MaskTy = dyn_cast<VectorType>(Mask->getType());\n  if (!MaskTy || !MaskTy->getElementType()->isIntegerTy(32) ||\n      isa<ScalableVectorType>(MaskTy) != isa<ScalableVectorType>(V1->getType()))\n    return false;\n\n  // Check to see if Mask is valid.\n  if (isa<UndefValue>(Mask) || isa<ConstantAggregateZero>(Mask))\n    return true;\n\n  if (const auto *MV = dyn_cast<ConstantVector>(Mask)) {\n    unsigned V1Size = cast<FixedVectorType>(V1->getType())->getNumElements();\n    for (Value *Op : MV->operands()) {\n      if (auto *CI = dyn_cast<ConstantInt>(Op)) {\n        if (CI->uge(V1Size*2))\n          return false;\n      } else if (!isa<UndefValue>(Op)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (const auto *CDS = dyn_cast<ConstantDataSequential>(Mask)) {\n    unsigned V1Size = cast<FixedVectorType>(V1->getType())->getNumElements();\n    for (unsigned i = 0, e = cast<FixedVectorType>(MaskTy)->getNumElements();\n         i != e; ++i)\n      if (CDS->getElementAsInteger(i) >= V1Size*2)\n        return false;\n    return true;\n  }\n\n  return false;\n}\n\nvoid ShuffleVectorInst::getShuffleMask(const Constant *Mask,\n                                       SmallVectorImpl<int> &Result) {\n  ElementCount EC = cast<VectorType>(Mask->getType())->getElementCount();\n\n  if (isa<ConstantAggregateZero>(Mask)) {\n    Result.resize(EC.getKnownMinValue(), 0);\n    return;\n  }\n\n  Result.reserve(EC.getKnownMinValue());\n\n  if (EC.isScalable()) {\n    assert((isa<ConstantAggregateZero>(Mask) || isa<UndefValue>(Mask)) &&\n           \"Scalable vector shuffle mask must be undef or zeroinitializer\");\n    int MaskVal = isa<UndefValue>(Mask) ? -1 : 0;\n    for (unsigned I = 0; I < EC.getKnownMinValue(); ++I)\n      Result.emplace_back(MaskVal);\n    return;\n  }\n\n  unsigned NumElts = EC.getKnownMinValue();\n\n  if (auto *CDS = dyn_cast<ConstantDataSequential>(Mask)) {\n    for (unsigned i = 0; i != NumElts; ++i)\n      Result.push_back(CDS->getElementAsInteger(i));\n    return;\n  }\n  for (unsigned i = 0; i != NumElts; ++i) {\n    Constant *C = Mask->getAggregateElement(i);\n    Result.push_back(isa<UndefValue>(C) ? -1 :\n                     cast<ConstantInt>(C)->getZExtValue());\n  }\n}\n\nvoid ShuffleVectorInst::setShuffleMask(ArrayRef<int> Mask) {\n  ShuffleMask.assign(Mask.begin(), Mask.end());\n  ShuffleMaskForBitcode = convertShuffleMaskForBitcode(Mask, getType());\n}\nConstant *ShuffleVectorInst::convertShuffleMaskForBitcode(ArrayRef<int> Mask,\n                                                          Type *ResultTy) {\n  Type *Int32Ty = Type::getInt32Ty(ResultTy->getContext());\n  if (isa<ScalableVectorType>(ResultTy)) {\n    assert(is_splat(Mask) && \"Unexpected shuffle\");\n    Type *VecTy = VectorType::get(Int32Ty, Mask.size(), true);\n    if (Mask[0] == 0)\n      return Constant::getNullValue(VecTy);\n    return UndefValue::get(VecTy);\n  }\n  SmallVector<Constant *, 16> MaskConst;\n  for (int Elem : Mask) {\n    if (Elem == UndefMaskElem)\n      MaskConst.push_back(UndefValue::get(Int32Ty));\n    else\n      MaskConst.push_back(ConstantInt::get(Int32Ty, Elem));\n  }\n  return ConstantVector::get(MaskConst);\n}\n\nstatic bool isSingleSourceMaskImpl(ArrayRef<int> Mask, int NumOpElts) {\n  assert(!Mask.empty() && \"Shuffle mask must contain elements\");\n  bool UsesLHS = false;\n  bool UsesRHS = false;\n  for (int i = 0, NumMaskElts = Mask.size(); i < NumMaskElts; ++i) {\n    if (Mask[i] == -1)\n      continue;\n    assert(Mask[i] >= 0 && Mask[i] < (NumOpElts * 2) &&\n           \"Out-of-bounds shuffle mask element\");\n    UsesLHS |= (Mask[i] < NumOpElts);\n    UsesRHS |= (Mask[i] >= NumOpElts);\n    if (UsesLHS && UsesRHS)\n      return false;\n  }\n  // Allow for degenerate case: completely undef mask means neither source is used.\n  return UsesLHS || UsesRHS;\n}\n\nbool ShuffleVectorInst::isSingleSourceMask(ArrayRef<int> Mask) {\n  // We don't have vector operand size information, so assume operands are the\n  // same size as the mask.\n  return isSingleSourceMaskImpl(Mask, Mask.size());\n}\n\nstatic bool isIdentityMaskImpl(ArrayRef<int> Mask, int NumOpElts) {\n  if (!isSingleSourceMaskImpl(Mask, NumOpElts))\n    return false;\n  for (int i = 0, NumMaskElts = Mask.size(); i < NumMaskElts; ++i) {\n    if (Mask[i] == -1)\n      continue;\n    if (Mask[i] != i && Mask[i] != (NumOpElts + i))\n      return false;\n  }\n  return true;\n}\n\nbool ShuffleVectorInst::isIdentityMask(ArrayRef<int> Mask) {\n  // We don't have vector operand size information, so assume operands are the\n  // same size as the mask.\n  return isIdentityMaskImpl(Mask, Mask.size());\n}\n\nbool ShuffleVectorInst::isReverseMask(ArrayRef<int> Mask) {\n  if (!isSingleSourceMask(Mask))\n    return false;\n  for (int i = 0, NumElts = Mask.size(); i < NumElts; ++i) {\n    if (Mask[i] == -1)\n      continue;\n    if (Mask[i] != (NumElts - 1 - i) && Mask[i] != (NumElts + NumElts - 1 - i))\n      return false;\n  }\n  return true;\n}\n\nbool ShuffleVectorInst::isZeroEltSplatMask(ArrayRef<int> Mask) {\n  if (!isSingleSourceMask(Mask))\n    return false;\n  for (int i = 0, NumElts = Mask.size(); i < NumElts; ++i) {\n    if (Mask[i] == -1)\n      continue;\n    if (Mask[i] != 0 && Mask[i] != NumElts)\n      return false;\n  }\n  return true;\n}\n\nbool ShuffleVectorInst::isSelectMask(ArrayRef<int> Mask) {\n  // Select is differentiated from identity. It requires using both sources.\n  if (isSingleSourceMask(Mask))\n    return false;\n  for (int i = 0, NumElts = Mask.size(); i < NumElts; ++i) {\n    if (Mask[i] == -1)\n      continue;\n    if (Mask[i] != i && Mask[i] != (NumElts + i))\n      return false;\n  }\n  return true;\n}\n\nbool ShuffleVectorInst::isTransposeMask(ArrayRef<int> Mask) {\n  // Example masks that will return true:\n  // v1 = <a, b, c, d>\n  // v2 = <e, f, g, h>\n  // trn1 = shufflevector v1, v2 <0, 4, 2, 6> = <a, e, c, g>\n  // trn2 = shufflevector v1, v2 <1, 5, 3, 7> = <b, f, d, h>\n\n  // 1. The number of elements in the mask must be a power-of-2 and at least 2.\n  int NumElts = Mask.size();\n  if (NumElts < 2 || !isPowerOf2_32(NumElts))\n    return false;\n\n  // 2. The first element of the mask must be either a 0 or a 1.\n  if (Mask[0] != 0 && Mask[0] != 1)\n    return false;\n\n  // 3. The difference between the first 2 elements must be equal to the\n  // number of elements in the mask.\n  if ((Mask[1] - Mask[0]) != NumElts)\n    return false;\n\n  // 4. The difference between consecutive even-numbered and odd-numbered\n  // elements must be equal to 2.\n  for (int i = 2; i < NumElts; ++i) {\n    int MaskEltVal = Mask[i];\n    if (MaskEltVal == -1)\n      return false;\n    int MaskEltPrevVal = Mask[i - 2];\n    if (MaskEltVal - MaskEltPrevVal != 2)\n      return false;\n  }\n  return true;\n}\n\nbool ShuffleVectorInst::isExtractSubvectorMask(ArrayRef<int> Mask,\n                                               int NumSrcElts, int &Index) {\n  // Must extract from a single source.\n  if (!isSingleSourceMaskImpl(Mask, NumSrcElts))\n    return false;\n\n  // Must be smaller (else this is an Identity shuffle).\n  if (NumSrcElts <= (int)Mask.size())\n    return false;\n\n  // Find start of extraction, accounting that we may start with an UNDEF.\n  int SubIndex = -1;\n  for (int i = 0, e = Mask.size(); i != e; ++i) {\n    int M = Mask[i];\n    if (M < 0)\n      continue;\n    int Offset = (M % NumSrcElts) - i;\n    if (0 <= SubIndex && SubIndex != Offset)\n      return false;\n    SubIndex = Offset;\n  }\n\n  if (0 <= SubIndex && SubIndex + (int)Mask.size() <= NumSrcElts) {\n    Index = SubIndex;\n    return true;\n  }\n  return false;\n}\n\nbool ShuffleVectorInst::isIdentityWithPadding() const {\n  if (isa<UndefValue>(Op<2>()))\n    return false;\n\n  // FIXME: Not currently possible to express a shuffle mask for a scalable\n  // vector for this case.\n  if (isa<ScalableVectorType>(getType()))\n    return false;\n\n  int NumOpElts = cast<FixedVectorType>(Op<0>()->getType())->getNumElements();\n  int NumMaskElts = cast<FixedVectorType>(getType())->getNumElements();\n  if (NumMaskElts <= NumOpElts)\n    return false;\n\n  // The first part of the mask must choose elements from exactly 1 source op.\n  ArrayRef<int> Mask = getShuffleMask();\n  if (!isIdentityMaskImpl(Mask, NumOpElts))\n    return false;\n\n  // All extending must be with undef elements.\n  for (int i = NumOpElts; i < NumMaskElts; ++i)\n    if (Mask[i] != -1)\n      return false;\n\n  return true;\n}\n\nbool ShuffleVectorInst::isIdentityWithExtract() const {\n  if (isa<UndefValue>(Op<2>()))\n    return false;\n\n  // FIXME: Not currently possible to express a shuffle mask for a scalable\n  // vector for this case.\n  if (isa<ScalableVectorType>(getType()))\n    return false;\n\n  int NumOpElts = cast<FixedVectorType>(Op<0>()->getType())->getNumElements();\n  int NumMaskElts = cast<FixedVectorType>(getType())->getNumElements();\n  if (NumMaskElts >= NumOpElts)\n    return false;\n\n  return isIdentityMaskImpl(getShuffleMask(), NumOpElts);\n}\n\nbool ShuffleVectorInst::isConcat() const {\n  // Vector concatenation is differentiated from identity with padding.\n  if (isa<UndefValue>(Op<0>()) || isa<UndefValue>(Op<1>()) ||\n      isa<UndefValue>(Op<2>()))\n    return false;\n\n  // FIXME: Not currently possible to express a shuffle mask for a scalable\n  // vector for this case.\n  if (isa<ScalableVectorType>(getType()))\n    return false;\n\n  int NumOpElts = cast<FixedVectorType>(Op<0>()->getType())->getNumElements();\n  int NumMaskElts = cast<FixedVectorType>(getType())->getNumElements();\n  if (NumMaskElts != NumOpElts * 2)\n    return false;\n\n  // Use the mask length rather than the operands' vector lengths here. We\n  // already know that the shuffle returns a vector twice as long as the inputs,\n  // and neither of the inputs are undef vectors. If the mask picks consecutive\n  // elements from both inputs, then this is a concatenation of the inputs.\n  return isIdentityMaskImpl(getShuffleMask(), NumMaskElts);\n}\n\n//===----------------------------------------------------------------------===//\n//                             InsertValueInst Class\n//===----------------------------------------------------------------------===//\n\nvoid InsertValueInst::init(Value *Agg, Value *Val, ArrayRef<unsigned> Idxs,\n                           const Twine &Name) {\n  assert(getNumOperands() == 2 && \"NumOperands not initialized?\");\n\n  // There's no fundamental reason why we require at least one index\n  // (other than weirdness with &*IdxBegin being invalid; see\n  // getelementptr's init routine for example). But there's no\n  // present need to support it.\n  assert(!Idxs.empty() && \"InsertValueInst must have at least one index\");\n\n  assert(ExtractValueInst::getIndexedType(Agg->getType(), Idxs) ==\n         Val->getType() && \"Inserted value must match indexed type!\");\n  Op<0>() = Agg;\n  Op<1>() = Val;\n\n  Indices.append(Idxs.begin(), Idxs.end());\n  setName(Name);\n}\n\nInsertValueInst::InsertValueInst(const InsertValueInst &IVI)\n  : Instruction(IVI.getType(), InsertValue,\n                OperandTraits<InsertValueInst>::op_begin(this), 2),\n    Indices(IVI.Indices) {\n  Op<0>() = IVI.getOperand(0);\n  Op<1>() = IVI.getOperand(1);\n  SubclassOptionalData = IVI.SubclassOptionalData;\n}\n\n//===----------------------------------------------------------------------===//\n//                             ExtractValueInst Class\n//===----------------------------------------------------------------------===//\n\nvoid ExtractValueInst::init(ArrayRef<unsigned> Idxs, const Twine &Name) {\n  assert(getNumOperands() == 1 && \"NumOperands not initialized?\");\n\n  // There's no fundamental reason why we require at least one index.\n  // But there's no present need to support it.\n  assert(!Idxs.empty() && \"ExtractValueInst must have at least one index\");\n\n  Indices.append(Idxs.begin(), Idxs.end());\n  setName(Name);\n}\n\nExtractValueInst::ExtractValueInst(const ExtractValueInst &EVI)\n  : UnaryInstruction(EVI.getType(), ExtractValue, EVI.getOperand(0)),\n    Indices(EVI.Indices) {\n  SubclassOptionalData = EVI.SubclassOptionalData;\n}\n\n// getIndexedType - Returns the type of the element that would be extracted\n// with an extractvalue instruction with the specified parameters.\n//\n// A null type is returned if the indices are invalid for the specified\n// pointer type.\n//\nType *ExtractValueInst::getIndexedType(Type *Agg,\n                                       ArrayRef<unsigned> Idxs) {\n  for (unsigned Index : Idxs) {\n    // We can't use CompositeType::indexValid(Index) here.\n    // indexValid() always returns true for arrays because getelementptr allows\n    // out-of-bounds indices. Since we don't allow those for extractvalue and\n    // insertvalue we need to check array indexing manually.\n    // Since the only other types we can index into are struct types it's just\n    // as easy to check those manually as well.\n    if (ArrayType *AT = dyn_cast<ArrayType>(Agg)) {\n      if (Index >= AT->getNumElements())\n        return nullptr;\n      Agg = AT->getElementType();\n    } else if (StructType *ST = dyn_cast<StructType>(Agg)) {\n      if (Index >= ST->getNumElements())\n        return nullptr;\n      Agg = ST->getElementType(Index);\n    } else {\n      // Not a valid type to index into.\n      return nullptr;\n    }\n  }\n  return const_cast<Type*>(Agg);\n}\n\n//===----------------------------------------------------------------------===//\n//                             UnaryOperator Class\n//===----------------------------------------------------------------------===//\n\nUnaryOperator::UnaryOperator(UnaryOps iType, Value *S,\n                             Type *Ty, const Twine &Name,\n                             Instruction *InsertBefore)\n  : UnaryInstruction(Ty, iType, S, InsertBefore) {\n  Op<0>() = S;\n  setName(Name);\n  AssertOK();\n}\n\nUnaryOperator::UnaryOperator(UnaryOps iType, Value *S,\n                             Type *Ty, const Twine &Name,\n                             BasicBlock *InsertAtEnd)\n  : UnaryInstruction(Ty, iType, S, InsertAtEnd) {\n  Op<0>() = S;\n  setName(Name);\n  AssertOK();\n}\n\nUnaryOperator *UnaryOperator::Create(UnaryOps Op, Value *S,\n                                     const Twine &Name,\n                                     Instruction *InsertBefore) {\n  return new UnaryOperator(Op, S, S->getType(), Name, InsertBefore);\n}\n\nUnaryOperator *UnaryOperator::Create(UnaryOps Op, Value *S,\n                                     const Twine &Name,\n                                     BasicBlock *InsertAtEnd) {\n  UnaryOperator *Res = Create(Op, S, Name);\n  InsertAtEnd->getInstList().push_back(Res);\n  return Res;\n}\n\nvoid UnaryOperator::AssertOK() {\n  Value *LHS = getOperand(0);\n  (void)LHS; // Silence warnings.\n#ifndef NDEBUG\n  switch (getOpcode()) {\n  case FNeg:\n    assert(getType() == LHS->getType() &&\n           \"Unary operation should return same type as operand!\");\n    assert(getType()->isFPOrFPVectorTy() &&\n           \"Tried to create a floating-point operation on a \"\n           \"non-floating-point type!\");\n    break;\n  default: llvm_unreachable(\"Invalid opcode provided\");\n  }\n#endif\n}\n\n//===----------------------------------------------------------------------===//\n//                             BinaryOperator Class\n//===----------------------------------------------------------------------===//\n\nBinaryOperator::BinaryOperator(BinaryOps iType, Value *S1, Value *S2,\n                               Type *Ty, const Twine &Name,\n                               Instruction *InsertBefore)\n  : Instruction(Ty, iType,\n                OperandTraits<BinaryOperator>::op_begin(this),\n                OperandTraits<BinaryOperator>::operands(this),\n                InsertBefore) {\n  Op<0>() = S1;\n  Op<1>() = S2;\n  setName(Name);\n  AssertOK();\n}\n\nBinaryOperator::BinaryOperator(BinaryOps iType, Value *S1, Value *S2,\n                               Type *Ty, const Twine &Name,\n                               BasicBlock *InsertAtEnd)\n  : Instruction(Ty, iType,\n                OperandTraits<BinaryOperator>::op_begin(this),\n                OperandTraits<BinaryOperator>::operands(this),\n                InsertAtEnd) {\n  Op<0>() = S1;\n  Op<1>() = S2;\n  setName(Name);\n  AssertOK();\n}\n\nvoid BinaryOperator::AssertOK() {\n  Value *LHS = getOperand(0), *RHS = getOperand(1);\n  (void)LHS; (void)RHS; // Silence warnings.\n  assert(LHS->getType() == RHS->getType() &&\n         \"Binary operator operand types must match!\");\n#ifndef NDEBUG\n  switch (getOpcode()) {\n  case Add: case Sub:\n  case Mul:\n    assert(getType() == LHS->getType() &&\n           \"Arithmetic operation should return same type as operands!\");\n    assert(getType()->isIntOrIntVectorTy() &&\n           \"Tried to create an integer operation on a non-integer type!\");\n    break;\n  case FAdd: case FSub:\n  case FMul:\n    assert(getType() == LHS->getType() &&\n           \"Arithmetic operation should return same type as operands!\");\n    assert(getType()->isFPOrFPVectorTy() &&\n           \"Tried to create a floating-point operation on a \"\n           \"non-floating-point type!\");\n    break;\n  case UDiv:\n  case SDiv:\n    assert(getType() == LHS->getType() &&\n           \"Arithmetic operation should return same type as operands!\");\n    assert(getType()->isIntOrIntVectorTy() &&\n           \"Incorrect operand type (not integer) for S/UDIV\");\n    break;\n  case FDiv:\n    assert(getType() == LHS->getType() &&\n           \"Arithmetic operation should return same type as operands!\");\n    assert(getType()->isFPOrFPVectorTy() &&\n           \"Incorrect operand type (not floating point) for FDIV\");\n    break;\n  case URem:\n  case SRem:\n    assert(getType() == LHS->getType() &&\n           \"Arithmetic operation should return same type as operands!\");\n    assert(getType()->isIntOrIntVectorTy() &&\n           \"Incorrect operand type (not integer) for S/UREM\");\n    break;\n  case FRem:\n    assert(getType() == LHS->getType() &&\n           \"Arithmetic operation should return same type as operands!\");\n    assert(getType()->isFPOrFPVectorTy() &&\n           \"Incorrect operand type (not floating point) for FREM\");\n    break;\n  case Shl:\n  case LShr:\n  case AShr:\n    assert(getType() == LHS->getType() &&\n           \"Shift operation should return same type as operands!\");\n    assert(getType()->isIntOrIntVectorTy() &&\n           \"Tried to create a shift operation on a non-integral type!\");\n    break;\n  case And: case Or:\n  case Xor:\n    assert(getType() == LHS->getType() &&\n           \"Logical operation should return same type as operands!\");\n    assert(getType()->isIntOrIntVectorTy() &&\n           \"Tried to create a logical operation on a non-integral type!\");\n    break;\n  default: llvm_unreachable(\"Invalid opcode provided\");\n  }\n#endif\n}\n\nBinaryOperator *BinaryOperator::Create(BinaryOps Op, Value *S1, Value *S2,\n                                       const Twine &Name,\n                                       Instruction *InsertBefore) {\n  assert(S1->getType() == S2->getType() &&\n         \"Cannot create binary operator with two operands of differing type!\");\n  return new BinaryOperator(Op, S1, S2, S1->getType(), Name, InsertBefore);\n}\n\nBinaryOperator *BinaryOperator::Create(BinaryOps Op, Value *S1, Value *S2,\n                                       const Twine &Name,\n                                       BasicBlock *InsertAtEnd) {\n  BinaryOperator *Res = Create(Op, S1, S2, Name);\n  InsertAtEnd->getInstList().push_back(Res);\n  return Res;\n}\n\nBinaryOperator *BinaryOperator::CreateNeg(Value *Op, const Twine &Name,\n                                          Instruction *InsertBefore) {\n  Value *zero = ConstantFP::getZeroValueForNegation(Op->getType());\n  return new BinaryOperator(Instruction::Sub,\n                            zero, Op,\n                            Op->getType(), Name, InsertBefore);\n}\n\nBinaryOperator *BinaryOperator::CreateNeg(Value *Op, const Twine &Name,\n                                          BasicBlock *InsertAtEnd) {\n  Value *zero = ConstantFP::getZeroValueForNegation(Op->getType());\n  return new BinaryOperator(Instruction::Sub,\n                            zero, Op,\n                            Op->getType(), Name, InsertAtEnd);\n}\n\nBinaryOperator *BinaryOperator::CreateNSWNeg(Value *Op, const Twine &Name,\n                                             Instruction *InsertBefore) {\n  Value *zero = ConstantFP::getZeroValueForNegation(Op->getType());\n  return BinaryOperator::CreateNSWSub(zero, Op, Name, InsertBefore);\n}\n\nBinaryOperator *BinaryOperator::CreateNSWNeg(Value *Op, const Twine &Name,\n                                             BasicBlock *InsertAtEnd) {\n  Value *zero = ConstantFP::getZeroValueForNegation(Op->getType());\n  return BinaryOperator::CreateNSWSub(zero, Op, Name, InsertAtEnd);\n}\n\nBinaryOperator *BinaryOperator::CreateNUWNeg(Value *Op, const Twine &Name,\n                                             Instruction *InsertBefore) {\n  Value *zero = ConstantFP::getZeroValueForNegation(Op->getType());\n  return BinaryOperator::CreateNUWSub(zero, Op, Name, InsertBefore);\n}\n\nBinaryOperator *BinaryOperator::CreateNUWNeg(Value *Op, const Twine &Name,\n                                             BasicBlock *InsertAtEnd) {\n  Value *zero = ConstantFP::getZeroValueForNegation(Op->getType());\n  return BinaryOperator::CreateNUWSub(zero, Op, Name, InsertAtEnd);\n}\n\nBinaryOperator *BinaryOperator::CreateNot(Value *Op, const Twine &Name,\n                                          Instruction *InsertBefore) {\n  Constant *C = Constant::getAllOnesValue(Op->getType());\n  return new BinaryOperator(Instruction::Xor, Op, C,\n                            Op->getType(), Name, InsertBefore);\n}\n\nBinaryOperator *BinaryOperator::CreateNot(Value *Op, const Twine &Name,\n                                          BasicBlock *InsertAtEnd) {\n  Constant *AllOnes = Constant::getAllOnesValue(Op->getType());\n  return new BinaryOperator(Instruction::Xor, Op, AllOnes,\n                            Op->getType(), Name, InsertAtEnd);\n}\n\n// Exchange the two operands to this instruction. This instruction is safe to\n// use on any binary instruction and does not modify the semantics of the\n// instruction. If the instruction is order-dependent (SetLT f.e.), the opcode\n// is changed.\nbool BinaryOperator::swapOperands() {\n  if (!isCommutative())\n    return true; // Can't commute operands\n  Op<0>().swap(Op<1>());\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n//                             FPMathOperator Class\n//===----------------------------------------------------------------------===//\n\nfloat FPMathOperator::getFPAccuracy() const {\n  const MDNode *MD =\n      cast<Instruction>(this)->getMetadata(LLVMContext::MD_fpmath);\n  if (!MD)\n    return 0.0;\n  ConstantFP *Accuracy = mdconst::extract<ConstantFP>(MD->getOperand(0));\n  return Accuracy->getValueAPF().convertToFloat();\n}\n\n//===----------------------------------------------------------------------===//\n//                                CastInst Class\n//===----------------------------------------------------------------------===//\n\n// Just determine if this cast only deals with integral->integral conversion.\nbool CastInst::isIntegerCast() const {\n  switch (getOpcode()) {\n    default: return false;\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::Trunc:\n      return true;\n    case Instruction::BitCast:\n      return getOperand(0)->getType()->isIntegerTy() &&\n        getType()->isIntegerTy();\n  }\n}\n\nbool CastInst::isLosslessCast() const {\n  // Only BitCast can be lossless, exit fast if we're not BitCast\n  if (getOpcode() != Instruction::BitCast)\n    return false;\n\n  // Identity cast is always lossless\n  Type *SrcTy = getOperand(0)->getType();\n  Type *DstTy = getType();\n  if (SrcTy == DstTy)\n    return true;\n\n  // Pointer to pointer is always lossless.\n  if (SrcTy->isPointerTy())\n    return DstTy->isPointerTy();\n  return false;  // Other types have no identity values\n}\n\n/// This function determines if the CastInst does not require any bits to be\n/// changed in order to effect the cast. Essentially, it identifies cases where\n/// no code gen is necessary for the cast, hence the name no-op cast.  For\n/// example, the following are all no-op casts:\n/// # bitcast i32* %x to i8*\n/// # bitcast <2 x i32> %x to <4 x i16>\n/// # ptrtoint i32* %x to i32     ; on 32-bit plaforms only\n/// Determine if the described cast is a no-op.\nbool CastInst::isNoopCast(Instruction::CastOps Opcode,\n                          Type *SrcTy,\n                          Type *DestTy,\n                          const DataLayout &DL) {\n  assert(castIsValid(Opcode, SrcTy, DestTy) && \"method precondition\");\n  switch (Opcode) {\n    default: llvm_unreachable(\"Invalid CastOp\");\n    case Instruction::Trunc:\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::FPTrunc:\n    case Instruction::FPExt:\n    case Instruction::UIToFP:\n    case Instruction::SIToFP:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::AddrSpaceCast:\n      // TODO: Target informations may give a more accurate answer here.\n      return false;\n    case Instruction::BitCast:\n      return true;  // BitCast never modifies bits.\n    case Instruction::PtrToInt:\n      return DL.getIntPtrType(SrcTy)->getScalarSizeInBits() ==\n             DestTy->getScalarSizeInBits();\n    case Instruction::IntToPtr:\n      return DL.getIntPtrType(DestTy)->getScalarSizeInBits() ==\n             SrcTy->getScalarSizeInBits();\n  }\n}\n\nbool CastInst::isNoopCast(const DataLayout &DL) const {\n  return isNoopCast(getOpcode(), getOperand(0)->getType(), getType(), DL);\n}\n\n/// This function determines if a pair of casts can be eliminated and what\n/// opcode should be used in the elimination. This assumes that there are two\n/// instructions like this:\n/// *  %F = firstOpcode SrcTy %x to MidTy\n/// *  %S = secondOpcode MidTy %F to DstTy\n/// The function returns a resultOpcode so these two casts can be replaced with:\n/// *  %Replacement = resultOpcode %SrcTy %x to DstTy\n/// If no such cast is permitted, the function returns 0.\nunsigned CastInst::isEliminableCastPair(\n  Instruction::CastOps firstOp, Instruction::CastOps secondOp,\n  Type *SrcTy, Type *MidTy, Type *DstTy, Type *SrcIntPtrTy, Type *MidIntPtrTy,\n  Type *DstIntPtrTy) {\n  // Define the 144 possibilities for these two cast instructions. The values\n  // in this matrix determine what to do in a given situation and select the\n  // case in the switch below.  The rows correspond to firstOp, the columns\n  // correspond to secondOp.  In looking at the table below, keep in mind\n  // the following cast properties:\n  //\n  //          Size Compare       Source               Destination\n  // Operator  Src ? Size   Type       Sign         Type       Sign\n  // -------- ------------ -------------------   ---------------------\n  // TRUNC         >       Integer      Any        Integral     Any\n  // ZEXT          <       Integral   Unsigned     Integer      Any\n  // SEXT          <       Integral    Signed      Integer      Any\n  // FPTOUI       n/a      FloatPt      n/a        Integral   Unsigned\n  // FPTOSI       n/a      FloatPt      n/a        Integral    Signed\n  // UITOFP       n/a      Integral   Unsigned     FloatPt      n/a\n  // SITOFP       n/a      Integral    Signed      FloatPt      n/a\n  // FPTRUNC       >       FloatPt      n/a        FloatPt      n/a\n  // FPEXT         <       FloatPt      n/a        FloatPt      n/a\n  // PTRTOINT     n/a      Pointer      n/a        Integral   Unsigned\n  // INTTOPTR     n/a      Integral   Unsigned     Pointer      n/a\n  // BITCAST       =       FirstClass   n/a       FirstClass    n/a\n  // ADDRSPCST    n/a      Pointer      n/a        Pointer      n/a\n  //\n  // NOTE: some transforms are safe, but we consider them to be non-profitable.\n  // For example, we could merge \"fptoui double to i32\" + \"zext i32 to i64\",\n  // into \"fptoui double to i64\", but this loses information about the range\n  // of the produced value (we no longer know the top-part is all zeros).\n  // Further this conversion is often much more expensive for typical hardware,\n  // and causes issues when building libgcc.  We disallow fptosi+sext for the\n  // same reason.\n  const unsigned numCastOps =\n    Instruction::CastOpsEnd - Instruction::CastOpsBegin;\n  static const uint8_t CastResults[numCastOps][numCastOps] = {\n    // T        F  F  U  S  F  F  P  I  B  A  -+\n    // R  Z  S  P  P  I  I  T  P  2  N  T  S   |\n    // U  E  E  2  2  2  2  R  E  I  T  C  C   +- secondOp\n    // N  X  X  U  S  F  F  N  X  N  2  V  V   |\n    // C  T  T  I  I  P  P  C  T  T  P  T  T  -+\n    {  1, 0, 0,99,99, 0, 0,99,99,99, 0, 3, 0}, // Trunc         -+\n    {  8, 1, 9,99,99, 2,17,99,99,99, 2, 3, 0}, // ZExt           |\n    {  8, 0, 1,99,99, 0, 2,99,99,99, 0, 3, 0}, // SExt           |\n    {  0, 0, 0,99,99, 0, 0,99,99,99, 0, 3, 0}, // FPToUI         |\n    {  0, 0, 0,99,99, 0, 0,99,99,99, 0, 3, 0}, // FPToSI         |\n    { 99,99,99, 0, 0,99,99, 0, 0,99,99, 4, 0}, // UIToFP         +- firstOp\n    { 99,99,99, 0, 0,99,99, 0, 0,99,99, 4, 0}, // SIToFP         |\n    { 99,99,99, 0, 0,99,99, 0, 0,99,99, 4, 0}, // FPTrunc        |\n    { 99,99,99, 2, 2,99,99, 8, 2,99,99, 4, 0}, // FPExt          |\n    {  1, 0, 0,99,99, 0, 0,99,99,99, 7, 3, 0}, // PtrToInt       |\n    { 99,99,99,99,99,99,99,99,99,11,99,15, 0}, // IntToPtr       |\n    {  5, 5, 5, 6, 6, 5, 5, 6, 6,16, 5, 1,14}, // BitCast        |\n    {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13,12}, // AddrSpaceCast -+\n  };\n\n  // TODO: This logic could be encoded into the table above and handled in the\n  // switch below.\n  // If either of the casts are a bitcast from scalar to vector, disallow the\n  // merging. However, any pair of bitcasts are allowed.\n  bool IsFirstBitcast  = (firstOp == Instruction::BitCast);\n  bool IsSecondBitcast = (secondOp == Instruction::BitCast);\n  bool AreBothBitcasts = IsFirstBitcast && IsSecondBitcast;\n\n  // Check if any of the casts convert scalars <-> vectors.\n  if ((IsFirstBitcast  && isa<VectorType>(SrcTy) != isa<VectorType>(MidTy)) ||\n      (IsSecondBitcast && isa<VectorType>(MidTy) != isa<VectorType>(DstTy)))\n    if (!AreBothBitcasts)\n      return 0;\n\n  int ElimCase = CastResults[firstOp-Instruction::CastOpsBegin]\n                            [secondOp-Instruction::CastOpsBegin];\n  switch (ElimCase) {\n    case 0:\n      // Categorically disallowed.\n      return 0;\n    case 1:\n      // Allowed, use first cast's opcode.\n      return firstOp;\n    case 2:\n      // Allowed, use second cast's opcode.\n      return secondOp;\n    case 3:\n      // No-op cast in second op implies firstOp as long as the DestTy\n      // is integer and we are not converting between a vector and a\n      // non-vector type.\n      if (!SrcTy->isVectorTy() && DstTy->isIntegerTy())\n        return firstOp;\n      return 0;\n    case 4:\n      // No-op cast in second op implies firstOp as long as the DestTy\n      // is floating point.\n      if (DstTy->isFloatingPointTy())\n        return firstOp;\n      return 0;\n    case 5:\n      // No-op cast in first op implies secondOp as long as the SrcTy\n      // is an integer.\n      if (SrcTy->isIntegerTy())\n        return secondOp;\n      return 0;\n    case 6:\n      // No-op cast in first op implies secondOp as long as the SrcTy\n      // is a floating point.\n      if (SrcTy->isFloatingPointTy())\n        return secondOp;\n      return 0;\n    case 7: {\n      // Cannot simplify if address spaces are different!\n      if (SrcTy->getPointerAddressSpace() != DstTy->getPointerAddressSpace())\n        return 0;\n\n      unsigned MidSize = MidTy->getScalarSizeInBits();\n      // We can still fold this without knowing the actual sizes as long we\n      // know that the intermediate pointer is the largest possible\n      // pointer size.\n      // FIXME: Is this always true?\n      if (MidSize == 64)\n        return Instruction::BitCast;\n\n      // ptrtoint, inttoptr -> bitcast (ptr -> ptr) if int size is >= ptr size.\n      if (!SrcIntPtrTy || DstIntPtrTy != SrcIntPtrTy)\n        return 0;\n      unsigned PtrSize = SrcIntPtrTy->getScalarSizeInBits();\n      if (MidSize >= PtrSize)\n        return Instruction::BitCast;\n      return 0;\n    }\n    case 8: {\n      // ext, trunc -> bitcast,    if the SrcTy and DstTy are same size\n      // ext, trunc -> ext,        if sizeof(SrcTy) < sizeof(DstTy)\n      // ext, trunc -> trunc,      if sizeof(SrcTy) > sizeof(DstTy)\n      unsigned SrcSize = SrcTy->getScalarSizeInBits();\n      unsigned DstSize = DstTy->getScalarSizeInBits();\n      if (SrcSize == DstSize)\n        return Instruction::BitCast;\n      else if (SrcSize < DstSize)\n        return firstOp;\n      return secondOp;\n    }\n    case 9:\n      // zext, sext -> zext, because sext can't sign extend after zext\n      return Instruction::ZExt;\n    case 11: {\n      // inttoptr, ptrtoint -> bitcast if SrcSize<=PtrSize and SrcSize==DstSize\n      if (!MidIntPtrTy)\n        return 0;\n      unsigned PtrSize = MidIntPtrTy->getScalarSizeInBits();\n      unsigned SrcSize = SrcTy->getScalarSizeInBits();\n      unsigned DstSize = DstTy->getScalarSizeInBits();\n      if (SrcSize <= PtrSize && SrcSize == DstSize)\n        return Instruction::BitCast;\n      return 0;\n    }\n    case 12:\n      // addrspacecast, addrspacecast -> bitcast,       if SrcAS == DstAS\n      // addrspacecast, addrspacecast -> addrspacecast, if SrcAS != DstAS\n      if (SrcTy->getPointerAddressSpace() != DstTy->getPointerAddressSpace())\n        return Instruction::AddrSpaceCast;\n      return Instruction::BitCast;\n    case 13:\n      // FIXME: this state can be merged with (1), but the following assert\n      // is useful to check the correcteness of the sequence due to semantic\n      // change of bitcast.\n      assert(\n        SrcTy->isPtrOrPtrVectorTy() &&\n        MidTy->isPtrOrPtrVectorTy() &&\n        DstTy->isPtrOrPtrVectorTy() &&\n        SrcTy->getPointerAddressSpace() != MidTy->getPointerAddressSpace() &&\n        MidTy->getPointerAddressSpace() == DstTy->getPointerAddressSpace() &&\n        \"Illegal addrspacecast, bitcast sequence!\");\n      // Allowed, use first cast's opcode\n      return firstOp;\n    case 14:\n      // bitcast, addrspacecast -> addrspacecast if the element type of\n      // bitcast's source is the same as that of addrspacecast's destination.\n      if (SrcTy->getScalarType()->getPointerElementType() ==\n          DstTy->getScalarType()->getPointerElementType())\n        return Instruction::AddrSpaceCast;\n      return 0;\n    case 15:\n      // FIXME: this state can be merged with (1), but the following assert\n      // is useful to check the correcteness of the sequence due to semantic\n      // change of bitcast.\n      assert(\n        SrcTy->isIntOrIntVectorTy() &&\n        MidTy->isPtrOrPtrVectorTy() &&\n        DstTy->isPtrOrPtrVectorTy() &&\n        MidTy->getPointerAddressSpace() == DstTy->getPointerAddressSpace() &&\n        \"Illegal inttoptr, bitcast sequence!\");\n      // Allowed, use first cast's opcode\n      return firstOp;\n    case 16:\n      // FIXME: this state can be merged with (2), but the following assert\n      // is useful to check the correcteness of the sequence due to semantic\n      // change of bitcast.\n      assert(\n        SrcTy->isPtrOrPtrVectorTy() &&\n        MidTy->isPtrOrPtrVectorTy() &&\n        DstTy->isIntOrIntVectorTy() &&\n        SrcTy->getPointerAddressSpace() == MidTy->getPointerAddressSpace() &&\n        \"Illegal bitcast, ptrtoint sequence!\");\n      // Allowed, use second cast's opcode\n      return secondOp;\n    case 17:\n      // (sitofp (zext x)) -> (uitofp x)\n      return Instruction::UIToFP;\n    case 99:\n      // Cast combination can't happen (error in input). This is for all cases\n      // where the MidTy is not the same for the two cast instructions.\n      llvm_unreachable(\"Invalid Cast Combination\");\n    default:\n      llvm_unreachable(\"Error in CastResults table!!!\");\n  }\n}\n\nCastInst *CastInst::Create(Instruction::CastOps op, Value *S, Type *Ty,\n  const Twine &Name, Instruction *InsertBefore) {\n  assert(castIsValid(op, S, Ty) && \"Invalid cast!\");\n  // Construct and return the appropriate CastInst subclass\n  switch (op) {\n  case Trunc:         return new TruncInst         (S, Ty, Name, InsertBefore);\n  case ZExt:          return new ZExtInst          (S, Ty, Name, InsertBefore);\n  case SExt:          return new SExtInst          (S, Ty, Name, InsertBefore);\n  case FPTrunc:       return new FPTruncInst       (S, Ty, Name, InsertBefore);\n  case FPExt:         return new FPExtInst         (S, Ty, Name, InsertBefore);\n  case UIToFP:        return new UIToFPInst        (S, Ty, Name, InsertBefore);\n  case SIToFP:        return new SIToFPInst        (S, Ty, Name, InsertBefore);\n  case FPToUI:        return new FPToUIInst        (S, Ty, Name, InsertBefore);\n  case FPToSI:        return new FPToSIInst        (S, Ty, Name, InsertBefore);\n  case PtrToInt:      return new PtrToIntInst      (S, Ty, Name, InsertBefore);\n  case IntToPtr:      return new IntToPtrInst      (S, Ty, Name, InsertBefore);\n  case BitCast:       return new BitCastInst       (S, Ty, Name, InsertBefore);\n  case AddrSpaceCast: return new AddrSpaceCastInst (S, Ty, Name, InsertBefore);\n  default: llvm_unreachable(\"Invalid opcode provided\");\n  }\n}\n\nCastInst *CastInst::Create(Instruction::CastOps op, Value *S, Type *Ty,\n  const Twine &Name, BasicBlock *InsertAtEnd) {\n  assert(castIsValid(op, S, Ty) && \"Invalid cast!\");\n  // Construct and return the appropriate CastInst subclass\n  switch (op) {\n  case Trunc:         return new TruncInst         (S, Ty, Name, InsertAtEnd);\n  case ZExt:          return new ZExtInst          (S, Ty, Name, InsertAtEnd);\n  case SExt:          return new SExtInst          (S, Ty, Name, InsertAtEnd);\n  case FPTrunc:       return new FPTruncInst       (S, Ty, Name, InsertAtEnd);\n  case FPExt:         return new FPExtInst         (S, Ty, Name, InsertAtEnd);\n  case UIToFP:        return new UIToFPInst        (S, Ty, Name, InsertAtEnd);\n  case SIToFP:        return new SIToFPInst        (S, Ty, Name, InsertAtEnd);\n  case FPToUI:        return new FPToUIInst        (S, Ty, Name, InsertAtEnd);\n  case FPToSI:        return new FPToSIInst        (S, Ty, Name, InsertAtEnd);\n  case PtrToInt:      return new PtrToIntInst      (S, Ty, Name, InsertAtEnd);\n  case IntToPtr:      return new IntToPtrInst      (S, Ty, Name, InsertAtEnd);\n  case BitCast:       return new BitCastInst       (S, Ty, Name, InsertAtEnd);\n  case AddrSpaceCast: return new AddrSpaceCastInst (S, Ty, Name, InsertAtEnd);\n  default: llvm_unreachable(\"Invalid opcode provided\");\n  }\n}\n\nCastInst *CastInst::CreateZExtOrBitCast(Value *S, Type *Ty,\n                                        const Twine &Name,\n                                        Instruction *InsertBefore) {\n  if (S->getType()->getScalarSizeInBits() == Ty->getScalarSizeInBits())\n    return Create(Instruction::BitCast, S, Ty, Name, InsertBefore);\n  return Create(Instruction::ZExt, S, Ty, Name, InsertBefore);\n}\n\nCastInst *CastInst::CreateZExtOrBitCast(Value *S, Type *Ty,\n                                        const Twine &Name,\n                                        BasicBlock *InsertAtEnd) {\n  if (S->getType()->getScalarSizeInBits() == Ty->getScalarSizeInBits())\n    return Create(Instruction::BitCast, S, Ty, Name, InsertAtEnd);\n  return Create(Instruction::ZExt, S, Ty, Name, InsertAtEnd);\n}\n\nCastInst *CastInst::CreateSExtOrBitCast(Value *S, Type *Ty,\n                                        const Twine &Name,\n                                        Instruction *InsertBefore) {\n  if (S->getType()->getScalarSizeInBits() == Ty->getScalarSizeInBits())\n    return Create(Instruction::BitCast, S, Ty, Name, InsertBefore);\n  return Create(Instruction::SExt, S, Ty, Name, InsertBefore);\n}\n\nCastInst *CastInst::CreateSExtOrBitCast(Value *S, Type *Ty,\n                                        const Twine &Name,\n                                        BasicBlock *InsertAtEnd) {\n  if (S->getType()->getScalarSizeInBits() == Ty->getScalarSizeInBits())\n    return Create(Instruction::BitCast, S, Ty, Name, InsertAtEnd);\n  return Create(Instruction::SExt, S, Ty, Name, InsertAtEnd);\n}\n\nCastInst *CastInst::CreateTruncOrBitCast(Value *S, Type *Ty,\n                                         const Twine &Name,\n                                         Instruction *InsertBefore) {\n  if (S->getType()->getScalarSizeInBits() == Ty->getScalarSizeInBits())\n    return Create(Instruction::BitCast, S, Ty, Name, InsertBefore);\n  return Create(Instruction::Trunc, S, Ty, Name, InsertBefore);\n}\n\nCastInst *CastInst::CreateTruncOrBitCast(Value *S, Type *Ty,\n                                         const Twine &Name,\n                                         BasicBlock *InsertAtEnd) {\n  if (S->getType()->getScalarSizeInBits() == Ty->getScalarSizeInBits())\n    return Create(Instruction::BitCast, S, Ty, Name, InsertAtEnd);\n  return Create(Instruction::Trunc, S, Ty, Name, InsertAtEnd);\n}\n\nCastInst *CastInst::CreatePointerCast(Value *S, Type *Ty,\n                                      const Twine &Name,\n                                      BasicBlock *InsertAtEnd) {\n  assert(S->getType()->isPtrOrPtrVectorTy() && \"Invalid cast\");\n  assert((Ty->isIntOrIntVectorTy() || Ty->isPtrOrPtrVectorTy()) &&\n         \"Invalid cast\");\n  assert(Ty->isVectorTy() == S->getType()->isVectorTy() && \"Invalid cast\");\n  assert((!Ty->isVectorTy() ||\n          cast<VectorType>(Ty)->getElementCount() ==\n              cast<VectorType>(S->getType())->getElementCount()) &&\n         \"Invalid cast\");\n\n  if (Ty->isIntOrIntVectorTy())\n    return Create(Instruction::PtrToInt, S, Ty, Name, InsertAtEnd);\n\n  return CreatePointerBitCastOrAddrSpaceCast(S, Ty, Name, InsertAtEnd);\n}\n\n/// Create a BitCast or a PtrToInt cast instruction\nCastInst *CastInst::CreatePointerCast(Value *S, Type *Ty,\n                                      const Twine &Name,\n                                      Instruction *InsertBefore) {\n  assert(S->getType()->isPtrOrPtrVectorTy() && \"Invalid cast\");\n  assert((Ty->isIntOrIntVectorTy() || Ty->isPtrOrPtrVectorTy()) &&\n         \"Invalid cast\");\n  assert(Ty->isVectorTy() == S->getType()->isVectorTy() && \"Invalid cast\");\n  assert((!Ty->isVectorTy() ||\n          cast<VectorType>(Ty)->getElementCount() ==\n              cast<VectorType>(S->getType())->getElementCount()) &&\n         \"Invalid cast\");\n\n  if (Ty->isIntOrIntVectorTy())\n    return Create(Instruction::PtrToInt, S, Ty, Name, InsertBefore);\n\n  return CreatePointerBitCastOrAddrSpaceCast(S, Ty, Name, InsertBefore);\n}\n\nCastInst *CastInst::CreatePointerBitCastOrAddrSpaceCast(\n  Value *S, Type *Ty,\n  const Twine &Name,\n  BasicBlock *InsertAtEnd) {\n  assert(S->getType()->isPtrOrPtrVectorTy() && \"Invalid cast\");\n  assert(Ty->isPtrOrPtrVectorTy() && \"Invalid cast\");\n\n  if (S->getType()->getPointerAddressSpace() != Ty->getPointerAddressSpace())\n    return Create(Instruction::AddrSpaceCast, S, Ty, Name, InsertAtEnd);\n\n  return Create(Instruction::BitCast, S, Ty, Name, InsertAtEnd);\n}\n\nCastInst *CastInst::CreatePointerBitCastOrAddrSpaceCast(\n  Value *S, Type *Ty,\n  const Twine &Name,\n  Instruction *InsertBefore) {\n  assert(S->getType()->isPtrOrPtrVectorTy() && \"Invalid cast\");\n  assert(Ty->isPtrOrPtrVectorTy() && \"Invalid cast\");\n\n  if (S->getType()->getPointerAddressSpace() != Ty->getPointerAddressSpace())\n    return Create(Instruction::AddrSpaceCast, S, Ty, Name, InsertBefore);\n\n  return Create(Instruction::BitCast, S, Ty, Name, InsertBefore);\n}\n\nCastInst *CastInst::CreateBitOrPointerCast(Value *S, Type *Ty,\n                                           const Twine &Name,\n                                           Instruction *InsertBefore) {\n  if (S->getType()->isPointerTy() && Ty->isIntegerTy())\n    return Create(Instruction::PtrToInt, S, Ty, Name, InsertBefore);\n  if (S->getType()->isIntegerTy() && Ty->isPointerTy())\n    return Create(Instruction::IntToPtr, S, Ty, Name, InsertBefore);\n\n  return Create(Instruction::BitCast, S, Ty, Name, InsertBefore);\n}\n\nCastInst *CastInst::CreateIntegerCast(Value *C, Type *Ty,\n                                      bool isSigned, const Twine &Name,\n                                      Instruction *InsertBefore) {\n  assert(C->getType()->isIntOrIntVectorTy() && Ty->isIntOrIntVectorTy() &&\n         \"Invalid integer cast\");\n  unsigned SrcBits = C->getType()->getScalarSizeInBits();\n  unsigned DstBits = Ty->getScalarSizeInBits();\n  Instruction::CastOps opcode =\n    (SrcBits == DstBits ? Instruction::BitCast :\n     (SrcBits > DstBits ? Instruction::Trunc :\n      (isSigned ? Instruction::SExt : Instruction::ZExt)));\n  return Create(opcode, C, Ty, Name, InsertBefore);\n}\n\nCastInst *CastInst::CreateIntegerCast(Value *C, Type *Ty,\n                                      bool isSigned, const Twine &Name,\n                                      BasicBlock *InsertAtEnd) {\n  assert(C->getType()->isIntOrIntVectorTy() && Ty->isIntOrIntVectorTy() &&\n         \"Invalid cast\");\n  unsigned SrcBits = C->getType()->getScalarSizeInBits();\n  unsigned DstBits = Ty->getScalarSizeInBits();\n  Instruction::CastOps opcode =\n    (SrcBits == DstBits ? Instruction::BitCast :\n     (SrcBits > DstBits ? Instruction::Trunc :\n      (isSigned ? Instruction::SExt : Instruction::ZExt)));\n  return Create(opcode, C, Ty, Name, InsertAtEnd);\n}\n\nCastInst *CastInst::CreateFPCast(Value *C, Type *Ty,\n                                 const Twine &Name,\n                                 Instruction *InsertBefore) {\n  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&\n         \"Invalid cast\");\n  unsigned SrcBits = C->getType()->getScalarSizeInBits();\n  unsigned DstBits = Ty->getScalarSizeInBits();\n  Instruction::CastOps opcode =\n    (SrcBits == DstBits ? Instruction::BitCast :\n     (SrcBits > DstBits ? Instruction::FPTrunc : Instruction::FPExt));\n  return Create(opcode, C, Ty, Name, InsertBefore);\n}\n\nCastInst *CastInst::CreateFPCast(Value *C, Type *Ty,\n                                 const Twine &Name,\n                                 BasicBlock *InsertAtEnd) {\n  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&\n         \"Invalid cast\");\n  unsigned SrcBits = C->getType()->getScalarSizeInBits();\n  unsigned DstBits = Ty->getScalarSizeInBits();\n  Instruction::CastOps opcode =\n    (SrcBits == DstBits ? Instruction::BitCast :\n     (SrcBits > DstBits ? Instruction::FPTrunc : Instruction::FPExt));\n  return Create(opcode, C, Ty, Name, InsertAtEnd);\n}\n\nbool CastInst::isBitCastable(Type *SrcTy, Type *DestTy) {\n  if (!SrcTy->isFirstClassType() || !DestTy->isFirstClassType())\n    return false;\n\n  if (SrcTy == DestTy)\n    return true;\n\n  if (VectorType *SrcVecTy = dyn_cast<VectorType>(SrcTy)) {\n    if (VectorType *DestVecTy = dyn_cast<VectorType>(DestTy)) {\n      if (SrcVecTy->getElementCount() == DestVecTy->getElementCount()) {\n        // An element by element cast. Valid if casting the elements is valid.\n        SrcTy = SrcVecTy->getElementType();\n        DestTy = DestVecTy->getElementType();\n      }\n    }\n  }\n\n  if (PointerType *DestPtrTy = dyn_cast<PointerType>(DestTy)) {\n    if (PointerType *SrcPtrTy = dyn_cast<PointerType>(SrcTy)) {\n      return SrcPtrTy->getAddressSpace() == DestPtrTy->getAddressSpace();\n    }\n  }\n\n  TypeSize SrcBits = SrcTy->getPrimitiveSizeInBits();   // 0 for ptr\n  TypeSize DestBits = DestTy->getPrimitiveSizeInBits(); // 0 for ptr\n\n  // Could still have vectors of pointers if the number of elements doesn't\n  // match\n  if (SrcBits.getKnownMinSize() == 0 || DestBits.getKnownMinSize() == 0)\n    return false;\n\n  if (SrcBits != DestBits)\n    return false;\n\n  if (DestTy->isX86_MMXTy() || SrcTy->isX86_MMXTy())\n    return false;\n\n  return true;\n}\n\nbool CastInst::isBitOrNoopPointerCastable(Type *SrcTy, Type *DestTy,\n                                          const DataLayout &DL) {\n  // ptrtoint and inttoptr are not allowed on non-integral pointers\n  if (auto *PtrTy = dyn_cast<PointerType>(SrcTy))\n    if (auto *IntTy = dyn_cast<IntegerType>(DestTy))\n      return (IntTy->getBitWidth() == DL.getPointerTypeSizeInBits(PtrTy) &&\n              !DL.isNonIntegralPointerType(PtrTy));\n  if (auto *PtrTy = dyn_cast<PointerType>(DestTy))\n    if (auto *IntTy = dyn_cast<IntegerType>(SrcTy))\n      return (IntTy->getBitWidth() == DL.getPointerTypeSizeInBits(PtrTy) &&\n              !DL.isNonIntegralPointerType(PtrTy));\n\n  return isBitCastable(SrcTy, DestTy);\n}\n\n// Provide a way to get a \"cast\" where the cast opcode is inferred from the\n// types and size of the operand. This, basically, is a parallel of the\n// logic in the castIsValid function below.  This axiom should hold:\n//   castIsValid( getCastOpcode(Val, Ty), Val, Ty)\n// should not assert in castIsValid. In other words, this produces a \"correct\"\n// casting opcode for the arguments passed to it.\nInstruction::CastOps\nCastInst::getCastOpcode(\n  const Value *Src, bool SrcIsSigned, Type *DestTy, bool DestIsSigned) {\n  Type *SrcTy = Src->getType();\n\n  assert(SrcTy->isFirstClassType() && DestTy->isFirstClassType() &&\n         \"Only first class types are castable!\");\n\n  if (SrcTy == DestTy)\n    return BitCast;\n\n  // FIXME: Check address space sizes here\n  if (VectorType *SrcVecTy = dyn_cast<VectorType>(SrcTy))\n    if (VectorType *DestVecTy = dyn_cast<VectorType>(DestTy))\n      if (SrcVecTy->getElementCount() == DestVecTy->getElementCount()) {\n        // An element by element cast.  Find the appropriate opcode based on the\n        // element types.\n        SrcTy = SrcVecTy->getElementType();\n        DestTy = DestVecTy->getElementType();\n      }\n\n  // Get the bit sizes, we'll need these\n  unsigned SrcBits = SrcTy->getPrimitiveSizeInBits();   // 0 for ptr\n  unsigned DestBits = DestTy->getPrimitiveSizeInBits(); // 0 for ptr\n\n  // Run through the possibilities ...\n  if (DestTy->isIntegerTy()) {                      // Casting to integral\n    if (SrcTy->isIntegerTy()) {                     // Casting from integral\n      if (DestBits < SrcBits)\n        return Trunc;                               // int -> smaller int\n      else if (DestBits > SrcBits) {                // its an extension\n        if (SrcIsSigned)\n          return SExt;                              // signed -> SEXT\n        else\n          return ZExt;                              // unsigned -> ZEXT\n      } else {\n        return BitCast;                             // Same size, No-op cast\n      }\n    } else if (SrcTy->isFloatingPointTy()) {        // Casting from floating pt\n      if (DestIsSigned)\n        return FPToSI;                              // FP -> sint\n      else\n        return FPToUI;                              // FP -> uint\n    } else if (SrcTy->isVectorTy()) {\n      assert(DestBits == SrcBits &&\n             \"Casting vector to integer of different width\");\n      return BitCast;                             // Same size, no-op cast\n    } else {\n      assert(SrcTy->isPointerTy() &&\n             \"Casting from a value that is not first-class type\");\n      return PtrToInt;                              // ptr -> int\n    }\n  } else if (DestTy->isFloatingPointTy()) {         // Casting to floating pt\n    if (SrcTy->isIntegerTy()) {                     // Casting from integral\n      if (SrcIsSigned)\n        return SIToFP;                              // sint -> FP\n      else\n        return UIToFP;                              // uint -> FP\n    } else if (SrcTy->isFloatingPointTy()) {        // Casting from floating pt\n      if (DestBits < SrcBits) {\n        return FPTrunc;                             // FP -> smaller FP\n      } else if (DestBits > SrcBits) {\n        return FPExt;                               // FP -> larger FP\n      } else  {\n        return BitCast;                             // same size, no-op cast\n      }\n    } else if (SrcTy->isVectorTy()) {\n      assert(DestBits == SrcBits &&\n             \"Casting vector to floating point of different width\");\n      return BitCast;                             // same size, no-op cast\n    }\n    llvm_unreachable(\"Casting pointer or non-first class to float\");\n  } else if (DestTy->isVectorTy()) {\n    assert(DestBits == SrcBits &&\n           \"Illegal cast to vector (wrong type or size)\");\n    return BitCast;\n  } else if (DestTy->isPointerTy()) {\n    if (SrcTy->isPointerTy()) {\n      if (DestTy->getPointerAddressSpace() != SrcTy->getPointerAddressSpace())\n        return AddrSpaceCast;\n      return BitCast;                               // ptr -> ptr\n    } else if (SrcTy->isIntegerTy()) {\n      return IntToPtr;                              // int -> ptr\n    }\n    llvm_unreachable(\"Casting pointer to other than pointer or int\");\n  } else if (DestTy->isX86_MMXTy()) {\n    if (SrcTy->isVectorTy()) {\n      assert(DestBits == SrcBits && \"Casting vector of wrong width to X86_MMX\");\n      return BitCast;                               // 64-bit vector to MMX\n    }\n    llvm_unreachable(\"Illegal cast to X86_MMX\");\n  }\n  llvm_unreachable(\"Casting to type that is not first-class\");\n}\n\n//===----------------------------------------------------------------------===//\n//                    CastInst SubClass Constructors\n//===----------------------------------------------------------------------===//\n\n/// Check that the construction parameters for a CastInst are correct. This\n/// could be broken out into the separate constructors but it is useful to have\n/// it in one place and to eliminate the redundant code for getting the sizes\n/// of the types involved.\nbool\nCastInst::castIsValid(Instruction::CastOps op, Type *SrcTy, Type *DstTy) {\n  if (!SrcTy->isFirstClassType() || !DstTy->isFirstClassType() ||\n      SrcTy->isAggregateType() || DstTy->isAggregateType())\n    return false;\n\n  // Get the size of the types in bits, and whether we are dealing\n  // with vector types, we'll need this later.\n  bool SrcIsVec = isa<VectorType>(SrcTy);\n  bool DstIsVec = isa<VectorType>(DstTy);\n  unsigned SrcScalarBitSize = SrcTy->getScalarSizeInBits();\n  unsigned DstScalarBitSize = DstTy->getScalarSizeInBits();\n\n  // If these are vector types, get the lengths of the vectors (using zero for\n  // scalar types means that checking that vector lengths match also checks that\n  // scalars are not being converted to vectors or vectors to scalars).\n  ElementCount SrcEC = SrcIsVec ? cast<VectorType>(SrcTy)->getElementCount()\n                                : ElementCount::getFixed(0);\n  ElementCount DstEC = DstIsVec ? cast<VectorType>(DstTy)->getElementCount()\n                                : ElementCount::getFixed(0);\n\n  // Switch on the opcode provided\n  switch (op) {\n  default: return false; // This is an input error\n  case Instruction::Trunc:\n    return SrcTy->isIntOrIntVectorTy() && DstTy->isIntOrIntVectorTy() &&\n           SrcEC == DstEC && SrcScalarBitSize > DstScalarBitSize;\n  case Instruction::ZExt:\n    return SrcTy->isIntOrIntVectorTy() && DstTy->isIntOrIntVectorTy() &&\n           SrcEC == DstEC && SrcScalarBitSize < DstScalarBitSize;\n  case Instruction::SExt:\n    return SrcTy->isIntOrIntVectorTy() && DstTy->isIntOrIntVectorTy() &&\n           SrcEC == DstEC && SrcScalarBitSize < DstScalarBitSize;\n  case Instruction::FPTrunc:\n    return SrcTy->isFPOrFPVectorTy() && DstTy->isFPOrFPVectorTy() &&\n           SrcEC == DstEC && SrcScalarBitSize > DstScalarBitSize;\n  case Instruction::FPExt:\n    return SrcTy->isFPOrFPVectorTy() && DstTy->isFPOrFPVectorTy() &&\n           SrcEC == DstEC && SrcScalarBitSize < DstScalarBitSize;\n  case Instruction::UIToFP:\n  case Instruction::SIToFP:\n    return SrcTy->isIntOrIntVectorTy() && DstTy->isFPOrFPVectorTy() &&\n           SrcEC == DstEC;\n  case Instruction::FPToUI:\n  case Instruction::FPToSI:\n    return SrcTy->isFPOrFPVectorTy() && DstTy->isIntOrIntVectorTy() &&\n           SrcEC == DstEC;\n  case Instruction::PtrToInt:\n    if (SrcEC != DstEC)\n      return false;\n    return SrcTy->isPtrOrPtrVectorTy() && DstTy->isIntOrIntVectorTy();\n  case Instruction::IntToPtr:\n    if (SrcEC != DstEC)\n      return false;\n    return SrcTy->isIntOrIntVectorTy() && DstTy->isPtrOrPtrVectorTy();\n  case Instruction::BitCast: {\n    PointerType *SrcPtrTy = dyn_cast<PointerType>(SrcTy->getScalarType());\n    PointerType *DstPtrTy = dyn_cast<PointerType>(DstTy->getScalarType());\n\n    // BitCast implies a no-op cast of type only. No bits change.\n    // However, you can't cast pointers to anything but pointers.\n    if (!SrcPtrTy != !DstPtrTy)\n      return false;\n\n    // For non-pointer cases, the cast is okay if the source and destination bit\n    // widths are identical.\n    if (!SrcPtrTy)\n      return SrcTy->getPrimitiveSizeInBits() == DstTy->getPrimitiveSizeInBits();\n\n    // If both are pointers then the address spaces must match.\n    if (SrcPtrTy->getAddressSpace() != DstPtrTy->getAddressSpace())\n      return false;\n\n    // A vector of pointers must have the same number of elements.\n    if (SrcIsVec && DstIsVec)\n      return SrcEC == DstEC;\n    if (SrcIsVec)\n      return SrcEC == ElementCount::getFixed(1);\n    if (DstIsVec)\n      return DstEC == ElementCount::getFixed(1);\n\n    return true;\n  }\n  case Instruction::AddrSpaceCast: {\n    PointerType *SrcPtrTy = dyn_cast<PointerType>(SrcTy->getScalarType());\n    if (!SrcPtrTy)\n      return false;\n\n    PointerType *DstPtrTy = dyn_cast<PointerType>(DstTy->getScalarType());\n    if (!DstPtrTy)\n      return false;\n\n    if (SrcPtrTy->getAddressSpace() == DstPtrTy->getAddressSpace())\n      return false;\n\n    return SrcEC == DstEC;\n  }\n  }\n}\n\nTruncInst::TruncInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, Trunc, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal Trunc\");\n}\n\nTruncInst::TruncInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, Trunc, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal Trunc\");\n}\n\nZExtInst::ZExtInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n)  : CastInst(Ty, ZExt, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal ZExt\");\n}\n\nZExtInst::ZExtInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n)  : CastInst(Ty, ZExt, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal ZExt\");\n}\nSExtInst::SExtInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, SExt, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal SExt\");\n}\n\nSExtInst::SExtInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n)  : CastInst(Ty, SExt, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal SExt\");\n}\n\nFPTruncInst::FPTruncInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, FPTrunc, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal FPTrunc\");\n}\n\nFPTruncInst::FPTruncInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, FPTrunc, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal FPTrunc\");\n}\n\nFPExtInst::FPExtInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, FPExt, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal FPExt\");\n}\n\nFPExtInst::FPExtInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, FPExt, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal FPExt\");\n}\n\nUIToFPInst::UIToFPInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, UIToFP, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal UIToFP\");\n}\n\nUIToFPInst::UIToFPInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, UIToFP, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal UIToFP\");\n}\n\nSIToFPInst::SIToFPInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, SIToFP, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal SIToFP\");\n}\n\nSIToFPInst::SIToFPInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, SIToFP, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal SIToFP\");\n}\n\nFPToUIInst::FPToUIInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, FPToUI, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal FPToUI\");\n}\n\nFPToUIInst::FPToUIInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, FPToUI, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal FPToUI\");\n}\n\nFPToSIInst::FPToSIInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, FPToSI, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal FPToSI\");\n}\n\nFPToSIInst::FPToSIInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, FPToSI, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal FPToSI\");\n}\n\nPtrToIntInst::PtrToIntInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, PtrToInt, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal PtrToInt\");\n}\n\nPtrToIntInst::PtrToIntInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, PtrToInt, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal PtrToInt\");\n}\n\nIntToPtrInst::IntToPtrInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, IntToPtr, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal IntToPtr\");\n}\n\nIntToPtrInst::IntToPtrInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, IntToPtr, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal IntToPtr\");\n}\n\nBitCastInst::BitCastInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, BitCast, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal BitCast\");\n}\n\nBitCastInst::BitCastInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, BitCast, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal BitCast\");\n}\n\nAddrSpaceCastInst::AddrSpaceCastInst(\n  Value *S, Type *Ty, const Twine &Name, Instruction *InsertBefore\n) : CastInst(Ty, AddrSpaceCast, S, Name, InsertBefore) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal AddrSpaceCast\");\n}\n\nAddrSpaceCastInst::AddrSpaceCastInst(\n  Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd\n) : CastInst(Ty, AddrSpaceCast, S, Name, InsertAtEnd) {\n  assert(castIsValid(getOpcode(), S, Ty) && \"Illegal AddrSpaceCast\");\n}\n\n//===----------------------------------------------------------------------===//\n//                               CmpInst Classes\n//===----------------------------------------------------------------------===//\n\nCmpInst::CmpInst(Type *ty, OtherOps op, Predicate predicate, Value *LHS,\n                 Value *RHS, const Twine &Name, Instruction *InsertBefore,\n                 Instruction *FlagsSource)\n  : Instruction(ty, op,\n                OperandTraits<CmpInst>::op_begin(this),\n                OperandTraits<CmpInst>::operands(this),\n                InsertBefore) {\n  Op<0>() = LHS;\n  Op<1>() = RHS;\n  setPredicate((Predicate)predicate);\n  setName(Name);\n  if (FlagsSource)\n    copyIRFlags(FlagsSource);\n}\n\nCmpInst::CmpInst(Type *ty, OtherOps op, Predicate predicate, Value *LHS,\n                 Value *RHS, const Twine &Name, BasicBlock *InsertAtEnd)\n  : Instruction(ty, op,\n                OperandTraits<CmpInst>::op_begin(this),\n                OperandTraits<CmpInst>::operands(this),\n                InsertAtEnd) {\n  Op<0>() = LHS;\n  Op<1>() = RHS;\n  setPredicate((Predicate)predicate);\n  setName(Name);\n}\n\nCmpInst *\nCmpInst::Create(OtherOps Op, Predicate predicate, Value *S1, Value *S2,\n                const Twine &Name, Instruction *InsertBefore) {\n  if (Op == Instruction::ICmp) {\n    if (InsertBefore)\n      return new ICmpInst(InsertBefore, CmpInst::Predicate(predicate),\n                          S1, S2, Name);\n    else\n      return new ICmpInst(CmpInst::Predicate(predicate),\n                          S1, S2, Name);\n  }\n\n  if (InsertBefore)\n    return new FCmpInst(InsertBefore, CmpInst::Predicate(predicate),\n                        S1, S2, Name);\n  else\n    return new FCmpInst(CmpInst::Predicate(predicate),\n                        S1, S2, Name);\n}\n\nCmpInst *\nCmpInst::Create(OtherOps Op, Predicate predicate, Value *S1, Value *S2,\n                const Twine &Name, BasicBlock *InsertAtEnd) {\n  if (Op == Instruction::ICmp) {\n    return new ICmpInst(*InsertAtEnd, CmpInst::Predicate(predicate),\n                        S1, S2, Name);\n  }\n  return new FCmpInst(*InsertAtEnd, CmpInst::Predicate(predicate),\n                      S1, S2, Name);\n}\n\nvoid CmpInst::swapOperands() {\n  if (ICmpInst *IC = dyn_cast<ICmpInst>(this))\n    IC->swapOperands();\n  else\n    cast<FCmpInst>(this)->swapOperands();\n}\n\nbool CmpInst::isCommutative() const {\n  if (const ICmpInst *IC = dyn_cast<ICmpInst>(this))\n    return IC->isCommutative();\n  return cast<FCmpInst>(this)->isCommutative();\n}\n\nbool CmpInst::isEquality(Predicate P) {\n  if (ICmpInst::isIntPredicate(P))\n    return ICmpInst::isEquality(P);\n  if (FCmpInst::isFPPredicate(P))\n    return FCmpInst::isEquality(P);\n  llvm_unreachable(\"Unsupported predicate kind\");\n}\n\nCmpInst::Predicate CmpInst::getInversePredicate(Predicate pred) {\n  switch (pred) {\n    default: llvm_unreachable(\"Unknown cmp predicate!\");\n    case ICMP_EQ: return ICMP_NE;\n    case ICMP_NE: return ICMP_EQ;\n    case ICMP_UGT: return ICMP_ULE;\n    case ICMP_ULT: return ICMP_UGE;\n    case ICMP_UGE: return ICMP_ULT;\n    case ICMP_ULE: return ICMP_UGT;\n    case ICMP_SGT: return ICMP_SLE;\n    case ICMP_SLT: return ICMP_SGE;\n    case ICMP_SGE: return ICMP_SLT;\n    case ICMP_SLE: return ICMP_SGT;\n\n    case FCMP_OEQ: return FCMP_UNE;\n    case FCMP_ONE: return FCMP_UEQ;\n    case FCMP_OGT: return FCMP_ULE;\n    case FCMP_OLT: return FCMP_UGE;\n    case FCMP_OGE: return FCMP_ULT;\n    case FCMP_OLE: return FCMP_UGT;\n    case FCMP_UEQ: return FCMP_ONE;\n    case FCMP_UNE: return FCMP_OEQ;\n    case FCMP_UGT: return FCMP_OLE;\n    case FCMP_ULT: return FCMP_OGE;\n    case FCMP_UGE: return FCMP_OLT;\n    case FCMP_ULE: return FCMP_OGT;\n    case FCMP_ORD: return FCMP_UNO;\n    case FCMP_UNO: return FCMP_ORD;\n    case FCMP_TRUE: return FCMP_FALSE;\n    case FCMP_FALSE: return FCMP_TRUE;\n  }\n}\n\nStringRef CmpInst::getPredicateName(Predicate Pred) {\n  switch (Pred) {\n  default:                   return \"unknown\";\n  case FCmpInst::FCMP_FALSE: return \"false\";\n  case FCmpInst::FCMP_OEQ:   return \"oeq\";\n  case FCmpInst::FCMP_OGT:   return \"ogt\";\n  case FCmpInst::FCMP_OGE:   return \"oge\";\n  case FCmpInst::FCMP_OLT:   return \"olt\";\n  case FCmpInst::FCMP_OLE:   return \"ole\";\n  case FCmpInst::FCMP_ONE:   return \"one\";\n  case FCmpInst::FCMP_ORD:   return \"ord\";\n  case FCmpInst::FCMP_UNO:   return \"uno\";\n  case FCmpInst::FCMP_UEQ:   return \"ueq\";\n  case FCmpInst::FCMP_UGT:   return \"ugt\";\n  case FCmpInst::FCMP_UGE:   return \"uge\";\n  case FCmpInst::FCMP_ULT:   return \"ult\";\n  case FCmpInst::FCMP_ULE:   return \"ule\";\n  case FCmpInst::FCMP_UNE:   return \"une\";\n  case FCmpInst::FCMP_TRUE:  return \"true\";\n  case ICmpInst::ICMP_EQ:    return \"eq\";\n  case ICmpInst::ICMP_NE:    return \"ne\";\n  case ICmpInst::ICMP_SGT:   return \"sgt\";\n  case ICmpInst::ICMP_SGE:   return \"sge\";\n  case ICmpInst::ICMP_SLT:   return \"slt\";\n  case ICmpInst::ICMP_SLE:   return \"sle\";\n  case ICmpInst::ICMP_UGT:   return \"ugt\";\n  case ICmpInst::ICMP_UGE:   return \"uge\";\n  case ICmpInst::ICMP_ULT:   return \"ult\";\n  case ICmpInst::ICMP_ULE:   return \"ule\";\n  }\n}\n\nICmpInst::Predicate ICmpInst::getSignedPredicate(Predicate pred) {\n  switch (pred) {\n    default: llvm_unreachable(\"Unknown icmp predicate!\");\n    case ICMP_EQ: case ICMP_NE:\n    case ICMP_SGT: case ICMP_SLT: case ICMP_SGE: case ICMP_SLE:\n       return pred;\n    case ICMP_UGT: return ICMP_SGT;\n    case ICMP_ULT: return ICMP_SLT;\n    case ICMP_UGE: return ICMP_SGE;\n    case ICMP_ULE: return ICMP_SLE;\n  }\n}\n\nICmpInst::Predicate ICmpInst::getUnsignedPredicate(Predicate pred) {\n  switch (pred) {\n    default: llvm_unreachable(\"Unknown icmp predicate!\");\n    case ICMP_EQ: case ICMP_NE:\n    case ICMP_UGT: case ICMP_ULT: case ICMP_UGE: case ICMP_ULE:\n       return pred;\n    case ICMP_SGT: return ICMP_UGT;\n    case ICMP_SLT: return ICMP_ULT;\n    case ICMP_SGE: return ICMP_UGE;\n    case ICMP_SLE: return ICMP_ULE;\n  }\n}\n\nCmpInst::Predicate CmpInst::getSwappedPredicate(Predicate pred) {\n  switch (pred) {\n    default: llvm_unreachable(\"Unknown cmp predicate!\");\n    case ICMP_EQ: case ICMP_NE:\n      return pred;\n    case ICMP_SGT: return ICMP_SLT;\n    case ICMP_SLT: return ICMP_SGT;\n    case ICMP_SGE: return ICMP_SLE;\n    case ICMP_SLE: return ICMP_SGE;\n    case ICMP_UGT: return ICMP_ULT;\n    case ICMP_ULT: return ICMP_UGT;\n    case ICMP_UGE: return ICMP_ULE;\n    case ICMP_ULE: return ICMP_UGE;\n\n    case FCMP_FALSE: case FCMP_TRUE:\n    case FCMP_OEQ: case FCMP_ONE:\n    case FCMP_UEQ: case FCMP_UNE:\n    case FCMP_ORD: case FCMP_UNO:\n      return pred;\n    case FCMP_OGT: return FCMP_OLT;\n    case FCMP_OLT: return FCMP_OGT;\n    case FCMP_OGE: return FCMP_OLE;\n    case FCMP_OLE: return FCMP_OGE;\n    case FCMP_UGT: return FCMP_ULT;\n    case FCMP_ULT: return FCMP_UGT;\n    case FCMP_UGE: return FCMP_ULE;\n    case FCMP_ULE: return FCMP_UGE;\n  }\n}\n\nbool CmpInst::isNonStrictPredicate(Predicate pred) {\n  switch (pred) {\n  case ICMP_SGE:\n  case ICMP_SLE:\n  case ICMP_UGE:\n  case ICMP_ULE:\n  case FCMP_OGE:\n  case FCMP_OLE:\n  case FCMP_UGE:\n  case FCMP_ULE:\n    return true;\n  default:\n    return false;\n  }\n}\n\nbool CmpInst::isStrictPredicate(Predicate pred) {\n  switch (pred) {\n  case ICMP_SGT:\n  case ICMP_SLT:\n  case ICMP_UGT:\n  case ICMP_ULT:\n  case FCMP_OGT:\n  case FCMP_OLT:\n  case FCMP_UGT:\n  case FCMP_ULT:\n    return true;\n  default:\n    return false;\n  }\n}\n\nCmpInst::Predicate CmpInst::getStrictPredicate(Predicate pred) {\n  switch (pred) {\n  case ICMP_SGE:\n    return ICMP_SGT;\n  case ICMP_SLE:\n    return ICMP_SLT;\n  case ICMP_UGE:\n    return ICMP_UGT;\n  case ICMP_ULE:\n    return ICMP_ULT;\n  case FCMP_OGE:\n    return FCMP_OGT;\n  case FCMP_OLE:\n    return FCMP_OLT;\n  case FCMP_UGE:\n    return FCMP_UGT;\n  case FCMP_ULE:\n    return FCMP_ULT;\n  default:\n    return pred;\n  }\n}\n\nCmpInst::Predicate CmpInst::getNonStrictPredicate(Predicate pred) {\n  switch (pred) {\n  case ICMP_SGT:\n    return ICMP_SGE;\n  case ICMP_SLT:\n    return ICMP_SLE;\n  case ICMP_UGT:\n    return ICMP_UGE;\n  case ICMP_ULT:\n    return ICMP_ULE;\n  case FCMP_OGT:\n    return FCMP_OGE;\n  case FCMP_OLT:\n    return FCMP_OLE;\n  case FCMP_UGT:\n    return FCMP_UGE;\n  case FCMP_ULT:\n    return FCMP_ULE;\n  default:\n    return pred;\n  }\n}\n\nCmpInst::Predicate CmpInst::getFlippedStrictnessPredicate(Predicate pred) {\n  assert(CmpInst::isRelational(pred) && \"Call only with relational predicate!\");\n\n  if (isStrictPredicate(pred))\n    return getNonStrictPredicate(pred);\n  if (isNonStrictPredicate(pred))\n    return getStrictPredicate(pred);\n\n  llvm_unreachable(\"Unknown predicate!\");\n}\n\nCmpInst::Predicate CmpInst::getSignedPredicate(Predicate pred) {\n  assert(CmpInst::isUnsigned(pred) && \"Call only with unsigned predicates!\");\n\n  switch (pred) {\n  default:\n    llvm_unreachable(\"Unknown predicate!\");\n  case CmpInst::ICMP_ULT:\n    return CmpInst::ICMP_SLT;\n  case CmpInst::ICMP_ULE:\n    return CmpInst::ICMP_SLE;\n  case CmpInst::ICMP_UGT:\n    return CmpInst::ICMP_SGT;\n  case CmpInst::ICMP_UGE:\n    return CmpInst::ICMP_SGE;\n  }\n}\n\nCmpInst::Predicate CmpInst::getUnsignedPredicate(Predicate pred) {\n  assert(CmpInst::isSigned(pred) && \"Call only with signed predicates!\");\n\n  switch (pred) {\n  default:\n    llvm_unreachable(\"Unknown predicate!\");\n  case CmpInst::ICMP_SLT:\n    return CmpInst::ICMP_ULT;\n  case CmpInst::ICMP_SLE:\n    return CmpInst::ICMP_ULE;\n  case CmpInst::ICMP_SGT:\n    return CmpInst::ICMP_UGT;\n  case CmpInst::ICMP_SGE:\n    return CmpInst::ICMP_UGE;\n  }\n}\n\nbool CmpInst::isUnsigned(Predicate predicate) {\n  switch (predicate) {\n    default: return false;\n    case ICmpInst::ICMP_ULT: case ICmpInst::ICMP_ULE: case ICmpInst::ICMP_UGT:\n    case ICmpInst::ICMP_UGE: return true;\n  }\n}\n\nbool CmpInst::isSigned(Predicate predicate) {\n  switch (predicate) {\n    default: return false;\n    case ICmpInst::ICMP_SLT: case ICmpInst::ICMP_SLE: case ICmpInst::ICMP_SGT:\n    case ICmpInst::ICMP_SGE: return true;\n  }\n}\n\nCmpInst::Predicate CmpInst::getFlippedSignednessPredicate(Predicate pred) {\n  assert(CmpInst::isRelational(pred) &&\n         \"Call only with non-equality predicates!\");\n\n  if (isSigned(pred))\n    return getUnsignedPredicate(pred);\n  if (isUnsigned(pred))\n    return getSignedPredicate(pred);\n\n  llvm_unreachable(\"Unknown predicate!\");\n}\n\nbool CmpInst::isOrdered(Predicate predicate) {\n  switch (predicate) {\n    default: return false;\n    case FCmpInst::FCMP_OEQ: case FCmpInst::FCMP_ONE: case FCmpInst::FCMP_OGT:\n    case FCmpInst::FCMP_OLT: case FCmpInst::FCMP_OGE: case FCmpInst::FCMP_OLE:\n    case FCmpInst::FCMP_ORD: return true;\n  }\n}\n\nbool CmpInst::isUnordered(Predicate predicate) {\n  switch (predicate) {\n    default: return false;\n    case FCmpInst::FCMP_UEQ: case FCmpInst::FCMP_UNE: case FCmpInst::FCMP_UGT:\n    case FCmpInst::FCMP_ULT: case FCmpInst::FCMP_UGE: case FCmpInst::FCMP_ULE:\n    case FCmpInst::FCMP_UNO: return true;\n  }\n}\n\nbool CmpInst::isTrueWhenEqual(Predicate predicate) {\n  switch(predicate) {\n    default: return false;\n    case ICMP_EQ:   case ICMP_UGE: case ICMP_ULE: case ICMP_SGE: case ICMP_SLE:\n    case FCMP_TRUE: case FCMP_UEQ: case FCMP_UGE: case FCMP_ULE: return true;\n  }\n}\n\nbool CmpInst::isFalseWhenEqual(Predicate predicate) {\n  switch(predicate) {\n  case ICMP_NE:    case ICMP_UGT: case ICMP_ULT: case ICMP_SGT: case ICMP_SLT:\n  case FCMP_FALSE: case FCMP_ONE: case FCMP_OGT: case FCMP_OLT: return true;\n  default: return false;\n  }\n}\n\nbool CmpInst::isImpliedTrueByMatchingCmp(Predicate Pred1, Predicate Pred2) {\n  // If the predicates match, then we know the first condition implies the\n  // second is true.\n  if (Pred1 == Pred2)\n    return true;\n\n  switch (Pred1) {\n  default:\n    break;\n  case ICMP_EQ:\n    // A == B implies A >=u B, A <=u B, A >=s B, and A <=s B are true.\n    return Pred2 == ICMP_UGE || Pred2 == ICMP_ULE || Pred2 == ICMP_SGE ||\n           Pred2 == ICMP_SLE;\n  case ICMP_UGT: // A >u B implies A != B and A >=u B are true.\n    return Pred2 == ICMP_NE || Pred2 == ICMP_UGE;\n  case ICMP_ULT: // A <u B implies A != B and A <=u B are true.\n    return Pred2 == ICMP_NE || Pred2 == ICMP_ULE;\n  case ICMP_SGT: // A >s B implies A != B and A >=s B are true.\n    return Pred2 == ICMP_NE || Pred2 == ICMP_SGE;\n  case ICMP_SLT: // A <s B implies A != B and A <=s B are true.\n    return Pred2 == ICMP_NE || Pred2 == ICMP_SLE;\n  }\n  return false;\n}\n\nbool CmpInst::isImpliedFalseByMatchingCmp(Predicate Pred1, Predicate Pred2) {\n  return isImpliedTrueByMatchingCmp(Pred1, getInversePredicate(Pred2));\n}\n\n//===----------------------------------------------------------------------===//\n//                        SwitchInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid SwitchInst::init(Value *Value, BasicBlock *Default, unsigned NumReserved) {\n  assert(Value && Default && NumReserved);\n  ReservedSpace = NumReserved;\n  setNumHungOffUseOperands(2);\n  allocHungoffUses(ReservedSpace);\n\n  Op<0>() = Value;\n  Op<1>() = Default;\n}\n\n/// SwitchInst ctor - Create a new switch instruction, specifying a value to\n/// switch on and a default destination.  The number of additional cases can\n/// be specified here to make memory allocation more efficient.  This\n/// constructor can also autoinsert before another instruction.\nSwitchInst::SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,\n                       Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(Value->getContext()), Instruction::Switch,\n                  nullptr, 0, InsertBefore) {\n  init(Value, Default, 2+NumCases*2);\n}\n\n/// SwitchInst ctor - Create a new switch instruction, specifying a value to\n/// switch on and a default destination.  The number of additional cases can\n/// be specified here to make memory allocation more efficient.  This\n/// constructor also autoinserts at the end of the specified BasicBlock.\nSwitchInst::SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,\n                       BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(Value->getContext()), Instruction::Switch,\n                  nullptr, 0, InsertAtEnd) {\n  init(Value, Default, 2+NumCases*2);\n}\n\nSwitchInst::SwitchInst(const SwitchInst &SI)\n    : Instruction(SI.getType(), Instruction::Switch, nullptr, 0) {\n  init(SI.getCondition(), SI.getDefaultDest(), SI.getNumOperands());\n  setNumHungOffUseOperands(SI.getNumOperands());\n  Use *OL = getOperandList();\n  const Use *InOL = SI.getOperandList();\n  for (unsigned i = 2, E = SI.getNumOperands(); i != E; i += 2) {\n    OL[i] = InOL[i];\n    OL[i+1] = InOL[i+1];\n  }\n  SubclassOptionalData = SI.SubclassOptionalData;\n}\n\n/// addCase - Add an entry to the switch instruction...\n///\nvoid SwitchInst::addCase(ConstantInt *OnVal, BasicBlock *Dest) {\n  unsigned NewCaseIdx = getNumCases();\n  unsigned OpNo = getNumOperands();\n  if (OpNo+2 > ReservedSpace)\n    growOperands();  // Get more space!\n  // Initialize some new operands.\n  assert(OpNo+1 < ReservedSpace && \"Growing didn't work!\");\n  setNumHungOffUseOperands(OpNo+2);\n  CaseHandle Case(this, NewCaseIdx);\n  Case.setValue(OnVal);\n  Case.setSuccessor(Dest);\n}\n\n/// removeCase - This method removes the specified case and its successor\n/// from the switch instruction.\nSwitchInst::CaseIt SwitchInst::removeCase(CaseIt I) {\n  unsigned idx = I->getCaseIndex();\n\n  assert(2 + idx*2 < getNumOperands() && \"Case index out of range!!!\");\n\n  unsigned NumOps = getNumOperands();\n  Use *OL = getOperandList();\n\n  // Overwrite this case with the end of the list.\n  if (2 + (idx + 1) * 2 != NumOps) {\n    OL[2 + idx * 2] = OL[NumOps - 2];\n    OL[2 + idx * 2 + 1] = OL[NumOps - 1];\n  }\n\n  // Nuke the last value.\n  OL[NumOps-2].set(nullptr);\n  OL[NumOps-2+1].set(nullptr);\n  setNumHungOffUseOperands(NumOps-2);\n\n  return CaseIt(this, idx);\n}\n\n/// growOperands - grow operands - This grows the operand list in response\n/// to a push_back style of operation.  This grows the number of ops by 3 times.\n///\nvoid SwitchInst::growOperands() {\n  unsigned e = getNumOperands();\n  unsigned NumOps = e*3;\n\n  ReservedSpace = NumOps;\n  growHungoffUses(ReservedSpace);\n}\n\nMDNode *\nSwitchInstProfUpdateWrapper::getProfBranchWeightsMD(const SwitchInst &SI) {\n  if (MDNode *ProfileData = SI.getMetadata(LLVMContext::MD_prof))\n    if (auto *MDName = dyn_cast<MDString>(ProfileData->getOperand(0)))\n      if (MDName->getString() == \"branch_weights\")\n        return ProfileData;\n  return nullptr;\n}\n\nMDNode *SwitchInstProfUpdateWrapper::buildProfBranchWeightsMD() {\n  assert(Changed && \"called only if metadata has changed\");\n\n  if (!Weights)\n    return nullptr;\n\n  assert(SI.getNumSuccessors() == Weights->size() &&\n         \"num of prof branch_weights must accord with num of successors\");\n\n  bool AllZeroes =\n      all_of(Weights.getValue(), [](uint32_t W) { return W == 0; });\n\n  if (AllZeroes || Weights.getValue().size() < 2)\n    return nullptr;\n\n  return MDBuilder(SI.getParent()->getContext()).createBranchWeights(*Weights);\n}\n\nvoid SwitchInstProfUpdateWrapper::init() {\n  MDNode *ProfileData = getProfBranchWeightsMD(SI);\n  if (!ProfileData)\n    return;\n\n  if (ProfileData->getNumOperands() != SI.getNumSuccessors() + 1) {\n    llvm_unreachable(\"number of prof branch_weights metadata operands does \"\n                     \"not correspond to number of succesors\");\n  }\n\n  SmallVector<uint32_t, 8> Weights;\n  for (unsigned CI = 1, CE = SI.getNumSuccessors(); CI <= CE; ++CI) {\n    ConstantInt *C = mdconst::extract<ConstantInt>(ProfileData->getOperand(CI));\n    uint32_t CW = C->getValue().getZExtValue();\n    Weights.push_back(CW);\n  }\n  this->Weights = std::move(Weights);\n}\n\nSwitchInst::CaseIt\nSwitchInstProfUpdateWrapper::removeCase(SwitchInst::CaseIt I) {\n  if (Weights) {\n    assert(SI.getNumSuccessors() == Weights->size() &&\n           \"num of prof branch_weights must accord with num of successors\");\n    Changed = true;\n    // Copy the last case to the place of the removed one and shrink.\n    // This is tightly coupled with the way SwitchInst::removeCase() removes\n    // the cases in SwitchInst::removeCase(CaseIt).\n    Weights.getValue()[I->getCaseIndex() + 1] = Weights.getValue().back();\n    Weights.getValue().pop_back();\n  }\n  return SI.removeCase(I);\n}\n\nvoid SwitchInstProfUpdateWrapper::addCase(\n    ConstantInt *OnVal, BasicBlock *Dest,\n    SwitchInstProfUpdateWrapper::CaseWeightOpt W) {\n  SI.addCase(OnVal, Dest);\n\n  if (!Weights && W && *W) {\n    Changed = true;\n    Weights = SmallVector<uint32_t, 8>(SI.getNumSuccessors(), 0);\n    Weights.getValue()[SI.getNumSuccessors() - 1] = *W;\n  } else if (Weights) {\n    Changed = true;\n    Weights.getValue().push_back(W ? *W : 0);\n  }\n  if (Weights)\n    assert(SI.getNumSuccessors() == Weights->size() &&\n           \"num of prof branch_weights must accord with num of successors\");\n}\n\nSymbolTableList<Instruction>::iterator\nSwitchInstProfUpdateWrapper::eraseFromParent() {\n  // Instruction is erased. Mark as unchanged to not touch it in the destructor.\n  Changed = false;\n  if (Weights)\n    Weights->resize(0);\n  return SI.eraseFromParent();\n}\n\nSwitchInstProfUpdateWrapper::CaseWeightOpt\nSwitchInstProfUpdateWrapper::getSuccessorWeight(unsigned idx) {\n  if (!Weights)\n    return None;\n  return Weights.getValue()[idx];\n}\n\nvoid SwitchInstProfUpdateWrapper::setSuccessorWeight(\n    unsigned idx, SwitchInstProfUpdateWrapper::CaseWeightOpt W) {\n  if (!W)\n    return;\n\n  if (!Weights && *W)\n    Weights = SmallVector<uint32_t, 8>(SI.getNumSuccessors(), 0);\n\n  if (Weights) {\n    auto &OldW = Weights.getValue()[idx];\n    if (*W != OldW) {\n      Changed = true;\n      OldW = *W;\n    }\n  }\n}\n\nSwitchInstProfUpdateWrapper::CaseWeightOpt\nSwitchInstProfUpdateWrapper::getSuccessorWeight(const SwitchInst &SI,\n                                                unsigned idx) {\n  if (MDNode *ProfileData = getProfBranchWeightsMD(SI))\n    if (ProfileData->getNumOperands() == SI.getNumSuccessors() + 1)\n      return mdconst::extract<ConstantInt>(ProfileData->getOperand(idx + 1))\n          ->getValue()\n          .getZExtValue();\n\n  return None;\n}\n\n//===----------------------------------------------------------------------===//\n//                        IndirectBrInst Implementation\n//===----------------------------------------------------------------------===//\n\nvoid IndirectBrInst::init(Value *Address, unsigned NumDests) {\n  assert(Address && Address->getType()->isPointerTy() &&\n         \"Address of indirectbr must be a pointer\");\n  ReservedSpace = 1+NumDests;\n  setNumHungOffUseOperands(1);\n  allocHungoffUses(ReservedSpace);\n\n  Op<0>() = Address;\n}\n\n\n/// growOperands - grow operands - This grows the operand list in response\n/// to a push_back style of operation.  This grows the number of ops by 2 times.\n///\nvoid IndirectBrInst::growOperands() {\n  unsigned e = getNumOperands();\n  unsigned NumOps = e*2;\n\n  ReservedSpace = NumOps;\n  growHungoffUses(ReservedSpace);\n}\n\nIndirectBrInst::IndirectBrInst(Value *Address, unsigned NumCases,\n                               Instruction *InsertBefore)\n    : Instruction(Type::getVoidTy(Address->getContext()),\n                  Instruction::IndirectBr, nullptr, 0, InsertBefore) {\n  init(Address, NumCases);\n}\n\nIndirectBrInst::IndirectBrInst(Value *Address, unsigned NumCases,\n                               BasicBlock *InsertAtEnd)\n    : Instruction(Type::getVoidTy(Address->getContext()),\n                  Instruction::IndirectBr, nullptr, 0, InsertAtEnd) {\n  init(Address, NumCases);\n}\n\nIndirectBrInst::IndirectBrInst(const IndirectBrInst &IBI)\n    : Instruction(Type::getVoidTy(IBI.getContext()), Instruction::IndirectBr,\n                  nullptr, IBI.getNumOperands()) {\n  allocHungoffUses(IBI.getNumOperands());\n  Use *OL = getOperandList();\n  const Use *InOL = IBI.getOperandList();\n  for (unsigned i = 0, E = IBI.getNumOperands(); i != E; ++i)\n    OL[i] = InOL[i];\n  SubclassOptionalData = IBI.SubclassOptionalData;\n}\n\n/// addDestination - Add a destination.\n///\nvoid IndirectBrInst::addDestination(BasicBlock *DestBB) {\n  unsigned OpNo = getNumOperands();\n  if (OpNo+1 > ReservedSpace)\n    growOperands();  // Get more space!\n  // Initialize some new operands.\n  assert(OpNo < ReservedSpace && \"Growing didn't work!\");\n  setNumHungOffUseOperands(OpNo+1);\n  getOperandList()[OpNo] = DestBB;\n}\n\n/// removeDestination - This method removes the specified successor from the\n/// indirectbr instruction.\nvoid IndirectBrInst::removeDestination(unsigned idx) {\n  assert(idx < getNumOperands()-1 && \"Successor index out of range!\");\n\n  unsigned NumOps = getNumOperands();\n  Use *OL = getOperandList();\n\n  // Replace this value with the last one.\n  OL[idx+1] = OL[NumOps-1];\n\n  // Nuke the last value.\n  OL[NumOps-1].set(nullptr);\n  setNumHungOffUseOperands(NumOps-1);\n}\n\n//===----------------------------------------------------------------------===//\n//                            FreezeInst Implementation\n//===----------------------------------------------------------------------===//\n\nFreezeInst::FreezeInst(Value *S,\n                       const Twine &Name, Instruction *InsertBefore)\n    : UnaryInstruction(S->getType(), Freeze, S, InsertBefore) {\n  setName(Name);\n}\n\nFreezeInst::FreezeInst(Value *S,\n                       const Twine &Name, BasicBlock *InsertAtEnd)\n    : UnaryInstruction(S->getType(), Freeze, S, InsertAtEnd) {\n  setName(Name);\n}\n\n//===----------------------------------------------------------------------===//\n//                           cloneImpl() implementations\n//===----------------------------------------------------------------------===//\n\n// Define these methods here so vtables don't get emitted into every translation\n// unit that uses these classes.\n\nGetElementPtrInst *GetElementPtrInst::cloneImpl() const {\n  return new (getNumOperands()) GetElementPtrInst(*this);\n}\n\nUnaryOperator *UnaryOperator::cloneImpl() const {\n  return Create(getOpcode(), Op<0>());\n}\n\nBinaryOperator *BinaryOperator::cloneImpl() const {\n  return Create(getOpcode(), Op<0>(), Op<1>());\n}\n\nFCmpInst *FCmpInst::cloneImpl() const {\n  return new FCmpInst(getPredicate(), Op<0>(), Op<1>());\n}\n\nICmpInst *ICmpInst::cloneImpl() const {\n  return new ICmpInst(getPredicate(), Op<0>(), Op<1>());\n}\n\nExtractValueInst *ExtractValueInst::cloneImpl() const {\n  return new ExtractValueInst(*this);\n}\n\nInsertValueInst *InsertValueInst::cloneImpl() const {\n  return new InsertValueInst(*this);\n}\n\nAllocaInst *AllocaInst::cloneImpl() const {\n  AllocaInst *Result =\n      new AllocaInst(getAllocatedType(), getType()->getAddressSpace(),\n                     getOperand(0), getAlign());\n  Result->setUsedWithInAlloca(isUsedWithInAlloca());\n  Result->setSwiftError(isSwiftError());\n  return Result;\n}\n\nLoadInst *LoadInst::cloneImpl() const {\n  return new LoadInst(getType(), getOperand(0), Twine(), isVolatile(),\n                      getAlign(), getOrdering(), getSyncScopeID());\n}\n\nStoreInst *StoreInst::cloneImpl() const {\n  return new StoreInst(getOperand(0), getOperand(1), isVolatile(), getAlign(),\n                       getOrdering(), getSyncScopeID());\n}\n\nAtomicCmpXchgInst *AtomicCmpXchgInst::cloneImpl() const {\n  AtomicCmpXchgInst *Result = new AtomicCmpXchgInst(\n      getOperand(0), getOperand(1), getOperand(2), getAlign(),\n      getSuccessOrdering(), getFailureOrdering(), getSyncScopeID());\n  Result->setVolatile(isVolatile());\n  Result->setWeak(isWeak());\n  return Result;\n}\n\nAtomicRMWInst *AtomicRMWInst::cloneImpl() const {\n  AtomicRMWInst *Result =\n      new AtomicRMWInst(getOperation(), getOperand(0), getOperand(1),\n                        getAlign(), getOrdering(), getSyncScopeID());\n  Result->setVolatile(isVolatile());\n  return Result;\n}\n\nFenceInst *FenceInst::cloneImpl() const {\n  return new FenceInst(getContext(), getOrdering(), getSyncScopeID());\n}\n\nTruncInst *TruncInst::cloneImpl() const {\n  return new TruncInst(getOperand(0), getType());\n}\n\nZExtInst *ZExtInst::cloneImpl() const {\n  return new ZExtInst(getOperand(0), getType());\n}\n\nSExtInst *SExtInst::cloneImpl() const {\n  return new SExtInst(getOperand(0), getType());\n}\n\nFPTruncInst *FPTruncInst::cloneImpl() const {\n  return new FPTruncInst(getOperand(0), getType());\n}\n\nFPExtInst *FPExtInst::cloneImpl() const {\n  return new FPExtInst(getOperand(0), getType());\n}\n\nUIToFPInst *UIToFPInst::cloneImpl() const {\n  return new UIToFPInst(getOperand(0), getType());\n}\n\nSIToFPInst *SIToFPInst::cloneImpl() const {\n  return new SIToFPInst(getOperand(0), getType());\n}\n\nFPToUIInst *FPToUIInst::cloneImpl() const {\n  return new FPToUIInst(getOperand(0), getType());\n}\n\nFPToSIInst *FPToSIInst::cloneImpl() const {\n  return new FPToSIInst(getOperand(0), getType());\n}\n\nPtrToIntInst *PtrToIntInst::cloneImpl() const {\n  return new PtrToIntInst(getOperand(0), getType());\n}\n\nIntToPtrInst *IntToPtrInst::cloneImpl() const {\n  return new IntToPtrInst(getOperand(0), getType());\n}\n\nBitCastInst *BitCastInst::cloneImpl() const {\n  return new BitCastInst(getOperand(0), getType());\n}\n\nAddrSpaceCastInst *AddrSpaceCastInst::cloneImpl() const {\n  return new AddrSpaceCastInst(getOperand(0), getType());\n}\n\nCallInst *CallInst::cloneImpl() const {\n  if (hasOperandBundles()) {\n    unsigned DescriptorBytes = getNumOperandBundles() * sizeof(BundleOpInfo);\n    return new(getNumOperands(), DescriptorBytes) CallInst(*this);\n  }\n  return  new(getNumOperands()) CallInst(*this);\n}\n\nSelectInst *SelectInst::cloneImpl() const {\n  return SelectInst::Create(getOperand(0), getOperand(1), getOperand(2));\n}\n\nVAArgInst *VAArgInst::cloneImpl() const {\n  return new VAArgInst(getOperand(0), getType());\n}\n\nExtractElementInst *ExtractElementInst::cloneImpl() const {\n  return ExtractElementInst::Create(getOperand(0), getOperand(1));\n}\n\nInsertElementInst *InsertElementInst::cloneImpl() const {\n  return InsertElementInst::Create(getOperand(0), getOperand(1), getOperand(2));\n}\n\nShuffleVectorInst *ShuffleVectorInst::cloneImpl() const {\n  return new ShuffleVectorInst(getOperand(0), getOperand(1), getShuffleMask());\n}\n\nPHINode *PHINode::cloneImpl() const { return new PHINode(*this); }\n\nLandingPadInst *LandingPadInst::cloneImpl() const {\n  return new LandingPadInst(*this);\n}\n\nReturnInst *ReturnInst::cloneImpl() const {\n  return new(getNumOperands()) ReturnInst(*this);\n}\n\nBranchInst *BranchInst::cloneImpl() const {\n  return new(getNumOperands()) BranchInst(*this);\n}\n\nSwitchInst *SwitchInst::cloneImpl() const { return new SwitchInst(*this); }\n\nIndirectBrInst *IndirectBrInst::cloneImpl() const {\n  return new IndirectBrInst(*this);\n}\n\nInvokeInst *InvokeInst::cloneImpl() const {\n  if (hasOperandBundles()) {\n    unsigned DescriptorBytes = getNumOperandBundles() * sizeof(BundleOpInfo);\n    return new(getNumOperands(), DescriptorBytes) InvokeInst(*this);\n  }\n  return new(getNumOperands()) InvokeInst(*this);\n}\n\nCallBrInst *CallBrInst::cloneImpl() const {\n  if (hasOperandBundles()) {\n    unsigned DescriptorBytes = getNumOperandBundles() * sizeof(BundleOpInfo);\n    return new (getNumOperands(), DescriptorBytes) CallBrInst(*this);\n  }\n  return new (getNumOperands()) CallBrInst(*this);\n}\n\nResumeInst *ResumeInst::cloneImpl() const { return new (1) ResumeInst(*this); }\n\nCleanupReturnInst *CleanupReturnInst::cloneImpl() const {\n  return new (getNumOperands()) CleanupReturnInst(*this);\n}\n\nCatchReturnInst *CatchReturnInst::cloneImpl() const {\n  return new (getNumOperands()) CatchReturnInst(*this);\n}\n\nCatchSwitchInst *CatchSwitchInst::cloneImpl() const {\n  return new CatchSwitchInst(*this);\n}\n\nFuncletPadInst *FuncletPadInst::cloneImpl() const {\n  return new (getNumOperands()) FuncletPadInst(*this);\n}\n\nUnreachableInst *UnreachableInst::cloneImpl() const {\n  LLVMContext &Context = getContext();\n  return new UnreachableInst(Context);\n}\n\nFreezeInst *FreezeInst::cloneImpl() const {\n  return new FreezeInst(getOperand(0));\n}\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "content": "//===- llvm/InstrTypes.h - Important Instruction subclasses -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines various meta classes of instructions that exist in the VM\n// representation.  Specific concrete subclasses of these may be found in the\n// i*.h files...\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INSTRTYPES_H\n#define LLVM_IR_INSTRTYPES_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nnamespace Intrinsic {\ntypedef unsigned ID;\n}\n\n//===----------------------------------------------------------------------===//\n//                          UnaryInstruction Class\n//===----------------------------------------------------------------------===//\n\nclass UnaryInstruction : public Instruction {\nprotected:\n  UnaryInstruction(Type *Ty, unsigned iType, Value *V,\n                   Instruction *IB = nullptr)\n    : Instruction(Ty, iType, &Op<0>(), 1, IB) {\n    Op<0>() = V;\n  }\n  UnaryInstruction(Type *Ty, unsigned iType, Value *V, BasicBlock *IAE)\n    : Instruction(Ty, iType, &Op<0>(), 1, IAE) {\n    Op<0>() = V;\n  }\n\npublic:\n  // allocate space for exactly one operand\n  void *operator new(size_t s) {\n    return User::operator new(s, 1);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isUnaryOp() ||\n           I->getOpcode() == Instruction::Alloca ||\n           I->getOpcode() == Instruction::Load ||\n           I->getOpcode() == Instruction::VAArg ||\n           I->getOpcode() == Instruction::ExtractValue ||\n           (I->getOpcode() >= CastOpsBegin && I->getOpcode() < CastOpsEnd);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<UnaryInstruction> :\n  public FixedNumOperandTraits<UnaryInstruction, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(UnaryInstruction, Value)\n\n//===----------------------------------------------------------------------===//\n//                                UnaryOperator Class\n//===----------------------------------------------------------------------===//\n\nclass UnaryOperator : public UnaryInstruction {\n  void AssertOK();\n\nprotected:\n  UnaryOperator(UnaryOps iType, Value *S, Type *Ty,\n                const Twine &Name, Instruction *InsertBefore);\n  UnaryOperator(UnaryOps iType, Value *S, Type *Ty,\n                const Twine &Name, BasicBlock *InsertAtEnd);\n\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  UnaryOperator *cloneImpl() const;\n\npublic:\n\n  /// Construct a unary instruction, given the opcode and an operand.\n  /// Optionally (if InstBefore is specified) insert the instruction\n  /// into a BasicBlock right before the specified instruction.  The specified\n  /// Instruction is allowed to be a dereferenced end iterator.\n  ///\n  static UnaryOperator *Create(UnaryOps Op, Value *S,\n                               const Twine &Name = Twine(),\n                               Instruction *InsertBefore = nullptr);\n\n  /// Construct a unary instruction, given the opcode and an operand.\n  /// Also automatically insert this instruction to the end of the\n  /// BasicBlock specified.\n  ///\n  static UnaryOperator *Create(UnaryOps Op, Value *S,\n                               const Twine &Name,\n                               BasicBlock *InsertAtEnd);\n\n  /// These methods just forward to Create, and are useful when you\n  /// statically know what type of instruction you're going to create.  These\n  /// helpers just save some typing.\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name = \"\") {\\\n    return Create(Instruction::OPC, V, Name);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name, \\\n                                    BasicBlock *BB) {\\\n    return Create(Instruction::OPC, V, Name, BB);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name, \\\n                                    Instruction *I) {\\\n    return Create(Instruction::OPC, V, Name, I);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n\n  static UnaryOperator *\n  CreateWithCopiedFlags(UnaryOps Opc, Value *V, Instruction *CopyO,\n                        const Twine &Name = \"\",\n                        Instruction *InsertBefore = nullptr) {\n    UnaryOperator *UO = Create(Opc, V, Name, InsertBefore);\n    UO->copyIRFlags(CopyO);\n    return UO;\n  }\n\n  static UnaryOperator *CreateFNegFMF(Value *Op, Instruction *FMFSource,\n                                      const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr) {\n    return CreateWithCopiedFlags(Instruction::FNeg, Op, FMFSource, Name,\n                                 InsertBefore);\n  }\n\n  UnaryOps getOpcode() const {\n    return static_cast<UnaryOps>(Instruction::getOpcode());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isUnaryOp();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                           BinaryOperator Class\n//===----------------------------------------------------------------------===//\n\nclass BinaryOperator : public Instruction {\n  void AssertOK();\n\nprotected:\n  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,\n                 const Twine &Name, Instruction *InsertBefore);\n  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,\n                 const Twine &Name, BasicBlock *InsertAtEnd);\n\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  BinaryOperator *cloneImpl() const;\n\npublic:\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Construct a binary instruction, given the opcode and the two\n  /// operands.  Optionally (if InstBefore is specified) insert the instruction\n  /// into a BasicBlock right before the specified instruction.  The specified\n  /// Instruction is allowed to be a dereferenced end iterator.\n  ///\n  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,\n                                const Twine &Name = Twine(),\n                                Instruction *InsertBefore = nullptr);\n\n  /// Construct a binary instruction, given the opcode and the two\n  /// operands.  Also automatically insert this instruction to the end of the\n  /// BasicBlock specified.\n  ///\n  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,\n                                const Twine &Name, BasicBlock *InsertAtEnd);\n\n  /// These methods just forward to Create, and are useful when you\n  /// statically know what type of instruction you're going to create.  These\n  /// helpers just save some typing.\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name = \"\") {\\\n    return Create(Instruction::OPC, V1, V2, Name);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name, BasicBlock *BB) {\\\n    return Create(Instruction::OPC, V1, V2, Name, BB);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name, Instruction *I) {\\\n    return Create(Instruction::OPC, V1, V2, Name, I);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n\n  static BinaryOperator *CreateWithCopiedFlags(BinaryOps Opc,\n                                               Value *V1, Value *V2,\n                                               Instruction *CopyO,\n                                               const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->copyIRFlags(CopyO);\n    return BO;\n  }\n\n  static BinaryOperator *CreateFAddFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FAdd, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFSubFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FSub, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFMulFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FMul, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFDivFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FDiv, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFRemFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FRem, V1, V2, FMFSource, Name);\n  }\n\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setIsExact(true);\n    return BO;\n  }\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setIsExact(true);\n    return BO;\n  }\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setIsExact(true);\n    return BO;\n  }\n\n#define DEFINE_HELPERS(OPC, NUWNSWEXACT)                                       \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(Value *V1, Value *V2,        \\\n                                                  const Twine &Name = \"\") {    \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name);                \\\n  }                                                                            \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(                             \\\n      Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) {               \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name, BB);            \\\n  }                                                                            \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(                             \\\n      Value *V1, Value *V2, const Twine &Name, Instruction *I) {               \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name, I);             \\\n  }\n\n  DEFINE_HELPERS(Add, NSW) // CreateNSWAdd\n  DEFINE_HELPERS(Add, NUW) // CreateNUWAdd\n  DEFINE_HELPERS(Sub, NSW) // CreateNSWSub\n  DEFINE_HELPERS(Sub, NUW) // CreateNUWSub\n  DEFINE_HELPERS(Mul, NSW) // CreateNSWMul\n  DEFINE_HELPERS(Mul, NUW) // CreateNUWMul\n  DEFINE_HELPERS(Shl, NSW) // CreateNSWShl\n  DEFINE_HELPERS(Shl, NUW) // CreateNUWShl\n\n  DEFINE_HELPERS(SDiv, Exact)  // CreateExactSDiv\n  DEFINE_HELPERS(UDiv, Exact)  // CreateExactUDiv\n  DEFINE_HELPERS(AShr, Exact)  // CreateExactAShr\n  DEFINE_HELPERS(LShr, Exact)  // CreateExactLShr\n\n#undef DEFINE_HELPERS\n\n  /// Helper functions to construct and inspect unary operations (NEG and NOT)\n  /// via binary operators SUB and XOR:\n  ///\n  /// Create the NEG and NOT instructions out of SUB and XOR instructions.\n  ///\n  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name = \"\",\n                                   Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name,\n                                   BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name,\n                                      BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name,\n                                      BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNot(Value *Op, const Twine &Name = \"\",\n                                   Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNot(Value *Op, const Twine &Name,\n                                   BasicBlock *InsertAtEnd);\n\n  BinaryOps getOpcode() const {\n    return static_cast<BinaryOps>(Instruction::getOpcode());\n  }\n\n  /// Exchange the two operands to this instruction.\n  /// This instruction is safe to use on any binary instruction and\n  /// does not modify the semantics of the instruction.  If the instruction\n  /// cannot be reversed (ie, it's a Div), then return true.\n  ///\n  bool swapOperands();\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isBinaryOp();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<BinaryOperator> :\n  public FixedNumOperandTraits<BinaryOperator, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(BinaryOperator, Value)\n\n//===----------------------------------------------------------------------===//\n//                               CastInst Class\n//===----------------------------------------------------------------------===//\n\n/// This is the base class for all instructions that perform data\n/// casts. It is simply provided so that instruction category testing\n/// can be performed with code like:\n///\n/// if (isa<CastInst>(Instr)) { ... }\n/// Base class of casting instructions.\nclass CastInst : public UnaryInstruction {\nprotected:\n  /// Constructor with insert-before-instruction semantics for subclasses\n  CastInst(Type *Ty, unsigned iType, Value *S,\n           const Twine &NameStr = \"\", Instruction *InsertBefore = nullptr)\n    : UnaryInstruction(Ty, iType, S, InsertBefore) {\n    setName(NameStr);\n  }\n  /// Constructor with insert-at-end-of-block semantics for subclasses\n  CastInst(Type *Ty, unsigned iType, Value *S,\n           const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : UnaryInstruction(Ty, iType, S, InsertAtEnd) {\n    setName(NameStr);\n  }\n\npublic:\n  /// Provides a way to construct any of the CastInst subclasses using an\n  /// opcode instead of the subclass's constructor. The opcode must be in the\n  /// CastOps category (Instruction::isCast(opcode) returns true). This\n  /// constructor has insert-before-instruction semantics to automatically\n  /// insert the new CastInst before InsertBefore (if it is non-null).\n  /// Construct any of the CastInst subclasses\n  static CastInst *Create(\n    Instruction::CastOps,    ///< The opcode of the cast instruction\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n  /// Provides a way to construct any of the CastInst subclasses using an\n  /// opcode instead of the subclass's constructor. The opcode must be in the\n  /// CastOps category. This constructor has insert-at-end-of-block semantics\n  /// to automatically insert the new CastInst at the end of InsertAtEnd (if\n  /// its non-null).\n  /// Construct any of the CastInst subclasses\n  static CastInst *Create(\n    Instruction::CastOps,    ///< The opcode for the cast instruction\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a ZExt or BitCast cast instruction\n  static CastInst *CreateZExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt or BitCast cast instruction\n  static CastInst *CreateZExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a SExt or BitCast cast instruction\n  static CastInst *CreateSExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a SExt or BitCast cast instruction\n  static CastInst *CreateSExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast AddrSpaceCast, or a PtrToInt cast instruction.\n  static CastInst *CreatePointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast, AddrSpaceCast or a PtrToInt cast instruction.\n  static CastInst *CreatePointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a BitCast or an AddrSpaceCast cast instruction.\n  static CastInst *CreatePointerBitCastOrAddrSpaceCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast or an AddrSpaceCast cast instruction.\n  static CastInst *CreatePointerBitCastOrAddrSpaceCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a BitCast, a PtrToInt, or an IntToPTr cast instruction.\n  ///\n  /// If the value is a pointer type and the destination an integer type,\n  /// creates a PtrToInt cast. If the value is an integer type and the\n  /// destination a pointer type, creates an IntToPtr cast. Otherwise, creates\n  /// a bitcast.\n  static CastInst *CreateBitOrPointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt, BitCast, or Trunc for int -> int casts.\n  static CastInst *CreateIntegerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    bool isSigned,           ///< Whether to regard S as signed or not\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt, BitCast, or Trunc for int -> int casts.\n  static CastInst *CreateIntegerCast(\n    Value *S,                ///< The integer value to be casted (operand 0)\n    Type *Ty,          ///< The integer type to which operand is casted\n    bool isSigned,           ///< Whether to regard S as signed or not\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create an FPExt, BitCast, or FPTrunc for fp -> fp casts\n  static CastInst *CreateFPCast(\n    Value *S,                ///< The floating point value to be casted\n    Type *Ty,          ///< The floating point type to cast to\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create an FPExt, BitCast, or FPTrunc for fp -> fp casts\n  static CastInst *CreateFPCast(\n    Value *S,                ///< The floating point value to be casted\n    Type *Ty,          ///< The floating point type to cast to\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a Trunc or BitCast cast instruction\n  static CastInst *CreateTruncOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a Trunc or BitCast cast instruction\n  static CastInst *CreateTruncOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Check whether a bitcast between these types is valid\n  static bool isBitCastable(\n    Type *SrcTy, ///< The Type from which the value should be cast.\n    Type *DestTy ///< The Type to which the value should be cast.\n  );\n\n  /// Check whether a bitcast, inttoptr, or ptrtoint cast between these\n  /// types is valid and a no-op.\n  ///\n  /// This ensures that any pointer<->integer cast has enough bits in the\n  /// integer and any other cast is a bitcast.\n  static bool isBitOrNoopPointerCastable(\n      Type *SrcTy,  ///< The Type from which the value should be cast.\n      Type *DestTy, ///< The Type to which the value should be cast.\n      const DataLayout &DL);\n\n  /// Returns the opcode necessary to cast Val into Ty using usual casting\n  /// rules.\n  /// Infer the opcode for cast operand and type\n  static Instruction::CastOps getCastOpcode(\n    const Value *Val, ///< The value to cast\n    bool SrcIsSigned, ///< Whether to treat the source as signed\n    Type *Ty,   ///< The Type to which the value should be casted\n    bool DstIsSigned  ///< Whether to treate the dest. as signed\n  );\n\n  /// There are several places where we need to know if a cast instruction\n  /// only deals with integer source and destination types. To simplify that\n  /// logic, this method is provided.\n  /// @returns true iff the cast has only integral typed operand and dest type.\n  /// Determine if this is an integer-only cast.\n  bool isIntegerCast() const;\n\n  /// A lossless cast is one that does not alter the basic value. It implies\n  /// a no-op cast but is more stringent, preventing things like int->float,\n  /// long->double, or int->ptr.\n  /// @returns true iff the cast is lossless.\n  /// Determine if this is a lossless cast.\n  bool isLosslessCast() const;\n\n  /// A no-op cast is one that can be effected without changing any bits.\n  /// It implies that the source and destination types are the same size. The\n  /// DataLayout argument is to determine the pointer size when examining casts\n  /// involving Integer and Pointer types. They are no-op casts if the integer\n  /// is the same size as the pointer. However, pointer size varies with\n  /// platform.  Note that a precondition of this method is that the cast is\n  /// legal - i.e. the instruction formed with these operands would verify.\n  static bool isNoopCast(\n    Instruction::CastOps Opcode, ///< Opcode of cast\n    Type *SrcTy,         ///< SrcTy of cast\n    Type *DstTy,         ///< DstTy of cast\n    const DataLayout &DL ///< DataLayout to get the Int Ptr type from.\n  );\n\n  /// Determine if this cast is a no-op cast.\n  ///\n  /// \\param DL is the DataLayout to determine pointer size.\n  bool isNoopCast(const DataLayout &DL) const;\n\n  /// Determine how a pair of casts can be eliminated, if they can be at all.\n  /// This is a helper function for both CastInst and ConstantExpr.\n  /// @returns 0 if the CastInst pair can't be eliminated, otherwise\n  /// returns Instruction::CastOps value for a cast that can replace\n  /// the pair, casting SrcTy to DstTy.\n  /// Determine if a cast pair is eliminable\n  static unsigned isEliminableCastPair(\n    Instruction::CastOps firstOpcode,  ///< Opcode of first cast\n    Instruction::CastOps secondOpcode, ///< Opcode of second cast\n    Type *SrcTy, ///< SrcTy of 1st cast\n    Type *MidTy, ///< DstTy of 1st cast & SrcTy of 2nd cast\n    Type *DstTy, ///< DstTy of 2nd cast\n    Type *SrcIntPtrTy, ///< Integer type corresponding to Ptr SrcTy, or null\n    Type *MidIntPtrTy, ///< Integer type corresponding to Ptr MidTy, or null\n    Type *DstIntPtrTy  ///< Integer type corresponding to Ptr DstTy, or null\n  );\n\n  /// Return the opcode of this CastInst\n  Instruction::CastOps getOpcode() const {\n    return Instruction::CastOps(Instruction::getOpcode());\n  }\n\n  /// Return the source type, as a convenience\n  Type* getSrcTy() const { return getOperand(0)->getType(); }\n  /// Return the destination type, as a convenience\n  Type* getDestTy() const { return getType(); }\n\n  /// This method can be used to determine if a cast from SrcTy to DstTy using\n  /// Opcode op is valid or not.\n  /// @returns true iff the proposed cast is valid.\n  /// Determine if a cast is valid without creating one.\n  static bool castIsValid(Instruction::CastOps op, Type *SrcTy, Type *DstTy);\n  static bool castIsValid(Instruction::CastOps op, Value *S, Type *DstTy) {\n    return castIsValid(op, S->getType(), DstTy);\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isCast();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               CmpInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class is the base class for the comparison instructions.\n/// Abstract base class of comparison instructions.\nclass CmpInst : public Instruction {\npublic:\n  /// This enumeration lists the possible predicates for CmpInst subclasses.\n  /// Values in the range 0-31 are reserved for FCmpInst, while values in the\n  /// range 32-64 are reserved for ICmpInst. This is necessary to ensure the\n  /// predicate values are not overlapping between the classes.\n  ///\n  /// Some passes (e.g. InstCombine) depend on the bit-wise characteristics of\n  /// FCMP_* values. Changing the bit patterns requires a potential change to\n  /// those passes.\n  enum Predicate : unsigned {\n    // Opcode            U L G E    Intuitive operation\n    FCMP_FALSE = 0, ///< 0 0 0 0    Always false (always folded)\n    FCMP_OEQ = 1,   ///< 0 0 0 1    True if ordered and equal\n    FCMP_OGT = 2,   ///< 0 0 1 0    True if ordered and greater than\n    FCMP_OGE = 3,   ///< 0 0 1 1    True if ordered and greater than or equal\n    FCMP_OLT = 4,   ///< 0 1 0 0    True if ordered and less than\n    FCMP_OLE = 5,   ///< 0 1 0 1    True if ordered and less than or equal\n    FCMP_ONE = 6,   ///< 0 1 1 0    True if ordered and operands are unequal\n    FCMP_ORD = 7,   ///< 0 1 1 1    True if ordered (no nans)\n    FCMP_UNO = 8,   ///< 1 0 0 0    True if unordered: isnan(X) | isnan(Y)\n    FCMP_UEQ = 9,   ///< 1 0 0 1    True if unordered or equal\n    FCMP_UGT = 10,  ///< 1 0 1 0    True if unordered or greater than\n    FCMP_UGE = 11,  ///< 1 0 1 1    True if unordered, greater than, or equal\n    FCMP_ULT = 12,  ///< 1 1 0 0    True if unordered or less than\n    FCMP_ULE = 13,  ///< 1 1 0 1    True if unordered, less than, or equal\n    FCMP_UNE = 14,  ///< 1 1 1 0    True if unordered or not equal\n    FCMP_TRUE = 15, ///< 1 1 1 1    Always true (always folded)\n    FIRST_FCMP_PREDICATE = FCMP_FALSE,\n    LAST_FCMP_PREDICATE = FCMP_TRUE,\n    BAD_FCMP_PREDICATE = FCMP_TRUE + 1,\n    ICMP_EQ = 32,  ///< equal\n    ICMP_NE = 33,  ///< not equal\n    ICMP_UGT = 34, ///< unsigned greater than\n    ICMP_UGE = 35, ///< unsigned greater or equal\n    ICMP_ULT = 36, ///< unsigned less than\n    ICMP_ULE = 37, ///< unsigned less or equal\n    ICMP_SGT = 38, ///< signed greater than\n    ICMP_SGE = 39, ///< signed greater or equal\n    ICMP_SLT = 40, ///< signed less than\n    ICMP_SLE = 41, ///< signed less or equal\n    FIRST_ICMP_PREDICATE = ICMP_EQ,\n    LAST_ICMP_PREDICATE = ICMP_SLE,\n    BAD_ICMP_PREDICATE = ICMP_SLE + 1\n  };\n  using PredicateField =\n      Bitfield::Element<Predicate, 0, 6, LAST_ICMP_PREDICATE>;\n\nprotected:\n  CmpInst(Type *ty, Instruction::OtherOps op, Predicate pred,\n          Value *LHS, Value *RHS, const Twine &Name = \"\",\n          Instruction *InsertBefore = nullptr,\n          Instruction *FlagsSource = nullptr);\n\n  CmpInst(Type *ty, Instruction::OtherOps op, Predicate pred,\n          Value *LHS, Value *RHS, const Twine &Name,\n          BasicBlock *InsertAtEnd);\n\npublic:\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  /// Construct a compare instruction, given the opcode, the predicate and\n  /// the two operands.  Optionally (if InstBefore is specified) insert the\n  /// instruction into a BasicBlock right before the specified instruction.\n  /// The specified Instruction is allowed to be a dereferenced end iterator.\n  /// Create a CmpInst\n  static CmpInst *Create(OtherOps Op,\n                         Predicate predicate, Value *S1,\n                         Value *S2, const Twine &Name = \"\",\n                         Instruction *InsertBefore = nullptr);\n\n  /// Construct a compare instruction, given the opcode, the predicate and the\n  /// two operands.  Also automatically insert this instruction to the end of\n  /// the BasicBlock specified.\n  /// Create a CmpInst\n  static CmpInst *Create(OtherOps Op, Predicate predicate, Value *S1,\n                         Value *S2, const Twine &Name, BasicBlock *InsertAtEnd);\n\n  /// Get the opcode casted to the right type\n  OtherOps getOpcode() const {\n    return static_cast<OtherOps>(Instruction::getOpcode());\n  }\n\n  /// Return the predicate for this instruction.\n  Predicate getPredicate() const { return getSubclassData<PredicateField>(); }\n\n  /// Set the predicate for this instruction to the specified value.\n  void setPredicate(Predicate P) { setSubclassData<PredicateField>(P); }\n\n  static bool isFPPredicate(Predicate P) {\n    static_assert(FIRST_FCMP_PREDICATE == 0,\n                  \"FIRST_FCMP_PREDICATE is required to be 0\");\n    return P <= LAST_FCMP_PREDICATE;\n  }\n\n  static bool isIntPredicate(Predicate P) {\n    return P >= FIRST_ICMP_PREDICATE && P <= LAST_ICMP_PREDICATE;\n  }\n\n  static StringRef getPredicateName(Predicate P);\n\n  bool isFPPredicate() const { return isFPPredicate(getPredicate()); }\n  bool isIntPredicate() const { return isIntPredicate(getPredicate()); }\n\n  /// For example, EQ -> NE, UGT -> ULE, SLT -> SGE,\n  ///              OEQ -> UNE, UGT -> OLE, OLT -> UGE, etc.\n  /// @returns the inverse predicate for the instruction's current predicate.\n  /// Return the inverse of the instruction's predicate.\n  Predicate getInversePredicate() const {\n    return getInversePredicate(getPredicate());\n  }\n\n  /// For example, EQ -> NE, UGT -> ULE, SLT -> SGE,\n  ///              OEQ -> UNE, UGT -> OLE, OLT -> UGE, etc.\n  /// @returns the inverse predicate for predicate provided in \\p pred.\n  /// Return the inverse of a given predicate\n  static Predicate getInversePredicate(Predicate pred);\n\n  /// For example, EQ->EQ, SLE->SGE, ULT->UGT,\n  ///              OEQ->OEQ, ULE->UGE, OLT->OGT, etc.\n  /// @returns the predicate that would be the result of exchanging the two\n  /// operands of the CmpInst instruction without changing the result\n  /// produced.\n  /// Return the predicate as if the operands were swapped\n  Predicate getSwappedPredicate() const {\n    return getSwappedPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// Return the predicate as if the operands were swapped.\n  static Predicate getSwappedPredicate(Predicate pred);\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns true if the comparison predicate is strict, false otherwise.\n  static bool isStrictPredicate(Predicate predicate);\n\n  /// @returns true if the comparison predicate is strict, false otherwise.\n  /// Determine if this instruction is using an strict comparison predicate.\n  bool isStrictPredicate() const { return isStrictPredicate(getPredicate()); }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns true if the comparison predicate is non-strict, false otherwise.\n  static bool isNonStrictPredicate(Predicate predicate);\n\n  /// @returns true if the comparison predicate is non-strict, false otherwise.\n  /// Determine if this instruction is using an non-strict comparison predicate.\n  bool isNonStrictPredicate() const {\n    return isNonStrictPredicate(getPredicate());\n  }\n\n  /// For example, SGE -> SGT, SLE -> SLT, ULE -> ULT, UGE -> UGT.\n  /// Returns the strict version of non-strict comparisons.\n  Predicate getStrictPredicate() const {\n    return getStrictPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns the strict version of comparison provided in \\p pred.\n  /// If \\p pred is not a strict comparison predicate, returns \\p pred.\n  /// Returns the strict version of non-strict comparisons.\n  static Predicate getStrictPredicate(Predicate pred);\n\n  /// For example, SGT -> SGE, SLT -> SLE, ULT -> ULE, UGT -> UGE.\n  /// Returns the non-strict version of strict comparisons.\n  Predicate getNonStrictPredicate() const {\n    return getNonStrictPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns the non-strict version of comparison provided in \\p pred.\n  /// If \\p pred is not a strict comparison predicate, returns \\p pred.\n  /// Returns the non-strict version of strict comparisons.\n  static Predicate getNonStrictPredicate(Predicate pred);\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// Return the flipped strictness of predicate\n  static Predicate getFlippedStrictnessPredicate(Predicate pred);\n\n  /// For predicate of kind \"is X or equal to 0\" returns the predicate \"is X\".\n  /// For predicate of kind \"is X\" returns the predicate \"is X or equal to 0\".\n  /// does not support other kind of predicates.\n  /// @returns the predicate that does not contains is equal to zero if\n  /// it had and vice versa.\n  /// Return the flipped strictness of predicate\n  Predicate getFlippedStrictnessPredicate() const {\n    return getFlippedStrictnessPredicate(getPredicate());\n  }\n\n  /// Provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// This is just a convenience that dispatches to the subclasses.\n  /// Swap the operands and adjust predicate accordingly to retain\n  /// the same comparison.\n  void swapOperands();\n\n  /// This is just a convenience that dispatches to the subclasses.\n  /// Determine if this CmpInst is commutative.\n  bool isCommutative() const;\n\n  /// Determine if this is an equals/not equals predicate.\n  /// This is a static version that you can use without an instruction\n  /// available.\n  static bool isEquality(Predicate pred);\n\n  /// Determine if this is an equals/not equals predicate.\n  bool isEquality() const { return isEquality(getPredicate()); }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  static bool isRelational(Predicate P) { return !isEquality(P); }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  bool isRelational() const { return !isEquality(); }\n\n  /// @returns true if the comparison is signed, false otherwise.\n  /// Determine if this instruction is using a signed comparison.\n  bool isSigned() const {\n    return isSigned(getPredicate());\n  }\n\n  /// @returns true if the comparison is unsigned, false otherwise.\n  /// Determine if this instruction is using an unsigned comparison.\n  bool isUnsigned() const {\n    return isUnsigned(getPredicate());\n  }\n\n  /// For example, ULT->SLT, ULE->SLE, UGT->SGT, UGE->SGE, SLT->Failed assert\n  /// @returns the signed version of the unsigned predicate pred.\n  /// return the signed version of a predicate\n  static Predicate getSignedPredicate(Predicate pred);\n\n  /// For example, ULT->SLT, ULE->SLE, UGT->SGT, UGE->SGE, SLT->Failed assert\n  /// @returns the signed version of the predicate for this instruction (which\n  /// has to be an unsigned predicate).\n  /// return the signed version of a predicate\n  Predicate getSignedPredicate() {\n    return getSignedPredicate(getPredicate());\n  }\n\n  /// For example, SLT->ULT, SLE->ULE, SGT->UGT, SGE->UGE, ULT->Failed assert\n  /// @returns the unsigned version of the signed predicate pred.\n  static Predicate getUnsignedPredicate(Predicate pred);\n\n  /// For example, SLT->ULT, SLE->ULE, SGT->UGT, SGE->UGE, ULT->Failed assert\n  /// @returns the unsigned version of the predicate for this instruction (which\n  /// has to be an signed predicate).\n  /// return the unsigned version of a predicate\n  Predicate getUnsignedPredicate() {\n    return getUnsignedPredicate(getPredicate());\n  }\n\n  /// For example, SLT->ULT, ULT->SLT, SLE->ULE, ULE->SLE, EQ->Failed assert\n  /// @returns the unsigned version of the signed predicate pred or\n  ///          the signed version of the signed predicate pred.\n  static Predicate getFlippedSignednessPredicate(Predicate pred);\n\n  /// For example, SLT->ULT, ULT->SLT, SLE->ULE, ULE->SLE, EQ->Failed assert\n  /// @returns the unsigned version of the signed predicate pred or\n  ///          the signed version of the signed predicate pred.\n  Predicate getFlippedSignednessPredicate() {\n    return getFlippedSignednessPredicate(getPredicate());\n  }\n\n  /// This is just a convenience.\n  /// Determine if this is true when both operands are the same.\n  bool isTrueWhenEqual() const {\n    return isTrueWhenEqual(getPredicate());\n  }\n\n  /// This is just a convenience.\n  /// Determine if this is false when both operands are the same.\n  bool isFalseWhenEqual() const {\n    return isFalseWhenEqual(getPredicate());\n  }\n\n  /// @returns true if the predicate is unsigned, false otherwise.\n  /// Determine if the predicate is an unsigned operation.\n  static bool isUnsigned(Predicate predicate);\n\n  /// @returns true if the predicate is signed, false otherwise.\n  /// Determine if the predicate is an signed operation.\n  static bool isSigned(Predicate predicate);\n\n  /// Determine if the predicate is an ordered operation.\n  static bool isOrdered(Predicate predicate);\n\n  /// Determine if the predicate is an unordered operation.\n  static bool isUnordered(Predicate predicate);\n\n  /// Determine if the predicate is true when comparing a value with itself.\n  static bool isTrueWhenEqual(Predicate predicate);\n\n  /// Determine if the predicate is false when comparing a value with itself.\n  static bool isFalseWhenEqual(Predicate predicate);\n\n  /// Determine if Pred1 implies Pred2 is true when two compares have matching\n  /// operands.\n  static bool isImpliedTrueByMatchingCmp(Predicate Pred1, Predicate Pred2);\n\n  /// Determine if Pred1 implies Pred2 is false when two compares have matching\n  /// operands.\n  static bool isImpliedFalseByMatchingCmp(Predicate Pred1, Predicate Pred2);\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ICmp ||\n           I->getOpcode() == Instruction::FCmp;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  /// Create a result type for fcmp/icmp\n  static Type* makeCmpResultType(Type* opnd_type) {\n    if (VectorType* vt = dyn_cast<VectorType>(opnd_type)) {\n      return VectorType::get(Type::getInt1Ty(opnd_type->getContext()),\n                             vt->getElementCount());\n    }\n    return Type::getInt1Ty(opnd_type->getContext());\n  }\n\nprivate:\n  // Shadow Value::setValueSubclassData with a private forwarding method so that\n  // subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n};\n\n// FIXME: these are redundant if CmpInst < BinaryOperator\ntemplate <>\nstruct OperandTraits<CmpInst> : public FixedNumOperandTraits<CmpInst, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CmpInst, Value)\n\n/// A lightweight accessor for an operand bundle meant to be passed\n/// around by value.\nstruct OperandBundleUse {\n  ArrayRef<Use> Inputs;\n\n  OperandBundleUse() = default;\n  explicit OperandBundleUse(StringMapEntry<uint32_t> *Tag, ArrayRef<Use> Inputs)\n      : Inputs(Inputs), Tag(Tag) {}\n\n  /// Return true if the operand at index \\p Idx in this operand bundle\n  /// has the attribute A.\n  bool operandHasAttr(unsigned Idx, Attribute::AttrKind A) const {\n    if (isDeoptOperandBundle())\n      if (A == Attribute::ReadOnly || A == Attribute::NoCapture)\n        return Inputs[Idx]->getType()->isPointerTy();\n\n    // Conservative answer:  no operands have any attributes.\n    return false;\n  }\n\n  /// Return the tag of this operand bundle as a string.\n  StringRef getTagName() const {\n    return Tag->getKey();\n  }\n\n  /// Return the tag of this operand bundle as an integer.\n  ///\n  /// Operand bundle tags are interned by LLVMContextImpl::getOrInsertBundleTag,\n  /// and this function returns the unique integer getOrInsertBundleTag\n  /// associated the tag of this operand bundle to.\n  uint32_t getTagID() const {\n    return Tag->getValue();\n  }\n\n  /// Return true if this is a \"deopt\" operand bundle.\n  bool isDeoptOperandBundle() const {\n    return getTagID() == LLVMContext::OB_deopt;\n  }\n\n  /// Return true if this is a \"funclet\" operand bundle.\n  bool isFuncletOperandBundle() const {\n    return getTagID() == LLVMContext::OB_funclet;\n  }\n\n  /// Return true if this is a \"cfguardtarget\" operand bundle.\n  bool isCFGuardTargetOperandBundle() const {\n    return getTagID() == LLVMContext::OB_cfguardtarget;\n  }\n\nprivate:\n  /// Pointer to an entry in LLVMContextImpl::getOrInsertBundleTag.\n  StringMapEntry<uint32_t> *Tag;\n};\n\n/// A container for an operand bundle being viewed as a set of values\n/// rather than a set of uses.\n///\n/// Unlike OperandBundleUse, OperandBundleDefT owns the memory it carries, and\n/// so it is possible to create and pass around \"self-contained\" instances of\n/// OperandBundleDef and ConstOperandBundleDef.\ntemplate <typename InputTy> class OperandBundleDefT {\n  std::string Tag;\n  std::vector<InputTy> Inputs;\n\npublic:\n  explicit OperandBundleDefT(std::string Tag, std::vector<InputTy> Inputs)\n      : Tag(std::move(Tag)), Inputs(std::move(Inputs)) {}\n  explicit OperandBundleDefT(std::string Tag, ArrayRef<InputTy> Inputs)\n      : Tag(std::move(Tag)), Inputs(Inputs) {}\n\n  explicit OperandBundleDefT(const OperandBundleUse &OBU) {\n    Tag = std::string(OBU.getTagName());\n    llvm::append_range(Inputs, OBU.Inputs);\n  }\n\n  ArrayRef<InputTy> inputs() const { return Inputs; }\n\n  using input_iterator = typename std::vector<InputTy>::const_iterator;\n\n  size_t input_size() const { return Inputs.size(); }\n  input_iterator input_begin() const { return Inputs.begin(); }\n  input_iterator input_end() const { return Inputs.end(); }\n\n  StringRef getTag() const { return Tag; }\n};\n\nusing OperandBundleDef = OperandBundleDefT<Value *>;\nusing ConstOperandBundleDef = OperandBundleDefT<const Value *>;\n\n//===----------------------------------------------------------------------===//\n//                               CallBase Class\n//===----------------------------------------------------------------------===//\n\n/// Base class for all callable instructions (InvokeInst and CallInst)\n/// Holds everything related to calling a function.\n///\n/// All call-like instructions are required to use a common operand layout:\n/// - Zero or more arguments to the call,\n/// - Zero or more operand bundles with zero or more operand inputs each\n///   bundle,\n/// - Zero or more subclass controlled operands\n/// - The called function.\n///\n/// This allows this base class to easily access the called function and the\n/// start of the arguments without knowing how many other operands a particular\n/// subclass requires. Note that accessing the end of the argument list isn't\n/// as cheap as most other operations on the base class.\nclass CallBase : public Instruction {\nprotected:\n  // The first two bits are reserved by CallInst for fast retrieval,\n  using CallInstReservedField = Bitfield::Element<unsigned, 0, 2>;\n  using CallingConvField =\n      Bitfield::Element<CallingConv::ID, CallInstReservedField::NextBit, 10,\n                        CallingConv::MaxID>;\n  static_assert(\n      Bitfield::areContiguous<CallInstReservedField, CallingConvField>(),\n      \"Bitfields must be contiguous\");\n\n  /// The last operand is the called operand.\n  static constexpr int CalledOperandOpEndIdx = -1;\n\n  AttributeList Attrs; ///< parameter attributes for callable\n  FunctionType *FTy;\n\n  template <class... ArgsTy>\n  CallBase(AttributeList const &A, FunctionType *FT, ArgsTy &&... Args)\n      : Instruction(std::forward<ArgsTy>(Args)...), Attrs(A), FTy(FT) {}\n\n  using Instruction::Instruction;\n\n  bool hasDescriptor() const { return Value::HasDescriptor; }\n\n  unsigned getNumSubclassExtraOperands() const {\n    switch (getOpcode()) {\n    case Instruction::Call:\n      return 0;\n    case Instruction::Invoke:\n      return 2;\n    case Instruction::CallBr:\n      return getNumSubclassExtraOperandsDynamic();\n    }\n    llvm_unreachable(\"Invalid opcode!\");\n  }\n\n  /// Get the number of extra operands for instructions that don't have a fixed\n  /// number of extra operands.\n  unsigned getNumSubclassExtraOperandsDynamic() const;\n\npublic:\n  using Instruction::getContext;\n\n  /// Create a clone of \\p CB with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned call instruction is identical \\p CB in every way except that\n  /// the operand bundles for the new instruction are set to the operand bundles\n  /// in \\p Bundles.\n  static CallBase *Create(CallBase *CB, ArrayRef<OperandBundleDef> Bundles,\n                          Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CB with operand bundle \\p OB added.\n  static CallBase *addOperandBundle(CallBase *CB, uint32_t ID,\n                                    OperandBundleDef OB,\n                                    Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CB with operand bundle \\p ID removed.\n  static CallBase *removeOperandBundle(CallBase *CB, uint32_t ID,\n                                       Instruction *InsertPt = nullptr);\n\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Call ||\n           I->getOpcode() == Instruction::Invoke ||\n           I->getOpcode() == Instruction::CallBr;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  FunctionType *getFunctionType() const { return FTy; }\n\n  void mutateFunctionType(FunctionType *FTy) {\n    Value::mutateType(FTy->getReturnType());\n    this->FTy = FTy;\n  }\n\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// data_operands_begin/data_operands_end - Return iterators iterating over\n  /// the call / invoke argument list and bundle operands.  For invokes, this is\n  /// the set of instruction operands except the invoke target and the two\n  /// successor blocks; and for calls this is the set of instruction operands\n  /// except the call target.\n  User::op_iterator data_operands_begin() { return op_begin(); }\n  User::const_op_iterator data_operands_begin() const {\n    return const_cast<CallBase *>(this)->data_operands_begin();\n  }\n  User::op_iterator data_operands_end() {\n    // Walk from the end of the operands over the called operand and any\n    // subclass operands.\n    return op_end() - getNumSubclassExtraOperands() - 1;\n  }\n  User::const_op_iterator data_operands_end() const {\n    return const_cast<CallBase *>(this)->data_operands_end();\n  }\n  iterator_range<User::op_iterator> data_ops() {\n    return make_range(data_operands_begin(), data_operands_end());\n  }\n  iterator_range<User::const_op_iterator> data_ops() const {\n    return make_range(data_operands_begin(), data_operands_end());\n  }\n  bool data_operands_empty() const {\n    return data_operands_end() == data_operands_begin();\n  }\n  unsigned data_operands_size() const {\n    return std::distance(data_operands_begin(), data_operands_end());\n  }\n\n  bool isDataOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return data_operands_begin() <= U && U < data_operands_end();\n  }\n  bool isDataOperand(Value::const_user_iterator UI) const {\n    return isDataOperand(&UI.getUse());\n  }\n\n  /// Given a value use iterator, return the data operand corresponding to it.\n  /// Iterator must actually correspond to a data operand.\n  unsigned getDataOperandNo(Value::const_user_iterator UI) const {\n    return getDataOperandNo(&UI.getUse());\n  }\n\n  /// Given a use for a data operand, get the data operand number that\n  /// corresponds to it.\n  unsigned getDataOperandNo(const Use *U) const {\n    assert(isDataOperand(U) && \"Data operand # out of range!\");\n    return U - data_operands_begin();\n  }\n\n  /// Return the iterator pointing to the beginning of the argument list.\n  User::op_iterator arg_begin() { return op_begin(); }\n  User::const_op_iterator arg_begin() const {\n    return const_cast<CallBase *>(this)->arg_begin();\n  }\n\n  /// Return the iterator pointing to the end of the argument list.\n  User::op_iterator arg_end() {\n    // From the end of the data operands, walk backwards past the bundle\n    // operands.\n    return data_operands_end() - getNumTotalBundleOperands();\n  }\n  User::const_op_iterator arg_end() const {\n    return const_cast<CallBase *>(this)->arg_end();\n  }\n\n  /// Iteration adapter for range-for loops.\n  iterator_range<User::op_iterator> args() {\n    return make_range(arg_begin(), arg_end());\n  }\n  iterator_range<User::const_op_iterator> args() const {\n    return make_range(arg_begin(), arg_end());\n  }\n  bool arg_empty() const { return arg_end() == arg_begin(); }\n  unsigned arg_size() const { return arg_end() - arg_begin(); }\n\n  // Legacy API names that duplicate the above and will be removed once users\n  // are migrated.\n  iterator_range<User::op_iterator> arg_operands() {\n    return make_range(arg_begin(), arg_end());\n  }\n  iterator_range<User::const_op_iterator> arg_operands() const {\n    return make_range(arg_begin(), arg_end());\n  }\n  unsigned getNumArgOperands() const { return arg_size(); }\n\n  Value *getArgOperand(unsigned i) const {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return getOperand(i);\n  }\n\n  void setArgOperand(unsigned i, Value *v) {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    setOperand(i, v);\n  }\n\n  /// Wrappers for getting the \\c Use of a call argument.\n  const Use &getArgOperandUse(unsigned i) const {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return User::getOperandUse(i);\n  }\n  Use &getArgOperandUse(unsigned i) {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return User::getOperandUse(i);\n  }\n\n  bool isArgOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return arg_begin() <= U && U < arg_end();\n  }\n  bool isArgOperand(Value::const_user_iterator UI) const {\n    return isArgOperand(&UI.getUse());\n  }\n\n  /// Given a use for a arg operand, get the arg operand number that\n  /// corresponds to it.\n  unsigned getArgOperandNo(const Use *U) const {\n    assert(isArgOperand(U) && \"Arg operand # out of range!\");\n    return U - arg_begin();\n  }\n\n  /// Given a value use iterator, return the arg operand number corresponding to\n  /// it. Iterator must actually correspond to a data operand.\n  unsigned getArgOperandNo(Value::const_user_iterator UI) const {\n    return getArgOperandNo(&UI.getUse());\n  }\n\n  /// Returns true if this CallSite passes the given Value* as an argument to\n  /// the called function.\n  bool hasArgument(const Value *V) const {\n    return llvm::is_contained(args(), V);\n  }\n\n  Value *getCalledOperand() const { return Op<CalledOperandOpEndIdx>(); }\n\n  const Use &getCalledOperandUse() const { return Op<CalledOperandOpEndIdx>(); }\n  Use &getCalledOperandUse() { return Op<CalledOperandOpEndIdx>(); }\n\n  /// Returns the function called, or null if this is an\n  /// indirect function invocation.\n  Function *getCalledFunction() const {\n    return dyn_cast_or_null<Function>(getCalledOperand());\n  }\n\n  /// Return true if the callsite is an indirect call.\n  bool isIndirectCall() const;\n\n  /// Determine whether the passed iterator points to the callee operand's Use.\n  bool isCallee(Value::const_user_iterator UI) const {\n    return isCallee(&UI.getUse());\n  }\n\n  /// Determine whether this Use is the callee operand's Use.\n  bool isCallee(const Use *U) const { return &getCalledOperandUse() == U; }\n\n  /// Helper to get the caller (the parent function).\n  Function *getCaller();\n  const Function *getCaller() const {\n    return const_cast<CallBase *>(this)->getCaller();\n  }\n\n  /// Tests if this call site must be tail call optimized. Only a CallInst can\n  /// be tail call optimized.\n  bool isMustTailCall() const;\n\n  /// Tests if this call site is marked as a tail call.\n  bool isTailCall() const;\n\n  /// Returns the intrinsic ID of the intrinsic called or\n  /// Intrinsic::not_intrinsic if the called function is not an intrinsic, or if\n  /// this is an indirect call.\n  Intrinsic::ID getIntrinsicID() const;\n\n  void setCalledOperand(Value *V) { Op<CalledOperandOpEndIdx>() = V; }\n\n  /// Sets the function called, including updating the function type.\n  void setCalledFunction(Function *Fn) {\n    setCalledFunction(Fn->getFunctionType(), Fn);\n  }\n\n  /// Sets the function called, including updating the function type.\n  void setCalledFunction(FunctionCallee Fn) {\n    setCalledFunction(Fn.getFunctionType(), Fn.getCallee());\n  }\n\n  /// Sets the function called, including updating to the specified function\n  /// type.\n  void setCalledFunction(FunctionType *FTy, Value *Fn) {\n    this->FTy = FTy;\n    assert(FTy == cast<FunctionType>(\n                      cast<PointerType>(Fn->getType())->getElementType()));\n    // This function doesn't mutate the return type, only the function\n    // type. Seems broken, but I'm just gonna stick an assert in for now.\n    assert(getType() == FTy->getReturnType());\n    setCalledOperand(Fn);\n  }\n\n  CallingConv::ID getCallingConv() const {\n    return getSubclassData<CallingConvField>();\n  }\n\n  void setCallingConv(CallingConv::ID CC) {\n    setSubclassData<CallingConvField>(CC);\n  }\n\n  /// Check if this call is an inline asm statement.\n  bool isInlineAsm() const { return isa<InlineAsm>(getCalledOperand()); }\n\n  /// \\name Attribute API\n  ///\n  /// These methods access and modify attributes on this call (including\n  /// looking through to the attributes on the called function when necessary).\n  ///@{\n\n  /// Return the parameter attributes for this call.\n  ///\n  AttributeList getAttributes() const { return Attrs; }\n\n  /// Set the parameter attributes for this call.\n  ///\n  void setAttributes(AttributeList A) { Attrs = A; }\n\n  /// Determine whether this call has the given attribute. If it does not\n  /// then determine if the called function has the attribute, but only if\n  /// the attribute is allowed for the call.\n  bool hasFnAttr(Attribute::AttrKind Kind) const {\n    assert(Kind != Attribute::NoBuiltin &&\n           \"Use CallBase::isNoBuiltin() to check for Attribute::NoBuiltin\");\n    return hasFnAttrImpl(Kind);\n  }\n\n  /// Determine whether this call has the given attribute. If it does not\n  /// then determine if the called function has the attribute, but only if\n  /// the attribute is allowed for the call.\n  bool hasFnAttr(StringRef Kind) const { return hasFnAttrImpl(Kind); }\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute::AttrKind Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute Attr) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addAttribute(getContext(), i, Attr);\n    setAttributes(PAL);\n  }\n\n  /// Adds the attribute to the indicated argument\n  void addParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// Adds the attribute to the indicated argument\n  void addParamAttr(unsigned ArgNo, Attribute Attr) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addParamAttribute(getContext(), ArgNo, Attr);\n    setAttributes(PAL);\n  }\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, Attribute::AttrKind Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, StringRef Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  void removeAttributes(unsigned i, const AttrBuilder &Attrs) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttributes(getContext(), i, Attrs);\n    setAttributes(PAL);\n  }\n\n  /// Removes the attribute from the given argument\n  void removeParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// Removes the attribute from the given argument\n  void removeParamAttr(unsigned ArgNo, StringRef Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// adds the dereferenceable attribute to the list of attributes.\n  void addDereferenceableAttr(unsigned i, uint64_t Bytes) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addDereferenceableAttr(getContext(), i, Bytes);\n    setAttributes(PAL);\n  }\n\n  /// adds the dereferenceable_or_null attribute to the list of\n  /// attributes.\n  void addDereferenceableOrNullAttr(unsigned i, uint64_t Bytes) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addDereferenceableOrNullAttr(getContext(), i, Bytes);\n    setAttributes(PAL);\n  }\n\n  /// Determine whether the return value has the given attribute.\n  bool hasRetAttr(Attribute::AttrKind Kind) const {\n    return hasRetAttrImpl(Kind);\n  }\n  /// Determine whether the return value has the given attribute.\n  bool hasRetAttr(StringRef Kind) const { return hasRetAttrImpl(Kind); }\n\n  /// Determine whether the argument or parameter has the given attribute.\n  bool paramHasAttr(unsigned ArgNo, Attribute::AttrKind Kind) const;\n\n  /// Get the attribute of a given kind at a position.\n  Attribute getAttribute(unsigned i, Attribute::AttrKind Kind) const {\n    return getAttributes().getAttribute(i, Kind);\n  }\n\n  /// Get the attribute of a given kind at a position.\n  Attribute getAttribute(unsigned i, StringRef Kind) const {\n    return getAttributes().getAttribute(i, Kind);\n  }\n\n  /// Get the attribute of a given kind from a given arg\n  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    return getAttributes().getParamAttr(ArgNo, Kind);\n  }\n\n  /// Get the attribute of a given kind from a given arg\n  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    return getAttributes().getParamAttr(ArgNo, Kind);\n  }\n\n  /// Return true if the data operand at index \\p i has the attribute \\p\n  /// A.\n  ///\n  /// Data operands include call arguments and values used in operand bundles,\n  /// but does not include the callee operand.  This routine dispatches to the\n  /// underlying AttributeList or the OperandBundleUser as appropriate.\n  ///\n  /// The index \\p i is interpreted as\n  ///\n  ///  \\p i == Attribute::ReturnIndex  -> the return value\n  ///  \\p i in [1, arg_size + 1)  -> argument number (\\p i - 1)\n  ///  \\p i in [arg_size + 1, data_operand_size + 1) -> bundle operand at index\n  ///     (\\p i - 1) in the operand list.\n  bool dataOperandHasImpliedAttr(unsigned i, Attribute::AttrKind Kind) const {\n    // Note that we have to add one because `i` isn't zero-indexed.\n    assert(i < (getNumArgOperands() + getNumTotalBundleOperands() + 1) &&\n           \"Data operand index out of bounds!\");\n\n    // The attribute A can either be directly specified, if the operand in\n    // question is a call argument; or be indirectly implied by the kind of its\n    // containing operand bundle, if the operand is a bundle operand.\n\n    if (i == AttributeList::ReturnIndex)\n      return hasRetAttr(Kind);\n\n    // FIXME: Avoid these i - 1 calculations and update the API to use\n    // zero-based indices.\n    if (i < (getNumArgOperands() + 1))\n      return paramHasAttr(i - 1, Kind);\n\n    assert(hasOperandBundles() && i >= (getBundleOperandsStartIndex() + 1) &&\n           \"Must be either a call argument or an operand bundle!\");\n    return bundleOperandHasAttr(i - 1, Kind);\n  }\n\n  /// Determine whether this data operand is not captured.\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotCapture(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::NoCapture);\n  }\n\n  /// Determine whether this argument is passed by value.\n  bool isByValArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::ByVal);\n  }\n\n  /// Determine whether this argument is passed in an alloca.\n  bool isInAllocaArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::InAlloca);\n  }\n\n  /// Determine whether this argument is passed by value, in an alloca, or is\n  /// preallocated.\n  bool isPassPointeeByValueArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::ByVal) ||\n           paramHasAttr(ArgNo, Attribute::InAlloca) ||\n           paramHasAttr(ArgNo, Attribute::Preallocated);\n  }\n\n  /// Determine if there are is an inalloca argument. Only the last argument can\n  /// have the inalloca attribute.\n  bool hasInAllocaArgument() const {\n    return !arg_empty() && paramHasAttr(arg_size() - 1, Attribute::InAlloca);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotAccessMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool onlyReadsMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadOnly) ||\n           dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotReadMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::WriteOnly) ||\n           dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getRetAlignment() const,\n                            \"Use getRetAlign() instead\") {\n    if (const auto MA = Attrs.getRetAlignment())\n      return MA->value();\n    return 0;\n  }\n\n  /// Extract the alignment of the return value.\n  MaybeAlign getRetAlign() const { return Attrs.getRetAlignment(); }\n\n  /// Extract the alignment for a call or parameter (0=unknown).\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getParamAlignment(unsigned ArgNo) const,\n                            \"Use getParamAlign() instead\") {\n    if (const auto MA = Attrs.getParamAlignment(ArgNo))\n      return MA->value();\n    return 0;\n  }\n\n  /// Extract the alignment for a call or parameter (0=unknown).\n  MaybeAlign getParamAlign(unsigned ArgNo) const {\n    return Attrs.getParamAlignment(ArgNo);\n  }\n\n  /// Extract the byval type for a call or parameter.\n  Type *getParamByValType(unsigned ArgNo) const {\n    Type *Ty = Attrs.getParamByValType(ArgNo);\n    return Ty ? Ty : getArgOperand(ArgNo)->getType()->getPointerElementType();\n  }\n\n  /// Extract the preallocated type for a call or parameter.\n  Type *getParamPreallocatedType(unsigned ArgNo) const {\n    Type *Ty = Attrs.getParamPreallocatedType(ArgNo);\n    return Ty ? Ty : getArgOperand(ArgNo)->getType()->getPointerElementType();\n  }\n\n  /// Extract the number of dereferenceable bytes for a call or\n  /// parameter (0=unknown).\n  uint64_t getDereferenceableBytes(unsigned i) const {\n    return Attrs.getDereferenceableBytes(i);\n  }\n\n  /// Extract the number of dereferenceable_or_null bytes for a call or\n  /// parameter (0=unknown).\n  uint64_t getDereferenceableOrNullBytes(unsigned i) const {\n    return Attrs.getDereferenceableOrNullBytes(i);\n  }\n\n  /// Return true if the return value is known to be not null.\n  /// This may be because it has the nonnull attribute, or because at least\n  /// one byte is dereferenceable and the pointer is in addrspace(0).\n  bool isReturnNonNull() const;\n\n  /// Determine if the return value is marked with NoAlias attribute.\n  bool returnDoesNotAlias() const {\n    return Attrs.hasAttribute(AttributeList::ReturnIndex, Attribute::NoAlias);\n  }\n\n  /// If one of the arguments has the 'returned' attribute, returns its\n  /// operand value. Otherwise, return nullptr.\n  Value *getReturnedArgOperand() const;\n\n  /// Return true if the call should not be treated as a call to a\n  /// builtin.\n  bool isNoBuiltin() const {\n    return hasFnAttrImpl(Attribute::NoBuiltin) &&\n           !hasFnAttrImpl(Attribute::Builtin);\n  }\n\n  /// Determine if the call requires strict floating point semantics.\n  bool isStrictFP() const { return hasFnAttr(Attribute::StrictFP); }\n\n  /// Return true if the call should not be inlined.\n  bool isNoInline() const { return hasFnAttr(Attribute::NoInline); }\n  void setIsNoInline() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoInline);\n  }\n  /// Determine if the call does not access memory.\n  bool doesNotAccessMemory() const { return hasFnAttr(Attribute::ReadNone); }\n  void setDoesNotAccessMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ReadNone);\n  }\n\n  /// Determine if the call does not access or only reads memory.\n  bool onlyReadsMemory() const {\n    return doesNotAccessMemory() || hasFnAttr(Attribute::ReadOnly);\n  }\n\n  /// Returns true if this function is guaranteed to return.\n  bool willReturn() const { return hasFnAttr(Attribute::WillReturn); }\n\n  void setOnlyReadsMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ReadOnly);\n  }\n\n  /// Determine if the call does not access or only writes memory.\n  bool doesNotReadMemory() const {\n    return doesNotAccessMemory() || hasFnAttr(Attribute::WriteOnly);\n  }\n  void setDoesNotReadMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::WriteOnly);\n  }\n\n  /// Determine if the call can access memmory only using pointers based\n  /// on its arguments.\n  bool onlyAccessesArgMemory() const {\n    return hasFnAttr(Attribute::ArgMemOnly);\n  }\n  void setOnlyAccessesArgMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ArgMemOnly);\n  }\n\n  /// Determine if the function may only access memory that is\n  /// inaccessible from the IR.\n  bool onlyAccessesInaccessibleMemory() const {\n    return hasFnAttr(Attribute::InaccessibleMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::InaccessibleMemOnly);\n  }\n\n  /// Determine if the function may only access memory that is\n  /// either inaccessible from the IR or pointed to by its arguments.\n  bool onlyAccessesInaccessibleMemOrArgMem() const {\n    return hasFnAttr(Attribute::InaccessibleMemOrArgMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemOrArgMem() {\n    addAttribute(AttributeList::FunctionIndex,\n                 Attribute::InaccessibleMemOrArgMemOnly);\n  }\n  /// Determine if the call cannot return.\n  bool doesNotReturn() const { return hasFnAttr(Attribute::NoReturn); }\n  void setDoesNotReturn() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoReturn);\n  }\n\n  /// Determine if the call should not perform indirect branch tracking.\n  bool doesNoCfCheck() const { return hasFnAttr(Attribute::NoCfCheck); }\n\n  /// Determine if the call cannot unwind.\n  bool doesNotThrow() const { return hasFnAttr(Attribute::NoUnwind); }\n  void setDoesNotThrow() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoUnwind);\n  }\n\n  /// Determine if the invoke cannot be duplicated.\n  bool cannotDuplicate() const { return hasFnAttr(Attribute::NoDuplicate); }\n  void setCannotDuplicate() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoDuplicate);\n  }\n\n  /// Determine if the call cannot be tail merged.\n  bool cannotMerge() const { return hasFnAttr(Attribute::NoMerge); }\n  void setCannotMerge() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoMerge);\n  }\n\n  /// Determine if the invoke is convergent\n  bool isConvergent() const { return hasFnAttr(Attribute::Convergent); }\n  void setConvergent() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::Convergent);\n  }\n  void setNotConvergent() {\n    removeAttribute(AttributeList::FunctionIndex, Attribute::Convergent);\n  }\n\n  /// Determine if the call returns a structure through first\n  /// pointer argument.\n  bool hasStructRetAttr() const {\n    if (getNumArgOperands() == 0)\n      return false;\n\n    // Be friendly and also check the callee.\n    return paramHasAttr(0, Attribute::StructRet);\n  }\n\n  /// Determine if any call argument is an aggregate passed by value.\n  bool hasByValArgument() const {\n    return Attrs.hasAttrSomewhere(Attribute::ByVal);\n  }\n\n  ///@{\n  // End of attribute API.\n\n  /// \\name Operand Bundle API\n  ///\n  /// This group of methods provides the API to access and manipulate operand\n  /// bundles on this call.\n  /// @{\n\n  /// Return the number of operand bundles associated with this User.\n  unsigned getNumOperandBundles() const {\n    return std::distance(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Return true if this User has any operand bundles.\n  bool hasOperandBundles() const { return getNumOperandBundles() != 0; }\n\n  /// Return the index of the first bundle operand in the Use array.\n  unsigned getBundleOperandsStartIndex() const {\n    assert(hasOperandBundles() && \"Don't call otherwise!\");\n    return bundle_op_info_begin()->Begin;\n  }\n\n  /// Return the index of the last bundle operand in the Use array.\n  unsigned getBundleOperandsEndIndex() const {\n    assert(hasOperandBundles() && \"Don't call otherwise!\");\n    return bundle_op_info_end()[-1].End;\n  }\n\n  /// Return true if the operand at index \\p Idx is a bundle operand.\n  bool isBundleOperand(unsigned Idx) const {\n    return hasOperandBundles() && Idx >= getBundleOperandsStartIndex() &&\n           Idx < getBundleOperandsEndIndex();\n  }\n\n  /// Returns true if the use is a bundle operand.\n  bool isBundleOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return hasOperandBundles() && isBundleOperand(U - op_begin());\n  }\n  bool isBundleOperand(Value::const_user_iterator UI) const {\n    return isBundleOperand(&UI.getUse());\n  }\n\n  /// Return the total number operands (not operand bundles) used by\n  /// every operand bundle in this OperandBundleUser.\n  unsigned getNumTotalBundleOperands() const {\n    if (!hasOperandBundles())\n      return 0;\n\n    unsigned Begin = getBundleOperandsStartIndex();\n    unsigned End = getBundleOperandsEndIndex();\n\n    assert(Begin <= End && \"Should be!\");\n    return End - Begin;\n  }\n\n  /// Return the operand bundle at a specific index.\n  OperandBundleUse getOperandBundleAt(unsigned Index) const {\n    assert(Index < getNumOperandBundles() && \"Index out of bounds!\");\n    return operandBundleFromBundleOpInfo(*(bundle_op_info_begin() + Index));\n  }\n\n  /// Return the number of operand bundles with the tag Name attached to\n  /// this instruction.\n  unsigned countOperandBundlesOfType(StringRef Name) const {\n    unsigned Count = 0;\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)\n      if (getOperandBundleAt(i).getTagName() == Name)\n        Count++;\n\n    return Count;\n  }\n\n  /// Return the number of operand bundles with the tag ID attached to\n  /// this instruction.\n  unsigned countOperandBundlesOfType(uint32_t ID) const {\n    unsigned Count = 0;\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)\n      if (getOperandBundleAt(i).getTagID() == ID)\n        Count++;\n\n    return Count;\n  }\n\n  /// Return an operand bundle by name, if present.\n  ///\n  /// It is an error to call this for operand bundle types that may have\n  /// multiple instances of them on the same instruction.\n  Optional<OperandBundleUse> getOperandBundle(StringRef Name) const {\n    assert(countOperandBundlesOfType(Name) < 2 && \"Precondition violated!\");\n\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      OperandBundleUse U = getOperandBundleAt(i);\n      if (U.getTagName() == Name)\n        return U;\n    }\n\n    return None;\n  }\n\n  /// Return an operand bundle by tag ID, if present.\n  ///\n  /// It is an error to call this for operand bundle types that may have\n  /// multiple instances of them on the same instruction.\n  Optional<OperandBundleUse> getOperandBundle(uint32_t ID) const {\n    assert(countOperandBundlesOfType(ID) < 2 && \"Precondition violated!\");\n\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      OperandBundleUse U = getOperandBundleAt(i);\n      if (U.getTagID() == ID)\n        return U;\n    }\n\n    return None;\n  }\n\n  /// Return the list of operand bundles attached to this instruction as\n  /// a vector of OperandBundleDefs.\n  ///\n  /// This function copies the OperandBundeUse instances associated with this\n  /// OperandBundleUser to a vector of OperandBundleDefs.  Note:\n  /// OperandBundeUses and OperandBundleDefs are non-trivially *different*\n  /// representations of operand bundles (see documentation above).\n  void getOperandBundlesAsDefs(SmallVectorImpl<OperandBundleDef> &Defs) const;\n\n  /// Return the operand bundle for the operand at index OpIdx.\n  ///\n  /// It is an error to call this with an OpIdx that does not correspond to an\n  /// bundle operand.\n  OperandBundleUse getOperandBundleForOperand(unsigned OpIdx) const {\n    return operandBundleFromBundleOpInfo(getBundleOpInfoForOperand(OpIdx));\n  }\n\n  /// Return true if this operand bundle user has operand bundles that\n  /// may read from the heap.\n  bool hasReadingOperandBundles() const {\n    // Implementation note: this is a conservative implementation of operand\n    // bundle semantics, where *any* operand bundle forces a callsite to be at\n    // least readonly.\n    return hasOperandBundles();\n  }\n\n  /// Return true if this operand bundle user has operand bundles that\n  /// may write to the heap.\n  bool hasClobberingOperandBundles() const {\n    for (auto &BOI : bundle_op_infos()) {\n      if (BOI.Tag->second == LLVMContext::OB_deopt ||\n          BOI.Tag->second == LLVMContext::OB_funclet)\n        continue;\n\n      // This instruction has an operand bundle that is not known to us.\n      // Assume the worst.\n      return true;\n    }\n\n    return false;\n  }\n\n  /// Return true if the bundle operand at index \\p OpIdx has the\n  /// attribute \\p A.\n  bool bundleOperandHasAttr(unsigned OpIdx,  Attribute::AttrKind A) const {\n    auto &BOI = getBundleOpInfoForOperand(OpIdx);\n    auto OBU = operandBundleFromBundleOpInfo(BOI);\n    return OBU.operandHasAttr(OpIdx - BOI.Begin, A);\n  }\n\n  /// Return true if \\p Other has the same sequence of operand bundle\n  /// tags with the same number of operands on each one of them as this\n  /// OperandBundleUser.\n  bool hasIdenticalOperandBundleSchema(const CallBase &Other) const {\n    if (getNumOperandBundles() != Other.getNumOperandBundles())\n      return false;\n\n    return std::equal(bundle_op_info_begin(), bundle_op_info_end(),\n                      Other.bundle_op_info_begin());\n  }\n\n  /// Return true if this operand bundle user contains operand bundles\n  /// with tags other than those specified in \\p IDs.\n  bool hasOperandBundlesOtherThan(ArrayRef<uint32_t> IDs) const {\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      uint32_t ID = getOperandBundleAt(i).getTagID();\n      if (!is_contained(IDs, ID))\n        return true;\n    }\n    return false;\n  }\n\n  /// Is the function attribute S disallowed by some operand bundle on\n  /// this operand bundle user?\n  bool isFnAttrDisallowedByOpBundle(StringRef S) const {\n    // Operand bundles only possibly disallow readnone, readonly and argmemonly\n    // attributes.  All String attributes are fine.\n    return false;\n  }\n\n  /// Is the function attribute A disallowed by some operand bundle on\n  /// this operand bundle user?\n  bool isFnAttrDisallowedByOpBundle(Attribute::AttrKind A) const {\n    switch (A) {\n    default:\n      return false;\n\n    case Attribute::InaccessibleMemOrArgMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::InaccessibleMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::ArgMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::ReadNone:\n      return hasReadingOperandBundles();\n\n    case Attribute::ReadOnly:\n      return hasClobberingOperandBundles();\n    }\n\n    llvm_unreachable(\"switch has a default case!\");\n  }\n\n  /// Used to keep track of an operand bundle.  See the main comment on\n  /// OperandBundleUser above.\n  struct BundleOpInfo {\n    /// The operand bundle tag, interned by\n    /// LLVMContextImpl::getOrInsertBundleTag.\n    StringMapEntry<uint32_t> *Tag;\n\n    /// The index in the Use& vector where operands for this operand\n    /// bundle starts.\n    uint32_t Begin;\n\n    /// The index in the Use& vector where operands for this operand\n    /// bundle ends.\n    uint32_t End;\n\n    bool operator==(const BundleOpInfo &Other) const {\n      return Tag == Other.Tag && Begin == Other.Begin && End == Other.End;\n    }\n  };\n\n  /// Simple helper function to map a BundleOpInfo to an\n  /// OperandBundleUse.\n  OperandBundleUse\n  operandBundleFromBundleOpInfo(const BundleOpInfo &BOI) const {\n    auto begin = op_begin();\n    ArrayRef<Use> Inputs(begin + BOI.Begin, begin + BOI.End);\n    return OperandBundleUse(BOI.Tag, Inputs);\n  }\n\n  using bundle_op_iterator = BundleOpInfo *;\n  using const_bundle_op_iterator = const BundleOpInfo *;\n\n  /// Return the start of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  ///\n  /// OperandBundleUser uses the descriptor area co-allocated with the host User\n  /// to store some meta information about which operands are \"normal\" operands,\n  /// and which ones belong to some operand bundle.\n  ///\n  /// The layout of an operand bundle user is\n  ///\n  ///          +-----------uint32_t End-------------------------------------+\n  ///          |                                                            |\n  ///          |  +--------uint32_t Begin--------------------+              |\n  ///          |  |                                          |              |\n  ///          ^  ^                                          v              v\n  ///  |------|------|----|----|----|----|----|---------|----|---------|----|-----\n  ///  | BOI0 | BOI1 | .. | DU | U0 | U1 | .. | BOI0_U0 | .. | BOI1_U0 | .. | Un\n  ///  |------|------|----|----|----|----|----|---------|----|---------|----|-----\n  ///   v  v                                  ^              ^\n  ///   |  |                                  |              |\n  ///   |  +--------uint32_t Begin------------+              |\n  ///   |                                                    |\n  ///   +-----------uint32_t End-----------------------------+\n  ///\n  ///\n  /// BOI0, BOI1 ... are descriptions of operand bundles in this User's use\n  /// list. These descriptions are installed and managed by this class, and\n  /// they're all instances of OperandBundleUser<T>::BundleOpInfo.\n  ///\n  /// DU is an additional descriptor installed by User's 'operator new' to keep\n  /// track of the 'BOI0 ... BOIN' co-allocation.  OperandBundleUser does not\n  /// access or modify DU in any way, it's an implementation detail private to\n  /// User.\n  ///\n  /// The regular Use& vector for the User starts at U0.  The operand bundle\n  /// uses are part of the Use& vector, just like normal uses.  In the diagram\n  /// above, the operand bundle uses start at BOI0_U0.  Each instance of\n  /// BundleOpInfo has information about a contiguous set of uses constituting\n  /// an operand bundle, and the total set of operand bundle uses themselves\n  /// form a contiguous set of uses (i.e. there are no gaps between uses\n  /// corresponding to individual operand bundles).\n  ///\n  /// This class does not know the location of the set of operand bundle uses\n  /// within the use list -- that is decided by the User using this class via\n  /// the BeginIdx argument in populateBundleOperandInfos.\n  ///\n  /// Currently operand bundle users with hung-off operands are not supported.\n  bundle_op_iterator bundle_op_info_begin() {\n    if (!hasDescriptor())\n      return nullptr;\n\n    uint8_t *BytesBegin = getDescriptor().begin();\n    return reinterpret_cast<bundle_op_iterator>(BytesBegin);\n  }\n\n  /// Return the start of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  const_bundle_op_iterator bundle_op_info_begin() const {\n    auto *NonConstThis = const_cast<CallBase *>(this);\n    return NonConstThis->bundle_op_info_begin();\n  }\n\n  /// Return the end of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  bundle_op_iterator bundle_op_info_end() {\n    if (!hasDescriptor())\n      return nullptr;\n\n    uint8_t *BytesEnd = getDescriptor().end();\n    return reinterpret_cast<bundle_op_iterator>(BytesEnd);\n  }\n\n  /// Return the end of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  const_bundle_op_iterator bundle_op_info_end() const {\n    auto *NonConstThis = const_cast<CallBase *>(this);\n    return NonConstThis->bundle_op_info_end();\n  }\n\n  /// Return the range [\\p bundle_op_info_begin, \\p bundle_op_info_end).\n  iterator_range<bundle_op_iterator> bundle_op_infos() {\n    return make_range(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Return the range [\\p bundle_op_info_begin, \\p bundle_op_info_end).\n  iterator_range<const_bundle_op_iterator> bundle_op_infos() const {\n    return make_range(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Populate the BundleOpInfo instances and the Use& vector from \\p\n  /// Bundles.  Return the op_iterator pointing to the Use& one past the last\n  /// last bundle operand use.\n  ///\n  /// Each \\p OperandBundleDef instance is tracked by a OperandBundleInfo\n  /// instance allocated in this User's descriptor.\n  op_iterator populateBundleOperandInfos(ArrayRef<OperandBundleDef> Bundles,\n                                         const unsigned BeginIndex);\n\npublic:\n  /// Return the BundleOpInfo for the operand at index OpIdx.\n  ///\n  /// It is an error to call this with an OpIdx that does not correspond to an\n  /// bundle operand.\n  BundleOpInfo &getBundleOpInfoForOperand(unsigned OpIdx);\n  const BundleOpInfo &getBundleOpInfoForOperand(unsigned OpIdx) const {\n    return const_cast<CallBase *>(this)->getBundleOpInfoForOperand(OpIdx);\n  }\n\nprotected:\n  /// Return the total number of values used in \\p Bundles.\n  static unsigned CountBundleInputs(ArrayRef<OperandBundleDef> Bundles) {\n    unsigned Total = 0;\n    for (auto &B : Bundles)\n      Total += B.input_size();\n    return Total;\n  }\n\n  /// @}\n  // End of operand bundle API.\n\nprivate:\n  bool hasFnAttrOnCalledFunction(Attribute::AttrKind Kind) const;\n  bool hasFnAttrOnCalledFunction(StringRef Kind) const;\n\n  template <typename AttrKind> bool hasFnAttrImpl(AttrKind Kind) const {\n    if (Attrs.hasFnAttribute(Kind))\n      return true;\n\n    // Operand bundles override attributes on the called function, but don't\n    // override attributes directly present on the call instruction.\n    if (isFnAttrDisallowedByOpBundle(Kind))\n      return false;\n\n    return hasFnAttrOnCalledFunction(Kind);\n  }\n\n  /// Determine whether the return value has the given attribute. Supports\n  /// Attribute::AttrKind and StringRef as \\p AttrKind types.\n  template <typename AttrKind> bool hasRetAttrImpl(AttrKind Kind) const {\n    if (Attrs.hasAttribute(AttributeList::ReturnIndex, Kind))\n      return true;\n\n    // Look at the callee, if available.\n    if (const Function *F = getCalledFunction())\n      return F->getAttributes().hasAttribute(AttributeList::ReturnIndex, Kind);\n    return false;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CallBase> : public VariadicOperandTraits<CallBase, 1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CallBase, Value)\n\n//===----------------------------------------------------------------------===//\n//                           FuncletPadInst Class\n//===----------------------------------------------------------------------===//\nclass FuncletPadInst : public Instruction {\nprivate:\n  FuncletPadInst(const FuncletPadInst &CPI);\n\n  explicit FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,\n                          ArrayRef<Value *> Args, unsigned Values,\n                          const Twine &NameStr, Instruction *InsertBefore);\n  explicit FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,\n                          ArrayRef<Value *> Args, unsigned Values,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(Value *ParentPad, ArrayRef<Value *> Args, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n  friend class CatchPadInst;\n  friend class CleanupPadInst;\n\n  FuncletPadInst *cloneImpl() const;\n\npublic:\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// getNumArgOperands - Return the number of funcletpad arguments.\n  ///\n  unsigned getNumArgOperands() const { return getNumOperands() - 1; }\n\n  /// Convenience accessors\n\n  /// Return the outer EH-pad this funclet is nested within.\n  ///\n  /// Note: This returns the associated CatchSwitchInst if this FuncletPadInst\n  /// is a CatchPadInst.\n  Value *getParentPad() const { return Op<-1>(); }\n  void setParentPad(Value *ParentPad) {\n    assert(ParentPad);\n    Op<-1>() = ParentPad;\n  }\n\n  /// getArgOperand/setArgOperand - Return/set the i-th funcletpad argument.\n  ///\n  Value *getArgOperand(unsigned i) const { return getOperand(i); }\n  void setArgOperand(unsigned i, Value *v) { setOperand(i, v); }\n\n  /// arg_operands - iteration adapter for range-for loops.\n  op_range arg_operands() { return op_range(op_begin(), op_end() - 1); }\n\n  /// arg_operands - iteration adapter for range-for loops.\n  const_op_range arg_operands() const {\n    return const_op_range(op_begin(), op_end() - 1);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) { return I->isFuncletPad(); }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<FuncletPadInst>\n    : public VariadicOperandTraits<FuncletPadInst, /*MINARITY=*/1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(FuncletPadInst, Value)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_INSTRTYPES_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "content": "//===- llvm/Instructions.h - Instruction subclass definitions ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file exposes the class definitions of all of the subclasses of the\n// Instruction class.  This is meant to be an easy way to get access to all\n// instruction subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INSTRUCTIONS_H\n#define LLVM_IR_INSTRUCTIONS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Bitfields.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n\nnamespace llvm {\n\nclass APInt;\nclass ConstantInt;\nclass DataLayout;\nclass LLVMContext;\n\n//===----------------------------------------------------------------------===//\n//                                AllocaInst Class\n//===----------------------------------------------------------------------===//\n\n/// an instruction to allocate memory on the stack\nclass AllocaInst : public UnaryInstruction {\n  Type *AllocatedType;\n\n  using AlignmentField = AlignmentBitfieldElementT<0>;\n  using UsedWithInAllocaField = BoolBitfieldElementT<AlignmentField::NextBit>;\n  using SwiftErrorField = BoolBitfieldElementT<UsedWithInAllocaField::NextBit>;\n  static_assert(Bitfield::areContiguous<AlignmentField, UsedWithInAllocaField,\n                                        SwiftErrorField>(),\n                \"Bitfields must be contiguous\");\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  AllocaInst *cloneImpl() const;\n\npublic:\n  explicit AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize,\n                      const Twine &Name, Instruction *InsertBefore);\n  AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize,\n             const Twine &Name, BasicBlock *InsertAtEnd);\n\n  AllocaInst(Type *Ty, unsigned AddrSpace, const Twine &Name,\n             Instruction *InsertBefore);\n  AllocaInst(Type *Ty, unsigned AddrSpace,\n             const Twine &Name, BasicBlock *InsertAtEnd);\n\n  AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize, Align Align,\n             const Twine &Name = \"\", Instruction *InsertBefore = nullptr);\n  AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize, Align Align,\n             const Twine &Name, BasicBlock *InsertAtEnd);\n\n  /// Return true if there is an allocation size parameter to the allocation\n  /// instruction that is not 1.\n  bool isArrayAllocation() const;\n\n  /// Get the number of elements allocated. For a simple allocation of a single\n  /// element, this will return a constant 1 value.\n  const Value *getArraySize() const { return getOperand(0); }\n  Value *getArraySize() { return getOperand(0); }\n\n  /// Overload to return most specific pointer type.\n  PointerType *getType() const {\n    return cast<PointerType>(Instruction::getType());\n  }\n\n  /// Get allocation size in bits. Returns None if size can't be determined,\n  /// e.g. in case of a VLA.\n  Optional<TypeSize> getAllocationSizeInBits(const DataLayout &DL) const;\n\n  /// Return the type that is being allocated by the instruction.\n  Type *getAllocatedType() const { return AllocatedType; }\n  /// for use only in special circumstances that need to generically\n  /// transform a whole instruction (eg: IR linking and vectorization).\n  void setAllocatedType(Type *Ty) { AllocatedType = Ty; }\n\n  /// Return the alignment of the memory that is being allocated by the\n  /// instruction.\n  Align getAlign() const {\n    return Align(1ULL << getSubclassData<AlignmentField>());\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  // FIXME: Remove this one transition to Align is over.\n  unsigned getAlignment() const { return getAlign().value(); }\n\n  /// Return true if this alloca is in the entry block of the function and is a\n  /// constant size. If so, the code generator will fold it into the\n  /// prolog/epilog code, so it is basically free.\n  bool isStaticAlloca() const;\n\n  /// Return true if this alloca is used as an inalloca argument to a call. Such\n  /// allocas are never considered static even if they are in the entry block.\n  bool isUsedWithInAlloca() const {\n    return getSubclassData<UsedWithInAllocaField>();\n  }\n\n  /// Specify whether this alloca is used to represent the arguments to a call.\n  void setUsedWithInAlloca(bool V) {\n    setSubclassData<UsedWithInAllocaField>(V);\n  }\n\n  /// Return true if this alloca is used as a swifterror argument to a call.\n  bool isSwiftError() const { return getSubclassData<SwiftErrorField>(); }\n  /// Specify whether this alloca is used to represent a swifterror.\n  void setSwiftError(bool V) { setSubclassData<SwiftErrorField>(V); }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::Alloca);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                LoadInst Class\n//===----------------------------------------------------------------------===//\n\n/// An instruction for reading from memory. This uses the SubclassData field in\n/// Value to store whether or not the load is volatile.\nclass LoadInst : public UnaryInstruction {\n  using VolatileField = BoolBitfieldElementT<0>;\n  using AlignmentField = AlignmentBitfieldElementT<VolatileField::NextBit>;\n  using OrderingField = AtomicOrderingBitfieldElementT<AlignmentField::NextBit>;\n  static_assert(\n      Bitfield::areContiguous<VolatileField, AlignmentField, OrderingField>(),\n      \"Bitfields must be contiguous\");\n\n  void AssertOK();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  LoadInst *cloneImpl() const;\n\npublic:\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr,\n           Instruction *InsertBefore);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, BasicBlock *InsertAtEnd);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Instruction *InsertBefore);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           BasicBlock *InsertAtEnd);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Align Align, Instruction *InsertBefore = nullptr);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Align Align, BasicBlock *InsertAtEnd);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Align Align, AtomicOrdering Order,\n           SyncScope::ID SSID = SyncScope::System,\n           Instruction *InsertBefore = nullptr);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Align Align, AtomicOrdering Order, SyncScope::ID SSID,\n           BasicBlock *InsertAtEnd);\n\n  /// Return true if this is a load from a volatile memory location.\n  bool isVolatile() const { return getSubclassData<VolatileField>(); }\n\n  /// Specify whether this is a volatile load or not.\n  void setVolatile(bool V) { setSubclassData<VolatileField>(V); }\n\n  /// Return the alignment of the access that is being performed.\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getAlign() instead.\n  unsigned getAlignment() const { return getAlign().value(); }\n\n  /// Return the alignment of the access that is being performed.\n  Align getAlign() const {\n    return Align(1ULL << (getSubclassData<AlignmentField>()));\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  /// Returns the ordering constraint of this load instruction.\n  AtomicOrdering getOrdering() const {\n    return getSubclassData<OrderingField>();\n  }\n  /// Sets the ordering constraint of this load instruction.  May not be Release\n  /// or AcquireRelease.\n  void setOrdering(AtomicOrdering Ordering) {\n    setSubclassData<OrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this load instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this load instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  /// Sets the ordering constraint and the synchronization scope ID of this load\n  /// instruction.\n  void setAtomic(AtomicOrdering Ordering,\n                 SyncScope::ID SSID = SyncScope::System) {\n    setOrdering(Ordering);\n    setSyncScopeID(SSID);\n  }\n\n  bool isSimple() const { return !isAtomic() && !isVolatile(); }\n\n  bool isUnordered() const {\n    return (getOrdering() == AtomicOrdering::NotAtomic ||\n            getOrdering() == AtomicOrdering::Unordered) &&\n           !isVolatile();\n  }\n\n  Value *getPointerOperand() { return getOperand(0); }\n  const Value *getPointerOperand() const { return getOperand(0); }\n  static unsigned getPointerOperandIndex() { return 0U; }\n  Type *getPointerOperandType() const { return getPointerOperand()->getType(); }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperandType()->getPointerAddressSpace();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Load;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this load instruction.  Not quite enough\n  /// room in SubClassData for everything, so synchronization scope ID gets its\n  /// own field.\n  SyncScope::ID SSID;\n};\n\n//===----------------------------------------------------------------------===//\n//                                StoreInst Class\n//===----------------------------------------------------------------------===//\n\n/// An instruction for storing to memory.\nclass StoreInst : public Instruction {\n  using VolatileField = BoolBitfieldElementT<0>;\n  using AlignmentField = AlignmentBitfieldElementT<VolatileField::NextBit>;\n  using OrderingField = AtomicOrderingBitfieldElementT<AlignmentField::NextBit>;\n  static_assert(\n      Bitfield::areContiguous<VolatileField, AlignmentField, OrderingField>(),\n      \"Bitfields must be contiguous\");\n\n  void AssertOK();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  StoreInst *cloneImpl() const;\n\npublic:\n  StoreInst(Value *Val, Value *Ptr, Instruction *InsertBefore);\n  StoreInst(Value *Val, Value *Ptr, BasicBlock *InsertAtEnd);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Instruction *InsertBefore);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, BasicBlock *InsertAtEnd);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Align Align,\n            Instruction *InsertBefore = nullptr);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Align Align,\n            BasicBlock *InsertAtEnd);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Align Align,\n            AtomicOrdering Order, SyncScope::ID SSID = SyncScope::System,\n            Instruction *InsertBefore = nullptr);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Align Align,\n            AtomicOrdering Order, SyncScope::ID SSID, BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  /// Return true if this is a store to a volatile memory location.\n  bool isVolatile() const { return getSubclassData<VolatileField>(); }\n\n  /// Specify whether this is a volatile store or not.\n  void setVolatile(bool V) { setSubclassData<VolatileField>(V); }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Return the alignment of the access that is being performed\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getAlign() instead.\n  unsigned getAlignment() const { return getAlign().value(); }\n\n  Align getAlign() const {\n    return Align(1ULL << (getSubclassData<AlignmentField>()));\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  /// Returns the ordering constraint of this store instruction.\n  AtomicOrdering getOrdering() const {\n    return getSubclassData<OrderingField>();\n  }\n\n  /// Sets the ordering constraint of this store instruction.  May not be\n  /// Acquire or AcquireRelease.\n  void setOrdering(AtomicOrdering Ordering) {\n    setSubclassData<OrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this store instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this store instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  /// Sets the ordering constraint and the synchronization scope ID of this\n  /// store instruction.\n  void setAtomic(AtomicOrdering Ordering,\n                 SyncScope::ID SSID = SyncScope::System) {\n    setOrdering(Ordering);\n    setSyncScopeID(SSID);\n  }\n\n  bool isSimple() const { return !isAtomic() && !isVolatile(); }\n\n  bool isUnordered() const {\n    return (getOrdering() == AtomicOrdering::NotAtomic ||\n            getOrdering() == AtomicOrdering::Unordered) &&\n           !isVolatile();\n  }\n\n  Value *getValueOperand() { return getOperand(0); }\n  const Value *getValueOperand() const { return getOperand(0); }\n\n  Value *getPointerOperand() { return getOperand(1); }\n  const Value *getPointerOperand() const { return getOperand(1); }\n  static unsigned getPointerOperandIndex() { return 1U; }\n  Type *getPointerOperandType() const { return getPointerOperand()->getType(); }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperandType()->getPointerAddressSpace();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Store;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this store instruction.  Not quite enough\n  /// room in SubClassData for everything, so synchronization scope ID gets its\n  /// own field.\n  SyncScope::ID SSID;\n};\n\ntemplate <>\nstruct OperandTraits<StoreInst> : public FixedNumOperandTraits<StoreInst, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(StoreInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                FenceInst Class\n//===----------------------------------------------------------------------===//\n\n/// An instruction for ordering other memory operations.\nclass FenceInst : public Instruction {\n  using OrderingField = AtomicOrderingBitfieldElementT<0>;\n\n  void Init(AtomicOrdering Ordering, SyncScope::ID SSID);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  FenceInst *cloneImpl() const;\n\npublic:\n  // Ordering may only be Acquire, Release, AcquireRelease, or\n  // SequentiallyConsistent.\n  FenceInst(LLVMContext &C, AtomicOrdering Ordering,\n            SyncScope::ID SSID = SyncScope::System,\n            Instruction *InsertBefore = nullptr);\n  FenceInst(LLVMContext &C, AtomicOrdering Ordering, SyncScope::ID SSID,\n            BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 0);\n  }\n\n  /// Returns the ordering constraint of this fence instruction.\n  AtomicOrdering getOrdering() const {\n    return getSubclassData<OrderingField>();\n  }\n\n  /// Sets the ordering constraint of this fence instruction.  May only be\n  /// Acquire, Release, AcquireRelease, or SequentiallyConsistent.\n  void setOrdering(AtomicOrdering Ordering) {\n    setSubclassData<OrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this fence instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this fence instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Fence;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this fence instruction.  Not quite enough\n  /// room in SubClassData for everything, so synchronization scope ID gets its\n  /// own field.\n  SyncScope::ID SSID;\n};\n\n//===----------------------------------------------------------------------===//\n//                                AtomicCmpXchgInst Class\n//===----------------------------------------------------------------------===//\n\n/// An instruction that atomically checks whether a\n/// specified value is in a memory location, and, if it is, stores a new value\n/// there. The value returned by this instruction is a pair containing the\n/// original value as first element, and an i1 indicating success (true) or\n/// failure (false) as second element.\n///\nclass AtomicCmpXchgInst : public Instruction {\n  void Init(Value *Ptr, Value *Cmp, Value *NewVal, Align Align,\n            AtomicOrdering SuccessOrdering, AtomicOrdering FailureOrdering,\n            SyncScope::ID SSID);\n\n  template <unsigned Offset>\n  using AtomicOrderingBitfieldElement =\n      typename Bitfield::Element<AtomicOrdering, Offset, 3,\n                                 AtomicOrdering::LAST>;\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  AtomicCmpXchgInst *cloneImpl() const;\n\npublic:\n  AtomicCmpXchgInst(Value *Ptr, Value *Cmp, Value *NewVal, Align Alignment,\n                    AtomicOrdering SuccessOrdering,\n                    AtomicOrdering FailureOrdering, SyncScope::ID SSID,\n                    Instruction *InsertBefore = nullptr);\n  AtomicCmpXchgInst(Value *Ptr, Value *Cmp, Value *NewVal, Align Alignment,\n                    AtomicOrdering SuccessOrdering,\n                    AtomicOrdering FailureOrdering, SyncScope::ID SSID,\n                    BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly three operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 3);\n  }\n\n  using VolatileField = BoolBitfieldElementT<0>;\n  using WeakField = BoolBitfieldElementT<VolatileField::NextBit>;\n  using SuccessOrderingField =\n      AtomicOrderingBitfieldElementT<WeakField::NextBit>;\n  using FailureOrderingField =\n      AtomicOrderingBitfieldElementT<SuccessOrderingField::NextBit>;\n  using AlignmentField =\n      AlignmentBitfieldElementT<FailureOrderingField::NextBit>;\n  static_assert(\n      Bitfield::areContiguous<VolatileField, WeakField, SuccessOrderingField,\n                              FailureOrderingField, AlignmentField>(),\n      \"Bitfields must be contiguous\");\n\n  /// Return the alignment of the memory that is being allocated by the\n  /// instruction.\n  Align getAlign() const {\n    return Align(1ULL << getSubclassData<AlignmentField>());\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  /// Return true if this is a cmpxchg from a volatile memory\n  /// location.\n  ///\n  bool isVolatile() const { return getSubclassData<VolatileField>(); }\n\n  /// Specify whether this is a volatile cmpxchg.\n  ///\n  void setVolatile(bool V) { setSubclassData<VolatileField>(V); }\n\n  /// Return true if this cmpxchg may spuriously fail.\n  bool isWeak() const { return getSubclassData<WeakField>(); }\n\n  void setWeak(bool IsWeak) { setSubclassData<WeakField>(IsWeak); }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Returns the success ordering constraint of this cmpxchg instruction.\n  AtomicOrdering getSuccessOrdering() const {\n    return getSubclassData<SuccessOrderingField>();\n  }\n\n  /// Sets the success ordering constraint of this cmpxchg instruction.\n  void setSuccessOrdering(AtomicOrdering Ordering) {\n    assert(Ordering != AtomicOrdering::NotAtomic &&\n           \"CmpXchg instructions can only be atomic.\");\n    setSubclassData<SuccessOrderingField>(Ordering);\n  }\n\n  /// Returns the failure ordering constraint of this cmpxchg instruction.\n  AtomicOrdering getFailureOrdering() const {\n    return getSubclassData<FailureOrderingField>();\n  }\n\n  /// Sets the failure ordering constraint of this cmpxchg instruction.\n  void setFailureOrdering(AtomicOrdering Ordering) {\n    assert(Ordering != AtomicOrdering::NotAtomic &&\n           \"CmpXchg instructions can only be atomic.\");\n    setSubclassData<FailureOrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this cmpxchg instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this cmpxchg instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  Value *getPointerOperand() { return getOperand(0); }\n  const Value *getPointerOperand() const { return getOperand(0); }\n  static unsigned getPointerOperandIndex() { return 0U; }\n\n  Value *getCompareOperand() { return getOperand(1); }\n  const Value *getCompareOperand() const { return getOperand(1); }\n\n  Value *getNewValOperand() { return getOperand(2); }\n  const Value *getNewValOperand() const { return getOperand(2); }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  /// Returns the strongest permitted ordering on failure, given the\n  /// desired ordering on success.\n  ///\n  /// If the comparison in a cmpxchg operation fails, there is no atomic store\n  /// so release semantics cannot be provided. So this function drops explicit\n  /// Release requests from the AtomicOrdering. A SequentiallyConsistent\n  /// operation would remain SequentiallyConsistent.\n  static AtomicOrdering\n  getStrongestFailureOrdering(AtomicOrdering SuccessOrdering) {\n    switch (SuccessOrdering) {\n    default:\n      llvm_unreachable(\"invalid cmpxchg success ordering\");\n    case AtomicOrdering::Release:\n    case AtomicOrdering::Monotonic:\n      return AtomicOrdering::Monotonic;\n    case AtomicOrdering::AcquireRelease:\n    case AtomicOrdering::Acquire:\n      return AtomicOrdering::Acquire;\n    case AtomicOrdering::SequentiallyConsistent:\n      return AtomicOrdering::SequentiallyConsistent;\n    }\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::AtomicCmpXchg;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this cmpxchg instruction.  Not quite\n  /// enough room in SubClassData for everything, so synchronization scope ID\n  /// gets its own field.\n  SyncScope::ID SSID;\n};\n\ntemplate <>\nstruct OperandTraits<AtomicCmpXchgInst> :\n    public FixedNumOperandTraits<AtomicCmpXchgInst, 3> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(AtomicCmpXchgInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                AtomicRMWInst Class\n//===----------------------------------------------------------------------===//\n\n/// an instruction that atomically reads a memory location,\n/// combines it with another value, and then stores the result back.  Returns\n/// the old value.\n///\nclass AtomicRMWInst : public Instruction {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  AtomicRMWInst *cloneImpl() const;\n\npublic:\n  /// This enumeration lists the possible modifications atomicrmw can make.  In\n  /// the descriptions, 'p' is the pointer to the instruction's memory location,\n  /// 'old' is the initial value of *p, and 'v' is the other value passed to the\n  /// instruction.  These instructions always return 'old'.\n  enum BinOp : unsigned {\n    /// *p = v\n    Xchg,\n    /// *p = old + v\n    Add,\n    /// *p = old - v\n    Sub,\n    /// *p = old & v\n    And,\n    /// *p = ~(old & v)\n    Nand,\n    /// *p = old | v\n    Or,\n    /// *p = old ^ v\n    Xor,\n    /// *p = old >signed v ? old : v\n    Max,\n    /// *p = old <signed v ? old : v\n    Min,\n    /// *p = old >unsigned v ? old : v\n    UMax,\n    /// *p = old <unsigned v ? old : v\n    UMin,\n\n    /// *p = old + v\n    FAdd,\n\n    /// *p = old - v\n    FSub,\n\n    FIRST_BINOP = Xchg,\n    LAST_BINOP = FSub,\n    BAD_BINOP\n  };\n\nprivate:\n  template <unsigned Offset>\n  using AtomicOrderingBitfieldElement =\n      typename Bitfield::Element<AtomicOrdering, Offset, 3,\n                                 AtomicOrdering::LAST>;\n\n  template <unsigned Offset>\n  using BinOpBitfieldElement =\n      typename Bitfield::Element<BinOp, Offset, 4, BinOp::LAST_BINOP>;\n\npublic:\n  AtomicRMWInst(BinOp Operation, Value *Ptr, Value *Val, Align Alignment,\n                AtomicOrdering Ordering, SyncScope::ID SSID,\n                Instruction *InsertBefore = nullptr);\n  AtomicRMWInst(BinOp Operation, Value *Ptr, Value *Val, Align Alignment,\n                AtomicOrdering Ordering, SyncScope::ID SSID,\n                BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  using VolatileField = BoolBitfieldElementT<0>;\n  using AtomicOrderingField =\n      AtomicOrderingBitfieldElementT<VolatileField::NextBit>;\n  using OperationField = BinOpBitfieldElement<AtomicOrderingField::NextBit>;\n  using AlignmentField = AlignmentBitfieldElementT<OperationField::NextBit>;\n  static_assert(Bitfield::areContiguous<VolatileField, AtomicOrderingField,\n                                        OperationField, AlignmentField>(),\n                \"Bitfields must be contiguous\");\n\n  BinOp getOperation() const { return getSubclassData<OperationField>(); }\n\n  static StringRef getOperationName(BinOp Op);\n\n  static bool isFPOperation(BinOp Op) {\n    switch (Op) {\n    case AtomicRMWInst::FAdd:\n    case AtomicRMWInst::FSub:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  void setOperation(BinOp Operation) {\n    setSubclassData<OperationField>(Operation);\n  }\n\n  /// Return the alignment of the memory that is being allocated by the\n  /// instruction.\n  Align getAlign() const {\n    return Align(1ULL << getSubclassData<AlignmentField>());\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  /// Return true if this is a RMW on a volatile memory location.\n  ///\n  bool isVolatile() const { return getSubclassData<VolatileField>(); }\n\n  /// Specify whether this is a volatile RMW or not.\n  ///\n  void setVolatile(bool V) { setSubclassData<VolatileField>(V); }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Returns the ordering constraint of this rmw instruction.\n  AtomicOrdering getOrdering() const {\n    return getSubclassData<AtomicOrderingField>();\n  }\n\n  /// Sets the ordering constraint of this rmw instruction.\n  void setOrdering(AtomicOrdering Ordering) {\n    assert(Ordering != AtomicOrdering::NotAtomic &&\n           \"atomicrmw instructions can only be atomic.\");\n    setSubclassData<AtomicOrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this rmw instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this rmw instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  Value *getPointerOperand() { return getOperand(0); }\n  const Value *getPointerOperand() const { return getOperand(0); }\n  static unsigned getPointerOperandIndex() { return 0U; }\n\n  Value *getValOperand() { return getOperand(1); }\n  const Value *getValOperand() const { return getOperand(1); }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  bool isFloatingPointOperation() const {\n    return isFPOperation(getOperation());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::AtomicRMW;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  void Init(BinOp Operation, Value *Ptr, Value *Val, Align Align,\n            AtomicOrdering Ordering, SyncScope::ID SSID);\n\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this rmw instruction.  Not quite enough\n  /// room in SubClassData for everything, so synchronization scope ID gets its\n  /// own field.\n  SyncScope::ID SSID;\n};\n\ntemplate <>\nstruct OperandTraits<AtomicRMWInst>\n    : public FixedNumOperandTraits<AtomicRMWInst,2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(AtomicRMWInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                             GetElementPtrInst Class\n//===----------------------------------------------------------------------===//\n\n// checkGEPType - Simple wrapper function to give a better assertion failure\n// message on bad indexes for a gep instruction.\n//\ninline Type *checkGEPType(Type *Ty) {\n  assert(Ty && \"Invalid GetElementPtrInst indices for type!\");\n  return Ty;\n}\n\n/// an instruction for type-safe pointer arithmetic to\n/// access elements of arrays and structs\n///\nclass GetElementPtrInst : public Instruction {\n  Type *SourceElementType;\n  Type *ResultElementType;\n\n  GetElementPtrInst(const GetElementPtrInst &GEPI);\n\n  /// Constructors - Create a getelementptr instruction with a base pointer an\n  /// list of indices. The first ctor can optionally insert before an existing\n  /// instruction, the second appends the new instruction to the specified\n  /// BasicBlock.\n  inline GetElementPtrInst(Type *PointeeType, Value *Ptr,\n                           ArrayRef<Value *> IdxList, unsigned Values,\n                           const Twine &NameStr, Instruction *InsertBefore);\n  inline GetElementPtrInst(Type *PointeeType, Value *Ptr,\n                           ArrayRef<Value *> IdxList, unsigned Values,\n                           const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(Value *Ptr, ArrayRef<Value *> IdxList, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  GetElementPtrInst *cloneImpl() const;\n\npublic:\n  static GetElementPtrInst *Create(Type *PointeeType, Value *Ptr,\n                                   ArrayRef<Value *> IdxList,\n                                   const Twine &NameStr = \"\",\n                                   Instruction *InsertBefore = nullptr) {\n    unsigned Values = 1 + unsigned(IdxList.size());\n    if (!PointeeType)\n      PointeeType =\n          cast<PointerType>(Ptr->getType()->getScalarType())->getElementType();\n    else\n      assert(\n          PointeeType ==\n          cast<PointerType>(Ptr->getType()->getScalarType())->getElementType());\n    return new (Values) GetElementPtrInst(PointeeType, Ptr, IdxList, Values,\n                                          NameStr, InsertBefore);\n  }\n\n  static GetElementPtrInst *Create(Type *PointeeType, Value *Ptr,\n                                   ArrayRef<Value *> IdxList,\n                                   const Twine &NameStr,\n                                   BasicBlock *InsertAtEnd) {\n    unsigned Values = 1 + unsigned(IdxList.size());\n    if (!PointeeType)\n      PointeeType =\n          cast<PointerType>(Ptr->getType()->getScalarType())->getElementType();\n    else\n      assert(\n          PointeeType ==\n          cast<PointerType>(Ptr->getType()->getScalarType())->getElementType());\n    return new (Values) GetElementPtrInst(PointeeType, Ptr, IdxList, Values,\n                                          NameStr, InsertAtEnd);\n  }\n\n  /// Create an \"inbounds\" getelementptr. See the documentation for the\n  /// \"inbounds\" flag in LangRef.html for details.\n  static GetElementPtrInst *CreateInBounds(Value *Ptr,\n                                           ArrayRef<Value *> IdxList,\n                                           const Twine &NameStr = \"\",\n                                           Instruction *InsertBefore = nullptr){\n    return CreateInBounds(nullptr, Ptr, IdxList, NameStr, InsertBefore);\n  }\n\n  static GetElementPtrInst *\n  CreateInBounds(Type *PointeeType, Value *Ptr, ArrayRef<Value *> IdxList,\n                 const Twine &NameStr = \"\",\n                 Instruction *InsertBefore = nullptr) {\n    GetElementPtrInst *GEP =\n        Create(PointeeType, Ptr, IdxList, NameStr, InsertBefore);\n    GEP->setIsInBounds(true);\n    return GEP;\n  }\n\n  static GetElementPtrInst *CreateInBounds(Value *Ptr,\n                                           ArrayRef<Value *> IdxList,\n                                           const Twine &NameStr,\n                                           BasicBlock *InsertAtEnd) {\n    return CreateInBounds(nullptr, Ptr, IdxList, NameStr, InsertAtEnd);\n  }\n\n  static GetElementPtrInst *CreateInBounds(Type *PointeeType, Value *Ptr,\n                                           ArrayRef<Value *> IdxList,\n                                           const Twine &NameStr,\n                                           BasicBlock *InsertAtEnd) {\n    GetElementPtrInst *GEP =\n        Create(PointeeType, Ptr, IdxList, NameStr, InsertAtEnd);\n    GEP->setIsInBounds(true);\n    return GEP;\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  Type *getSourceElementType() const { return SourceElementType; }\n\n  void setSourceElementType(Type *Ty) { SourceElementType = Ty; }\n  void setResultElementType(Type *Ty) { ResultElementType = Ty; }\n\n  Type *getResultElementType() const {\n    assert(ResultElementType ==\n           cast<PointerType>(getType()->getScalarType())->getElementType());\n    return ResultElementType;\n  }\n\n  /// Returns the address space of this instruction's pointer type.\n  unsigned getAddressSpace() const {\n    // Note that this is always the same as the pointer operand's address space\n    // and that is cheaper to compute, so cheat here.\n    return getPointerAddressSpace();\n  }\n\n  /// Returns the result type of a getelementptr with the given source\n  /// element type and indexes.\n  ///\n  /// Null is returned if the indices are invalid for the specified\n  /// source element type.\n  static Type *getIndexedType(Type *Ty, ArrayRef<Value *> IdxList);\n  static Type *getIndexedType(Type *Ty, ArrayRef<Constant *> IdxList);\n  static Type *getIndexedType(Type *Ty, ArrayRef<uint64_t> IdxList);\n\n  /// Return the type of the element at the given index of an indexable\n  /// type.  This is equivalent to \"getIndexedType(Agg, {Zero, Idx})\".\n  ///\n  /// Returns null if the type can't be indexed, or the given index is not\n  /// legal for the given type.\n  static Type *getTypeAtIndex(Type *Ty, Value *Idx);\n  static Type *getTypeAtIndex(Type *Ty, uint64_t Idx);\n\n  inline op_iterator       idx_begin()       { return op_begin()+1; }\n  inline const_op_iterator idx_begin() const { return op_begin()+1; }\n  inline op_iterator       idx_end()         { return op_end(); }\n  inline const_op_iterator idx_end()   const { return op_end(); }\n\n  inline iterator_range<op_iterator> indices() {\n    return make_range(idx_begin(), idx_end());\n  }\n\n  inline iterator_range<const_op_iterator> indices() const {\n    return make_range(idx_begin(), idx_end());\n  }\n\n  Value *getPointerOperand() {\n    return getOperand(0);\n  }\n  const Value *getPointerOperand() const {\n    return getOperand(0);\n  }\n  static unsigned getPointerOperandIndex() {\n    return 0U;    // get index for modifying correct operand.\n  }\n\n  /// Method to return the pointer operand as a\n  /// PointerType.\n  Type *getPointerOperandType() const {\n    return getPointerOperand()->getType();\n  }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperandType()->getPointerAddressSpace();\n  }\n\n  /// Returns the pointer type returned by the GEP\n  /// instruction, which may be a vector of pointers.\n  static Type *getGEPReturnType(Type *ElTy, Value *Ptr,\n                                ArrayRef<Value *> IdxList) {\n    Type *PtrTy = PointerType::get(checkGEPType(getIndexedType(ElTy, IdxList)),\n                                   Ptr->getType()->getPointerAddressSpace());\n    // Vector GEP\n    if (auto *PtrVTy = dyn_cast<VectorType>(Ptr->getType())) {\n      ElementCount EltCount = PtrVTy->getElementCount();\n      return VectorType::get(PtrTy, EltCount);\n    }\n    for (Value *Index : IdxList)\n      if (auto *IndexVTy = dyn_cast<VectorType>(Index->getType())) {\n        ElementCount EltCount = IndexVTy->getElementCount();\n        return VectorType::get(PtrTy, EltCount);\n      }\n    // Scalar GEP\n    return PtrTy;\n  }\n\n  unsigned getNumIndices() const {  // Note: always non-negative\n    return getNumOperands() - 1;\n  }\n\n  bool hasIndices() const {\n    return getNumOperands() > 1;\n  }\n\n  /// Return true if all of the indices of this GEP are\n  /// zeros.  If so, the result pointer and the first operand have the same\n  /// value, just potentially different types.\n  bool hasAllZeroIndices() const;\n\n  /// Return true if all of the indices of this GEP are\n  /// constant integers.  If so, the result pointer and the first operand have\n  /// a constant offset between them.\n  bool hasAllConstantIndices() const;\n\n  /// Set or clear the inbounds flag on this GEP instruction.\n  /// See LangRef.html for the meaning of inbounds on a getelementptr.\n  void setIsInBounds(bool b = true);\n\n  /// Determine whether the GEP has the inbounds flag.\n  bool isInBounds() const;\n\n  /// Accumulate the constant address offset of this GEP if possible.\n  ///\n  /// This routine accepts an APInt into which it will accumulate the constant\n  /// offset of this GEP if the GEP is in fact constant. If the GEP is not\n  /// all-constant, it returns false and the value of the offset APInt is\n  /// undefined (it is *not* preserved!). The APInt passed into this routine\n  /// must be at least as wide as the IntPtr type for the address space of\n  /// the base GEP pointer.\n  bool accumulateConstantOffset(const DataLayout &DL, APInt &Offset) const;\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::GetElementPtr);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<GetElementPtrInst> :\n  public VariadicOperandTraits<GetElementPtrInst, 1> {\n};\n\nGetElementPtrInst::GetElementPtrInst(Type *PointeeType, Value *Ptr,\n                                     ArrayRef<Value *> IdxList, unsigned Values,\n                                     const Twine &NameStr,\n                                     Instruction *InsertBefore)\n    : Instruction(getGEPReturnType(PointeeType, Ptr, IdxList), GetElementPtr,\n                  OperandTraits<GetElementPtrInst>::op_end(this) - Values,\n                  Values, InsertBefore),\n      SourceElementType(PointeeType),\n      ResultElementType(getIndexedType(PointeeType, IdxList)) {\n  assert(ResultElementType ==\n         cast<PointerType>(getType()->getScalarType())->getElementType());\n  init(Ptr, IdxList, NameStr);\n}\n\nGetElementPtrInst::GetElementPtrInst(Type *PointeeType, Value *Ptr,\n                                     ArrayRef<Value *> IdxList, unsigned Values,\n                                     const Twine &NameStr,\n                                     BasicBlock *InsertAtEnd)\n    : Instruction(getGEPReturnType(PointeeType, Ptr, IdxList), GetElementPtr,\n                  OperandTraits<GetElementPtrInst>::op_end(this) - Values,\n                  Values, InsertAtEnd),\n      SourceElementType(PointeeType),\n      ResultElementType(getIndexedType(PointeeType, IdxList)) {\n  assert(ResultElementType ==\n         cast<PointerType>(getType()->getScalarType())->getElementType());\n  init(Ptr, IdxList, NameStr);\n}\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(GetElementPtrInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               ICmpInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction compares its operands according to the predicate given\n/// to the constructor. It only operates on integers or pointers. The operands\n/// must be identical types.\n/// Represent an integer comparison operator.\nclass ICmpInst: public CmpInst {\n  void AssertOK() {\n    assert(isIntPredicate() &&\n           \"Invalid ICmp predicate value\");\n    assert(getOperand(0)->getType() == getOperand(1)->getType() &&\n          \"Both operands to ICmp instruction are not of the same type!\");\n    // Check that the operands are the right type\n    assert((getOperand(0)->getType()->isIntOrIntVectorTy() ||\n            getOperand(0)->getType()->isPtrOrPtrVectorTy()) &&\n           \"Invalid operand types for ICmp instruction\");\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical ICmpInst\n  ICmpInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics.\n  ICmpInst(\n    Instruction *InsertBefore,  ///< Where to insert\n    Predicate pred,  ///< The predicate to use for the comparison\n    Value *LHS,      ///< The left-hand-side of the expression\n    Value *RHS,      ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\"  ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::ICmp, pred, LHS, RHS, NameStr,\n              InsertBefore) {\n#ifndef NDEBUG\n  AssertOK();\n#endif\n  }\n\n  /// Constructor with insert-at-end semantics.\n  ICmpInst(\n    BasicBlock &InsertAtEnd, ///< Block to insert into.\n    Predicate pred,  ///< The predicate to use for the comparison\n    Value *LHS,      ///< The left-hand-side of the expression\n    Value *RHS,      ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\"  ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::ICmp, pred, LHS, RHS, NameStr,\n              &InsertAtEnd) {\n#ifndef NDEBUG\n  AssertOK();\n#endif\n  }\n\n  /// Constructor with no-insertion semantics\n  ICmpInst(\n    Predicate pred, ///< The predicate to use for the comparison\n    Value *LHS,     ///< The left-hand-side of the expression\n    Value *RHS,     ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\" ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::ICmp, pred, LHS, RHS, NameStr) {\n#ifndef NDEBUG\n  AssertOK();\n#endif\n  }\n\n  /// For example, EQ->EQ, SLE->SLE, UGT->SGT, etc.\n  /// @returns the predicate that would be the result if the operand were\n  /// regarded as signed.\n  /// Return the signed version of the predicate\n  Predicate getSignedPredicate() const {\n    return getSignedPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction.\n  /// Return the signed version of the predicate.\n  static Predicate getSignedPredicate(Predicate pred);\n\n  /// For example, EQ->EQ, SLE->ULE, UGT->UGT, etc.\n  /// @returns the predicate that would be the result if the operand were\n  /// regarded as unsigned.\n  /// Return the unsigned version of the predicate\n  Predicate getUnsignedPredicate() const {\n    return getUnsignedPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction.\n  /// Return the unsigned version of the predicate.\n  static Predicate getUnsignedPredicate(Predicate pred);\n\n  /// Return true if this predicate is either EQ or NE.  This also\n  /// tests for commutativity.\n  static bool isEquality(Predicate P) {\n    return P == ICMP_EQ || P == ICMP_NE;\n  }\n\n  /// Return true if this predicate is either EQ or NE.  This also\n  /// tests for commutativity.\n  bool isEquality() const {\n    return isEquality(getPredicate());\n  }\n\n  /// @returns true if the predicate of this ICmpInst is commutative\n  /// Determine if this relation is commutative.\n  bool isCommutative() const { return isEquality(); }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  ///\n  bool isRelational() const {\n    return !isEquality();\n  }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  ///\n  static bool isRelational(Predicate P) {\n    return !isEquality(P);\n  }\n\n  /// Return true if the predicate is SGT or UGT.\n  ///\n  static bool isGT(Predicate P) {\n    return P == ICMP_SGT || P == ICMP_UGT;\n  }\n\n  /// Return true if the predicate is SLT or ULT.\n  ///\n  static bool isLT(Predicate P) {\n    return P == ICMP_SLT || P == ICMP_ULT;\n  }\n\n  /// Return true if the predicate is SGE or UGE.\n  ///\n  static bool isGE(Predicate P) {\n    return P == ICMP_SGE || P == ICMP_UGE;\n  }\n\n  /// Return true if the predicate is SLE or ULE.\n  ///\n  static bool isLE(Predicate P) {\n    return P == ICMP_SLE || P == ICMP_ULE;\n  }\n\n  /// Exchange the two operands to this instruction in such a way that it does\n  /// not modify the semantics of the instruction. The predicate value may be\n  /// changed to retain the same result if the predicate is order dependent\n  /// (e.g. ult).\n  /// Swap operands and adjust predicate.\n  void swapOperands() {\n    setPredicate(getSwappedPredicate());\n    Op<0>().swap(Op<1>());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ICmp;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               FCmpInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction compares its operands according to the predicate given\n/// to the constructor. It only operates on floating point values or packed\n/// vectors of floating point values. The operands must be identical types.\n/// Represents a floating point comparison operator.\nclass FCmpInst: public CmpInst {\n  void AssertOK() {\n    assert(isFPPredicate() && \"Invalid FCmp predicate value\");\n    assert(getOperand(0)->getType() == getOperand(1)->getType() &&\n           \"Both operands to FCmp instruction are not of the same type!\");\n    // Check that the operands are the right type\n    assert(getOperand(0)->getType()->isFPOrFPVectorTy() &&\n           \"Invalid operand types for FCmp instruction\");\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FCmpInst\n  FCmpInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics.\n  FCmpInst(\n    Instruction *InsertBefore, ///< Where to insert\n    Predicate pred,  ///< The predicate to use for the comparison\n    Value *LHS,      ///< The left-hand-side of the expression\n    Value *RHS,      ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\"  ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::FCmp, pred, LHS, RHS, NameStr,\n              InsertBefore) {\n    AssertOK();\n  }\n\n  /// Constructor with insert-at-end semantics.\n  FCmpInst(\n    BasicBlock &InsertAtEnd, ///< Block to insert into.\n    Predicate pred,  ///< The predicate to use for the comparison\n    Value *LHS,      ///< The left-hand-side of the expression\n    Value *RHS,      ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\"  ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::FCmp, pred, LHS, RHS, NameStr,\n              &InsertAtEnd) {\n    AssertOK();\n  }\n\n  /// Constructor with no-insertion semantics\n  FCmpInst(\n    Predicate Pred, ///< The predicate to use for the comparison\n    Value *LHS,     ///< The left-hand-side of the expression\n    Value *RHS,     ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\", ///< Name of the instruction\n    Instruction *FlagsSource = nullptr\n  ) : CmpInst(makeCmpResultType(LHS->getType()), Instruction::FCmp, Pred, LHS,\n              RHS, NameStr, nullptr, FlagsSource) {\n    AssertOK();\n  }\n\n  /// @returns true if the predicate of this instruction is EQ or NE.\n  /// Determine if this is an equality predicate.\n  static bool isEquality(Predicate Pred) {\n    return Pred == FCMP_OEQ || Pred == FCMP_ONE || Pred == FCMP_UEQ ||\n           Pred == FCMP_UNE;\n  }\n\n  /// @returns true if the predicate of this instruction is EQ or NE.\n  /// Determine if this is an equality predicate.\n  bool isEquality() const { return isEquality(getPredicate()); }\n\n  /// @returns true if the predicate of this instruction is commutative.\n  /// Determine if this is a commutative predicate.\n  bool isCommutative() const {\n    return isEquality() ||\n           getPredicate() == FCMP_FALSE ||\n           getPredicate() == FCMP_TRUE ||\n           getPredicate() == FCMP_ORD ||\n           getPredicate() == FCMP_UNO;\n  }\n\n  /// @returns true if the predicate is relational (not EQ or NE).\n  /// Determine if this a relational predicate.\n  bool isRelational() const { return !isEquality(); }\n\n  /// Exchange the two operands to this instruction in such a way that it does\n  /// not modify the semantics of the instruction. The predicate value may be\n  /// changed to retain the same result if the predicate is order dependent\n  /// (e.g. ult).\n  /// Swap operands and adjust predicate.\n  void swapOperands() {\n    setPredicate(getSwappedPredicate());\n    Op<0>().swap(Op<1>());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::FCmp;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// This class represents a function call, abstracting a target\n/// machine's calling convention.  This class uses low bit of the SubClassData\n/// field to indicate whether or not this is a tail call.  The rest of the bits\n/// hold the calling convention of the call.\n///\nclass CallInst : public CallBase {\n  CallInst(const CallInst &CI);\n\n  /// Construct a CallInst given a range of arguments.\n  /// Construct a CallInst from a range of arguments\n  inline CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                  ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr,\n                  Instruction *InsertBefore);\n\n  inline CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                  const Twine &NameStr, Instruction *InsertBefore)\n      : CallInst(Ty, Func, Args, None, NameStr, InsertBefore) {}\n\n  /// Construct a CallInst given a range of arguments.\n  /// Construct a CallInst from a range of arguments\n  inline CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                  ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr,\n                  BasicBlock *InsertAtEnd);\n\n  explicit CallInst(FunctionType *Ty, Value *F, const Twine &NameStr,\n                    Instruction *InsertBefore);\n\n  CallInst(FunctionType *ty, Value *F, const Twine &NameStr,\n           BasicBlock *InsertAtEnd);\n\n  void init(FunctionType *FTy, Value *Func, ArrayRef<Value *> Args,\n            ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr);\n  void init(FunctionType *FTy, Value *Func, const Twine &NameStr);\n\n  /// Compute the number of operands to allocate.\n  static int ComputeNumOperands(int NumArgs, int NumBundleInputs = 0) {\n    // We need one operand for the called function, plus the input operand\n    // counts provided.\n    return 1 + NumArgs + NumBundleInputs;\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CallInst *cloneImpl() const;\n\npublic:\n  static CallInst *Create(FunctionType *Ty, Value *F, const Twine &NameStr = \"\",\n                          Instruction *InsertBefore = nullptr) {\n    return new (ComputeNumOperands(0)) CallInst(Ty, F, NameStr, InsertBefore);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                          const Twine &NameStr,\n                          Instruction *InsertBefore = nullptr) {\n    return new (ComputeNumOperands(Args.size()))\n        CallInst(Ty, Func, Args, None, NameStr, InsertBefore);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                          ArrayRef<OperandBundleDef> Bundles = None,\n                          const Twine &NameStr = \"\",\n                          Instruction *InsertBefore = nullptr) {\n    const int NumOperands =\n        ComputeNumOperands(Args.size(), CountBundleInputs(Bundles));\n    const unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        CallInst(Ty, Func, Args, Bundles, NameStr, InsertBefore);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *F, const Twine &NameStr,\n                          BasicBlock *InsertAtEnd) {\n    return new (ComputeNumOperands(0)) CallInst(Ty, F, NameStr, InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return new (ComputeNumOperands(Args.size()))\n        CallInst(Ty, Func, Args, None, NameStr, InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                          ArrayRef<OperandBundleDef> Bundles,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    const int NumOperands =\n        ComputeNumOperands(Args.size(), CountBundleInputs(Bundles));\n    const unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        CallInst(Ty, Func, Args, Bundles, NameStr, InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionCallee Func, const Twine &NameStr = \"\",\n                          Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), NameStr,\n                  InsertBefore);\n  }\n\n  static CallInst *Create(FunctionCallee Func, ArrayRef<Value *> Args,\n                          ArrayRef<OperandBundleDef> Bundles = None,\n                          const Twine &NameStr = \"\",\n                          Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), Args, Bundles,\n                  NameStr, InsertBefore);\n  }\n\n  static CallInst *Create(FunctionCallee Func, ArrayRef<Value *> Args,\n                          const Twine &NameStr,\n                          Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), Args, NameStr,\n                  InsertBefore);\n  }\n\n  static CallInst *Create(FunctionCallee Func, const Twine &NameStr,\n                          BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), NameStr,\n                  InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionCallee Func, ArrayRef<Value *> Args,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), Args, NameStr,\n                  InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionCallee Func, ArrayRef<Value *> Args,\n                          ArrayRef<OperandBundleDef> Bundles,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), Args, Bundles,\n                  NameStr, InsertAtEnd);\n  }\n\n  /// Create a clone of \\p CI with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned call instruction is identical \\p CI in every way except that\n  /// the operand bundles for the new instruction are set to the operand bundles\n  /// in \\p Bundles.\n  static CallInst *Create(CallInst *CI, ArrayRef<OperandBundleDef> Bundles,\n                          Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CI with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned call instruction is identical \\p CI in every way except that\n  /// the operand bundle for the new instruction is set to the operand bundle\n  /// in \\p Bundle.\n  static CallInst *CreateWithReplacedBundle(CallInst *CI,\n                                            OperandBundleDef Bundle,\n                                            Instruction *InsertPt = nullptr);\n\n  /// Generate the IR for a call to malloc:\n  /// 1. Compute the malloc call's argument as the specified type's size,\n  ///    possibly multiplied by the array size if the array size is not\n  ///    constant 1.\n  /// 2. Call malloc with that argument.\n  /// 3. Bitcast the result of the malloc call to the specified type.\n  static Instruction *CreateMalloc(Instruction *InsertBefore, Type *IntPtrTy,\n                                   Type *AllocTy, Value *AllocSize,\n                                   Value *ArraySize = nullptr,\n                                   Function *MallocF = nullptr,\n                                   const Twine &Name = \"\");\n  static Instruction *CreateMalloc(BasicBlock *InsertAtEnd, Type *IntPtrTy,\n                                   Type *AllocTy, Value *AllocSize,\n                                   Value *ArraySize = nullptr,\n                                   Function *MallocF = nullptr,\n                                   const Twine &Name = \"\");\n  static Instruction *CreateMalloc(Instruction *InsertBefore, Type *IntPtrTy,\n                                   Type *AllocTy, Value *AllocSize,\n                                   Value *ArraySize = nullptr,\n                                   ArrayRef<OperandBundleDef> Bundles = None,\n                                   Function *MallocF = nullptr,\n                                   const Twine &Name = \"\");\n  static Instruction *CreateMalloc(BasicBlock *InsertAtEnd, Type *IntPtrTy,\n                                   Type *AllocTy, Value *AllocSize,\n                                   Value *ArraySize = nullptr,\n                                   ArrayRef<OperandBundleDef> Bundles = None,\n                                   Function *MallocF = nullptr,\n                                   const Twine &Name = \"\");\n  /// Generate the IR for a call to the builtin free function.\n  static Instruction *CreateFree(Value *Source, Instruction *InsertBefore);\n  static Instruction *CreateFree(Value *Source, BasicBlock *InsertAtEnd);\n  static Instruction *CreateFree(Value *Source,\n                                 ArrayRef<OperandBundleDef> Bundles,\n                                 Instruction *InsertBefore);\n  static Instruction *CreateFree(Value *Source,\n                                 ArrayRef<OperandBundleDef> Bundles,\n                                 BasicBlock *InsertAtEnd);\n\n  // Note that 'musttail' implies 'tail'.\n  enum TailCallKind : unsigned {\n    TCK_None = 0,\n    TCK_Tail = 1,\n    TCK_MustTail = 2,\n    TCK_NoTail = 3,\n    TCK_LAST = TCK_NoTail\n  };\n\n  using TailCallKindField = Bitfield::Element<TailCallKind, 0, 2, TCK_LAST>;\n  static_assert(\n      Bitfield::areContiguous<TailCallKindField, CallBase::CallingConvField>(),\n      \"Bitfields must be contiguous\");\n\n  TailCallKind getTailCallKind() const {\n    return getSubclassData<TailCallKindField>();\n  }\n\n  bool isTailCall() const {\n    TailCallKind Kind = getTailCallKind();\n    return Kind == TCK_Tail || Kind == TCK_MustTail;\n  }\n\n  bool isMustTailCall() const { return getTailCallKind() == TCK_MustTail; }\n\n  bool isNoTailCall() const { return getTailCallKind() == TCK_NoTail; }\n\n  void setTailCallKind(TailCallKind TCK) {\n    setSubclassData<TailCallKindField>(TCK);\n  }\n\n  void setTailCall(bool IsTc = true) {\n    setTailCallKind(IsTc ? TCK_Tail : TCK_None);\n  }\n\n  /// Return true if the call can return twice\n  bool canReturnTwice() const { return hasFnAttr(Attribute::ReturnsTwice); }\n  void setCanReturnTwice() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ReturnsTwice);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Call;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  /// Updates profile metadata by scaling it by \\p S / \\p T.\n  void updateProfWeight(uint64_t S, uint64_t T);\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\nCallInst::CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                   ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr,\n                   BasicBlock *InsertAtEnd)\n    : CallBase(Ty->getReturnType(), Instruction::Call,\n               OperandTraits<CallBase>::op_end(this) -\n                   (Args.size() + CountBundleInputs(Bundles) + 1),\n               unsigned(Args.size() + CountBundleInputs(Bundles) + 1),\n               InsertAtEnd) {\n  init(Ty, Func, Args, Bundles, NameStr);\n}\n\nCallInst::CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                   ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr,\n                   Instruction *InsertBefore)\n    : CallBase(Ty->getReturnType(), Instruction::Call,\n               OperandTraits<CallBase>::op_end(this) -\n                   (Args.size() + CountBundleInputs(Bundles) + 1),\n               unsigned(Args.size() + CountBundleInputs(Bundles) + 1),\n               InsertBefore) {\n  init(Ty, Func, Args, Bundles, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                               SelectInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents the LLVM 'select' instruction.\n///\nclass SelectInst : public Instruction {\n  SelectInst(Value *C, Value *S1, Value *S2, const Twine &NameStr,\n             Instruction *InsertBefore)\n    : Instruction(S1->getType(), Instruction::Select,\n                  &Op<0>(), 3, InsertBefore) {\n    init(C, S1, S2);\n    setName(NameStr);\n  }\n\n  SelectInst(Value *C, Value *S1, Value *S2, const Twine &NameStr,\n             BasicBlock *InsertAtEnd)\n    : Instruction(S1->getType(), Instruction::Select,\n                  &Op<0>(), 3, InsertAtEnd) {\n    init(C, S1, S2);\n    setName(NameStr);\n  }\n\n  void init(Value *C, Value *S1, Value *S2) {\n    assert(!areInvalidOperands(C, S1, S2) && \"Invalid operands for select\");\n    Op<0>() = C;\n    Op<1>() = S1;\n    Op<2>() = S2;\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  SelectInst *cloneImpl() const;\n\npublic:\n  static SelectInst *Create(Value *C, Value *S1, Value *S2,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr,\n                            Instruction *MDFrom = nullptr) {\n    SelectInst *Sel = new(3) SelectInst(C, S1, S2, NameStr, InsertBefore);\n    if (MDFrom)\n      Sel->copyMetadata(*MDFrom);\n    return Sel;\n  }\n\n  static SelectInst *Create(Value *C, Value *S1, Value *S2,\n                            const Twine &NameStr,\n                            BasicBlock *InsertAtEnd) {\n    return new(3) SelectInst(C, S1, S2, NameStr, InsertAtEnd);\n  }\n\n  const Value *getCondition() const { return Op<0>(); }\n  const Value *getTrueValue() const { return Op<1>(); }\n  const Value *getFalseValue() const { return Op<2>(); }\n  Value *getCondition() { return Op<0>(); }\n  Value *getTrueValue() { return Op<1>(); }\n  Value *getFalseValue() { return Op<2>(); }\n\n  void setCondition(Value *V) { Op<0>() = V; }\n  void setTrueValue(Value *V) { Op<1>() = V; }\n  void setFalseValue(Value *V) { Op<2>() = V; }\n\n  /// Swap the true and false values of the select instruction.\n  /// This doesn't swap prof metadata.\n  void swapValues() { Op<1>().swap(Op<2>()); }\n\n  /// Return a string if the specified operands are invalid\n  /// for a select operation, otherwise return null.\n  static const char *areInvalidOperands(Value *Cond, Value *True, Value *False);\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  OtherOps getOpcode() const {\n    return static_cast<OtherOps>(Instruction::getOpcode());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Select;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<SelectInst> : public FixedNumOperandTraits<SelectInst, 3> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(SelectInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                VAArgInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents the va_arg llvm instruction, which returns\n/// an argument of the specified type given a va_list and increments that list\n///\nclass VAArgInst : public UnaryInstruction {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  VAArgInst *cloneImpl() const;\n\npublic:\n  VAArgInst(Value *List, Type *Ty, const Twine &NameStr = \"\",\n             Instruction *InsertBefore = nullptr)\n    : UnaryInstruction(Ty, VAArg, List, InsertBefore) {\n    setName(NameStr);\n  }\n\n  VAArgInst(Value *List, Type *Ty, const Twine &NameStr,\n            BasicBlock *InsertAtEnd)\n    : UnaryInstruction(Ty, VAArg, List, InsertAtEnd) {\n    setName(NameStr);\n  }\n\n  Value *getPointerOperand() { return getOperand(0); }\n  const Value *getPointerOperand() const { return getOperand(0); }\n  static unsigned getPointerOperandIndex() { return 0U; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == VAArg;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                ExtractElementInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction extracts a single (scalar)\n/// element from a VectorType value\n///\nclass ExtractElementInst : public Instruction {\n  ExtractElementInst(Value *Vec, Value *Idx, const Twine &NameStr = \"\",\n                     Instruction *InsertBefore = nullptr);\n  ExtractElementInst(Value *Vec, Value *Idx, const Twine &NameStr,\n                     BasicBlock *InsertAtEnd);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ExtractElementInst *cloneImpl() const;\n\npublic:\n  static ExtractElementInst *Create(Value *Vec, Value *Idx,\n                                   const Twine &NameStr = \"\",\n                                   Instruction *InsertBefore = nullptr) {\n    return new(2) ExtractElementInst(Vec, Idx, NameStr, InsertBefore);\n  }\n\n  static ExtractElementInst *Create(Value *Vec, Value *Idx,\n                                   const Twine &NameStr,\n                                   BasicBlock *InsertAtEnd) {\n    return new(2) ExtractElementInst(Vec, Idx, NameStr, InsertAtEnd);\n  }\n\n  /// Return true if an extractelement instruction can be\n  /// formed with the specified operands.\n  static bool isValidOperands(const Value *Vec, const Value *Idx);\n\n  Value *getVectorOperand() { return Op<0>(); }\n  Value *getIndexOperand() { return Op<1>(); }\n  const Value *getVectorOperand() const { return Op<0>(); }\n  const Value *getIndexOperand() const { return Op<1>(); }\n\n  VectorType *getVectorOperandType() const {\n    return cast<VectorType>(getVectorOperand()->getType());\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ExtractElement;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ExtractElementInst> :\n  public FixedNumOperandTraits<ExtractElementInst, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ExtractElementInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                InsertElementInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction inserts a single (scalar)\n/// element into a VectorType value\n///\nclass InsertElementInst : public Instruction {\n  InsertElementInst(Value *Vec, Value *NewElt, Value *Idx,\n                    const Twine &NameStr = \"\",\n                    Instruction *InsertBefore = nullptr);\n  InsertElementInst(Value *Vec, Value *NewElt, Value *Idx, const Twine &NameStr,\n                    BasicBlock *InsertAtEnd);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  InsertElementInst *cloneImpl() const;\n\npublic:\n  static InsertElementInst *Create(Value *Vec, Value *NewElt, Value *Idx,\n                                   const Twine &NameStr = \"\",\n                                   Instruction *InsertBefore = nullptr) {\n    return new(3) InsertElementInst(Vec, NewElt, Idx, NameStr, InsertBefore);\n  }\n\n  static InsertElementInst *Create(Value *Vec, Value *NewElt, Value *Idx,\n                                   const Twine &NameStr,\n                                   BasicBlock *InsertAtEnd) {\n    return new(3) InsertElementInst(Vec, NewElt, Idx, NameStr, InsertAtEnd);\n  }\n\n  /// Return true if an insertelement instruction can be\n  /// formed with the specified operands.\n  static bool isValidOperands(const Value *Vec, const Value *NewElt,\n                              const Value *Idx);\n\n  /// Overload to return most specific vector type.\n  ///\n  VectorType *getType() const {\n    return cast<VectorType>(Instruction::getType());\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::InsertElement;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<InsertElementInst> :\n  public FixedNumOperandTraits<InsertElementInst, 3> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(InsertElementInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                           ShuffleVectorInst Class\n//===----------------------------------------------------------------------===//\n\nconstexpr int UndefMaskElem = -1;\n\n/// This instruction constructs a fixed permutation of two\n/// input vectors.\n///\n/// For each element of the result vector, the shuffle mask selects an element\n/// from one of the input vectors to copy to the result. Non-negative elements\n/// in the mask represent an index into the concatenated pair of input vectors.\n/// UndefMaskElem (-1) specifies that the result element is undefined.\n///\n/// For scalable vectors, all the elements of the mask must be 0 or -1. This\n/// requirement may be relaxed in the future.\nclass ShuffleVectorInst : public Instruction {\n  SmallVector<int, 4> ShuffleMask;\n  Constant *ShuffleMaskForBitcode;\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ShuffleVectorInst *cloneImpl() const;\n\npublic:\n  ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,\n                    const Twine &NameStr = \"\",\n                    Instruction *InsertBefor = nullptr);\n  ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,\n                    const Twine &NameStr, BasicBlock *InsertAtEnd);\n  ShuffleVectorInst(Value *V1, Value *V2, ArrayRef<int> Mask,\n                    const Twine &NameStr = \"\",\n                    Instruction *InsertBefor = nullptr);\n  ShuffleVectorInst(Value *V1, Value *V2, ArrayRef<int> Mask,\n                    const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void *operator new(size_t s) { return User::operator new(s, 2); }\n\n  /// Swap the operands and adjust the mask to preserve the semantics\n  /// of the instruction.\n  void commute();\n\n  /// Return true if a shufflevector instruction can be\n  /// formed with the specified operands.\n  static bool isValidOperands(const Value *V1, const Value *V2,\n                              const Value *Mask);\n  static bool isValidOperands(const Value *V1, const Value *V2,\n                              ArrayRef<int> Mask);\n\n  /// Overload to return most specific vector type.\n  ///\n  VectorType *getType() const {\n    return cast<VectorType>(Instruction::getType());\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Return the shuffle mask value of this instruction for the given element\n  /// index. Return UndefMaskElem if the element is undef.\n  int getMaskValue(unsigned Elt) const { return ShuffleMask[Elt]; }\n\n  /// Convert the input shuffle mask operand to a vector of integers. Undefined\n  /// elements of the mask are returned as UndefMaskElem.\n  static void getShuffleMask(const Constant *Mask,\n                             SmallVectorImpl<int> &Result);\n\n  /// Return the mask for this instruction as a vector of integers. Undefined\n  /// elements of the mask are returned as UndefMaskElem.\n  void getShuffleMask(SmallVectorImpl<int> &Result) const {\n    Result.assign(ShuffleMask.begin(), ShuffleMask.end());\n  }\n\n  /// Return the mask for this instruction, for use in bitcode.\n  ///\n  /// TODO: This is temporary until we decide a new bitcode encoding for\n  /// shufflevector.\n  Constant *getShuffleMaskForBitcode() const { return ShuffleMaskForBitcode; }\n\n  static Constant *convertShuffleMaskForBitcode(ArrayRef<int> Mask,\n                                                Type *ResultTy);\n\n  void setShuffleMask(ArrayRef<int> Mask);\n\n  ArrayRef<int> getShuffleMask() const { return ShuffleMask; }\n\n  /// Return true if this shuffle returns a vector with a different number of\n  /// elements than its source vectors.\n  /// Examples: shufflevector <4 x n> A, <4 x n> B, <1,2,3>\n  ///           shufflevector <4 x n> A, <4 x n> B, <1,2,3,4,5>\n  bool changesLength() const {\n    unsigned NumSourceElts = cast<VectorType>(Op<0>()->getType())\n                                 ->getElementCount()\n                                 .getKnownMinValue();\n    unsigned NumMaskElts = ShuffleMask.size();\n    return NumSourceElts != NumMaskElts;\n  }\n\n  /// Return true if this shuffle returns a vector with a greater number of\n  /// elements than its source vectors.\n  /// Example: shufflevector <2 x n> A, <2 x n> B, <1,2,3>\n  bool increasesLength() const {\n    unsigned NumSourceElts = cast<VectorType>(Op<0>()->getType())\n                                 ->getElementCount()\n                                 .getKnownMinValue();\n    unsigned NumMaskElts = ShuffleMask.size();\n    return NumSourceElts < NumMaskElts;\n  }\n\n  /// Return true if this shuffle mask chooses elements from exactly one source\n  /// vector.\n  /// Example: <7,5,undef,7>\n  /// This assumes that vector operands are the same length as the mask.\n  static bool isSingleSourceMask(ArrayRef<int> Mask);\n  static bool isSingleSourceMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isSingleSourceMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle chooses elements from exactly one source\n  /// vector without changing the length of that vector.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <3,0,undef,3>\n  /// TODO: Optionally allow length-changing shuffles.\n  bool isSingleSource() const {\n    return !changesLength() && isSingleSourceMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask chooses elements from exactly one source\n  /// vector without lane crossings. A shuffle using this mask is not\n  /// necessarily a no-op because it may change the number of elements from its\n  /// input vectors or it may provide demanded bits knowledge via undef lanes.\n  /// Example: <undef,undef,2,3>\n  static bool isIdentityMask(ArrayRef<int> Mask);\n  static bool isIdentityMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isIdentityMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle chooses elements from exactly one source\n  /// vector without lane crossings and does not change the number of elements\n  /// from its input vectors.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <4,undef,6,undef>\n  bool isIdentity() const {\n    return !changesLength() && isIdentityMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle lengthens exactly one source vector with\n  /// undefs in the high elements.\n  bool isIdentityWithPadding() const;\n\n  /// Return true if this shuffle extracts the first N elements of exactly one\n  /// source vector.\n  bool isIdentityWithExtract() const;\n\n  /// Return true if this shuffle concatenates its 2 source vectors. This\n  /// returns false if either input is undefined. In that case, the shuffle is\n  /// is better classified as an identity with padding operation.\n  bool isConcat() const;\n\n  /// Return true if this shuffle mask chooses elements from its source vectors\n  /// without lane crossings. A shuffle using this mask would be\n  /// equivalent to a vector select with a constant condition operand.\n  /// Example: <4,1,6,undef>\n  /// This returns false if the mask does not choose from both input vectors.\n  /// In that case, the shuffle is better classified as an identity shuffle.\n  /// This assumes that vector operands are the same length as the mask\n  /// (a length-changing shuffle can never be equivalent to a vector select).\n  static bool isSelectMask(ArrayRef<int> Mask);\n  static bool isSelectMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isSelectMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle chooses elements from its source vectors\n  /// without lane crossings and all operands have the same number of elements.\n  /// In other words, this shuffle is equivalent to a vector select with a\n  /// constant condition operand.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <undef,1,6,3>\n  /// This returns false if the mask does not choose from both input vectors.\n  /// In that case, the shuffle is better classified as an identity shuffle.\n  /// TODO: Optionally allow length-changing shuffles.\n  bool isSelect() const {\n    return !changesLength() && isSelectMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask swaps the order of elements from exactly\n  /// one source vector.\n  /// Example: <7,6,undef,4>\n  /// This assumes that vector operands are the same length as the mask.\n  static bool isReverseMask(ArrayRef<int> Mask);\n  static bool isReverseMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isReverseMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle swaps the order of elements from exactly\n  /// one source vector.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <3,undef,1,undef>\n  /// TODO: Optionally allow length-changing shuffles.\n  bool isReverse() const {\n    return !changesLength() && isReverseMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask chooses all elements with the same value\n  /// as the first element of exactly one source vector.\n  /// Example: <4,undef,undef,4>\n  /// This assumes that vector operands are the same length as the mask.\n  static bool isZeroEltSplatMask(ArrayRef<int> Mask);\n  static bool isZeroEltSplatMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isZeroEltSplatMask(MaskAsInts);\n  }\n\n  /// Return true if all elements of this shuffle are the same value as the\n  /// first element of exactly one source vector without changing the length\n  /// of that vector.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <undef,0,undef,0>\n  /// TODO: Optionally allow length-changing shuffles.\n  /// TODO: Optionally allow splats from other elements.\n  bool isZeroEltSplat() const {\n    return !changesLength() && isZeroEltSplatMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask is a transpose mask.\n  /// Transpose vector masks transpose a 2xn matrix. They read corresponding\n  /// even- or odd-numbered vector elements from two n-dimensional source\n  /// vectors and write each result into consecutive elements of an\n  /// n-dimensional destination vector. Two shuffles are necessary to complete\n  /// the transpose, one for the even elements and another for the odd elements.\n  /// This description closely follows how the TRN1 and TRN2 AArch64\n  /// instructions operate.\n  ///\n  /// For example, a simple 2x2 matrix can be transposed with:\n  ///\n  ///   ; Original matrix\n  ///   m0 = < a, b >\n  ///   m1 = < c, d >\n  ///\n  ///   ; Transposed matrix\n  ///   t0 = < a, c > = shufflevector m0, m1, < 0, 2 >\n  ///   t1 = < b, d > = shufflevector m0, m1, < 1, 3 >\n  ///\n  /// For matrices having greater than n columns, the resulting nx2 transposed\n  /// matrix is stored in two result vectors such that one vector contains\n  /// interleaved elements from all the even-numbered rows and the other vector\n  /// contains interleaved elements from all the odd-numbered rows. For example,\n  /// a 2x4 matrix can be transposed with:\n  ///\n  ///   ; Original matrix\n  ///   m0 = < a, b, c, d >\n  ///   m1 = < e, f, g, h >\n  ///\n  ///   ; Transposed matrix\n  ///   t0 = < a, e, c, g > = shufflevector m0, m1 < 0, 4, 2, 6 >\n  ///   t1 = < b, f, d, h > = shufflevector m0, m1 < 1, 5, 3, 7 >\n  static bool isTransposeMask(ArrayRef<int> Mask);\n  static bool isTransposeMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isTransposeMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle transposes the elements of its inputs without\n  /// changing the length of the vectors. This operation may also be known as a\n  /// merge or interleave. See the description for isTransposeMask() for the\n  /// exact specification.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <0,4,2,6>\n  bool isTranspose() const {\n    return !changesLength() && isTransposeMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask is an extract subvector mask.\n  /// A valid extract subvector mask returns a smaller vector from a single\n  /// source operand. The base extraction index is returned as well.\n  static bool isExtractSubvectorMask(ArrayRef<int> Mask, int NumSrcElts,\n                                     int &Index);\n  static bool isExtractSubvectorMask(const Constant *Mask, int NumSrcElts,\n                                     int &Index) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    // Not possible to express a shuffle mask for a scalable vector for this\n    // case.\n    if (isa<ScalableVectorType>(Mask->getType()))\n      return false;\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isExtractSubvectorMask(MaskAsInts, NumSrcElts, Index);\n  }\n\n  /// Return true if this shuffle mask is an extract subvector mask.\n  bool isExtractSubvectorMask(int &Index) const {\n    // Not possible to express a shuffle mask for a scalable vector for this\n    // case.\n    if (isa<ScalableVectorType>(getType()))\n      return false;\n\n    int NumSrcElts =\n        cast<FixedVectorType>(Op<0>()->getType())->getNumElements();\n    return isExtractSubvectorMask(ShuffleMask, NumSrcElts, Index);\n  }\n\n  /// Change values in a shuffle permute mask assuming the two vector operands\n  /// of length InVecNumElts have swapped position.\n  static void commuteShuffleMask(MutableArrayRef<int> Mask,\n                                 unsigned InVecNumElts) {\n    for (int &Idx : Mask) {\n      if (Idx == -1)\n        continue;\n      Idx = Idx < (int)InVecNumElts ? Idx + InVecNumElts : Idx - InVecNumElts;\n      assert(Idx >= 0 && Idx < (int)InVecNumElts * 2 &&\n             \"shufflevector mask index out of range\");\n    }\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ShuffleVector;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ShuffleVectorInst>\n    : public FixedNumOperandTraits<ShuffleVectorInst, 2> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ShuffleVectorInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                ExtractValueInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction extracts a struct member or array\n/// element value from an aggregate value.\n///\nclass ExtractValueInst : public UnaryInstruction {\n  SmallVector<unsigned, 4> Indices;\n\n  ExtractValueInst(const ExtractValueInst &EVI);\n\n  /// Constructors - Create a extractvalue instruction with a base aggregate\n  /// value and a list of indices.  The first ctor can optionally insert before\n  /// an existing instruction, the second appends the new instruction to the\n  /// specified BasicBlock.\n  inline ExtractValueInst(Value *Agg,\n                          ArrayRef<unsigned> Idxs,\n                          const Twine &NameStr,\n                          Instruction *InsertBefore);\n  inline ExtractValueInst(Value *Agg,\n                          ArrayRef<unsigned> Idxs,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(ArrayRef<unsigned> Idxs, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ExtractValueInst *cloneImpl() const;\n\npublic:\n  static ExtractValueInst *Create(Value *Agg,\n                                  ArrayRef<unsigned> Idxs,\n                                  const Twine &NameStr = \"\",\n                                  Instruction *InsertBefore = nullptr) {\n    return new\n      ExtractValueInst(Agg, Idxs, NameStr, InsertBefore);\n  }\n\n  static ExtractValueInst *Create(Value *Agg,\n                                  ArrayRef<unsigned> Idxs,\n                                  const Twine &NameStr,\n                                  BasicBlock *InsertAtEnd) {\n    return new ExtractValueInst(Agg, Idxs, NameStr, InsertAtEnd);\n  }\n\n  /// Returns the type of the element that would be extracted\n  /// with an extractvalue instruction with the specified parameters.\n  ///\n  /// Null is returned if the indices are invalid for the specified type.\n  static Type *getIndexedType(Type *Agg, ArrayRef<unsigned> Idxs);\n\n  using idx_iterator = const unsigned*;\n\n  inline idx_iterator idx_begin() const { return Indices.begin(); }\n  inline idx_iterator idx_end()   const { return Indices.end(); }\n  inline iterator_range<idx_iterator> indices() const {\n    return make_range(idx_begin(), idx_end());\n  }\n\n  Value *getAggregateOperand() {\n    return getOperand(0);\n  }\n  const Value *getAggregateOperand() const {\n    return getOperand(0);\n  }\n  static unsigned getAggregateOperandIndex() {\n    return 0U;                      // get index for modifying correct operand\n  }\n\n  ArrayRef<unsigned> getIndices() const {\n    return Indices;\n  }\n\n  unsigned getNumIndices() const {\n    return (unsigned)Indices.size();\n  }\n\n  bool hasIndices() const {\n    return true;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ExtractValue;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\nExtractValueInst::ExtractValueInst(Value *Agg,\n                                   ArrayRef<unsigned> Idxs,\n                                   const Twine &NameStr,\n                                   Instruction *InsertBefore)\n  : UnaryInstruction(checkGEPType(getIndexedType(Agg->getType(), Idxs)),\n                     ExtractValue, Agg, InsertBefore) {\n  init(Idxs, NameStr);\n}\n\nExtractValueInst::ExtractValueInst(Value *Agg,\n                                   ArrayRef<unsigned> Idxs,\n                                   const Twine &NameStr,\n                                   BasicBlock *InsertAtEnd)\n  : UnaryInstruction(checkGEPType(getIndexedType(Agg->getType(), Idxs)),\n                     ExtractValue, Agg, InsertAtEnd) {\n  init(Idxs, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                                InsertValueInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction inserts a struct field of array element\n/// value into an aggregate value.\n///\nclass InsertValueInst : public Instruction {\n  SmallVector<unsigned, 4> Indices;\n\n  InsertValueInst(const InsertValueInst &IVI);\n\n  /// Constructors - Create a insertvalue instruction with a base aggregate\n  /// value, a value to insert, and a list of indices.  The first ctor can\n  /// optionally insert before an existing instruction, the second appends\n  /// the new instruction to the specified BasicBlock.\n  inline InsertValueInst(Value *Agg, Value *Val,\n                         ArrayRef<unsigned> Idxs,\n                         const Twine &NameStr,\n                         Instruction *InsertBefore);\n  inline InsertValueInst(Value *Agg, Value *Val,\n                         ArrayRef<unsigned> Idxs,\n                         const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  /// Constructors - These two constructors are convenience methods because one\n  /// and two index insertvalue instructions are so common.\n  InsertValueInst(Value *Agg, Value *Val, unsigned Idx,\n                  const Twine &NameStr = \"\",\n                  Instruction *InsertBefore = nullptr);\n  InsertValueInst(Value *Agg, Value *Val, unsigned Idx, const Twine &NameStr,\n                  BasicBlock *InsertAtEnd);\n\n  void init(Value *Agg, Value *Val, ArrayRef<unsigned> Idxs,\n            const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  InsertValueInst *cloneImpl() const;\n\npublic:\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  static InsertValueInst *Create(Value *Agg, Value *Val,\n                                 ArrayRef<unsigned> Idxs,\n                                 const Twine &NameStr = \"\",\n                                 Instruction *InsertBefore = nullptr) {\n    return new InsertValueInst(Agg, Val, Idxs, NameStr, InsertBefore);\n  }\n\n  static InsertValueInst *Create(Value *Agg, Value *Val,\n                                 ArrayRef<unsigned> Idxs,\n                                 const Twine &NameStr,\n                                 BasicBlock *InsertAtEnd) {\n    return new InsertValueInst(Agg, Val, Idxs, NameStr, InsertAtEnd);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  using idx_iterator = const unsigned*;\n\n  inline idx_iterator idx_begin() const { return Indices.begin(); }\n  inline idx_iterator idx_end()   const { return Indices.end(); }\n  inline iterator_range<idx_iterator> indices() const {\n    return make_range(idx_begin(), idx_end());\n  }\n\n  Value *getAggregateOperand() {\n    return getOperand(0);\n  }\n  const Value *getAggregateOperand() const {\n    return getOperand(0);\n  }\n  static unsigned getAggregateOperandIndex() {\n    return 0U;                      // get index for modifying correct operand\n  }\n\n  Value *getInsertedValueOperand() {\n    return getOperand(1);\n  }\n  const Value *getInsertedValueOperand() const {\n    return getOperand(1);\n  }\n  static unsigned getInsertedValueOperandIndex() {\n    return 1U;                      // get index for modifying correct operand\n  }\n\n  ArrayRef<unsigned> getIndices() const {\n    return Indices;\n  }\n\n  unsigned getNumIndices() const {\n    return (unsigned)Indices.size();\n  }\n\n  bool hasIndices() const {\n    return true;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::InsertValue;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<InsertValueInst> :\n  public FixedNumOperandTraits<InsertValueInst, 2> {\n};\n\nInsertValueInst::InsertValueInst(Value *Agg,\n                                 Value *Val,\n                                 ArrayRef<unsigned> Idxs,\n                                 const Twine &NameStr,\n                                 Instruction *InsertBefore)\n  : Instruction(Agg->getType(), InsertValue,\n                OperandTraits<InsertValueInst>::op_begin(this),\n                2, InsertBefore) {\n  init(Agg, Val, Idxs, NameStr);\n}\n\nInsertValueInst::InsertValueInst(Value *Agg,\n                                 Value *Val,\n                                 ArrayRef<unsigned> Idxs,\n                                 const Twine &NameStr,\n                                 BasicBlock *InsertAtEnd)\n  : Instruction(Agg->getType(), InsertValue,\n                OperandTraits<InsertValueInst>::op_begin(this),\n                2, InsertAtEnd) {\n  init(Agg, Val, Idxs, NameStr);\n}\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(InsertValueInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               PHINode Class\n//===----------------------------------------------------------------------===//\n\n// PHINode - The PHINode class is used to represent the magical mystical PHI\n// node, that can not exist in nature, but can be synthesized in a computer\n// scientist's overactive imagination.\n//\nclass PHINode : public Instruction {\n  /// The number of operands actually allocated.  NumOperands is\n  /// the number actually in use.\n  unsigned ReservedSpace;\n\n  PHINode(const PHINode &PN);\n\n  explicit PHINode(Type *Ty, unsigned NumReservedValues,\n                   const Twine &NameStr = \"\",\n                   Instruction *InsertBefore = nullptr)\n    : Instruction(Ty, Instruction::PHI, nullptr, 0, InsertBefore),\n      ReservedSpace(NumReservedValues) {\n    setName(NameStr);\n    allocHungoffUses(ReservedSpace);\n  }\n\n  PHINode(Type *Ty, unsigned NumReservedValues, const Twine &NameStr,\n          BasicBlock *InsertAtEnd)\n    : Instruction(Ty, Instruction::PHI, nullptr, 0, InsertAtEnd),\n      ReservedSpace(NumReservedValues) {\n    setName(NameStr);\n    allocHungoffUses(ReservedSpace);\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  PHINode *cloneImpl() const;\n\n  // allocHungoffUses - this is more complicated than the generic\n  // User::allocHungoffUses, because we have to allocate Uses for the incoming\n  // values and pointers to the incoming blocks, all in one allocation.\n  void allocHungoffUses(unsigned N) {\n    User::allocHungoffUses(N, /* IsPhi */ true);\n  }\n\npublic:\n  /// Constructors - NumReservedValues is a hint for the number of incoming\n  /// edges that this phi node will have (use 0 if you really have no idea).\n  static PHINode *Create(Type *Ty, unsigned NumReservedValues,\n                         const Twine &NameStr = \"\",\n                         Instruction *InsertBefore = nullptr) {\n    return new PHINode(Ty, NumReservedValues, NameStr, InsertBefore);\n  }\n\n  static PHINode *Create(Type *Ty, unsigned NumReservedValues,\n                         const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return new PHINode(Ty, NumReservedValues, NameStr, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Block iterator interface. This provides access to the list of incoming\n  // basic blocks, which parallels the list of incoming values.\n\n  using block_iterator = BasicBlock **;\n  using const_block_iterator = BasicBlock * const *;\n\n  block_iterator block_begin() {\n    return reinterpret_cast<block_iterator>(op_begin() + ReservedSpace);\n  }\n\n  const_block_iterator block_begin() const {\n    return reinterpret_cast<const_block_iterator>(op_begin() + ReservedSpace);\n  }\n\n  block_iterator block_end() {\n    return block_begin() + getNumOperands();\n  }\n\n  const_block_iterator block_end() const {\n    return block_begin() + getNumOperands();\n  }\n\n  iterator_range<block_iterator> blocks() {\n    return make_range(block_begin(), block_end());\n  }\n\n  iterator_range<const_block_iterator> blocks() const {\n    return make_range(block_begin(), block_end());\n  }\n\n  op_range incoming_values() { return operands(); }\n\n  const_op_range incoming_values() const { return operands(); }\n\n  /// Return the number of incoming edges\n  ///\n  unsigned getNumIncomingValues() const { return getNumOperands(); }\n\n  /// Return incoming value number x\n  ///\n  Value *getIncomingValue(unsigned i) const {\n    return getOperand(i);\n  }\n  void setIncomingValue(unsigned i, Value *V) {\n    assert(V && \"PHI node got a null value!\");\n    assert(getType() == V->getType() &&\n           \"All operands to PHI node must be the same type as the PHI node!\");\n    setOperand(i, V);\n  }\n\n  static unsigned getOperandNumForIncomingValue(unsigned i) {\n    return i;\n  }\n\n  static unsigned getIncomingValueNumForOperand(unsigned i) {\n    return i;\n  }\n\n  /// Return incoming basic block number @p i.\n  ///\n  BasicBlock *getIncomingBlock(unsigned i) const {\n    return block_begin()[i];\n  }\n\n  /// Return incoming basic block corresponding\n  /// to an operand of the PHI.\n  ///\n  BasicBlock *getIncomingBlock(const Use &U) const {\n    assert(this == U.getUser() && \"Iterator doesn't point to PHI's Uses?\");\n    return getIncomingBlock(unsigned(&U - op_begin()));\n  }\n\n  /// Return incoming basic block corresponding\n  /// to value use iterator.\n  ///\n  BasicBlock *getIncomingBlock(Value::const_user_iterator I) const {\n    return getIncomingBlock(I.getUse());\n  }\n\n  void setIncomingBlock(unsigned i, BasicBlock *BB) {\n    assert(BB && \"PHI node got a null basic block!\");\n    block_begin()[i] = BB;\n  }\n\n  /// Replace every incoming basic block \\p Old to basic block \\p New.\n  void replaceIncomingBlockWith(const BasicBlock *Old, BasicBlock *New) {\n    assert(New && Old && \"PHI node got a null basic block!\");\n    for (unsigned Op = 0, NumOps = getNumOperands(); Op != NumOps; ++Op)\n      if (getIncomingBlock(Op) == Old)\n        setIncomingBlock(Op, New);\n  }\n\n  /// Add an incoming value to the end of the PHI list\n  ///\n  void addIncoming(Value *V, BasicBlock *BB) {\n    if (getNumOperands() == ReservedSpace)\n      growOperands();  // Get more space!\n    // Initialize some new operands.\n    setNumHungOffUseOperands(getNumOperands() + 1);\n    setIncomingValue(getNumOperands() - 1, V);\n    setIncomingBlock(getNumOperands() - 1, BB);\n  }\n\n  /// Remove an incoming value.  This is useful if a\n  /// predecessor basic block is deleted.  The value removed is returned.\n  ///\n  /// If the last incoming value for a PHI node is removed (and DeletePHIIfEmpty\n  /// is true), the PHI node is destroyed and any uses of it are replaced with\n  /// dummy values.  The only time there should be zero incoming values to a PHI\n  /// node is when the block is dead, so this strategy is sound.\n  ///\n  Value *removeIncomingValue(unsigned Idx, bool DeletePHIIfEmpty = true);\n\n  Value *removeIncomingValue(const BasicBlock *BB, bool DeletePHIIfEmpty=true) {\n    int Idx = getBasicBlockIndex(BB);\n    assert(Idx >= 0 && \"Invalid basic block argument to remove!\");\n    return removeIncomingValue(Idx, DeletePHIIfEmpty);\n  }\n\n  /// Return the first index of the specified basic\n  /// block in the value list for this PHI.  Returns -1 if no instance.\n  ///\n  int getBasicBlockIndex(const BasicBlock *BB) const {\n    for (unsigned i = 0, e = getNumOperands(); i != e; ++i)\n      if (block_begin()[i] == BB)\n        return i;\n    return -1;\n  }\n\n  Value *getIncomingValueForBlock(const BasicBlock *BB) const {\n    int Idx = getBasicBlockIndex(BB);\n    assert(Idx >= 0 && \"Invalid basic block argument!\");\n    return getIncomingValue(Idx);\n  }\n\n  /// Set every incoming value(s) for block \\p BB to \\p V.\n  void setIncomingValueForBlock(const BasicBlock *BB, Value *V) {\n    assert(BB && \"PHI node got a null basic block!\");\n    bool Found = false;\n    for (unsigned Op = 0, NumOps = getNumOperands(); Op != NumOps; ++Op)\n      if (getIncomingBlock(Op) == BB) {\n        Found = true;\n        setIncomingValue(Op, V);\n      }\n    (void)Found;\n    assert(Found && \"Invalid basic block argument to set!\");\n  }\n\n  /// If the specified PHI node always merges together the\n  /// same value, return the value, otherwise return null.\n  Value *hasConstantValue() const;\n\n  /// Whether the specified PHI node always merges\n  /// together the same value, assuming undefs are equal to a unique\n  /// non-undef value.\n  bool hasConstantOrUndefValue() const;\n\n  /// If the PHI node is complete which means all of its parent's predecessors\n  /// have incoming value in this PHI, return true, otherwise return false.\n  bool isComplete() const {\n    return llvm::all_of(predecessors(getParent()),\n                        [this](const BasicBlock *Pred) {\n                          return getBasicBlockIndex(Pred) >= 0;\n                        });\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::PHI;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  void growOperands();\n};\n\ntemplate <>\nstruct OperandTraits<PHINode> : public HungoffOperandTraits<2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(PHINode, Value)\n\n//===----------------------------------------------------------------------===//\n//                           LandingPadInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// The landingpad instruction holds all of the information\n/// necessary to generate correct exception handling. The landingpad instruction\n/// cannot be moved from the top of a landing pad block, which itself is\n/// accessible only from the 'unwind' edge of an invoke. This uses the\n/// SubclassData field in Value to store whether or not the landingpad is a\n/// cleanup.\n///\nclass LandingPadInst : public Instruction {\n  using CleanupField = BoolBitfieldElementT<0>;\n\n  /// The number of operands actually allocated.  NumOperands is\n  /// the number actually in use.\n  unsigned ReservedSpace;\n\n  LandingPadInst(const LandingPadInst &LP);\n\npublic:\n  enum ClauseType { Catch, Filter };\n\nprivate:\n  explicit LandingPadInst(Type *RetTy, unsigned NumReservedValues,\n                          const Twine &NameStr, Instruction *InsertBefore);\n  explicit LandingPadInst(Type *RetTy, unsigned NumReservedValues,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  // Allocate space for exactly zero operands.\n  void *operator new(size_t s) {\n    return User::operator new(s);\n  }\n\n  void growOperands(unsigned Size);\n  void init(unsigned NumReservedValues, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  LandingPadInst *cloneImpl() const;\n\npublic:\n  /// Constructors - NumReservedClauses is a hint for the number of incoming\n  /// clauses that this landingpad will have (use 0 if you really have no idea).\n  static LandingPadInst *Create(Type *RetTy, unsigned NumReservedClauses,\n                                const Twine &NameStr = \"\",\n                                Instruction *InsertBefore = nullptr);\n  static LandingPadInst *Create(Type *RetTy, unsigned NumReservedClauses,\n                                const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Return 'true' if this landingpad instruction is a\n  /// cleanup. I.e., it should be run when unwinding even if its landing pad\n  /// doesn't catch the exception.\n  bool isCleanup() const { return getSubclassData<CleanupField>(); }\n\n  /// Indicate that this landingpad instruction is a cleanup.\n  void setCleanup(bool V) { setSubclassData<CleanupField>(V); }\n\n  /// Add a catch or filter clause to the landing pad.\n  void addClause(Constant *ClauseVal);\n\n  /// Get the value of the clause at index Idx. Use isCatch/isFilter to\n  /// determine what type of clause this is.\n  Constant *getClause(unsigned Idx) const {\n    return cast<Constant>(getOperandList()[Idx]);\n  }\n\n  /// Return 'true' if the clause and index Idx is a catch clause.\n  bool isCatch(unsigned Idx) const {\n    return !isa<ArrayType>(getOperandList()[Idx]->getType());\n  }\n\n  /// Return 'true' if the clause and index Idx is a filter clause.\n  bool isFilter(unsigned Idx) const {\n    return isa<ArrayType>(getOperandList()[Idx]->getType());\n  }\n\n  /// Get the number of clauses for this landing pad.\n  unsigned getNumClauses() const { return getNumOperands(); }\n\n  /// Grow the size of the operand list to accommodate the new\n  /// number of clauses.\n  void reserveClauses(unsigned Size) { growOperands(Size); }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::LandingPad;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<LandingPadInst> : public HungoffOperandTraits<1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(LandingPadInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               ReturnInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Return a value (possibly void), from a function.  Execution\n/// does not continue in this function any longer.\n///\nclass ReturnInst : public Instruction {\n  ReturnInst(const ReturnInst &RI);\n\nprivate:\n  // ReturnInst constructors:\n  // ReturnInst()                  - 'ret void' instruction\n  // ReturnInst(    null)          - 'ret void' instruction\n  // ReturnInst(Value* X)          - 'ret X'    instruction\n  // ReturnInst(    null, Inst *I) - 'ret void' instruction, insert before I\n  // ReturnInst(Value* X, Inst *I) - 'ret X'    instruction, insert before I\n  // ReturnInst(    null, BB *B)   - 'ret void' instruction, insert @ end of B\n  // ReturnInst(Value* X, BB *B)   - 'ret X'    instruction, insert @ end of B\n  //\n  // NOTE: If the Value* passed is of type void then the constructor behaves as\n  // if it was passed NULL.\n  explicit ReturnInst(LLVMContext &C, Value *retVal = nullptr,\n                      Instruction *InsertBefore = nullptr);\n  ReturnInst(LLVMContext &C, Value *retVal, BasicBlock *InsertAtEnd);\n  explicit ReturnInst(LLVMContext &C, BasicBlock *InsertAtEnd);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ReturnInst *cloneImpl() const;\n\npublic:\n  static ReturnInst* Create(LLVMContext &C, Value *retVal = nullptr,\n                            Instruction *InsertBefore = nullptr) {\n    return new(!!retVal) ReturnInst(C, retVal, InsertBefore);\n  }\n\n  static ReturnInst* Create(LLVMContext &C, Value *retVal,\n                            BasicBlock *InsertAtEnd) {\n    return new(!!retVal) ReturnInst(C, retVal, InsertAtEnd);\n  }\n\n  static ReturnInst* Create(LLVMContext &C, BasicBlock *InsertAtEnd) {\n    return new(0) ReturnInst(C, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Convenience accessor. Returns null if there is no return value.\n  Value *getReturnValue() const {\n    return getNumOperands() != 0 ? getOperand(0) : nullptr;\n  }\n\n  unsigned getNumSuccessors() const { return 0; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::Ret);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned idx) const {\n    llvm_unreachable(\"ReturnInst has no successors!\");\n  }\n\n  void setSuccessor(unsigned idx, BasicBlock *B) {\n    llvm_unreachable(\"ReturnInst has no successors!\");\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ReturnInst> : public VariadicOperandTraits<ReturnInst> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ReturnInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               BranchInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Conditional or Unconditional Branch instruction.\n///\nclass BranchInst : public Instruction {\n  /// Ops list - Branches are strange.  The operands are ordered:\n  ///  [Cond, FalseDest,] TrueDest.  This makes some accessors faster because\n  /// they don't have to check for cond/uncond branchness. These are mostly\n  /// accessed relative from op_end().\n  BranchInst(const BranchInst &BI);\n  // BranchInst constructors (where {B, T, F} are blocks, and C is a condition):\n  // BranchInst(BB *B)                           - 'br B'\n  // BranchInst(BB* T, BB *F, Value *C)          - 'br C, T, F'\n  // BranchInst(BB* B, Inst *I)                  - 'br B'        insert before I\n  // BranchInst(BB* T, BB *F, Value *C, Inst *I) - 'br C, T, F', insert before I\n  // BranchInst(BB* B, BB *I)                    - 'br B'        insert at end\n  // BranchInst(BB* T, BB *F, Value *C, BB *I)   - 'br C, T, F', insert at end\n  explicit BranchInst(BasicBlock *IfTrue, Instruction *InsertBefore = nullptr);\n  BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,\n             Instruction *InsertBefore = nullptr);\n  BranchInst(BasicBlock *IfTrue, BasicBlock *InsertAtEnd);\n  BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,\n             BasicBlock *InsertAtEnd);\n\n  void AssertOK();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  BranchInst *cloneImpl() const;\n\npublic:\n  /// Iterator type that casts an operand to a basic block.\n  ///\n  /// This only makes sense because the successors are stored as adjacent\n  /// operands for branch instructions.\n  struct succ_op_iterator\n      : iterator_adaptor_base<succ_op_iterator, value_op_iterator,\n                              std::random_access_iterator_tag, BasicBlock *,\n                              ptrdiff_t, BasicBlock *, BasicBlock *> {\n    explicit succ_op_iterator(value_op_iterator I) : iterator_adaptor_base(I) {}\n\n    BasicBlock *operator*() const { return cast<BasicBlock>(*I); }\n    BasicBlock *operator->() const { return operator*(); }\n  };\n\n  /// The const version of `succ_op_iterator`.\n  struct const_succ_op_iterator\n      : iterator_adaptor_base<const_succ_op_iterator, const_value_op_iterator,\n                              std::random_access_iterator_tag,\n                              const BasicBlock *, ptrdiff_t, const BasicBlock *,\n                              const BasicBlock *> {\n    explicit const_succ_op_iterator(const_value_op_iterator I)\n        : iterator_adaptor_base(I) {}\n\n    const BasicBlock *operator*() const { return cast<BasicBlock>(*I); }\n    const BasicBlock *operator->() const { return operator*(); }\n  };\n\n  static BranchInst *Create(BasicBlock *IfTrue,\n                            Instruction *InsertBefore = nullptr) {\n    return new(1) BranchInst(IfTrue, InsertBefore);\n  }\n\n  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *IfFalse,\n                            Value *Cond, Instruction *InsertBefore = nullptr) {\n    return new(3) BranchInst(IfTrue, IfFalse, Cond, InsertBefore);\n  }\n\n  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *InsertAtEnd) {\n    return new(1) BranchInst(IfTrue, InsertAtEnd);\n  }\n\n  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *IfFalse,\n                            Value *Cond, BasicBlock *InsertAtEnd) {\n    return new(3) BranchInst(IfTrue, IfFalse, Cond, InsertAtEnd);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  bool isUnconditional() const { return getNumOperands() == 1; }\n  bool isConditional()   const { return getNumOperands() == 3; }\n\n  Value *getCondition() const {\n    assert(isConditional() && \"Cannot get condition of an uncond branch!\");\n    return Op<-3>();\n  }\n\n  void setCondition(Value *V) {\n    assert(isConditional() && \"Cannot set condition of unconditional branch!\");\n    Op<-3>() = V;\n  }\n\n  unsigned getNumSuccessors() const { return 1+isConditional(); }\n\n  BasicBlock *getSuccessor(unsigned i) const {\n    assert(i < getNumSuccessors() && \"Successor # out of range for Branch!\");\n    return cast_or_null<BasicBlock>((&Op<-1>() - i)->get());\n  }\n\n  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {\n    assert(idx < getNumSuccessors() && \"Successor # out of range for Branch!\");\n    *(&Op<-1>() - idx) = NewSucc;\n  }\n\n  /// Swap the successors of this branch instruction.\n  ///\n  /// Swaps the successors of the branch instruction. This also swaps any\n  /// branch weight metadata associated with the instruction so that it\n  /// continues to map correctly to each operand.\n  void swapSuccessors();\n\n  iterator_range<succ_op_iterator> successors() {\n    return make_range(\n        succ_op_iterator(std::next(value_op_begin(), isConditional() ? 1 : 0)),\n        succ_op_iterator(value_op_end()));\n  }\n\n  iterator_range<const_succ_op_iterator> successors() const {\n    return make_range(const_succ_op_iterator(\n                          std::next(value_op_begin(), isConditional() ? 1 : 0)),\n                      const_succ_op_iterator(value_op_end()));\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::Br);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<BranchInst> : public VariadicOperandTraits<BranchInst, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(BranchInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               SwitchInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Multiway switch\n///\nclass SwitchInst : public Instruction {\n  unsigned ReservedSpace;\n\n  // Operand[0]    = Value to switch on\n  // Operand[1]    = Default basic block destination\n  // Operand[2n  ] = Value to match\n  // Operand[2n+1] = BasicBlock to go to on match\n  SwitchInst(const SwitchInst &SI);\n\n  /// Create a new switch instruction, specifying a value to switch on and a\n  /// default destination. The number of additional cases can be specified here\n  /// to make memory allocation more efficient. This constructor can also\n  /// auto-insert before another instruction.\n  SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,\n             Instruction *InsertBefore);\n\n  /// Create a new switch instruction, specifying a value to switch on and a\n  /// default destination. The number of additional cases can be specified here\n  /// to make memory allocation more efficient. This constructor also\n  /// auto-inserts at the end of the specified BasicBlock.\n  SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,\n             BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) {\n    return User::operator new(s);\n  }\n\n  void init(Value *Value, BasicBlock *Default, unsigned NumReserved);\n  void growOperands();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  SwitchInst *cloneImpl() const;\n\npublic:\n  // -2\n  static const unsigned DefaultPseudoIndex = static_cast<unsigned>(~0L-1);\n\n  template <typename CaseHandleT> class CaseIteratorImpl;\n\n  /// A handle to a particular switch case. It exposes a convenient interface\n  /// to both the case value and the successor block.\n  ///\n  /// We define this as a template and instantiate it to form both a const and\n  /// non-const handle.\n  template <typename SwitchInstT, typename ConstantIntT, typename BasicBlockT>\n  class CaseHandleImpl {\n    // Directly befriend both const and non-const iterators.\n    friend class SwitchInst::CaseIteratorImpl<\n        CaseHandleImpl<SwitchInstT, ConstantIntT, BasicBlockT>>;\n\n  protected:\n    // Expose the switch type we're parameterized with to the iterator.\n    using SwitchInstType = SwitchInstT;\n\n    SwitchInstT *SI;\n    ptrdiff_t Index;\n\n    CaseHandleImpl() = default;\n    CaseHandleImpl(SwitchInstT *SI, ptrdiff_t Index) : SI(SI), Index(Index) {}\n\n  public:\n    /// Resolves case value for current case.\n    ConstantIntT *getCaseValue() const {\n      assert((unsigned)Index < SI->getNumCases() &&\n             \"Index out the number of cases.\");\n      return reinterpret_cast<ConstantIntT *>(SI->getOperand(2 + Index * 2));\n    }\n\n    /// Resolves successor for current case.\n    BasicBlockT *getCaseSuccessor() const {\n      assert(((unsigned)Index < SI->getNumCases() ||\n              (unsigned)Index == DefaultPseudoIndex) &&\n             \"Index out the number of cases.\");\n      return SI->getSuccessor(getSuccessorIndex());\n    }\n\n    /// Returns number of current case.\n    unsigned getCaseIndex() const { return Index; }\n\n    /// Returns successor index for current case successor.\n    unsigned getSuccessorIndex() const {\n      assert(((unsigned)Index == DefaultPseudoIndex ||\n              (unsigned)Index < SI->getNumCases()) &&\n             \"Index out the number of cases.\");\n      return (unsigned)Index != DefaultPseudoIndex ? Index + 1 : 0;\n    }\n\n    bool operator==(const CaseHandleImpl &RHS) const {\n      assert(SI == RHS.SI && \"Incompatible operators.\");\n      return Index == RHS.Index;\n    }\n  };\n\n  using ConstCaseHandle =\n      CaseHandleImpl<const SwitchInst, const ConstantInt, const BasicBlock>;\n\n  class CaseHandle\n      : public CaseHandleImpl<SwitchInst, ConstantInt, BasicBlock> {\n    friend class SwitchInst::CaseIteratorImpl<CaseHandle>;\n\n  public:\n    CaseHandle(SwitchInst *SI, ptrdiff_t Index) : CaseHandleImpl(SI, Index) {}\n\n    /// Sets the new value for current case.\n    void setValue(ConstantInt *V) {\n      assert((unsigned)Index < SI->getNumCases() &&\n             \"Index out the number of cases.\");\n      SI->setOperand(2 + Index*2, reinterpret_cast<Value*>(V));\n    }\n\n    /// Sets the new successor for current case.\n    void setSuccessor(BasicBlock *S) {\n      SI->setSuccessor(getSuccessorIndex(), S);\n    }\n  };\n\n  template <typename CaseHandleT>\n  class CaseIteratorImpl\n      : public iterator_facade_base<CaseIteratorImpl<CaseHandleT>,\n                                    std::random_access_iterator_tag,\n                                    CaseHandleT> {\n    using SwitchInstT = typename CaseHandleT::SwitchInstType;\n\n    CaseHandleT Case;\n\n  public:\n    /// Default constructed iterator is in an invalid state until assigned to\n    /// a case for a particular switch.\n    CaseIteratorImpl() = default;\n\n    /// Initializes case iterator for given SwitchInst and for given\n    /// case number.\n    CaseIteratorImpl(SwitchInstT *SI, unsigned CaseNum) : Case(SI, CaseNum) {}\n\n    /// Initializes case iterator for given SwitchInst and for given\n    /// successor index.\n    static CaseIteratorImpl fromSuccessorIndex(SwitchInstT *SI,\n                                               unsigned SuccessorIndex) {\n      assert(SuccessorIndex < SI->getNumSuccessors() &&\n             \"Successor index # out of range!\");\n      return SuccessorIndex != 0 ? CaseIteratorImpl(SI, SuccessorIndex - 1)\n                                 : CaseIteratorImpl(SI, DefaultPseudoIndex);\n    }\n\n    /// Support converting to the const variant. This will be a no-op for const\n    /// variant.\n    operator CaseIteratorImpl<ConstCaseHandle>() const {\n      return CaseIteratorImpl<ConstCaseHandle>(Case.SI, Case.Index);\n    }\n\n    CaseIteratorImpl &operator+=(ptrdiff_t N) {\n      // Check index correctness after addition.\n      // Note: Index == getNumCases() means end().\n      assert(Case.Index + N >= 0 &&\n             (unsigned)(Case.Index + N) <= Case.SI->getNumCases() &&\n             \"Case.Index out the number of cases.\");\n      Case.Index += N;\n      return *this;\n    }\n    CaseIteratorImpl &operator-=(ptrdiff_t N) {\n      // Check index correctness after subtraction.\n      // Note: Case.Index == getNumCases() means end().\n      assert(Case.Index - N >= 0 &&\n             (unsigned)(Case.Index - N) <= Case.SI->getNumCases() &&\n             \"Case.Index out the number of cases.\");\n      Case.Index -= N;\n      return *this;\n    }\n    ptrdiff_t operator-(const CaseIteratorImpl &RHS) const {\n      assert(Case.SI == RHS.Case.SI && \"Incompatible operators.\");\n      return Case.Index - RHS.Case.Index;\n    }\n    bool operator==(const CaseIteratorImpl &RHS) const {\n      return Case == RHS.Case;\n    }\n    bool operator<(const CaseIteratorImpl &RHS) const {\n      assert(Case.SI == RHS.Case.SI && \"Incompatible operators.\");\n      return Case.Index < RHS.Case.Index;\n    }\n    CaseHandleT &operator*() { return Case; }\n    const CaseHandleT &operator*() const { return Case; }\n  };\n\n  using CaseIt = CaseIteratorImpl<CaseHandle>;\n  using ConstCaseIt = CaseIteratorImpl<ConstCaseHandle>;\n\n  static SwitchInst *Create(Value *Value, BasicBlock *Default,\n                            unsigned NumCases,\n                            Instruction *InsertBefore = nullptr) {\n    return new SwitchInst(Value, Default, NumCases, InsertBefore);\n  }\n\n  static SwitchInst *Create(Value *Value, BasicBlock *Default,\n                            unsigned NumCases, BasicBlock *InsertAtEnd) {\n    return new SwitchInst(Value, Default, NumCases, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Accessor Methods for Switch stmt\n  Value *getCondition() const { return getOperand(0); }\n  void setCondition(Value *V) { setOperand(0, V); }\n\n  BasicBlock *getDefaultDest() const {\n    return cast<BasicBlock>(getOperand(1));\n  }\n\n  void setDefaultDest(BasicBlock *DefaultCase) {\n    setOperand(1, reinterpret_cast<Value*>(DefaultCase));\n  }\n\n  /// Return the number of 'cases' in this switch instruction, excluding the\n  /// default case.\n  unsigned getNumCases() const {\n    return getNumOperands()/2 - 1;\n  }\n\n  /// Returns a read/write iterator that points to the first case in the\n  /// SwitchInst.\n  CaseIt case_begin() {\n    return CaseIt(this, 0);\n  }\n\n  /// Returns a read-only iterator that points to the first case in the\n  /// SwitchInst.\n  ConstCaseIt case_begin() const {\n    return ConstCaseIt(this, 0);\n  }\n\n  /// Returns a read/write iterator that points one past the last in the\n  /// SwitchInst.\n  CaseIt case_end() {\n    return CaseIt(this, getNumCases());\n  }\n\n  /// Returns a read-only iterator that points one past the last in the\n  /// SwitchInst.\n  ConstCaseIt case_end() const {\n    return ConstCaseIt(this, getNumCases());\n  }\n\n  /// Iteration adapter for range-for loops.\n  iterator_range<CaseIt> cases() {\n    return make_range(case_begin(), case_end());\n  }\n\n  /// Constant iteration adapter for range-for loops.\n  iterator_range<ConstCaseIt> cases() const {\n    return make_range(case_begin(), case_end());\n  }\n\n  /// Returns an iterator that points to the default case.\n  /// Note: this iterator allows to resolve successor only. Attempt\n  /// to resolve case value causes an assertion.\n  /// Also note, that increment and decrement also causes an assertion and\n  /// makes iterator invalid.\n  CaseIt case_default() {\n    return CaseIt(this, DefaultPseudoIndex);\n  }\n  ConstCaseIt case_default() const {\n    return ConstCaseIt(this, DefaultPseudoIndex);\n  }\n\n  /// Search all of the case values for the specified constant. If it is\n  /// explicitly handled, return the case iterator of it, otherwise return\n  /// default case iterator to indicate that it is handled by the default\n  /// handler.\n  CaseIt findCaseValue(const ConstantInt *C) {\n    CaseIt I = llvm::find_if(\n        cases(), [C](CaseHandle &Case) { return Case.getCaseValue() == C; });\n    if (I != case_end())\n      return I;\n\n    return case_default();\n  }\n  ConstCaseIt findCaseValue(const ConstantInt *C) const {\n    ConstCaseIt I = llvm::find_if(cases(), [C](ConstCaseHandle &Case) {\n      return Case.getCaseValue() == C;\n    });\n    if (I != case_end())\n      return I;\n\n    return case_default();\n  }\n\n  /// Finds the unique case value for a given successor. Returns null if the\n  /// successor is not found, not unique, or is the default case.\n  ConstantInt *findCaseDest(BasicBlock *BB) {\n    if (BB == getDefaultDest())\n      return nullptr;\n\n    ConstantInt *CI = nullptr;\n    for (auto Case : cases()) {\n      if (Case.getCaseSuccessor() != BB)\n        continue;\n\n      if (CI)\n        return nullptr; // Multiple cases lead to BB.\n\n      CI = Case.getCaseValue();\n    }\n\n    return CI;\n  }\n\n  /// Add an entry to the switch instruction.\n  /// Note:\n  /// This action invalidates case_end(). Old case_end() iterator will\n  /// point to the added case.\n  void addCase(ConstantInt *OnVal, BasicBlock *Dest);\n\n  /// This method removes the specified case and its successor from the switch\n  /// instruction. Note that this operation may reorder the remaining cases at\n  /// index idx and above.\n  /// Note:\n  /// This action invalidates iterators for all cases following the one removed,\n  /// including the case_end() iterator. It returns an iterator for the next\n  /// case.\n  CaseIt removeCase(CaseIt I);\n\n  unsigned getNumSuccessors() const { return getNumOperands()/2; }\n  BasicBlock *getSuccessor(unsigned idx) const {\n    assert(idx < getNumSuccessors() &&\"Successor idx out of range for switch!\");\n    return cast<BasicBlock>(getOperand(idx*2+1));\n  }\n  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {\n    assert(idx < getNumSuccessors() && \"Successor # out of range for switch!\");\n    setOperand(idx * 2 + 1, NewSucc);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Switch;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n/// A wrapper class to simplify modification of SwitchInst cases along with\n/// their prof branch_weights metadata.\nclass SwitchInstProfUpdateWrapper {\n  SwitchInst &SI;\n  Optional<SmallVector<uint32_t, 8> > Weights = None;\n  bool Changed = false;\n\nprotected:\n  static MDNode *getProfBranchWeightsMD(const SwitchInst &SI);\n\n  MDNode *buildProfBranchWeightsMD();\n\n  void init();\n\npublic:\n  using CaseWeightOpt = Optional<uint32_t>;\n  SwitchInst *operator->() { return &SI; }\n  SwitchInst &operator*() { return SI; }\n  operator SwitchInst *() { return &SI; }\n\n  SwitchInstProfUpdateWrapper(SwitchInst &SI) : SI(SI) { init(); }\n\n  ~SwitchInstProfUpdateWrapper() {\n    if (Changed)\n      SI.setMetadata(LLVMContext::MD_prof, buildProfBranchWeightsMD());\n  }\n\n  /// Delegate the call to the underlying SwitchInst::removeCase() and remove\n  /// correspondent branch weight.\n  SwitchInst::CaseIt removeCase(SwitchInst::CaseIt I);\n\n  /// Delegate the call to the underlying SwitchInst::addCase() and set the\n  /// specified branch weight for the added case.\n  void addCase(ConstantInt *OnVal, BasicBlock *Dest, CaseWeightOpt W);\n\n  /// Delegate the call to the underlying SwitchInst::eraseFromParent() and mark\n  /// this object to not touch the underlying SwitchInst in destructor.\n  SymbolTableList<Instruction>::iterator eraseFromParent();\n\n  void setSuccessorWeight(unsigned idx, CaseWeightOpt W);\n  CaseWeightOpt getSuccessorWeight(unsigned idx);\n\n  static CaseWeightOpt getSuccessorWeight(const SwitchInst &SI, unsigned idx);\n};\n\ntemplate <>\nstruct OperandTraits<SwitchInst> : public HungoffOperandTraits<2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(SwitchInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                             IndirectBrInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Indirect Branch Instruction.\n///\nclass IndirectBrInst : public Instruction {\n  unsigned ReservedSpace;\n\n  // Operand[0]   = Address to jump to\n  // Operand[n+1] = n-th destination\n  IndirectBrInst(const IndirectBrInst &IBI);\n\n  /// Create a new indirectbr instruction, specifying an\n  /// Address to jump to.  The number of expected destinations can be specified\n  /// here to make memory allocation more efficient.  This constructor can also\n  /// autoinsert before another instruction.\n  IndirectBrInst(Value *Address, unsigned NumDests, Instruction *InsertBefore);\n\n  /// Create a new indirectbr instruction, specifying an\n  /// Address to jump to.  The number of expected destinations can be specified\n  /// here to make memory allocation more efficient.  This constructor also\n  /// autoinserts at the end of the specified BasicBlock.\n  IndirectBrInst(Value *Address, unsigned NumDests, BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) {\n    return User::operator new(s);\n  }\n\n  void init(Value *Address, unsigned NumDests);\n  void growOperands();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  IndirectBrInst *cloneImpl() const;\n\npublic:\n  /// Iterator type that casts an operand to a basic block.\n  ///\n  /// This only makes sense because the successors are stored as adjacent\n  /// operands for indirectbr instructions.\n  struct succ_op_iterator\n      : iterator_adaptor_base<succ_op_iterator, value_op_iterator,\n                              std::random_access_iterator_tag, BasicBlock *,\n                              ptrdiff_t, BasicBlock *, BasicBlock *> {\n    explicit succ_op_iterator(value_op_iterator I) : iterator_adaptor_base(I) {}\n\n    BasicBlock *operator*() const { return cast<BasicBlock>(*I); }\n    BasicBlock *operator->() const { return operator*(); }\n  };\n\n  /// The const version of `succ_op_iterator`.\n  struct const_succ_op_iterator\n      : iterator_adaptor_base<const_succ_op_iterator, const_value_op_iterator,\n                              std::random_access_iterator_tag,\n                              const BasicBlock *, ptrdiff_t, const BasicBlock *,\n                              const BasicBlock *> {\n    explicit const_succ_op_iterator(const_value_op_iterator I)\n        : iterator_adaptor_base(I) {}\n\n    const BasicBlock *operator*() const { return cast<BasicBlock>(*I); }\n    const BasicBlock *operator->() const { return operator*(); }\n  };\n\n  static IndirectBrInst *Create(Value *Address, unsigned NumDests,\n                                Instruction *InsertBefore = nullptr) {\n    return new IndirectBrInst(Address, NumDests, InsertBefore);\n  }\n\n  static IndirectBrInst *Create(Value *Address, unsigned NumDests,\n                                BasicBlock *InsertAtEnd) {\n    return new IndirectBrInst(Address, NumDests, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Accessor Methods for IndirectBrInst instruction.\n  Value *getAddress() { return getOperand(0); }\n  const Value *getAddress() const { return getOperand(0); }\n  void setAddress(Value *V) { setOperand(0, V); }\n\n  /// return the number of possible destinations in this\n  /// indirectbr instruction.\n  unsigned getNumDestinations() const { return getNumOperands()-1; }\n\n  /// Return the specified destination.\n  BasicBlock *getDestination(unsigned i) { return getSuccessor(i); }\n  const BasicBlock *getDestination(unsigned i) const { return getSuccessor(i); }\n\n  /// Add a destination.\n  ///\n  void addDestination(BasicBlock *Dest);\n\n  /// This method removes the specified successor from the\n  /// indirectbr instruction.\n  void removeDestination(unsigned i);\n\n  unsigned getNumSuccessors() const { return getNumOperands()-1; }\n  BasicBlock *getSuccessor(unsigned i) const {\n    return cast<BasicBlock>(getOperand(i+1));\n  }\n  void setSuccessor(unsigned i, BasicBlock *NewSucc) {\n    setOperand(i + 1, NewSucc);\n  }\n\n  iterator_range<succ_op_iterator> successors() {\n    return make_range(succ_op_iterator(std::next(value_op_begin())),\n                      succ_op_iterator(value_op_end()));\n  }\n\n  iterator_range<const_succ_op_iterator> successors() const {\n    return make_range(const_succ_op_iterator(std::next(value_op_begin())),\n                      const_succ_op_iterator(value_op_end()));\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::IndirectBr;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<IndirectBrInst> : public HungoffOperandTraits<1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(IndirectBrInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               InvokeInst Class\n//===----------------------------------------------------------------------===//\n\n/// Invoke instruction.  The SubclassData field is used to hold the\n/// calling convention of the call.\n///\nclass InvokeInst : public CallBase {\n  /// The number of operands for this call beyond the called function,\n  /// arguments, and operand bundles.\n  static constexpr int NumExtraOperands = 2;\n\n  /// The index from the end of the operand array to the normal destination.\n  static constexpr int NormalDestOpEndIdx = -3;\n\n  /// The index from the end of the operand array to the unwind destination.\n  static constexpr int UnwindDestOpEndIdx = -2;\n\n  InvokeInst(const InvokeInst &BI);\n\n  /// Construct an InvokeInst given a range of arguments.\n  ///\n  /// Construct an InvokeInst from a range of arguments\n  inline InvokeInst(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                    BasicBlock *IfException, ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                    const Twine &NameStr, Instruction *InsertBefore);\n\n  inline InvokeInst(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                    BasicBlock *IfException, ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                    const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n            BasicBlock *IfException, ArrayRef<Value *> Args,\n            ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr);\n\n  /// Compute the number of operands to allocate.\n  static int ComputeNumOperands(int NumArgs, int NumBundleInputs = 0) {\n    // We need one operand for the called function, plus our extra operands and\n    // the input operand counts provided.\n    return 1 + NumExtraOperands + NumArgs + NumBundleInputs;\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  InvokeInst *cloneImpl() const;\n\npublic:\n  static InvokeInst *Create(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            const Twine &NameStr,\n                            Instruction *InsertBefore = nullptr) {\n    int NumOperands = ComputeNumOperands(Args.size());\n    return new (NumOperands)\n        InvokeInst(Ty, Func, IfNormal, IfException, Args, None, NumOperands,\n                   NameStr, InsertBefore);\n  }\n\n  static InvokeInst *Create(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles = None,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr) {\n    int NumOperands =\n        ComputeNumOperands(Args.size(), CountBundleInputs(Bundles));\n    unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        InvokeInst(Ty, Func, IfNormal, IfException, Args, Bundles, NumOperands,\n                   NameStr, InsertBefore);\n  }\n\n  static InvokeInst *Create(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    int NumOperands = ComputeNumOperands(Args.size());\n    return new (NumOperands)\n        InvokeInst(Ty, Func, IfNormal, IfException, Args, None, NumOperands,\n                   NameStr, InsertAtEnd);\n  }\n\n  static InvokeInst *Create(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    int NumOperands =\n        ComputeNumOperands(Args.size(), CountBundleInputs(Bundles));\n    unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        InvokeInst(Ty, Func, IfNormal, IfException, Args, Bundles, NumOperands,\n                   NameStr, InsertAtEnd);\n  }\n\n  static InvokeInst *Create(FunctionCallee Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            const Twine &NameStr,\n                            Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), IfNormal,\n                  IfException, Args, None, NameStr, InsertBefore);\n  }\n\n  static InvokeInst *Create(FunctionCallee Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles = None,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), IfNormal,\n                  IfException, Args, Bundles, NameStr, InsertBefore);\n  }\n\n  static InvokeInst *Create(FunctionCallee Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), IfNormal,\n                  IfException, Args, NameStr, InsertAtEnd);\n  }\n\n  static InvokeInst *Create(FunctionCallee Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), IfNormal,\n                  IfException, Args, Bundles, NameStr, InsertAtEnd);\n  }\n\n  /// Create a clone of \\p II with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned invoke instruction is identical to \\p II in every way except\n  /// that the operand bundles for the new instruction are set to the operand\n  /// bundles in \\p Bundles.\n  static InvokeInst *Create(InvokeInst *II, ArrayRef<OperandBundleDef> Bundles,\n                            Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p II with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned invoke instruction is identical to \\p II in every way except\n  /// that the operand bundle for the new instruction is set to the operand\n  /// bundle in \\p Bundle.\n  static InvokeInst *CreateWithReplacedBundle(InvokeInst *II,\n                                              OperandBundleDef Bundles,\n                                              Instruction *InsertPt = nullptr);\n\n  // get*Dest - Return the destination basic blocks...\n  BasicBlock *getNormalDest() const {\n    return cast<BasicBlock>(Op<NormalDestOpEndIdx>());\n  }\n  BasicBlock *getUnwindDest() const {\n    return cast<BasicBlock>(Op<UnwindDestOpEndIdx>());\n  }\n  void setNormalDest(BasicBlock *B) {\n    Op<NormalDestOpEndIdx>() = reinterpret_cast<Value *>(B);\n  }\n  void setUnwindDest(BasicBlock *B) {\n    Op<UnwindDestOpEndIdx>() = reinterpret_cast<Value *>(B);\n  }\n\n  /// Get the landingpad instruction from the landing pad\n  /// block (the unwind destination).\n  LandingPadInst *getLandingPadInst() const;\n\n  BasicBlock *getSuccessor(unsigned i) const {\n    assert(i < 2 && \"Successor # out of range for invoke!\");\n    return i == 0 ? getNormalDest() : getUnwindDest();\n  }\n\n  void setSuccessor(unsigned i, BasicBlock *NewSucc) {\n    assert(i < 2 && \"Successor # out of range for invoke!\");\n    if (i == 0)\n      setNormalDest(NewSucc);\n    else\n      setUnwindDest(NewSucc);\n  }\n\n  unsigned getNumSuccessors() const { return 2; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::Invoke);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\nInvokeInst::InvokeInst(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                       BasicBlock *IfException, ArrayRef<Value *> Args,\n                       ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                       const Twine &NameStr, Instruction *InsertBefore)\n    : CallBase(Ty->getReturnType(), Instruction::Invoke,\n               OperandTraits<CallBase>::op_end(this) - NumOperands, NumOperands,\n               InsertBefore) {\n  init(Ty, Func, IfNormal, IfException, Args, Bundles, NameStr);\n}\n\nInvokeInst::InvokeInst(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                       BasicBlock *IfException, ArrayRef<Value *> Args,\n                       ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                       const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : CallBase(Ty->getReturnType(), Instruction::Invoke,\n               OperandTraits<CallBase>::op_end(this) - NumOperands, NumOperands,\n               InsertAtEnd) {\n  init(Ty, Func, IfNormal, IfException, Args, Bundles, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                              CallBrInst Class\n//===----------------------------------------------------------------------===//\n\n/// CallBr instruction, tracking function calls that may not return control but\n/// instead transfer it to a third location. The SubclassData field is used to\n/// hold the calling convention of the call.\n///\nclass CallBrInst : public CallBase {\n\n  unsigned NumIndirectDests;\n\n  CallBrInst(const CallBrInst &BI);\n\n  /// Construct a CallBrInst given a range of arguments.\n  ///\n  /// Construct a CallBrInst from a range of arguments\n  inline CallBrInst(FunctionType *Ty, Value *Func, BasicBlock *DefaultDest,\n                    ArrayRef<BasicBlock *> IndirectDests,\n                    ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                    const Twine &NameStr, Instruction *InsertBefore);\n\n  inline CallBrInst(FunctionType *Ty, Value *Func, BasicBlock *DefaultDest,\n                    ArrayRef<BasicBlock *> IndirectDests,\n                    ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                    const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(FunctionType *FTy, Value *Func, BasicBlock *DefaultDest,\n            ArrayRef<BasicBlock *> IndirectDests, ArrayRef<Value *> Args,\n            ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr);\n\n  /// Should the Indirect Destinations change, scan + update the Arg list.\n  void updateArgBlockAddresses(unsigned i, BasicBlock *B);\n\n  /// Compute the number of operands to allocate.\n  static int ComputeNumOperands(int NumArgs, int NumIndirectDests,\n                                int NumBundleInputs = 0) {\n    // We need one operand for the called function, plus our extra operands and\n    // the input operand counts provided.\n    return 2 + NumIndirectDests + NumArgs + NumBundleInputs;\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CallBrInst *cloneImpl() const;\n\npublic:\n  static CallBrInst *Create(FunctionType *Ty, Value *Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args, const Twine &NameStr,\n                            Instruction *InsertBefore = nullptr) {\n    int NumOperands = ComputeNumOperands(Args.size(), IndirectDests.size());\n    return new (NumOperands)\n        CallBrInst(Ty, Func, DefaultDest, IndirectDests, Args, None,\n                   NumOperands, NameStr, InsertBefore);\n  }\n\n  static CallBrInst *Create(FunctionType *Ty, Value *Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles = None,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr) {\n    int NumOperands = ComputeNumOperands(Args.size(), IndirectDests.size(),\n                                         CountBundleInputs(Bundles));\n    unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        CallBrInst(Ty, Func, DefaultDest, IndirectDests, Args, Bundles,\n                   NumOperands, NameStr, InsertBefore);\n  }\n\n  static CallBrInst *Create(FunctionType *Ty, Value *Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args, const Twine &NameStr,\n                            BasicBlock *InsertAtEnd) {\n    int NumOperands = ComputeNumOperands(Args.size(), IndirectDests.size());\n    return new (NumOperands)\n        CallBrInst(Ty, Func, DefaultDest, IndirectDests, Args, None,\n                   NumOperands, NameStr, InsertAtEnd);\n  }\n\n  static CallBrInst *Create(FunctionType *Ty, Value *Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    int NumOperands = ComputeNumOperands(Args.size(), IndirectDests.size(),\n                                         CountBundleInputs(Bundles));\n    unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        CallBrInst(Ty, Func, DefaultDest, IndirectDests, Args, Bundles,\n                   NumOperands, NameStr, InsertAtEnd);\n  }\n\n  static CallBrInst *Create(FunctionCallee Func, BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args, const Twine &NameStr,\n                            Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), DefaultDest,\n                  IndirectDests, Args, NameStr, InsertBefore);\n  }\n\n  static CallBrInst *Create(FunctionCallee Func, BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles = None,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), DefaultDest,\n                  IndirectDests, Args, Bundles, NameStr, InsertBefore);\n  }\n\n  static CallBrInst *Create(FunctionCallee Func, BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args, const Twine &NameStr,\n                            BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), DefaultDest,\n                  IndirectDests, Args, NameStr, InsertAtEnd);\n  }\n\n  static CallBrInst *Create(FunctionCallee Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), DefaultDest,\n                  IndirectDests, Args, Bundles, NameStr, InsertAtEnd);\n  }\n\n  /// Create a clone of \\p CBI with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned callbr instruction is identical to \\p CBI in every way\n  /// except that the operand bundles for the new instruction are set to the\n  /// operand bundles in \\p Bundles.\n  static CallBrInst *Create(CallBrInst *CBI,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            Instruction *InsertPt = nullptr);\n\n  /// Return the number of callbr indirect dest labels.\n  ///\n  unsigned getNumIndirectDests() const { return NumIndirectDests; }\n\n  /// getIndirectDestLabel - Return the i-th indirect dest label.\n  ///\n  Value *getIndirectDestLabel(unsigned i) const {\n    assert(i < getNumIndirectDests() && \"Out of bounds!\");\n    return getOperand(i + getNumArgOperands() + getNumTotalBundleOperands() +\n                      1);\n  }\n\n  Value *getIndirectDestLabelUse(unsigned i) const {\n    assert(i < getNumIndirectDests() && \"Out of bounds!\");\n    return getOperandUse(i + getNumArgOperands() + getNumTotalBundleOperands() +\n                         1);\n  }\n\n  // Return the destination basic blocks...\n  BasicBlock *getDefaultDest() const {\n    return cast<BasicBlock>(*(&Op<-1>() - getNumIndirectDests() - 1));\n  }\n  BasicBlock *getIndirectDest(unsigned i) const {\n    return cast_or_null<BasicBlock>(*(&Op<-1>() - getNumIndirectDests() + i));\n  }\n  SmallVector<BasicBlock *, 16> getIndirectDests() const {\n    SmallVector<BasicBlock *, 16> IndirectDests;\n    for (unsigned i = 0, e = getNumIndirectDests(); i < e; ++i)\n      IndirectDests.push_back(getIndirectDest(i));\n    return IndirectDests;\n  }\n  void setDefaultDest(BasicBlock *B) {\n    *(&Op<-1>() - getNumIndirectDests() - 1) = reinterpret_cast<Value *>(B);\n  }\n  void setIndirectDest(unsigned i, BasicBlock *B) {\n    updateArgBlockAddresses(i, B);\n    *(&Op<-1>() - getNumIndirectDests() + i) = reinterpret_cast<Value *>(B);\n  }\n\n  BasicBlock *getSuccessor(unsigned i) const {\n    assert(i < getNumSuccessors() + 1 &&\n           \"Successor # out of range for callbr!\");\n    return i == 0 ? getDefaultDest() : getIndirectDest(i - 1);\n  }\n\n  void setSuccessor(unsigned i, BasicBlock *NewSucc) {\n    assert(i < getNumIndirectDests() + 1 &&\n           \"Successor # out of range for callbr!\");\n    return i == 0 ? setDefaultDest(NewSucc) : setIndirectDest(i - 1, NewSucc);\n  }\n\n  unsigned getNumSuccessors() const { return getNumIndirectDests() + 1; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::CallBr);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\nCallBrInst::CallBrInst(FunctionType *Ty, Value *Func, BasicBlock *DefaultDest,\n                       ArrayRef<BasicBlock *> IndirectDests,\n                       ArrayRef<Value *> Args,\n                       ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                       const Twine &NameStr, Instruction *InsertBefore)\n    : CallBase(Ty->getReturnType(), Instruction::CallBr,\n               OperandTraits<CallBase>::op_end(this) - NumOperands, NumOperands,\n               InsertBefore) {\n  init(Ty, Func, DefaultDest, IndirectDests, Args, Bundles, NameStr);\n}\n\nCallBrInst::CallBrInst(FunctionType *Ty, Value *Func, BasicBlock *DefaultDest,\n                       ArrayRef<BasicBlock *> IndirectDests,\n                       ArrayRef<Value *> Args,\n                       ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                       const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : CallBase(Ty->getReturnType(), Instruction::CallBr,\n               OperandTraits<CallBase>::op_end(this) - NumOperands, NumOperands,\n               InsertAtEnd) {\n  init(Ty, Func, DefaultDest, IndirectDests, Args, Bundles, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                              ResumeInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Resume the propagation of an exception.\n///\nclass ResumeInst : public Instruction {\n  ResumeInst(const ResumeInst &RI);\n\n  explicit ResumeInst(Value *Exn, Instruction *InsertBefore=nullptr);\n  ResumeInst(Value *Exn, BasicBlock *InsertAtEnd);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ResumeInst *cloneImpl() const;\n\npublic:\n  static ResumeInst *Create(Value *Exn, Instruction *InsertBefore = nullptr) {\n    return new(1) ResumeInst(Exn, InsertBefore);\n  }\n\n  static ResumeInst *Create(Value *Exn, BasicBlock *InsertAtEnd) {\n    return new(1) ResumeInst(Exn, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Convenience accessor.\n  Value *getValue() const { return Op<0>(); }\n\n  unsigned getNumSuccessors() const { return 0; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Resume;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned idx) const {\n    llvm_unreachable(\"ResumeInst has no successors!\");\n  }\n\n  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {\n    llvm_unreachable(\"ResumeInst has no successors!\");\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ResumeInst> :\n    public FixedNumOperandTraits<ResumeInst, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ResumeInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                         CatchSwitchInst Class\n//===----------------------------------------------------------------------===//\nclass CatchSwitchInst : public Instruction {\n  using UnwindDestField = BoolBitfieldElementT<0>;\n\n  /// The number of operands actually allocated.  NumOperands is\n  /// the number actually in use.\n  unsigned ReservedSpace;\n\n  // Operand[0] = Outer scope\n  // Operand[1] = Unwind block destination\n  // Operand[n] = BasicBlock to go to on match\n  CatchSwitchInst(const CatchSwitchInst &CSI);\n\n  /// Create a new switch instruction, specifying a\n  /// default destination.  The number of additional handlers can be specified\n  /// here to make memory allocation more efficient.\n  /// This constructor can also autoinsert before another instruction.\n  CatchSwitchInst(Value *ParentPad, BasicBlock *UnwindDest,\n                  unsigned NumHandlers, const Twine &NameStr,\n                  Instruction *InsertBefore);\n\n  /// Create a new switch instruction, specifying a\n  /// default destination.  The number of additional handlers can be specified\n  /// here to make memory allocation more efficient.\n  /// This constructor also autoinserts at the end of the specified BasicBlock.\n  CatchSwitchInst(Value *ParentPad, BasicBlock *UnwindDest,\n                  unsigned NumHandlers, const Twine &NameStr,\n                  BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) { return User::operator new(s); }\n\n  void init(Value *ParentPad, BasicBlock *UnwindDest, unsigned NumReserved);\n  void growOperands(unsigned Size);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CatchSwitchInst *cloneImpl() const;\n\npublic:\n  static CatchSwitchInst *Create(Value *ParentPad, BasicBlock *UnwindDest,\n                                 unsigned NumHandlers,\n                                 const Twine &NameStr = \"\",\n                                 Instruction *InsertBefore = nullptr) {\n    return new CatchSwitchInst(ParentPad, UnwindDest, NumHandlers, NameStr,\n                               InsertBefore);\n  }\n\n  static CatchSwitchInst *Create(Value *ParentPad, BasicBlock *UnwindDest,\n                                 unsigned NumHandlers, const Twine &NameStr,\n                                 BasicBlock *InsertAtEnd) {\n    return new CatchSwitchInst(ParentPad, UnwindDest, NumHandlers, NameStr,\n                               InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Accessor Methods for CatchSwitch stmt\n  Value *getParentPad() const { return getOperand(0); }\n  void setParentPad(Value *ParentPad) { setOperand(0, ParentPad); }\n\n  // Accessor Methods for CatchSwitch stmt\n  bool hasUnwindDest() const { return getSubclassData<UnwindDestField>(); }\n  bool unwindsToCaller() const { return !hasUnwindDest(); }\n  BasicBlock *getUnwindDest() const {\n    if (hasUnwindDest())\n      return cast<BasicBlock>(getOperand(1));\n    return nullptr;\n  }\n  void setUnwindDest(BasicBlock *UnwindDest) {\n    assert(UnwindDest);\n    assert(hasUnwindDest());\n    setOperand(1, UnwindDest);\n  }\n\n  /// return the number of 'handlers' in this catchswitch\n  /// instruction, except the default handler\n  unsigned getNumHandlers() const {\n    if (hasUnwindDest())\n      return getNumOperands() - 2;\n    return getNumOperands() - 1;\n  }\n\nprivate:\n  static BasicBlock *handler_helper(Value *V) { return cast<BasicBlock>(V); }\n  static const BasicBlock *handler_helper(const Value *V) {\n    return cast<BasicBlock>(V);\n  }\n\npublic:\n  using DerefFnTy = BasicBlock *(*)(Value *);\n  using handler_iterator = mapped_iterator<op_iterator, DerefFnTy>;\n  using handler_range = iterator_range<handler_iterator>;\n  using ConstDerefFnTy = const BasicBlock *(*)(const Value *);\n  using const_handler_iterator =\n      mapped_iterator<const_op_iterator, ConstDerefFnTy>;\n  using const_handler_range = iterator_range<const_handler_iterator>;\n\n  /// Returns an iterator that points to the first handler in CatchSwitchInst.\n  handler_iterator handler_begin() {\n    op_iterator It = op_begin() + 1;\n    if (hasUnwindDest())\n      ++It;\n    return handler_iterator(It, DerefFnTy(handler_helper));\n  }\n\n  /// Returns an iterator that points to the first handler in the\n  /// CatchSwitchInst.\n  const_handler_iterator handler_begin() const {\n    const_op_iterator It = op_begin() + 1;\n    if (hasUnwindDest())\n      ++It;\n    return const_handler_iterator(It, ConstDerefFnTy(handler_helper));\n  }\n\n  /// Returns a read-only iterator that points one past the last\n  /// handler in the CatchSwitchInst.\n  handler_iterator handler_end() {\n    return handler_iterator(op_end(), DerefFnTy(handler_helper));\n  }\n\n  /// Returns an iterator that points one past the last handler in the\n  /// CatchSwitchInst.\n  const_handler_iterator handler_end() const {\n    return const_handler_iterator(op_end(), ConstDerefFnTy(handler_helper));\n  }\n\n  /// iteration adapter for range-for loops.\n  handler_range handlers() {\n    return make_range(handler_begin(), handler_end());\n  }\n\n  /// iteration adapter for range-for loops.\n  const_handler_range handlers() const {\n    return make_range(handler_begin(), handler_end());\n  }\n\n  /// Add an entry to the switch instruction...\n  /// Note:\n  /// This action invalidates handler_end(). Old handler_end() iterator will\n  /// point to the added handler.\n  void addHandler(BasicBlock *Dest);\n\n  void removeHandler(handler_iterator HI);\n\n  unsigned getNumSuccessors() const { return getNumOperands() - 1; }\n  BasicBlock *getSuccessor(unsigned Idx) const {\n    assert(Idx < getNumSuccessors() &&\n           \"Successor # out of range for catchswitch!\");\n    return cast<BasicBlock>(getOperand(Idx + 1));\n  }\n  void setSuccessor(unsigned Idx, BasicBlock *NewSucc) {\n    assert(Idx < getNumSuccessors() &&\n           \"Successor # out of range for catchswitch!\");\n    setOperand(Idx + 1, NewSucc);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::CatchSwitch;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CatchSwitchInst> : public HungoffOperandTraits<2> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CatchSwitchInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               CleanupPadInst Class\n//===----------------------------------------------------------------------===//\nclass CleanupPadInst : public FuncletPadInst {\nprivate:\n  explicit CleanupPadInst(Value *ParentPad, ArrayRef<Value *> Args,\n                          unsigned Values, const Twine &NameStr,\n                          Instruction *InsertBefore)\n      : FuncletPadInst(Instruction::CleanupPad, ParentPad, Args, Values,\n                       NameStr, InsertBefore) {}\n  explicit CleanupPadInst(Value *ParentPad, ArrayRef<Value *> Args,\n                          unsigned Values, const Twine &NameStr,\n                          BasicBlock *InsertAtEnd)\n      : FuncletPadInst(Instruction::CleanupPad, ParentPad, Args, Values,\n                       NameStr, InsertAtEnd) {}\n\npublic:\n  static CleanupPadInst *Create(Value *ParentPad, ArrayRef<Value *> Args = None,\n                                const Twine &NameStr = \"\",\n                                Instruction *InsertBefore = nullptr) {\n    unsigned Values = 1 + Args.size();\n    return new (Values)\n        CleanupPadInst(ParentPad, Args, Values, NameStr, InsertBefore);\n  }\n\n  static CleanupPadInst *Create(Value *ParentPad, ArrayRef<Value *> Args,\n                                const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    unsigned Values = 1 + Args.size();\n    return new (Values)\n        CleanupPadInst(ParentPad, Args, Values, NameStr, InsertAtEnd);\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::CleanupPad;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               CatchPadInst Class\n//===----------------------------------------------------------------------===//\nclass CatchPadInst : public FuncletPadInst {\nprivate:\n  explicit CatchPadInst(Value *CatchSwitch, ArrayRef<Value *> Args,\n                        unsigned Values, const Twine &NameStr,\n                        Instruction *InsertBefore)\n      : FuncletPadInst(Instruction::CatchPad, CatchSwitch, Args, Values,\n                       NameStr, InsertBefore) {}\n  explicit CatchPadInst(Value *CatchSwitch, ArrayRef<Value *> Args,\n                        unsigned Values, const Twine &NameStr,\n                        BasicBlock *InsertAtEnd)\n      : FuncletPadInst(Instruction::CatchPad, CatchSwitch, Args, Values,\n                       NameStr, InsertAtEnd) {}\n\npublic:\n  static CatchPadInst *Create(Value *CatchSwitch, ArrayRef<Value *> Args,\n                              const Twine &NameStr = \"\",\n                              Instruction *InsertBefore = nullptr) {\n    unsigned Values = 1 + Args.size();\n    return new (Values)\n        CatchPadInst(CatchSwitch, Args, Values, NameStr, InsertBefore);\n  }\n\n  static CatchPadInst *Create(Value *CatchSwitch, ArrayRef<Value *> Args,\n                              const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    unsigned Values = 1 + Args.size();\n    return new (Values)\n        CatchPadInst(CatchSwitch, Args, Values, NameStr, InsertAtEnd);\n  }\n\n  /// Convenience accessors\n  CatchSwitchInst *getCatchSwitch() const {\n    return cast<CatchSwitchInst>(Op<-1>());\n  }\n  void setCatchSwitch(Value *CatchSwitch) {\n    assert(CatchSwitch);\n    Op<-1>() = CatchSwitch;\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::CatchPad;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               CatchReturnInst Class\n//===----------------------------------------------------------------------===//\n\nclass CatchReturnInst : public Instruction {\n  CatchReturnInst(const CatchReturnInst &RI);\n  CatchReturnInst(Value *CatchPad, BasicBlock *BB, Instruction *InsertBefore);\n  CatchReturnInst(Value *CatchPad, BasicBlock *BB, BasicBlock *InsertAtEnd);\n\n  void init(Value *CatchPad, BasicBlock *BB);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CatchReturnInst *cloneImpl() const;\n\npublic:\n  static CatchReturnInst *Create(Value *CatchPad, BasicBlock *BB,\n                                 Instruction *InsertBefore = nullptr) {\n    assert(CatchPad);\n    assert(BB);\n    return new (2) CatchReturnInst(CatchPad, BB, InsertBefore);\n  }\n\n  static CatchReturnInst *Create(Value *CatchPad, BasicBlock *BB,\n                                 BasicBlock *InsertAtEnd) {\n    assert(CatchPad);\n    assert(BB);\n    return new (2) CatchReturnInst(CatchPad, BB, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Convenience accessors.\n  CatchPadInst *getCatchPad() const { return cast<CatchPadInst>(Op<0>()); }\n  void setCatchPad(CatchPadInst *CatchPad) {\n    assert(CatchPad);\n    Op<0>() = CatchPad;\n  }\n\n  BasicBlock *getSuccessor() const { return cast<BasicBlock>(Op<1>()); }\n  void setSuccessor(BasicBlock *NewSucc) {\n    assert(NewSucc);\n    Op<1>() = NewSucc;\n  }\n  unsigned getNumSuccessors() const { return 1; }\n\n  /// Get the parentPad of this catchret's catchpad's catchswitch.\n  /// The successor block is implicitly a member of this funclet.\n  Value *getCatchSwitchParentPad() const {\n    return getCatchPad()->getCatchSwitch()->getParentPad();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::CatchRet);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned Idx) const {\n    assert(Idx < getNumSuccessors() && \"Successor # out of range for catchret!\");\n    return getSuccessor();\n  }\n\n  void setSuccessor(unsigned Idx, BasicBlock *B) {\n    assert(Idx < getNumSuccessors() && \"Successor # out of range for catchret!\");\n    setSuccessor(B);\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CatchReturnInst>\n    : public FixedNumOperandTraits<CatchReturnInst, 2> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CatchReturnInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               CleanupReturnInst Class\n//===----------------------------------------------------------------------===//\n\nclass CleanupReturnInst : public Instruction {\n  using UnwindDestField = BoolBitfieldElementT<0>;\n\nprivate:\n  CleanupReturnInst(const CleanupReturnInst &RI);\n  CleanupReturnInst(Value *CleanupPad, BasicBlock *UnwindBB, unsigned Values,\n                    Instruction *InsertBefore = nullptr);\n  CleanupReturnInst(Value *CleanupPad, BasicBlock *UnwindBB, unsigned Values,\n                    BasicBlock *InsertAtEnd);\n\n  void init(Value *CleanupPad, BasicBlock *UnwindBB);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CleanupReturnInst *cloneImpl() const;\n\npublic:\n  static CleanupReturnInst *Create(Value *CleanupPad,\n                                   BasicBlock *UnwindBB = nullptr,\n                                   Instruction *InsertBefore = nullptr) {\n    assert(CleanupPad);\n    unsigned Values = 1;\n    if (UnwindBB)\n      ++Values;\n    return new (Values)\n        CleanupReturnInst(CleanupPad, UnwindBB, Values, InsertBefore);\n  }\n\n  static CleanupReturnInst *Create(Value *CleanupPad, BasicBlock *UnwindBB,\n                                   BasicBlock *InsertAtEnd) {\n    assert(CleanupPad);\n    unsigned Values = 1;\n    if (UnwindBB)\n      ++Values;\n    return new (Values)\n        CleanupReturnInst(CleanupPad, UnwindBB, Values, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  bool hasUnwindDest() const { return getSubclassData<UnwindDestField>(); }\n  bool unwindsToCaller() const { return !hasUnwindDest(); }\n\n  /// Convenience accessor.\n  CleanupPadInst *getCleanupPad() const {\n    return cast<CleanupPadInst>(Op<0>());\n  }\n  void setCleanupPad(CleanupPadInst *CleanupPad) {\n    assert(CleanupPad);\n    Op<0>() = CleanupPad;\n  }\n\n  unsigned getNumSuccessors() const { return hasUnwindDest() ? 1 : 0; }\n\n  BasicBlock *getUnwindDest() const {\n    return hasUnwindDest() ? cast<BasicBlock>(Op<1>()) : nullptr;\n  }\n  void setUnwindDest(BasicBlock *NewDest) {\n    assert(NewDest);\n    assert(hasUnwindDest());\n    Op<1>() = NewDest;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::CleanupRet);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned Idx) const {\n    assert(Idx == 0);\n    return getUnwindDest();\n  }\n\n  void setSuccessor(unsigned Idx, BasicBlock *B) {\n    assert(Idx == 0);\n    setUnwindDest(B);\n  }\n\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CleanupReturnInst>\n    : public VariadicOperandTraits<CleanupReturnInst, /*MINARITY=*/1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CleanupReturnInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                           UnreachableInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// This function has undefined behavior.  In particular, the\n/// presence of this instruction indicates some higher level knowledge that the\n/// end of the block cannot be reached.\n///\nclass UnreachableInst : public Instruction {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  UnreachableInst *cloneImpl() const;\n\npublic:\n  explicit UnreachableInst(LLVMContext &C, Instruction *InsertBefore = nullptr);\n  explicit UnreachableInst(LLVMContext &C, BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 0);\n  }\n\n  unsigned getNumSuccessors() const { return 0; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Unreachable;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned idx) const {\n    llvm_unreachable(\"UnreachableInst has no successors!\");\n  }\n\n  void setSuccessor(unsigned idx, BasicBlock *B) {\n    llvm_unreachable(\"UnreachableInst has no successors!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 TruncInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a truncation of integer types.\nclass TruncInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical TruncInst\n  TruncInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  TruncInst(\n    Value *S,                           ///< The value to be truncated\n    Type *Ty,                           ///< The (smaller) type to truncate to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  TruncInst(\n    Value *S,                     ///< The value to be truncated\n    Type *Ty,                     ///< The (smaller) type to truncate to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Trunc;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 ZExtInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents zero extension of integer types.\nclass ZExtInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical ZExtInst\n  ZExtInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  ZExtInst(\n    Value *S,                           ///< The value to be zero extended\n    Type *Ty,                           ///< The type to zero extend to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end semantics.\n  ZExtInst(\n    Value *S,                     ///< The value to be zero extended\n    Type *Ty,                     ///< The type to zero extend to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == ZExt;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 SExtInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a sign extension of integer types.\nclass SExtInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical SExtInst\n  SExtInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  SExtInst(\n    Value *S,                           ///< The value to be sign extended\n    Type *Ty,                           ///< The type to sign extend to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  SExtInst(\n    Value *S,                     ///< The value to be sign extended\n    Type *Ty,                     ///< The type to sign extend to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == SExt;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 FPTruncInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a truncation of floating point types.\nclass FPTruncInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FPTruncInst\n  FPTruncInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  FPTruncInst(\n    Value *S,                           ///< The value to be truncated\n    Type *Ty,                           ///< The type to truncate to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-before-instruction semantics\n  FPTruncInst(\n    Value *S,                     ///< The value to be truncated\n    Type *Ty,                     ///< The type to truncate to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == FPTrunc;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 FPExtInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents an extension of floating point types.\nclass FPExtInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FPExtInst\n  FPExtInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  FPExtInst(\n    Value *S,                           ///< The value to be extended\n    Type *Ty,                           ///< The type to extend to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  FPExtInst(\n    Value *S,                     ///< The value to be extended\n    Type *Ty,                     ///< The type to extend to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == FPExt;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 UIToFPInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast unsigned integer to floating point.\nclass UIToFPInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical UIToFPInst\n  UIToFPInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  UIToFPInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  UIToFPInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == UIToFP;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 SIToFPInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from signed integer to floating point.\nclass SIToFPInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical SIToFPInst\n  SIToFPInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  SIToFPInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  SIToFPInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == SIToFP;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 FPToUIInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from floating point to unsigned integer\nclass FPToUIInst  : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FPToUIInst\n  FPToUIInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  FPToUIInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  FPToUIInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< Where to insert the new instruction\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == FPToUI;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 FPToSIInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from floating point to signed integer.\nclass FPToSIInst  : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FPToSIInst\n  FPToSIInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  FPToSIInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  FPToSIInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == FPToSI;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 IntToPtrInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from an integer to a pointer.\nclass IntToPtrInst : public CastInst {\npublic:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Constructor with insert-before-instruction semantics\n  IntToPtrInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  IntToPtrInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Clone an identical IntToPtrInst.\n  IntToPtrInst *cloneImpl() const;\n\n  /// Returns the address space of this instruction's pointer type.\n  unsigned getAddressSpace() const {\n    return getType()->getPointerAddressSpace();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == IntToPtr;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 PtrToIntInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from a pointer to an integer.\nclass PtrToIntInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical PtrToIntInst.\n  PtrToIntInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  PtrToIntInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  PtrToIntInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Gets the pointer operand.\n  Value *getPointerOperand() { return getOperand(0); }\n  /// Gets the pointer operand.\n  const Value *getPointerOperand() const { return getOperand(0); }\n  /// Gets the operand index of the pointer operand.\n  static unsigned getPointerOperandIndex() { return 0U; }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == PtrToInt;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                             BitCastInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a no-op cast from one type to another.\nclass BitCastInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical BitCastInst.\n  BitCastInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  BitCastInst(\n    Value *S,                           ///< The value to be casted\n    Type *Ty,                           ///< The type to casted to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  BitCastInst(\n    Value *S,                     ///< The value to be casted\n    Type *Ty,                     ///< The type to casted to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == BitCast;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                          AddrSpaceCastInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a conversion between pointers from one address space\n/// to another.\nclass AddrSpaceCastInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical AddrSpaceCastInst.\n  AddrSpaceCastInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  AddrSpaceCastInst(\n    Value *S,                           ///< The value to be casted\n    Type *Ty,                           ///< The type to casted to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  AddrSpaceCastInst(\n    Value *S,                     ///< The value to be casted\n    Type *Ty,                     ///< The type to casted to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == AddrSpaceCast;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  /// Gets the pointer operand.\n  Value *getPointerOperand() {\n    return getOperand(0);\n  }\n\n  /// Gets the pointer operand.\n  const Value *getPointerOperand() const {\n    return getOperand(0);\n  }\n\n  /// Gets the operand index of the pointer operand.\n  static unsigned getPointerOperandIndex() {\n    return 0U;\n  }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getSrcAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  /// Returns the address space of the result.\n  unsigned getDestAddressSpace() const {\n    return getType()->getPointerAddressSpace();\n  }\n};\n\n/// A helper function that returns the pointer operand of a load or store\n/// instruction. Returns nullptr if not load or store.\ninline const Value *getLoadStorePointerOperand(const Value *V) {\n  if (auto *Load = dyn_cast<LoadInst>(V))\n    return Load->getPointerOperand();\n  if (auto *Store = dyn_cast<StoreInst>(V))\n    return Store->getPointerOperand();\n  return nullptr;\n}\ninline Value *getLoadStorePointerOperand(Value *V) {\n  return const_cast<Value *>(\n      getLoadStorePointerOperand(static_cast<const Value *>(V)));\n}\n\n/// A helper function that returns the pointer operand of a load, store\n/// or GEP instruction. Returns nullptr if not load, store, or GEP.\ninline const Value *getPointerOperand(const Value *V) {\n  if (auto *Ptr = getLoadStorePointerOperand(V))\n    return Ptr;\n  if (auto *Gep = dyn_cast<GetElementPtrInst>(V))\n    return Gep->getPointerOperand();\n  return nullptr;\n}\ninline Value *getPointerOperand(Value *V) {\n  return const_cast<Value *>(getPointerOperand(static_cast<const Value *>(V)));\n}\n\n/// A helper function that returns the alignment of load or store instruction.\ninline Align getLoadStoreAlignment(Value *I) {\n  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) &&\n         \"Expected Load or Store instruction\");\n  if (auto *LI = dyn_cast<LoadInst>(I))\n    return LI->getAlign();\n  return cast<StoreInst>(I)->getAlign();\n}\n\n/// A helper function that returns the address space of the pointer operand of\n/// load or store instruction.\ninline unsigned getLoadStoreAddressSpace(Value *I) {\n  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) &&\n         \"Expected Load or Store instruction\");\n  if (auto *LI = dyn_cast<LoadInst>(I))\n    return LI->getPointerAddressSpace();\n  return cast<StoreInst>(I)->getPointerAddressSpace();\n}\n\n//===----------------------------------------------------------------------===//\n//                              FreezeInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a freeze function that returns random concrete\n/// value if an operand is either a poison value or an undef value\nclass FreezeInst : public UnaryInstruction {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FreezeInst\n  FreezeInst *cloneImpl() const;\n\npublic:\n  explicit FreezeInst(Value *S,\n                      const Twine &NameStr = \"\",\n                      Instruction *InsertBefore = nullptr);\n  FreezeInst(Value *S, const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static inline bool classof(const Instruction *I) {\n    return I->getOpcode() == Freeze;\n  }\n  static inline bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_INSTRUCTIONS_H\n"}}, "reports": [{"events": [{"location": {"col": 21, "file": 3, "line": 3110}, "message": "the definition seen here"}, {"location": {"col": 20, "file": 2, "line": 553}, "message": "differing parameters are named here: ('S'), in definition: ('C')"}, {"location": {"col": 20, "file": 2, "line": 553}, "message": "function 'llvm::CastInst::CreateIntegerCast' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "06b4543f5d147b078e754097f4360ca0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 3, "line": 3124}, "message": "the definition seen here"}, {"location": {"col": 20, "file": 2, "line": 562}, "message": "differing parameters are named here: ('S'), in definition: ('C')"}, {"location": {"col": 20, "file": 2, "line": 562}, "message": "function 'llvm::CastInst::CreateIntegerCast' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "06b4543f5d147b078e754097f4360ca0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 3, "line": 3138}, "message": "the definition seen here"}, {"location": {"col": 20, "file": 2, "line": 571}, "message": "differing parameters are named here: ('S'), in definition: ('C')"}, {"location": {"col": 20, "file": 2, "line": 571}, "message": "function 'llvm::CastInst::CreateFPCast' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "9f59d15f0881d0ee093203040f1a76f4", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 3, "line": 3151}, "message": "the definition seen here"}, {"location": {"col": 20, "file": 2, "line": 579}, "message": "differing parameters are named here: ('S'), in definition: ('C')"}, {"location": {"col": 20, "file": 2, "line": 579}, "message": "function 'llvm::CastInst::CreateFPCast' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "9f59d15f0881d0ee093203040f1a76f4", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 3, "line": 3226}, "message": "the definition seen here"}, {"location": {"col": 31, "file": 2, "line": 621}, "message": "differing parameters are named here: ('Val', 'DstIsSigned'), in definition: ('Src', 'DestIsSigned')"}, {"location": {"col": 31, "file": 2, "line": 621}, "message": "function 'llvm::CastInst::getCastOpcode' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "d35113bd15b9e05c0dfdf370d8e75659", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 3, "line": 2685}, "message": "the definition seen here"}, {"location": {"col": 15, "file": 2, "line": 649}, "message": "differing parameters are named here: ('DstTy'), in definition: ('DestTy')"}, {"location": {"col": 15, "file": 2, "line": 649}, "message": "function 'llvm::CastInst::isNoopCast' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "4373a80d8a94d79ae26e29ca7e1ecad3", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 3, "line": 1181}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 2, "line": 2276}, "message": "differing parameters are named here: ('CPI'), in definition: ('FPI')"}, {"location": {"col": 3, "file": 2, "line": 2276}, "message": "function 'llvm::FuncletPadInst::FuncletPadInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "5dad4770f6f8c88e7df1d59559f1048e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 3, "line": 1410}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 193}, "message": "differing parameters are named here: ('InsertAtEnd'), in definition: ('InsertAE')"}, {"location": {"col": 3, "file": 4, "line": 193}, "message": "function 'llvm::LoadInst::LoadInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "ba5b4e83bbb723afbbd0d4620f9e50fe", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 3, "line": 1419}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 196}, "message": "differing parameters are named here: ('InsertAtEnd'), in definition: ('InsertAE')"}, {"location": {"col": 3, "file": 4, "line": 196}, "message": "function 'llvm::LoadInst::LoadInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "3be91604bf5b415472c020a05939abf2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 3, "line": 1429}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 200}, "message": "differing parameters are named here: ('InsertAtEnd'), in definition: ('InsertAE')"}, {"location": {"col": 3, "file": 4, "line": 200}, "message": "function 'llvm::LoadInst::LoadInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "3be91604bf5b415472c020a05939abf2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 3, "line": 1446}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 206}, "message": "differing parameters are named here: ('InsertAtEnd'), in definition: ('InsertAE')"}, {"location": {"col": 3, "file": 4, "line": 206}, "message": "function 'llvm::LoadInst::LoadInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "3be91604bf5b415472c020a05939abf2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 3, "line": 1473}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 320}, "message": "differing parameters are named here: ('Ptr'), in definition: ('addr')"}, {"location": {"col": 3, "file": 4, "line": 320}, "message": "function 'llvm::StoreInst::StoreInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "8291415225b92ff474f8001cca791580", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 3, "line": 1476}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 321}, "message": "differing parameters are named here: ('Ptr'), in definition: ('addr')"}, {"location": {"col": 3, "file": 4, "line": 321}, "message": "function 'llvm::StoreInst::StoreInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "445ee02f561a104ec7a4490e5842b398", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 3, "line": 1479}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 322}, "message": "differing parameters are named here: ('Ptr'), in definition: ('addr')"}, {"location": {"col": 3, "file": 4, "line": 322}, "message": "function 'llvm::StoreInst::StoreInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "d29b32f49831deb6d9bc4fda28458289", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 3, "line": 1485}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 323}, "message": "differing parameters are named here: ('Ptr'), in definition: ('addr')"}, {"location": {"col": 3, "file": 4, "line": 323}, "message": "function 'llvm::StoreInst::StoreInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "c4688c9f3faa82070661a184d8629502", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 3, "line": 1491}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 324}, "message": "differing parameters are named here: ('Ptr'), in definition: ('addr')"}, {"location": {"col": 3, "file": 4, "line": 324}, "message": "function 'llvm::StoreInst::StoreInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "a049c005ad2ef049808a6c13eecc98f2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 3, "line": 1496}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 326}, "message": "differing parameters are named here: ('Ptr'), in definition: ('addr')"}, {"location": {"col": 3, "file": 4, "line": 326}, "message": "function 'llvm::StoreInst::StoreInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "a049c005ad2ef049808a6c13eecc98f2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 3, "line": 1501}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 328}, "message": "differing parameters are named here: ('Ptr'), in definition: ('addr')"}, {"location": {"col": 3, "file": 4, "line": 328}, "message": "function 'llvm::StoreInst::StoreInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "a049c005ad2ef049808a6c13eecc98f2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 3, "line": 1515}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 331}, "message": "differing parameters are named here: ('Ptr'), in definition: ('addr')"}, {"location": {"col": 3, "file": 4, "line": 331}, "message": "function 'llvm::StoreInst::StoreInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "a049c005ad2ef049808a6c13eecc98f2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 3, "line": 524}, "message": "the definition seen here"}, {"location": {"col": 20, "file": 4, "line": 1585}, "message": "differing parameters are named here: ('Bundles'), in definition: ('OpB')"}, {"location": {"col": 20, "file": 4, "line": 1585}, "message": "function 'llvm::CallInst::Create' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "6073e5074d85f00e32221c11dc6575b5", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 3, "line": 538}, "message": "the definition seen here"}, {"location": {"col": 20, "file": 4, "line": 1594}, "message": "differing parameters are named here: ('Bundle'), in definition: ('OpB')"}, {"location": {"col": 20, "file": 4, "line": 1594}, "message": "function 'llvm::CallInst::CreateWithReplacedBundle' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "681c28cd6657e829a523c2a2ef1b212d", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 3, "line": 706}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 1614}, "message": "differing parameters are named here: ('Bundles'), in definition: ('OpB')"}, {"location": {"col": 23, "file": 4, "line": 1614}, "message": "function 'llvm::CallInst::CreateMalloc' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "cc3afb3e4ebf32173f6d45a18ebf9be6", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 3, "line": 731}, "message": "the definition seen here"}, {"location": {"col": 23, "file": 4, "line": 1620}, "message": "differing parameters are named here: ('Bundles'), in definition: ('OpB')"}, {"location": {"col": 23, "file": 4, "line": 1620}, "message": "function 'llvm::CallInst::CreateMalloc' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "338595d08a0270c68ee0acd87b7399d8", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 3, "line": 71}, "message": "the definition seen here"}, {"location": {"col": 22, "file": 4, "line": 1789}, "message": "differing parameters are named here: ('Cond', 'True', 'False'), in definition: ('Op0', 'Op1', 'Op2')"}, {"location": {"col": 22, "file": 4, "line": 1789}, "message": "function 'llvm::SelectInst::areInvalidOperands' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "64d080f4ed529640a342fb8ab6fe51e9", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 3, "line": 1812}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 1861}, "message": "differing parameters are named here: ('Vec', 'Idx'), in definition: ('Val', 'Index')"}, {"location": {"col": 3, "file": 4, "line": 1861}, "message": "function 'llvm::ExtractElementInst::ExtractElementInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "857b5452f04ae6e5b728b91affc97d68", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 3, "line": 1826}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 1863}, "message": "differing parameters are named here: ('Vec', 'Idx', 'InsertAtEnd'), in definition: ('Val', 'Index', 'InsertAE')"}, {"location": {"col": 3, "file": 4, "line": 1863}, "message": "function 'llvm::ExtractElementInst::ExtractElementInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "d5e21f04d13d97f4b08107b7abad1dfa", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 3, "line": 1841}, "message": "the definition seen here"}, {"location": {"col": 15, "file": 4, "line": 1887}, "message": "differing parameters are named here: ('Vec', 'Idx'), in definition: ('Val', 'Index')"}, {"location": {"col": 15, "file": 4, "line": 1887}, "message": "function 'llvm::ExtractElementInst::isValidOperands' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "48858129545fca5fa8f0549cc0c54c82", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 3, "line": 1851}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 1925}, "message": "differing parameters are named here: ('Idx'), in definition: ('Index')"}, {"location": {"col": 3, "file": 4, "line": 1925}, "message": "function 'llvm::InsertElementInst::InsertElementInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "52d774f137eb20b83070119cf25335ca", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 3, "line": 1865}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 1928}, "message": "differing parameters are named here: ('Idx', 'InsertAtEnd'), in definition: ('Index', 'InsertAE')"}, {"location": {"col": 3, "file": 4, "line": 1928}, "message": "function 'llvm::InsertElementInst::InsertElementInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "c3ffab4669e1b4abd203b49106a36b93", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 3, "line": 1880}, "message": "the definition seen here"}, {"location": {"col": 15, "file": 4, "line": 1952}, "message": "differing parameters are named here: ('Idx'), in definition: ('Index')"}, {"location": {"col": 15, "file": 4, "line": 1952}, "message": "function 'llvm::InsertElementInst::isValidOperands' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "a9eca29b5821a7dbd7dc4fac2026067e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 3, "line": 4250}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 3572}, "message": "differing parameters are named here: ('NumDests'), in definition: ('NumCases')"}, {"location": {"col": 3, "file": 4, "line": 3572}, "message": "function 'llvm::IndirectBrInst::IndirectBrInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "60b733c2582be4cd7b33094fee56bc34", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 3, "line": 4257}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 3578}, "message": "differing parameters are named here: ('NumDests'), in definition: ('NumCases')"}, {"location": {"col": 3, "file": 4, "line": 3578}, "message": "function 'llvm::IndirectBrInst::IndirectBrInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "5a3b74d6b0f12cfe842a22f063a613a9", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 3, "line": 837}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 3707}, "message": "differing parameters are named here: ('BI'), in definition: ('II')"}, {"location": {"col": 3, "file": 4, "line": 3707}, "message": "function 'llvm::InvokeInst::InvokeInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "88efd3409909cf5ce4df4b6c41c83ab6", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 3, "line": 804}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 4, "line": 3722}, "message": "differing parameters are named here: ('Func'), in definition: ('Fn')"}, {"location": {"col": 8, "file": 4, "line": 3722}, "message": "function 'llvm::InvokeInst::init' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "8fae7b1d760dc6acc29eb5de8449f72a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 3, "line": 848}, "message": "the definition seen here"}, {"location": {"col": 22, "file": 4, "line": 3824}, "message": "differing parameters are named here: ('Bundles'), in definition: ('OpB')"}, {"location": {"col": 22, "file": 4, "line": 3824}, "message": "function 'llvm::InvokeInst::Create' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "c3e4fcaf08e17c92f2bb4f77def1ca49", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 3, "line": 862}, "message": "the definition seen here"}, {"location": {"col": 22, "file": 4, "line": 3833}, "message": "differing parameters are named here: ('Bundles'), in definition: ('OpB')"}, {"location": {"col": 22, "file": 4, "line": 3833}, "message": "function 'llvm::InvokeInst::CreateWithReplacedBundle' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "2c9488ec92a67c2e269f5effc5a2e953", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 3, "line": 883}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 4, "line": 3936}, "message": "differing parameters are named here: ('Func', 'DefaultDest'), in definition: ('Fn', 'Fallthrough')"}, {"location": {"col": 8, "file": 4, "line": 3936}, "message": "function 'llvm::CallBrInst::init' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "0aa73a39fd393678c60edc0322cb955b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 3, "line": 943}, "message": "the definition seen here"}, {"location": {"col": 22, "file": 4, "line": 4053}, "message": "differing parameters are named here: ('Bundles'), in definition: ('OpB')"}, {"location": {"col": 22, "file": 4, "line": 4053}, "message": "function 'llvm::CallBrInst::Create' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "7906825247c423db7abee10c207382d3", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 3, "line": 1091}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 4229}, "message": "differing parameters are named here: ('NumHandlers'), in definition: ('NumReservedValues')"}, {"location": {"col": 3, "file": 4, "line": 4229}, "message": "function 'llvm::CatchSwitchInst::CatchSwitchInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "870308c0ef3e6e50b89373e6b6dd93c0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 3, "line": 1103}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 4, "line": 4237}, "message": "differing parameters are named here: ('NumHandlers'), in definition: ('NumReservedValues')"}, {"location": {"col": 3, "file": 4, "line": 4237}, "message": "function 'llvm::CatchSwitchInst::CatchSwitchInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "870308c0ef3e6e50b89373e6b6dd93c0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 3, "line": 1151}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 4, "line": 4356}, "message": "differing parameters are named here: ('Dest'), in definition: ('Handler')"}, {"location": {"col": 8, "file": 4, "line": 4356}, "message": "function 'llvm::CatchSwitchInst::addHandler' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "cc4070a1ba9fe962021bc68ba503d418", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
