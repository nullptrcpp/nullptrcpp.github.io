<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/lldb/source/Target/Process.cpp", "content": "//===-- Process.cpp -------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include <atomic>\n#include <memory>\n#include <mutex>\n\n#include \"llvm/Support/ScopedPrinter.h\"\n#include \"llvm/Support/Threading.h\"\n\n#include \"lldb/Breakpoint/BreakpointLocation.h\"\n#include \"lldb/Breakpoint/StoppointCallbackContext.h\"\n#include \"lldb/Core/Debugger.h\"\n#include \"lldb/Core/Module.h\"\n#include \"lldb/Core/ModuleSpec.h\"\n#include \"lldb/Core/PluginManager.h\"\n#include \"lldb/Core/StreamFile.h\"\n#include \"lldb/Expression/DiagnosticManager.h\"\n#include \"lldb/Expression/DynamicCheckerFunctions.h\"\n#include \"lldb/Expression/UserExpression.h\"\n#include \"lldb/Expression/UtilityFunction.h\"\n#include \"lldb/Host/ConnectionFileDescriptor.h\"\n#include \"lldb/Host/FileSystem.h\"\n#include \"lldb/Host/Host.h\"\n#include \"lldb/Host/HostInfo.h\"\n#include \"lldb/Host/OptionParser.h\"\n#include \"lldb/Host/Pipe.h\"\n#include \"lldb/Host/Terminal.h\"\n#include \"lldb/Host/ThreadLauncher.h\"\n#include \"lldb/Interpreter/CommandInterpreter.h\"\n#include \"lldb/Interpreter/OptionArgParser.h\"\n#include \"lldb/Interpreter/OptionValueProperties.h\"\n#include \"lldb/Symbol/Function.h\"\n#include \"lldb/Symbol/Symbol.h\"\n#include \"lldb/Target/ABI.h\"\n#include \"lldb/Target/AssertFrameRecognizer.h\"\n#include \"lldb/Target/DynamicLoader.h\"\n#include \"lldb/Target/InstrumentationRuntime.h\"\n#include \"lldb/Target/JITLoader.h\"\n#include \"lldb/Target/JITLoaderList.h\"\n#include \"lldb/Target/Language.h\"\n#include \"lldb/Target/LanguageRuntime.h\"\n#include \"lldb/Target/MemoryHistory.h\"\n#include \"lldb/Target/MemoryRegionInfo.h\"\n#include \"lldb/Target/OperatingSystem.h\"\n#include \"lldb/Target/Platform.h\"\n#include \"lldb/Target/Process.h\"\n#include \"lldb/Target/RegisterContext.h\"\n#include \"lldb/Target/StopInfo.h\"\n#include \"lldb/Target/StructuredDataPlugin.h\"\n#include \"lldb/Target/SystemRuntime.h\"\n#include \"lldb/Target/Target.h\"\n#include \"lldb/Target/TargetList.h\"\n#include \"lldb/Target/Thread.h\"\n#include \"lldb/Target/ThreadPlan.h\"\n#include \"lldb/Target/ThreadPlanBase.h\"\n#include \"lldb/Target/ThreadPlanCallFunction.h\"\n#include \"lldb/Target/ThreadPlanStack.h\"\n#include \"lldb/Target/UnixSignals.h\"\n#include \"lldb/Utility/Event.h\"\n#include \"lldb/Utility/Log.h\"\n#include \"lldb/Utility/NameMatches.h\"\n#include \"lldb/Utility/ProcessInfo.h\"\n#include \"lldb/Utility/SelectHelper.h\"\n#include \"lldb/Utility/State.h\"\n\nusing namespace lldb;\nusing namespace lldb_private;\nusing namespace std::chrono;\n\n// Comment out line below to disable memory caching, overriding the process\n// setting target.process.disable-memory-cache\n#define ENABLE_MEMORY_CACHING\n\n#ifdef ENABLE_MEMORY_CACHING\n#define DISABLE_MEM_CACHE_DEFAULT false\n#else\n#define DISABLE_MEM_CACHE_DEFAULT true\n#endif\n\nclass ProcessOptionValueProperties\n    : public Cloneable<ProcessOptionValueProperties, OptionValueProperties> {\npublic:\n  ProcessOptionValueProperties(ConstString name) : Cloneable(name) {}\n\n  const Property *GetPropertyAtIndex(const ExecutionContext *exe_ctx,\n                                     bool will_modify,\n                                     uint32_t idx) const override {\n    // When getting the value for a key from the process options, we will\n    // always try and grab the setting from the current process if there is\n    // one. Else we just use the one from this instance.\n    if (exe_ctx) {\n      Process *process = exe_ctx->GetProcessPtr();\n      if (process) {\n        ProcessOptionValueProperties *instance_properties =\n            static_cast<ProcessOptionValueProperties *>(\n                process->GetValueProperties().get());\n        if (this != instance_properties)\n          return instance_properties->ProtectedGetPropertyAtIndex(idx);\n      }\n    }\n    return ProtectedGetPropertyAtIndex(idx);\n  }\n};\n\n#define LLDB_PROPERTIES_process\n#include \"TargetProperties.inc\"\n\nenum {\n#define LLDB_PROPERTIES_process\n#include \"TargetPropertiesEnum.inc\"\n  ePropertyExperimental,\n};\n\n#define LLDB_PROPERTIES_process_experimental\n#include \"TargetProperties.inc\"\n\nenum {\n#define LLDB_PROPERTIES_process_experimental\n#include \"TargetPropertiesEnum.inc\"\n};\n\nclass ProcessExperimentalOptionValueProperties\n    : public Cloneable<ProcessExperimentalOptionValueProperties,\n                       OptionValueProperties> {\npublic:\n  ProcessExperimentalOptionValueProperties()\n      : Cloneable(\n            ConstString(Properties::GetExperimentalSettingsName())) {}\n};\n\nProcessExperimentalProperties::ProcessExperimentalProperties()\n    : Properties(OptionValuePropertiesSP(\n          new ProcessExperimentalOptionValueProperties())) {\n  m_collection_sp->Initialize(g_process_experimental_properties);\n}\n\nProcessProperties::ProcessProperties(lldb_private::Process *process)\n    : Properties(),\n      m_process(process) // Can be nullptr for global ProcessProperties\n{\n  if (process == nullptr) {\n    // Global process properties, set them up one time\n    m_collection_sp =\n        std::make_shared<ProcessOptionValueProperties>(ConstString(\"process\"));\n    m_collection_sp->Initialize(g_process_properties);\n    m_collection_sp->AppendProperty(\n        ConstString(\"thread\"), ConstString(\"Settings specific to threads.\"),\n        true, Thread::GetGlobalProperties()->GetValueProperties());\n  } else {\n    m_collection_sp =\n        OptionValueProperties::CreateLocalCopy(*Process::GetGlobalProperties());\n    m_collection_sp->SetValueChangedCallback(\n        ePropertyPythonOSPluginPath,\n        [this] { m_process->LoadOperatingSystemPlugin(true); });\n  }\n\n  m_experimental_properties_up =\n      std::make_unique<ProcessExperimentalProperties>();\n  m_collection_sp->AppendProperty(\n      ConstString(Properties::GetExperimentalSettingsName()),\n      ConstString(\"Experimental settings - setting these won't produce \"\n                  \"errors if the setting is not present.\"),\n      true, m_experimental_properties_up->GetValueProperties());\n}\n\nProcessProperties::~ProcessProperties() = default;\n\nbool ProcessProperties::GetDisableMemoryCache() const {\n  const uint32_t idx = ePropertyDisableMemCache;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nuint64_t ProcessProperties::GetMemoryCacheLineSize() const {\n  const uint32_t idx = ePropertyMemCacheLineSize;\n  return m_collection_sp->GetPropertyAtIndexAsUInt64(\n      nullptr, idx, g_process_properties[idx].default_uint_value);\n}\n\nArgs ProcessProperties::GetExtraStartupCommands() const {\n  Args args;\n  const uint32_t idx = ePropertyExtraStartCommand;\n  m_collection_sp->GetPropertyAtIndexAsArgs(nullptr, idx, args);\n  return args;\n}\n\nvoid ProcessProperties::SetExtraStartupCommands(const Args &args) {\n  const uint32_t idx = ePropertyExtraStartCommand;\n  m_collection_sp->SetPropertyAtIndexFromArgs(nullptr, idx, args);\n}\n\nFileSpec ProcessProperties::GetPythonOSPluginPath() const {\n  const uint32_t idx = ePropertyPythonOSPluginPath;\n  return m_collection_sp->GetPropertyAtIndexAsFileSpec(nullptr, idx);\n}\n\nuint32_t ProcessProperties::GetVirtualAddressableBits() const {\n  const uint32_t idx = ePropertyVirtualAddressableBits;\n  return m_collection_sp->GetPropertyAtIndexAsUInt64(\n      nullptr, idx, g_process_properties[idx].default_uint_value);\n}\n\nvoid ProcessProperties::SetVirtualAddressableBits(uint32_t bits) {\n  const uint32_t idx = ePropertyVirtualAddressableBits;\n  m_collection_sp->SetPropertyAtIndexAsUInt64(nullptr, idx, bits);\n}\nvoid ProcessProperties::SetPythonOSPluginPath(const FileSpec &file) {\n  const uint32_t idx = ePropertyPythonOSPluginPath;\n  m_collection_sp->SetPropertyAtIndexAsFileSpec(nullptr, idx, file);\n}\n\nbool ProcessProperties::GetIgnoreBreakpointsInExpressions() const {\n  const uint32_t idx = ePropertyIgnoreBreakpointsInExpressions;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nvoid ProcessProperties::SetIgnoreBreakpointsInExpressions(bool ignore) {\n  const uint32_t idx = ePropertyIgnoreBreakpointsInExpressions;\n  m_collection_sp->SetPropertyAtIndexAsBoolean(nullptr, idx, ignore);\n}\n\nbool ProcessProperties::GetUnwindOnErrorInExpressions() const {\n  const uint32_t idx = ePropertyUnwindOnErrorInExpressions;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nvoid ProcessProperties::SetUnwindOnErrorInExpressions(bool ignore) {\n  const uint32_t idx = ePropertyUnwindOnErrorInExpressions;\n  m_collection_sp->SetPropertyAtIndexAsBoolean(nullptr, idx, ignore);\n}\n\nbool ProcessProperties::GetStopOnSharedLibraryEvents() const {\n  const uint32_t idx = ePropertyStopOnSharedLibraryEvents;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nvoid ProcessProperties::SetStopOnSharedLibraryEvents(bool stop) {\n  const uint32_t idx = ePropertyStopOnSharedLibraryEvents;\n  m_collection_sp->SetPropertyAtIndexAsBoolean(nullptr, idx, stop);\n}\n\nbool ProcessProperties::GetDisableLangRuntimeUnwindPlans() const {\n  const uint32_t idx = ePropertyDisableLangRuntimeUnwindPlans;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nvoid ProcessProperties::SetDisableLangRuntimeUnwindPlans(bool disable) {\n  const uint32_t idx = ePropertyDisableLangRuntimeUnwindPlans;\n  m_collection_sp->SetPropertyAtIndexAsBoolean(nullptr, idx, disable);\n  m_process->Flush();\n}\n\nbool ProcessProperties::GetDetachKeepsStopped() const {\n  const uint32_t idx = ePropertyDetachKeepsStopped;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nvoid ProcessProperties::SetDetachKeepsStopped(bool stop) {\n  const uint32_t idx = ePropertyDetachKeepsStopped;\n  m_collection_sp->SetPropertyAtIndexAsBoolean(nullptr, idx, stop);\n}\n\nbool ProcessProperties::GetWarningsOptimization() const {\n  const uint32_t idx = ePropertyWarningOptimization;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nbool ProcessProperties::GetWarningsUnsupportedLanguage() const {\n  const uint32_t idx = ePropertyWarningUnsupportedLanguage;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nbool ProcessProperties::GetStopOnExec() const {\n  const uint32_t idx = ePropertyStopOnExec;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nstd::chrono::seconds ProcessProperties::GetUtilityExpressionTimeout() const {\n  const uint32_t idx = ePropertyUtilityExpressionTimeout;\n  uint64_t value = m_collection_sp->GetPropertyAtIndexAsUInt64(\n      nullptr, idx, g_process_properties[idx].default_uint_value);\n  return std::chrono::seconds(value);\n}\n\nbool ProcessProperties::GetSteppingRunsAllThreads() const {\n  const uint32_t idx = ePropertySteppingRunsAllThreads;\n  return m_collection_sp->GetPropertyAtIndexAsBoolean(\n      nullptr, idx, g_process_properties[idx].default_uint_value != 0);\n}\n\nbool ProcessProperties::GetOSPluginReportsAllThreads() const {\n  const bool fail_value = true;\n  const Property *exp_property =\n      m_collection_sp->GetPropertyAtIndex(nullptr, true, ePropertyExperimental);\n  OptionValueProperties *exp_values =\n      exp_property->GetValue()->GetAsProperties();\n  if (!exp_values)\n    return fail_value;\n\n  return exp_values->GetPropertyAtIndexAsBoolean(\n      nullptr, ePropertyOSPluginReportsAllThreads, fail_value);\n}\n\nvoid ProcessProperties::SetOSPluginReportsAllThreads(bool does_report) {\n  const Property *exp_property =\n      m_collection_sp->GetPropertyAtIndex(nullptr, true, ePropertyExperimental);\n  OptionValueProperties *exp_values =\n      exp_property->GetValue()->GetAsProperties();\n  if (exp_values)\n    exp_values->SetPropertyAtIndexAsBoolean(\n        nullptr, ePropertyOSPluginReportsAllThreads, does_report);\n}\n\nProcessSP Process::FindPlugin(lldb::TargetSP target_sp,\n                              llvm::StringRef plugin_name,\n                              ListenerSP listener_sp,\n                              const FileSpec *crash_file_path,\n                              bool can_connect) {\n  static uint32_t g_process_unique_id = 0;\n\n  ProcessSP process_sp;\n  ProcessCreateInstance create_callback = nullptr;\n  if (!plugin_name.empty()) {\n    ConstString const_plugin_name(plugin_name);\n    create_callback =\n        PluginManager::GetProcessCreateCallbackForPluginName(const_plugin_name);\n    if (create_callback) {\n      process_sp = create_callback(target_sp, listener_sp, crash_file_path,\n                                   can_connect);\n      if (process_sp) {\n        if (process_sp->CanDebug(target_sp, true)) {\n          process_sp->m_process_unique_id = ++g_process_unique_id;\n        } else\n          process_sp.reset();\n      }\n    }\n  } else {\n    for (uint32_t idx = 0;\n         (create_callback =\n              PluginManager::GetProcessCreateCallbackAtIndex(idx)) != nullptr;\n         ++idx) {\n      process_sp = create_callback(target_sp, listener_sp, crash_file_path,\n                                   can_connect);\n      if (process_sp) {\n        if (process_sp->CanDebug(target_sp, false)) {\n          process_sp->m_process_unique_id = ++g_process_unique_id;\n          break;\n        } else\n          process_sp.reset();\n      }\n    }\n  }\n  return process_sp;\n}\n\nConstString &Process::GetStaticBroadcasterClass() {\n  static ConstString class_name(\"lldb.process\");\n  return class_name;\n}\n\nProcess::Process(lldb::TargetSP target_sp, ListenerSP listener_sp)\n    : Process(target_sp, listener_sp,\n              UnixSignals::Create(HostInfo::GetArchitecture())) {\n  // This constructor just delegates to the full Process constructor,\n  // defaulting to using the Host's UnixSignals.\n}\n\nProcess::Process(lldb::TargetSP target_sp, ListenerSP listener_sp,\n                 const UnixSignalsSP &unix_signals_sp)\n    : ProcessProperties(this),\n      Broadcaster((target_sp->GetDebugger().GetBroadcasterManager()),\n                  Process::GetStaticBroadcasterClass().AsCString()),\n      m_target_wp(target_sp), m_public_state(eStateUnloaded),\n      m_private_state(eStateUnloaded),\n      m_private_state_broadcaster(nullptr,\n                                  \"lldb.process.internal_state_broadcaster\"),\n      m_private_state_control_broadcaster(\n          nullptr, \"lldb.process.internal_state_control_broadcaster\"),\n      m_private_state_listener_sp(\n          Listener::MakeListener(\"lldb.process.internal_state_listener\")),\n      m_mod_id(), m_process_unique_id(0), m_thread_index_id(0),\n      m_thread_id_to_index_id_map(), m_exit_status(-1), m_exit_string(),\n      m_exit_status_mutex(), m_thread_mutex(), m_thread_list_real(this),\n      m_thread_list(this), m_thread_plans(*this), m_extended_thread_list(this),\n      m_extended_thread_stop_id(0), m_queue_list(this), m_queue_list_stop_id(0),\n      m_notifications(), m_image_tokens(), m_listener_sp(listener_sp),\n      m_breakpoint_site_list(), m_dynamic_checkers_up(),\n      m_unix_signals_sp(unix_signals_sp), m_abi_sp(), m_process_input_reader(),\n      m_stdio_communication(\"process.stdio\"), m_stdio_communication_mutex(),\n      m_stdin_forward(false), m_stdout_data(), m_stderr_data(),\n      m_profile_data_comm_mutex(), m_profile_data(), m_iohandler_sync(0),\n      m_memory_cache(*this), m_allocated_memory_cache(*this),\n      m_should_detach(false), m_next_event_action_up(), m_public_run_lock(),\n      m_private_run_lock(), m_finalizing(false),\n      m_clear_thread_plans_on_stop(false), m_force_next_event_delivery(false),\n      m_last_broadcast_state(eStateInvalid), m_destroy_in_process(false),\n      m_can_interpret_function_calls(false), m_warnings_issued(),\n      m_run_thread_plan_lock(), m_can_jit(eCanJITDontKnow) {\n  CheckInWithManager();\n\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_OBJECT));\n  LLDB_LOGF(log, \"%p Process::Process()\", static_cast<void *>(this));\n\n  if (!m_unix_signals_sp)\n    m_unix_signals_sp = std::make_shared<UnixSignals>();\n\n  SetEventName(eBroadcastBitStateChanged, \"state-changed\");\n  SetEventName(eBroadcastBitInterrupt, \"interrupt\");\n  SetEventName(eBroadcastBitSTDOUT, \"stdout-available\");\n  SetEventName(eBroadcastBitSTDERR, \"stderr-available\");\n  SetEventName(eBroadcastBitProfileData, \"profile-data-available\");\n  SetEventName(eBroadcastBitStructuredData, \"structured-data-available\");\n\n  m_private_state_control_broadcaster.SetEventName(\n      eBroadcastInternalStateControlStop, \"control-stop\");\n  m_private_state_control_broadcaster.SetEventName(\n      eBroadcastInternalStateControlPause, \"control-pause\");\n  m_private_state_control_broadcaster.SetEventName(\n      eBroadcastInternalStateControlResume, \"control-resume\");\n\n  m_listener_sp->StartListeningForEvents(\n      this, eBroadcastBitStateChanged | eBroadcastBitInterrupt |\n                eBroadcastBitSTDOUT | eBroadcastBitSTDERR |\n                eBroadcastBitProfileData | eBroadcastBitStructuredData);\n\n  m_private_state_listener_sp->StartListeningForEvents(\n      &m_private_state_broadcaster,\n      eBroadcastBitStateChanged | eBroadcastBitInterrupt);\n\n  m_private_state_listener_sp->StartListeningForEvents(\n      &m_private_state_control_broadcaster,\n      eBroadcastInternalStateControlStop | eBroadcastInternalStateControlPause |\n          eBroadcastInternalStateControlResume);\n  // We need something valid here, even if just the default UnixSignalsSP.\n  assert(m_unix_signals_sp && \"null m_unix_signals_sp after initialization\");\n\n  // Allow the platform to override the default cache line size\n  OptionValueSP value_sp =\n      m_collection_sp\n          ->GetPropertyAtIndex(nullptr, true, ePropertyMemCacheLineSize)\n          ->GetValue();\n  uint32_t platform_cache_line_size =\n      target_sp->GetPlatform()->GetDefaultMemoryCacheLineSize();\n  if (!value_sp->OptionWasSet() && platform_cache_line_size != 0)\n    value_sp->SetUInt64Value(platform_cache_line_size);\n\n  RegisterAssertFrameRecognizer(this);\n}\n\nProcess::~Process() {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_OBJECT));\n  LLDB_LOGF(log, \"%p Process::~Process()\", static_cast<void *>(this));\n  StopPrivateStateThread();\n\n  // ThreadList::Clear() will try to acquire this process's mutex, so\n  // explicitly clear the thread list here to ensure that the mutex is not\n  // destroyed before the thread list.\n  m_thread_list.Clear();\n}\n\nconst ProcessPropertiesSP &Process::GetGlobalProperties() {\n  // NOTE: intentional leak so we don't crash if global destructor chain gets\n  // called as other threads still use the result of this function\n  static ProcessPropertiesSP *g_settings_sp_ptr =\n      new ProcessPropertiesSP(new ProcessProperties(nullptr));\n  return *g_settings_sp_ptr;\n}\n\nvoid Process::Finalize() {\n  if (m_finalizing.exchange(true))\n    return;\n\n  // Destroy this process if needed\n  switch (GetPrivateState()) {\n  case eStateConnected:\n  case eStateAttaching:\n  case eStateLaunching:\n  case eStateStopped:\n  case eStateRunning:\n  case eStateStepping:\n  case eStateCrashed:\n  case eStateSuspended:\n    DestroyImpl(false);\n    break;\n\n  case eStateInvalid:\n  case eStateUnloaded:\n  case eStateDetached:\n  case eStateExited:\n    break;\n  }\n\n  // Clear our broadcaster before we proceed with destroying\n  Broadcaster::Clear();\n\n  // Do any cleanup needed prior to being destructed... Subclasses that\n  // override this method should call this superclass method as well.\n\n  // We need to destroy the loader before the derived Process class gets\n  // destroyed since it is very likely that undoing the loader will require\n  // access to the real process.\n  m_dynamic_checkers_up.reset();\n  m_abi_sp.reset();\n  m_os_up.reset();\n  m_system_runtime_up.reset();\n  m_dyld_up.reset();\n  m_jit_loaders_up.reset();\n  m_thread_plans.Clear();\n  m_thread_list_real.Destroy();\n  m_thread_list.Destroy();\n  m_extended_thread_list.Destroy();\n  m_queue_list.Clear();\n  m_queue_list_stop_id = 0;\n  std::vector<Notifications> empty_notifications;\n  m_notifications.swap(empty_notifications);\n  m_image_tokens.clear();\n  m_memory_cache.Clear();\n  m_allocated_memory_cache.Clear();\n  {\n    std::lock_guard<std::recursive_mutex> guard(m_language_runtimes_mutex);\n    m_language_runtimes.clear();\n  }\n  m_instrumentation_runtimes.clear();\n  m_next_event_action_up.reset();\n  // Clear the last natural stop ID since it has a strong reference to this\n  // process\n  m_mod_id.SetStopEventForLastNaturalStopID(EventSP());\n  //#ifdef LLDB_CONFIGURATION_DEBUG\n  //    StreamFile s(stdout, false);\n  //    EventSP event_sp;\n  //    while (m_private_state_listener_sp->GetNextEvent(event_sp))\n  //    {\n  //        event_sp->Dump (&s);\n  //        s.EOL();\n  //    }\n  //#endif\n  // We have to be very careful here as the m_private_state_listener might\n  // contain events that have ProcessSP values in them which can keep this\n  // process around forever. These events need to be cleared out.\n  m_private_state_listener_sp->Clear();\n  m_public_run_lock.TrySetRunning(); // This will do nothing if already locked\n  m_public_run_lock.SetStopped();\n  m_private_run_lock.TrySetRunning(); // This will do nothing if already locked\n  m_private_run_lock.SetStopped();\n  m_structured_data_plugin_map.clear();\n}\n\nvoid Process::RegisterNotificationCallbacks(const Notifications &callbacks) {\n  m_notifications.push_back(callbacks);\n  if (callbacks.initialize != nullptr)\n    callbacks.initialize(callbacks.baton, this);\n}\n\nbool Process::UnregisterNotificationCallbacks(const Notifications &callbacks) {\n  std::vector<Notifications>::iterator pos, end = m_notifications.end();\n  for (pos = m_notifications.begin(); pos != end; ++pos) {\n    if (pos->baton == callbacks.baton &&\n        pos->initialize == callbacks.initialize &&\n        pos->process_state_changed == callbacks.process_state_changed) {\n      m_notifications.erase(pos);\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid Process::SynchronouslyNotifyStateChanged(StateType state) {\n  std::vector<Notifications>::iterator notification_pos,\n      notification_end = m_notifications.end();\n  for (notification_pos = m_notifications.begin();\n       notification_pos != notification_end; ++notification_pos) {\n    if (notification_pos->process_state_changed)\n      notification_pos->process_state_changed(notification_pos->baton, this,\n                                              state);\n  }\n}\n\n// FIXME: We need to do some work on events before the general Listener sees\n// them.\n// For instance if we are continuing from a breakpoint, we need to ensure that\n// we do the little \"insert real insn, step & stop\" trick.  But we can't do\n// that when the event is delivered by the broadcaster - since that is done on\n// the thread that is waiting for new events, so if we needed more than one\n// event for our handling, we would stall.  So instead we do it when we fetch\n// the event off of the queue.\n//\n\nStateType Process::GetNextEvent(EventSP &event_sp) {\n  StateType state = eStateInvalid;\n\n  if (m_listener_sp->GetEventForBroadcaster(this, event_sp,\n                                            std::chrono::seconds(0)) &&\n      event_sp)\n    state = Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n\n  return state;\n}\n\nvoid Process::SyncIOHandler(uint32_t iohandler_id,\n                            const Timeout<std::micro> &timeout) {\n  // don't sync (potentially context switch) in case where there is no process\n  // IO\n  if (!m_process_input_reader)\n    return;\n\n  auto Result = m_iohandler_sync.WaitForValueNotEqualTo(iohandler_id, timeout);\n\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  if (Result) {\n    LLDB_LOG(\n        log,\n        \"waited from m_iohandler_sync to change from {0}. New value is {1}.\",\n        iohandler_id, *Result);\n  } else {\n    LLDB_LOG(log, \"timed out waiting for m_iohandler_sync to change from {0}.\",\n             iohandler_id);\n  }\n}\n\nStateType Process::WaitForProcessToStop(const Timeout<std::micro> &timeout,\n                                        EventSP *event_sp_ptr, bool wait_always,\n                                        ListenerSP hijack_listener_sp,\n                                        Stream *stream, bool use_run_lock) {\n  // We can't just wait for a \"stopped\" event, because the stopped event may\n  // have restarted the target. We have to actually check each event, and in\n  // the case of a stopped event check the restarted flag on the event.\n  if (event_sp_ptr)\n    event_sp_ptr->reset();\n  StateType state = GetState();\n  // If we are exited or detached, we won't ever get back to any other valid\n  // state...\n  if (state == eStateDetached || state == eStateExited)\n    return state;\n\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOG(log, \"timeout = {0}\", timeout);\n\n  if (!wait_always && StateIsStoppedState(state, true) &&\n      StateIsStoppedState(GetPrivateState(), true)) {\n    LLDB_LOGF(log,\n              \"Process::%s returning without waiting for events; process \"\n              \"private and public states are already 'stopped'.\",\n              __FUNCTION__);\n    // We need to toggle the run lock as this won't get done in\n    // SetPublicState() if the process is hijacked.\n    if (hijack_listener_sp && use_run_lock)\n      m_public_run_lock.SetStopped();\n    return state;\n  }\n\n  while (state != eStateInvalid) {\n    EventSP event_sp;\n    state = GetStateChangedEvents(event_sp, timeout, hijack_listener_sp);\n    if (event_sp_ptr && event_sp)\n      *event_sp_ptr = event_sp;\n\n    bool pop_process_io_handler = (hijack_listener_sp.get() != nullptr);\n    Process::HandleProcessStateChangedEvent(event_sp, stream,\n                                            pop_process_io_handler);\n\n    switch (state) {\n    case eStateCrashed:\n    case eStateDetached:\n    case eStateExited:\n    case eStateUnloaded:\n      // We need to toggle the run lock as this won't get done in\n      // SetPublicState() if the process is hijacked.\n      if (hijack_listener_sp && use_run_lock)\n        m_public_run_lock.SetStopped();\n      return state;\n    case eStateStopped:\n      if (Process::ProcessEventData::GetRestartedFromEvent(event_sp.get()))\n        continue;\n      else {\n        // We need to toggle the run lock as this won't get done in\n        // SetPublicState() if the process is hijacked.\n        if (hijack_listener_sp && use_run_lock)\n          m_public_run_lock.SetStopped();\n        return state;\n      }\n    default:\n      continue;\n    }\n  }\n  return state;\n}\n\nbool Process::HandleProcessStateChangedEvent(const EventSP &event_sp,\n                                             Stream *stream,\n                                             bool &pop_process_io_handler) {\n  const bool handle_pop = pop_process_io_handler;\n\n  pop_process_io_handler = false;\n  ProcessSP process_sp =\n      Process::ProcessEventData::GetProcessFromEvent(event_sp.get());\n\n  if (!process_sp)\n    return false;\n\n  StateType event_state =\n      Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n  if (event_state == eStateInvalid)\n    return false;\n\n  switch (event_state) {\n  case eStateInvalid:\n  case eStateUnloaded:\n  case eStateAttaching:\n  case eStateLaunching:\n  case eStateStepping:\n  case eStateDetached:\n    if (stream)\n      stream->Printf(\"Process %\" PRIu64 \" %s\\n\", process_sp->GetID(),\n                     StateAsCString(event_state));\n    if (event_state == eStateDetached)\n      pop_process_io_handler = true;\n    break;\n\n  case eStateConnected:\n  case eStateRunning:\n    // Don't be chatty when we run...\n    break;\n\n  case eStateExited:\n    if (stream)\n      process_sp->GetStatus(*stream);\n    pop_process_io_handler = true;\n    break;\n\n  case eStateStopped:\n  case eStateCrashed:\n  case eStateSuspended:\n    // Make sure the program hasn't been auto-restarted:\n    if (Process::ProcessEventData::GetRestartedFromEvent(event_sp.get())) {\n      if (stream) {\n        size_t num_reasons =\n            Process::ProcessEventData::GetNumRestartedReasons(event_sp.get());\n        if (num_reasons > 0) {\n          // FIXME: Do we want to report this, or would that just be annoyingly\n          // chatty?\n          if (num_reasons == 1) {\n            const char *reason =\n                Process::ProcessEventData::GetRestartedReasonAtIndex(\n                    event_sp.get(), 0);\n            stream->Printf(\"Process %\" PRIu64 \" stopped and restarted: %s\\n\",\n                           process_sp->GetID(),\n                           reason ? reason : \"<UNKNOWN REASON>\");\n          } else {\n            stream->Printf(\"Process %\" PRIu64\n                           \" stopped and restarted, reasons:\\n\",\n                           process_sp->GetID());\n\n            for (size_t i = 0; i < num_reasons; i++) {\n              const char *reason =\n                  Process::ProcessEventData::GetRestartedReasonAtIndex(\n                      event_sp.get(), i);\n              stream->Printf(\"\\t%s\\n\", reason ? reason : \"<UNKNOWN REASON>\");\n            }\n          }\n        }\n      }\n    } else {\n      StopInfoSP curr_thread_stop_info_sp;\n      // Lock the thread list so it doesn't change on us, this is the scope for\n      // the locker:\n      {\n        ThreadList &thread_list = process_sp->GetThreadList();\n        std::lock_guard<std::recursive_mutex> guard(thread_list.GetMutex());\n\n        ThreadSP curr_thread(thread_list.GetSelectedThread());\n        ThreadSP thread;\n        StopReason curr_thread_stop_reason = eStopReasonInvalid;\n        if (curr_thread) {\n          curr_thread_stop_reason = curr_thread->GetStopReason();\n          curr_thread_stop_info_sp = curr_thread->GetStopInfo();\n        }\n        if (!curr_thread || !curr_thread->IsValid() ||\n            curr_thread_stop_reason == eStopReasonInvalid ||\n            curr_thread_stop_reason == eStopReasonNone) {\n          // Prefer a thread that has just completed its plan over another\n          // thread as current thread.\n          ThreadSP plan_thread;\n          ThreadSP other_thread;\n\n          const size_t num_threads = thread_list.GetSize();\n          size_t i;\n          for (i = 0; i < num_threads; ++i) {\n            thread = thread_list.GetThreadAtIndex(i);\n            StopReason thread_stop_reason = thread->GetStopReason();\n            switch (thread_stop_reason) {\n            case eStopReasonInvalid:\n            case eStopReasonNone:\n              break;\n\n            case eStopReasonSignal: {\n              // Don't select a signal thread if we weren't going to stop at\n              // that signal.  We have to have had another reason for stopping\n              // here, and the user doesn't want to see this thread.\n              uint64_t signo = thread->GetStopInfo()->GetValue();\n              if (process_sp->GetUnixSignals()->GetShouldStop(signo)) {\n                if (!other_thread)\n                  other_thread = thread;\n              }\n              break;\n            }\n            case eStopReasonTrace:\n            case eStopReasonBreakpoint:\n            case eStopReasonWatchpoint:\n            case eStopReasonException:\n            case eStopReasonExec:\n            case eStopReasonThreadExiting:\n            case eStopReasonInstrumentation:\n            case eStopReasonProcessorTrace:\n              if (!other_thread)\n                other_thread = thread;\n              break;\n            case eStopReasonPlanComplete:\n              if (!plan_thread)\n                plan_thread = thread;\n              break;\n            }\n          }\n          if (plan_thread)\n            thread_list.SetSelectedThreadByID(plan_thread->GetID());\n          else if (other_thread)\n            thread_list.SetSelectedThreadByID(other_thread->GetID());\n          else {\n            if (curr_thread && curr_thread->IsValid())\n              thread = curr_thread;\n            else\n              thread = thread_list.GetThreadAtIndex(0);\n\n            if (thread)\n              thread_list.SetSelectedThreadByID(thread->GetID());\n          }\n        }\n      }\n      // Drop the ThreadList mutex by here, since GetThreadStatus below might\n      // have to run code, e.g. for Data formatters, and if we hold the\n      // ThreadList mutex, then the process is going to have a hard time\n      // restarting the process.\n      if (stream) {\n        Debugger &debugger = process_sp->GetTarget().GetDebugger();\n        if (debugger.GetTargetList().GetSelectedTarget().get() ==\n            &process_sp->GetTarget()) {\n          ThreadSP thread_sp = process_sp->GetThreadList().GetSelectedThread();\n\n          if (!thread_sp || !thread_sp->IsValid())\n            return false;\n\n          const bool only_threads_with_stop_reason = true;\n          const uint32_t start_frame = thread_sp->GetSelectedFrameIndex();\n          const uint32_t num_frames = 1;\n          const uint32_t num_frames_with_source = 1;\n          const bool stop_format = true;\n\n          process_sp->GetStatus(*stream);\n          process_sp->GetThreadStatus(*stream, only_threads_with_stop_reason,\n                                      start_frame, num_frames,\n                                      num_frames_with_source,\n                                      stop_format);\n          if (curr_thread_stop_info_sp) {\n            lldb::addr_t crashing_address;\n            ValueObjectSP valobj_sp = StopInfo::GetCrashingDereference(\n                curr_thread_stop_info_sp, &crashing_address);\n            if (valobj_sp) {\n              const ValueObject::GetExpressionPathFormat format =\n                  ValueObject::GetExpressionPathFormat::\n                      eGetExpressionPathFormatHonorPointers;\n              stream->PutCString(\"Likely cause: \");\n              valobj_sp->GetExpressionPath(*stream, format);\n              stream->Printf(\" accessed 0x%\" PRIx64 \"\\n\", crashing_address);\n            }\n          }\n        } else {\n          uint32_t target_idx = debugger.GetTargetList().GetIndexOfTarget(\n              process_sp->GetTarget().shared_from_this());\n          if (target_idx != UINT32_MAX)\n            stream->Printf(\"Target %d: (\", target_idx);\n          else\n            stream->Printf(\"Target <unknown index>: (\");\n          process_sp->GetTarget().Dump(stream, eDescriptionLevelBrief);\n          stream->Printf(\") stopped.\\n\");\n        }\n      }\n\n      // Pop the process IO handler\n      pop_process_io_handler = true;\n    }\n    break;\n  }\n\n  if (handle_pop && pop_process_io_handler)\n    process_sp->PopProcessIOHandler();\n\n  return true;\n}\n\nbool Process::HijackProcessEvents(ListenerSP listener_sp) {\n  if (listener_sp) {\n    return HijackBroadcaster(listener_sp, eBroadcastBitStateChanged |\n                                              eBroadcastBitInterrupt);\n  } else\n    return false;\n}\n\nvoid Process::RestoreProcessEvents() { RestoreBroadcaster(); }\n\nStateType Process::GetStateChangedEvents(EventSP &event_sp,\n                                         const Timeout<std::micro> &timeout,\n                                         ListenerSP hijack_listener_sp) {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOG(log, \"timeout = {0}, event_sp)...\", timeout);\n\n  ListenerSP listener_sp = hijack_listener_sp;\n  if (!listener_sp)\n    listener_sp = m_listener_sp;\n\n  StateType state = eStateInvalid;\n  if (listener_sp->GetEventForBroadcasterWithType(\n          this, eBroadcastBitStateChanged | eBroadcastBitInterrupt, event_sp,\n          timeout)) {\n    if (event_sp && event_sp->GetType() == eBroadcastBitStateChanged)\n      state = Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n    else\n      LLDB_LOG(log, \"got no event or was interrupted.\");\n  }\n\n  LLDB_LOG(log, \"timeout = {0}, event_sp) => {1}\", timeout, state);\n  return state;\n}\n\nEvent *Process::PeekAtStateChangedEvents() {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n\n  LLDB_LOGF(log, \"Process::%s...\", __FUNCTION__);\n\n  Event *event_ptr;\n  event_ptr = m_listener_sp->PeekAtNextEventForBroadcasterWithType(\n      this, eBroadcastBitStateChanged);\n  if (log) {\n    if (event_ptr) {\n      LLDB_LOGF(log, \"Process::%s (event_ptr) => %s\", __FUNCTION__,\n                StateAsCString(ProcessEventData::GetStateFromEvent(event_ptr)));\n    } else {\n      LLDB_LOGF(log, \"Process::%s no events found\", __FUNCTION__);\n    }\n  }\n  return event_ptr;\n}\n\nStateType\nProcess::GetStateChangedEventsPrivate(EventSP &event_sp,\n                                      const Timeout<std::micro> &timeout) {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOG(log, \"timeout = {0}, event_sp)...\", timeout);\n\n  StateType state = eStateInvalid;\n  if (m_private_state_listener_sp->GetEventForBroadcasterWithType(\n          &m_private_state_broadcaster,\n          eBroadcastBitStateChanged | eBroadcastBitInterrupt, event_sp,\n          timeout))\n    if (event_sp && event_sp->GetType() == eBroadcastBitStateChanged)\n      state = Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n\n  LLDB_LOG(log, \"timeout = {0}, event_sp) => {1}\", timeout,\n           state == eStateInvalid ? \"TIMEOUT\" : StateAsCString(state));\n  return state;\n}\n\nbool Process::GetEventsPrivate(EventSP &event_sp,\n                               const Timeout<std::micro> &timeout,\n                               bool control_only) {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOG(log, \"timeout = {0}, event_sp)...\", timeout);\n\n  if (control_only)\n    return m_private_state_listener_sp->GetEventForBroadcaster(\n        &m_private_state_control_broadcaster, event_sp, timeout);\n  else\n    return m_private_state_listener_sp->GetEvent(event_sp, timeout);\n}\n\nbool Process::IsRunning() const {\n  return StateIsRunningState(m_public_state.GetValue());\n}\n\nint Process::GetExitStatus() {\n  std::lock_guard<std::mutex> guard(m_exit_status_mutex);\n\n  if (m_public_state.GetValue() == eStateExited)\n    return m_exit_status;\n  return -1;\n}\n\nconst char *Process::GetExitDescription() {\n  std::lock_guard<std::mutex> guard(m_exit_status_mutex);\n\n  if (m_public_state.GetValue() == eStateExited && !m_exit_string.empty())\n    return m_exit_string.c_str();\n  return nullptr;\n}\n\nbool Process::SetExitStatus(int status, const char *cstr) {\n  // Use a mutex to protect setting the exit status.\n  std::lock_guard<std::mutex> guard(m_exit_status_mutex);\n\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STATE |\n                                                  LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(\n      log, \"Process::SetExitStatus (status=%i (0x%8.8x), description=%s%s%s)\",\n      status, status, cstr ? \"\\\"\" : \"\", cstr ? cstr : \"NULL\", cstr ? \"\\\"\" : \"\");\n\n  // We were already in the exited state\n  if (m_private_state.GetValue() == eStateExited) {\n    LLDB_LOGF(log, \"Process::SetExitStatus () ignoring exit status because \"\n                   \"state was already set to eStateExited\");\n    return false;\n  }\n\n  m_exit_status = status;\n  if (cstr)\n    m_exit_string = cstr;\n  else\n    m_exit_string.clear();\n\n  // Clear the last natural stop ID since it has a strong reference to this\n  // process\n  m_mod_id.SetStopEventForLastNaturalStopID(EventSP());\n\n  SetPrivateState(eStateExited);\n\n  // Allow subclasses to do some cleanup\n  DidExit();\n\n  return true;\n}\n\nbool Process::IsAlive() {\n  switch (m_private_state.GetValue()) {\n  case eStateConnected:\n  case eStateAttaching:\n  case eStateLaunching:\n  case eStateStopped:\n  case eStateRunning:\n  case eStateStepping:\n  case eStateCrashed:\n  case eStateSuspended:\n    return true;\n  default:\n    return false;\n  }\n}\n\n// This static callback can be used to watch for local child processes on the\n// current host. The child process exits, the process will be found in the\n// global target list (we want to be completely sure that the\n// lldb_private::Process doesn't go away before we can deliver the signal.\nbool Process::SetProcessExitStatus(\n    lldb::pid_t pid, bool exited,\n    int signo,      // Zero for no signal\n    int exit_status // Exit value of process if signal is zero\n    ) {\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(log,\n            \"Process::SetProcessExitStatus (pid=%\" PRIu64\n            \", exited=%i, signal=%i, exit_status=%i)\\n\",\n            pid, exited, signo, exit_status);\n\n  if (exited) {\n    TargetSP target_sp(Debugger::FindTargetWithProcessID(pid));\n    if (target_sp) {\n      ProcessSP process_sp(target_sp->GetProcessSP());\n      if (process_sp) {\n        const char *signal_cstr = nullptr;\n        if (signo)\n          signal_cstr = process_sp->GetUnixSignals()->GetSignalAsCString(signo);\n\n        process_sp->SetExitStatus(exit_status, signal_cstr);\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nbool Process::UpdateThreadList(ThreadList &old_thread_list,\n                               ThreadList &new_thread_list) {\n  m_thread_plans.ClearThreadCache();\n  return DoUpdateThreadList(old_thread_list, new_thread_list);\n}\n\nvoid Process::UpdateThreadListIfNeeded() {\n  const uint32_t stop_id = GetStopID();\n  if (m_thread_list.GetSize(false) == 0 ||\n      stop_id != m_thread_list.GetStopID()) {\n    bool clear_unused_threads = true;\n    const StateType state = GetPrivateState();\n    if (StateIsStoppedState(state, true)) {\n      std::lock_guard<std::recursive_mutex> guard(m_thread_list.GetMutex());\n      m_thread_list.SetStopID(stop_id);\n\n      // m_thread_list does have its own mutex, but we need to hold onto the\n      // mutex between the call to UpdateThreadList(...) and the\n      // os->UpdateThreadList(...) so it doesn't change on us\n      ThreadList &old_thread_list = m_thread_list;\n      ThreadList real_thread_list(this);\n      ThreadList new_thread_list(this);\n      // Always update the thread list with the protocol specific thread list,\n      // but only update if \"true\" is returned\n      if (UpdateThreadList(m_thread_list_real, real_thread_list)) {\n        // Don't call into the OperatingSystem to update the thread list if we\n        // are shutting down, since that may call back into the SBAPI's,\n        // requiring the API lock which is already held by whoever is shutting\n        // us down, causing a deadlock.\n        OperatingSystem *os = GetOperatingSystem();\n        if (os && !m_destroy_in_process) {\n          // Clear any old backing threads where memory threads might have been\n          // backed by actual threads from the lldb_private::Process subclass\n          size_t num_old_threads = old_thread_list.GetSize(false);\n          for (size_t i = 0; i < num_old_threads; ++i)\n            old_thread_list.GetThreadAtIndex(i, false)->ClearBackingThread();\n          // See if the OS plugin reports all threads.  If it does, then\n          // it is safe to clear unseen thread's plans here.  Otherwise we\n          // should preserve them in case they show up again:\n          clear_unused_threads = GetOSPluginReportsAllThreads();\n\n          // Turn off dynamic types to ensure we don't run any expressions.\n          // Objective-C can run an expression to determine if a SBValue is a\n          // dynamic type or not and we need to avoid this. OperatingSystem\n          // plug-ins can't run expressions that require running code...\n\n          Target &target = GetTarget();\n          const lldb::DynamicValueType saved_prefer_dynamic =\n              target.GetPreferDynamicValue();\n          if (saved_prefer_dynamic != lldb::eNoDynamicValues)\n            target.SetPreferDynamicValue(lldb::eNoDynamicValues);\n\n          // Now let the OperatingSystem plug-in update the thread list\n\n          os->UpdateThreadList(\n              old_thread_list, // Old list full of threads created by OS plug-in\n              real_thread_list, // The actual thread list full of threads\n                                // created by each lldb_private::Process\n                                // subclass\n              new_thread_list); // The new thread list that we will show to the\n                                // user that gets filled in\n\n          if (saved_prefer_dynamic != lldb::eNoDynamicValues)\n            target.SetPreferDynamicValue(saved_prefer_dynamic);\n        } else {\n          // No OS plug-in, the new thread list is the same as the real thread\n          // list.\n          new_thread_list = real_thread_list;\n        }\n\n        m_thread_list_real.Update(real_thread_list);\n        m_thread_list.Update(new_thread_list);\n        m_thread_list.SetStopID(stop_id);\n\n        if (GetLastNaturalStopID() != m_extended_thread_stop_id) {\n          // Clear any extended threads that we may have accumulated previously\n          m_extended_thread_list.Clear();\n          m_extended_thread_stop_id = GetLastNaturalStopID();\n\n          m_queue_list.Clear();\n          m_queue_list_stop_id = GetLastNaturalStopID();\n        }\n      }\n      // Now update the plan stack map.\n      // If we do have an OS plugin, any absent real threads in the\n      // m_thread_list have already been removed from the ThreadPlanStackMap.\n      // So any remaining threads are OS Plugin threads, and those we want to\n      // preserve in case they show up again.\n      m_thread_plans.Update(m_thread_list, clear_unused_threads);\n    }\n  }\n}\n\nThreadPlanStack *Process::FindThreadPlans(lldb::tid_t tid) {\n  return m_thread_plans.Find(tid);\n}\n\nbool Process::PruneThreadPlansForTID(lldb::tid_t tid) {\n  return m_thread_plans.PrunePlansForTID(tid);\n}\n\nvoid Process::PruneThreadPlans() {\n  m_thread_plans.Update(GetThreadList(), true, false);\n}\n\nbool Process::DumpThreadPlansForTID(Stream &strm, lldb::tid_t tid,\n                                    lldb::DescriptionLevel desc_level,\n                                    bool internal, bool condense_trivial,\n                                    bool skip_unreported_plans) {\n  return m_thread_plans.DumpPlansForTID(\n      strm, tid, desc_level, internal, condense_trivial, skip_unreported_plans);\n}\nvoid Process::DumpThreadPlans(Stream &strm, lldb::DescriptionLevel desc_level,\n                              bool internal, bool condense_trivial,\n                              bool skip_unreported_plans) {\n  m_thread_plans.DumpPlans(strm, desc_level, internal, condense_trivial,\n                           skip_unreported_plans);\n}\n\nvoid Process::UpdateQueueListIfNeeded() {\n  if (m_system_runtime_up) {\n    if (m_queue_list.GetSize() == 0 ||\n        m_queue_list_stop_id != GetLastNaturalStopID()) {\n      const StateType state = GetPrivateState();\n      if (StateIsStoppedState(state, true)) {\n        m_system_runtime_up->PopulateQueueList(m_queue_list);\n        m_queue_list_stop_id = GetLastNaturalStopID();\n      }\n    }\n  }\n}\n\nThreadSP Process::CreateOSPluginThread(lldb::tid_t tid, lldb::addr_t context) {\n  OperatingSystem *os = GetOperatingSystem();\n  if (os)\n    return os->CreateThread(tid, context);\n  return ThreadSP();\n}\n\nuint32_t Process::GetNextThreadIndexID(uint64_t thread_id) {\n  return AssignIndexIDToThread(thread_id);\n}\n\nbool Process::HasAssignedIndexIDToThread(uint64_t thread_id) {\n  return (m_thread_id_to_index_id_map.find(thread_id) !=\n          m_thread_id_to_index_id_map.end());\n}\n\nuint32_t Process::AssignIndexIDToThread(uint64_t thread_id) {\n  uint32_t result = 0;\n  std::map<uint64_t, uint32_t>::iterator iterator =\n      m_thread_id_to_index_id_map.find(thread_id);\n  if (iterator == m_thread_id_to_index_id_map.end()) {\n    result = ++m_thread_index_id;\n    m_thread_id_to_index_id_map[thread_id] = result;\n  } else {\n    result = iterator->second;\n  }\n\n  return result;\n}\n\nStateType Process::GetState() {\n  return m_public_state.GetValue();\n}\n\nvoid Process::SetPublicState(StateType new_state, bool restarted) {\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STATE |\n                                                  LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(log, \"Process::SetPublicState (state = %s, restarted = %i)\",\n            StateAsCString(new_state), restarted);\n  const StateType old_state = m_public_state.GetValue();\n  m_public_state.SetValue(new_state);\n\n  // On the transition from Run to Stopped, we unlock the writer end of the run\n  // lock.  The lock gets locked in Resume, which is the public API to tell the\n  // program to run.\n  if (!StateChangedIsExternallyHijacked()) {\n    if (new_state == eStateDetached) {\n      LLDB_LOGF(log,\n                \"Process::SetPublicState (%s) -- unlocking run lock for detach\",\n                StateAsCString(new_state));\n      m_public_run_lock.SetStopped();\n    } else {\n      const bool old_state_is_stopped = StateIsStoppedState(old_state, false);\n      const bool new_state_is_stopped = StateIsStoppedState(new_state, false);\n      if ((old_state_is_stopped != new_state_is_stopped)) {\n        if (new_state_is_stopped && !restarted) {\n          LLDB_LOGF(log, \"Process::SetPublicState (%s) -- unlocking run lock\",\n                    StateAsCString(new_state));\n          m_public_run_lock.SetStopped();\n        }\n      }\n    }\n  }\n}\n\nStatus Process::Resume() {\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STATE |\n                                                  LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(log, \"Process::Resume -- locking run lock\");\n  if (!m_public_run_lock.TrySetRunning()) {\n    Status error(\"Resume request failed - process still running.\");\n    LLDB_LOGF(log, \"Process::Resume: -- TrySetRunning failed, not resuming.\");\n    return error;\n  }\n  Status error = PrivateResume();\n  if (!error.Success()) {\n    // Undo running state change\n    m_public_run_lock.SetStopped();\n  }\n  return error;\n}\n\nstatic const char *g_resume_sync_name = \"lldb.Process.ResumeSynchronous.hijack\";\n\nStatus Process::ResumeSynchronous(Stream *stream) {\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STATE |\n                                                  LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(log, \"Process::ResumeSynchronous -- locking run lock\");\n  if (!m_public_run_lock.TrySetRunning()) {\n    Status error(\"Resume request failed - process still running.\");\n    LLDB_LOGF(log, \"Process::Resume: -- TrySetRunning failed, not resuming.\");\n    return error;\n  }\n\n  ListenerSP listener_sp(\n      Listener::MakeListener(g_resume_sync_name));\n  HijackProcessEvents(listener_sp);\n\n  Status error = PrivateResume();\n  if (error.Success()) {\n    StateType state =\n        WaitForProcessToStop(llvm::None, nullptr, true, listener_sp, stream);\n    const bool must_be_alive =\n        false; // eStateExited is ok, so this must be false\n    if (!StateIsStoppedState(state, must_be_alive))\n      error.SetErrorStringWithFormat(\n          \"process not in stopped state after synchronous resume: %s\",\n          StateAsCString(state));\n  } else {\n    // Undo running state change\n    m_public_run_lock.SetStopped();\n  }\n\n  // Undo the hijacking of process events...\n  RestoreProcessEvents();\n\n  return error;\n}\n\nbool Process::StateChangedIsExternallyHijacked() {\n  if (IsHijackedForEvent(eBroadcastBitStateChanged)) {\n    const char *hijacking_name = GetHijackingListenerName();\n    if (hijacking_name &&\n        strcmp(hijacking_name, g_resume_sync_name))\n      return true;\n  }\n  return false;\n}\n\nbool Process::StateChangedIsHijackedForSynchronousResume() {\n  if (IsHijackedForEvent(eBroadcastBitStateChanged)) {\n    const char *hijacking_name = GetHijackingListenerName();\n    if (hijacking_name &&\n        strcmp(hijacking_name, g_resume_sync_name) == 0)\n      return true;\n  }\n  return false;\n}\n\nStateType Process::GetPrivateState() { return m_private_state.GetValue(); }\n\nvoid Process::SetPrivateState(StateType new_state) {\n  if (m_finalizing)\n    return;\n\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(\n      LIBLLDB_LOG_STATE | LIBLLDB_LOG_PROCESS | LIBLLDB_LOG_UNWIND));\n  bool state_changed = false;\n\n  LLDB_LOGF(log, \"Process::SetPrivateState (%s)\", StateAsCString(new_state));\n\n  std::lock_guard<std::recursive_mutex> thread_guard(m_thread_list.GetMutex());\n  std::lock_guard<std::recursive_mutex> guard(m_private_state.GetMutex());\n\n  const StateType old_state = m_private_state.GetValueNoLock();\n  state_changed = old_state != new_state;\n\n  const bool old_state_is_stopped = StateIsStoppedState(old_state, false);\n  const bool new_state_is_stopped = StateIsStoppedState(new_state, false);\n  if (old_state_is_stopped != new_state_is_stopped) {\n    if (new_state_is_stopped)\n      m_private_run_lock.SetStopped();\n    else\n      m_private_run_lock.SetRunning();\n  }\n\n  if (state_changed) {\n    m_private_state.SetValueNoLock(new_state);\n    EventSP event_sp(\n        new Event(eBroadcastBitStateChanged,\n                  new ProcessEventData(shared_from_this(), new_state)));\n    if (StateIsStoppedState(new_state, false)) {\n      // Note, this currently assumes that all threads in the list stop when\n      // the process stops.  In the future we will want to support a debugging\n      // model where some threads continue to run while others are stopped.\n      // When that happens we will either need a way for the thread list to\n      // identify which threads are stopping or create a special thread list\n      // containing only threads which actually stopped.\n      //\n      // The process plugin is responsible for managing the actual behavior of\n      // the threads and should have stopped any threads that are going to stop\n      // before we get here.\n      m_thread_list.DidStop();\n\n      m_mod_id.BumpStopID();\n      if (!m_mod_id.IsLastResumeForUserExpression())\n        m_mod_id.SetStopEventForLastNaturalStopID(event_sp);\n      m_memory_cache.Clear();\n      LLDB_LOGF(log, \"Process::SetPrivateState (%s) stop_id = %u\",\n                StateAsCString(new_state), m_mod_id.GetStopID());\n    }\n\n    m_private_state_broadcaster.BroadcastEvent(event_sp);\n  } else {\n    LLDB_LOGF(log,\n              \"Process::SetPrivateState (%s) state didn't change. Ignoring...\",\n              StateAsCString(new_state));\n  }\n}\n\nvoid Process::SetRunningUserExpression(bool on) {\n  m_mod_id.SetRunningUserExpression(on);\n}\n\nvoid Process::SetRunningUtilityFunction(bool on) {\n  m_mod_id.SetRunningUtilityFunction(on);\n}\n\naddr_t Process::GetImageInfoAddress() { return LLDB_INVALID_ADDRESS; }\n\nconst lldb::ABISP &Process::GetABI() {\n  if (!m_abi_sp)\n    m_abi_sp = ABI::FindPlugin(shared_from_this(), GetTarget().GetArchitecture());\n  return m_abi_sp;\n}\n\nstd::vector<LanguageRuntime *> Process::GetLanguageRuntimes() {\n  std::vector<LanguageRuntime *> language_runtimes;\n\n  if (m_finalizing)\n    return language_runtimes;\n\n  std::lock_guard<std::recursive_mutex> guard(m_language_runtimes_mutex);\n  // Before we pass off a copy of the language runtimes, we must make sure that\n  // our collection is properly populated. It's possible that some of the\n  // language runtimes were not loaded yet, either because nobody requested it\n  // yet or the proper condition for loading wasn't yet met (e.g. libc++.so\n  // hadn't been loaded).\n  for (const lldb::LanguageType lang_type : Language::GetSupportedLanguages()) {\n    if (LanguageRuntime *runtime = GetLanguageRuntime(lang_type))\n      language_runtimes.emplace_back(runtime);\n  }\n\n  return language_runtimes;\n}\n\nLanguageRuntime *Process::GetLanguageRuntime(lldb::LanguageType language) {\n  if (m_finalizing)\n    return nullptr;\n\n  LanguageRuntime *runtime = nullptr;\n\n  std::lock_guard<std::recursive_mutex> guard(m_language_runtimes_mutex);\n  LanguageRuntimeCollection::iterator pos;\n  pos = m_language_runtimes.find(language);\n  if (pos == m_language_runtimes.end() || !pos->second) {\n    lldb::LanguageRuntimeSP runtime_sp(\n        LanguageRuntime::FindPlugin(this, language));\n\n    m_language_runtimes[language] = runtime_sp;\n    runtime = runtime_sp.get();\n  } else\n    runtime = pos->second.get();\n\n  if (runtime)\n    // It's possible that a language runtime can support multiple LanguageTypes,\n    // for example, CPPLanguageRuntime will support eLanguageTypeC_plus_plus,\n    // eLanguageTypeC_plus_plus_03, etc. Because of this, we should get the\n    // primary language type and make sure that our runtime supports it.\n    assert(runtime->GetLanguageType() == Language::GetPrimaryLanguage(language));\n\n  return runtime;\n}\n\nbool Process::IsPossibleDynamicValue(ValueObject &in_value) {\n  if (m_finalizing)\n    return false;\n\n  if (in_value.IsDynamic())\n    return false;\n  LanguageType known_type = in_value.GetObjectRuntimeLanguage();\n\n  if (known_type != eLanguageTypeUnknown && known_type != eLanguageTypeC) {\n    LanguageRuntime *runtime = GetLanguageRuntime(known_type);\n    return runtime ? runtime->CouldHaveDynamicValue(in_value) : false;\n  }\n\n  for (LanguageRuntime *runtime : GetLanguageRuntimes()) {\n    if (runtime->CouldHaveDynamicValue(in_value))\n      return true;\n  }\n\n  return false;\n}\n\nvoid Process::SetDynamicCheckers(DynamicCheckerFunctions *dynamic_checkers) {\n  m_dynamic_checkers_up.reset(dynamic_checkers);\n}\n\nBreakpointSiteList &Process::GetBreakpointSiteList() {\n  return m_breakpoint_site_list;\n}\n\nconst BreakpointSiteList &Process::GetBreakpointSiteList() const {\n  return m_breakpoint_site_list;\n}\n\nvoid Process::DisableAllBreakpointSites() {\n  m_breakpoint_site_list.ForEach([this](BreakpointSite *bp_site) -> void {\n    //        bp_site->SetEnabled(true);\n    DisableBreakpointSite(bp_site);\n  });\n}\n\nStatus Process::ClearBreakpointSiteByID(lldb::user_id_t break_id) {\n  Status error(DisableBreakpointSiteByID(break_id));\n\n  if (error.Success())\n    m_breakpoint_site_list.Remove(break_id);\n\n  return error;\n}\n\nStatus Process::DisableBreakpointSiteByID(lldb::user_id_t break_id) {\n  Status error;\n  BreakpointSiteSP bp_site_sp = m_breakpoint_site_list.FindByID(break_id);\n  if (bp_site_sp) {\n    if (bp_site_sp->IsEnabled())\n      error = DisableBreakpointSite(bp_site_sp.get());\n  } else {\n    error.SetErrorStringWithFormat(\"invalid breakpoint site ID: %\" PRIu64,\n                                   break_id);\n  }\n\n  return error;\n}\n\nStatus Process::EnableBreakpointSiteByID(lldb::user_id_t break_id) {\n  Status error;\n  BreakpointSiteSP bp_site_sp = m_breakpoint_site_list.FindByID(break_id);\n  if (bp_site_sp) {\n    if (!bp_site_sp->IsEnabled())\n      error = EnableBreakpointSite(bp_site_sp.get());\n  } else {\n    error.SetErrorStringWithFormat(\"invalid breakpoint site ID: %\" PRIu64,\n                                   break_id);\n  }\n  return error;\n}\n\nlldb::break_id_t\nProcess::CreateBreakpointSite(const BreakpointLocationSP &owner,\n                              bool use_hardware) {\n  addr_t load_addr = LLDB_INVALID_ADDRESS;\n\n  bool show_error = true;\n  switch (GetState()) {\n  case eStateInvalid:\n  case eStateUnloaded:\n  case eStateConnected:\n  case eStateAttaching:\n  case eStateLaunching:\n  case eStateDetached:\n  case eStateExited:\n    show_error = false;\n    break;\n\n  case eStateStopped:\n  case eStateRunning:\n  case eStateStepping:\n  case eStateCrashed:\n  case eStateSuspended:\n    show_error = IsAlive();\n    break;\n  }\n\n  // Reset the IsIndirect flag here, in case the location changes from pointing\n  // to a indirect symbol to a regular symbol.\n  owner->SetIsIndirect(false);\n\n  if (owner->ShouldResolveIndirectFunctions()) {\n    Symbol *symbol = owner->GetAddress().CalculateSymbolContextSymbol();\n    if (symbol && symbol->IsIndirect()) {\n      Status error;\n      Address symbol_address = symbol->GetAddress();\n      load_addr = ResolveIndirectFunction(&symbol_address, error);\n      if (!error.Success() && show_error) {\n        GetTarget().GetDebugger().GetErrorStream().Printf(\n            \"warning: failed to resolve indirect function at 0x%\" PRIx64\n            \" for breakpoint %i.%i: %s\\n\",\n            symbol->GetLoadAddress(&GetTarget()),\n            owner->GetBreakpoint().GetID(), owner->GetID(),\n            error.AsCString() ? error.AsCString() : \"unknown error\");\n        return LLDB_INVALID_BREAK_ID;\n      }\n      Address resolved_address(load_addr);\n      load_addr = resolved_address.GetOpcodeLoadAddress(&GetTarget());\n      owner->SetIsIndirect(true);\n    } else\n      load_addr = owner->GetAddress().GetOpcodeLoadAddress(&GetTarget());\n  } else\n    load_addr = owner->GetAddress().GetOpcodeLoadAddress(&GetTarget());\n\n  if (load_addr != LLDB_INVALID_ADDRESS) {\n    BreakpointSiteSP bp_site_sp;\n\n    // Look up this breakpoint site.  If it exists, then add this new owner,\n    // otherwise create a new breakpoint site and add it.\n\n    bp_site_sp = m_breakpoint_site_list.FindByAddress(load_addr);\n\n    if (bp_site_sp) {\n      bp_site_sp->AddOwner(owner);\n      owner->SetBreakpointSite(bp_site_sp);\n      return bp_site_sp->GetID();\n    } else {\n      bp_site_sp.reset(new BreakpointSite(&m_breakpoint_site_list, owner,\n                                          load_addr, use_hardware));\n      if (bp_site_sp) {\n        Status error = EnableBreakpointSite(bp_site_sp.get());\n        if (error.Success()) {\n          owner->SetBreakpointSite(bp_site_sp);\n          return m_breakpoint_site_list.Add(bp_site_sp);\n        } else {\n          if (show_error || use_hardware) {\n            // Report error for setting breakpoint...\n            GetTarget().GetDebugger().GetErrorStream().Printf(\n                \"warning: failed to set breakpoint site at 0x%\" PRIx64\n                \" for breakpoint %i.%i: %s\\n\",\n                load_addr, owner->GetBreakpoint().GetID(), owner->GetID(),\n                error.AsCString() ? error.AsCString() : \"unknown error\");\n          }\n        }\n      }\n    }\n  }\n  // We failed to enable the breakpoint\n  return LLDB_INVALID_BREAK_ID;\n}\n\nvoid Process::RemoveOwnerFromBreakpointSite(lldb::user_id_t owner_id,\n                                            lldb::user_id_t owner_loc_id,\n                                            BreakpointSiteSP &bp_site_sp) {\n  uint32_t num_owners = bp_site_sp->RemoveOwner(owner_id, owner_loc_id);\n  if (num_owners == 0) {\n    // Don't try to disable the site if we don't have a live process anymore.\n    if (IsAlive())\n      DisableBreakpointSite(bp_site_sp.get());\n    m_breakpoint_site_list.RemoveByAddress(bp_site_sp->GetLoadAddress());\n  }\n}\n\nsize_t Process::RemoveBreakpointOpcodesFromBuffer(addr_t bp_addr, size_t size,\n                                                  uint8_t *buf) const {\n  size_t bytes_removed = 0;\n  BreakpointSiteList bp_sites_in_range;\n\n  if (m_breakpoint_site_list.FindInRange(bp_addr, bp_addr + size,\n                                         bp_sites_in_range)) {\n    bp_sites_in_range.ForEach([bp_addr, size,\n                               buf](BreakpointSite *bp_site) -> void {\n      if (bp_site->GetType() == BreakpointSite::eSoftware) {\n        addr_t intersect_addr;\n        size_t intersect_size;\n        size_t opcode_offset;\n        if (bp_site->IntersectsRange(bp_addr, size, &intersect_addr,\n                                     &intersect_size, &opcode_offset)) {\n          assert(bp_addr <= intersect_addr && intersect_addr < bp_addr + size);\n          assert(bp_addr < intersect_addr + intersect_size &&\n                 intersect_addr + intersect_size <= bp_addr + size);\n          assert(opcode_offset + intersect_size <= bp_site->GetByteSize());\n          size_t buf_offset = intersect_addr - bp_addr;\n          ::memcpy(buf + buf_offset,\n                   bp_site->GetSavedOpcodeBytes() + opcode_offset,\n                   intersect_size);\n        }\n      }\n    });\n  }\n  return bytes_removed;\n}\n\nsize_t Process::GetSoftwareBreakpointTrapOpcode(BreakpointSite *bp_site) {\n  PlatformSP platform_sp(GetTarget().GetPlatform());\n  if (platform_sp)\n    return platform_sp->GetSoftwareBreakpointTrapOpcode(GetTarget(), bp_site);\n  return 0;\n}\n\nStatus Process::EnableSoftwareBreakpoint(BreakpointSite *bp_site) {\n  Status error;\n  assert(bp_site != nullptr);\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_BREAKPOINTS));\n  const addr_t bp_addr = bp_site->GetLoadAddress();\n  LLDB_LOGF(\n      log, \"Process::EnableSoftwareBreakpoint (site_id = %d) addr = 0x%\" PRIx64,\n      bp_site->GetID(), (uint64_t)bp_addr);\n  if (bp_site->IsEnabled()) {\n    LLDB_LOGF(\n        log,\n        \"Process::EnableSoftwareBreakpoint (site_id = %d) addr = 0x%\" PRIx64\n        \" -- already enabled\",\n        bp_site->GetID(), (uint64_t)bp_addr);\n    return error;\n  }\n\n  if (bp_addr == LLDB_INVALID_ADDRESS) {\n    error.SetErrorString(\"BreakpointSite contains an invalid load address.\");\n    return error;\n  }\n  // Ask the lldb::Process subclass to fill in the correct software breakpoint\n  // trap for the breakpoint site\n  const size_t bp_opcode_size = GetSoftwareBreakpointTrapOpcode(bp_site);\n\n  if (bp_opcode_size == 0) {\n    error.SetErrorStringWithFormat(\"Process::GetSoftwareBreakpointTrapOpcode() \"\n                                   \"returned zero, unable to get breakpoint \"\n                                   \"trap for address 0x%\" PRIx64,\n                                   bp_addr);\n  } else {\n    const uint8_t *const bp_opcode_bytes = bp_site->GetTrapOpcodeBytes();\n\n    if (bp_opcode_bytes == nullptr) {\n      error.SetErrorString(\n          \"BreakpointSite doesn't contain a valid breakpoint trap opcode.\");\n      return error;\n    }\n\n    // Save the original opcode by reading it\n    if (DoReadMemory(bp_addr, bp_site->GetSavedOpcodeBytes(), bp_opcode_size,\n                     error) == bp_opcode_size) {\n      // Write a software breakpoint in place of the original opcode\n      if (DoWriteMemory(bp_addr, bp_opcode_bytes, bp_opcode_size, error) ==\n          bp_opcode_size) {\n        uint8_t verify_bp_opcode_bytes[64];\n        if (DoReadMemory(bp_addr, verify_bp_opcode_bytes, bp_opcode_size,\n                         error) == bp_opcode_size) {\n          if (::memcmp(bp_opcode_bytes, verify_bp_opcode_bytes,\n                       bp_opcode_size) == 0) {\n            bp_site->SetEnabled(true);\n            bp_site->SetType(BreakpointSite::eSoftware);\n            LLDB_LOGF(log,\n                      \"Process::EnableSoftwareBreakpoint (site_id = %d) \"\n                      \"addr = 0x%\" PRIx64 \" -- SUCCESS\",\n                      bp_site->GetID(), (uint64_t)bp_addr);\n          } else\n            error.SetErrorString(\n                \"failed to verify the breakpoint trap in memory.\");\n        } else\n          error.SetErrorString(\n              \"Unable to read memory to verify breakpoint trap.\");\n      } else\n        error.SetErrorString(\"Unable to write breakpoint trap to memory.\");\n    } else\n      error.SetErrorString(\"Unable to read memory at breakpoint address.\");\n  }\n  if (log && error.Fail())\n    LLDB_LOGF(\n        log,\n        \"Process::EnableSoftwareBreakpoint (site_id = %d) addr = 0x%\" PRIx64\n        \" -- FAILED: %s\",\n        bp_site->GetID(), (uint64_t)bp_addr, error.AsCString());\n  return error;\n}\n\nStatus Process::DisableSoftwareBreakpoint(BreakpointSite *bp_site) {\n  Status error;\n  assert(bp_site != nullptr);\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_BREAKPOINTS));\n  addr_t bp_addr = bp_site->GetLoadAddress();\n  lldb::user_id_t breakID = bp_site->GetID();\n  LLDB_LOGF(log,\n            \"Process::DisableSoftwareBreakpoint (breakID = %\" PRIu64\n            \") addr = 0x%\" PRIx64,\n            breakID, (uint64_t)bp_addr);\n\n  if (bp_site->IsHardware()) {\n    error.SetErrorString(\"Breakpoint site is a hardware breakpoint.\");\n  } else if (bp_site->IsEnabled()) {\n    const size_t break_op_size = bp_site->GetByteSize();\n    const uint8_t *const break_op = bp_site->GetTrapOpcodeBytes();\n    if (break_op_size > 0) {\n      // Clear a software breakpoint instruction\n      uint8_t curr_break_op[8];\n      assert(break_op_size <= sizeof(curr_break_op));\n      bool break_op_found = false;\n\n      // Read the breakpoint opcode\n      if (DoReadMemory(bp_addr, curr_break_op, break_op_size, error) ==\n          break_op_size) {\n        bool verify = false;\n        // Make sure the breakpoint opcode exists at this address\n        if (::memcmp(curr_break_op, break_op, break_op_size) == 0) {\n          break_op_found = true;\n          // We found a valid breakpoint opcode at this address, now restore\n          // the saved opcode.\n          if (DoWriteMemory(bp_addr, bp_site->GetSavedOpcodeBytes(),\n                            break_op_size, error) == break_op_size) {\n            verify = true;\n          } else\n            error.SetErrorString(\n                \"Memory write failed when restoring original opcode.\");\n        } else {\n          error.SetErrorString(\n              \"Original breakpoint trap is no longer in memory.\");\n          // Set verify to true and so we can check if the original opcode has\n          // already been restored\n          verify = true;\n        }\n\n        if (verify) {\n          uint8_t verify_opcode[8];\n          assert(break_op_size < sizeof(verify_opcode));\n          // Verify that our original opcode made it back to the inferior\n          if (DoReadMemory(bp_addr, verify_opcode, break_op_size, error) ==\n              break_op_size) {\n            // compare the memory we just read with the original opcode\n            if (::memcmp(bp_site->GetSavedOpcodeBytes(), verify_opcode,\n                         break_op_size) == 0) {\n              // SUCCESS\n              bp_site->SetEnabled(false);\n              LLDB_LOGF(log,\n                        \"Process::DisableSoftwareBreakpoint (site_id = %d) \"\n                        \"addr = 0x%\" PRIx64 \" -- SUCCESS\",\n                        bp_site->GetID(), (uint64_t)bp_addr);\n              return error;\n            } else {\n              if (break_op_found)\n                error.SetErrorString(\"Failed to restore original opcode.\");\n            }\n          } else\n            error.SetErrorString(\"Failed to read memory to verify that \"\n                                 \"breakpoint trap was restored.\");\n        }\n      } else\n        error.SetErrorString(\n            \"Unable to read memory that should contain the breakpoint trap.\");\n    }\n  } else {\n    LLDB_LOGF(\n        log,\n        \"Process::DisableSoftwareBreakpoint (site_id = %d) addr = 0x%\" PRIx64\n        \" -- already disabled\",\n        bp_site->GetID(), (uint64_t)bp_addr);\n    return error;\n  }\n\n  LLDB_LOGF(\n      log,\n      \"Process::DisableSoftwareBreakpoint (site_id = %d) addr = 0x%\" PRIx64\n      \" -- FAILED: %s\",\n      bp_site->GetID(), (uint64_t)bp_addr, error.AsCString());\n  return error;\n}\n\n// Uncomment to verify memory caching works after making changes to caching\n// code\n//#define VERIFY_MEMORY_READS\n\nsize_t Process::ReadMemory(addr_t addr, void *buf, size_t size, Status &error) {\n  error.Clear();\n  if (!GetDisableMemoryCache()) {\n#if defined(VERIFY_MEMORY_READS)\n    // Memory caching is enabled, with debug verification\n\n    if (buf && size) {\n      // Uncomment the line below to make sure memory caching is working.\n      // I ran this through the test suite and got no assertions, so I am\n      // pretty confident this is working well. If any changes are made to\n      // memory caching, uncomment the line below and test your changes!\n\n      // Verify all memory reads by using the cache first, then redundantly\n      // reading the same memory from the inferior and comparing to make sure\n      // everything is exactly the same.\n      std::string verify_buf(size, '\\0');\n      assert(verify_buf.size() == size);\n      const size_t cache_bytes_read =\n          m_memory_cache.Read(this, addr, buf, size, error);\n      Status verify_error;\n      const size_t verify_bytes_read =\n          ReadMemoryFromInferior(addr, const_cast<char *>(verify_buf.data()),\n                                 verify_buf.size(), verify_error);\n      assert(cache_bytes_read == verify_bytes_read);\n      assert(memcmp(buf, verify_buf.data(), verify_buf.size()) == 0);\n      assert(verify_error.Success() == error.Success());\n      return cache_bytes_read;\n    }\n    return 0;\n#else  // !defined(VERIFY_MEMORY_READS)\n    // Memory caching is enabled, without debug verification\n\n    return m_memory_cache.Read(addr, buf, size, error);\n#endif // defined (VERIFY_MEMORY_READS)\n  } else {\n    // Memory caching is disabled\n\n    return ReadMemoryFromInferior(addr, buf, size, error);\n  }\n}\n\nsize_t Process::ReadCStringFromMemory(addr_t addr, std::string &out_str,\n                                      Status &error) {\n  char buf[256];\n  out_str.clear();\n  addr_t curr_addr = addr;\n  while (true) {\n    size_t length = ReadCStringFromMemory(curr_addr, buf, sizeof(buf), error);\n    if (length == 0)\n      break;\n    out_str.append(buf, length);\n    // If we got \"length - 1\" bytes, we didn't get the whole C string, we need\n    // to read some more characters\n    if (length == sizeof(buf) - 1)\n      curr_addr += length;\n    else\n      break;\n  }\n  return out_str.size();\n}\n\nsize_t Process::ReadStringFromMemory(addr_t addr, char *dst, size_t max_bytes,\n                                     Status &error, size_t type_width) {\n  size_t total_bytes_read = 0;\n  if (dst && max_bytes && type_width && max_bytes >= type_width) {\n    // Ensure a null terminator independent of the number of bytes that is\n    // read.\n    memset(dst, 0, max_bytes);\n    size_t bytes_left = max_bytes - type_width;\n\n    const char terminator[4] = {'\\0', '\\0', '\\0', '\\0'};\n    assert(sizeof(terminator) >= type_width && \"Attempting to validate a \"\n                                               \"string with more than 4 bytes \"\n                                               \"per character!\");\n\n    addr_t curr_addr = addr;\n    const size_t cache_line_size = m_memory_cache.GetMemoryCacheLineSize();\n    char *curr_dst = dst;\n\n    error.Clear();\n    while (bytes_left > 0 && error.Success()) {\n      addr_t cache_line_bytes_left =\n          cache_line_size - (curr_addr % cache_line_size);\n      addr_t bytes_to_read =\n          std::min<addr_t>(bytes_left, cache_line_bytes_left);\n      size_t bytes_read = ReadMemory(curr_addr, curr_dst, bytes_to_read, error);\n\n      if (bytes_read == 0)\n        break;\n\n      // Search for a null terminator of correct size and alignment in\n      // bytes_read\n      size_t aligned_start = total_bytes_read - total_bytes_read % type_width;\n      for (size_t i = aligned_start;\n           i + type_width <= total_bytes_read + bytes_read; i += type_width)\n        if (::memcmp(&dst[i], terminator, type_width) == 0) {\n          error.Clear();\n          return i;\n        }\n\n      total_bytes_read += bytes_read;\n      curr_dst += bytes_read;\n      curr_addr += bytes_read;\n      bytes_left -= bytes_read;\n    }\n  } else {\n    if (max_bytes)\n      error.SetErrorString(\"invalid arguments\");\n  }\n  return total_bytes_read;\n}\n\n// Deprecated in favor of ReadStringFromMemory which has wchar support and\n// correct code to find null terminators.\nsize_t Process::ReadCStringFromMemory(addr_t addr, char *dst,\n                                      size_t dst_max_len,\n                                      Status &result_error) {\n  size_t total_cstr_len = 0;\n  if (dst && dst_max_len) {\n    result_error.Clear();\n    // NULL out everything just to be safe\n    memset(dst, 0, dst_max_len);\n    Status error;\n    addr_t curr_addr = addr;\n    const size_t cache_line_size = m_memory_cache.GetMemoryCacheLineSize();\n    size_t bytes_left = dst_max_len - 1;\n    char *curr_dst = dst;\n\n    while (bytes_left > 0) {\n      addr_t cache_line_bytes_left =\n          cache_line_size - (curr_addr % cache_line_size);\n      addr_t bytes_to_read =\n          std::min<addr_t>(bytes_left, cache_line_bytes_left);\n      size_t bytes_read = ReadMemory(curr_addr, curr_dst, bytes_to_read, error);\n\n      if (bytes_read == 0) {\n        result_error = error;\n        dst[total_cstr_len] = '\\0';\n        break;\n      }\n      const size_t len = strlen(curr_dst);\n\n      total_cstr_len += len;\n\n      if (len < bytes_to_read)\n        break;\n\n      curr_dst += bytes_read;\n      curr_addr += bytes_read;\n      bytes_left -= bytes_read;\n    }\n  } else {\n    if (dst == nullptr)\n      result_error.SetErrorString(\"invalid arguments\");\n    else\n      result_error.Clear();\n  }\n  return total_cstr_len;\n}\n\nsize_t Process::ReadMemoryFromInferior(addr_t addr, void *buf, size_t size,\n                                       Status &error) {\n  if (buf == nullptr || size == 0)\n    return 0;\n\n  size_t bytes_read = 0;\n  uint8_t *bytes = (uint8_t *)buf;\n\n  while (bytes_read < size) {\n    const size_t curr_size = size - bytes_read;\n    const size_t curr_bytes_read =\n        DoReadMemory(addr + bytes_read, bytes + bytes_read, curr_size, error);\n    bytes_read += curr_bytes_read;\n    if (curr_bytes_read == curr_size || curr_bytes_read == 0)\n      break;\n  }\n\n  // Replace any software breakpoint opcodes that fall into this range back\n  // into \"buf\" before we return\n  if (bytes_read > 0)\n    RemoveBreakpointOpcodesFromBuffer(addr, bytes_read, (uint8_t *)buf);\n  return bytes_read;\n}\n\nuint64_t Process::ReadUnsignedIntegerFromMemory(lldb::addr_t vm_addr,\n                                                size_t integer_byte_size,\n                                                uint64_t fail_value,\n                                                Status &error) {\n  Scalar scalar;\n  if (ReadScalarIntegerFromMemory(vm_addr, integer_byte_size, false, scalar,\n                                  error))\n    return scalar.ULongLong(fail_value);\n  return fail_value;\n}\n\nint64_t Process::ReadSignedIntegerFromMemory(lldb::addr_t vm_addr,\n                                             size_t integer_byte_size,\n                                             int64_t fail_value,\n                                             Status &error) {\n  Scalar scalar;\n  if (ReadScalarIntegerFromMemory(vm_addr, integer_byte_size, true, scalar,\n                                  error))\n    return scalar.SLongLong(fail_value);\n  return fail_value;\n}\n\naddr_t Process::ReadPointerFromMemory(lldb::addr_t vm_addr, Status &error) {\n  Scalar scalar;\n  if (ReadScalarIntegerFromMemory(vm_addr, GetAddressByteSize(), false, scalar,\n                                  error))\n    return scalar.ULongLong(LLDB_INVALID_ADDRESS);\n  return LLDB_INVALID_ADDRESS;\n}\n\nbool Process::WritePointerToMemory(lldb::addr_t vm_addr, lldb::addr_t ptr_value,\n                                   Status &error) {\n  Scalar scalar;\n  const uint32_t addr_byte_size = GetAddressByteSize();\n  if (addr_byte_size <= 4)\n    scalar = (uint32_t)ptr_value;\n  else\n    scalar = ptr_value;\n  return WriteScalarToMemory(vm_addr, scalar, addr_byte_size, error) ==\n         addr_byte_size;\n}\n\nsize_t Process::WriteMemoryPrivate(addr_t addr, const void *buf, size_t size,\n                                   Status &error) {\n  size_t bytes_written = 0;\n  const uint8_t *bytes = (const uint8_t *)buf;\n\n  while (bytes_written < size) {\n    const size_t curr_size = size - bytes_written;\n    const size_t curr_bytes_written = DoWriteMemory(\n        addr + bytes_written, bytes + bytes_written, curr_size, error);\n    bytes_written += curr_bytes_written;\n    if (curr_bytes_written == curr_size || curr_bytes_written == 0)\n      break;\n  }\n  return bytes_written;\n}\n\nsize_t Process::WriteMemory(addr_t addr, const void *buf, size_t size,\n                            Status &error) {\n#if defined(ENABLE_MEMORY_CACHING)\n  m_memory_cache.Flush(addr, size);\n#endif\n\n  if (buf == nullptr || size == 0)\n    return 0;\n\n  m_mod_id.BumpMemoryID();\n\n  // We need to write any data that would go where any current software traps\n  // (enabled software breakpoints) any software traps (breakpoints) that we\n  // may have placed in our tasks memory.\n\n  BreakpointSiteList bp_sites_in_range;\n  if (!m_breakpoint_site_list.FindInRange(addr, addr + size, bp_sites_in_range))\n    return WriteMemoryPrivate(addr, buf, size, error);\n\n  // No breakpoint sites overlap\n  if (bp_sites_in_range.IsEmpty())\n    return WriteMemoryPrivate(addr, buf, size, error);\n\n  const uint8_t *ubuf = (const uint8_t *)buf;\n  uint64_t bytes_written = 0;\n\n  bp_sites_in_range.ForEach([this, addr, size, &bytes_written, &ubuf,\n                             &error](BreakpointSite *bp) -> void {\n    if (error.Fail())\n      return;\n\n    if (bp->GetType() != BreakpointSite::eSoftware)\n      return;\n\n    addr_t intersect_addr;\n    size_t intersect_size;\n    size_t opcode_offset;\n    const bool intersects = bp->IntersectsRange(\n        addr, size, &intersect_addr, &intersect_size, &opcode_offset);\n    UNUSED_IF_ASSERT_DISABLED(intersects);\n    assert(intersects);\n    assert(addr <= intersect_addr && intersect_addr < addr + size);\n    assert(addr < intersect_addr + intersect_size &&\n           intersect_addr + intersect_size <= addr + size);\n    assert(opcode_offset + intersect_size <= bp->GetByteSize());\n\n    // Check for bytes before this breakpoint\n    const addr_t curr_addr = addr + bytes_written;\n    if (intersect_addr > curr_addr) {\n      // There are some bytes before this breakpoint that we need to just\n      // write to memory\n      size_t curr_size = intersect_addr - curr_addr;\n      size_t curr_bytes_written =\n          WriteMemoryPrivate(curr_addr, ubuf + bytes_written, curr_size, error);\n      bytes_written += curr_bytes_written;\n      if (curr_bytes_written != curr_size) {\n        // We weren't able to write all of the requested bytes, we are\n        // done looping and will return the number of bytes that we have\n        // written so far.\n        if (error.Success())\n          error.SetErrorToGenericError();\n      }\n    }\n    // Now write any bytes that would cover up any software breakpoints\n    // directly into the breakpoint opcode buffer\n    ::memcpy(bp->GetSavedOpcodeBytes() + opcode_offset, ubuf + bytes_written,\n             intersect_size);\n    bytes_written += intersect_size;\n  });\n\n  // Write any remaining bytes after the last breakpoint if we have any left\n  if (bytes_written < size)\n    bytes_written +=\n        WriteMemoryPrivate(addr + bytes_written, ubuf + bytes_written,\n                           size - bytes_written, error);\n\n  return bytes_written;\n}\n\nsize_t Process::WriteScalarToMemory(addr_t addr, const Scalar &scalar,\n                                    size_t byte_size, Status &error) {\n  if (byte_size == UINT32_MAX)\n    byte_size = scalar.GetByteSize();\n  if (byte_size > 0) {\n    uint8_t buf[32];\n    const size_t mem_size =\n        scalar.GetAsMemoryData(buf, byte_size, GetByteOrder(), error);\n    if (mem_size > 0)\n      return WriteMemory(addr, buf, mem_size, error);\n    else\n      error.SetErrorString(\"failed to get scalar as memory data\");\n  } else {\n    error.SetErrorString(\"invalid scalar value\");\n  }\n  return 0;\n}\n\nsize_t Process::ReadScalarIntegerFromMemory(addr_t addr, uint32_t byte_size,\n                                            bool is_signed, Scalar &scalar,\n                                            Status &error) {\n  uint64_t uval = 0;\n  if (byte_size == 0) {\n    error.SetErrorString(\"byte size is zero\");\n  } else if (byte_size & (byte_size - 1)) {\n    error.SetErrorStringWithFormat(\"byte size %u is not a power of 2\",\n                                   byte_size);\n  } else if (byte_size <= sizeof(uval)) {\n    const size_t bytes_read = ReadMemory(addr, &uval, byte_size, error);\n    if (bytes_read == byte_size) {\n      DataExtractor data(&uval, sizeof(uval), GetByteOrder(),\n                         GetAddressByteSize());\n      lldb::offset_t offset = 0;\n      if (byte_size <= 4)\n        scalar = data.GetMaxU32(&offset, byte_size);\n      else\n        scalar = data.GetMaxU64(&offset, byte_size);\n      if (is_signed)\n        scalar.SignExtend(byte_size * 8);\n      return bytes_read;\n    }\n  } else {\n    error.SetErrorStringWithFormat(\n        \"byte size of %u is too large for integer scalar type\", byte_size);\n  }\n  return 0;\n}\n\nStatus Process::WriteObjectFile(std::vector<ObjectFile::LoadableData> entries) {\n  Status error;\n  for (const auto &Entry : entries) {\n    WriteMemory(Entry.Dest, Entry.Contents.data(), Entry.Contents.size(),\n                error);\n    if (!error.Success())\n      break;\n  }\n  return error;\n}\n\n#define USE_ALLOCATE_MEMORY_CACHE 1\naddr_t Process::AllocateMemory(size_t size, uint32_t permissions,\n                               Status &error) {\n  if (GetPrivateState() != eStateStopped) {\n    error.SetErrorToGenericError();\n    return LLDB_INVALID_ADDRESS;\n  }\n\n#if defined(USE_ALLOCATE_MEMORY_CACHE)\n  return m_allocated_memory_cache.AllocateMemory(size, permissions, error);\n#else\n  addr_t allocated_addr = DoAllocateMemory(size, permissions, error);\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(log,\n            \"Process::AllocateMemory(size=%\" PRIu64\n            \", permissions=%s) => 0x%16.16\" PRIx64\n            \" (m_stop_id = %u m_memory_id = %u)\",\n            (uint64_t)size, GetPermissionsAsCString(permissions),\n            (uint64_t)allocated_addr, m_mod_id.GetStopID(),\n            m_mod_id.GetMemoryID());\n  return allocated_addr;\n#endif\n}\n\naddr_t Process::CallocateMemory(size_t size, uint32_t permissions,\n                                Status &error) {\n  addr_t return_addr = AllocateMemory(size, permissions, error);\n  if (error.Success()) {\n    std::string buffer(size, 0);\n    WriteMemory(return_addr, buffer.c_str(), size, error);\n  }\n  return return_addr;\n}\n\nbool Process::CanJIT() {\n  if (m_can_jit == eCanJITDontKnow) {\n    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n    Status err;\n\n    uint64_t allocated_memory = AllocateMemory(\n        8, ePermissionsReadable | ePermissionsWritable | ePermissionsExecutable,\n        err);\n\n    if (err.Success()) {\n      m_can_jit = eCanJITYes;\n      LLDB_LOGF(log,\n                \"Process::%s pid %\" PRIu64\n                \" allocation test passed, CanJIT () is true\",\n                __FUNCTION__, GetID());\n    } else {\n      m_can_jit = eCanJITNo;\n      LLDB_LOGF(log,\n                \"Process::%s pid %\" PRIu64\n                \" allocation test failed, CanJIT () is false: %s\",\n                __FUNCTION__, GetID(), err.AsCString());\n    }\n\n    DeallocateMemory(allocated_memory);\n  }\n\n  return m_can_jit == eCanJITYes;\n}\n\nvoid Process::SetCanJIT(bool can_jit) {\n  m_can_jit = (can_jit ? eCanJITYes : eCanJITNo);\n}\n\nvoid Process::SetCanRunCode(bool can_run_code) {\n  SetCanJIT(can_run_code);\n  m_can_interpret_function_calls = can_run_code;\n}\n\nStatus Process::DeallocateMemory(addr_t ptr) {\n  Status error;\n#if defined(USE_ALLOCATE_MEMORY_CACHE)\n  if (!m_allocated_memory_cache.DeallocateMemory(ptr)) {\n    error.SetErrorStringWithFormat(\n        \"deallocation of memory at 0x%\" PRIx64 \" failed.\", (uint64_t)ptr);\n  }\n#else\n  error = DoDeallocateMemory(ptr);\n\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(log,\n            \"Process::DeallocateMemory(addr=0x%16.16\" PRIx64\n            \") => err = %s (m_stop_id = %u, m_memory_id = %u)\",\n            ptr, error.AsCString(\"SUCCESS\"), m_mod_id.GetStopID(),\n            m_mod_id.GetMemoryID());\n#endif\n  return error;\n}\n\nModuleSP Process::ReadModuleFromMemory(const FileSpec &file_spec,\n                                       lldb::addr_t header_addr,\n                                       size_t size_to_read) {\n  Log *log = lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_HOST);\n  if (log) {\n    LLDB_LOGF(log,\n              \"Process::ReadModuleFromMemory reading %s binary from memory\",\n              file_spec.GetPath().c_str());\n  }\n  ModuleSP module_sp(new Module(file_spec, ArchSpec()));\n  if (module_sp) {\n    Status error;\n    ObjectFile *objfile = module_sp->GetMemoryObjectFile(\n        shared_from_this(), header_addr, error, size_to_read);\n    if (objfile)\n      return module_sp;\n  }\n  return ModuleSP();\n}\n\nbool Process::GetLoadAddressPermissions(lldb::addr_t load_addr,\n                                        uint32_t &permissions) {\n  MemoryRegionInfo range_info;\n  permissions = 0;\n  Status error(GetMemoryRegionInfo(load_addr, range_info));\n  if (!error.Success())\n    return false;\n  if (range_info.GetReadable() == MemoryRegionInfo::eDontKnow ||\n      range_info.GetWritable() == MemoryRegionInfo::eDontKnow ||\n      range_info.GetExecutable() == MemoryRegionInfo::eDontKnow) {\n    return false;\n  }\n\n  if (range_info.GetReadable() == MemoryRegionInfo::eYes)\n    permissions |= lldb::ePermissionsReadable;\n\n  if (range_info.GetWritable() == MemoryRegionInfo::eYes)\n    permissions |= lldb::ePermissionsWritable;\n\n  if (range_info.GetExecutable() == MemoryRegionInfo::eYes)\n    permissions |= lldb::ePermissionsExecutable;\n\n  return true;\n}\n\nStatus Process::EnableWatchpoint(Watchpoint *watchpoint, bool notify) {\n  Status error;\n  error.SetErrorString(\"watchpoints are not supported\");\n  return error;\n}\n\nStatus Process::DisableWatchpoint(Watchpoint *watchpoint, bool notify) {\n  Status error;\n  error.SetErrorString(\"watchpoints are not supported\");\n  return error;\n}\n\nStateType\nProcess::WaitForProcessStopPrivate(EventSP &event_sp,\n                                   const Timeout<std::micro> &timeout) {\n  StateType state;\n\n  while (true) {\n    event_sp.reset();\n    state = GetStateChangedEventsPrivate(event_sp, timeout);\n\n    if (StateIsStoppedState(state, false))\n      break;\n\n    // If state is invalid, then we timed out\n    if (state == eStateInvalid)\n      break;\n\n    if (event_sp)\n      HandlePrivateEvent(event_sp);\n  }\n  return state;\n}\n\nvoid Process::LoadOperatingSystemPlugin(bool flush) {\n  if (flush)\n    m_thread_list.Clear();\n  m_os_up.reset(OperatingSystem::FindPlugin(this, nullptr));\n  if (flush)\n    Flush();\n}\n\nStatus Process::Launch(ProcessLaunchInfo &launch_info) {\n  Status error;\n  m_abi_sp.reset();\n  m_dyld_up.reset();\n  m_jit_loaders_up.reset();\n  m_system_runtime_up.reset();\n  m_os_up.reset();\n  m_process_input_reader.reset();\n\n  Module *exe_module = GetTarget().GetExecutableModulePointer();\n  if (!exe_module) {\n    error.SetErrorString(\"executable module does not exist\");\n    return error;\n  }\n\n  char local_exec_file_path[PATH_MAX];\n  char platform_exec_file_path[PATH_MAX];\n  exe_module->GetFileSpec().GetPath(local_exec_file_path,\n                                    sizeof(local_exec_file_path));\n  exe_module->GetPlatformFileSpec().GetPath(platform_exec_file_path,\n                                            sizeof(platform_exec_file_path));\n  if (FileSystem::Instance().Exists(exe_module->GetFileSpec())) {\n    // Install anything that might need to be installed prior to launching.\n    // For host systems, this will do nothing, but if we are connected to a\n    // remote platform it will install any needed binaries\n    error = GetTarget().Install(&launch_info);\n    if (error.Fail())\n      return error;\n\n    if (PrivateStateThreadIsValid())\n      PausePrivateStateThread();\n\n    error = WillLaunch(exe_module);\n    if (error.Success()) {\n      const bool restarted = false;\n      SetPublicState(eStateLaunching, restarted);\n      m_should_detach = false;\n\n      if (m_public_run_lock.TrySetRunning()) {\n        // Now launch using these arguments.\n        error = DoLaunch(exe_module, launch_info);\n      } else {\n        // This shouldn't happen\n        error.SetErrorString(\"failed to acquire process run lock\");\n      }\n\n      if (error.Fail()) {\n        if (GetID() != LLDB_INVALID_PROCESS_ID) {\n          SetID(LLDB_INVALID_PROCESS_ID);\n          const char *error_string = error.AsCString();\n          if (error_string == nullptr)\n            error_string = \"launch failed\";\n          SetExitStatus(-1, error_string);\n        }\n      } else {\n        EventSP event_sp;\n\n        // Now wait for the process to launch and return control to us, and then\n        // call DidLaunch:\n        StateType state = WaitForProcessStopPrivate(event_sp, seconds(10));\n\n        if (state == eStateInvalid || !event_sp) {\n          // We were able to launch the process, but we failed to catch the\n          // initial stop.\n          error.SetErrorString(\"failed to catch stop after launch\");\n          SetExitStatus(0, \"failed to catch stop after launch\");\n          Destroy(false);\n        } else if (state == eStateStopped || state == eStateCrashed) {\n          DidLaunch();\n\n          DynamicLoader *dyld = GetDynamicLoader();\n          if (dyld)\n            dyld->DidLaunch();\n\n          GetJITLoaders().DidLaunch();\n\n          SystemRuntime *system_runtime = GetSystemRuntime();\n          if (system_runtime)\n            system_runtime->DidLaunch();\n\n          if (!m_os_up)\n            LoadOperatingSystemPlugin(false);\n\n          // We successfully launched the process and stopped, now it the\n          // right time to set up signal filters before resuming.\n          UpdateAutomaticSignalFiltering();\n\n          // Note, the stop event was consumed above, but not handled. This\n          // was done to give DidLaunch a chance to run. The target is either\n          // stopped or crashed. Directly set the state.  This is done to\n          // prevent a stop message with a bunch of spurious output on thread\n          // status, as well as not pop a ProcessIOHandler.\n          SetPublicState(state, false);\n\n          if (PrivateStateThreadIsValid())\n            ResumePrivateStateThread();\n          else\n            StartPrivateStateThread();\n\n          // Target was stopped at entry as was intended. Need to notify the\n          // listeners about it.\n          if (state == eStateStopped &&\n              launch_info.GetFlags().Test(eLaunchFlagStopAtEntry))\n            HandlePrivateEvent(event_sp);\n        } else if (state == eStateExited) {\n          // We exited while trying to launch somehow.  Don't call DidLaunch\n          // as that's not likely to work, and return an invalid pid.\n          HandlePrivateEvent(event_sp);\n        }\n      }\n    }\n  } else {\n    error.SetErrorStringWithFormat(\"file doesn't exist: '%s'\",\n                                   local_exec_file_path);\n  }\n\n  return error;\n}\n\nStatus Process::LoadCore() {\n  Status error = DoLoadCore();\n  if (error.Success()) {\n    ListenerSP listener_sp(\n        Listener::MakeListener(\"lldb.process.load_core_listener\"));\n    HijackProcessEvents(listener_sp);\n\n    if (PrivateStateThreadIsValid())\n      ResumePrivateStateThread();\n    else\n      StartPrivateStateThread();\n\n    DynamicLoader *dyld = GetDynamicLoader();\n    if (dyld)\n      dyld->DidAttach();\n\n    GetJITLoaders().DidAttach();\n\n    SystemRuntime *system_runtime = GetSystemRuntime();\n    if (system_runtime)\n      system_runtime->DidAttach();\n\n    if (!m_os_up)\n      LoadOperatingSystemPlugin(false);\n\n    // We successfully loaded a core file, now pretend we stopped so we can\n    // show all of the threads in the core file and explore the crashed state.\n    SetPrivateState(eStateStopped);\n\n    // Wait for a stopped event since we just posted one above...\n    lldb::EventSP event_sp;\n    StateType state =\n        WaitForProcessToStop(llvm::None, &event_sp, true, listener_sp);\n\n    if (!StateIsStoppedState(state, false)) {\n      Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n      LLDB_LOGF(log, \"Process::Halt() failed to stop, state is: %s\",\n                StateAsCString(state));\n      error.SetErrorString(\n          \"Did not get stopped event after loading the core file.\");\n    }\n    RestoreProcessEvents();\n  }\n  return error;\n}\n\nDynamicLoader *Process::GetDynamicLoader() {\n  if (!m_dyld_up)\n    m_dyld_up.reset(DynamicLoader::FindPlugin(this, nullptr));\n  return m_dyld_up.get();\n}\n\nDataExtractor Process::GetAuxvData() { return DataExtractor(); }\n\nJITLoaderList &Process::GetJITLoaders() {\n  if (!m_jit_loaders_up) {\n    m_jit_loaders_up = std::make_unique<JITLoaderList>();\n    JITLoader::LoadPlugins(this, *m_jit_loaders_up);\n  }\n  return *m_jit_loaders_up;\n}\n\nSystemRuntime *Process::GetSystemRuntime() {\n  if (!m_system_runtime_up)\n    m_system_runtime_up.reset(SystemRuntime::FindPlugin(this));\n  return m_system_runtime_up.get();\n}\n\nProcess::AttachCompletionHandler::AttachCompletionHandler(Process *process,\n                                                          uint32_t exec_count)\n    : NextEventAction(process), m_exec_count(exec_count) {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(\n      log,\n      \"Process::AttachCompletionHandler::%s process=%p, exec_count=%\" PRIu32,\n      __FUNCTION__, static_cast<void *>(process), exec_count);\n}\n\nProcess::NextEventAction::EventActionResult\nProcess::AttachCompletionHandler::PerformAction(lldb::EventSP &event_sp) {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n\n  StateType state = ProcessEventData::GetStateFromEvent(event_sp.get());\n  LLDB_LOGF(log,\n            \"Process::AttachCompletionHandler::%s called with state %s (%d)\",\n            __FUNCTION__, StateAsCString(state), static_cast<int>(state));\n\n  switch (state) {\n  case eStateAttaching:\n    return eEventActionSuccess;\n\n  case eStateRunning:\n  case eStateConnected:\n    return eEventActionRetry;\n\n  case eStateStopped:\n  case eStateCrashed:\n    // During attach, prior to sending the eStateStopped event,\n    // lldb_private::Process subclasses must set the new process ID.\n    assert(m_process->GetID() != LLDB_INVALID_PROCESS_ID);\n    // We don't want these events to be reported, so go set the\n    // ShouldReportStop here:\n    m_process->GetThreadList().SetShouldReportStop(eVoteNo);\n\n    if (m_exec_count > 0) {\n      --m_exec_count;\n\n      LLDB_LOGF(log,\n                \"Process::AttachCompletionHandler::%s state %s: reduced \"\n                \"remaining exec count to %\" PRIu32 \", requesting resume\",\n                __FUNCTION__, StateAsCString(state), m_exec_count);\n\n      RequestResume();\n      return eEventActionRetry;\n    } else {\n      LLDB_LOGF(log,\n                \"Process::AttachCompletionHandler::%s state %s: no more \"\n                \"execs expected to start, continuing with attach\",\n                __FUNCTION__, StateAsCString(state));\n\n      m_process->CompleteAttach();\n      return eEventActionSuccess;\n    }\n    break;\n\n  default:\n  case eStateExited:\n  case eStateInvalid:\n    break;\n  }\n\n  m_exit_string.assign(\"No valid Process\");\n  return eEventActionExit;\n}\n\nProcess::NextEventAction::EventActionResult\nProcess::AttachCompletionHandler::HandleBeingInterrupted() {\n  return eEventActionSuccess;\n}\n\nconst char *Process::AttachCompletionHandler::GetExitString() {\n  return m_exit_string.c_str();\n}\n\nListenerSP ProcessAttachInfo::GetListenerForProcess(Debugger &debugger) {\n  if (m_listener_sp)\n    return m_listener_sp;\n  else\n    return debugger.GetListener();\n}\n\nStatus Process::Attach(ProcessAttachInfo &attach_info) {\n  m_abi_sp.reset();\n  m_process_input_reader.reset();\n  m_dyld_up.reset();\n  m_jit_loaders_up.reset();\n  m_system_runtime_up.reset();\n  m_os_up.reset();\n\n  lldb::pid_t attach_pid = attach_info.GetProcessID();\n  Status error;\n  if (attach_pid == LLDB_INVALID_PROCESS_ID) {\n    char process_name[PATH_MAX];\n\n    if (attach_info.GetExecutableFile().GetPath(process_name,\n                                                sizeof(process_name))) {\n      const bool wait_for_launch = attach_info.GetWaitForLaunch();\n\n      if (wait_for_launch) {\n        error = WillAttachToProcessWithName(process_name, wait_for_launch);\n        if (error.Success()) {\n          if (m_public_run_lock.TrySetRunning()) {\n            m_should_detach = true;\n            const bool restarted = false;\n            SetPublicState(eStateAttaching, restarted);\n            // Now attach using these arguments.\n            error = DoAttachToProcessWithName(process_name, attach_info);\n          } else {\n            // This shouldn't happen\n            error.SetErrorString(\"failed to acquire process run lock\");\n          }\n\n          if (error.Fail()) {\n            if (GetID() != LLDB_INVALID_PROCESS_ID) {\n              SetID(LLDB_INVALID_PROCESS_ID);\n              if (error.AsCString() == nullptr)\n                error.SetErrorString(\"attach failed\");\n\n              SetExitStatus(-1, error.AsCString());\n            }\n          } else {\n            SetNextEventAction(new Process::AttachCompletionHandler(\n                this, attach_info.GetResumeCount()));\n            StartPrivateStateThread();\n          }\n          return error;\n        }\n      } else {\n        ProcessInstanceInfoList process_infos;\n        PlatformSP platform_sp(GetTarget().GetPlatform());\n\n        if (platform_sp) {\n          ProcessInstanceInfoMatch match_info;\n          match_info.GetProcessInfo() = attach_info;\n          match_info.SetNameMatchType(NameMatch::Equals);\n          platform_sp->FindProcesses(match_info, process_infos);\n          const uint32_t num_matches = process_infos.size();\n          if (num_matches == 1) {\n            attach_pid = process_infos[0].GetProcessID();\n            // Fall through and attach using the above process ID\n          } else {\n            match_info.GetProcessInfo().GetExecutableFile().GetPath(\n                process_name, sizeof(process_name));\n            if (num_matches > 1) {\n              StreamString s;\n              ProcessInstanceInfo::DumpTableHeader(s, true, false);\n              for (size_t i = 0; i < num_matches; i++) {\n                process_infos[i].DumpAsTableRow(\n                    s, platform_sp->GetUserIDResolver(), true, false);\n              }\n              error.SetErrorStringWithFormat(\n                  \"more than one process named %s:\\n%s\", process_name,\n                  s.GetData());\n            } else\n              error.SetErrorStringWithFormat(\n                  \"could not find a process named %s\", process_name);\n          }\n        } else {\n          error.SetErrorString(\n              \"invalid platform, can't find processes by name\");\n          return error;\n        }\n      }\n    } else {\n      error.SetErrorString(\"invalid process name\");\n    }\n  }\n\n  if (attach_pid != LLDB_INVALID_PROCESS_ID) {\n    error = WillAttachToProcessWithID(attach_pid);\n    if (error.Success()) {\n\n      if (m_public_run_lock.TrySetRunning()) {\n        // Now attach using these arguments.\n        m_should_detach = true;\n        const bool restarted = false;\n        SetPublicState(eStateAttaching, restarted);\n        error = DoAttachToProcessWithID(attach_pid, attach_info);\n      } else {\n        // This shouldn't happen\n        error.SetErrorString(\"failed to acquire process run lock\");\n      }\n\n      if (error.Success()) {\n        SetNextEventAction(new Process::AttachCompletionHandler(\n            this, attach_info.GetResumeCount()));\n        StartPrivateStateThread();\n      } else {\n        if (GetID() != LLDB_INVALID_PROCESS_ID)\n          SetID(LLDB_INVALID_PROCESS_ID);\n\n        const char *error_string = error.AsCString();\n        if (error_string == nullptr)\n          error_string = \"attach failed\";\n\n        SetExitStatus(-1, error_string);\n      }\n    }\n  }\n  return error;\n}\n\nvoid Process::CompleteAttach() {\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_PROCESS |\n                                                  LIBLLDB_LOG_TARGET));\n  LLDB_LOGF(log, \"Process::%s()\", __FUNCTION__);\n\n  // Let the process subclass figure out at much as it can about the process\n  // before we go looking for a dynamic loader plug-in.\n  ArchSpec process_arch;\n  DidAttach(process_arch);\n\n  if (process_arch.IsValid()) {\n    GetTarget().SetArchitecture(process_arch);\n    if (log) {\n      const char *triple_str = process_arch.GetTriple().getTriple().c_str();\n      LLDB_LOGF(log,\n                \"Process::%s replacing process architecture with DidAttach() \"\n                \"architecture: %s\",\n                __FUNCTION__, triple_str ? triple_str : \"<null>\");\n    }\n  }\n\n  // We just attached.  If we have a platform, ask it for the process\n  // architecture, and if it isn't the same as the one we've already set,\n  // switch architectures.\n  PlatformSP platform_sp(GetTarget().GetPlatform());\n  assert(platform_sp);\n  if (platform_sp) {\n    const ArchSpec &target_arch = GetTarget().GetArchitecture();\n    if (target_arch.IsValid() &&\n        !platform_sp->IsCompatibleArchitecture(target_arch, false, nullptr)) {\n      ArchSpec platform_arch;\n      platform_sp =\n          platform_sp->GetPlatformForArchitecture(target_arch, &platform_arch);\n      if (platform_sp) {\n        GetTarget().SetPlatform(platform_sp);\n        GetTarget().SetArchitecture(platform_arch);\n        LLDB_LOGF(log,\n                  \"Process::%s switching platform to %s and architecture \"\n                  \"to %s based on info from attach\",\n                  __FUNCTION__, platform_sp->GetName().AsCString(\"\"),\n                  platform_arch.GetTriple().getTriple().c_str());\n      }\n    } else if (!process_arch.IsValid()) {\n      ProcessInstanceInfo process_info;\n      GetProcessInfo(process_info);\n      const ArchSpec &process_arch = process_info.GetArchitecture();\n      const ArchSpec &target_arch = GetTarget().GetArchitecture();\n      if (process_arch.IsValid() &&\n          target_arch.IsCompatibleMatch(process_arch) &&\n          !target_arch.IsExactMatch(process_arch)) {\n        GetTarget().SetArchitecture(process_arch);\n        LLDB_LOGF(log,\n                  \"Process::%s switching architecture to %s based on info \"\n                  \"the platform retrieved for pid %\" PRIu64,\n                  __FUNCTION__, process_arch.GetTriple().getTriple().c_str(),\n                  GetID());\n      }\n    }\n  }\n\n  // We have completed the attach, now it is time to find the dynamic loader\n  // plug-in\n  DynamicLoader *dyld = GetDynamicLoader();\n  if (dyld) {\n    dyld->DidAttach();\n    if (log) {\n      ModuleSP exe_module_sp = GetTarget().GetExecutableModule();\n      LLDB_LOGF(log,\n                \"Process::%s after DynamicLoader::DidAttach(), target \"\n                \"executable is %s (using %s plugin)\",\n                __FUNCTION__,\n                exe_module_sp ? exe_module_sp->GetFileSpec().GetPath().c_str()\n                              : \"<none>\",\n                dyld->GetPluginName().AsCString(\"<unnamed>\"));\n    }\n  }\n\n  GetJITLoaders().DidAttach();\n\n  SystemRuntime *system_runtime = GetSystemRuntime();\n  if (system_runtime) {\n    system_runtime->DidAttach();\n    if (log) {\n      ModuleSP exe_module_sp = GetTarget().GetExecutableModule();\n      LLDB_LOGF(log,\n                \"Process::%s after SystemRuntime::DidAttach(), target \"\n                \"executable is %s (using %s plugin)\",\n                __FUNCTION__,\n                exe_module_sp ? exe_module_sp->GetFileSpec().GetPath().c_str()\n                              : \"<none>\",\n                system_runtime->GetPluginName().AsCString(\"<unnamed>\"));\n    }\n  }\n\n  if (!m_os_up) {\n    LoadOperatingSystemPlugin(false);\n    if (m_os_up) {\n      // Somebody might have gotten threads before now, but we need to force the\n      // update after we've loaded the OperatingSystem plugin or it won't get a\n      // chance to process the threads.\n      m_thread_list.Clear();\n      UpdateThreadListIfNeeded();\n    }\n  }\n  // Figure out which one is the executable, and set that in our target:\n  ModuleSP new_executable_module_sp;\n  for (ModuleSP module_sp : GetTarget().GetImages().Modules()) {\n    if (module_sp && module_sp->IsExecutable()) {\n      if (GetTarget().GetExecutableModulePointer() != module_sp.get())\n        new_executable_module_sp = module_sp;\n      break;\n    }\n  }\n  if (new_executable_module_sp) {\n    GetTarget().SetExecutableModule(new_executable_module_sp,\n                                    eLoadDependentsNo);\n    if (log) {\n      ModuleSP exe_module_sp = GetTarget().GetExecutableModule();\n      LLDB_LOGF(\n          log,\n          \"Process::%s after looping through modules, target executable is %s\",\n          __FUNCTION__,\n          exe_module_sp ? exe_module_sp->GetFileSpec().GetPath().c_str()\n                        : \"<none>\");\n    }\n  }\n}\n\nStatus Process::ConnectRemote(llvm::StringRef remote_url) {\n  m_abi_sp.reset();\n  m_process_input_reader.reset();\n\n  // Find the process and its architecture.  Make sure it matches the\n  // architecture of the current Target, and if not adjust it.\n\n  Status error(DoConnectRemote(remote_url));\n  if (error.Success()) {\n    if (GetID() != LLDB_INVALID_PROCESS_ID) {\n      EventSP event_sp;\n      StateType state = WaitForProcessStopPrivate(event_sp, llvm::None);\n\n      if (state == eStateStopped || state == eStateCrashed) {\n        // If we attached and actually have a process on the other end, then\n        // this ended up being the equivalent of an attach.\n        CompleteAttach();\n\n        // This delays passing the stopped event to listeners till\n        // CompleteAttach gets a chance to complete...\n        HandlePrivateEvent(event_sp);\n      }\n    }\n\n    if (PrivateStateThreadIsValid())\n      ResumePrivateStateThread();\n    else\n      StartPrivateStateThread();\n  }\n  return error;\n}\n\nStatus Process::PrivateResume() {\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_PROCESS |\n                                                  LIBLLDB_LOG_STEP));\n  LLDB_LOGF(log,\n            \"Process::PrivateResume() m_stop_id = %u, public state: %s \"\n            \"private state: %s\",\n            m_mod_id.GetStopID(), StateAsCString(m_public_state.GetValue()),\n            StateAsCString(m_private_state.GetValue()));\n\n  // If signals handing status changed we might want to update our signal\n  // filters before resuming.\n  UpdateAutomaticSignalFiltering();\n\n  Status error(WillResume());\n  // Tell the process it is about to resume before the thread list\n  if (error.Success()) {\n    // Now let the thread list know we are about to resume so it can let all of\n    // our threads know that they are about to be resumed. Threads will each be\n    // called with Thread::WillResume(StateType) where StateType contains the\n    // state that they are supposed to have when the process is resumed\n    // (suspended/running/stepping). Threads should also check their resume\n    // signal in lldb::Thread::GetResumeSignal() to see if they are supposed to\n    // start back up with a signal.\n    if (m_thread_list.WillResume()) {\n      // Last thing, do the PreResumeActions.\n      if (!RunPreResumeActions()) {\n        error.SetErrorString(\n            \"Process::PrivateResume PreResumeActions failed, not resuming.\");\n      } else {\n        m_mod_id.BumpResumeID();\n        error = DoResume();\n        if (error.Success()) {\n          DidResume();\n          m_thread_list.DidResume();\n          LLDB_LOGF(log, \"Process thinks the process has resumed.\");\n        } else {\n          LLDB_LOGF(log, \"Process::PrivateResume() DoResume failed.\");\n          return error;\n        }\n      }\n    } else {\n      // Somebody wanted to run without running (e.g. we were faking a step\n      // from one frame of a set of inlined frames that share the same PC to\n      // another.)  So generate a continue & a stopped event, and let the world\n      // handle them.\n      LLDB_LOGF(log,\n                \"Process::PrivateResume() asked to simulate a start & stop.\");\n\n      SetPrivateState(eStateRunning);\n      SetPrivateState(eStateStopped);\n    }\n  } else\n    LLDB_LOGF(log, \"Process::PrivateResume() got an error \\\"%s\\\".\",\n              error.AsCString(\"<unknown error>\"));\n  return error;\n}\n\nStatus Process::Halt(bool clear_thread_plans, bool use_run_lock) {\n  if (!StateIsRunningState(m_public_state.GetValue()))\n    return Status(\"Process is not running.\");\n\n  // Don't clear the m_clear_thread_plans_on_stop, only set it to true if in\n  // case it was already set and some thread plan logic calls halt on its own.\n  m_clear_thread_plans_on_stop |= clear_thread_plans;\n\n  ListenerSP halt_listener_sp(\n      Listener::MakeListener(\"lldb.process.halt_listener\"));\n  HijackProcessEvents(halt_listener_sp);\n\n  EventSP event_sp;\n\n  SendAsyncInterrupt();\n\n  if (m_public_state.GetValue() == eStateAttaching) {\n    // Don't hijack and eat the eStateExited as the code that was doing the\n    // attach will be waiting for this event...\n    RestoreProcessEvents();\n    SetExitStatus(SIGKILL, \"Cancelled async attach.\");\n    Destroy(false);\n    return Status();\n  }\n\n  // Wait for 10 second for the process to stop.\n  StateType state = WaitForProcessToStop(\n      seconds(10), &event_sp, true, halt_listener_sp, nullptr, use_run_lock);\n  RestoreProcessEvents();\n\n  if (state == eStateInvalid || !event_sp) {\n    // We timed out and didn't get a stop event...\n    return Status(\"Halt timed out. State = %s\", StateAsCString(GetState()));\n  }\n\n  BroadcastEvent(event_sp);\n\n  return Status();\n}\n\nStatus Process::StopForDestroyOrDetach(lldb::EventSP &exit_event_sp) {\n  Status error;\n\n  // Check both the public & private states here.  If we're hung evaluating an\n  // expression, for instance, then the public state will be stopped, but we\n  // still need to interrupt.\n  if (m_public_state.GetValue() == eStateRunning ||\n      m_private_state.GetValue() == eStateRunning) {\n    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n    LLDB_LOGF(log, \"Process::%s() About to stop.\", __FUNCTION__);\n\n    ListenerSP listener_sp(\n        Listener::MakeListener(\"lldb.Process.StopForDestroyOrDetach.hijack\"));\n    HijackProcessEvents(listener_sp);\n\n    SendAsyncInterrupt();\n\n    // Consume the interrupt event.\n    StateType state =\n        WaitForProcessToStop(seconds(10), &exit_event_sp, true, listener_sp);\n\n    RestoreProcessEvents();\n\n    // If the process exited while we were waiting for it to stop, put the\n    // exited event into the shared pointer passed in and return.  Our caller\n    // doesn't need to do anything else, since they don't have a process\n    // anymore...\n\n    if (state == eStateExited || m_private_state.GetValue() == eStateExited) {\n      LLDB_LOGF(log, \"Process::%s() Process exited while waiting to stop.\",\n                __FUNCTION__);\n      return error;\n    } else\n      exit_event_sp.reset(); // It is ok to consume any non-exit stop events\n\n    if (state != eStateStopped) {\n      LLDB_LOGF(log, \"Process::%s() failed to stop, state is: %s\", __FUNCTION__,\n                StateAsCString(state));\n      // If we really couldn't stop the process then we should just error out\n      // here, but if the lower levels just bobbled sending the event and we\n      // really are stopped, then continue on.\n      StateType private_state = m_private_state.GetValue();\n      if (private_state != eStateStopped) {\n        return Status(\n            \"Attempt to stop the target in order to detach timed out. \"\n            \"State = %s\",\n            StateAsCString(GetState()));\n      }\n    }\n  }\n  return error;\n}\n\nStatus Process::Detach(bool keep_stopped) {\n  EventSP exit_event_sp;\n  Status error;\n  m_destroy_in_process = true;\n\n  error = WillDetach();\n\n  if (error.Success()) {\n    if (DetachRequiresHalt()) {\n      error = StopForDestroyOrDetach(exit_event_sp);\n      if (!error.Success()) {\n        m_destroy_in_process = false;\n        return error;\n      } else if (exit_event_sp) {\n        // We shouldn't need to do anything else here.  There's no process left\n        // to detach from...\n        StopPrivateStateThread();\n        m_destroy_in_process = false;\n        return error;\n      }\n    }\n\n    m_thread_list.DiscardThreadPlans();\n    DisableAllBreakpointSites();\n\n    error = DoDetach(keep_stopped);\n    if (error.Success()) {\n      DidDetach();\n      StopPrivateStateThread();\n    } else {\n      return error;\n    }\n  }\n  m_destroy_in_process = false;\n\n  // If we exited when we were waiting for a process to stop, then forward the\n  // event here so we don't lose the event\n  if (exit_event_sp) {\n    // Directly broadcast our exited event because we shut down our private\n    // state thread above\n    BroadcastEvent(exit_event_sp);\n  }\n\n  // If we have been interrupted (to kill us) in the middle of running, we may\n  // not end up propagating the last events through the event system, in which\n  // case we might strand the write lock.  Unlock it here so when we do to tear\n  // down the process we don't get an error destroying the lock.\n\n  m_public_run_lock.SetStopped();\n  return error;\n}\n\nStatus Process::Destroy(bool force_kill) {\n  // If we've already called Process::Finalize then there's nothing useful to\n  // be done here.  Finalize has actually called Destroy already.\n  if (m_finalizing)\n    return {};\n  return DestroyImpl(force_kill);\n}\n\nStatus Process::DestroyImpl(bool force_kill) {\n  // Tell ourselves we are in the process of destroying the process, so that we\n  // don't do any unnecessary work that might hinder the destruction.  Remember\n  // to set this back to false when we are done.  That way if the attempt\n  // failed and the process stays around for some reason it won't be in a\n  // confused state.\n\n  if (force_kill)\n    m_should_detach = false;\n\n  if (GetShouldDetach()) {\n    // FIXME: This will have to be a process setting:\n    bool keep_stopped = false;\n    Detach(keep_stopped);\n  }\n\n  m_destroy_in_process = true;\n\n  Status error(WillDestroy());\n  if (error.Success()) {\n    EventSP exit_event_sp;\n    if (DestroyRequiresHalt()) {\n      error = StopForDestroyOrDetach(exit_event_sp);\n    }\n\n    if (m_public_state.GetValue() != eStateRunning) {\n      // Ditch all thread plans, and remove all our breakpoints: in case we\n      // have to restart the target to kill it, we don't want it hitting a\n      // breakpoint... Only do this if we've stopped, however, since if we\n      // didn't manage to halt it above, then we're not going to have much luck\n      // doing this now.\n      m_thread_list.DiscardThreadPlans();\n      DisableAllBreakpointSites();\n    }\n\n    error = DoDestroy();\n    if (error.Success()) {\n      DidDestroy();\n      StopPrivateStateThread();\n    }\n    m_stdio_communication.StopReadThread();\n    m_stdio_communication.Disconnect();\n    m_stdin_forward = false;\n\n    if (m_process_input_reader) {\n      m_process_input_reader->SetIsDone(true);\n      m_process_input_reader->Cancel();\n      m_process_input_reader.reset();\n    }\n\n    // If we exited when we were waiting for a process to stop, then forward\n    // the event here so we don't lose the event\n    if (exit_event_sp) {\n      // Directly broadcast our exited event because we shut down our private\n      // state thread above\n      BroadcastEvent(exit_event_sp);\n    }\n\n    // If we have been interrupted (to kill us) in the middle of running, we\n    // may not end up propagating the last events through the event system, in\n    // which case we might strand the write lock.  Unlock it here so when we do\n    // to tear down the process we don't get an error destroying the lock.\n    m_public_run_lock.SetStopped();\n  }\n\n  m_destroy_in_process = false;\n\n  return error;\n}\n\nStatus Process::Signal(int signal) {\n  Status error(WillSignal());\n  if (error.Success()) {\n    error = DoSignal(signal);\n    if (error.Success())\n      DidSignal();\n  }\n  return error;\n}\n\nvoid Process::SetUnixSignals(UnixSignalsSP &&signals_sp) {\n  assert(signals_sp && \"null signals_sp\");\n  m_unix_signals_sp = signals_sp;\n}\n\nconst lldb::UnixSignalsSP &Process::GetUnixSignals() {\n  assert(m_unix_signals_sp && \"null m_unix_signals_sp\");\n  return m_unix_signals_sp;\n}\n\nlldb::ByteOrder Process::GetByteOrder() const {\n  return GetTarget().GetArchitecture().GetByteOrder();\n}\n\nuint32_t Process::GetAddressByteSize() const {\n  return GetTarget().GetArchitecture().GetAddressByteSize();\n}\n\nbool Process::ShouldBroadcastEvent(Event *event_ptr) {\n  const StateType state =\n      Process::ProcessEventData::GetStateFromEvent(event_ptr);\n  bool return_value = true;\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_EVENTS |\n                                                  LIBLLDB_LOG_PROCESS));\n\n  switch (state) {\n  case eStateDetached:\n  case eStateExited:\n  case eStateUnloaded:\n    m_stdio_communication.SynchronizeWithReadThread();\n    m_stdio_communication.StopReadThread();\n    m_stdio_communication.Disconnect();\n    m_stdin_forward = false;\n\n    LLVM_FALLTHROUGH;\n  case eStateConnected:\n  case eStateAttaching:\n  case eStateLaunching:\n    // These events indicate changes in the state of the debugging session,\n    // always report them.\n    return_value = true;\n    break;\n  case eStateInvalid:\n    // We stopped for no apparent reason, don't report it.\n    return_value = false;\n    break;\n  case eStateRunning:\n  case eStateStepping:\n    // If we've started the target running, we handle the cases where we are\n    // already running and where there is a transition from stopped to running\n    // differently. running -> running: Automatically suppress extra running\n    // events stopped -> running: Report except when there is one or more no\n    // votes\n    //     and no yes votes.\n    SynchronouslyNotifyStateChanged(state);\n    if (m_force_next_event_delivery)\n      return_value = true;\n    else {\n      switch (m_last_broadcast_state) {\n      case eStateRunning:\n      case eStateStepping:\n        // We always suppress multiple runnings with no PUBLIC stop in between.\n        return_value = false;\n        break;\n      default:\n        // TODO: make this work correctly. For now always report\n        // run if we aren't running so we don't miss any running events. If I\n        // run the lldb/test/thread/a.out file and break at main.cpp:58, run\n        // and hit the breakpoints on multiple threads, then somehow during the\n        // stepping over of all breakpoints no run gets reported.\n\n        // This is a transition from stop to run.\n        switch (m_thread_list.ShouldReportRun(event_ptr)) {\n        case eVoteYes:\n        case eVoteNoOpinion:\n          return_value = true;\n          break;\n        case eVoteNo:\n          return_value = false;\n          break;\n        }\n        break;\n      }\n    }\n    break;\n  case eStateStopped:\n  case eStateCrashed:\n  case eStateSuspended:\n    // We've stopped.  First see if we're going to restart the target. If we\n    // are going to stop, then we always broadcast the event. If we aren't\n    // going to stop, let the thread plans decide if we're going to report this\n    // event. If no thread has an opinion, we don't report it.\n\n    m_stdio_communication.SynchronizeWithReadThread();\n    RefreshStateAfterStop();\n    if (ProcessEventData::GetInterruptedFromEvent(event_ptr)) {\n      LLDB_LOGF(log,\n                \"Process::ShouldBroadcastEvent (%p) stopped due to an \"\n                \"interrupt, state: %s\",\n                static_cast<void *>(event_ptr), StateAsCString(state));\n      // Even though we know we are going to stop, we should let the threads\n      // have a look at the stop, so they can properly set their state.\n      m_thread_list.ShouldStop(event_ptr);\n      return_value = true;\n    } else {\n      bool was_restarted = ProcessEventData::GetRestartedFromEvent(event_ptr);\n      bool should_resume = false;\n\n      // It makes no sense to ask \"ShouldStop\" if we've already been\n      // restarted... Asking the thread list is also not likely to go well,\n      // since we are running again. So in that case just report the event.\n\n      if (!was_restarted)\n        should_resume = !m_thread_list.ShouldStop(event_ptr);\n\n      if (was_restarted || should_resume || m_resume_requested) {\n        Vote report_stop_vote = m_thread_list.ShouldReportStop(event_ptr);\n        LLDB_LOGF(log,\n                  \"Process::ShouldBroadcastEvent: should_resume: %i state: \"\n                  \"%s was_restarted: %i report_stop_vote: %d.\",\n                  should_resume, StateAsCString(state), was_restarted,\n                  report_stop_vote);\n\n        switch (report_stop_vote) {\n        case eVoteYes:\n          return_value = true;\n          break;\n        case eVoteNoOpinion:\n        case eVoteNo:\n          return_value = false;\n          break;\n        }\n\n        if (!was_restarted) {\n          LLDB_LOGF(log,\n                    \"Process::ShouldBroadcastEvent (%p) Restarting process \"\n                    \"from state: %s\",\n                    static_cast<void *>(event_ptr), StateAsCString(state));\n          ProcessEventData::SetRestartedInEvent(event_ptr, true);\n          PrivateResume();\n        }\n      } else {\n        return_value = true;\n        SynchronouslyNotifyStateChanged(state);\n      }\n    }\n    break;\n  }\n\n  // Forcing the next event delivery is a one shot deal.  So reset it here.\n  m_force_next_event_delivery = false;\n\n  // We do some coalescing of events (for instance two consecutive running\n  // events get coalesced.) But we only coalesce against events we actually\n  // broadcast.  So we use m_last_broadcast_state to track that.  NB - you\n  // can't use \"m_public_state.GetValue()\" for that purpose, as was originally\n  // done, because the PublicState reflects the last event pulled off the\n  // queue, and there may be several events stacked up on the queue unserviced.\n  // So the PublicState may not reflect the last broadcasted event yet.\n  // m_last_broadcast_state gets updated here.\n\n  if (return_value)\n    m_last_broadcast_state = state;\n\n  LLDB_LOGF(log,\n            \"Process::ShouldBroadcastEvent (%p) => new state: %s, last \"\n            \"broadcast state: %s - %s\",\n            static_cast<void *>(event_ptr), StateAsCString(state),\n            StateAsCString(m_last_broadcast_state),\n            return_value ? \"YES\" : \"NO\");\n  return return_value;\n}\n\nbool Process::StartPrivateStateThread(bool is_secondary_thread) {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EVENTS));\n\n  bool already_running = PrivateStateThreadIsValid();\n  LLDB_LOGF(log, \"Process::%s()%s \", __FUNCTION__,\n            already_running ? \" already running\"\n                            : \" starting private state thread\");\n\n  if (!is_secondary_thread && already_running)\n    return true;\n\n  // Create a thread that watches our internal state and controls which events\n  // make it to clients (into the DCProcess event queue).\n  char thread_name[1024];\n  uint32_t max_len = llvm::get_max_thread_name_length();\n  if (max_len > 0 && max_len <= 30) {\n    // On platforms with abbreviated thread name lengths, choose thread names\n    // that fit within the limit.\n    if (already_running)\n      snprintf(thread_name, sizeof(thread_name), \"intern-state-OV\");\n    else\n      snprintf(thread_name, sizeof(thread_name), \"intern-state\");\n  } else {\n    if (already_running)\n      snprintf(thread_name, sizeof(thread_name),\n               \"<lldb.process.internal-state-override(pid=%\" PRIu64 \")>\",\n               GetID());\n    else\n      snprintf(thread_name, sizeof(thread_name),\n               \"<lldb.process.internal-state(pid=%\" PRIu64 \")>\", GetID());\n  }\n\n  // Create the private state thread, and start it running.\n  PrivateStateThreadArgs *args_ptr =\n      new PrivateStateThreadArgs(this, is_secondary_thread);\n  llvm::Expected<HostThread> private_state_thread =\n      ThreadLauncher::LaunchThread(thread_name, Process::PrivateStateThread,\n                                   (void *)args_ptr, 8 * 1024 * 1024);\n  if (!private_state_thread) {\n    LLDB_LOG(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_HOST),\n             \"failed to launch host thread: {}\",\n             llvm::toString(private_state_thread.takeError()));\n    return false;\n  }\n\n  assert(private_state_thread->IsJoinable());\n  m_private_state_thread = *private_state_thread;\n  ResumePrivateStateThread();\n  return true;\n}\n\nvoid Process::PausePrivateStateThread() {\n  ControlPrivateStateThread(eBroadcastInternalStateControlPause);\n}\n\nvoid Process::ResumePrivateStateThread() {\n  ControlPrivateStateThread(eBroadcastInternalStateControlResume);\n}\n\nvoid Process::StopPrivateStateThread() {\n  if (m_private_state_thread.IsJoinable())\n    ControlPrivateStateThread(eBroadcastInternalStateControlStop);\n  else {\n    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n    LLDB_LOGF(\n        log,\n        \"Went to stop the private state thread, but it was already invalid.\");\n  }\n}\n\nvoid Process::ControlPrivateStateThread(uint32_t signal) {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n\n  assert(signal == eBroadcastInternalStateControlStop ||\n         signal == eBroadcastInternalStateControlPause ||\n         signal == eBroadcastInternalStateControlResume);\n\n  LLDB_LOGF(log, \"Process::%s (signal = %d)\", __FUNCTION__, signal);\n\n  // Signal the private state thread\n  if (m_private_state_thread.IsJoinable()) {\n    // Broadcast the event.\n    // It is important to do this outside of the if below, because it's\n    // possible that the thread state is invalid but that the thread is waiting\n    // on a control event instead of simply being on its way out (this should\n    // not happen, but it apparently can).\n    LLDB_LOGF(log, \"Sending control event of type: %d.\", signal);\n    std::shared_ptr<EventDataReceipt> event_receipt_sp(new EventDataReceipt());\n    m_private_state_control_broadcaster.BroadcastEvent(signal,\n                                                       event_receipt_sp);\n\n    // Wait for the event receipt or for the private state thread to exit\n    bool receipt_received = false;\n    if (PrivateStateThreadIsValid()) {\n      while (!receipt_received) {\n        // Check for a receipt for n seconds and then check if the private\n        // state thread is still around.\n        receipt_received =\n          event_receipt_sp->WaitForEventReceived(GetUtilityExpressionTimeout());\n        if (!receipt_received) {\n          // Check if the private state thread is still around. If it isn't\n          // then we are done waiting\n          if (!PrivateStateThreadIsValid())\n            break; // Private state thread exited or is exiting, we are done\n        }\n      }\n    }\n\n    if (signal == eBroadcastInternalStateControlStop) {\n      thread_result_t result = {};\n      m_private_state_thread.Join(&result);\n      m_private_state_thread.Reset();\n    }\n  } else {\n    LLDB_LOGF(\n        log,\n        \"Private state thread already dead, no need to signal it to stop.\");\n  }\n}\n\nvoid Process::SendAsyncInterrupt() {\n  if (PrivateStateThreadIsValid())\n    m_private_state_broadcaster.BroadcastEvent(Process::eBroadcastBitInterrupt,\n                                               nullptr);\n  else\n    BroadcastEvent(Process::eBroadcastBitInterrupt, nullptr);\n}\n\nvoid Process::HandlePrivateEvent(EventSP &event_sp) {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  m_resume_requested = false;\n\n  const StateType new_state =\n      Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n\n  // First check to see if anybody wants a shot at this event:\n  if (m_next_event_action_up) {\n    NextEventAction::EventActionResult action_result =\n        m_next_event_action_up->PerformAction(event_sp);\n    LLDB_LOGF(log, \"Ran next event action, result was %d.\", action_result);\n\n    switch (action_result) {\n    case NextEventAction::eEventActionSuccess:\n      SetNextEventAction(nullptr);\n      break;\n\n    case NextEventAction::eEventActionRetry:\n      break;\n\n    case NextEventAction::eEventActionExit:\n      // Handle Exiting Here.  If we already got an exited event, we should\n      // just propagate it.  Otherwise, swallow this event, and set our state\n      // to exit so the next event will kill us.\n      if (new_state != eStateExited) {\n        // FIXME: should cons up an exited event, and discard this one.\n        SetExitStatus(0, m_next_event_action_up->GetExitString());\n        SetNextEventAction(nullptr);\n        return;\n      }\n      SetNextEventAction(nullptr);\n      break;\n    }\n  }\n\n  // See if we should broadcast this state to external clients?\n  const bool should_broadcast = ShouldBroadcastEvent(event_sp.get());\n\n  if (should_broadcast) {\n    const bool is_hijacked = IsHijackedForEvent(eBroadcastBitStateChanged);\n    if (log) {\n      LLDB_LOGF(log,\n                \"Process::%s (pid = %\" PRIu64\n                \") broadcasting new state %s (old state %s) to %s\",\n                __FUNCTION__, GetID(), StateAsCString(new_state),\n                StateAsCString(GetState()),\n                is_hijacked ? \"hijacked\" : \"public\");\n    }\n    Process::ProcessEventData::SetUpdateStateOnRemoval(event_sp.get());\n    if (StateIsRunningState(new_state)) {\n      // Only push the input handler if we aren't fowarding events, as this\n      // means the curses GUI is in use... Or don't push it if we are launching\n      // since it will come up stopped.\n      if (!GetTarget().GetDebugger().IsForwardingEvents() &&\n          new_state != eStateLaunching && new_state != eStateAttaching) {\n        PushProcessIOHandler();\n        m_iohandler_sync.SetValue(m_iohandler_sync.GetValue() + 1,\n                                  eBroadcastAlways);\n        LLDB_LOGF(log, \"Process::%s updated m_iohandler_sync to %d\",\n                  __FUNCTION__, m_iohandler_sync.GetValue());\n      }\n    } else if (StateIsStoppedState(new_state, false)) {\n      if (!Process::ProcessEventData::GetRestartedFromEvent(event_sp.get())) {\n        // If the lldb_private::Debugger is handling the events, we don't want\n        // to pop the process IOHandler here, we want to do it when we receive\n        // the stopped event so we can carefully control when the process\n        // IOHandler is popped because when we stop we want to display some\n        // text stating how and why we stopped, then maybe some\n        // process/thread/frame info, and then we want the \"(lldb) \" prompt to\n        // show up. If we pop the process IOHandler here, then we will cause\n        // the command interpreter to become the top IOHandler after the\n        // process pops off and it will update its prompt right away... See the\n        // Debugger.cpp file where it calls the function as\n        // \"process_sp->PopProcessIOHandler()\" to see where I am talking about.\n        // Otherwise we end up getting overlapping \"(lldb) \" prompts and\n        // garbled output.\n        //\n        // If we aren't handling the events in the debugger (which is indicated\n        // by \"m_target.GetDebugger().IsHandlingEvents()\" returning false) or\n        // we are hijacked, then we always pop the process IO handler manually.\n        // Hijacking happens when the internal process state thread is running\n        // thread plans, or when commands want to run in synchronous mode and\n        // they call \"process->WaitForProcessToStop()\". An example of something\n        // that will hijack the events is a simple expression:\n        //\n        //  (lldb) expr (int)puts(\"hello\")\n        //\n        // This will cause the internal process state thread to resume and halt\n        // the process (and _it_ will hijack the eBroadcastBitStateChanged\n        // events) and we do need the IO handler to be pushed and popped\n        // correctly.\n\n        if (is_hijacked || !GetTarget().GetDebugger().IsHandlingEvents())\n          PopProcessIOHandler();\n      }\n    }\n\n    BroadcastEvent(event_sp);\n  } else {\n    if (log) {\n      LLDB_LOGF(\n          log,\n          \"Process::%s (pid = %\" PRIu64\n          \") suppressing state %s (old state %s): should_broadcast == false\",\n          __FUNCTION__, GetID(), StateAsCString(new_state),\n          StateAsCString(GetState()));\n    }\n  }\n}\n\nStatus Process::HaltPrivate() {\n  EventSP event_sp;\n  Status error(WillHalt());\n  if (error.Fail())\n    return error;\n\n  // Ask the process subclass to actually halt our process\n  bool caused_stop;\n  error = DoHalt(caused_stop);\n\n  DidHalt();\n  return error;\n}\n\nthread_result_t Process::PrivateStateThread(void *arg) {\n  std::unique_ptr<PrivateStateThreadArgs> args_up(\n      static_cast<PrivateStateThreadArgs *>(arg));\n  thread_result_t result =\n      args_up->process->RunPrivateStateThread(args_up->is_secondary_thread);\n  return result;\n}\n\nthread_result_t Process::RunPrivateStateThread(bool is_secondary_thread) {\n  bool control_only = true;\n\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(log, \"Process::%s (arg = %p, pid = %\" PRIu64 \") thread starting...\",\n            __FUNCTION__, static_cast<void *>(this), GetID());\n\n  bool exit_now = false;\n  bool interrupt_requested = false;\n  while (!exit_now) {\n    EventSP event_sp;\n    GetEventsPrivate(event_sp, llvm::None, control_only);\n    if (event_sp->BroadcasterIs(&m_private_state_control_broadcaster)) {\n      LLDB_LOGF(log,\n                \"Process::%s (arg = %p, pid = %\" PRIu64\n                \") got a control event: %d\",\n                __FUNCTION__, static_cast<void *>(this), GetID(),\n                event_sp->GetType());\n\n      switch (event_sp->GetType()) {\n      case eBroadcastInternalStateControlStop:\n        exit_now = true;\n        break; // doing any internal state management below\n\n      case eBroadcastInternalStateControlPause:\n        control_only = true;\n        break;\n\n      case eBroadcastInternalStateControlResume:\n        control_only = false;\n        break;\n      }\n\n      continue;\n    } else if (event_sp->GetType() == eBroadcastBitInterrupt) {\n      if (m_public_state.GetValue() == eStateAttaching) {\n        LLDB_LOGF(log,\n                  \"Process::%s (arg = %p, pid = %\" PRIu64\n                  \") woke up with an interrupt while attaching - \"\n                  \"forwarding interrupt.\",\n                  __FUNCTION__, static_cast<void *>(this), GetID());\n        BroadcastEvent(eBroadcastBitInterrupt, nullptr);\n      } else if (StateIsRunningState(m_last_broadcast_state)) {\n        LLDB_LOGF(log,\n                  \"Process::%s (arg = %p, pid = %\" PRIu64\n                  \") woke up with an interrupt - Halting.\",\n                  __FUNCTION__, static_cast<void *>(this), GetID());\n        Status error = HaltPrivate();\n        if (error.Fail() && log)\n          LLDB_LOGF(log,\n                    \"Process::%s (arg = %p, pid = %\" PRIu64\n                    \") failed to halt the process: %s\",\n                    __FUNCTION__, static_cast<void *>(this), GetID(),\n                    error.AsCString());\n        // Halt should generate a stopped event. Make a note of the fact that\n        // we were doing the interrupt, so we can set the interrupted flag\n        // after we receive the event. We deliberately set this to true even if\n        // HaltPrivate failed, so that we can interrupt on the next natural\n        // stop.\n        interrupt_requested = true;\n      } else {\n        // This can happen when someone (e.g. Process::Halt) sees that we are\n        // running and sends an interrupt request, but the process actually\n        // stops before we receive it. In that case, we can just ignore the\n        // request. We use m_last_broadcast_state, because the Stopped event\n        // may not have been popped of the event queue yet, which is when the\n        // public state gets updated.\n        LLDB_LOGF(log,\n                  \"Process::%s ignoring interrupt as we have already stopped.\",\n                  __FUNCTION__);\n      }\n      continue;\n    }\n\n    const StateType internal_state =\n        Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n\n    if (internal_state != eStateInvalid) {\n      if (m_clear_thread_plans_on_stop &&\n          StateIsStoppedState(internal_state, true)) {\n        m_clear_thread_plans_on_stop = false;\n        m_thread_list.DiscardThreadPlans();\n      }\n\n      if (interrupt_requested) {\n        if (StateIsStoppedState(internal_state, true)) {\n          // We requested the interrupt, so mark this as such in the stop event\n          // so clients can tell an interrupted process from a natural stop\n          ProcessEventData::SetInterruptedInEvent(event_sp.get(), true);\n          interrupt_requested = false;\n        } else if (log) {\n          LLDB_LOGF(log,\n                    \"Process::%s interrupt_requested, but a non-stopped \"\n                    \"state '%s' received.\",\n                    __FUNCTION__, StateAsCString(internal_state));\n        }\n      }\n\n      HandlePrivateEvent(event_sp);\n    }\n\n    if (internal_state == eStateInvalid || internal_state == eStateExited ||\n        internal_state == eStateDetached) {\n      LLDB_LOGF(log,\n                \"Process::%s (arg = %p, pid = %\" PRIu64\n                \") about to exit with internal state %s...\",\n                __FUNCTION__, static_cast<void *>(this), GetID(),\n                StateAsCString(internal_state));\n\n      break;\n    }\n  }\n\n  // Verify log is still enabled before attempting to write to it...\n  LLDB_LOGF(log, \"Process::%s (arg = %p, pid = %\" PRIu64 \") thread exiting...\",\n            __FUNCTION__, static_cast<void *>(this), GetID());\n\n  // If we are a secondary thread, then the primary thread we are working for\n  // will have already acquired the public_run_lock, and isn't done with what\n  // it was doing yet, so don't try to change it on the way out.\n  if (!is_secondary_thread)\n    m_public_run_lock.SetStopped();\n  return {};\n}\n\n// Process Event Data\n\nProcess::ProcessEventData::ProcessEventData()\n    : EventData(), m_process_wp(), m_state(eStateInvalid), m_restarted(false),\n      m_update_state(0), m_interrupted(false) {}\n\nProcess::ProcessEventData::ProcessEventData(const ProcessSP &process_sp,\n                                            StateType state)\n    : EventData(), m_process_wp(), m_state(state), m_restarted(false),\n      m_update_state(0), m_interrupted(false) {\n  if (process_sp)\n    m_process_wp = process_sp;\n}\n\nProcess::ProcessEventData::~ProcessEventData() = default;\n\nConstString Process::ProcessEventData::GetFlavorString() {\n  static ConstString g_flavor(\"Process::ProcessEventData\");\n  return g_flavor;\n}\n\nConstString Process::ProcessEventData::GetFlavor() const {\n  return ProcessEventData::GetFlavorString();\n}\n\nbool Process::ProcessEventData::ShouldStop(Event *event_ptr,\n                                           bool &found_valid_stopinfo) {\n  found_valid_stopinfo = false;\n\n  ProcessSP process_sp(m_process_wp.lock());\n  if (!process_sp)\n    return false;\n\n  ThreadList &curr_thread_list = process_sp->GetThreadList();\n  uint32_t num_threads = curr_thread_list.GetSize();\n  uint32_t idx;\n\n  // The actions might change one of the thread's stop_info's opinions about\n  // whether we should stop the process, so we need to query that as we go.\n\n  // One other complication here, is that we try to catch any case where the\n  // target has run (except for expressions) and immediately exit, but if we\n  // get that wrong (which is possible) then the thread list might have\n  // changed, and that would cause our iteration here to crash.  We could\n  // make a copy of the thread list, but we'd really like to also know if it\n  // has changed at all, so we make up a vector of the thread ID's and check\n  // what we get back against this list & bag out if anything differs.\n  ThreadList not_suspended_thread_list(process_sp.get());\n  std::vector<uint32_t> thread_index_array(num_threads);\n  uint32_t not_suspended_idx = 0;\n  for (idx = 0; idx < num_threads; ++idx) {\n    lldb::ThreadSP thread_sp = curr_thread_list.GetThreadAtIndex(idx);\n\n    /*\n     Filter out all suspended threads, they could not be the reason\n     of stop and no need to perform any actions on them.\n     */\n    if (thread_sp->GetResumeState() != eStateSuspended) {\n      not_suspended_thread_list.AddThread(thread_sp);\n      thread_index_array[not_suspended_idx] = thread_sp->GetIndexID();\n      not_suspended_idx++;\n    }\n  }\n\n  // Use this to track whether we should continue from here.  We will only\n  // continue the target running if no thread says we should stop.  Of course\n  // if some thread's PerformAction actually sets the target running, then it\n  // doesn't matter what the other threads say...\n\n  bool still_should_stop = false;\n\n  // Sometimes - for instance if we have a bug in the stub we are talking to,\n  // we stop but no thread has a valid stop reason.  In that case we should\n  // just stop, because we have no way of telling what the right thing to do\n  // is, and it's better to let the user decide than continue behind their\n  // backs.\n\n  for (idx = 0; idx < not_suspended_thread_list.GetSize(); ++idx) {\n    curr_thread_list = process_sp->GetThreadList();\n    if (curr_thread_list.GetSize() != num_threads) {\n      Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STEP |\n                                                      LIBLLDB_LOG_PROCESS));\n      LLDB_LOGF(\n          log,\n          \"Number of threads changed from %u to %u while processing event.\",\n          num_threads, curr_thread_list.GetSize());\n      break;\n    }\n\n    lldb::ThreadSP thread_sp = not_suspended_thread_list.GetThreadAtIndex(idx);\n\n    if (thread_sp->GetIndexID() != thread_index_array[idx]) {\n      Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STEP |\n                                                      LIBLLDB_LOG_PROCESS));\n      LLDB_LOGF(log,\n                \"The thread at position %u changed from %u to %u while \"\n                \"processing event.\",\n                idx, thread_index_array[idx], thread_sp->GetIndexID());\n      break;\n    }\n\n    StopInfoSP stop_info_sp = thread_sp->GetStopInfo();\n    if (stop_info_sp && stop_info_sp->IsValid()) {\n      found_valid_stopinfo = true;\n      bool this_thread_wants_to_stop;\n      if (stop_info_sp->GetOverrideShouldStop()) {\n        this_thread_wants_to_stop =\n            stop_info_sp->GetOverriddenShouldStopValue();\n      } else {\n        stop_info_sp->PerformAction(event_ptr);\n        // The stop action might restart the target.  If it does, then we\n        // want to mark that in the event so that whoever is receiving it\n        // will know to wait for the running event and reflect that state\n        // appropriately. We also need to stop processing actions, since they\n        // aren't expecting the target to be running.\n\n        // FIXME: we might have run.\n        if (stop_info_sp->HasTargetRunSinceMe()) {\n          SetRestarted(true);\n          break;\n        }\n\n        this_thread_wants_to_stop = stop_info_sp->ShouldStop(event_ptr);\n      }\n\n      if (!still_should_stop)\n        still_should_stop = this_thread_wants_to_stop;\n    }\n  }\n\n  return still_should_stop;\n}\n\nvoid Process::ProcessEventData::DoOnRemoval(Event *event_ptr) {\n  ProcessSP process_sp(m_process_wp.lock());\n\n  if (!process_sp)\n    return;\n\n  // This function gets called twice for each event, once when the event gets\n  // pulled off of the private process event queue, and then any number of\n  // times, first when it gets pulled off of the public event queue, then other\n  // times when we're pretending that this is where we stopped at the end of\n  // expression evaluation.  m_update_state is used to distinguish these three\n  // cases; it is 0 when we're just pulling it off for private handling, and >\n  // 1 for expression evaluation, and we don't want to do the breakpoint\n  // command handling then.\n  if (m_update_state != 1)\n    return;\n\n  process_sp->SetPublicState(\n      m_state, Process::ProcessEventData::GetRestartedFromEvent(event_ptr));\n\n  if (m_state == eStateStopped && !m_restarted) {\n    // Let process subclasses know we are about to do a public stop and do\n    // anything they might need to in order to speed up register and memory\n    // accesses.\n    process_sp->WillPublicStop();\n  }\n\n  // If this is a halt event, even if the halt stopped with some reason other\n  // than a plain interrupt (e.g. we had already stopped for a breakpoint when\n  // the halt request came through) don't do the StopInfo actions, as they may\n  // end up restarting the process.\n  if (m_interrupted)\n    return;\n\n  // If we're not stopped or have restarted, then skip the StopInfo actions:\n  if (m_state != eStateStopped || m_restarted) {\n    return;\n  }\n\n  bool does_anybody_have_an_opinion = false;\n  bool still_should_stop = ShouldStop(event_ptr, does_anybody_have_an_opinion);\n\n  if (GetRestarted()) {\n    return;\n  }\n\n  if (!still_should_stop && does_anybody_have_an_opinion) {\n    // We've been asked to continue, so do that here.\n    SetRestarted(true);\n    // Use the public resume method here, since this is just extending a\n    // public resume.\n    process_sp->PrivateResume();\n  } else {\n    bool hijacked = process_sp->IsHijackedForEvent(eBroadcastBitStateChanged) &&\n                    !process_sp->StateChangedIsHijackedForSynchronousResume();\n\n    if (!hijacked) {\n      // If we didn't restart, run the Stop Hooks here.\n      // Don't do that if state changed events aren't hooked up to the\n      // public (or SyncResume) broadcasters.  StopHooks are just for\n      // real public stops.  They might also restart the target,\n      // so watch for that.\n      if (process_sp->GetTarget().RunStopHooks())\n        SetRestarted(true);\n    }\n  }\n}\n\nvoid Process::ProcessEventData::Dump(Stream *s) const {\n  ProcessSP process_sp(m_process_wp.lock());\n\n  if (process_sp)\n    s->Printf(\" process = %p (pid = %\" PRIu64 \"), \",\n              static_cast<void *>(process_sp.get()), process_sp->GetID());\n  else\n    s->PutCString(\" process = NULL, \");\n\n  s->Printf(\"state = %s\", StateAsCString(GetState()));\n}\n\nconst Process::ProcessEventData *\nProcess::ProcessEventData::GetEventDataFromEvent(const Event *event_ptr) {\n  if (event_ptr) {\n    const EventData *event_data = event_ptr->GetData();\n    if (event_data &&\n        event_data->GetFlavor() == ProcessEventData::GetFlavorString())\n      return static_cast<const ProcessEventData *>(event_ptr->GetData());\n  }\n  return nullptr;\n}\n\nProcessSP\nProcess::ProcessEventData::GetProcessFromEvent(const Event *event_ptr) {\n  ProcessSP process_sp;\n  const ProcessEventData *data = GetEventDataFromEvent(event_ptr);\n  if (data)\n    process_sp = data->GetProcessSP();\n  return process_sp;\n}\n\nStateType Process::ProcessEventData::GetStateFromEvent(const Event *event_ptr) {\n  const ProcessEventData *data = GetEventDataFromEvent(event_ptr);\n  if (data == nullptr)\n    return eStateInvalid;\n  else\n    return data->GetState();\n}\n\nbool Process::ProcessEventData::GetRestartedFromEvent(const Event *event_ptr) {\n  const ProcessEventData *data = GetEventDataFromEvent(event_ptr);\n  if (data == nullptr)\n    return false;\n  else\n    return data->GetRestarted();\n}\n\nvoid Process::ProcessEventData::SetRestartedInEvent(Event *event_ptr,\n                                                    bool new_value) {\n  ProcessEventData *data =\n      const_cast<ProcessEventData *>(GetEventDataFromEvent(event_ptr));\n  if (data != nullptr)\n    data->SetRestarted(new_value);\n}\n\nsize_t\nProcess::ProcessEventData::GetNumRestartedReasons(const Event *event_ptr) {\n  ProcessEventData *data =\n      const_cast<ProcessEventData *>(GetEventDataFromEvent(event_ptr));\n  if (data != nullptr)\n    return data->GetNumRestartedReasons();\n  else\n    return 0;\n}\n\nconst char *\nProcess::ProcessEventData::GetRestartedReasonAtIndex(const Event *event_ptr,\n                                                     size_t idx) {\n  ProcessEventData *data =\n      const_cast<ProcessEventData *>(GetEventDataFromEvent(event_ptr));\n  if (data != nullptr)\n    return data->GetRestartedReasonAtIndex(idx);\n  else\n    return nullptr;\n}\n\nvoid Process::ProcessEventData::AddRestartedReason(Event *event_ptr,\n                                                   const char *reason) {\n  ProcessEventData *data =\n      const_cast<ProcessEventData *>(GetEventDataFromEvent(event_ptr));\n  if (data != nullptr)\n    data->AddRestartedReason(reason);\n}\n\nbool Process::ProcessEventData::GetInterruptedFromEvent(\n    const Event *event_ptr) {\n  const ProcessEventData *data = GetEventDataFromEvent(event_ptr);\n  if (data == nullptr)\n    return false;\n  else\n    return data->GetInterrupted();\n}\n\nvoid Process::ProcessEventData::SetInterruptedInEvent(Event *event_ptr,\n                                                      bool new_value) {\n  ProcessEventData *data =\n      const_cast<ProcessEventData *>(GetEventDataFromEvent(event_ptr));\n  if (data != nullptr)\n    data->SetInterrupted(new_value);\n}\n\nbool Process::ProcessEventData::SetUpdateStateOnRemoval(Event *event_ptr) {\n  ProcessEventData *data =\n      const_cast<ProcessEventData *>(GetEventDataFromEvent(event_ptr));\n  if (data) {\n    data->SetUpdateStateOnRemoval();\n    return true;\n  }\n  return false;\n}\n\nlldb::TargetSP Process::CalculateTarget() { return m_target_wp.lock(); }\n\nvoid Process::CalculateExecutionContext(ExecutionContext &exe_ctx) {\n  exe_ctx.SetTargetPtr(&GetTarget());\n  exe_ctx.SetProcessPtr(this);\n  exe_ctx.SetThreadPtr(nullptr);\n  exe_ctx.SetFramePtr(nullptr);\n}\n\n// uint32_t\n// Process::ListProcessesMatchingName (const char *name, StringList &matches,\n// std::vector<lldb::pid_t> &pids)\n//{\n//    return 0;\n//}\n//\n// ArchSpec\n// Process::GetArchSpecForExistingProcess (lldb::pid_t pid)\n//{\n//    return Host::GetArchSpecForExistingProcess (pid);\n//}\n//\n// ArchSpec\n// Process::GetArchSpecForExistingProcess (const char *process_name)\n//{\n//    return Host::GetArchSpecForExistingProcess (process_name);\n//}\n\nvoid Process::AppendSTDOUT(const char *s, size_t len) {\n  std::lock_guard<std::recursive_mutex> guard(m_stdio_communication_mutex);\n  m_stdout_data.append(s, len);\n  BroadcastEventIfUnique(eBroadcastBitSTDOUT,\n                         new ProcessEventData(shared_from_this(), GetState()));\n}\n\nvoid Process::AppendSTDERR(const char *s, size_t len) {\n  std::lock_guard<std::recursive_mutex> guard(m_stdio_communication_mutex);\n  m_stderr_data.append(s, len);\n  BroadcastEventIfUnique(eBroadcastBitSTDERR,\n                         new ProcessEventData(shared_from_this(), GetState()));\n}\n\nvoid Process::BroadcastAsyncProfileData(const std::string &one_profile_data) {\n  std::lock_guard<std::recursive_mutex> guard(m_profile_data_comm_mutex);\n  m_profile_data.push_back(one_profile_data);\n  BroadcastEventIfUnique(eBroadcastBitProfileData,\n                         new ProcessEventData(shared_from_this(), GetState()));\n}\n\nvoid Process::BroadcastStructuredData(const StructuredData::ObjectSP &object_sp,\n                                      const StructuredDataPluginSP &plugin_sp) {\n  BroadcastEvent(\n      eBroadcastBitStructuredData,\n      new EventDataStructuredData(shared_from_this(), object_sp, plugin_sp));\n}\n\nStructuredDataPluginSP\nProcess::GetStructuredDataPlugin(ConstString type_name) const {\n  auto find_it = m_structured_data_plugin_map.find(type_name);\n  if (find_it != m_structured_data_plugin_map.end())\n    return find_it->second;\n  else\n    return StructuredDataPluginSP();\n}\n\nsize_t Process::GetAsyncProfileData(char *buf, size_t buf_size, Status &error) {\n  std::lock_guard<std::recursive_mutex> guard(m_profile_data_comm_mutex);\n  if (m_profile_data.empty())\n    return 0;\n\n  std::string &one_profile_data = m_profile_data.front();\n  size_t bytes_available = one_profile_data.size();\n  if (bytes_available > 0) {\n    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n    LLDB_LOGF(log, \"Process::GetProfileData (buf = %p, size = %\" PRIu64 \")\",\n              static_cast<void *>(buf), static_cast<uint64_t>(buf_size));\n    if (bytes_available > buf_size) {\n      memcpy(buf, one_profile_data.c_str(), buf_size);\n      one_profile_data.erase(0, buf_size);\n      bytes_available = buf_size;\n    } else {\n      memcpy(buf, one_profile_data.c_str(), bytes_available);\n      m_profile_data.erase(m_profile_data.begin());\n    }\n  }\n  return bytes_available;\n}\n\n// Process STDIO\n\nsize_t Process::GetSTDOUT(char *buf, size_t buf_size, Status &error) {\n  std::lock_guard<std::recursive_mutex> guard(m_stdio_communication_mutex);\n  size_t bytes_available = m_stdout_data.size();\n  if (bytes_available > 0) {\n    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n    LLDB_LOGF(log, \"Process::GetSTDOUT (buf = %p, size = %\" PRIu64 \")\",\n              static_cast<void *>(buf), static_cast<uint64_t>(buf_size));\n    if (bytes_available > buf_size) {\n      memcpy(buf, m_stdout_data.c_str(), buf_size);\n      m_stdout_data.erase(0, buf_size);\n      bytes_available = buf_size;\n    } else {\n      memcpy(buf, m_stdout_data.c_str(), bytes_available);\n      m_stdout_data.clear();\n    }\n  }\n  return bytes_available;\n}\n\nsize_t Process::GetSTDERR(char *buf, size_t buf_size, Status &error) {\n  std::lock_guard<std::recursive_mutex> gaurd(m_stdio_communication_mutex);\n  size_t bytes_available = m_stderr_data.size();\n  if (bytes_available > 0) {\n    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n    LLDB_LOGF(log, \"Process::GetSTDERR (buf = %p, size = %\" PRIu64 \")\",\n              static_cast<void *>(buf), static_cast<uint64_t>(buf_size));\n    if (bytes_available > buf_size) {\n      memcpy(buf, m_stderr_data.c_str(), buf_size);\n      m_stderr_data.erase(0, buf_size);\n      bytes_available = buf_size;\n    } else {\n      memcpy(buf, m_stderr_data.c_str(), bytes_available);\n      m_stderr_data.clear();\n    }\n  }\n  return bytes_available;\n}\n\nvoid Process::STDIOReadThreadBytesReceived(void *baton, const void *src,\n                                           size_t src_len) {\n  Process *process = (Process *)baton;\n  process->AppendSTDOUT(static_cast<const char *>(src), src_len);\n}\n\nclass IOHandlerProcessSTDIO : public IOHandler {\npublic:\n  IOHandlerProcessSTDIO(Process *process, int write_fd)\n      : IOHandler(process->GetTarget().GetDebugger(),\n                  IOHandler::Type::ProcessIO),\n        m_process(process),\n        m_read_file(GetInputFD(), File::eOpenOptionRead, false),\n        m_write_file(write_fd, File::eOpenOptionWrite, false) {\n    m_pipe.CreateNew(false);\n  }\n\n  ~IOHandlerProcessSTDIO() override = default;\n\n  // Each IOHandler gets to run until it is done. It should read data from the\n  // \"in\" and place output into \"out\" and \"err and return when done.\n  void Run() override {\n    if (!m_read_file.IsValid() || !m_write_file.IsValid() ||\n        !m_pipe.CanRead() || !m_pipe.CanWrite()) {\n      SetIsDone(true);\n      return;\n    }\n\n    SetIsDone(false);\n    const int read_fd = m_read_file.GetDescriptor();\n    TerminalState terminal_state;\n    terminal_state.Save(read_fd, false);\n    Terminal terminal(read_fd);\n    terminal.SetCanonical(false);\n    terminal.SetEcho(false);\n// FD_ZERO, FD_SET are not supported on windows\n#ifndef _WIN32\n    const int pipe_read_fd = m_pipe.GetReadFileDescriptor();\n    m_is_running = true;\n    while (!GetIsDone()) {\n      SelectHelper select_helper;\n      select_helper.FDSetRead(read_fd);\n      select_helper.FDSetRead(pipe_read_fd);\n      Status error = select_helper.Select();\n\n      if (error.Fail()) {\n        SetIsDone(true);\n      } else {\n        char ch = 0;\n        size_t n;\n        if (select_helper.FDIsSetRead(read_fd)) {\n          n = 1;\n          if (m_read_file.Read(&ch, n).Success() && n == 1) {\n            if (m_write_file.Write(&ch, n).Fail() || n != 1)\n              SetIsDone(true);\n          } else\n            SetIsDone(true);\n        }\n        if (select_helper.FDIsSetRead(pipe_read_fd)) {\n          size_t bytes_read;\n          // Consume the interrupt byte\n          Status error = m_pipe.Read(&ch, 1, bytes_read);\n          if (error.Success()) {\n            switch (ch) {\n            case 'q':\n              SetIsDone(true);\n              break;\n            case 'i':\n              if (StateIsRunningState(m_process->GetState()))\n                m_process->SendAsyncInterrupt();\n              break;\n            }\n          }\n        }\n      }\n    }\n    m_is_running = false;\n#endif\n    terminal_state.Restore();\n  }\n\n  void Cancel() override {\n    SetIsDone(true);\n    // Only write to our pipe to cancel if we are in\n    // IOHandlerProcessSTDIO::Run(). We can end up with a python command that\n    // is being run from the command interpreter:\n    //\n    // (lldb) step_process_thousands_of_times\n    //\n    // In this case the command interpreter will be in the middle of handling\n    // the command and if the process pushes and pops the IOHandler thousands\n    // of times, we can end up writing to m_pipe without ever consuming the\n    // bytes from the pipe in IOHandlerProcessSTDIO::Run() and end up\n    // deadlocking when the pipe gets fed up and blocks until data is consumed.\n    if (m_is_running) {\n      char ch = 'q'; // Send 'q' for quit\n      size_t bytes_written = 0;\n      m_pipe.Write(&ch, 1, bytes_written);\n    }\n  }\n\n  bool Interrupt() override {\n    // Do only things that are safe to do in an interrupt context (like in a\n    // SIGINT handler), like write 1 byte to a file descriptor. This will\n    // interrupt the IOHandlerProcessSTDIO::Run() and we can look at the byte\n    // that was written to the pipe and then call\n    // m_process->SendAsyncInterrupt() from a much safer location in code.\n    if (m_active) {\n      char ch = 'i'; // Send 'i' for interrupt\n      size_t bytes_written = 0;\n      Status result = m_pipe.Write(&ch, 1, bytes_written);\n      return result.Success();\n    } else {\n      // This IOHandler might be pushed on the stack, but not being run\n      // currently so do the right thing if we aren't actively watching for\n      // STDIN by sending the interrupt to the process. Otherwise the write to\n      // the pipe above would do nothing. This can happen when the command\n      // interpreter is running and gets a \"expression ...\". It will be on the\n      // IOHandler thread and sending the input is complete to the delegate\n      // which will cause the expression to run, which will push the process IO\n      // handler, but not run it.\n\n      if (StateIsRunningState(m_process->GetState())) {\n        m_process->SendAsyncInterrupt();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void GotEOF() override {}\n\nprotected:\n  Process *m_process;\n  NativeFile m_read_file;  // Read from this file (usually actual STDIN for LLDB\n  NativeFile m_write_file; // Write to this file (usually the master pty for\n                           // getting io to debuggee)\n  Pipe m_pipe;\n  std::atomic<bool> m_is_running{false};\n};\n\nvoid Process::SetSTDIOFileDescriptor(int fd) {\n  // First set up the Read Thread for reading/handling process I/O\n  m_stdio_communication.SetConnection(\n      std::make_unique<ConnectionFileDescriptor>(fd, true));\n  if (m_stdio_communication.IsConnected()) {\n    m_stdio_communication.SetReadThreadBytesReceivedCallback(\n        STDIOReadThreadBytesReceived, this);\n    m_stdio_communication.StartReadThread();\n\n    // Now read thread is set up, set up input reader.\n\n    if (!m_process_input_reader)\n      m_process_input_reader =\n          std::make_shared<IOHandlerProcessSTDIO>(this, fd);\n  }\n}\n\nbool Process::ProcessIOHandlerIsActive() {\n  IOHandlerSP io_handler_sp(m_process_input_reader);\n  if (io_handler_sp)\n    return GetTarget().GetDebugger().IsTopIOHandler(io_handler_sp);\n  return false;\n}\nbool Process::PushProcessIOHandler() {\n  IOHandlerSP io_handler_sp(m_process_input_reader);\n  if (io_handler_sp) {\n    Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n    LLDB_LOGF(log, \"Process::%s pushing IO handler\", __FUNCTION__);\n\n    io_handler_sp->SetIsDone(false);\n    // If we evaluate an utility function, then we don't cancel the current\n    // IOHandler. Our IOHandler is non-interactive and shouldn't disturb the\n    // existing IOHandler that potentially provides the user interface (e.g.\n    // the IOHandler for Editline).\n    bool cancel_top_handler = !m_mod_id.IsRunningUtilityFunction();\n    GetTarget().GetDebugger().RunIOHandlerAsync(io_handler_sp,\n                                                cancel_top_handler);\n    return true;\n  }\n  return false;\n}\n\nbool Process::PopProcessIOHandler() {\n  IOHandlerSP io_handler_sp(m_process_input_reader);\n  if (io_handler_sp)\n    return GetTarget().GetDebugger().RemoveIOHandler(io_handler_sp);\n  return false;\n}\n\n// The process needs to know about installed plug-ins\nvoid Process::SettingsInitialize() { Thread::SettingsInitialize(); }\n\nvoid Process::SettingsTerminate() { Thread::SettingsTerminate(); }\n\nnamespace {\n// RestorePlanState is used to record the \"is private\", \"is master\" and \"okay\n// to discard\" fields of the plan we are running, and reset it on Clean or on\n// destruction. It will only reset the state once, so you can call Clean and\n// then monkey with the state and it won't get reset on you again.\n\nclass RestorePlanState {\npublic:\n  RestorePlanState(lldb::ThreadPlanSP thread_plan_sp)\n      : m_thread_plan_sp(thread_plan_sp), m_already_reset(false) {\n    if (m_thread_plan_sp) {\n      m_private = m_thread_plan_sp->GetPrivate();\n      m_is_master = m_thread_plan_sp->IsMasterPlan();\n      m_okay_to_discard = m_thread_plan_sp->OkayToDiscard();\n    }\n  }\n\n  ~RestorePlanState() { Clean(); }\n\n  void Clean() {\n    if (!m_already_reset && m_thread_plan_sp) {\n      m_already_reset = true;\n      m_thread_plan_sp->SetPrivate(m_private);\n      m_thread_plan_sp->SetIsMasterPlan(m_is_master);\n      m_thread_plan_sp->SetOkayToDiscard(m_okay_to_discard);\n    }\n  }\n\nprivate:\n  lldb::ThreadPlanSP m_thread_plan_sp;\n  bool m_already_reset;\n  bool m_private;\n  bool m_is_master;\n  bool m_okay_to_discard;\n};\n} // anonymous namespace\n\nstatic microseconds\nGetOneThreadExpressionTimeout(const EvaluateExpressionOptions &options) {\n  const milliseconds default_one_thread_timeout(250);\n\n  // If the overall wait is forever, then we don't need to worry about it.\n  if (!options.GetTimeout()) {\n    return options.GetOneThreadTimeout() ? *options.GetOneThreadTimeout()\n                                         : default_one_thread_timeout;\n  }\n\n  // If the one thread timeout is set, use it.\n  if (options.GetOneThreadTimeout())\n    return *options.GetOneThreadTimeout();\n\n  // Otherwise use half the total timeout, bounded by the\n  // default_one_thread_timeout.\n  return std::min<microseconds>(default_one_thread_timeout,\n                                *options.GetTimeout() / 2);\n}\n\nstatic Timeout<std::micro>\nGetExpressionTimeout(const EvaluateExpressionOptions &options,\n                     bool before_first_timeout) {\n  // If we are going to run all threads the whole time, or if we are only going\n  // to run one thread, we can just return the overall timeout.\n  if (!options.GetStopOthers() || !options.GetTryAllThreads())\n    return options.GetTimeout();\n\n  if (before_first_timeout)\n    return GetOneThreadExpressionTimeout(options);\n\n  if (!options.GetTimeout())\n    return llvm::None;\n  else\n    return *options.GetTimeout() - GetOneThreadExpressionTimeout(options);\n}\n\nstatic llvm::Optional<ExpressionResults>\nHandleStoppedEvent(lldb::tid_t thread_id, const ThreadPlanSP &thread_plan_sp,\n                   RestorePlanState &restorer, const EventSP &event_sp,\n                   EventSP &event_to_broadcast_sp,\n                   const EvaluateExpressionOptions &options,\n                   bool handle_interrupts) {\n  Log *log = GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STEP | LIBLLDB_LOG_PROCESS);\n\n  ThreadSP thread_sp = thread_plan_sp->GetTarget()\n                           .GetProcessSP()\n                           ->GetThreadList()\n                           .FindThreadByID(thread_id);\n  if (!thread_sp) {\n    LLDB_LOG(log,\n             \"The thread on which we were running the \"\n             \"expression: tid = {0}, exited while \"\n             \"the expression was running.\",\n             thread_id);\n    return eExpressionThreadVanished;\n  }\n\n  ThreadPlanSP plan = thread_sp->GetCompletedPlan();\n  if (plan == thread_plan_sp && plan->PlanSucceeded()) {\n    LLDB_LOG(log, \"execution completed successfully\");\n\n    // Restore the plan state so it will get reported as intended when we are\n    // done.\n    restorer.Clean();\n    return eExpressionCompleted;\n  }\n\n  StopInfoSP stop_info_sp = thread_sp->GetStopInfo();\n  if (stop_info_sp && stop_info_sp->GetStopReason() == eStopReasonBreakpoint &&\n      stop_info_sp->ShouldNotify(event_sp.get())) {\n    LLDB_LOG(log, \"stopped for breakpoint: {0}.\", stop_info_sp->GetDescription());\n    if (!options.DoesIgnoreBreakpoints()) {\n      // Restore the plan state and then force Private to false.  We are going\n      // to stop because of this plan so we need it to become a public plan or\n      // it won't report correctly when we continue to its termination later\n      // on.\n      restorer.Clean();\n      thread_plan_sp->SetPrivate(false);\n      event_to_broadcast_sp = event_sp;\n    }\n    return eExpressionHitBreakpoint;\n  }\n\n  if (!handle_interrupts &&\n      Process::ProcessEventData::GetInterruptedFromEvent(event_sp.get()))\n    return llvm::None;\n\n  LLDB_LOG(log, \"thread plan did not successfully complete\");\n  if (!options.DoesUnwindOnError())\n    event_to_broadcast_sp = event_sp;\n  return eExpressionInterrupted;\n}\n\nExpressionResults\nProcess::RunThreadPlan(ExecutionContext &exe_ctx,\n                       lldb::ThreadPlanSP &thread_plan_sp,\n                       const EvaluateExpressionOptions &options,\n                       DiagnosticManager &diagnostic_manager) {\n  ExpressionResults return_value = eExpressionSetupError;\n\n  std::lock_guard<std::mutex> run_thread_plan_locker(m_run_thread_plan_lock);\n\n  if (!thread_plan_sp) {\n    diagnostic_manager.PutString(\n        eDiagnosticSeverityError,\n        \"RunThreadPlan called with empty thread plan.\");\n    return eExpressionSetupError;\n  }\n\n  if (!thread_plan_sp->ValidatePlan(nullptr)) {\n    diagnostic_manager.PutString(\n        eDiagnosticSeverityError,\n        \"RunThreadPlan called with an invalid thread plan.\");\n    return eExpressionSetupError;\n  }\n\n  if (exe_ctx.GetProcessPtr() != this) {\n    diagnostic_manager.PutString(eDiagnosticSeverityError,\n                                 \"RunThreadPlan called on wrong process.\");\n    return eExpressionSetupError;\n  }\n\n  Thread *thread = exe_ctx.GetThreadPtr();\n  if (thread == nullptr) {\n    diagnostic_manager.PutString(eDiagnosticSeverityError,\n                                 \"RunThreadPlan called with invalid thread.\");\n    return eExpressionSetupError;\n  }\n\n  // Record the thread's id so we can tell when a thread we were using\n  // to run the expression exits during the expression evaluation.\n  lldb::tid_t expr_thread_id = thread->GetID();\n\n  // We need to change some of the thread plan attributes for the thread plan\n  // runner.  This will restore them when we are done:\n\n  RestorePlanState thread_plan_restorer(thread_plan_sp);\n\n  // We rely on the thread plan we are running returning \"PlanCompleted\" if\n  // when it successfully completes. For that to be true the plan can't be\n  // private - since private plans suppress themselves in the GetCompletedPlan\n  // call.\n\n  thread_plan_sp->SetPrivate(false);\n\n  // The plans run with RunThreadPlan also need to be terminal master plans or\n  // when they are done we will end up asking the plan above us whether we\n  // should stop, which may give the wrong answer.\n\n  thread_plan_sp->SetIsMasterPlan(true);\n  thread_plan_sp->SetOkayToDiscard(false);\n\n  // If we are running some utility expression for LLDB, we now have to mark\n  // this in the ProcesModID of this process. This RAII takes care of marking\n  // and reverting the mark it once we are done running the expression.\n  UtilityFunctionScope util_scope(options.IsForUtilityExpr() ? this : nullptr);\n\n  if (m_private_state.GetValue() != eStateStopped) {\n    diagnostic_manager.PutString(\n        eDiagnosticSeverityError,\n        \"RunThreadPlan called while the private state was not stopped.\");\n    return eExpressionSetupError;\n  }\n\n  // Save the thread & frame from the exe_ctx for restoration after we run\n  const uint32_t thread_idx_id = thread->GetIndexID();\n  StackFrameSP selected_frame_sp = thread->GetSelectedFrame();\n  if (!selected_frame_sp) {\n    thread->SetSelectedFrame(nullptr);\n    selected_frame_sp = thread->GetSelectedFrame();\n    if (!selected_frame_sp) {\n      diagnostic_manager.Printf(\n          eDiagnosticSeverityError,\n          \"RunThreadPlan called without a selected frame on thread %d\",\n          thread_idx_id);\n      return eExpressionSetupError;\n    }\n  }\n\n  // Make sure the timeout values make sense. The one thread timeout needs to\n  // be smaller than the overall timeout.\n  if (options.GetOneThreadTimeout() && options.GetTimeout() &&\n      *options.GetTimeout() < *options.GetOneThreadTimeout()) {\n    diagnostic_manager.PutString(eDiagnosticSeverityError,\n                                 \"RunThreadPlan called with one thread \"\n                                 \"timeout greater than total timeout\");\n    return eExpressionSetupError;\n  }\n\n  StackID ctx_frame_id = selected_frame_sp->GetStackID();\n\n  // N.B. Running the target may unset the currently selected thread and frame.\n  // We don't want to do that either, so we should arrange to reset them as\n  // well.\n\n  lldb::ThreadSP selected_thread_sp = GetThreadList().GetSelectedThread();\n\n  uint32_t selected_tid;\n  StackID selected_stack_id;\n  if (selected_thread_sp) {\n    selected_tid = selected_thread_sp->GetIndexID();\n    selected_stack_id = selected_thread_sp->GetSelectedFrame()->GetStackID();\n  } else {\n    selected_tid = LLDB_INVALID_THREAD_ID;\n  }\n\n  HostThread backup_private_state_thread;\n  lldb::StateType old_state = eStateInvalid;\n  lldb::ThreadPlanSP stopper_base_plan_sp;\n\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_STEP |\n                                                  LIBLLDB_LOG_PROCESS));\n  if (m_private_state_thread.EqualsThread(Host::GetCurrentThread())) {\n    // Yikes, we are running on the private state thread!  So we can't wait for\n    // public events on this thread, since we are the thread that is generating\n    // public events. The simplest thing to do is to spin up a temporary thread\n    // to handle private state thread events while we are fielding public\n    // events here.\n    LLDB_LOGF(log, \"Running thread plan on private state thread, spinning up \"\n                   \"another state thread to handle the events.\");\n\n    backup_private_state_thread = m_private_state_thread;\n\n    // One other bit of business: we want to run just this thread plan and\n    // anything it pushes, and then stop, returning control here. But in the\n    // normal course of things, the plan above us on the stack would be given a\n    // shot at the stop event before deciding to stop, and we don't want that.\n    // So we insert a \"stopper\" base plan on the stack before the plan we want\n    // to run.  Since base plans always stop and return control to the user,\n    // that will do just what we want.\n    stopper_base_plan_sp.reset(new ThreadPlanBase(*thread));\n    thread->QueueThreadPlan(stopper_base_plan_sp, false);\n    // Have to make sure our public state is stopped, since otherwise the\n    // reporting logic below doesn't work correctly.\n    old_state = m_public_state.GetValue();\n    m_public_state.SetValueNoLock(eStateStopped);\n\n    // Now spin up the private state thread:\n    StartPrivateStateThread(true);\n  }\n\n  thread->QueueThreadPlan(\n      thread_plan_sp, false); // This used to pass \"true\" does that make sense?\n\n  if (options.GetDebug()) {\n    // In this case, we aren't actually going to run, we just want to stop\n    // right away. Flush this thread so we will refetch the stacks and show the\n    // correct backtrace.\n    // FIXME: To make this prettier we should invent some stop reason for this,\n    // but that\n    // is only cosmetic, and this functionality is only of use to lldb\n    // developers who can live with not pretty...\n    thread->Flush();\n    return eExpressionStoppedForDebug;\n  }\n\n  ListenerSP listener_sp(\n      Listener::MakeListener(\"lldb.process.listener.run-thread-plan\"));\n\n  lldb::EventSP event_to_broadcast_sp;\n\n  {\n    // This process event hijacker Hijacks the Public events and its destructor\n    // makes sure that the process events get restored on exit to the function.\n    //\n    // If the event needs to propagate beyond the hijacker (e.g., the process\n    // exits during execution), then the event is put into\n    // event_to_broadcast_sp for rebroadcasting.\n\n    ProcessEventHijacker run_thread_plan_hijacker(*this, listener_sp);\n\n    if (log) {\n      StreamString s;\n      thread_plan_sp->GetDescription(&s, lldb::eDescriptionLevelVerbose);\n      LLDB_LOGF(log,\n                \"Process::RunThreadPlan(): Resuming thread %u - 0x%4.4\" PRIx64\n                \" to run thread plan \\\"%s\\\".\",\n                thread_idx_id, expr_thread_id, s.GetData());\n    }\n\n    bool got_event;\n    lldb::EventSP event_sp;\n    lldb::StateType stop_state = lldb::eStateInvalid;\n\n    bool before_first_timeout = true; // This is set to false the first time\n                                      // that we have to halt the target.\n    bool do_resume = true;\n    bool handle_running_event = true;\n\n    // This is just for accounting:\n    uint32_t num_resumes = 0;\n\n    // If we are going to run all threads the whole time, or if we are only\n    // going to run one thread, then we don't need the first timeout.  So we\n    // pretend we are after the first timeout already.\n    if (!options.GetStopOthers() || !options.GetTryAllThreads())\n      before_first_timeout = false;\n\n    LLDB_LOGF(log, \"Stop others: %u, try all: %u, before_first: %u.\\n\",\n              options.GetStopOthers(), options.GetTryAllThreads(),\n              before_first_timeout);\n\n    // This isn't going to work if there are unfetched events on the queue. Are\n    // there cases where we might want to run the remaining events here, and\n    // then try to call the function?  That's probably being too tricky for our\n    // own good.\n\n    Event *other_events = listener_sp->PeekAtNextEvent();\n    if (other_events != nullptr) {\n      diagnostic_manager.PutString(\n          eDiagnosticSeverityError,\n          \"RunThreadPlan called with pending events on the queue.\");\n      return eExpressionSetupError;\n    }\n\n    // We also need to make sure that the next event is delivered.  We might be\n    // calling a function as part of a thread plan, in which case the last\n    // delivered event could be the running event, and we don't want event\n    // coalescing to cause us to lose OUR running event...\n    ForceNextEventDelivery();\n\n// This while loop must exit out the bottom, there's cleanup that we need to do\n// when we are done. So don't call return anywhere within it.\n\n#ifdef LLDB_RUN_THREAD_HALT_WITH_EVENT\n    // It's pretty much impossible to write test cases for things like: One\n    // thread timeout expires, I go to halt, but the process already stopped on\n    // the function call stop breakpoint.  Turning on this define will make us\n    // not fetch the first event till after the halt.  So if you run a quick\n    // function, it will have completed, and the completion event will be\n    // waiting, when you interrupt for halt. The expression evaluation should\n    // still succeed.\n    bool miss_first_event = true;\n#endif\n    while (true) {\n      // We usually want to resume the process if we get to the top of the\n      // loop. The only exception is if we get two running events with no\n      // intervening stop, which can happen, we will just wait for then next\n      // stop event.\n      LLDB_LOGF(log,\n                \"Top of while loop: do_resume: %i handle_running_event: %i \"\n                \"before_first_timeout: %i.\",\n                do_resume, handle_running_event, before_first_timeout);\n\n      if (do_resume || handle_running_event) {\n        // Do the initial resume and wait for the running event before going\n        // further.\n\n        if (do_resume) {\n          num_resumes++;\n          Status resume_error = PrivateResume();\n          if (!resume_error.Success()) {\n            diagnostic_manager.Printf(\n                eDiagnosticSeverityError,\n                \"couldn't resume inferior the %d time: \\\"%s\\\".\", num_resumes,\n                resume_error.AsCString());\n            return_value = eExpressionSetupError;\n            break;\n          }\n        }\n\n        got_event =\n            listener_sp->GetEvent(event_sp, GetUtilityExpressionTimeout());\n        if (!got_event) {\n          LLDB_LOGF(log,\n                    \"Process::RunThreadPlan(): didn't get any event after \"\n                    \"resume %\" PRIu32 \", exiting.\",\n                    num_resumes);\n\n          diagnostic_manager.Printf(eDiagnosticSeverityError,\n                                    \"didn't get any event after resume %\" PRIu32\n                                    \", exiting.\",\n                                    num_resumes);\n          return_value = eExpressionSetupError;\n          break;\n        }\n\n        stop_state =\n            Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n\n        if (stop_state != eStateRunning) {\n          bool restarted = false;\n\n          if (stop_state == eStateStopped) {\n            restarted = Process::ProcessEventData::GetRestartedFromEvent(\n                event_sp.get());\n            LLDB_LOGF(\n                log,\n                \"Process::RunThreadPlan(): didn't get running event after \"\n                \"resume %d, got %s instead (restarted: %i, do_resume: %i, \"\n                \"handle_running_event: %i).\",\n                num_resumes, StateAsCString(stop_state), restarted, do_resume,\n                handle_running_event);\n          }\n\n          if (restarted) {\n            // This is probably an overabundance of caution, I don't think I\n            // should ever get a stopped & restarted event here.  But if I do,\n            // the best thing is to Halt and then get out of here.\n            const bool clear_thread_plans = false;\n            const bool use_run_lock = false;\n            Halt(clear_thread_plans, use_run_lock);\n          }\n\n          diagnostic_manager.Printf(\n              eDiagnosticSeverityError,\n              \"didn't get running event after initial resume, got %s instead.\",\n              StateAsCString(stop_state));\n          return_value = eExpressionSetupError;\n          break;\n        }\n\n        if (log)\n          log->PutCString(\"Process::RunThreadPlan(): resuming succeeded.\");\n        // We need to call the function synchronously, so spin waiting for it\n        // to return. If we get interrupted while executing, we're going to\n        // lose our context, and won't be able to gather the result at this\n        // point. We set the timeout AFTER the resume, since the resume takes\n        // some time and we don't want to charge that to the timeout.\n      } else {\n        if (log)\n          log->PutCString(\"Process::RunThreadPlan(): waiting for next event.\");\n      }\n\n      do_resume = true;\n      handle_running_event = true;\n\n      // Now wait for the process to stop again:\n      event_sp.reset();\n\n      Timeout<std::micro> timeout =\n          GetExpressionTimeout(options, before_first_timeout);\n      if (log) {\n        if (timeout) {\n          auto now = system_clock::now();\n          LLDB_LOGF(log,\n                    \"Process::RunThreadPlan(): about to wait - now is %s - \"\n                    \"endpoint is %s\",\n                    llvm::to_string(now).c_str(),\n                    llvm::to_string(now + *timeout).c_str());\n        } else {\n          LLDB_LOGF(log, \"Process::RunThreadPlan(): about to wait forever.\");\n        }\n      }\n\n#ifdef LLDB_RUN_THREAD_HALT_WITH_EVENT\n      // See comment above...\n      if (miss_first_event) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n        miss_first_event = false;\n        got_event = false;\n      } else\n#endif\n        got_event = listener_sp->GetEvent(event_sp, timeout);\n\n      if (got_event) {\n        if (event_sp) {\n          bool keep_going = false;\n          if (event_sp->GetType() == eBroadcastBitInterrupt) {\n            const bool clear_thread_plans = false;\n            const bool use_run_lock = false;\n            Halt(clear_thread_plans, use_run_lock);\n            return_value = eExpressionInterrupted;\n            diagnostic_manager.PutString(eDiagnosticSeverityRemark,\n                                         \"execution halted by user interrupt.\");\n            LLDB_LOGF(log, \"Process::RunThreadPlan(): Got  interrupted by \"\n                           \"eBroadcastBitInterrupted, exiting.\");\n            break;\n          } else {\n            stop_state =\n                Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n            LLDB_LOGF(log,\n                      \"Process::RunThreadPlan(): in while loop, got event: %s.\",\n                      StateAsCString(stop_state));\n\n            switch (stop_state) {\n            case lldb::eStateStopped: {\n              if (Process::ProcessEventData::GetRestartedFromEvent(\n                      event_sp.get())) {\n                // If we were restarted, we just need to go back up to fetch\n                // another event.\n                LLDB_LOGF(log, \"Process::RunThreadPlan(): Got a stop and \"\n                               \"restart, so we'll continue waiting.\");\n                keep_going = true;\n                do_resume = false;\n                handle_running_event = true;\n              } else {\n                const bool handle_interrupts = true;\n                return_value = *HandleStoppedEvent(\n                    expr_thread_id, thread_plan_sp, thread_plan_restorer,\n                    event_sp, event_to_broadcast_sp, options,\n                    handle_interrupts);\n                if (return_value == eExpressionThreadVanished)\n                  keep_going = false;\n              }\n            } break;\n\n            case lldb::eStateRunning:\n              // This shouldn't really happen, but sometimes we do get two\n              // running events without an intervening stop, and in that case\n              // we should just go back to waiting for the stop.\n              do_resume = false;\n              keep_going = true;\n              handle_running_event = false;\n              break;\n\n            default:\n              LLDB_LOGF(log,\n                        \"Process::RunThreadPlan(): execution stopped with \"\n                        \"unexpected state: %s.\",\n                        StateAsCString(stop_state));\n\n              if (stop_state == eStateExited)\n                event_to_broadcast_sp = event_sp;\n\n              diagnostic_manager.PutString(\n                  eDiagnosticSeverityError,\n                  \"execution stopped with unexpected state.\");\n              return_value = eExpressionInterrupted;\n              break;\n            }\n          }\n\n          if (keep_going)\n            continue;\n          else\n            break;\n        } else {\n          if (log)\n            log->PutCString(\"Process::RunThreadPlan(): got_event was true, but \"\n                            \"the event pointer was null.  How odd...\");\n          return_value = eExpressionInterrupted;\n          break;\n        }\n      } else {\n        // If we didn't get an event that means we've timed out... We will\n        // interrupt the process here.  Depending on what we were asked to do\n        // we will either exit, or try with all threads running for the same\n        // timeout.\n\n        if (log) {\n          if (options.GetTryAllThreads()) {\n            if (before_first_timeout) {\n              LLDB_LOG(log,\n                       \"Running function with one thread timeout timed out.\");\n            } else\n              LLDB_LOG(log, \"Restarting function with all threads enabled and \"\n                            \"timeout: {0} timed out, abandoning execution.\",\n                       timeout);\n          } else\n            LLDB_LOG(log, \"Running function with timeout: {0} timed out, \"\n                          \"abandoning execution.\",\n                     timeout);\n        }\n\n        // It is possible that between the time we issued the Halt, and we get\n        // around to calling Halt the target could have stopped.  That's fine,\n        // Halt will figure that out and send the appropriate Stopped event.\n        // BUT it is also possible that we stopped & restarted (e.g. hit a\n        // signal with \"stop\" set to false.)  In\n        // that case, we'll get the stopped & restarted event, and we should go\n        // back to waiting for the Halt's stopped event.  That's what this\n        // while loop does.\n\n        bool back_to_top = true;\n        uint32_t try_halt_again = 0;\n        bool do_halt = true;\n        const uint32_t num_retries = 5;\n        while (try_halt_again < num_retries) {\n          Status halt_error;\n          if (do_halt) {\n            LLDB_LOGF(log, \"Process::RunThreadPlan(): Running Halt.\");\n            const bool clear_thread_plans = false;\n            const bool use_run_lock = false;\n            Halt(clear_thread_plans, use_run_lock);\n          }\n          if (halt_error.Success()) {\n            if (log)\n              log->PutCString(\"Process::RunThreadPlan(): Halt succeeded.\");\n\n            got_event =\n                listener_sp->GetEvent(event_sp, GetUtilityExpressionTimeout());\n\n            if (got_event) {\n              stop_state =\n                  Process::ProcessEventData::GetStateFromEvent(event_sp.get());\n              if (log) {\n                LLDB_LOGF(log,\n                          \"Process::RunThreadPlan(): Stopped with event: %s\",\n                          StateAsCString(stop_state));\n                if (stop_state == lldb::eStateStopped &&\n                    Process::ProcessEventData::GetInterruptedFromEvent(\n                        event_sp.get()))\n                  log->PutCString(\"    Event was the Halt interruption event.\");\n              }\n\n              if (stop_state == lldb::eStateStopped) {\n                if (Process::ProcessEventData::GetRestartedFromEvent(\n                        event_sp.get())) {\n                  if (log)\n                    log->PutCString(\"Process::RunThreadPlan(): Went to halt \"\n                                    \"but got a restarted event, there must be \"\n                                    \"an un-restarted stopped event so try \"\n                                    \"again...  \"\n                                    \"Exiting wait loop.\");\n                  try_halt_again++;\n                  do_halt = false;\n                  continue;\n                }\n\n                // Between the time we initiated the Halt and the time we\n                // delivered it, the process could have already finished its\n                // job.  Check that here:\n                const bool handle_interrupts = false;\n                if (auto result = HandleStoppedEvent(\n                        expr_thread_id, thread_plan_sp, thread_plan_restorer,\n                        event_sp, event_to_broadcast_sp, options,\n                        handle_interrupts)) {\n                  return_value = *result;\n                  back_to_top = false;\n                  break;\n                }\n\n                if (!options.GetTryAllThreads()) {\n                  if (log)\n                    log->PutCString(\"Process::RunThreadPlan(): try_all_threads \"\n                                    \"was false, we stopped so now we're \"\n                                    \"quitting.\");\n                  return_value = eExpressionInterrupted;\n                  back_to_top = false;\n                  break;\n                }\n\n                if (before_first_timeout) {\n                  // Set all the other threads to run, and return to the top of\n                  // the loop, which will continue;\n                  before_first_timeout = false;\n                  thread_plan_sp->SetStopOthers(false);\n                  if (log)\n                    log->PutCString(\n                        \"Process::RunThreadPlan(): about to resume.\");\n\n                  back_to_top = true;\n                  break;\n                } else {\n                  // Running all threads failed, so return Interrupted.\n                  if (log)\n                    log->PutCString(\"Process::RunThreadPlan(): running all \"\n                                    \"threads timed out.\");\n                  return_value = eExpressionInterrupted;\n                  back_to_top = false;\n                  break;\n                }\n              }\n            } else {\n              if (log)\n                log->PutCString(\"Process::RunThreadPlan(): halt said it \"\n                                \"succeeded, but I got no event.  \"\n                                \"I'm getting out of here passing Interrupted.\");\n              return_value = eExpressionInterrupted;\n              back_to_top = false;\n              break;\n            }\n          } else {\n            try_halt_again++;\n            continue;\n          }\n        }\n\n        if (!back_to_top || try_halt_again > num_retries)\n          break;\n        else\n          continue;\n      }\n    } // END WAIT LOOP\n\n    // If we had to start up a temporary private state thread to run this\n    // thread plan, shut it down now.\n    if (backup_private_state_thread.IsJoinable()) {\n      StopPrivateStateThread();\n      Status error;\n      m_private_state_thread = backup_private_state_thread;\n      if (stopper_base_plan_sp) {\n        thread->DiscardThreadPlansUpToPlan(stopper_base_plan_sp);\n      }\n      if (old_state != eStateInvalid)\n        m_public_state.SetValueNoLock(old_state);\n    }\n\n    // If our thread went away on us, we need to get out of here without\n    // doing any more work.  We don't have to clean up the thread plan, that\n    // will have happened when the Thread was destroyed.\n    if (return_value == eExpressionThreadVanished) {\n      return return_value;\n    }\n\n    if (return_value != eExpressionCompleted && log) {\n      // Print a backtrace into the log so we can figure out where we are:\n      StreamString s;\n      s.PutCString(\"Thread state after unsuccessful completion: \\n\");\n      thread->GetStackFrameStatus(s, 0, UINT32_MAX, true, UINT32_MAX);\n      log->PutString(s.GetString());\n    }\n    // Restore the thread state if we are going to discard the plan execution.\n    // There are three cases where this could happen: 1) The execution\n    // successfully completed 2) We hit a breakpoint, and ignore_breakpoints\n    // was true 3) We got some other error, and discard_on_error was true\n    bool should_unwind = (return_value == eExpressionInterrupted &&\n                          options.DoesUnwindOnError()) ||\n                         (return_value == eExpressionHitBreakpoint &&\n                          options.DoesIgnoreBreakpoints());\n\n    if (return_value == eExpressionCompleted || should_unwind) {\n      thread_plan_sp->RestoreThreadState();\n    }\n\n    // Now do some processing on the results of the run:\n    if (return_value == eExpressionInterrupted ||\n        return_value == eExpressionHitBreakpoint) {\n      if (log) {\n        StreamString s;\n        if (event_sp)\n          event_sp->Dump(&s);\n        else {\n          log->PutCString(\"Process::RunThreadPlan(): Stop event that \"\n                          \"interrupted us is NULL.\");\n        }\n\n        StreamString ts;\n\n        const char *event_explanation = nullptr;\n\n        do {\n          if (!event_sp) {\n            event_explanation = \"<no event>\";\n            break;\n          } else if (event_sp->GetType() == eBroadcastBitInterrupt) {\n            event_explanation = \"<user interrupt>\";\n            break;\n          } else {\n            const Process::ProcessEventData *event_data =\n                Process::ProcessEventData::GetEventDataFromEvent(\n                    event_sp.get());\n\n            if (!event_data) {\n              event_explanation = \"<no event data>\";\n              break;\n            }\n\n            Process *process = event_data->GetProcessSP().get();\n\n            if (!process) {\n              event_explanation = \"<no process>\";\n              break;\n            }\n\n            ThreadList &thread_list = process->GetThreadList();\n\n            uint32_t num_threads = thread_list.GetSize();\n            uint32_t thread_index;\n\n            ts.Printf(\"<%u threads> \", num_threads);\n\n            for (thread_index = 0; thread_index < num_threads; ++thread_index) {\n              Thread *thread = thread_list.GetThreadAtIndex(thread_index).get();\n\n              if (!thread) {\n                ts.Printf(\"<?> \");\n                continue;\n              }\n\n              ts.Printf(\"<0x%4.4\" PRIx64 \" \", thread->GetID());\n              RegisterContext *register_context =\n                  thread->GetRegisterContext().get();\n\n              if (register_context)\n                ts.Printf(\"[ip 0x%\" PRIx64 \"] \", register_context->GetPC());\n              else\n                ts.Printf(\"[ip unknown] \");\n\n              // Show the private stop info here, the public stop info will be\n              // from the last natural stop.\n              lldb::StopInfoSP stop_info_sp = thread->GetPrivateStopInfo();\n              if (stop_info_sp) {\n                const char *stop_desc = stop_info_sp->GetDescription();\n                if (stop_desc)\n                  ts.PutCString(stop_desc);\n              }\n              ts.Printf(\">\");\n            }\n\n            event_explanation = ts.GetData();\n          }\n        } while (false);\n\n        if (event_explanation)\n          LLDB_LOGF(log,\n                    \"Process::RunThreadPlan(): execution interrupted: %s %s\",\n                    s.GetData(), event_explanation);\n        else\n          LLDB_LOGF(log, \"Process::RunThreadPlan(): execution interrupted: %s\",\n                    s.GetData());\n      }\n\n      if (should_unwind) {\n        LLDB_LOGF(log,\n                  \"Process::RunThreadPlan: ExecutionInterrupted - \"\n                  \"discarding thread plans up to %p.\",\n                  static_cast<void *>(thread_plan_sp.get()));\n        thread->DiscardThreadPlansUpToPlan(thread_plan_sp);\n      } else {\n        LLDB_LOGF(log,\n                  \"Process::RunThreadPlan: ExecutionInterrupted - for \"\n                  \"plan: %p not discarding.\",\n                  static_cast<void *>(thread_plan_sp.get()));\n      }\n    } else if (return_value == eExpressionSetupError) {\n      if (log)\n        log->PutCString(\"Process::RunThreadPlan(): execution set up error.\");\n\n      if (options.DoesUnwindOnError()) {\n        thread->DiscardThreadPlansUpToPlan(thread_plan_sp);\n      }\n    } else {\n      if (thread->IsThreadPlanDone(thread_plan_sp.get())) {\n        if (log)\n          log->PutCString(\"Process::RunThreadPlan(): thread plan is done\");\n        return_value = eExpressionCompleted;\n      } else if (thread->WasThreadPlanDiscarded(thread_plan_sp.get())) {\n        if (log)\n          log->PutCString(\n              \"Process::RunThreadPlan(): thread plan was discarded\");\n        return_value = eExpressionDiscarded;\n      } else {\n        if (log)\n          log->PutCString(\n              \"Process::RunThreadPlan(): thread plan stopped in mid course\");\n        if (options.DoesUnwindOnError() && thread_plan_sp) {\n          if (log)\n            log->PutCString(\"Process::RunThreadPlan(): discarding thread plan \"\n                            \"'cause unwind_on_error is set.\");\n          thread->DiscardThreadPlansUpToPlan(thread_plan_sp);\n        }\n      }\n    }\n\n    // Thread we ran the function in may have gone away because we ran the\n    // target Check that it's still there, and if it is put it back in the\n    // context. Also restore the frame in the context if it is still present.\n    thread = GetThreadList().FindThreadByIndexID(thread_idx_id, true).get();\n    if (thread) {\n      exe_ctx.SetFrameSP(thread->GetFrameWithStackID(ctx_frame_id));\n    }\n\n    // Also restore the current process'es selected frame & thread, since this\n    // function calling may be done behind the user's back.\n\n    if (selected_tid != LLDB_INVALID_THREAD_ID) {\n      if (GetThreadList().SetSelectedThreadByIndexID(selected_tid) &&\n          selected_stack_id.IsValid()) {\n        // We were able to restore the selected thread, now restore the frame:\n        std::lock_guard<std::recursive_mutex> guard(GetThreadList().GetMutex());\n        StackFrameSP old_frame_sp =\n            GetThreadList().GetSelectedThread()->GetFrameWithStackID(\n                selected_stack_id);\n        if (old_frame_sp)\n          GetThreadList().GetSelectedThread()->SetSelectedFrame(\n              old_frame_sp.get());\n      }\n    }\n  }\n\n  // If the process exited during the run of the thread plan, notify everyone.\n\n  if (event_to_broadcast_sp) {\n    if (log)\n      log->PutCString(\"Process::RunThreadPlan(): rebroadcasting event.\");\n    BroadcastEvent(event_to_broadcast_sp);\n  }\n\n  return return_value;\n}\n\nconst char *Process::ExecutionResultAsCString(ExpressionResults result) {\n  const char *result_name = \"<unknown>\";\n\n  switch (result) {\n  case eExpressionCompleted:\n    result_name = \"eExpressionCompleted\";\n    break;\n  case eExpressionDiscarded:\n    result_name = \"eExpressionDiscarded\";\n    break;\n  case eExpressionInterrupted:\n    result_name = \"eExpressionInterrupted\";\n    break;\n  case eExpressionHitBreakpoint:\n    result_name = \"eExpressionHitBreakpoint\";\n    break;\n  case eExpressionSetupError:\n    result_name = \"eExpressionSetupError\";\n    break;\n  case eExpressionParseError:\n    result_name = \"eExpressionParseError\";\n    break;\n  case eExpressionResultUnavailable:\n    result_name = \"eExpressionResultUnavailable\";\n    break;\n  case eExpressionTimedOut:\n    result_name = \"eExpressionTimedOut\";\n    break;\n  case eExpressionStoppedForDebug:\n    result_name = \"eExpressionStoppedForDebug\";\n    break;\n  case eExpressionThreadVanished:\n    result_name = \"eExpressionThreadVanished\";\n  }\n  return result_name;\n}\n\nvoid Process::GetStatus(Stream &strm) {\n  const StateType state = GetState();\n  if (StateIsStoppedState(state, false)) {\n    if (state == eStateExited) {\n      int exit_status = GetExitStatus();\n      const char *exit_description = GetExitDescription();\n      strm.Printf(\"Process %\" PRIu64 \" exited with status = %i (0x%8.8x) %s\\n\",\n                  GetID(), exit_status, exit_status,\n                  exit_description ? exit_description : \"\");\n    } else {\n      if (state == eStateConnected)\n        strm.Printf(\"Connected to remote target.\\n\");\n      else\n        strm.Printf(\"Process %\" PRIu64 \" %s\\n\", GetID(), StateAsCString(state));\n    }\n  } else {\n    strm.Printf(\"Process %\" PRIu64 \" is running.\\n\", GetID());\n  }\n}\n\nsize_t Process::GetThreadStatus(Stream &strm,\n                                bool only_threads_with_stop_reason,\n                                uint32_t start_frame, uint32_t num_frames,\n                                uint32_t num_frames_with_source,\n                                bool stop_format) {\n  size_t num_thread_infos_dumped = 0;\n\n  // You can't hold the thread list lock while calling Thread::GetStatus.  That\n  // very well might run code (e.g. if we need it to get return values or\n  // arguments.)  For that to work the process has to be able to acquire it.\n  // So instead copy the thread ID's, and look them up one by one:\n\n  uint32_t num_threads;\n  std::vector<lldb::tid_t> thread_id_array;\n  // Scope for thread list locker;\n  {\n    std::lock_guard<std::recursive_mutex> guard(GetThreadList().GetMutex());\n    ThreadList &curr_thread_list = GetThreadList();\n    num_threads = curr_thread_list.GetSize();\n    uint32_t idx;\n    thread_id_array.resize(num_threads);\n    for (idx = 0; idx < num_threads; ++idx)\n      thread_id_array[idx] = curr_thread_list.GetThreadAtIndex(idx)->GetID();\n  }\n\n  for (uint32_t i = 0; i < num_threads; i++) {\n    ThreadSP thread_sp(GetThreadList().FindThreadByID(thread_id_array[i]));\n    if (thread_sp) {\n      if (only_threads_with_stop_reason) {\n        StopInfoSP stop_info_sp = thread_sp->GetStopInfo();\n        if (!stop_info_sp || !stop_info_sp->IsValid())\n          continue;\n      }\n      thread_sp->GetStatus(strm, start_frame, num_frames,\n                           num_frames_with_source,\n                           stop_format);\n      ++num_thread_infos_dumped;\n    } else {\n      Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_PROCESS));\n      LLDB_LOGF(log, \"Process::GetThreadStatus - thread 0x\" PRIu64\n                     \" vanished while running Thread::GetStatus.\");\n    }\n  }\n  return num_thread_infos_dumped;\n}\n\nvoid Process::AddInvalidMemoryRegion(const LoadRange &region) {\n  m_memory_cache.AddInvalidRange(region.GetRangeBase(), region.GetByteSize());\n}\n\nbool Process::RemoveInvalidMemoryRange(const LoadRange &region) {\n  return m_memory_cache.RemoveInvalidRange(region.GetRangeBase(),\n                                           region.GetByteSize());\n}\n\nvoid Process::AddPreResumeAction(PreResumeActionCallback callback,\n                                 void *baton) {\n  m_pre_resume_actions.push_back(PreResumeCallbackAndBaton(callback, baton));\n}\n\nbool Process::RunPreResumeActions() {\n  bool result = true;\n  while (!m_pre_resume_actions.empty()) {\n    struct PreResumeCallbackAndBaton action = m_pre_resume_actions.back();\n    m_pre_resume_actions.pop_back();\n    bool this_result = action.callback(action.baton);\n    if (result)\n      result = this_result;\n  }\n  return result;\n}\n\nvoid Process::ClearPreResumeActions() { m_pre_resume_actions.clear(); }\n\nvoid Process::ClearPreResumeAction(PreResumeActionCallback callback, void *baton)\n{\n    PreResumeCallbackAndBaton element(callback, baton);\n    auto found_iter = std::find(m_pre_resume_actions.begin(), m_pre_resume_actions.end(), element);\n    if (found_iter != m_pre_resume_actions.end())\n    {\n        m_pre_resume_actions.erase(found_iter);\n    }\n}\n\nProcessRunLock &Process::GetRunLock() {\n  if (m_private_state_thread.EqualsThread(Host::GetCurrentThread()))\n    return m_private_run_lock;\n  else\n    return m_public_run_lock;\n}\n\nbool Process::CurrentThreadIsPrivateStateThread()\n{\n  return m_private_state_thread.EqualsThread(Host::GetCurrentThread());\n}\n\n\nvoid Process::Flush() {\n  m_thread_list.Flush();\n  m_extended_thread_list.Flush();\n  m_extended_thread_stop_id = 0;\n  m_queue_list.Clear();\n  m_queue_list_stop_id = 0;\n}\n\nlldb::addr_t Process::GetCodeAddressMask() {\n  if (m_code_address_mask == 0) {\n    if (uint32_t number_of_addressable_bits = GetVirtualAddressableBits()) {\n      lldb::addr_t address_mask = ~((1ULL << number_of_addressable_bits) - 1);\n      SetCodeAddressMask(address_mask);\n    }\n  }\n  return m_code_address_mask;\n}\n\nlldb::addr_t Process::GetDataAddressMask() {\n  if (m_data_address_mask == 0) {\n    if (uint32_t number_of_addressable_bits = GetVirtualAddressableBits()) {\n      lldb::addr_t address_mask = ~((1ULL << number_of_addressable_bits) - 1);\n      SetDataAddressMask(address_mask);\n    }\n  }\n  return m_data_address_mask;\n}\n\nvoid Process::DidExec() {\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(log, \"Process::%s()\", __FUNCTION__);\n\n  Target &target = GetTarget();\n  target.CleanupProcess();\n  target.ClearModules(false);\n  m_dynamic_checkers_up.reset();\n  m_abi_sp.reset();\n  m_system_runtime_up.reset();\n  m_os_up.reset();\n  m_dyld_up.reset();\n  m_jit_loaders_up.reset();\n  m_image_tokens.clear();\n  m_allocated_memory_cache.Clear();\n  {\n    std::lock_guard<std::recursive_mutex> guard(m_language_runtimes_mutex);\n    m_language_runtimes.clear();\n  }\n  m_instrumentation_runtimes.clear();\n  m_thread_list.DiscardThreadPlans();\n  m_memory_cache.Clear(true);\n  DoDidExec();\n  CompleteAttach();\n  // Flush the process (threads and all stack frames) after running\n  // CompleteAttach() in case the dynamic loader loaded things in new\n  // locations.\n  Flush();\n\n  // After we figure out what was loaded/unloaded in CompleteAttach, we need to\n  // let the target know so it can do any cleanup it needs to.\n  target.DidExec();\n}\n\naddr_t Process::ResolveIndirectFunction(const Address *address, Status &error) {\n  if (address == nullptr) {\n    error.SetErrorString(\"Invalid address argument\");\n    return LLDB_INVALID_ADDRESS;\n  }\n\n  addr_t function_addr = LLDB_INVALID_ADDRESS;\n\n  addr_t addr = address->GetLoadAddress(&GetTarget());\n  std::map<addr_t, addr_t>::const_iterator iter =\n      m_resolved_indirect_addresses.find(addr);\n  if (iter != m_resolved_indirect_addresses.end()) {\n    function_addr = (*iter).second;\n  } else {\n    if (!CallVoidArgVoidPtrReturn(address, function_addr)) {\n      Symbol *symbol = address->CalculateSymbolContextSymbol();\n      error.SetErrorStringWithFormat(\n          \"Unable to call resolver for indirect function %s\",\n          symbol ? symbol->GetName().AsCString() : \"<UNKNOWN>\");\n      function_addr = LLDB_INVALID_ADDRESS;\n    } else {\n      m_resolved_indirect_addresses.insert(\n          std::pair<addr_t, addr_t>(addr, function_addr));\n    }\n  }\n  return function_addr;\n}\n\nvoid Process::ModulesDidLoad(ModuleList &module_list) {\n  // Inform the system runtime of the modified modules.\n  SystemRuntime *sys_runtime = GetSystemRuntime();\n  if (sys_runtime)\n    sys_runtime->ModulesDidLoad(module_list);\n\n  GetJITLoaders().ModulesDidLoad(module_list);\n\n  // Give the instrumentation runtimes a chance to be created before informing\n  // them of the modified modules.\n  InstrumentationRuntime::ModulesDidLoad(module_list, this,\n                                         m_instrumentation_runtimes);\n  for (auto &runtime : m_instrumentation_runtimes)\n    runtime.second->ModulesDidLoad(module_list);\n\n  // Give the language runtimes a chance to be created before informing them of\n  // the modified modules.\n  for (const lldb::LanguageType lang_type : Language::GetSupportedLanguages()) {\n    if (LanguageRuntime *runtime = GetLanguageRuntime(lang_type))\n      runtime->ModulesDidLoad(module_list);\n  }\n\n  // If we don't have an operating system plug-in, try to load one since\n  // loading shared libraries might cause a new one to try and load\n  if (!m_os_up)\n    LoadOperatingSystemPlugin(false);\n\n  // Inform the structured-data plugins of the modified modules.\n  for (auto pair : m_structured_data_plugin_map) {\n    if (pair.second)\n      pair.second->ModulesDidLoad(*this, module_list);\n  }\n}\n\nvoid Process::PrintWarning(uint64_t warning_type, const void *repeat_key,\n                           const char *fmt, ...) {\n  bool print_warning = true;\n\n  StreamSP stream_sp = GetTarget().GetDebugger().GetAsyncOutputStream();\n  if (!stream_sp)\n    return;\n\n  if (repeat_key != nullptr) {\n    WarningsCollection::iterator it = m_warnings_issued.find(warning_type);\n    if (it == m_warnings_issued.end()) {\n      m_warnings_issued[warning_type] = WarningsPointerSet();\n      m_warnings_issued[warning_type].insert(repeat_key);\n    } else {\n      if (it->second.find(repeat_key) != it->second.end()) {\n        print_warning = false;\n      } else {\n        it->second.insert(repeat_key);\n      }\n    }\n  }\n\n  if (print_warning) {\n    va_list args;\n    va_start(args, fmt);\n    stream_sp->PrintfVarArg(fmt, args);\n    va_end(args);\n  }\n}\n\nvoid Process::PrintWarningOptimization(const SymbolContext &sc) {\n  if (!GetWarningsOptimization())\n    return;\n  if (!sc.module_sp)\n    return;\n  if (!sc.module_sp->GetFileSpec().GetFilename().IsEmpty() && sc.function &&\n      sc.function->GetIsOptimized()) {\n    PrintWarning(Process::Warnings::eWarningsOptimization, sc.module_sp.get(),\n                 \"%s was compiled with optimization - stepping may behave \"\n                 \"oddly; variables may not be available.\\n\",\n                 sc.module_sp->GetFileSpec().GetFilename().GetCString());\n  }\n}\n\nvoid Process::PrintWarningUnsupportedLanguage(const SymbolContext &sc) {\n  if (!GetWarningsUnsupportedLanguage())\n    return;\n  if (!sc.module_sp)\n    return;\n  LanguageType language = sc.GetLanguage();\n  if (language == eLanguageTypeUnknown)\n    return;\n  LanguageSet plugins =\n      PluginManager::GetAllTypeSystemSupportedLanguagesForTypes();\n  if (!plugins[language]) {\n    PrintWarning(Process::Warnings::eWarningsUnsupportedLanguage,\n                 sc.module_sp.get(),\n                 \"This version of LLDB has no plugin for the %s language. \"\n                 \"Inspection of frame variables will be limited.\\n\",\n                 Language::GetNameForLanguageType(language));\n  }\n}\n\nbool Process::GetProcessInfo(ProcessInstanceInfo &info) {\n  info.Clear();\n\n  PlatformSP platform_sp = GetTarget().GetPlatform();\n  if (!platform_sp)\n    return false;\n\n  return platform_sp->GetProcessInfo(GetID(), info);\n}\n\nThreadCollectionSP Process::GetHistoryThreads(lldb::addr_t addr) {\n  ThreadCollectionSP threads;\n\n  const MemoryHistorySP &memory_history =\n      MemoryHistory::FindPlugin(shared_from_this());\n\n  if (!memory_history) {\n    return threads;\n  }\n\n  threads = std::make_shared<ThreadCollection>(\n      memory_history->GetHistoryThreads(addr));\n\n  return threads;\n}\n\nInstrumentationRuntimeSP\nProcess::GetInstrumentationRuntime(lldb::InstrumentationRuntimeType type) {\n  InstrumentationRuntimeCollection::iterator pos;\n  pos = m_instrumentation_runtimes.find(type);\n  if (pos == m_instrumentation_runtimes.end()) {\n    return InstrumentationRuntimeSP();\n  } else\n    return (*pos).second;\n}\n\nbool Process::GetModuleSpec(const FileSpec &module_file_spec,\n                            const ArchSpec &arch, ModuleSpec &module_spec) {\n  module_spec.Clear();\n  return false;\n}\n\nsize_t Process::AddImageToken(lldb::addr_t image_ptr) {\n  m_image_tokens.push_back(image_ptr);\n  return m_image_tokens.size() - 1;\n}\n\nlldb::addr_t Process::GetImagePtrFromToken(size_t token) const {\n  if (token < m_image_tokens.size())\n    return m_image_tokens[token];\n  return LLDB_INVALID_ADDRESS;\n}\n\nvoid Process::ResetImageToken(size_t token) {\n  if (token < m_image_tokens.size())\n    m_image_tokens[token] = LLDB_INVALID_ADDRESS;\n}\n\nAddress\nProcess::AdvanceAddressToNextBranchInstruction(Address default_stop_addr,\n                                               AddressRange range_bounds) {\n  Target &target = GetTarget();\n  DisassemblerSP disassembler_sp;\n  InstructionList *insn_list = nullptr;\n\n  Address retval = default_stop_addr;\n\n  if (!target.GetUseFastStepping())\n    return retval;\n  if (!default_stop_addr.IsValid())\n    return retval;\n\n  const char *plugin_name = nullptr;\n  const char *flavor = nullptr;\n  disassembler_sp = Disassembler::DisassembleRange(\n      target.GetArchitecture(), plugin_name, flavor, GetTarget(), range_bounds);\n  if (disassembler_sp)\n    insn_list = &disassembler_sp->GetInstructionList();\n\n  if (insn_list == nullptr) {\n    return retval;\n  }\n\n  size_t insn_offset =\n      insn_list->GetIndexOfInstructionAtAddress(default_stop_addr);\n  if (insn_offset == UINT32_MAX) {\n    return retval;\n  }\n\n  uint32_t branch_index = insn_list->GetIndexOfNextBranchInstruction(\n      insn_offset, false /* ignore_calls*/, nullptr);\n  if (branch_index == UINT32_MAX) {\n    return retval;\n  }\n\n  if (branch_index > insn_offset) {\n    Address next_branch_insn_address =\n        insn_list->GetInstructionAtIndex(branch_index)->GetAddress();\n    if (next_branch_insn_address.IsValid() &&\n        range_bounds.ContainsFileAddress(next_branch_insn_address)) {\n      retval = next_branch_insn_address;\n    }\n  }\n\n  return retval;\n}\n\nStatus\nProcess::GetMemoryRegions(lldb_private::MemoryRegionInfos &region_list) {\n\n  Status error;\n\n  lldb::addr_t range_end = 0;\n\n  region_list.clear();\n  do {\n    lldb_private::MemoryRegionInfo region_info;\n    error = GetMemoryRegionInfo(range_end, region_info);\n    // GetMemoryRegionInfo should only return an error if it is unimplemented.\n    if (error.Fail()) {\n      region_list.clear();\n      break;\n    }\n\n    range_end = region_info.GetRange().GetRangeEnd();\n    if (region_info.GetMapped() == MemoryRegionInfo::eYes) {\n      region_list.push_back(std::move(region_info));\n    }\n  } while (range_end != LLDB_INVALID_ADDRESS);\n\n  return error;\n}\n\nStatus\nProcess::ConfigureStructuredData(ConstString type_name,\n                                 const StructuredData::ObjectSP &config_sp) {\n  // If you get this, the Process-derived class needs to implement a method to\n  // enable an already-reported asynchronous structured data feature. See\n  // ProcessGDBRemote for an example implementation over gdb-remote.\n  return Status(\"unimplemented\");\n}\n\nvoid Process::MapSupportedStructuredDataPlugins(\n    const StructuredData::Array &supported_type_names) {\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_PROCESS));\n\n  // Bail out early if there are no type names to map.\n  if (supported_type_names.GetSize() == 0) {\n    LLDB_LOGF(log, \"Process::%s(): no structured data types supported\",\n              __FUNCTION__);\n    return;\n  }\n\n  // Convert StructuredData type names to ConstString instances.\n  std::set<ConstString> const_type_names;\n\n  LLDB_LOGF(log,\n            \"Process::%s(): the process supports the following async \"\n            \"structured data types:\",\n            __FUNCTION__);\n\n  supported_type_names.ForEach(\n      [&const_type_names, &log](StructuredData::Object *object) {\n        if (!object) {\n          // Invalid - shouldn't be null objects in the array.\n          return false;\n        }\n\n        auto type_name = object->GetAsString();\n        if (!type_name) {\n          // Invalid format - all type names should be strings.\n          return false;\n        }\n\n        const_type_names.insert(ConstString(type_name->GetValue()));\n        LLDB_LOG(log, \"- {0}\", type_name->GetValue());\n        return true;\n      });\n\n  // For each StructuredDataPlugin, if the plugin handles any of the types in\n  // the supported_type_names, map that type name to that plugin. Stop when\n  // we've consumed all the type names.\n  // FIXME: should we return an error if there are type names nobody\n  // supports?\n  for (uint32_t plugin_index = 0; !const_type_names.empty(); plugin_index++) {\n    auto create_instance =\n           PluginManager::GetStructuredDataPluginCreateCallbackAtIndex(\n               plugin_index);\n    if (!create_instance)\n      break;\n\n    // Create the plugin.\n    StructuredDataPluginSP plugin_sp = (*create_instance)(*this);\n    if (!plugin_sp) {\n      // This plugin doesn't think it can work with the process. Move on to the\n      // next.\n      continue;\n    }\n\n    // For any of the remaining type names, map any that this plugin supports.\n    std::vector<ConstString> names_to_remove;\n    for (auto &type_name : const_type_names) {\n      if (plugin_sp->SupportsStructuredDataType(type_name)) {\n        m_structured_data_plugin_map.insert(\n            std::make_pair(type_name, plugin_sp));\n        names_to_remove.push_back(type_name);\n        LLDB_LOGF(log,\n                  \"Process::%s(): using plugin %s for type name \"\n                  \"%s\",\n                  __FUNCTION__, plugin_sp->GetPluginName().GetCString(),\n                  type_name.GetCString());\n      }\n    }\n\n    // Remove the type names that were consumed by this plugin.\n    for (auto &type_name : names_to_remove)\n      const_type_names.erase(type_name);\n  }\n}\n\nbool Process::RouteAsyncStructuredData(\n    const StructuredData::ObjectSP object_sp) {\n  // Nothing to do if there's no data.\n  if (!object_sp)\n    return false;\n\n  // The contract is this must be a dictionary, so we can look up the routing\n  // key via the top-level 'type' string value within the dictionary.\n  StructuredData::Dictionary *dictionary = object_sp->GetAsDictionary();\n  if (!dictionary)\n    return false;\n\n  // Grab the async structured type name (i.e. the feature/plugin name).\n  ConstString type_name;\n  if (!dictionary->GetValueForKeyAsString(\"type\", type_name))\n    return false;\n\n  // Check if there's a plugin registered for this type name.\n  auto find_it = m_structured_data_plugin_map.find(type_name);\n  if (find_it == m_structured_data_plugin_map.end()) {\n    // We don't have a mapping for this structured data type.\n    return false;\n  }\n\n  // Route the structured data to the plugin.\n  find_it->second->HandleArrivalOfStructuredData(*this, type_name, object_sp);\n  return true;\n}\n\nStatus Process::UpdateAutomaticSignalFiltering() {\n  // Default implementation does nothign.\n  // No automatic signal filtering to speak of.\n  return Status();\n}\n\nUtilityFunction *Process::GetLoadImageUtilityFunction(\n    Platform *platform,\n    llvm::function_ref<std::unique_ptr<UtilityFunction>()> factory) {\n  if (platform != GetTarget().GetPlatform().get())\n    return nullptr;\n  llvm::call_once(m_dlopen_utility_func_flag_once,\n                  [&] { m_dlopen_utility_func_up = factory(); });\n  return m_dlopen_utility_func_up.get();\n}\n\nllvm::Expected<TraceSupportedResponse> Process::TraceSupported() {\n  if (!IsLiveDebugSession())\n    return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                   \"Can't trace a non-live process.\");\n  return llvm::make_error<UnimplementedError>();\n}\n\nbool Process::CallVoidArgVoidPtrReturn(const Address *address,\n                                       addr_t &returned_func,\n                                       bool trap_exceptions) {\n  Thread *thread = GetThreadList().GetExpressionExecutionThread().get();\n  if (thread == nullptr || address == nullptr)\n    return false;\n\n  EvaluateExpressionOptions options;\n  options.SetStopOthers(true);\n  options.SetUnwindOnError(true);\n  options.SetIgnoreBreakpoints(true);\n  options.SetTryAllThreads(true);\n  options.SetDebug(false);\n  options.SetTimeout(GetUtilityExpressionTimeout());\n  options.SetTrapExceptions(trap_exceptions);\n\n  auto type_system_or_err =\n      GetTarget().GetScratchTypeSystemForLanguage(eLanguageTypeC);\n  if (!type_system_or_err) {\n    llvm::consumeError(type_system_or_err.takeError());\n    return false;\n  }\n  CompilerType void_ptr_type =\n      type_system_or_err->GetBasicTypeFromAST(eBasicTypeVoid).GetPointerType();\n  lldb::ThreadPlanSP call_plan_sp(new ThreadPlanCallFunction(\n      *thread, *address, void_ptr_type, llvm::ArrayRef<addr_t>(), options));\n  if (call_plan_sp) {\n    DiagnosticManager diagnostics;\n\n    StackFrame *frame = thread->GetStackFrameAtIndex(0).get();\n    if (frame) {\n      ExecutionContext exe_ctx;\n      frame->CalculateExecutionContext(exe_ctx);\n      ExpressionResults result =\n          RunThreadPlan(exe_ctx, call_plan_sp, options, diagnostics);\n      if (result == eExpressionCompleted) {\n        returned_func =\n            call_plan_sp->GetReturnValueObject()->GetValueAsUnsigned(\n                LLDB_INVALID_ADDRESS);\n\n        if (GetAddressByteSize() == 4) {\n          if (returned_func == UINT32_MAX)\n            return false;\n        } else if (GetAddressByteSize() == 8) {\n          if (returned_func == UINT64_MAX)\n            return false;\n        }\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 6, "line": 112}, "message": "'TargetProperties.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Target/Process.cpp", "reportHash": "28d61e6cfe40e9b64ded77b0645a713e", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
