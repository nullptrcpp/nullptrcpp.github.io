<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp", "content": "//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements routines for folding instructions into simpler forms\n// that do not require creating new instructions.  This does constant folding\n// (\"add i32 1, 1\" -> \"2\") but can also handle non-constant operands, either\n// returning a constant (\"and i32 %x, 0\" -> \"0\") or an already existing value\n// (\"and i32 %x, %x\" -> \"%x\").  All operands are assumed to have already been\n// simplified: This is usually true and assuming it simplifies the logic (if\n// they have not been simplified then results are correct but maybe suboptimal).\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/CaptureTracking.h\"\n#include \"llvm/Analysis/CmpInstAnalysis.h\"\n#include \"llvm/Analysis/ConstantFolding.h\"\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/Analysis/MemoryBuiltins.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/Analysis/VectorUtils.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/GetElementPtrTypeIterator.h\"\n#include \"llvm/IR/GlobalAlias.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include <algorithm>\nusing namespace llvm;\nusing namespace llvm::PatternMatch;\n\n#define DEBUG_TYPE \"instsimplify\"\n\nenum { RecursionLimit = 3 };\n\nSTATISTIC(NumExpand,  \"Number of expansions\");\nSTATISTIC(NumReassoc, \"Number of reassociations\");\n\nstatic Value *SimplifyAndInst(Value *, Value *, const SimplifyQuery &, unsigned);\nstatic Value *simplifyUnOp(unsigned, Value *, const SimplifyQuery &, unsigned);\nstatic Value *simplifyFPUnOp(unsigned, Value *, const FastMathFlags &,\n                             const SimplifyQuery &, unsigned);\nstatic Value *SimplifyBinOp(unsigned, Value *, Value *, const SimplifyQuery &,\n                            unsigned);\nstatic Value *SimplifyBinOp(unsigned, Value *, Value *, const FastMathFlags &,\n                            const SimplifyQuery &, unsigned);\nstatic Value *SimplifyCmpInst(unsigned, Value *, Value *, const SimplifyQuery &,\n                              unsigned);\nstatic Value *SimplifyICmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                               const SimplifyQuery &Q, unsigned MaxRecurse);\nstatic Value *SimplifyOrInst(Value *, Value *, const SimplifyQuery &, unsigned);\nstatic Value *SimplifyXorInst(Value *, Value *, const SimplifyQuery &, unsigned);\nstatic Value *SimplifyCastInst(unsigned, Value *, Type *,\n                               const SimplifyQuery &, unsigned);\nstatic Value *SimplifyGEPInst(Type *, ArrayRef<Value *>, const SimplifyQuery &,\n                              unsigned);\n\nstatic Value *foldSelectWithBinaryOp(Value *Cond, Value *TrueVal,\n                                     Value *FalseVal) {\n  BinaryOperator::BinaryOps BinOpCode;\n  if (auto *BO = dyn_cast<BinaryOperator>(Cond))\n    BinOpCode = BO->getOpcode();\n  else\n    return nullptr;\n\n  CmpInst::Predicate ExpectedPred, Pred1, Pred2;\n  if (BinOpCode == BinaryOperator::Or) {\n    ExpectedPred = ICmpInst::ICMP_NE;\n  } else if (BinOpCode == BinaryOperator::And) {\n    ExpectedPred = ICmpInst::ICMP_EQ;\n  } else\n    return nullptr;\n\n  // %A = icmp eq %TV, %FV\n  // %B = icmp eq %X, %Y (and one of these is a select operand)\n  // %C = and %A, %B\n  // %D = select %C, %TV, %FV\n  // -->\n  // %FV\n\n  // %A = icmp ne %TV, %FV\n  // %B = icmp ne %X, %Y (and one of these is a select operand)\n  // %C = or %A, %B\n  // %D = select %C, %TV, %FV\n  // -->\n  // %TV\n  Value *X, *Y;\n  if (!match(Cond, m_c_BinOp(m_c_ICmp(Pred1, m_Specific(TrueVal),\n                                      m_Specific(FalseVal)),\n                             m_ICmp(Pred2, m_Value(X), m_Value(Y)))) ||\n      Pred1 != Pred2 || Pred1 != ExpectedPred)\n    return nullptr;\n\n  if (X == TrueVal || X == FalseVal || Y == TrueVal || Y == FalseVal)\n    return BinOpCode == BinaryOperator::Or ? TrueVal : FalseVal;\n\n  return nullptr;\n}\n\n/// For a boolean type or a vector of boolean type, return false or a vector\n/// with every element false.\nstatic Constant *getFalse(Type *Ty) {\n  return ConstantInt::getFalse(Ty);\n}\n\n/// For a boolean type or a vector of boolean type, return true or a vector\n/// with every element true.\nstatic Constant *getTrue(Type *Ty) {\n  return ConstantInt::getTrue(Ty);\n}\n\n/// isSameCompare - Is V equivalent to the comparison \"LHS Pred RHS\"?\nstatic bool isSameCompare(Value *V, CmpInst::Predicate Pred, Value *LHS,\n                          Value *RHS) {\n  CmpInst *Cmp = dyn_cast<CmpInst>(V);\n  if (!Cmp)\n    return false;\n  CmpInst::Predicate CPred = Cmp->getPredicate();\n  Value *CLHS = Cmp->getOperand(0), *CRHS = Cmp->getOperand(1);\n  if (CPred == Pred && CLHS == LHS && CRHS == RHS)\n    return true;\n  return CPred == CmpInst::getSwappedPredicate(Pred) && CLHS == RHS &&\n    CRHS == LHS;\n}\n\n/// Simplify comparison with true or false branch of select:\n///  %sel = select i1 %cond, i32 %tv, i32 %fv\n///  %cmp = icmp sle i32 %sel, %rhs\n/// Compose new comparison by substituting %sel with either %tv or %fv\n/// and see if it simplifies.\nstatic Value *simplifyCmpSelCase(CmpInst::Predicate Pred, Value *LHS,\n                                 Value *RHS, Value *Cond,\n                                 const SimplifyQuery &Q, unsigned MaxRecurse,\n                                 Constant *TrueOrFalse) {\n  Value *SimplifiedCmp = SimplifyCmpInst(Pred, LHS, RHS, Q, MaxRecurse);\n  if (SimplifiedCmp == Cond) {\n    // %cmp simplified to the select condition (%cond).\n    return TrueOrFalse;\n  } else if (!SimplifiedCmp && isSameCompare(Cond, Pred, LHS, RHS)) {\n    // It didn't simplify. However, if composed comparison is equivalent\n    // to the select condition (%cond) then we can replace it.\n    return TrueOrFalse;\n  }\n  return SimplifiedCmp;\n}\n\n/// Simplify comparison with true branch of select\nstatic Value *simplifyCmpSelTrueCase(CmpInst::Predicate Pred, Value *LHS,\n                                     Value *RHS, Value *Cond,\n                                     const SimplifyQuery &Q,\n                                     unsigned MaxRecurse) {\n  return simplifyCmpSelCase(Pred, LHS, RHS, Cond, Q, MaxRecurse,\n                            getTrue(Cond->getType()));\n}\n\n/// Simplify comparison with false branch of select\nstatic Value *simplifyCmpSelFalseCase(CmpInst::Predicate Pred, Value *LHS,\n                                      Value *RHS, Value *Cond,\n                                      const SimplifyQuery &Q,\n                                      unsigned MaxRecurse) {\n  return simplifyCmpSelCase(Pred, LHS, RHS, Cond, Q, MaxRecurse,\n                            getFalse(Cond->getType()));\n}\n\n/// We know comparison with both branches of select can be simplified, but they\n/// are not equal. This routine handles some logical simplifications.\nstatic Value *handleOtherCmpSelSimplifications(Value *TCmp, Value *FCmp,\n                                               Value *Cond,\n                                               const SimplifyQuery &Q,\n                                               unsigned MaxRecurse) {\n  // If the false value simplified to false, then the result of the compare\n  // is equal to \"Cond && TCmp\".  This also catches the case when the false\n  // value simplified to false and the true value to true, returning \"Cond\".\n  if (match(FCmp, m_Zero()))\n    if (Value *V = SimplifyAndInst(Cond, TCmp, Q, MaxRecurse))\n      return V;\n  // If the true value simplified to true, then the result of the compare\n  // is equal to \"Cond || FCmp\".\n  if (match(TCmp, m_One()))\n    if (Value *V = SimplifyOrInst(Cond, FCmp, Q, MaxRecurse))\n      return V;\n  // Finally, if the false value simplified to true and the true value to\n  // false, then the result of the compare is equal to \"!Cond\".\n  if (match(FCmp, m_One()) && match(TCmp, m_Zero()))\n    if (Value *V = SimplifyXorInst(\n            Cond, Constant::getAllOnesValue(Cond->getType()), Q, MaxRecurse))\n      return V;\n  return nullptr;\n}\n\n/// Does the given value dominate the specified phi node?\nstatic bool valueDominatesPHI(Value *V, PHINode *P, const DominatorTree *DT) {\n  Instruction *I = dyn_cast<Instruction>(V);\n  if (!I)\n    // Arguments and constants dominate all instructions.\n    return true;\n\n  // If we are processing instructions (and/or basic blocks) that have not been\n  // fully added to a function, the parent nodes may still be null. Simply\n  // return the conservative answer in these cases.\n  if (!I->getParent() || !P->getParent() || !I->getFunction())\n    return false;\n\n  // If we have a DominatorTree then do a precise test.\n  if (DT)\n    return DT->dominates(I, P);\n\n  // Otherwise, if the instruction is in the entry block and is not an invoke,\n  // then it obviously dominates all phi nodes.\n  if (I->getParent() == &I->getFunction()->getEntryBlock() &&\n      !isa<InvokeInst>(I) && !isa<CallBrInst>(I))\n    return true;\n\n  return false;\n}\n\n/// Try to simplify a binary operator of form \"V op OtherOp\" where V is\n/// \"(B0 opex B1)\" by distributing 'op' across 'opex' as\n/// \"(B0 op OtherOp) opex (B1 op OtherOp)\".\nstatic Value *expandBinOp(Instruction::BinaryOps Opcode, Value *V,\n                          Value *OtherOp, Instruction::BinaryOps OpcodeToExpand,\n                          const SimplifyQuery &Q, unsigned MaxRecurse) {\n  auto *B = dyn_cast<BinaryOperator>(V);\n  if (!B || B->getOpcode() != OpcodeToExpand)\n    return nullptr;\n  Value *B0 = B->getOperand(0), *B1 = B->getOperand(1);\n  Value *L = SimplifyBinOp(Opcode, B0, OtherOp, Q.getWithoutUndef(),\n                           MaxRecurse);\n  if (!L)\n    return nullptr;\n  Value *R = SimplifyBinOp(Opcode, B1, OtherOp, Q.getWithoutUndef(),\n                           MaxRecurse);\n  if (!R)\n    return nullptr;\n\n  // Does the expanded pair of binops simplify to the existing binop?\n  if ((L == B0 && R == B1) ||\n      (Instruction::isCommutative(OpcodeToExpand) && L == B1 && R == B0)) {\n    ++NumExpand;\n    return B;\n  }\n\n  // Otherwise, return \"L op' R\" if it simplifies.\n  Value *S = SimplifyBinOp(OpcodeToExpand, L, R, Q, MaxRecurse);\n  if (!S)\n    return nullptr;\n\n  ++NumExpand;\n  return S;\n}\n\n/// Try to simplify binops of form \"A op (B op' C)\" or the commuted variant by\n/// distributing op over op'.\nstatic Value *expandCommutativeBinOp(Instruction::BinaryOps Opcode,\n                                     Value *L, Value *R,\n                                     Instruction::BinaryOps OpcodeToExpand,\n                                     const SimplifyQuery &Q,\n                                     unsigned MaxRecurse) {\n  // Recursion is always used, so bail out at once if we already hit the limit.\n  if (!MaxRecurse--)\n    return nullptr;\n\n  if (Value *V = expandBinOp(Opcode, L, R, OpcodeToExpand, Q, MaxRecurse))\n    return V;\n  if (Value *V = expandBinOp(Opcode, R, L, OpcodeToExpand, Q, MaxRecurse))\n    return V;\n  return nullptr;\n}\n\n/// Generic simplifications for associative binary operations.\n/// Returns the simpler value, or null if none was found.\nstatic Value *SimplifyAssociativeBinOp(Instruction::BinaryOps Opcode,\n                                       Value *LHS, Value *RHS,\n                                       const SimplifyQuery &Q,\n                                       unsigned MaxRecurse) {\n  assert(Instruction::isAssociative(Opcode) && \"Not an associative operation!\");\n\n  // Recursion is always used, so bail out at once if we already hit the limit.\n  if (!MaxRecurse--)\n    return nullptr;\n\n  BinaryOperator *Op0 = dyn_cast<BinaryOperator>(LHS);\n  BinaryOperator *Op1 = dyn_cast<BinaryOperator>(RHS);\n\n  // Transform: \"(A op B) op C\" ==> \"A op (B op C)\" if it simplifies completely.\n  if (Op0 && Op0->getOpcode() == Opcode) {\n    Value *A = Op0->getOperand(0);\n    Value *B = Op0->getOperand(1);\n    Value *C = RHS;\n\n    // Does \"B op C\" simplify?\n    if (Value *V = SimplifyBinOp(Opcode, B, C, Q, MaxRecurse)) {\n      // It does!  Return \"A op V\" if it simplifies or is already available.\n      // If V equals B then \"A op V\" is just the LHS.\n      if (V == B) return LHS;\n      // Otherwise return \"A op V\" if it simplifies.\n      if (Value *W = SimplifyBinOp(Opcode, A, V, Q, MaxRecurse)) {\n        ++NumReassoc;\n        return W;\n      }\n    }\n  }\n\n  // Transform: \"A op (B op C)\" ==> \"(A op B) op C\" if it simplifies completely.\n  if (Op1 && Op1->getOpcode() == Opcode) {\n    Value *A = LHS;\n    Value *B = Op1->getOperand(0);\n    Value *C = Op1->getOperand(1);\n\n    // Does \"A op B\" simplify?\n    if (Value *V = SimplifyBinOp(Opcode, A, B, Q, MaxRecurse)) {\n      // It does!  Return \"V op C\" if it simplifies or is already available.\n      // If V equals B then \"V op C\" is just the RHS.\n      if (V == B) return RHS;\n      // Otherwise return \"V op C\" if it simplifies.\n      if (Value *W = SimplifyBinOp(Opcode, V, C, Q, MaxRecurse)) {\n        ++NumReassoc;\n        return W;\n      }\n    }\n  }\n\n  // The remaining transforms require commutativity as well as associativity.\n  if (!Instruction::isCommutative(Opcode))\n    return nullptr;\n\n  // Transform: \"(A op B) op C\" ==> \"(C op A) op B\" if it simplifies completely.\n  if (Op0 && Op0->getOpcode() == Opcode) {\n    Value *A = Op0->getOperand(0);\n    Value *B = Op0->getOperand(1);\n    Value *C = RHS;\n\n    // Does \"C op A\" simplify?\n    if (Value *V = SimplifyBinOp(Opcode, C, A, Q, MaxRecurse)) {\n      // It does!  Return \"V op B\" if it simplifies or is already available.\n      // If V equals A then \"V op B\" is just the LHS.\n      if (V == A) return LHS;\n      // Otherwise return \"V op B\" if it simplifies.\n      if (Value *W = SimplifyBinOp(Opcode, V, B, Q, MaxRecurse)) {\n        ++NumReassoc;\n        return W;\n      }\n    }\n  }\n\n  // Transform: \"A op (B op C)\" ==> \"B op (C op A)\" if it simplifies completely.\n  if (Op1 && Op1->getOpcode() == Opcode) {\n    Value *A = LHS;\n    Value *B = Op1->getOperand(0);\n    Value *C = Op1->getOperand(1);\n\n    // Does \"C op A\" simplify?\n    if (Value *V = SimplifyBinOp(Opcode, C, A, Q, MaxRecurse)) {\n      // It does!  Return \"B op V\" if it simplifies or is already available.\n      // If V equals C then \"B op V\" is just the RHS.\n      if (V == C) return RHS;\n      // Otherwise return \"B op V\" if it simplifies.\n      if (Value *W = SimplifyBinOp(Opcode, B, V, Q, MaxRecurse)) {\n        ++NumReassoc;\n        return W;\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n/// In the case of a binary operation with a select instruction as an operand,\n/// try to simplify the binop by seeing whether evaluating it on both branches\n/// of the select results in the same value. Returns the common value if so,\n/// otherwise returns null.\nstatic Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,\n                                    Value *RHS, const SimplifyQuery &Q,\n                                    unsigned MaxRecurse) {\n  // Recursion is always used, so bail out at once if we already hit the limit.\n  if (!MaxRecurse--)\n    return nullptr;\n\n  SelectInst *SI;\n  if (isa<SelectInst>(LHS)) {\n    SI = cast<SelectInst>(LHS);\n  } else {\n    assert(isa<SelectInst>(RHS) && \"No select instruction operand!\");\n    SI = cast<SelectInst>(RHS);\n  }\n\n  // Evaluate the BinOp on the true and false branches of the select.\n  Value *TV;\n  Value *FV;\n  if (SI == LHS) {\n    TV = SimplifyBinOp(Opcode, SI->getTrueValue(), RHS, Q, MaxRecurse);\n    FV = SimplifyBinOp(Opcode, SI->getFalseValue(), RHS, Q, MaxRecurse);\n  } else {\n    TV = SimplifyBinOp(Opcode, LHS, SI->getTrueValue(), Q, MaxRecurse);\n    FV = SimplifyBinOp(Opcode, LHS, SI->getFalseValue(), Q, MaxRecurse);\n  }\n\n  // If they simplified to the same value, then return the common value.\n  // If they both failed to simplify then return null.\n  if (TV == FV)\n    return TV;\n\n  // If one branch simplified to undef, return the other one.\n  if (TV && Q.isUndefValue(TV))\n    return FV;\n  if (FV && Q.isUndefValue(FV))\n    return TV;\n\n  // If applying the operation did not change the true and false select values,\n  // then the result of the binop is the select itself.\n  if (TV == SI->getTrueValue() && FV == SI->getFalseValue())\n    return SI;\n\n  // If one branch simplified and the other did not, and the simplified\n  // value is equal to the unsimplified one, return the simplified value.\n  // For example, select (cond, X, X & Z) & Z -> X & Z.\n  if ((FV && !TV) || (TV && !FV)) {\n    // Check that the simplified value has the form \"X op Y\" where \"op\" is the\n    // same as the original operation.\n    Instruction *Simplified = dyn_cast<Instruction>(FV ? FV : TV);\n    if (Simplified && Simplified->getOpcode() == unsigned(Opcode)) {\n      // The value that didn't simplify is \"UnsimplifiedLHS op UnsimplifiedRHS\".\n      // We already know that \"op\" is the same as for the simplified value.  See\n      // if the operands match too.  If so, return the simplified value.\n      Value *UnsimplifiedBranch = FV ? SI->getTrueValue() : SI->getFalseValue();\n      Value *UnsimplifiedLHS = SI == LHS ? UnsimplifiedBranch : LHS;\n      Value *UnsimplifiedRHS = SI == LHS ? RHS : UnsimplifiedBranch;\n      if (Simplified->getOperand(0) == UnsimplifiedLHS &&\n          Simplified->getOperand(1) == UnsimplifiedRHS)\n        return Simplified;\n      if (Simplified->isCommutative() &&\n          Simplified->getOperand(1) == UnsimplifiedLHS &&\n          Simplified->getOperand(0) == UnsimplifiedRHS)\n        return Simplified;\n    }\n  }\n\n  return nullptr;\n}\n\n/// In the case of a comparison with a select instruction, try to simplify the\n/// comparison by seeing whether both branches of the select result in the same\n/// value. Returns the common value if so, otherwise returns null.\n/// For example, if we have:\n///  %tmp = select i1 %cmp, i32 1, i32 2\n///  %cmp1 = icmp sle i32 %tmp, 3\n/// We can simplify %cmp1 to true, because both branches of select are\n/// less than 3. We compose new comparison by substituting %tmp with both\n/// branches of select and see if it can be simplified.\nstatic Value *ThreadCmpOverSelect(CmpInst::Predicate Pred, Value *LHS,\n                                  Value *RHS, const SimplifyQuery &Q,\n                                  unsigned MaxRecurse) {\n  // Recursion is always used, so bail out at once if we already hit the limit.\n  if (!MaxRecurse--)\n    return nullptr;\n\n  // Make sure the select is on the LHS.\n  if (!isa<SelectInst>(LHS)) {\n    std::swap(LHS, RHS);\n    Pred = CmpInst::getSwappedPredicate(Pred);\n  }\n  assert(isa<SelectInst>(LHS) && \"Not comparing with a select instruction!\");\n  SelectInst *SI = cast<SelectInst>(LHS);\n  Value *Cond = SI->getCondition();\n  Value *TV = SI->getTrueValue();\n  Value *FV = SI->getFalseValue();\n\n  // Now that we have \"cmp select(Cond, TV, FV), RHS\", analyse it.\n  // Does \"cmp TV, RHS\" simplify?\n  Value *TCmp = simplifyCmpSelTrueCase(Pred, TV, RHS, Cond, Q, MaxRecurse);\n  if (!TCmp)\n    return nullptr;\n\n  // Does \"cmp FV, RHS\" simplify?\n  Value *FCmp = simplifyCmpSelFalseCase(Pred, FV, RHS, Cond, Q, MaxRecurse);\n  if (!FCmp)\n    return nullptr;\n\n  // If both sides simplified to the same value, then use it as the result of\n  // the original comparison.\n  if (TCmp == FCmp)\n    return TCmp;\n\n  // The remaining cases only make sense if the select condition has the same\n  // type as the result of the comparison, so bail out if this is not so.\n  if (Cond->getType()->isVectorTy() == RHS->getType()->isVectorTy())\n    return handleOtherCmpSelSimplifications(TCmp, FCmp, Cond, Q, MaxRecurse);\n\n  return nullptr;\n}\n\n/// In the case of a binary operation with an operand that is a PHI instruction,\n/// try to simplify the binop by seeing whether evaluating it on the incoming\n/// phi values yields the same result for every value. If so returns the common\n/// value, otherwise returns null.\nstatic Value *ThreadBinOpOverPHI(Instruction::BinaryOps Opcode, Value *LHS,\n                                 Value *RHS, const SimplifyQuery &Q,\n                                 unsigned MaxRecurse) {\n  // Recursion is always used, so bail out at once if we already hit the limit.\n  if (!MaxRecurse--)\n    return nullptr;\n\n  PHINode *PI;\n  if (isa<PHINode>(LHS)) {\n    PI = cast<PHINode>(LHS);\n    // Bail out if RHS and the phi may be mutually interdependent due to a loop.\n    if (!valueDominatesPHI(RHS, PI, Q.DT))\n      return nullptr;\n  } else {\n    assert(isa<PHINode>(RHS) && \"No PHI instruction operand!\");\n    PI = cast<PHINode>(RHS);\n    // Bail out if LHS and the phi may be mutually interdependent due to a loop.\n    if (!valueDominatesPHI(LHS, PI, Q.DT))\n      return nullptr;\n  }\n\n  // Evaluate the BinOp on the incoming phi values.\n  Value *CommonValue = nullptr;\n  for (Value *Incoming : PI->incoming_values()) {\n    // If the incoming value is the phi node itself, it can safely be skipped.\n    if (Incoming == PI) continue;\n    Value *V = PI == LHS ?\n      SimplifyBinOp(Opcode, Incoming, RHS, Q, MaxRecurse) :\n      SimplifyBinOp(Opcode, LHS, Incoming, Q, MaxRecurse);\n    // If the operation failed to simplify, or simplified to a different value\n    // to previously, then give up.\n    if (!V || (CommonValue && V != CommonValue))\n      return nullptr;\n    CommonValue = V;\n  }\n\n  return CommonValue;\n}\n\n/// In the case of a comparison with a PHI instruction, try to simplify the\n/// comparison by seeing whether comparing with all of the incoming phi values\n/// yields the same result every time. If so returns the common result,\n/// otherwise returns null.\nstatic Value *ThreadCmpOverPHI(CmpInst::Predicate Pred, Value *LHS, Value *RHS,\n                               const SimplifyQuery &Q, unsigned MaxRecurse) {\n  // Recursion is always used, so bail out at once if we already hit the limit.\n  if (!MaxRecurse--)\n    return nullptr;\n\n  // Make sure the phi is on the LHS.\n  if (!isa<PHINode>(LHS)) {\n    std::swap(LHS, RHS);\n    Pred = CmpInst::getSwappedPredicate(Pred);\n  }\n  assert(isa<PHINode>(LHS) && \"Not comparing with a phi instruction!\");\n  PHINode *PI = cast<PHINode>(LHS);\n\n  // Bail out if RHS and the phi may be mutually interdependent due to a loop.\n  if (!valueDominatesPHI(RHS, PI, Q.DT))\n    return nullptr;\n\n  // Evaluate the BinOp on the incoming phi values.\n  Value *CommonValue = nullptr;\n  for (unsigned u = 0, e = PI->getNumIncomingValues(); u < e; ++u) {\n    Value *Incoming = PI->getIncomingValue(u);\n    Instruction *InTI = PI->getIncomingBlock(u)->getTerminator();\n    // If the incoming value is the phi node itself, it can safely be skipped.\n    if (Incoming == PI) continue;\n    // Change the context instruction to the \"edge\" that flows into the phi.\n    // This is important because that is where incoming is actually \"evaluated\"\n    // even though it is used later somewhere else.\n    Value *V = SimplifyCmpInst(Pred, Incoming, RHS, Q.getWithInstruction(InTI),\n                               MaxRecurse);\n    // If the operation failed to simplify, or simplified to a different value\n    // to previously, then give up.\n    if (!V || (CommonValue && V != CommonValue))\n      return nullptr;\n    CommonValue = V;\n  }\n\n  return CommonValue;\n}\n\nstatic Constant *foldOrCommuteConstant(Instruction::BinaryOps Opcode,\n                                       Value *&Op0, Value *&Op1,\n                                       const SimplifyQuery &Q) {\n  if (auto *CLHS = dyn_cast<Constant>(Op0)) {\n    if (auto *CRHS = dyn_cast<Constant>(Op1))\n      return ConstantFoldBinaryOpOperands(Opcode, CLHS, CRHS, Q.DL);\n\n    // Canonicalize the constant to the RHS if this is a commutative operation.\n    if (Instruction::isCommutative(Opcode))\n      std::swap(Op0, Op1);\n  }\n  return nullptr;\n}\n\n/// Given operands for an Add, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyAddInst(Value *Op0, Value *Op1, bool IsNSW, bool IsNUW,\n                              const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::Add, Op0, Op1, Q))\n    return C;\n\n  // X + undef -> undef\n  if (Q.isUndefValue(Op1))\n    return Op1;\n\n  // X + 0 -> X\n  if (match(Op1, m_Zero()))\n    return Op0;\n\n  // If two operands are negative, return 0.\n  if (isKnownNegation(Op0, Op1))\n    return Constant::getNullValue(Op0->getType());\n\n  // X + (Y - X) -> Y\n  // (Y - X) + X -> Y\n  // Eg: X + -X -> 0\n  Value *Y = nullptr;\n  if (match(Op1, m_Sub(m_Value(Y), m_Specific(Op0))) ||\n      match(Op0, m_Sub(m_Value(Y), m_Specific(Op1))))\n    return Y;\n\n  // X + ~X -> -1   since   ~X = -X-1\n  Type *Ty = Op0->getType();\n  if (match(Op0, m_Not(m_Specific(Op1))) ||\n      match(Op1, m_Not(m_Specific(Op0))))\n    return Constant::getAllOnesValue(Ty);\n\n  // add nsw/nuw (xor Y, signmask), signmask --> Y\n  // The no-wrapping add guarantees that the top bit will be set by the add.\n  // Therefore, the xor must be clearing the already set sign bit of Y.\n  if ((IsNSW || IsNUW) && match(Op1, m_SignMask()) &&\n      match(Op0, m_Xor(m_Value(Y), m_SignMask())))\n    return Y;\n\n  // add nuw %x, -1  ->  -1, because %x can only be 0.\n  if (IsNUW && match(Op1, m_AllOnes()))\n    return Op1; // Which is -1.\n\n  /// i1 add -> xor.\n  if (MaxRecurse && Op0->getType()->isIntOrIntVectorTy(1))\n    if (Value *V = SimplifyXorInst(Op0, Op1, Q, MaxRecurse-1))\n      return V;\n\n  // Try some generic simplifications for associative operations.\n  if (Value *V = SimplifyAssociativeBinOp(Instruction::Add, Op0, Op1, Q,\n                                          MaxRecurse))\n    return V;\n\n  // Threading Add over selects and phi nodes is pointless, so don't bother.\n  // Threading over the select in \"A + select(cond, B, C)\" means evaluating\n  // \"A+B\" and \"A+C\" and seeing if they are equal; but they are equal if and\n  // only if B and C are equal.  If B and C are equal then (since we assume\n  // that operands have already been simplified) \"select(cond, B, C)\" should\n  // have been simplified to the common value of B and C already.  Analysing\n  // \"A+B\" and \"A+C\" thus gains nothing, but costs compile time.  Similarly\n  // for threading over phi nodes.\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyAddInst(Value *Op0, Value *Op1, bool IsNSW, bool IsNUW,\n                             const SimplifyQuery &Query) {\n  return ::SimplifyAddInst(Op0, Op1, IsNSW, IsNUW, Query, RecursionLimit);\n}\n\n/// Compute the base pointer and cumulative constant offsets for V.\n///\n/// This strips all constant offsets off of V, leaving it the base pointer, and\n/// accumulates the total constant offset applied in the returned constant. It\n/// returns 0 if V is not a pointer, and returns the constant '0' if there are\n/// no constant offsets applied.\n///\n/// This is very similar to GetPointerBaseWithConstantOffset except it doesn't\n/// follow non-inbounds geps. This allows it to remain usable for icmp ult/etc.\n/// folding.\nstatic Constant *stripAndComputeConstantOffsets(const DataLayout &DL, Value *&V,\n                                                bool AllowNonInbounds = false) {\n  assert(V->getType()->isPtrOrPtrVectorTy());\n\n  Type *IntIdxTy = DL.getIndexType(V->getType())->getScalarType();\n  APInt Offset = APInt::getNullValue(IntIdxTy->getIntegerBitWidth());\n\n  V = V->stripAndAccumulateConstantOffsets(DL, Offset, AllowNonInbounds);\n  // As that strip may trace through `addrspacecast`, need to sext or trunc\n  // the offset calculated.\n  IntIdxTy = DL.getIndexType(V->getType())->getScalarType();\n  Offset = Offset.sextOrTrunc(IntIdxTy->getIntegerBitWidth());\n\n  Constant *OffsetIntPtr = ConstantInt::get(IntIdxTy, Offset);\n  if (VectorType *VecTy = dyn_cast<VectorType>(V->getType()))\n    return ConstantVector::getSplat(VecTy->getElementCount(), OffsetIntPtr);\n  return OffsetIntPtr;\n}\n\n/// Compute the constant difference between two pointer values.\n/// If the difference is not a constant, returns zero.\nstatic Constant *computePointerDifference(const DataLayout &DL, Value *LHS,\n                                          Value *RHS) {\n  Constant *LHSOffset = stripAndComputeConstantOffsets(DL, LHS);\n  Constant *RHSOffset = stripAndComputeConstantOffsets(DL, RHS);\n\n  // If LHS and RHS are not related via constant offsets to the same base\n  // value, there is nothing we can do here.\n  if (LHS != RHS)\n    return nullptr;\n\n  // Otherwise, the difference of LHS - RHS can be computed as:\n  //    LHS - RHS\n  //  = (LHSOffset + Base) - (RHSOffset + Base)\n  //  = LHSOffset - RHSOffset\n  return ConstantExpr::getSub(LHSOffset, RHSOffset);\n}\n\n/// Given operands for a Sub, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifySubInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,\n                              const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::Sub, Op0, Op1, Q))\n    return C;\n\n  // X - undef -> undef\n  // undef - X -> undef\n  if (Q.isUndefValue(Op0) || Q.isUndefValue(Op1))\n    return UndefValue::get(Op0->getType());\n\n  // X - 0 -> X\n  if (match(Op1, m_Zero()))\n    return Op0;\n\n  // X - X -> 0\n  if (Op0 == Op1)\n    return Constant::getNullValue(Op0->getType());\n\n  // Is this a negation?\n  if (match(Op0, m_Zero())) {\n    // 0 - X -> 0 if the sub is NUW.\n    if (isNUW)\n      return Constant::getNullValue(Op0->getType());\n\n    KnownBits Known = computeKnownBits(Op1, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n    if (Known.Zero.isMaxSignedValue()) {\n      // Op1 is either 0 or the minimum signed value. If the sub is NSW, then\n      // Op1 must be 0 because negating the minimum signed value is undefined.\n      if (isNSW)\n        return Constant::getNullValue(Op0->getType());\n\n      // 0 - X -> X if X is 0 or the minimum signed value.\n      return Op1;\n    }\n  }\n\n  // (X + Y) - Z -> X + (Y - Z) or Y + (X - Z) if everything simplifies.\n  // For example, (X + Y) - Y -> X; (Y + X) - Y -> X\n  Value *X = nullptr, *Y = nullptr, *Z = Op1;\n  if (MaxRecurse && match(Op0, m_Add(m_Value(X), m_Value(Y)))) { // (X + Y) - Z\n    // See if \"V === Y - Z\" simplifies.\n    if (Value *V = SimplifyBinOp(Instruction::Sub, Y, Z, Q, MaxRecurse-1))\n      // It does!  Now see if \"X + V\" simplifies.\n      if (Value *W = SimplifyBinOp(Instruction::Add, X, V, Q, MaxRecurse-1)) {\n        // It does, we successfully reassociated!\n        ++NumReassoc;\n        return W;\n      }\n    // See if \"V === X - Z\" simplifies.\n    if (Value *V = SimplifyBinOp(Instruction::Sub, X, Z, Q, MaxRecurse-1))\n      // It does!  Now see if \"Y + V\" simplifies.\n      if (Value *W = SimplifyBinOp(Instruction::Add, Y, V, Q, MaxRecurse-1)) {\n        // It does, we successfully reassociated!\n        ++NumReassoc;\n        return W;\n      }\n  }\n\n  // X - (Y + Z) -> (X - Y) - Z or (X - Z) - Y if everything simplifies.\n  // For example, X - (X + 1) -> -1\n  X = Op0;\n  if (MaxRecurse && match(Op1, m_Add(m_Value(Y), m_Value(Z)))) { // X - (Y + Z)\n    // See if \"V === X - Y\" simplifies.\n    if (Value *V = SimplifyBinOp(Instruction::Sub, X, Y, Q, MaxRecurse-1))\n      // It does!  Now see if \"V - Z\" simplifies.\n      if (Value *W = SimplifyBinOp(Instruction::Sub, V, Z, Q, MaxRecurse-1)) {\n        // It does, we successfully reassociated!\n        ++NumReassoc;\n        return W;\n      }\n    // See if \"V === X - Z\" simplifies.\n    if (Value *V = SimplifyBinOp(Instruction::Sub, X, Z, Q, MaxRecurse-1))\n      // It does!  Now see if \"V - Y\" simplifies.\n      if (Value *W = SimplifyBinOp(Instruction::Sub, V, Y, Q, MaxRecurse-1)) {\n        // It does, we successfully reassociated!\n        ++NumReassoc;\n        return W;\n      }\n  }\n\n  // Z - (X - Y) -> (Z - X) + Y if everything simplifies.\n  // For example, X - (X - Y) -> Y.\n  Z = Op0;\n  if (MaxRecurse && match(Op1, m_Sub(m_Value(X), m_Value(Y)))) // Z - (X - Y)\n    // See if \"V === Z - X\" simplifies.\n    if (Value *V = SimplifyBinOp(Instruction::Sub, Z, X, Q, MaxRecurse-1))\n      // It does!  Now see if \"V + Y\" simplifies.\n      if (Value *W = SimplifyBinOp(Instruction::Add, V, Y, Q, MaxRecurse-1)) {\n        // It does, we successfully reassociated!\n        ++NumReassoc;\n        return W;\n      }\n\n  // trunc(X) - trunc(Y) -> trunc(X - Y) if everything simplifies.\n  if (MaxRecurse && match(Op0, m_Trunc(m_Value(X))) &&\n      match(Op1, m_Trunc(m_Value(Y))))\n    if (X->getType() == Y->getType())\n      // See if \"V === X - Y\" simplifies.\n      if (Value *V = SimplifyBinOp(Instruction::Sub, X, Y, Q, MaxRecurse-1))\n        // It does!  Now see if \"trunc V\" simplifies.\n        if (Value *W = SimplifyCastInst(Instruction::Trunc, V, Op0->getType(),\n                                        Q, MaxRecurse - 1))\n          // It does, return the simplified \"trunc V\".\n          return W;\n\n  // Variations on GEP(base, I, ...) - GEP(base, i, ...) -> GEP(null, I-i, ...).\n  if (match(Op0, m_PtrToInt(m_Value(X))) &&\n      match(Op1, m_PtrToInt(m_Value(Y))))\n    if (Constant *Result = computePointerDifference(Q.DL, X, Y))\n      return ConstantExpr::getIntegerCast(Result, Op0->getType(), true);\n\n  // i1 sub -> xor.\n  if (MaxRecurse && Op0->getType()->isIntOrIntVectorTy(1))\n    if (Value *V = SimplifyXorInst(Op0, Op1, Q, MaxRecurse-1))\n      return V;\n\n  // Threading Sub over selects and phi nodes is pointless, so don't bother.\n  // Threading over the select in \"A - select(cond, B, C)\" means evaluating\n  // \"A-B\" and \"A-C\" and seeing if they are equal; but they are equal if and\n  // only if B and C are equal.  If B and C are equal then (since we assume\n  // that operands have already been simplified) \"select(cond, B, C)\" should\n  // have been simplified to the common value of B and C already.  Analysing\n  // \"A-B\" and \"A-C\" thus gains nothing, but costs compile time.  Similarly\n  // for threading over phi nodes.\n\n  return nullptr;\n}\n\nValue *llvm::SimplifySubInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,\n                             const SimplifyQuery &Q) {\n  return ::SimplifySubInst(Op0, Op1, isNSW, isNUW, Q, RecursionLimit);\n}\n\n/// Given operands for a Mul, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyMulInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                              unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::Mul, Op0, Op1, Q))\n    return C;\n\n  // X * undef -> 0\n  // X * 0 -> 0\n  if (Q.isUndefValue(Op1) || match(Op1, m_Zero()))\n    return Constant::getNullValue(Op0->getType());\n\n  // X * 1 -> X\n  if (match(Op1, m_One()))\n    return Op0;\n\n  // (X / Y) * Y -> X if the division is exact.\n  Value *X = nullptr;\n  if (Q.IIQ.UseInstrInfo &&\n      (match(Op0,\n             m_Exact(m_IDiv(m_Value(X), m_Specific(Op1)))) ||     // (X / Y) * Y\n       match(Op1, m_Exact(m_IDiv(m_Value(X), m_Specific(Op0)))))) // Y * (X / Y)\n    return X;\n\n  // i1 mul -> and.\n  if (MaxRecurse && Op0->getType()->isIntOrIntVectorTy(1))\n    if (Value *V = SimplifyAndInst(Op0, Op1, Q, MaxRecurse-1))\n      return V;\n\n  // Try some generic simplifications for associative operations.\n  if (Value *V = SimplifyAssociativeBinOp(Instruction::Mul, Op0, Op1, Q,\n                                          MaxRecurse))\n    return V;\n\n  // Mul distributes over Add. Try some generic simplifications based on this.\n  if (Value *V = expandCommutativeBinOp(Instruction::Mul, Op0, Op1,\n                                        Instruction::Add, Q, MaxRecurse))\n    return V;\n\n  // If the operation is with the result of a select instruction, check whether\n  // operating on either branch of the select always yields the same value.\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1))\n    if (Value *V = ThreadBinOpOverSelect(Instruction::Mul, Op0, Op1, Q,\n                                         MaxRecurse))\n      return V;\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Instruction::Mul, Op0, Op1, Q,\n                                      MaxRecurse))\n      return V;\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyMulInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {\n  return ::SimplifyMulInst(Op0, Op1, Q, RecursionLimit);\n}\n\n/// Check for common or similar folds of integer division or integer remainder.\n/// This applies to all 4 opcodes (sdiv/udiv/srem/urem).\nstatic Value *simplifyDivRem(Value *Op0, Value *Op1, bool IsDiv,\n                             const SimplifyQuery &Q) {\n  Type *Ty = Op0->getType();\n\n  // X / undef -> poison\n  // X % undef -> poison\n  if (Q.isUndefValue(Op1))\n    return PoisonValue::get(Ty);\n\n  // X / 0 -> poison\n  // X % 0 -> poison\n  // We don't need to preserve faults!\n  if (match(Op1, m_Zero()))\n    return PoisonValue::get(Ty);\n\n  // If any element of a constant divisor fixed width vector is zero or undef\n  // the behavior is undefined and we can fold the whole op to poison.\n  auto *Op1C = dyn_cast<Constant>(Op1);\n  auto *VTy = dyn_cast<FixedVectorType>(Ty);\n  if (Op1C && VTy) {\n    unsigned NumElts = VTy->getNumElements();\n    for (unsigned i = 0; i != NumElts; ++i) {\n      Constant *Elt = Op1C->getAggregateElement(i);\n      if (Elt && (Elt->isNullValue() || Q.isUndefValue(Elt)))\n        return PoisonValue::get(Ty);\n    }\n  }\n\n  // undef / X -> 0\n  // undef % X -> 0\n  if (Q.isUndefValue(Op0))\n    return Constant::getNullValue(Ty);\n\n  // 0 / X -> 0\n  // 0 % X -> 0\n  if (match(Op0, m_Zero()))\n    return Constant::getNullValue(Op0->getType());\n\n  // X / X -> 1\n  // X % X -> 0\n  if (Op0 == Op1)\n    return IsDiv ? ConstantInt::get(Ty, 1) : Constant::getNullValue(Ty);\n\n  // X / 1 -> X\n  // X % 1 -> 0\n  // If this is a boolean op (single-bit element type), we can't have\n  // division-by-zero or remainder-by-zero, so assume the divisor is 1.\n  // Similarly, if we're zero-extending a boolean divisor, then assume it's a 1.\n  Value *X;\n  if (match(Op1, m_One()) || Ty->isIntOrIntVectorTy(1) ||\n      (match(Op1, m_ZExt(m_Value(X))) && X->getType()->isIntOrIntVectorTy(1)))\n    return IsDiv ? Op0 : Constant::getNullValue(Ty);\n\n  return nullptr;\n}\n\n/// Given a predicate and two operands, return true if the comparison is true.\n/// This is a helper for div/rem simplification where we return some other value\n/// when we can prove a relationship between the operands.\nstatic bool isICmpTrue(ICmpInst::Predicate Pred, Value *LHS, Value *RHS,\n                       const SimplifyQuery &Q, unsigned MaxRecurse) {\n  Value *V = SimplifyICmpInst(Pred, LHS, RHS, Q, MaxRecurse);\n  Constant *C = dyn_cast_or_null<Constant>(V);\n  return (C && C->isAllOnesValue());\n}\n\n/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer\n/// to simplify X % Y to X.\nstatic bool isDivZero(Value *X, Value *Y, const SimplifyQuery &Q,\n                      unsigned MaxRecurse, bool IsSigned) {\n  // Recursion is always used, so bail out at once if we already hit the limit.\n  if (!MaxRecurse--)\n    return false;\n\n  if (IsSigned) {\n    // |X| / |Y| --> 0\n    //\n    // We require that 1 operand is a simple constant. That could be extended to\n    // 2 variables if we computed the sign bit for each.\n    //\n    // Make sure that a constant is not the minimum signed value because taking\n    // the abs() of that is undefined.\n    Type *Ty = X->getType();\n    const APInt *C;\n    if (match(X, m_APInt(C)) && !C->isMinSignedValue()) {\n      // Is the variable divisor magnitude always greater than the constant\n      // dividend magnitude?\n      // |Y| > |C| --> Y < -abs(C) or Y > abs(C)\n      Constant *PosDividendC = ConstantInt::get(Ty, C->abs());\n      Constant *NegDividendC = ConstantInt::get(Ty, -C->abs());\n      if (isICmpTrue(CmpInst::ICMP_SLT, Y, NegDividendC, Q, MaxRecurse) ||\n          isICmpTrue(CmpInst::ICMP_SGT, Y, PosDividendC, Q, MaxRecurse))\n        return true;\n    }\n    if (match(Y, m_APInt(C))) {\n      // Special-case: we can't take the abs() of a minimum signed value. If\n      // that's the divisor, then all we have to do is prove that the dividend\n      // is also not the minimum signed value.\n      if (C->isMinSignedValue())\n        return isICmpTrue(CmpInst::ICMP_NE, X, Y, Q, MaxRecurse);\n\n      // Is the variable dividend magnitude always less than the constant\n      // divisor magnitude?\n      // |X| < |C| --> X > -abs(C) and X < abs(C)\n      Constant *PosDivisorC = ConstantInt::get(Ty, C->abs());\n      Constant *NegDivisorC = ConstantInt::get(Ty, -C->abs());\n      if (isICmpTrue(CmpInst::ICMP_SGT, X, NegDivisorC, Q, MaxRecurse) &&\n          isICmpTrue(CmpInst::ICMP_SLT, X, PosDivisorC, Q, MaxRecurse))\n        return true;\n    }\n    return false;\n  }\n\n  // IsSigned == false.\n  // Is the dividend unsigned less than the divisor?\n  return isICmpTrue(ICmpInst::ICMP_ULT, X, Y, Q, MaxRecurse);\n}\n\n/// These are simplifications common to SDiv and UDiv.\nstatic Value *simplifyDiv(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,\n                          const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))\n    return C;\n\n  if (Value *V = simplifyDivRem(Op0, Op1, true, Q))\n    return V;\n\n  bool IsSigned = Opcode == Instruction::SDiv;\n\n  // (X * Y) / Y -> X if the multiplication does not overflow.\n  Value *X;\n  if (match(Op0, m_c_Mul(m_Value(X), m_Specific(Op1)))) {\n    auto *Mul = cast<OverflowingBinaryOperator>(Op0);\n    // If the Mul does not overflow, then we are good to go.\n    if ((IsSigned && Q.IIQ.hasNoSignedWrap(Mul)) ||\n        (!IsSigned && Q.IIQ.hasNoUnsignedWrap(Mul)))\n      return X;\n    // If X has the form X = A / Y, then X * Y cannot overflow.\n    if ((IsSigned && match(X, m_SDiv(m_Value(), m_Specific(Op1)))) ||\n        (!IsSigned && match(X, m_UDiv(m_Value(), m_Specific(Op1)))))\n      return X;\n  }\n\n  // (X rem Y) / Y -> 0\n  if ((IsSigned && match(Op0, m_SRem(m_Value(), m_Specific(Op1)))) ||\n      (!IsSigned && match(Op0, m_URem(m_Value(), m_Specific(Op1)))))\n    return Constant::getNullValue(Op0->getType());\n\n  // (X /u C1) /u C2 -> 0 if C1 * C2 overflow\n  ConstantInt *C1, *C2;\n  if (!IsSigned && match(Op0, m_UDiv(m_Value(X), m_ConstantInt(C1))) &&\n      match(Op1, m_ConstantInt(C2))) {\n    bool Overflow;\n    (void)C1->getValue().umul_ov(C2->getValue(), Overflow);\n    if (Overflow)\n      return Constant::getNullValue(Op0->getType());\n  }\n\n  // If the operation is with the result of a select instruction, check whether\n  // operating on either branch of the select always yields the same value.\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1))\n    if (Value *V = ThreadBinOpOverSelect(Opcode, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Opcode, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  if (isDivZero(Op0, Op1, Q, MaxRecurse, IsSigned))\n    return Constant::getNullValue(Op0->getType());\n\n  return nullptr;\n}\n\n/// These are simplifications common to SRem and URem.\nstatic Value *simplifyRem(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,\n                          const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))\n    return C;\n\n  if (Value *V = simplifyDivRem(Op0, Op1, false, Q))\n    return V;\n\n  // (X % Y) % Y -> X % Y\n  if ((Opcode == Instruction::SRem &&\n       match(Op0, m_SRem(m_Value(), m_Specific(Op1)))) ||\n      (Opcode == Instruction::URem &&\n       match(Op0, m_URem(m_Value(), m_Specific(Op1)))))\n    return Op0;\n\n  // (X << Y) % X -> 0\n  if (Q.IIQ.UseInstrInfo &&\n      ((Opcode == Instruction::SRem &&\n        match(Op0, m_NSWShl(m_Specific(Op1), m_Value()))) ||\n       (Opcode == Instruction::URem &&\n        match(Op0, m_NUWShl(m_Specific(Op1), m_Value())))))\n    return Constant::getNullValue(Op0->getType());\n\n  // If the operation is with the result of a select instruction, check whether\n  // operating on either branch of the select always yields the same value.\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1))\n    if (Value *V = ThreadBinOpOverSelect(Opcode, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Opcode, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  // If X / Y == 0, then X % Y == X.\n  if (isDivZero(Op0, Op1, Q, MaxRecurse, Opcode == Instruction::SRem))\n    return Op0;\n\n  return nullptr;\n}\n\n/// Given operands for an SDiv, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifySDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                               unsigned MaxRecurse) {\n  // If two operands are negated and no signed overflow, return -1.\n  if (isKnownNegation(Op0, Op1, /*NeedNSW=*/true))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  return simplifyDiv(Instruction::SDiv, Op0, Op1, Q, MaxRecurse);\n}\n\nValue *llvm::SimplifySDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {\n  return ::SimplifySDivInst(Op0, Op1, Q, RecursionLimit);\n}\n\n/// Given operands for a UDiv, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyUDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                               unsigned MaxRecurse) {\n  return simplifyDiv(Instruction::UDiv, Op0, Op1, Q, MaxRecurse);\n}\n\nValue *llvm::SimplifyUDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {\n  return ::SimplifyUDivInst(Op0, Op1, Q, RecursionLimit);\n}\n\n/// Given operands for an SRem, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifySRemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                               unsigned MaxRecurse) {\n  // If the divisor is 0, the result is undefined, so assume the divisor is -1.\n  // srem Op0, (sext i1 X) --> srem Op0, -1 --> 0\n  Value *X;\n  if (match(Op1, m_SExt(m_Value(X))) && X->getType()->isIntOrIntVectorTy(1))\n    return ConstantInt::getNullValue(Op0->getType());\n\n  // If the two operands are negated, return 0.\n  if (isKnownNegation(Op0, Op1))\n    return ConstantInt::getNullValue(Op0->getType());\n\n  return simplifyRem(Instruction::SRem, Op0, Op1, Q, MaxRecurse);\n}\n\nValue *llvm::SimplifySRemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {\n  return ::SimplifySRemInst(Op0, Op1, Q, RecursionLimit);\n}\n\n/// Given operands for a URem, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyURemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                               unsigned MaxRecurse) {\n  return simplifyRem(Instruction::URem, Op0, Op1, Q, MaxRecurse);\n}\n\nValue *llvm::SimplifyURemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {\n  return ::SimplifyURemInst(Op0, Op1, Q, RecursionLimit);\n}\n\n/// Returns true if a shift by \\c Amount always yields poison.\nstatic bool isPoisonShift(Value *Amount, const SimplifyQuery &Q) {\n  Constant *C = dyn_cast<Constant>(Amount);\n  if (!C)\n    return false;\n\n  // X shift by undef -> poison because it may shift by the bitwidth.\n  if (Q.isUndefValue(C))\n    return true;\n\n  // Shifting by the bitwidth or more is undefined.\n  if (ConstantInt *CI = dyn_cast<ConstantInt>(C))\n    if (CI->getValue().getLimitedValue() >=\n        CI->getType()->getScalarSizeInBits())\n      return true;\n\n  // If all lanes of a vector shift are undefined the whole shift is.\n  if (isa<ConstantVector>(C) || isa<ConstantDataVector>(C)) {\n    for (unsigned I = 0,\n                  E = cast<FixedVectorType>(C->getType())->getNumElements();\n         I != E; ++I)\n      if (!isPoisonShift(C->getAggregateElement(I), Q))\n        return false;\n    return true;\n  }\n\n  return false;\n}\n\n/// Given operands for an Shl, LShr or AShr, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyShift(Instruction::BinaryOps Opcode, Value *Op0,\n                            Value *Op1, const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))\n    return C;\n\n  // 0 shift by X -> 0\n  if (match(Op0, m_Zero()))\n    return Constant::getNullValue(Op0->getType());\n\n  // X shift by 0 -> X\n  // Shift-by-sign-extended bool must be shift-by-0 because shift-by-all-ones\n  // would be poison.\n  Value *X;\n  if (match(Op1, m_Zero()) ||\n      (match(Op1, m_SExt(m_Value(X))) && X->getType()->isIntOrIntVectorTy(1)))\n    return Op0;\n\n  // Fold undefined shifts.\n  if (isPoisonShift(Op1, Q))\n    return PoisonValue::get(Op0->getType());\n\n  // If the operation is with the result of a select instruction, check whether\n  // operating on either branch of the select always yields the same value.\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1))\n    if (Value *V = ThreadBinOpOverSelect(Opcode, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Opcode, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  // If any bits in the shift amount make that value greater than or equal to\n  // the number of bits in the type, the shift is undefined.\n  KnownBits Known = computeKnownBits(Op1, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n  if (Known.One.getLimitedValue() >= Known.getBitWidth())\n    return PoisonValue::get(Op0->getType());\n\n  // If all valid bits in the shift amount are known zero, the first operand is\n  // unchanged.\n  unsigned NumValidShiftBits = Log2_32_Ceil(Known.getBitWidth());\n  if (Known.countMinTrailingZeros() >= NumValidShiftBits)\n    return Op0;\n\n  return nullptr;\n}\n\n/// Given operands for an Shl, LShr or AShr, see if we can\n/// fold the result.  If not, this returns null.\nstatic Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,\n                                 Value *Op1, bool isExact, const SimplifyQuery &Q,\n                                 unsigned MaxRecurse) {\n  if (Value *V = SimplifyShift(Opcode, Op0, Op1, Q, MaxRecurse))\n    return V;\n\n  // X >> X -> 0\n  if (Op0 == Op1)\n    return Constant::getNullValue(Op0->getType());\n\n  // undef >> X -> 0\n  // undef >> X -> undef (if it's exact)\n  if (Q.isUndefValue(Op0))\n    return isExact ? Op0 : Constant::getNullValue(Op0->getType());\n\n  // The low bit cannot be shifted out of an exact shift if it is set.\n  if (isExact) {\n    KnownBits Op0Known = computeKnownBits(Op0, Q.DL, /*Depth=*/0, Q.AC, Q.CxtI, Q.DT);\n    if (Op0Known.One[0])\n      return Op0;\n  }\n\n  return nullptr;\n}\n\n/// Given operands for an Shl, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,\n                              const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Value *V = SimplifyShift(Instruction::Shl, Op0, Op1, Q, MaxRecurse))\n    return V;\n\n  // undef << X -> 0\n  // undef << X -> undef if (if it's NSW/NUW)\n  if (Q.isUndefValue(Op0))\n    return isNSW || isNUW ? Op0 : Constant::getNullValue(Op0->getType());\n\n  // (X >> A) << A -> X\n  Value *X;\n  if (Q.IIQ.UseInstrInfo &&\n      match(Op0, m_Exact(m_Shr(m_Value(X), m_Specific(Op1)))))\n    return X;\n\n  // shl nuw i8 C, %x  ->  C  iff C has sign bit set.\n  if (isNUW && match(Op0, m_Negative()))\n    return Op0;\n  // NOTE: could use computeKnownBits() / LazyValueInfo,\n  // but the cost-benefit analysis suggests it isn't worth it.\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,\n                             const SimplifyQuery &Q) {\n  return ::SimplifyShlInst(Op0, Op1, isNSW, isNUW, Q, RecursionLimit);\n}\n\n/// Given operands for an LShr, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,\n                               const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Value *V = SimplifyRightShift(Instruction::LShr, Op0, Op1, isExact, Q,\n                                    MaxRecurse))\n      return V;\n\n  // (X << A) >> A -> X\n  Value *X;\n  if (match(Op0, m_NUWShl(m_Value(X), m_Specific(Op1))))\n    return X;\n\n  // ((X << A) | Y) >> A -> X  if effective width of Y is not larger than A.\n  // We can return X as we do in the above case since OR alters no bits in X.\n  // SimplifyDemandedBits in InstCombine can do more general optimization for\n  // bit manipulation. This pattern aims to provide opportunities for other\n  // optimizers by supporting a simple but common case in InstSimplify.\n  Value *Y;\n  const APInt *ShRAmt, *ShLAmt;\n  if (match(Op1, m_APInt(ShRAmt)) &&\n      match(Op0, m_c_Or(m_NUWShl(m_Value(X), m_APInt(ShLAmt)), m_Value(Y))) &&\n      *ShRAmt == *ShLAmt) {\n    const KnownBits YKnown = computeKnownBits(Y, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n    const unsigned Width = Op0->getType()->getScalarSizeInBits();\n    const unsigned EffWidthY = Width - YKnown.countMinLeadingZeros();\n    if (ShRAmt->uge(EffWidthY))\n      return X;\n  }\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyLShrInst(Op0, Op1, isExact, Q, RecursionLimit);\n}\n\n/// Given operands for an AShr, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,\n                               const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Value *V = SimplifyRightShift(Instruction::AShr, Op0, Op1, isExact, Q,\n                                    MaxRecurse))\n    return V;\n\n  // all ones >>a X -> -1\n  // Do not return Op0 because it may contain undef elements if it's a vector.\n  if (match(Op0, m_AllOnes()))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // (X << A) >> A -> X\n  Value *X;\n  if (Q.IIQ.UseInstrInfo && match(Op0, m_NSWShl(m_Value(X), m_Specific(Op1))))\n    return X;\n\n  // Arithmetic shifting an all-sign-bit value is a no-op.\n  unsigned NumSignBits = ComputeNumSignBits(Op0, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n  if (NumSignBits == Op0->getType()->getScalarSizeInBits())\n    return Op0;\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyAShrInst(Op0, Op1, isExact, Q, RecursionLimit);\n}\n\n/// Commuted variants are assumed to be handled by calling this function again\n/// with the parameters swapped.\nstatic Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,\n                                         ICmpInst *UnsignedICmp, bool IsAnd,\n                                         const SimplifyQuery &Q) {\n  Value *X, *Y;\n\n  ICmpInst::Predicate EqPred;\n  if (!match(ZeroICmp, m_ICmp(EqPred, m_Value(Y), m_Zero())) ||\n      !ICmpInst::isEquality(EqPred))\n    return nullptr;\n\n  ICmpInst::Predicate UnsignedPred;\n\n  Value *A, *B;\n  // Y = (A - B);\n  if (match(Y, m_Sub(m_Value(A), m_Value(B)))) {\n    if (match(UnsignedICmp,\n              m_c_ICmp(UnsignedPred, m_Specific(A), m_Specific(B))) &&\n        ICmpInst::isUnsigned(UnsignedPred)) {\n      // A >=/<= B || (A - B) != 0  <-->  true\n      if ((UnsignedPred == ICmpInst::ICMP_UGE ||\n           UnsignedPred == ICmpInst::ICMP_ULE) &&\n          EqPred == ICmpInst::ICMP_NE && !IsAnd)\n        return ConstantInt::getTrue(UnsignedICmp->getType());\n      // A </> B && (A - B) == 0  <-->  false\n      if ((UnsignedPred == ICmpInst::ICMP_ULT ||\n           UnsignedPred == ICmpInst::ICMP_UGT) &&\n          EqPred == ICmpInst::ICMP_EQ && IsAnd)\n        return ConstantInt::getFalse(UnsignedICmp->getType());\n\n      // A </> B && (A - B) != 0  <-->  A </> B\n      // A </> B || (A - B) != 0  <-->  (A - B) != 0\n      if (EqPred == ICmpInst::ICMP_NE && (UnsignedPred == ICmpInst::ICMP_ULT ||\n                                          UnsignedPred == ICmpInst::ICMP_UGT))\n        return IsAnd ? UnsignedICmp : ZeroICmp;\n\n      // A <=/>= B && (A - B) == 0  <-->  (A - B) == 0\n      // A <=/>= B || (A - B) == 0  <-->  A <=/>= B\n      if (EqPred == ICmpInst::ICMP_EQ && (UnsignedPred == ICmpInst::ICMP_ULE ||\n                                          UnsignedPred == ICmpInst::ICMP_UGE))\n        return IsAnd ? ZeroICmp : UnsignedICmp;\n    }\n\n    // Given  Y = (A - B)\n    //   Y >= A && Y != 0  --> Y >= A  iff B != 0\n    //   Y <  A || Y == 0  --> Y <  A  iff B != 0\n    if (match(UnsignedICmp,\n              m_c_ICmp(UnsignedPred, m_Specific(Y), m_Specific(A)))) {\n      if (UnsignedPred == ICmpInst::ICMP_UGE && IsAnd &&\n          EqPred == ICmpInst::ICMP_NE &&\n          isKnownNonZero(B, Q.DL, /*Depth=*/0, Q.AC, Q.CxtI, Q.DT))\n        return UnsignedICmp;\n      if (UnsignedPred == ICmpInst::ICMP_ULT && !IsAnd &&\n          EqPred == ICmpInst::ICMP_EQ &&\n          isKnownNonZero(B, Q.DL, /*Depth=*/0, Q.AC, Q.CxtI, Q.DT))\n        return UnsignedICmp;\n    }\n  }\n\n  if (match(UnsignedICmp, m_ICmp(UnsignedPred, m_Value(X), m_Specific(Y))) &&\n      ICmpInst::isUnsigned(UnsignedPred))\n    ;\n  else if (match(UnsignedICmp,\n                 m_ICmp(UnsignedPred, m_Specific(Y), m_Value(X))) &&\n           ICmpInst::isUnsigned(UnsignedPred))\n    UnsignedPred = ICmpInst::getSwappedPredicate(UnsignedPred);\n  else\n    return nullptr;\n\n  // X > Y && Y == 0  -->  Y == 0  iff X != 0\n  // X > Y || Y == 0  -->  X > Y   iff X != 0\n  if (UnsignedPred == ICmpInst::ICMP_UGT && EqPred == ICmpInst::ICMP_EQ &&\n      isKnownNonZero(X, Q.DL, /*Depth=*/0, Q.AC, Q.CxtI, Q.DT))\n    return IsAnd ? ZeroICmp : UnsignedICmp;\n\n  // X <= Y && Y != 0  -->  X <= Y  iff X != 0\n  // X <= Y || Y != 0  -->  Y != 0  iff X != 0\n  if (UnsignedPred == ICmpInst::ICMP_ULE && EqPred == ICmpInst::ICMP_NE &&\n      isKnownNonZero(X, Q.DL, /*Depth=*/0, Q.AC, Q.CxtI, Q.DT))\n    return IsAnd ? UnsignedICmp : ZeroICmp;\n\n  // The transforms below here are expected to be handled more generally with\n  // simplifyAndOrOfICmpsWithLimitConst() or in InstCombine's\n  // foldAndOrOfICmpsWithConstEq(). If we are looking to trim optimizer overlap,\n  // these are candidates for removal.\n\n  // X < Y && Y != 0  -->  X < Y\n  // X < Y || Y != 0  -->  Y != 0\n  if (UnsignedPred == ICmpInst::ICMP_ULT && EqPred == ICmpInst::ICMP_NE)\n    return IsAnd ? UnsignedICmp : ZeroICmp;\n\n  // X >= Y && Y == 0  -->  Y == 0\n  // X >= Y || Y == 0  -->  X >= Y\n  if (UnsignedPred == ICmpInst::ICMP_UGE && EqPred == ICmpInst::ICMP_EQ)\n    return IsAnd ? ZeroICmp : UnsignedICmp;\n\n  // X < Y && Y == 0  -->  false\n  if (UnsignedPred == ICmpInst::ICMP_ULT && EqPred == ICmpInst::ICMP_EQ &&\n      IsAnd)\n    return getFalse(UnsignedICmp->getType());\n\n  // X >= Y || Y != 0  -->  true\n  if (UnsignedPred == ICmpInst::ICMP_UGE && EqPred == ICmpInst::ICMP_NE &&\n      !IsAnd)\n    return getTrue(UnsignedICmp->getType());\n\n  return nullptr;\n}\n\n/// Commuted variants are assumed to be handled by calling this function again\n/// with the parameters swapped.\nstatic Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {\n  ICmpInst::Predicate Pred0, Pred1;\n  Value *A ,*B;\n  if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||\n      !match(Op1, m_ICmp(Pred1, m_Specific(A), m_Specific(B))))\n    return nullptr;\n\n  // We have (icmp Pred0, A, B) & (icmp Pred1, A, B).\n  // If Op1 is always implied true by Op0, then Op0 is a subset of Op1, and we\n  // can eliminate Op1 from this 'and'.\n  if (ICmpInst::isImpliedTrueByMatchingCmp(Pred0, Pred1))\n    return Op0;\n\n  // Check for any combination of predicates that are guaranteed to be disjoint.\n  if ((Pred0 == ICmpInst::getInversePredicate(Pred1)) ||\n      (Pred0 == ICmpInst::ICMP_EQ && ICmpInst::isFalseWhenEqual(Pred1)) ||\n      (Pred0 == ICmpInst::ICMP_SLT && Pred1 == ICmpInst::ICMP_SGT) ||\n      (Pred0 == ICmpInst::ICMP_ULT && Pred1 == ICmpInst::ICMP_UGT))\n    return getFalse(Op0->getType());\n\n  return nullptr;\n}\n\n/// Commuted variants are assumed to be handled by calling this function again\n/// with the parameters swapped.\nstatic Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {\n  ICmpInst::Predicate Pred0, Pred1;\n  Value *A ,*B;\n  if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||\n      !match(Op1, m_ICmp(Pred1, m_Specific(A), m_Specific(B))))\n    return nullptr;\n\n  // We have (icmp Pred0, A, B) | (icmp Pred1, A, B).\n  // If Op1 is always implied true by Op0, then Op0 is a subset of Op1, and we\n  // can eliminate Op0 from this 'or'.\n  if (ICmpInst::isImpliedTrueByMatchingCmp(Pred0, Pred1))\n    return Op1;\n\n  // Check for any combination of predicates that cover the entire range of\n  // possibilities.\n  if ((Pred0 == ICmpInst::getInversePredicate(Pred1)) ||\n      (Pred0 == ICmpInst::ICMP_NE && ICmpInst::isTrueWhenEqual(Pred1)) ||\n      (Pred0 == ICmpInst::ICMP_SLE && Pred1 == ICmpInst::ICMP_SGE) ||\n      (Pred0 == ICmpInst::ICMP_ULE && Pred1 == ICmpInst::ICMP_UGE))\n    return getTrue(Op0->getType());\n\n  return nullptr;\n}\n\n/// Test if a pair of compares with a shared operand and 2 constants has an\n/// empty set intersection, full set union, or if one compare is a superset of\n/// the other.\nstatic Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,\n                                                bool IsAnd) {\n  // Look for this pattern: {and/or} (icmp X, C0), (icmp X, C1)).\n  if (Cmp0->getOperand(0) != Cmp1->getOperand(0))\n    return nullptr;\n\n  const APInt *C0, *C1;\n  if (!match(Cmp0->getOperand(1), m_APInt(C0)) ||\n      !match(Cmp1->getOperand(1), m_APInt(C1)))\n    return nullptr;\n\n  auto Range0 = ConstantRange::makeExactICmpRegion(Cmp0->getPredicate(), *C0);\n  auto Range1 = ConstantRange::makeExactICmpRegion(Cmp1->getPredicate(), *C1);\n\n  // For and-of-compares, check if the intersection is empty:\n  // (icmp X, C0) && (icmp X, C1) --> empty set --> false\n  if (IsAnd && Range0.intersectWith(Range1).isEmptySet())\n    return getFalse(Cmp0->getType());\n\n  // For or-of-compares, check if the union is full:\n  // (icmp X, C0) || (icmp X, C1) --> full set --> true\n  if (!IsAnd && Range0.unionWith(Range1).isFullSet())\n    return getTrue(Cmp0->getType());\n\n  // Is one range a superset of the other?\n  // If this is and-of-compares, take the smaller set:\n  // (icmp sgt X, 4) && (icmp sgt X, 42) --> icmp sgt X, 42\n  // If this is or-of-compares, take the larger set:\n  // (icmp sgt X, 4) || (icmp sgt X, 42) --> icmp sgt X, 4\n  if (Range0.contains(Range1))\n    return IsAnd ? Cmp1 : Cmp0;\n  if (Range1.contains(Range0))\n    return IsAnd ? Cmp0 : Cmp1;\n\n  return nullptr;\n}\n\nstatic Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,\n                                           bool IsAnd) {\n  ICmpInst::Predicate P0 = Cmp0->getPredicate(), P1 = Cmp1->getPredicate();\n  if (!match(Cmp0->getOperand(1), m_Zero()) ||\n      !match(Cmp1->getOperand(1), m_Zero()) || P0 != P1)\n    return nullptr;\n\n  if ((IsAnd && P0 != ICmpInst::ICMP_NE) || (!IsAnd && P1 != ICmpInst::ICMP_EQ))\n    return nullptr;\n\n  // We have either \"(X == 0 || Y == 0)\" or \"(X != 0 && Y != 0)\".\n  Value *X = Cmp0->getOperand(0);\n  Value *Y = Cmp1->getOperand(0);\n\n  // If one of the compares is a masked version of a (not) null check, then\n  // that compare implies the other, so we eliminate the other. Optionally, look\n  // through a pointer-to-int cast to match a null check of a pointer type.\n\n  // (X == 0) || (([ptrtoint] X & ?) == 0) --> ([ptrtoint] X & ?) == 0\n  // (X == 0) || ((? & [ptrtoint] X) == 0) --> (? & [ptrtoint] X) == 0\n  // (X != 0) && (([ptrtoint] X & ?) != 0) --> ([ptrtoint] X & ?) != 0\n  // (X != 0) && ((? & [ptrtoint] X) != 0) --> (? & [ptrtoint] X) != 0\n  if (match(Y, m_c_And(m_Specific(X), m_Value())) ||\n      match(Y, m_c_And(m_PtrToInt(m_Specific(X)), m_Value())))\n    return Cmp1;\n\n  // (([ptrtoint] Y & ?) == 0) || (Y == 0) --> ([ptrtoint] Y & ?) == 0\n  // ((? & [ptrtoint] Y) == 0) || (Y == 0) --> (? & [ptrtoint] Y) == 0\n  // (([ptrtoint] Y & ?) != 0) && (Y != 0) --> ([ptrtoint] Y & ?) != 0\n  // ((? & [ptrtoint] Y) != 0) && (Y != 0) --> (? & [ptrtoint] Y) != 0\n  if (match(X, m_c_And(m_Specific(Y), m_Value())) ||\n      match(X, m_c_And(m_PtrToInt(m_Specific(Y)), m_Value())))\n    return Cmp0;\n\n  return nullptr;\n}\n\nstatic Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,\n                                        const InstrInfoQuery &IIQ) {\n  // (icmp (add V, C0), C1) & (icmp V, C0)\n  ICmpInst::Predicate Pred0, Pred1;\n  const APInt *C0, *C1;\n  Value *V;\n  if (!match(Op0, m_ICmp(Pred0, m_Add(m_Value(V), m_APInt(C0)), m_APInt(C1))))\n    return nullptr;\n\n  if (!match(Op1, m_ICmp(Pred1, m_Specific(V), m_Value())))\n    return nullptr;\n\n  auto *AddInst = cast<OverflowingBinaryOperator>(Op0->getOperand(0));\n  if (AddInst->getOperand(1) != Op1->getOperand(1))\n    return nullptr;\n\n  Type *ITy = Op0->getType();\n  bool isNSW = IIQ.hasNoSignedWrap(AddInst);\n  bool isNUW = IIQ.hasNoUnsignedWrap(AddInst);\n\n  const APInt Delta = *C1 - *C0;\n  if (C0->isStrictlyPositive()) {\n    if (Delta == 2) {\n      if (Pred0 == ICmpInst::ICMP_ULT && Pred1 == ICmpInst::ICMP_SGT)\n        return getFalse(ITy);\n      if (Pred0 == ICmpInst::ICMP_SLT && Pred1 == ICmpInst::ICMP_SGT && isNSW)\n        return getFalse(ITy);\n    }\n    if (Delta == 1) {\n      if (Pred0 == ICmpInst::ICMP_ULE && Pred1 == ICmpInst::ICMP_SGT)\n        return getFalse(ITy);\n      if (Pred0 == ICmpInst::ICMP_SLE && Pred1 == ICmpInst::ICMP_SGT && isNSW)\n        return getFalse(ITy);\n    }\n  }\n  if (C0->getBoolValue() && isNUW) {\n    if (Delta == 2)\n      if (Pred0 == ICmpInst::ICMP_ULT && Pred1 == ICmpInst::ICMP_UGT)\n        return getFalse(ITy);\n    if (Delta == 1)\n      if (Pred0 == ICmpInst::ICMP_ULE && Pred1 == ICmpInst::ICMP_UGT)\n        return getFalse(ITy);\n  }\n\n  return nullptr;\n}\n\n/// Try to eliminate compares with signed or unsigned min/max constants.\nstatic Value *simplifyAndOrOfICmpsWithLimitConst(ICmpInst *Cmp0, ICmpInst *Cmp1,\n                                                 bool IsAnd) {\n  // Canonicalize an equality compare as Cmp0.\n  if (Cmp1->isEquality())\n    std::swap(Cmp0, Cmp1);\n  if (!Cmp0->isEquality())\n    return nullptr;\n\n  // The non-equality compare must include a common operand (X). Canonicalize\n  // the common operand as operand 0 (the predicate is swapped if the common\n  // operand was operand 1).\n  ICmpInst::Predicate Pred0 = Cmp0->getPredicate();\n  Value *X = Cmp0->getOperand(0);\n  ICmpInst::Predicate Pred1;\n  bool HasNotOp = match(Cmp1, m_c_ICmp(Pred1, m_Not(m_Specific(X)), m_Value()));\n  if (!HasNotOp && !match(Cmp1, m_c_ICmp(Pred1, m_Specific(X), m_Value())))\n    return nullptr;\n  if (ICmpInst::isEquality(Pred1))\n    return nullptr;\n\n  // The equality compare must be against a constant. Flip bits if we matched\n  // a bitwise not. Convert a null pointer constant to an integer zero value.\n  APInt MinMaxC;\n  const APInt *C;\n  if (match(Cmp0->getOperand(1), m_APInt(C)))\n    MinMaxC = HasNotOp ? ~*C : *C;\n  else if (isa<ConstantPointerNull>(Cmp0->getOperand(1)))\n    MinMaxC = APInt::getNullValue(8);\n  else\n    return nullptr;\n\n  // DeMorganize if this is 'or': P0 || P1 --> !P0 && !P1.\n  if (!IsAnd) {\n    Pred0 = ICmpInst::getInversePredicate(Pred0);\n    Pred1 = ICmpInst::getInversePredicate(Pred1);\n  }\n\n  // Normalize to unsigned compare and unsigned min/max value.\n  // Example for 8-bit: -128 + 128 -> 0; 127 + 128 -> 255\n  if (ICmpInst::isSigned(Pred1)) {\n    Pred1 = ICmpInst::getUnsignedPredicate(Pred1);\n    MinMaxC += APInt::getSignedMinValue(MinMaxC.getBitWidth());\n  }\n\n  // (X != MAX) && (X < Y) --> X < Y\n  // (X == MAX) || (X >= Y) --> X >= Y\n  if (MinMaxC.isMaxValue())\n    if (Pred0 == ICmpInst::ICMP_NE && Pred1 == ICmpInst::ICMP_ULT)\n      return Cmp1;\n\n  // (X != MIN) && (X > Y) -->  X > Y\n  // (X == MIN) || (X <= Y) --> X <= Y\n  if (MinMaxC.isMinValue())\n    if (Pred0 == ICmpInst::ICMP_NE && Pred1 == ICmpInst::ICMP_UGT)\n      return Cmp1;\n\n  return nullptr;\n}\n\nstatic Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,\n                                 const SimplifyQuery &Q) {\n  if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/true, Q))\n    return X;\n  if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/true, Q))\n    return X;\n\n  if (Value *X = simplifyAndOfICmpsWithSameOperands(Op0, Op1))\n    return X;\n  if (Value *X = simplifyAndOfICmpsWithSameOperands(Op1, Op0))\n    return X;\n\n  if (Value *X = simplifyAndOrOfICmpsWithConstants(Op0, Op1, true))\n    return X;\n\n  if (Value *X = simplifyAndOrOfICmpsWithLimitConst(Op0, Op1, true))\n    return X;\n\n  if (Value *X = simplifyAndOrOfICmpsWithZero(Op0, Op1, true))\n    return X;\n\n  if (Value *X = simplifyAndOfICmpsWithAdd(Op0, Op1, Q.IIQ))\n    return X;\n  if (Value *X = simplifyAndOfICmpsWithAdd(Op1, Op0, Q.IIQ))\n    return X;\n\n  return nullptr;\n}\n\nstatic Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,\n                                       const InstrInfoQuery &IIQ) {\n  // (icmp (add V, C0), C1) | (icmp V, C0)\n  ICmpInst::Predicate Pred0, Pred1;\n  const APInt *C0, *C1;\n  Value *V;\n  if (!match(Op0, m_ICmp(Pred0, m_Add(m_Value(V), m_APInt(C0)), m_APInt(C1))))\n    return nullptr;\n\n  if (!match(Op1, m_ICmp(Pred1, m_Specific(V), m_Value())))\n    return nullptr;\n\n  auto *AddInst = cast<BinaryOperator>(Op0->getOperand(0));\n  if (AddInst->getOperand(1) != Op1->getOperand(1))\n    return nullptr;\n\n  Type *ITy = Op0->getType();\n  bool isNSW = IIQ.hasNoSignedWrap(AddInst);\n  bool isNUW = IIQ.hasNoUnsignedWrap(AddInst);\n\n  const APInt Delta = *C1 - *C0;\n  if (C0->isStrictlyPositive()) {\n    if (Delta == 2) {\n      if (Pred0 == ICmpInst::ICMP_UGE && Pred1 == ICmpInst::ICMP_SLE)\n        return getTrue(ITy);\n      if (Pred0 == ICmpInst::ICMP_SGE && Pred1 == ICmpInst::ICMP_SLE && isNSW)\n        return getTrue(ITy);\n    }\n    if (Delta == 1) {\n      if (Pred0 == ICmpInst::ICMP_UGT && Pred1 == ICmpInst::ICMP_SLE)\n        return getTrue(ITy);\n      if (Pred0 == ICmpInst::ICMP_SGT && Pred1 == ICmpInst::ICMP_SLE && isNSW)\n        return getTrue(ITy);\n    }\n  }\n  if (C0->getBoolValue() && isNUW) {\n    if (Delta == 2)\n      if (Pred0 == ICmpInst::ICMP_UGE && Pred1 == ICmpInst::ICMP_ULE)\n        return getTrue(ITy);\n    if (Delta == 1)\n      if (Pred0 == ICmpInst::ICMP_UGT && Pred1 == ICmpInst::ICMP_ULE)\n        return getTrue(ITy);\n  }\n\n  return nullptr;\n}\n\nstatic Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,\n                                const SimplifyQuery &Q) {\n  if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/false, Q))\n    return X;\n  if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/false, Q))\n    return X;\n\n  if (Value *X = simplifyOrOfICmpsWithSameOperands(Op0, Op1))\n    return X;\n  if (Value *X = simplifyOrOfICmpsWithSameOperands(Op1, Op0))\n    return X;\n\n  if (Value *X = simplifyAndOrOfICmpsWithConstants(Op0, Op1, false))\n    return X;\n\n  if (Value *X = simplifyAndOrOfICmpsWithLimitConst(Op0, Op1, false))\n    return X;\n\n  if (Value *X = simplifyAndOrOfICmpsWithZero(Op0, Op1, false))\n    return X;\n\n  if (Value *X = simplifyOrOfICmpsWithAdd(Op0, Op1, Q.IIQ))\n    return X;\n  if (Value *X = simplifyOrOfICmpsWithAdd(Op1, Op0, Q.IIQ))\n    return X;\n\n  return nullptr;\n}\n\nstatic Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,\n                                   FCmpInst *LHS, FCmpInst *RHS, bool IsAnd) {\n  Value *LHS0 = LHS->getOperand(0), *LHS1 = LHS->getOperand(1);\n  Value *RHS0 = RHS->getOperand(0), *RHS1 = RHS->getOperand(1);\n  if (LHS0->getType() != RHS0->getType())\n    return nullptr;\n\n  FCmpInst::Predicate PredL = LHS->getPredicate(), PredR = RHS->getPredicate();\n  if ((PredL == FCmpInst::FCMP_ORD && PredR == FCmpInst::FCMP_ORD && IsAnd) ||\n      (PredL == FCmpInst::FCMP_UNO && PredR == FCmpInst::FCMP_UNO && !IsAnd)) {\n    // (fcmp ord NNAN, X) & (fcmp ord X, Y) --> fcmp ord X, Y\n    // (fcmp ord NNAN, X) & (fcmp ord Y, X) --> fcmp ord Y, X\n    // (fcmp ord X, NNAN) & (fcmp ord X, Y) --> fcmp ord X, Y\n    // (fcmp ord X, NNAN) & (fcmp ord Y, X) --> fcmp ord Y, X\n    // (fcmp uno NNAN, X) | (fcmp uno X, Y) --> fcmp uno X, Y\n    // (fcmp uno NNAN, X) | (fcmp uno Y, X) --> fcmp uno Y, X\n    // (fcmp uno X, NNAN) | (fcmp uno X, Y) --> fcmp uno X, Y\n    // (fcmp uno X, NNAN) | (fcmp uno Y, X) --> fcmp uno Y, X\n    if ((isKnownNeverNaN(LHS0, TLI) && (LHS1 == RHS0 || LHS1 == RHS1)) ||\n        (isKnownNeverNaN(LHS1, TLI) && (LHS0 == RHS0 || LHS0 == RHS1)))\n      return RHS;\n\n    // (fcmp ord X, Y) & (fcmp ord NNAN, X) --> fcmp ord X, Y\n    // (fcmp ord Y, X) & (fcmp ord NNAN, X) --> fcmp ord Y, X\n    // (fcmp ord X, Y) & (fcmp ord X, NNAN) --> fcmp ord X, Y\n    // (fcmp ord Y, X) & (fcmp ord X, NNAN) --> fcmp ord Y, X\n    // (fcmp uno X, Y) | (fcmp uno NNAN, X) --> fcmp uno X, Y\n    // (fcmp uno Y, X) | (fcmp uno NNAN, X) --> fcmp uno Y, X\n    // (fcmp uno X, Y) | (fcmp uno X, NNAN) --> fcmp uno X, Y\n    // (fcmp uno Y, X) | (fcmp uno X, NNAN) --> fcmp uno Y, X\n    if ((isKnownNeverNaN(RHS0, TLI) && (RHS1 == LHS0 || RHS1 == LHS1)) ||\n        (isKnownNeverNaN(RHS1, TLI) && (RHS0 == LHS0 || RHS0 == LHS1)))\n      return LHS;\n  }\n\n  return nullptr;\n}\n\nstatic Value *simplifyAndOrOfCmps(const SimplifyQuery &Q,\n                                  Value *Op0, Value *Op1, bool IsAnd) {\n  // Look through casts of the 'and' operands to find compares.\n  auto *Cast0 = dyn_cast<CastInst>(Op0);\n  auto *Cast1 = dyn_cast<CastInst>(Op1);\n  if (Cast0 && Cast1 && Cast0->getOpcode() == Cast1->getOpcode() &&\n      Cast0->getSrcTy() == Cast1->getSrcTy()) {\n    Op0 = Cast0->getOperand(0);\n    Op1 = Cast1->getOperand(0);\n  }\n\n  Value *V = nullptr;\n  auto *ICmp0 = dyn_cast<ICmpInst>(Op0);\n  auto *ICmp1 = dyn_cast<ICmpInst>(Op1);\n  if (ICmp0 && ICmp1)\n    V = IsAnd ? simplifyAndOfICmps(ICmp0, ICmp1, Q)\n              : simplifyOrOfICmps(ICmp0, ICmp1, Q);\n\n  auto *FCmp0 = dyn_cast<FCmpInst>(Op0);\n  auto *FCmp1 = dyn_cast<FCmpInst>(Op1);\n  if (FCmp0 && FCmp1)\n    V = simplifyAndOrOfFCmps(Q.TLI, FCmp0, FCmp1, IsAnd);\n\n  if (!V)\n    return nullptr;\n  if (!Cast0)\n    return V;\n\n  // If we looked through casts, we can only handle a constant simplification\n  // because we are not allowed to create a cast instruction here.\n  if (auto *C = dyn_cast<Constant>(V))\n    return ConstantExpr::getCast(Cast0->getOpcode(), C, Cast0->getType());\n\n  return nullptr;\n}\n\n/// Check that the Op1 is in expected form, i.e.:\n///   %Agg = tail call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %???)\n///   %Op1 = extractvalue { i4, i1 } %Agg, 1\nstatic bool omitCheckForZeroBeforeMulWithOverflowInternal(Value *Op1,\n                                                          Value *X) {\n  auto *Extract = dyn_cast<ExtractValueInst>(Op1);\n  // We should only be extracting the overflow bit.\n  if (!Extract || !Extract->getIndices().equals(1))\n    return false;\n  Value *Agg = Extract->getAggregateOperand();\n  // This should be a multiplication-with-overflow intrinsic.\n  if (!match(Agg, m_CombineOr(m_Intrinsic<Intrinsic::umul_with_overflow>(),\n                              m_Intrinsic<Intrinsic::smul_with_overflow>())))\n    return false;\n  // One of its multipliers should be the value we checked for zero before.\n  if (!match(Agg, m_CombineOr(m_Argument<0>(m_Specific(X)),\n                              m_Argument<1>(m_Specific(X)))))\n    return false;\n  return true;\n}\n\n/// The @llvm.[us]mul.with.overflow intrinsic could have been folded from some\n/// other form of check, e.g. one that was using division; it may have been\n/// guarded against division-by-zero. We can drop that check now.\n/// Look for:\n///   %Op0 = icmp ne i4 %X, 0\n///   %Agg = tail call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %???)\n///   %Op1 = extractvalue { i4, i1 } %Agg, 1\n///   %??? = and i1 %Op0, %Op1\n/// We can just return  %Op1\nstatic Value *omitCheckForZeroBeforeMulWithOverflow(Value *Op0, Value *Op1) {\n  ICmpInst::Predicate Pred;\n  Value *X;\n  if (!match(Op0, m_ICmp(Pred, m_Value(X), m_Zero())) ||\n      Pred != ICmpInst::Predicate::ICMP_NE)\n    return nullptr;\n  // Is Op1 in expected form?\n  if (!omitCheckForZeroBeforeMulWithOverflowInternal(Op1, X))\n    return nullptr;\n  // Can omit 'and', and just return the overflow bit.\n  return Op1;\n}\n\n/// The @llvm.[us]mul.with.overflow intrinsic could have been folded from some\n/// other form of check, e.g. one that was using division; it may have been\n/// guarded against division-by-zero. We can drop that check now.\n/// Look for:\n///   %Op0 = icmp eq i4 %X, 0\n///   %Agg = tail call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %???)\n///   %Op1 = extractvalue { i4, i1 } %Agg, 1\n///   %NotOp1 = xor i1 %Op1, true\n///   %or = or i1 %Op0, %NotOp1\n/// We can just return  %NotOp1\nstatic Value *omitCheckForZeroBeforeInvertedMulWithOverflow(Value *Op0,\n                                                            Value *NotOp1) {\n  ICmpInst::Predicate Pred;\n  Value *X;\n  if (!match(Op0, m_ICmp(Pred, m_Value(X), m_Zero())) ||\n      Pred != ICmpInst::Predicate::ICMP_EQ)\n    return nullptr;\n  // We expect the other hand of an 'or' to be a 'not'.\n  Value *Op1;\n  if (!match(NotOp1, m_Not(m_Value(Op1))))\n    return nullptr;\n  // Is Op1 in expected form?\n  if (!omitCheckForZeroBeforeMulWithOverflowInternal(Op1, X))\n    return nullptr;\n  // Can omit 'and', and just return the inverted overflow bit.\n  return NotOp1;\n}\n\n/// Given a bitwise logic op, check if the operands are add/sub with a common\n/// source value and inverted constant (identity: C - X -> ~(X + ~C)).\nstatic Value *simplifyLogicOfAddSub(Value *Op0, Value *Op1,\n                                    Instruction::BinaryOps Opcode) {\n  assert(Op0->getType() == Op1->getType() && \"Mismatched binop types\");\n  assert(BinaryOperator::isBitwiseLogicOp(Opcode) && \"Expected logic op\");\n  Value *X;\n  Constant *C1, *C2;\n  if ((match(Op0, m_Add(m_Value(X), m_Constant(C1))) &&\n       match(Op1, m_Sub(m_Constant(C2), m_Specific(X)))) ||\n      (match(Op1, m_Add(m_Value(X), m_Constant(C1))) &&\n       match(Op0, m_Sub(m_Constant(C2), m_Specific(X))))) {\n    if (ConstantExpr::getNot(C1) == C2) {\n      // (X + C) & (~C - X) --> (X + C) & ~(X + C) --> 0\n      // (X + C) | (~C - X) --> (X + C) | ~(X + C) --> -1\n      // (X + C) ^ (~C - X) --> (X + C) ^ ~(X + C) --> -1\n      Type *Ty = Op0->getType();\n      return Opcode == Instruction::And ? ConstantInt::getNullValue(Ty)\n                                        : ConstantInt::getAllOnesValue(Ty);\n    }\n  }\n  return nullptr;\n}\n\n/// Given operands for an And, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyAndInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                              unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::And, Op0, Op1, Q))\n    return C;\n\n  // X & undef -> 0\n  if (Q.isUndefValue(Op1))\n    return Constant::getNullValue(Op0->getType());\n\n  // X & X = X\n  if (Op0 == Op1)\n    return Op0;\n\n  // X & 0 = 0\n  if (match(Op1, m_Zero()))\n    return Constant::getNullValue(Op0->getType());\n\n  // X & -1 = X\n  if (match(Op1, m_AllOnes()))\n    return Op0;\n\n  // A & ~A  =  ~A & A  =  0\n  if (match(Op0, m_Not(m_Specific(Op1))) ||\n      match(Op1, m_Not(m_Specific(Op0))))\n    return Constant::getNullValue(Op0->getType());\n\n  // (A | ?) & A = A\n  if (match(Op0, m_c_Or(m_Specific(Op1), m_Value())))\n    return Op1;\n\n  // A & (A | ?) = A\n  if (match(Op1, m_c_Or(m_Specific(Op0), m_Value())))\n    return Op0;\n\n  if (Value *V = simplifyLogicOfAddSub(Op0, Op1, Instruction::And))\n    return V;\n\n  // A mask that only clears known zeros of a shifted value is a no-op.\n  Value *X;\n  const APInt *Mask;\n  const APInt *ShAmt;\n  if (match(Op1, m_APInt(Mask))) {\n    // If all bits in the inverted and shifted mask are clear:\n    // and (shl X, ShAmt), Mask --> shl X, ShAmt\n    if (match(Op0, m_Shl(m_Value(X), m_APInt(ShAmt))) &&\n        (~(*Mask)).lshr(*ShAmt).isNullValue())\n      return Op0;\n\n    // If all bits in the inverted and shifted mask are clear:\n    // and (lshr X, ShAmt), Mask --> lshr X, ShAmt\n    if (match(Op0, m_LShr(m_Value(X), m_APInt(ShAmt))) &&\n        (~(*Mask)).shl(*ShAmt).isNullValue())\n      return Op0;\n  }\n\n  // If we have a multiplication overflow check that is being 'and'ed with a\n  // check that one of the multipliers is not zero, we can omit the 'and', and\n  // only keep the overflow check.\n  if (Value *V = omitCheckForZeroBeforeMulWithOverflow(Op0, Op1))\n    return V;\n  if (Value *V = omitCheckForZeroBeforeMulWithOverflow(Op1, Op0))\n    return V;\n\n  // A & (-A) = A if A is a power of two or zero.\n  if (match(Op0, m_Neg(m_Specific(Op1))) ||\n      match(Op1, m_Neg(m_Specific(Op0)))) {\n    if (isKnownToBeAPowerOfTwo(Op0, Q.DL, /*OrZero*/ true, 0, Q.AC, Q.CxtI,\n                               Q.DT))\n      return Op0;\n    if (isKnownToBeAPowerOfTwo(Op1, Q.DL, /*OrZero*/ true, 0, Q.AC, Q.CxtI,\n                               Q.DT))\n      return Op1;\n  }\n\n  // This is a similar pattern used for checking if a value is a power-of-2:\n  // (A - 1) & A --> 0 (if A is a power-of-2 or 0)\n  // A & (A - 1) --> 0 (if A is a power-of-2 or 0)\n  if (match(Op0, m_Add(m_Specific(Op1), m_AllOnes())) &&\n      isKnownToBeAPowerOfTwo(Op1, Q.DL, /*OrZero*/ true, 0, Q.AC, Q.CxtI, Q.DT))\n    return Constant::getNullValue(Op1->getType());\n  if (match(Op1, m_Add(m_Specific(Op0), m_AllOnes())) &&\n      isKnownToBeAPowerOfTwo(Op0, Q.DL, /*OrZero*/ true, 0, Q.AC, Q.CxtI, Q.DT))\n    return Constant::getNullValue(Op0->getType());\n\n  if (Value *V = simplifyAndOrOfCmps(Q, Op0, Op1, true))\n    return V;\n\n  // Try some generic simplifications for associative operations.\n  if (Value *V = SimplifyAssociativeBinOp(Instruction::And, Op0, Op1, Q,\n                                          MaxRecurse))\n    return V;\n\n  // And distributes over Or.  Try some generic simplifications based on this.\n  if (Value *V = expandCommutativeBinOp(Instruction::And, Op0, Op1,\n                                        Instruction::Or, Q, MaxRecurse))\n    return V;\n\n  // And distributes over Xor.  Try some generic simplifications based on this.\n  if (Value *V = expandCommutativeBinOp(Instruction::And, Op0, Op1,\n                                        Instruction::Xor, Q, MaxRecurse))\n    return V;\n\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1)) {\n    if (Op0->getType()->isIntOrIntVectorTy(1)) {\n      // A & (A && B) -> A && B\n      if (match(Op1, m_Select(m_Specific(Op0), m_Value(), m_Zero())))\n        return Op1;\n      else if (match(Op0, m_Select(m_Specific(Op1), m_Value(), m_Zero())))\n        return Op0;\n    }\n    // If the operation is with the result of a select instruction, check\n    // whether operating on either branch of the select always yields the same\n    // value.\n    if (Value *V = ThreadBinOpOverSelect(Instruction::And, Op0, Op1, Q,\n                                         MaxRecurse))\n      return V;\n  }\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Instruction::And, Op0, Op1, Q,\n                                      MaxRecurse))\n      return V;\n\n  // Assuming the effective width of Y is not larger than A, i.e. all bits\n  // from X and Y are disjoint in (X << A) | Y,\n  // if the mask of this AND op covers all bits of X or Y, while it covers\n  // no bits from the other, we can bypass this AND op. E.g.,\n  // ((X << A) | Y) & Mask -> Y,\n  //     if Mask = ((1 << effective_width_of(Y)) - 1)\n  // ((X << A) | Y) & Mask -> X << A,\n  //     if Mask = ((1 << effective_width_of(X)) - 1) << A\n  // SimplifyDemandedBits in InstCombine can optimize the general case.\n  // This pattern aims to help other passes for a common case.\n  Value *Y, *XShifted;\n  if (match(Op1, m_APInt(Mask)) &&\n      match(Op0, m_c_Or(m_CombineAnd(m_NUWShl(m_Value(X), m_APInt(ShAmt)),\n                                     m_Value(XShifted)),\n                        m_Value(Y)))) {\n    const unsigned Width = Op0->getType()->getScalarSizeInBits();\n    const unsigned ShftCnt = ShAmt->getLimitedValue(Width);\n    const KnownBits YKnown = computeKnownBits(Y, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n    const unsigned EffWidthY = Width - YKnown.countMinLeadingZeros();\n    if (EffWidthY <= ShftCnt) {\n      const KnownBits XKnown = computeKnownBits(X, Q.DL, 0, Q.AC, Q.CxtI,\n                                                Q.DT);\n      const unsigned EffWidthX = Width - XKnown.countMinLeadingZeros();\n      const APInt EffBitsY = APInt::getLowBitsSet(Width, EffWidthY);\n      const APInt EffBitsX = APInt::getLowBitsSet(Width, EffWidthX) << ShftCnt;\n      // If the mask is extracting all bits from X or Y as is, we can skip\n      // this AND op.\n      if (EffBitsY.isSubsetOf(*Mask) && !EffBitsX.intersects(*Mask))\n        return Y;\n      if (EffBitsX.isSubsetOf(*Mask) && !EffBitsY.intersects(*Mask))\n        return XShifted;\n    }\n  }\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyAndInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {\n  return ::SimplifyAndInst(Op0, Op1, Q, RecursionLimit);\n}\n\n/// Given operands for an Or, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                             unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))\n    return C;\n\n  // X | undef -> -1\n  // X | -1 = -1\n  // Do not return Op1 because it may contain undef elements if it's a vector.\n  if (Q.isUndefValue(Op1) || match(Op1, m_AllOnes()))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // X | X = X\n  // X | 0 = X\n  if (Op0 == Op1 || match(Op1, m_Zero()))\n    return Op0;\n\n  // A | ~A  =  ~A | A  =  -1\n  if (match(Op0, m_Not(m_Specific(Op1))) ||\n      match(Op1, m_Not(m_Specific(Op0))))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // (A & ?) | A = A\n  if (match(Op0, m_c_And(m_Specific(Op1), m_Value())))\n    return Op1;\n\n  // A | (A & ?) = A\n  if (match(Op1, m_c_And(m_Specific(Op0), m_Value())))\n    return Op0;\n\n  // ~(A & ?) | A = -1\n  if (match(Op0, m_Not(m_c_And(m_Specific(Op1), m_Value()))))\n    return Constant::getAllOnesValue(Op1->getType());\n\n  // A | ~(A & ?) = -1\n  if (match(Op1, m_Not(m_c_And(m_Specific(Op0), m_Value()))))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  if (Value *V = simplifyLogicOfAddSub(Op0, Op1, Instruction::Or))\n    return V;\n\n  Value *A, *B, *NotA;\n  // (A & ~B) | (A ^ B) -> (A ^ B)\n  // (~B & A) | (A ^ B) -> (A ^ B)\n  // (A & ~B) | (B ^ A) -> (B ^ A)\n  // (~B & A) | (B ^ A) -> (B ^ A)\n  if (match(Op1, m_Xor(m_Value(A), m_Value(B))) &&\n      (match(Op0, m_c_And(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op0, m_c_And(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op1;\n\n  // Commute the 'or' operands.\n  // (A ^ B) | (A & ~B) -> (A ^ B)\n  // (A ^ B) | (~B & A) -> (A ^ B)\n  // (B ^ A) | (A & ~B) -> (B ^ A)\n  // (B ^ A) | (~B & A) -> (B ^ A)\n  if (match(Op0, m_Xor(m_Value(A), m_Value(B))) &&\n      (match(Op1, m_c_And(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op1, m_c_And(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op0;\n\n  // (A & B) | (~A ^ B) -> (~A ^ B)\n  // (B & A) | (~A ^ B) -> (~A ^ B)\n  // (A & B) | (B ^ ~A) -> (B ^ ~A)\n  // (B & A) | (B ^ ~A) -> (B ^ ~A)\n  if (match(Op0, m_And(m_Value(A), m_Value(B))) &&\n      (match(Op1, m_c_Xor(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op1, m_c_Xor(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op1;\n\n  // Commute the 'or' operands.\n  // (~A ^ B) | (A & B) -> (~A ^ B)\n  // (~A ^ B) | (B & A) -> (~A ^ B)\n  // (B ^ ~A) | (A & B) -> (B ^ ~A)\n  // (B ^ ~A) | (B & A) -> (B ^ ~A)\n  if (match(Op1, m_And(m_Value(A), m_Value(B))) &&\n      (match(Op0, m_c_Xor(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op0, m_c_Xor(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op0;\n\n  // (~A & B) | ~(A | B) --> ~A\n  // (~A & B) | ~(B | A) --> ~A\n  // (B & ~A) | ~(A | B) --> ~A\n  // (B & ~A) | ~(B | A) --> ~A\n  if (match(Op0, m_c_And(m_CombineAnd(m_Value(NotA), m_Not(m_Value(A))),\n                         m_Value(B))) &&\n      match(Op1, m_Not(m_c_Or(m_Specific(A), m_Specific(B)))))\n    return NotA;\n\n  // Commute the 'or' operands.\n  // ~(A | B) | (~A & B) --> ~A\n  // ~(B | A) | (~A & B) --> ~A\n  // ~(A | B) | (B & ~A) --> ~A\n  // ~(B | A) | (B & ~A) --> ~A\n  if (match(Op1, m_c_And(m_CombineAnd(m_Value(NotA), m_Not(m_Value(A))),\n                         m_Value(B))) &&\n      match(Op0, m_Not(m_c_Or(m_Specific(A), m_Specific(B)))))\n    return NotA;\n\n  if (Value *V = simplifyAndOrOfCmps(Q, Op0, Op1, false))\n    return V;\n\n  // If we have a multiplication overflow check that is being 'and'ed with a\n  // check that one of the multipliers is not zero, we can omit the 'and', and\n  // only keep the overflow check.\n  if (Value *V = omitCheckForZeroBeforeInvertedMulWithOverflow(Op0, Op1))\n    return V;\n  if (Value *V = omitCheckForZeroBeforeInvertedMulWithOverflow(Op1, Op0))\n    return V;\n\n  // Try some generic simplifications for associative operations.\n  if (Value *V = SimplifyAssociativeBinOp(Instruction::Or, Op0, Op1, Q,\n                                          MaxRecurse))\n    return V;\n\n  // Or distributes over And.  Try some generic simplifications based on this.\n  if (Value *V = expandCommutativeBinOp(Instruction::Or, Op0, Op1,\n                                        Instruction::And, Q, MaxRecurse))\n    return V;\n\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1)) {\n    if (Op0->getType()->isIntOrIntVectorTy(1)) {\n      // A | (A || B) -> A || B\n      if (match(Op1, m_Select(m_Specific(Op0), m_One(), m_Value())))\n        return Op1;\n      else if (match(Op0, m_Select(m_Specific(Op1), m_One(), m_Value())))\n        return Op0;\n    }\n    // If the operation is with the result of a select instruction, check\n    // whether operating on either branch of the select always yields the same\n    // value.\n    if (Value *V = ThreadBinOpOverSelect(Instruction::Or, Op0, Op1, Q,\n                                         MaxRecurse))\n      return V;\n  }\n\n  // (A & C1)|(B & C2)\n  const APInt *C1, *C2;\n  if (match(Op0, m_And(m_Value(A), m_APInt(C1))) &&\n      match(Op1, m_And(m_Value(B), m_APInt(C2)))) {\n    if (*C1 == ~*C2) {\n      // (A & C1)|(B & C2)\n      // If we have: ((V + N) & C1) | (V & C2)\n      // .. and C2 = ~C1 and C2 is 0+1+ and (N & C2) == 0\n      // replace with V+N.\n      Value *N;\n      if (C2->isMask() && // C2 == 0+1+\n          match(A, m_c_Add(m_Specific(B), m_Value(N)))) {\n        // Add commutes, try both ways.\n        if (MaskedValueIsZero(N, *C2, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n          return A;\n      }\n      // Or commutes, try both ways.\n      if (C1->isMask() &&\n          match(B, m_c_Add(m_Specific(A), m_Value(N)))) {\n        // Add commutes, try both ways.\n        if (MaskedValueIsZero(N, *C1, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n          return B;\n      }\n    }\n  }\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Instruction::Or, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {\n  return ::SimplifyOrInst(Op0, Op1, Q, RecursionLimit);\n}\n\n/// Given operands for a Xor, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyXorInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                              unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::Xor, Op0, Op1, Q))\n    return C;\n\n  // A ^ undef -> undef\n  if (Q.isUndefValue(Op1))\n    return Op1;\n\n  // A ^ 0 = A\n  if (match(Op1, m_Zero()))\n    return Op0;\n\n  // A ^ A = 0\n  if (Op0 == Op1)\n    return Constant::getNullValue(Op0->getType());\n\n  // A ^ ~A  =  ~A ^ A  =  -1\n  if (match(Op0, m_Not(m_Specific(Op1))) ||\n      match(Op1, m_Not(m_Specific(Op0))))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  if (Value *V = simplifyLogicOfAddSub(Op0, Op1, Instruction::Xor))\n    return V;\n\n  // Try some generic simplifications for associative operations.\n  if (Value *V = SimplifyAssociativeBinOp(Instruction::Xor, Op0, Op1, Q,\n                                          MaxRecurse))\n    return V;\n\n  // Threading Xor over selects and phi nodes is pointless, so don't bother.\n  // Threading over the select in \"A ^ select(cond, B, C)\" means evaluating\n  // \"A^B\" and \"A^C\" and seeing if they are equal; but they are equal if and\n  // only if B and C are equal.  If B and C are equal then (since we assume\n  // that operands have already been simplified) \"select(cond, B, C)\" should\n  // have been simplified to the common value of B and C already.  Analysing\n  // \"A^B\" and \"A^C\" thus gains nothing, but costs compile time.  Similarly\n  // for threading over phi nodes.\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyXorInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {\n  return ::SimplifyXorInst(Op0, Op1, Q, RecursionLimit);\n}\n\n\nstatic Type *GetCompareTy(Value *Op) {\n  return CmpInst::makeCmpResultType(Op->getType());\n}\n\n/// Rummage around inside V looking for something equivalent to the comparison\n/// \"LHS Pred RHS\". Return such a value if found, otherwise return null.\n/// Helper function for analyzing max/min idioms.\nstatic Value *ExtractEquivalentCondition(Value *V, CmpInst::Predicate Pred,\n                                         Value *LHS, Value *RHS) {\n  SelectInst *SI = dyn_cast<SelectInst>(V);\n  if (!SI)\n    return nullptr;\n  CmpInst *Cmp = dyn_cast<CmpInst>(SI->getCondition());\n  if (!Cmp)\n    return nullptr;\n  Value *CmpLHS = Cmp->getOperand(0), *CmpRHS = Cmp->getOperand(1);\n  if (Pred == Cmp->getPredicate() && LHS == CmpLHS && RHS == CmpRHS)\n    return Cmp;\n  if (Pred == CmpInst::getSwappedPredicate(Cmp->getPredicate()) &&\n      LHS == CmpRHS && RHS == CmpLHS)\n    return Cmp;\n  return nullptr;\n}\n\n// A significant optimization not implemented here is assuming that alloca\n// addresses are not equal to incoming argument values. They don't *alias*,\n// as we say, but that doesn't mean they aren't equal, so we take a\n// conservative approach.\n//\n// This is inspired in part by C++11 5.10p1:\n//   \"Two pointers of the same type compare equal if and only if they are both\n//    null, both point to the same function, or both represent the same\n//    address.\"\n//\n// This is pretty permissive.\n//\n// It's also partly due to C11 6.5.9p6:\n//   \"Two pointers compare equal if and only if both are null pointers, both are\n//    pointers to the same object (including a pointer to an object and a\n//    subobject at its beginning) or function, both are pointers to one past the\n//    last element of the same array object, or one is a pointer to one past the\n//    end of one array object and the other is a pointer to the start of a\n//    different array object that happens to immediately follow the first array\n//    object in the address space.)\n//\n// C11's version is more restrictive, however there's no reason why an argument\n// couldn't be a one-past-the-end value for a stack object in the caller and be\n// equal to the beginning of a stack object in the callee.\n//\n// If the C and C++ standards are ever made sufficiently restrictive in this\n// area, it may be possible to update LLVM's semantics accordingly and reinstate\n// this optimization.\nstatic Constant *\ncomputePointerICmp(const DataLayout &DL, const TargetLibraryInfo *TLI,\n                   const DominatorTree *DT, CmpInst::Predicate Pred,\n                   AssumptionCache *AC, const Instruction *CxtI,\n                   const InstrInfoQuery &IIQ, Value *LHS, Value *RHS) {\n  // First, skip past any trivial no-ops.\n  LHS = LHS->stripPointerCasts();\n  RHS = RHS->stripPointerCasts();\n\n  // A non-null pointer is not equal to a null pointer.\n  if (isa<ConstantPointerNull>(RHS) && ICmpInst::isEquality(Pred) &&\n      llvm::isKnownNonZero(LHS, DL, 0, nullptr, nullptr, nullptr,\n                           IIQ.UseInstrInfo))\n    return ConstantInt::get(GetCompareTy(LHS),\n                            !CmpInst::isTrueWhenEqual(Pred));\n\n  // We can only fold certain predicates on pointer comparisons.\n  switch (Pred) {\n  default:\n    return nullptr;\n\n    // Equality comaprisons are easy to fold.\n  case CmpInst::ICMP_EQ:\n  case CmpInst::ICMP_NE:\n    break;\n\n    // We can only handle unsigned relational comparisons because 'inbounds' on\n    // a GEP only protects against unsigned wrapping.\n  case CmpInst::ICMP_UGT:\n  case CmpInst::ICMP_UGE:\n  case CmpInst::ICMP_ULT:\n  case CmpInst::ICMP_ULE:\n    // However, we have to switch them to their signed variants to handle\n    // negative indices from the base pointer.\n    Pred = ICmpInst::getSignedPredicate(Pred);\n    break;\n  }\n\n  // Strip off any constant offsets so that we can reason about them.\n  // It's tempting to use getUnderlyingObject or even just stripInBoundsOffsets\n  // here and compare base addresses like AliasAnalysis does, however there are\n  // numerous hazards. AliasAnalysis and its utilities rely on special rules\n  // governing loads and stores which don't apply to icmps. Also, AliasAnalysis\n  // doesn't need to guarantee pointer inequality when it says NoAlias.\n  Constant *LHSOffset = stripAndComputeConstantOffsets(DL, LHS);\n  Constant *RHSOffset = stripAndComputeConstantOffsets(DL, RHS);\n\n  // If LHS and RHS are related via constant offsets to the same base\n  // value, we can replace it with an icmp which just compares the offsets.\n  if (LHS == RHS)\n    return ConstantExpr::getICmp(Pred, LHSOffset, RHSOffset);\n\n  // Various optimizations for (in)equality comparisons.\n  if (Pred == CmpInst::ICMP_EQ || Pred == CmpInst::ICMP_NE) {\n    // Different non-empty allocations that exist at the same time have\n    // different addresses (if the program can tell). Global variables always\n    // exist, so they always exist during the lifetime of each other and all\n    // allocas. Two different allocas usually have different addresses...\n    //\n    // However, if there's an @llvm.stackrestore dynamically in between two\n    // allocas, they may have the same address. It's tempting to reduce the\n    // scope of the problem by only looking at *static* allocas here. That would\n    // cover the majority of allocas while significantly reducing the likelihood\n    // of having an @llvm.stackrestore pop up in the middle. However, it's not\n    // actually impossible for an @llvm.stackrestore to pop up in the middle of\n    // an entry block. Also, if we have a block that's not attached to a\n    // function, we can't tell if it's \"static\" under the current definition.\n    // Theoretically, this problem could be fixed by creating a new kind of\n    // instruction kind specifically for static allocas. Such a new instruction\n    // could be required to be at the top of the entry block, thus preventing it\n    // from being subject to a @llvm.stackrestore. Instcombine could even\n    // convert regular allocas into these special allocas. It'd be nifty.\n    // However, until then, this problem remains open.\n    //\n    // So, we'll assume that two non-empty allocas have different addresses\n    // for now.\n    //\n    // With all that, if the offsets are within the bounds of their allocations\n    // (and not one-past-the-end! so we can't use inbounds!), and their\n    // allocations aren't the same, the pointers are not equal.\n    //\n    // Note that it's not necessary to check for LHS being a global variable\n    // address, due to canonicalization and constant folding.\n    if (isa<AllocaInst>(LHS) &&\n        (isa<AllocaInst>(RHS) || isa<GlobalVariable>(RHS))) {\n      ConstantInt *LHSOffsetCI = dyn_cast<ConstantInt>(LHSOffset);\n      ConstantInt *RHSOffsetCI = dyn_cast<ConstantInt>(RHSOffset);\n      uint64_t LHSSize, RHSSize;\n      ObjectSizeOpts Opts;\n      Opts.NullIsUnknownSize =\n          NullPointerIsDefined(cast<AllocaInst>(LHS)->getFunction());\n      if (LHSOffsetCI && RHSOffsetCI &&\n          getObjectSize(LHS, LHSSize, DL, TLI, Opts) &&\n          getObjectSize(RHS, RHSSize, DL, TLI, Opts)) {\n        const APInt &LHSOffsetValue = LHSOffsetCI->getValue();\n        const APInt &RHSOffsetValue = RHSOffsetCI->getValue();\n        if (!LHSOffsetValue.isNegative() &&\n            !RHSOffsetValue.isNegative() &&\n            LHSOffsetValue.ult(LHSSize) &&\n            RHSOffsetValue.ult(RHSSize)) {\n          return ConstantInt::get(GetCompareTy(LHS),\n                                  !CmpInst::isTrueWhenEqual(Pred));\n        }\n      }\n\n      // Repeat the above check but this time without depending on DataLayout\n      // or being able to compute a precise size.\n      if (!cast<PointerType>(LHS->getType())->isEmptyTy() &&\n          !cast<PointerType>(RHS->getType())->isEmptyTy() &&\n          LHSOffset->isNullValue() &&\n          RHSOffset->isNullValue())\n        return ConstantInt::get(GetCompareTy(LHS),\n                                !CmpInst::isTrueWhenEqual(Pred));\n    }\n\n    // Even if an non-inbounds GEP occurs along the path we can still optimize\n    // equality comparisons concerning the result. We avoid walking the whole\n    // chain again by starting where the last calls to\n    // stripAndComputeConstantOffsets left off and accumulate the offsets.\n    Constant *LHSNoBound = stripAndComputeConstantOffsets(DL, LHS, true);\n    Constant *RHSNoBound = stripAndComputeConstantOffsets(DL, RHS, true);\n    if (LHS == RHS)\n      return ConstantExpr::getICmp(Pred,\n                                   ConstantExpr::getAdd(LHSOffset, LHSNoBound),\n                                   ConstantExpr::getAdd(RHSOffset, RHSNoBound));\n\n    // If one side of the equality comparison must come from a noalias call\n    // (meaning a system memory allocation function), and the other side must\n    // come from a pointer that cannot overlap with dynamically-allocated\n    // memory within the lifetime of the current function (allocas, byval\n    // arguments, globals), then determine the comparison result here.\n    SmallVector<const Value *, 8> LHSUObjs, RHSUObjs;\n    getUnderlyingObjects(LHS, LHSUObjs);\n    getUnderlyingObjects(RHS, RHSUObjs);\n\n    // Is the set of underlying objects all noalias calls?\n    auto IsNAC = [](ArrayRef<const Value *> Objects) {\n      return all_of(Objects, isNoAliasCall);\n    };\n\n    // Is the set of underlying objects all things which must be disjoint from\n    // noalias calls. For allocas, we consider only static ones (dynamic\n    // allocas might be transformed into calls to malloc not simultaneously\n    // live with the compared-to allocation). For globals, we exclude symbols\n    // that might be resolve lazily to symbols in another dynamically-loaded\n    // library (and, thus, could be malloc'ed by the implementation).\n    auto IsAllocDisjoint = [](ArrayRef<const Value *> Objects) {\n      return all_of(Objects, [](const Value *V) {\n        if (const AllocaInst *AI = dyn_cast<AllocaInst>(V))\n          return AI->getParent() && AI->getFunction() && AI->isStaticAlloca();\n        if (const GlobalValue *GV = dyn_cast<GlobalValue>(V))\n          return (GV->hasLocalLinkage() || GV->hasHiddenVisibility() ||\n                  GV->hasProtectedVisibility() || GV->hasGlobalUnnamedAddr()) &&\n                 !GV->isThreadLocal();\n        if (const Argument *A = dyn_cast<Argument>(V))\n          return A->hasByValAttr();\n        return false;\n      });\n    };\n\n    if ((IsNAC(LHSUObjs) && IsAllocDisjoint(RHSUObjs)) ||\n        (IsNAC(RHSUObjs) && IsAllocDisjoint(LHSUObjs)))\n        return ConstantInt::get(GetCompareTy(LHS),\n                                !CmpInst::isTrueWhenEqual(Pred));\n\n    // Fold comparisons for non-escaping pointer even if the allocation call\n    // cannot be elided. We cannot fold malloc comparison to null. Also, the\n    // dynamic allocation call could be either of the operands.\n    Value *MI = nullptr;\n    if (isAllocLikeFn(LHS, TLI) &&\n        llvm::isKnownNonZero(RHS, DL, 0, nullptr, CxtI, DT))\n      MI = LHS;\n    else if (isAllocLikeFn(RHS, TLI) &&\n             llvm::isKnownNonZero(LHS, DL, 0, nullptr, CxtI, DT))\n      MI = RHS;\n    // FIXME: We should also fold the compare when the pointer escapes, but the\n    // compare dominates the pointer escape\n    if (MI && !PointerMayBeCaptured(MI, true, true))\n      return ConstantInt::get(GetCompareTy(LHS),\n                              CmpInst::isFalseWhenEqual(Pred));\n  }\n\n  // Otherwise, fail.\n  return nullptr;\n}\n\n/// Fold an icmp when its operands have i1 scalar type.\nstatic Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,\n                                  Value *RHS, const SimplifyQuery &Q) {\n  Type *ITy = GetCompareTy(LHS); // The return type.\n  Type *OpTy = LHS->getType();   // The operand type.\n  if (!OpTy->isIntOrIntVectorTy(1))\n    return nullptr;\n\n  // A boolean compared to true/false can be simplified in 14 out of the 20\n  // (10 predicates * 2 constants) possible combinations. Cases not handled here\n  // require a 'not' of the LHS, so those must be transformed in InstCombine.\n  if (match(RHS, m_Zero())) {\n    switch (Pred) {\n    case CmpInst::ICMP_NE:  // X !=  0 -> X\n    case CmpInst::ICMP_UGT: // X >u  0 -> X\n    case CmpInst::ICMP_SLT: // X <s  0 -> X\n      return LHS;\n\n    case CmpInst::ICMP_ULT: // X <u  0 -> false\n    case CmpInst::ICMP_SGT: // X >s  0 -> false\n      return getFalse(ITy);\n\n    case CmpInst::ICMP_UGE: // X >=u 0 -> true\n    case CmpInst::ICMP_SLE: // X <=s 0 -> true\n      return getTrue(ITy);\n\n    default: break;\n    }\n  } else if (match(RHS, m_One())) {\n    switch (Pred) {\n    case CmpInst::ICMP_EQ:  // X ==   1 -> X\n    case CmpInst::ICMP_UGE: // X >=u  1 -> X\n    case CmpInst::ICMP_SLE: // X <=s -1 -> X\n      return LHS;\n\n    case CmpInst::ICMP_UGT: // X >u   1 -> false\n    case CmpInst::ICMP_SLT: // X <s  -1 -> false\n      return getFalse(ITy);\n\n    case CmpInst::ICMP_ULE: // X <=u  1 -> true\n    case CmpInst::ICMP_SGE: // X >=s -1 -> true\n      return getTrue(ITy);\n\n    default: break;\n    }\n  }\n\n  switch (Pred) {\n  default:\n    break;\n  case ICmpInst::ICMP_UGE:\n    if (isImpliedCondition(RHS, LHS, Q.DL).getValueOr(false))\n      return getTrue(ITy);\n    break;\n  case ICmpInst::ICMP_SGE:\n    /// For signed comparison, the values for an i1 are 0 and -1\n    /// respectively. This maps into a truth table of:\n    /// LHS | RHS | LHS >=s RHS   | LHS implies RHS\n    ///  0  |  0  |  1 (0 >= 0)   |  1\n    ///  0  |  1  |  1 (0 >= -1)  |  1\n    ///  1  |  0  |  0 (-1 >= 0)  |  0\n    ///  1  |  1  |  1 (-1 >= -1) |  1\n    if (isImpliedCondition(LHS, RHS, Q.DL).getValueOr(false))\n      return getTrue(ITy);\n    break;\n  case ICmpInst::ICMP_ULE:\n    if (isImpliedCondition(LHS, RHS, Q.DL).getValueOr(false))\n      return getTrue(ITy);\n    break;\n  }\n\n  return nullptr;\n}\n\n/// Try hard to fold icmp with zero RHS because this is a common case.\nstatic Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,\n                                   Value *RHS, const SimplifyQuery &Q) {\n  if (!match(RHS, m_Zero()))\n    return nullptr;\n\n  Type *ITy = GetCompareTy(LHS); // The return type.\n  switch (Pred) {\n  default:\n    llvm_unreachable(\"Unknown ICmp predicate!\");\n  case ICmpInst::ICMP_ULT:\n    return getFalse(ITy);\n  case ICmpInst::ICMP_UGE:\n    return getTrue(ITy);\n  case ICmpInst::ICMP_EQ:\n  case ICmpInst::ICMP_ULE:\n    if (isKnownNonZero(LHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT, Q.IIQ.UseInstrInfo))\n      return getFalse(ITy);\n    break;\n  case ICmpInst::ICMP_NE:\n  case ICmpInst::ICMP_UGT:\n    if (isKnownNonZero(LHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT, Q.IIQ.UseInstrInfo))\n      return getTrue(ITy);\n    break;\n  case ICmpInst::ICMP_SLT: {\n    KnownBits LHSKnown = computeKnownBits(LHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n    if (LHSKnown.isNegative())\n      return getTrue(ITy);\n    if (LHSKnown.isNonNegative())\n      return getFalse(ITy);\n    break;\n  }\n  case ICmpInst::ICMP_SLE: {\n    KnownBits LHSKnown = computeKnownBits(LHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n    if (LHSKnown.isNegative())\n      return getTrue(ITy);\n    if (LHSKnown.isNonNegative() &&\n        isKnownNonZero(LHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n      return getFalse(ITy);\n    break;\n  }\n  case ICmpInst::ICMP_SGE: {\n    KnownBits LHSKnown = computeKnownBits(LHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n    if (LHSKnown.isNegative())\n      return getFalse(ITy);\n    if (LHSKnown.isNonNegative())\n      return getTrue(ITy);\n    break;\n  }\n  case ICmpInst::ICMP_SGT: {\n    KnownBits LHSKnown = computeKnownBits(LHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n    if (LHSKnown.isNegative())\n      return getFalse(ITy);\n    if (LHSKnown.isNonNegative() &&\n        isKnownNonZero(LHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n      return getTrue(ITy);\n    break;\n  }\n  }\n\n  return nullptr;\n}\n\nstatic Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,\n                                       Value *RHS, const InstrInfoQuery &IIQ) {\n  Type *ITy = GetCompareTy(RHS); // The return type.\n\n  Value *X;\n  // Sign-bit checks can be optimized to true/false after unsigned\n  // floating-point casts:\n  // icmp slt (bitcast (uitofp X)),  0 --> false\n  // icmp sgt (bitcast (uitofp X)), -1 --> true\n  if (match(LHS, m_BitCast(m_UIToFP(m_Value(X))))) {\n    if (Pred == ICmpInst::ICMP_SLT && match(RHS, m_Zero()))\n      return ConstantInt::getFalse(ITy);\n    if (Pred == ICmpInst::ICMP_SGT && match(RHS, m_AllOnes()))\n      return ConstantInt::getTrue(ITy);\n  }\n\n  const APInt *C;\n  if (!match(RHS, m_APIntAllowUndef(C)))\n    return nullptr;\n\n  // Rule out tautological comparisons (eg., ult 0 or uge 0).\n  ConstantRange RHS_CR = ConstantRange::makeExactICmpRegion(Pred, *C);\n  if (RHS_CR.isEmptySet())\n    return ConstantInt::getFalse(ITy);\n  if (RHS_CR.isFullSet())\n    return ConstantInt::getTrue(ITy);\n\n  ConstantRange LHS_CR = computeConstantRange(LHS, IIQ.UseInstrInfo);\n  if (!LHS_CR.isFullSet()) {\n    if (RHS_CR.contains(LHS_CR))\n      return ConstantInt::getTrue(ITy);\n    if (RHS_CR.inverse().contains(LHS_CR))\n      return ConstantInt::getFalse(ITy);\n  }\n\n  // (mul nuw/nsw X, MulC) != C --> true  (if C is not a multiple of MulC)\n  // (mul nuw/nsw X, MulC) == C --> false (if C is not a multiple of MulC)\n  const APInt *MulC;\n  if (ICmpInst::isEquality(Pred) &&\n      ((match(LHS, m_NUWMul(m_Value(), m_APIntAllowUndef(MulC))) &&\n        *MulC != 0 && C->urem(*MulC) != 0) ||\n       (match(LHS, m_NSWMul(m_Value(), m_APIntAllowUndef(MulC))) &&\n        *MulC != 0 && C->srem(*MulC) != 0)))\n    return ConstantInt::get(ITy, Pred == ICmpInst::ICMP_NE);\n\n  return nullptr;\n}\n\nstatic Value *simplifyICmpWithBinOpOnLHS(\n    CmpInst::Predicate Pred, BinaryOperator *LBO, Value *RHS,\n    const SimplifyQuery &Q, unsigned MaxRecurse) {\n  Type *ITy = GetCompareTy(RHS); // The return type.\n\n  Value *Y = nullptr;\n  // icmp pred (or X, Y), X\n  if (match(LBO, m_c_Or(m_Value(Y), m_Specific(RHS)))) {\n    if (Pred == ICmpInst::ICMP_ULT)\n      return getFalse(ITy);\n    if (Pred == ICmpInst::ICMP_UGE)\n      return getTrue(ITy);\n\n    if (Pred == ICmpInst::ICMP_SLT || Pred == ICmpInst::ICMP_SGE) {\n      KnownBits RHSKnown = computeKnownBits(RHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n      KnownBits YKnown = computeKnownBits(Y, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n      if (RHSKnown.isNonNegative() && YKnown.isNegative())\n        return Pred == ICmpInst::ICMP_SLT ? getTrue(ITy) : getFalse(ITy);\n      if (RHSKnown.isNegative() || YKnown.isNonNegative())\n        return Pred == ICmpInst::ICMP_SLT ? getFalse(ITy) : getTrue(ITy);\n    }\n  }\n\n  // icmp pred (and X, Y), X\n  if (match(LBO, m_c_And(m_Value(), m_Specific(RHS)))) {\n    if (Pred == ICmpInst::ICMP_UGT)\n      return getFalse(ITy);\n    if (Pred == ICmpInst::ICMP_ULE)\n      return getTrue(ITy);\n  }\n\n  // icmp pred (urem X, Y), Y\n  if (match(LBO, m_URem(m_Value(), m_Specific(RHS)))) {\n    switch (Pred) {\n    default:\n      break;\n    case ICmpInst::ICMP_SGT:\n    case ICmpInst::ICMP_SGE: {\n      KnownBits Known = computeKnownBits(RHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n      if (!Known.isNonNegative())\n        break;\n      LLVM_FALLTHROUGH;\n    }\n    case ICmpInst::ICMP_EQ:\n    case ICmpInst::ICMP_UGT:\n    case ICmpInst::ICMP_UGE:\n      return getFalse(ITy);\n    case ICmpInst::ICMP_SLT:\n    case ICmpInst::ICMP_SLE: {\n      KnownBits Known = computeKnownBits(RHS, Q.DL, 0, Q.AC, Q.CxtI, Q.DT);\n      if (!Known.isNonNegative())\n        break;\n      LLVM_FALLTHROUGH;\n    }\n    case ICmpInst::ICMP_NE:\n    case ICmpInst::ICMP_ULT:\n    case ICmpInst::ICMP_ULE:\n      return getTrue(ITy);\n    }\n  }\n\n  // icmp pred (urem X, Y), X\n  if (match(LBO, m_URem(m_Specific(RHS), m_Value()))) {\n    if (Pred == ICmpInst::ICMP_ULE)\n      return getTrue(ITy);\n    if (Pred == ICmpInst::ICMP_UGT)\n      return getFalse(ITy);\n  }\n\n  // x >> y <=u x\n  // x udiv y <=u x.\n  if (match(LBO, m_LShr(m_Specific(RHS), m_Value())) ||\n      match(LBO, m_UDiv(m_Specific(RHS), m_Value()))) {\n    // icmp pred (X op Y), X\n    if (Pred == ICmpInst::ICMP_UGT)\n      return getFalse(ITy);\n    if (Pred == ICmpInst::ICMP_ULE)\n      return getTrue(ITy);\n  }\n\n  // (x*C1)/C2 <= x for C1 <= C2.\n  // This holds even if the multiplication overflows: Assume that x != 0 and\n  // arithmetic is modulo M. For overflow to occur we must have C1 >= M/x and\n  // thus C2 >= M/x. It follows that (x*C1)/C2 <= (M-1)/C2 <= ((M-1)*x)/M < x.\n  //\n  // Additionally, either the multiplication and division might be represented\n  // as shifts:\n  // (x*C1)>>C2 <= x for C1 < 2**C2.\n  // (x<<C1)/C2 <= x for 2**C1 < C2.\n  const APInt *C1, *C2;\n  if ((match(LBO, m_UDiv(m_Mul(m_Specific(RHS), m_APInt(C1)), m_APInt(C2))) &&\n       C1->ule(*C2)) ||\n      (match(LBO, m_LShr(m_Mul(m_Specific(RHS), m_APInt(C1)), m_APInt(C2))) &&\n       C1->ule(APInt(C2->getBitWidth(), 1) << *C2)) ||\n      (match(LBO, m_UDiv(m_Shl(m_Specific(RHS), m_APInt(C1)), m_APInt(C2))) &&\n       (APInt(C1->getBitWidth(), 1) << *C1).ule(*C2))) {\n    if (Pred == ICmpInst::ICMP_UGT)\n      return getFalse(ITy);\n    if (Pred == ICmpInst::ICMP_ULE)\n      return getTrue(ITy);\n  }\n\n  return nullptr;\n}\n\n\n// If only one of the icmp's operands has NSW flags, try to prove that:\n//\n//   icmp slt (x + C1), (x +nsw C2)\n//\n// is equivalent to:\n//\n//   icmp slt C1, C2\n//\n// which is true if x + C2 has the NSW flags set and:\n// *) C1 < C2 && C1 >= 0, or\n// *) C2 < C1 && C1 <= 0.\n//\nstatic bool trySimplifyICmpWithAdds(CmpInst::Predicate Pred, Value *LHS,\n                                    Value *RHS) {\n  // TODO: only support icmp slt for now.\n  if (Pred != CmpInst::ICMP_SLT)\n    return false;\n\n  // Canonicalize nsw add as RHS.\n  if (!match(RHS, m_NSWAdd(m_Value(), m_Value())))\n    std::swap(LHS, RHS);\n  if (!match(RHS, m_NSWAdd(m_Value(), m_Value())))\n    return false;\n\n  Value *X;\n  const APInt *C1, *C2;\n  if (!match(LHS, m_c_Add(m_Value(X), m_APInt(C1))) ||\n      !match(RHS, m_c_Add(m_Specific(X), m_APInt(C2))))\n    return false;\n\n  return (C1->slt(*C2) && C1->isNonNegative()) ||\n         (C2->slt(*C1) && C1->isNonPositive());\n}\n\n\n/// TODO: A large part of this logic is duplicated in InstCombine's\n/// foldICmpBinOp(). We should be able to share that and avoid the code\n/// duplication.\nstatic Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,\n                                    Value *RHS, const SimplifyQuery &Q,\n                                    unsigned MaxRecurse) {\n  BinaryOperator *LBO = dyn_cast<BinaryOperator>(LHS);\n  BinaryOperator *RBO = dyn_cast<BinaryOperator>(RHS);\n  if (MaxRecurse && (LBO || RBO)) {\n    // Analyze the case when either LHS or RHS is an add instruction.\n    Value *A = nullptr, *B = nullptr, *C = nullptr, *D = nullptr;\n    // LHS = A + B (or A and B are null); RHS = C + D (or C and D are null).\n    bool NoLHSWrapProblem = false, NoRHSWrapProblem = false;\n    if (LBO && LBO->getOpcode() == Instruction::Add) {\n      A = LBO->getOperand(0);\n      B = LBO->getOperand(1);\n      NoLHSWrapProblem =\n          ICmpInst::isEquality(Pred) ||\n          (CmpInst::isUnsigned(Pred) &&\n           Q.IIQ.hasNoUnsignedWrap(cast<OverflowingBinaryOperator>(LBO))) ||\n          (CmpInst::isSigned(Pred) &&\n           Q.IIQ.hasNoSignedWrap(cast<OverflowingBinaryOperator>(LBO)));\n    }\n    if (RBO && RBO->getOpcode() == Instruction::Add) {\n      C = RBO->getOperand(0);\n      D = RBO->getOperand(1);\n      NoRHSWrapProblem =\n          ICmpInst::isEquality(Pred) ||\n          (CmpInst::isUnsigned(Pred) &&\n           Q.IIQ.hasNoUnsignedWrap(cast<OverflowingBinaryOperator>(RBO))) ||\n          (CmpInst::isSigned(Pred) &&\n           Q.IIQ.hasNoSignedWrap(cast<OverflowingBinaryOperator>(RBO)));\n    }\n\n    // icmp (X+Y), X -> icmp Y, 0 for equalities or if there is no overflow.\n    if ((A == RHS || B == RHS) && NoLHSWrapProblem)\n      if (Value *V = SimplifyICmpInst(Pred, A == RHS ? B : A,\n                                      Constant::getNullValue(RHS->getType()), Q,\n                                      MaxRecurse - 1))\n        return V;\n\n    // icmp X, (X+Y) -> icmp 0, Y for equalities or if there is no overflow.\n    if ((C == LHS || D == LHS) && NoRHSWrapProblem)\n      if (Value *V =\n              SimplifyICmpInst(Pred, Constant::getNullValue(LHS->getType()),\n                               C == LHS ? D : C, Q, MaxRecurse - 1))\n        return V;\n\n    // icmp (X+Y), (X+Z) -> icmp Y,Z for equalities or if there is no overflow.\n    bool CanSimplify = (NoLHSWrapProblem && NoRHSWrapProblem) ||\n                       trySimplifyICmpWithAdds(Pred, LHS, RHS);\n    if (A && C && (A == C || A == D || B == C || B == D) && CanSimplify) {\n      // Determine Y and Z in the form icmp (X+Y), (X+Z).\n      Value *Y, *Z;\n      if (A == C) {\n        // C + B == C + D  ->  B == D\n        Y = B;\n        Z = D;\n      } else if (A == D) {\n        // D + B == C + D  ->  B == C\n        Y = B;\n        Z = C;\n      } else if (B == C) {\n        // A + C == C + D  ->  A == D\n        Y = A;\n        Z = D;\n      } else {\n        assert(B == D);\n        // A + D == C + D  ->  A == C\n        Y = A;\n        Z = C;\n      }\n      if (Value *V = SimplifyICmpInst(Pred, Y, Z, Q, MaxRecurse - 1))\n        return V;\n    }\n  }\n\n  if (LBO)\n    if (Value *V = simplifyICmpWithBinOpOnLHS(Pred, LBO, RHS, Q, MaxRecurse))\n      return V;\n\n  if (RBO)\n    if (Value *V = simplifyICmpWithBinOpOnLHS(\n            ICmpInst::getSwappedPredicate(Pred), RBO, LHS, Q, MaxRecurse))\n      return V;\n\n  // 0 - (zext X) pred C\n  if (!CmpInst::isUnsigned(Pred) && match(LHS, m_Neg(m_ZExt(m_Value())))) {\n    const APInt *C;\n    if (match(RHS, m_APInt(C))) {\n      if (C->isStrictlyPositive()) {\n        if (Pred == ICmpInst::ICMP_SLT || Pred == ICmpInst::ICMP_NE)\n          return ConstantInt::getTrue(GetCompareTy(RHS));\n        if (Pred == ICmpInst::ICMP_SGE || Pred == ICmpInst::ICMP_EQ)\n          return ConstantInt::getFalse(GetCompareTy(RHS));\n      }\n      if (C->isNonNegative()) {\n        if (Pred == ICmpInst::ICMP_SLE)\n          return ConstantInt::getTrue(GetCompareTy(RHS));\n        if (Pred == ICmpInst::ICMP_SGT)\n          return ConstantInt::getFalse(GetCompareTy(RHS));\n      }\n    }\n  }\n\n  //   If C2 is a power-of-2 and C is not:\n  //   (C2 << X) == C --> false\n  //   (C2 << X) != C --> true\n  const APInt *C;\n  if (match(LHS, m_Shl(m_Power2(), m_Value())) &&\n      match(RHS, m_APIntAllowUndef(C)) && !C->isPowerOf2()) {\n    // C2 << X can equal zero in some circumstances.\n    // This simplification might be unsafe if C is zero.\n    //\n    // We know it is safe if:\n    // - The shift is nsw. We can't shift out the one bit.\n    // - The shift is nuw. We can't shift out the one bit.\n    // - C2 is one.\n    // - C isn't zero.\n    if (Q.IIQ.hasNoSignedWrap(cast<OverflowingBinaryOperator>(LBO)) ||\n        Q.IIQ.hasNoUnsignedWrap(cast<OverflowingBinaryOperator>(LBO)) ||\n        match(LHS, m_Shl(m_One(), m_Value())) || !C->isNullValue()) {\n      if (Pred == ICmpInst::ICMP_EQ)\n        return ConstantInt::getFalse(GetCompareTy(RHS));\n      if (Pred == ICmpInst::ICMP_NE)\n        return ConstantInt::getTrue(GetCompareTy(RHS));\n    }\n  }\n\n  // TODO: This is overly constrained. LHS can be any power-of-2.\n  // (1 << X)  >u 0x8000 --> false\n  // (1 << X) <=u 0x8000 --> true\n  if (match(LHS, m_Shl(m_One(), m_Value())) && match(RHS, m_SignMask())) {\n    if (Pred == ICmpInst::ICMP_UGT)\n      return ConstantInt::getFalse(GetCompareTy(RHS));\n    if (Pred == ICmpInst::ICMP_ULE)\n      return ConstantInt::getTrue(GetCompareTy(RHS));\n  }\n\n  if (MaxRecurse && LBO && RBO && LBO->getOpcode() == RBO->getOpcode() &&\n      LBO->getOperand(1) == RBO->getOperand(1)) {\n    switch (LBO->getOpcode()) {\n    default:\n      break;\n    case Instruction::UDiv:\n    case Instruction::LShr:\n      if (ICmpInst::isSigned(Pred) || !Q.IIQ.isExact(LBO) ||\n          !Q.IIQ.isExact(RBO))\n        break;\n      if (Value *V = SimplifyICmpInst(Pred, LBO->getOperand(0),\n                                      RBO->getOperand(0), Q, MaxRecurse - 1))\n          return V;\n      break;\n    case Instruction::SDiv:\n      if (!ICmpInst::isEquality(Pred) || !Q.IIQ.isExact(LBO) ||\n          !Q.IIQ.isExact(RBO))\n        break;\n      if (Value *V = SimplifyICmpInst(Pred, LBO->getOperand(0),\n                                      RBO->getOperand(0), Q, MaxRecurse - 1))\n        return V;\n      break;\n    case Instruction::AShr:\n      if (!Q.IIQ.isExact(LBO) || !Q.IIQ.isExact(RBO))\n        break;\n      if (Value *V = SimplifyICmpInst(Pred, LBO->getOperand(0),\n                                      RBO->getOperand(0), Q, MaxRecurse - 1))\n        return V;\n      break;\n    case Instruction::Shl: {\n      bool NUW = Q.IIQ.hasNoUnsignedWrap(LBO) && Q.IIQ.hasNoUnsignedWrap(RBO);\n      bool NSW = Q.IIQ.hasNoSignedWrap(LBO) && Q.IIQ.hasNoSignedWrap(RBO);\n      if (!NUW && !NSW)\n        break;\n      if (!NSW && ICmpInst::isSigned(Pred))\n        break;\n      if (Value *V = SimplifyICmpInst(Pred, LBO->getOperand(0),\n                                      RBO->getOperand(0), Q, MaxRecurse - 1))\n        return V;\n      break;\n    }\n    }\n  }\n  return nullptr;\n}\n\n/// Simplify integer comparisons where at least one operand of the compare\n/// matches an integer min/max idiom.\nstatic Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,\n                                     Value *RHS, const SimplifyQuery &Q,\n                                     unsigned MaxRecurse) {\n  Type *ITy = GetCompareTy(LHS); // The return type.\n  Value *A, *B;\n  CmpInst::Predicate P = CmpInst::BAD_ICMP_PREDICATE;\n  CmpInst::Predicate EqP; // Chosen so that \"A == max/min(A,B)\" iff \"A EqP B\".\n\n  // Signed variants on \"max(a,b)>=a -> true\".\n  if (match(LHS, m_SMax(m_Value(A), m_Value(B))) && (A == RHS || B == RHS)) {\n    if (A != RHS)\n      std::swap(A, B);       // smax(A, B) pred A.\n    EqP = CmpInst::ICMP_SGE; // \"A == smax(A, B)\" iff \"A sge B\".\n    // We analyze this as smax(A, B) pred A.\n    P = Pred;\n  } else if (match(RHS, m_SMax(m_Value(A), m_Value(B))) &&\n             (A == LHS || B == LHS)) {\n    if (A != LHS)\n      std::swap(A, B);       // A pred smax(A, B).\n    EqP = CmpInst::ICMP_SGE; // \"A == smax(A, B)\" iff \"A sge B\".\n    // We analyze this as smax(A, B) swapped-pred A.\n    P = CmpInst::getSwappedPredicate(Pred);\n  } else if (match(LHS, m_SMin(m_Value(A), m_Value(B))) &&\n             (A == RHS || B == RHS)) {\n    if (A != RHS)\n      std::swap(A, B);       // smin(A, B) pred A.\n    EqP = CmpInst::ICMP_SLE; // \"A == smin(A, B)\" iff \"A sle B\".\n    // We analyze this as smax(-A, -B) swapped-pred -A.\n    // Note that we do not need to actually form -A or -B thanks to EqP.\n    P = CmpInst::getSwappedPredicate(Pred);\n  } else if (match(RHS, m_SMin(m_Value(A), m_Value(B))) &&\n             (A == LHS || B == LHS)) {\n    if (A != LHS)\n      std::swap(A, B);       // A pred smin(A, B).\n    EqP = CmpInst::ICMP_SLE; // \"A == smin(A, B)\" iff \"A sle B\".\n    // We analyze this as smax(-A, -B) pred -A.\n    // Note that we do not need to actually form -A or -B thanks to EqP.\n    P = Pred;\n  }\n  if (P != CmpInst::BAD_ICMP_PREDICATE) {\n    // Cases correspond to \"max(A, B) p A\".\n    switch (P) {\n    default:\n      break;\n    case CmpInst::ICMP_EQ:\n    case CmpInst::ICMP_SLE:\n      // Equivalent to \"A EqP B\".  This may be the same as the condition tested\n      // in the max/min; if so, we can just return that.\n      if (Value *V = ExtractEquivalentCondition(LHS, EqP, A, B))\n        return V;\n      if (Value *V = ExtractEquivalentCondition(RHS, EqP, A, B))\n        return V;\n      // Otherwise, see if \"A EqP B\" simplifies.\n      if (MaxRecurse)\n        if (Value *V = SimplifyICmpInst(EqP, A, B, Q, MaxRecurse - 1))\n          return V;\n      break;\n    case CmpInst::ICMP_NE:\n    case CmpInst::ICMP_SGT: {\n      CmpInst::Predicate InvEqP = CmpInst::getInversePredicate(EqP);\n      // Equivalent to \"A InvEqP B\".  This may be the same as the condition\n      // tested in the max/min; if so, we can just return that.\n      if (Value *V = ExtractEquivalentCondition(LHS, InvEqP, A, B))\n        return V;\n      if (Value *V = ExtractEquivalentCondition(RHS, InvEqP, A, B))\n        return V;\n      // Otherwise, see if \"A InvEqP B\" simplifies.\n      if (MaxRecurse)\n        if (Value *V = SimplifyICmpInst(InvEqP, A, B, Q, MaxRecurse - 1))\n          return V;\n      break;\n    }\n    case CmpInst::ICMP_SGE:\n      // Always true.\n      return getTrue(ITy);\n    case CmpInst::ICMP_SLT:\n      // Always false.\n      return getFalse(ITy);\n    }\n  }\n\n  // Unsigned variants on \"max(a,b)>=a -> true\".\n  P = CmpInst::BAD_ICMP_PREDICATE;\n  if (match(LHS, m_UMax(m_Value(A), m_Value(B))) && (A == RHS || B == RHS)) {\n    if (A != RHS)\n      std::swap(A, B);       // umax(A, B) pred A.\n    EqP = CmpInst::ICMP_UGE; // \"A == umax(A, B)\" iff \"A uge B\".\n    // We analyze this as umax(A, B) pred A.\n    P = Pred;\n  } else if (match(RHS, m_UMax(m_Value(A), m_Value(B))) &&\n             (A == LHS || B == LHS)) {\n    if (A != LHS)\n      std::swap(A, B);       // A pred umax(A, B).\n    EqP = CmpInst::ICMP_UGE; // \"A == umax(A, B)\" iff \"A uge B\".\n    // We analyze this as umax(A, B) swapped-pred A.\n    P = CmpInst::getSwappedPredicate(Pred);\n  } else if (match(LHS, m_UMin(m_Value(A), m_Value(B))) &&\n             (A == RHS || B == RHS)) {\n    if (A != RHS)\n      std::swap(A, B);       // umin(A, B) pred A.\n    EqP = CmpInst::ICMP_ULE; // \"A == umin(A, B)\" iff \"A ule B\".\n    // We analyze this as umax(-A, -B) swapped-pred -A.\n    // Note that we do not need to actually form -A or -B thanks to EqP.\n    P = CmpInst::getSwappedPredicate(Pred);\n  } else if (match(RHS, m_UMin(m_Value(A), m_Value(B))) &&\n             (A == LHS || B == LHS)) {\n    if (A != LHS)\n      std::swap(A, B);       // A pred umin(A, B).\n    EqP = CmpInst::ICMP_ULE; // \"A == umin(A, B)\" iff \"A ule B\".\n    // We analyze this as umax(-A, -B) pred -A.\n    // Note that we do not need to actually form -A or -B thanks to EqP.\n    P = Pred;\n  }\n  if (P != CmpInst::BAD_ICMP_PREDICATE) {\n    // Cases correspond to \"max(A, B) p A\".\n    switch (P) {\n    default:\n      break;\n    case CmpInst::ICMP_EQ:\n    case CmpInst::ICMP_ULE:\n      // Equivalent to \"A EqP B\".  This may be the same as the condition tested\n      // in the max/min; if so, we can just return that.\n      if (Value *V = ExtractEquivalentCondition(LHS, EqP, A, B))\n        return V;\n      if (Value *V = ExtractEquivalentCondition(RHS, EqP, A, B))\n        return V;\n      // Otherwise, see if \"A EqP B\" simplifies.\n      if (MaxRecurse)\n        if (Value *V = SimplifyICmpInst(EqP, A, B, Q, MaxRecurse - 1))\n          return V;\n      break;\n    case CmpInst::ICMP_NE:\n    case CmpInst::ICMP_UGT: {\n      CmpInst::Predicate InvEqP = CmpInst::getInversePredicate(EqP);\n      // Equivalent to \"A InvEqP B\".  This may be the same as the condition\n      // tested in the max/min; if so, we can just return that.\n      if (Value *V = ExtractEquivalentCondition(LHS, InvEqP, A, B))\n        return V;\n      if (Value *V = ExtractEquivalentCondition(RHS, InvEqP, A, B))\n        return V;\n      // Otherwise, see if \"A InvEqP B\" simplifies.\n      if (MaxRecurse)\n        if (Value *V = SimplifyICmpInst(InvEqP, A, B, Q, MaxRecurse - 1))\n          return V;\n      break;\n    }\n    case CmpInst::ICMP_UGE:\n      return getTrue(ITy);\n    case CmpInst::ICMP_ULT:\n      return getFalse(ITy);\n    }\n  }\n\n  // Comparing 1 each of min/max with a common operand?\n  // Canonicalize min operand to RHS.\n  if (match(LHS, m_UMin(m_Value(), m_Value())) ||\n      match(LHS, m_SMin(m_Value(), m_Value()))) {\n    std::swap(LHS, RHS);\n    Pred = ICmpInst::getSwappedPredicate(Pred);\n  }\n\n  Value *C, *D;\n  if (match(LHS, m_SMax(m_Value(A), m_Value(B))) &&\n      match(RHS, m_SMin(m_Value(C), m_Value(D))) &&\n      (A == C || A == D || B == C || B == D)) {\n    // smax(A, B) >=s smin(A, D) --> true\n    if (Pred == CmpInst::ICMP_SGE)\n      return getTrue(ITy);\n    // smax(A, B) <s smin(A, D) --> false\n    if (Pred == CmpInst::ICMP_SLT)\n      return getFalse(ITy);\n  } else if (match(LHS, m_UMax(m_Value(A), m_Value(B))) &&\n             match(RHS, m_UMin(m_Value(C), m_Value(D))) &&\n             (A == C || A == D || B == C || B == D)) {\n    // umax(A, B) >=u umin(A, D) --> true\n    if (Pred == CmpInst::ICMP_UGE)\n      return getTrue(ITy);\n    // umax(A, B) <u umin(A, D) --> false\n    if (Pred == CmpInst::ICMP_ULT)\n      return getFalse(ITy);\n  }\n\n  return nullptr;\n}\n\nstatic Value *simplifyICmpWithDominatingAssume(CmpInst::Predicate Predicate,\n                                               Value *LHS, Value *RHS,\n                                               const SimplifyQuery &Q) {\n  // Gracefully handle instructions that have not been inserted yet.\n  if (!Q.AC || !Q.CxtI || !Q.CxtI->getParent())\n    return nullptr;\n\n  for (Value *AssumeBaseOp : {LHS, RHS}) {\n    for (auto &AssumeVH : Q.AC->assumptionsFor(AssumeBaseOp)) {\n      if (!AssumeVH)\n        continue;\n\n      CallInst *Assume = cast<CallInst>(AssumeVH);\n      if (Optional<bool> Imp =\n              isImpliedCondition(Assume->getArgOperand(0), Predicate, LHS, RHS,\n                                 Q.DL))\n        if (isValidAssumeForContext(Assume, Q.CxtI, Q.DT))\n          return ConstantInt::get(GetCompareTy(LHS), *Imp);\n    }\n  }\n\n  return nullptr;\n}\n\n/// Given operands for an ICmpInst, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyICmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                               const SimplifyQuery &Q, unsigned MaxRecurse) {\n  CmpInst::Predicate Pred = (CmpInst::Predicate)Predicate;\n  assert(CmpInst::isIntPredicate(Pred) && \"Not an integer compare!\");\n\n  if (Constant *CLHS = dyn_cast<Constant>(LHS)) {\n    if (Constant *CRHS = dyn_cast<Constant>(RHS))\n      return ConstantFoldCompareInstOperands(Pred, CLHS, CRHS, Q.DL, Q.TLI);\n\n    // If we have a constant, make sure it is on the RHS.\n    std::swap(LHS, RHS);\n    Pred = CmpInst::getSwappedPredicate(Pred);\n  }\n  assert(!isa<UndefValue>(LHS) && \"Unexpected icmp undef,%X\");\n\n  Type *ITy = GetCompareTy(LHS); // The return type.\n\n  // For EQ and NE, we can always pick a value for the undef to make the\n  // predicate pass or fail, so we can return undef.\n  // Matches behavior in llvm::ConstantFoldCompareInstruction.\n  if (Q.isUndefValue(RHS) && ICmpInst::isEquality(Pred))\n    return UndefValue::get(ITy);\n\n  // icmp X, X -> true/false\n  // icmp X, undef -> true/false because undef could be X.\n  if (LHS == RHS || Q.isUndefValue(RHS))\n    return ConstantInt::get(ITy, CmpInst::isTrueWhenEqual(Pred));\n\n  if (Value *V = simplifyICmpOfBools(Pred, LHS, RHS, Q))\n    return V;\n\n  if (Value *V = simplifyICmpWithZero(Pred, LHS, RHS, Q))\n    return V;\n\n  if (Value *V = simplifyICmpWithConstant(Pred, LHS, RHS, Q.IIQ))\n    return V;\n\n  // If both operands have range metadata, use the metadata\n  // to simplify the comparison.\n  if (isa<Instruction>(RHS) && isa<Instruction>(LHS)) {\n    auto RHS_Instr = cast<Instruction>(RHS);\n    auto LHS_Instr = cast<Instruction>(LHS);\n\n    if (Q.IIQ.getMetadata(RHS_Instr, LLVMContext::MD_range) &&\n        Q.IIQ.getMetadata(LHS_Instr, LLVMContext::MD_range)) {\n      auto RHS_CR = getConstantRangeFromMetadata(\n          *RHS_Instr->getMetadata(LLVMContext::MD_range));\n      auto LHS_CR = getConstantRangeFromMetadata(\n          *LHS_Instr->getMetadata(LLVMContext::MD_range));\n\n      auto Satisfied_CR = ConstantRange::makeSatisfyingICmpRegion(Pred, RHS_CR);\n      if (Satisfied_CR.contains(LHS_CR))\n        return ConstantInt::getTrue(RHS->getContext());\n\n      auto InversedSatisfied_CR = ConstantRange::makeSatisfyingICmpRegion(\n                CmpInst::getInversePredicate(Pred), RHS_CR);\n      if (InversedSatisfied_CR.contains(LHS_CR))\n        return ConstantInt::getFalse(RHS->getContext());\n    }\n  }\n\n  // Compare of cast, for example (zext X) != 0 -> X != 0\n  if (isa<CastInst>(LHS) && (isa<Constant>(RHS) || isa<CastInst>(RHS))) {\n    Instruction *LI = cast<CastInst>(LHS);\n    Value *SrcOp = LI->getOperand(0);\n    Type *SrcTy = SrcOp->getType();\n    Type *DstTy = LI->getType();\n\n    // Turn icmp (ptrtoint x), (ptrtoint/constant) into a compare of the input\n    // if the integer type is the same size as the pointer type.\n    if (MaxRecurse && isa<PtrToIntInst>(LI) &&\n        Q.DL.getTypeSizeInBits(SrcTy) == DstTy->getPrimitiveSizeInBits()) {\n      if (Constant *RHSC = dyn_cast<Constant>(RHS)) {\n        // Transfer the cast to the constant.\n        if (Value *V = SimplifyICmpInst(Pred, SrcOp,\n                                        ConstantExpr::getIntToPtr(RHSC, SrcTy),\n                                        Q, MaxRecurse-1))\n          return V;\n      } else if (PtrToIntInst *RI = dyn_cast<PtrToIntInst>(RHS)) {\n        if (RI->getOperand(0)->getType() == SrcTy)\n          // Compare without the cast.\n          if (Value *V = SimplifyICmpInst(Pred, SrcOp, RI->getOperand(0),\n                                          Q, MaxRecurse-1))\n            return V;\n      }\n    }\n\n    if (isa<ZExtInst>(LHS)) {\n      // Turn icmp (zext X), (zext Y) into a compare of X and Y if they have the\n      // same type.\n      if (ZExtInst *RI = dyn_cast<ZExtInst>(RHS)) {\n        if (MaxRecurse && SrcTy == RI->getOperand(0)->getType())\n          // Compare X and Y.  Note that signed predicates become unsigned.\n          if (Value *V = SimplifyICmpInst(ICmpInst::getUnsignedPredicate(Pred),\n                                          SrcOp, RI->getOperand(0), Q,\n                                          MaxRecurse-1))\n            return V;\n      }\n      // Fold (zext X) ule (sext X), (zext X) sge (sext X) to true.\n      else if (SExtInst *RI = dyn_cast<SExtInst>(RHS)) {\n        if (SrcOp == RI->getOperand(0)) {\n          if (Pred == ICmpInst::ICMP_ULE || Pred == ICmpInst::ICMP_SGE)\n            return ConstantInt::getTrue(ITy);\n          if (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_SLT)\n            return ConstantInt::getFalse(ITy);\n        }\n      }\n      // Turn icmp (zext X), Cst into a compare of X and Cst if Cst is extended\n      // too.  If not, then try to deduce the result of the comparison.\n      else if (ConstantInt *CI = dyn_cast<ConstantInt>(RHS)) {\n        // Compute the constant that would happen if we truncated to SrcTy then\n        // reextended to DstTy.\n        Constant *Trunc = ConstantExpr::getTrunc(CI, SrcTy);\n        Constant *RExt = ConstantExpr::getCast(CastInst::ZExt, Trunc, DstTy);\n\n        // If the re-extended constant didn't change then this is effectively\n        // also a case of comparing two zero-extended values.\n        if (RExt == CI && MaxRecurse)\n          if (Value *V = SimplifyICmpInst(ICmpInst::getUnsignedPredicate(Pred),\n                                        SrcOp, Trunc, Q, MaxRecurse-1))\n            return V;\n\n        // Otherwise the upper bits of LHS are zero while RHS has a non-zero bit\n        // there.  Use this to work out the result of the comparison.\n        if (RExt != CI) {\n          switch (Pred) {\n          default: llvm_unreachable(\"Unknown ICmp predicate!\");\n          // LHS <u RHS.\n          case ICmpInst::ICMP_EQ:\n          case ICmpInst::ICMP_UGT:\n          case ICmpInst::ICMP_UGE:\n            return ConstantInt::getFalse(CI->getContext());\n\n          case ICmpInst::ICMP_NE:\n          case ICmpInst::ICMP_ULT:\n          case ICmpInst::ICMP_ULE:\n            return ConstantInt::getTrue(CI->getContext());\n\n          // LHS is non-negative.  If RHS is negative then LHS >s LHS.  If RHS\n          // is non-negative then LHS <s RHS.\n          case ICmpInst::ICMP_SGT:\n          case ICmpInst::ICMP_SGE:\n            return CI->getValue().isNegative() ?\n              ConstantInt::getTrue(CI->getContext()) :\n              ConstantInt::getFalse(CI->getContext());\n\n          case ICmpInst::ICMP_SLT:\n          case ICmpInst::ICMP_SLE:\n            return CI->getValue().isNegative() ?\n              ConstantInt::getFalse(CI->getContext()) :\n              ConstantInt::getTrue(CI->getContext());\n          }\n        }\n      }\n    }\n\n    if (isa<SExtInst>(LHS)) {\n      // Turn icmp (sext X), (sext Y) into a compare of X and Y if they have the\n      // same type.\n      if (SExtInst *RI = dyn_cast<SExtInst>(RHS)) {\n        if (MaxRecurse && SrcTy == RI->getOperand(0)->getType())\n          // Compare X and Y.  Note that the predicate does not change.\n          if (Value *V = SimplifyICmpInst(Pred, SrcOp, RI->getOperand(0),\n                                          Q, MaxRecurse-1))\n            return V;\n      }\n      // Fold (sext X) uge (zext X), (sext X) sle (zext X) to true.\n      else if (ZExtInst *RI = dyn_cast<ZExtInst>(RHS)) {\n        if (SrcOp == RI->getOperand(0)) {\n          if (Pred == ICmpInst::ICMP_UGE || Pred == ICmpInst::ICMP_SLE)\n            return ConstantInt::getTrue(ITy);\n          if (Pred == ICmpInst::ICMP_ULT || Pred == ICmpInst::ICMP_SGT)\n            return ConstantInt::getFalse(ITy);\n        }\n      }\n      // Turn icmp (sext X), Cst into a compare of X and Cst if Cst is extended\n      // too.  If not, then try to deduce the result of the comparison.\n      else if (ConstantInt *CI = dyn_cast<ConstantInt>(RHS)) {\n        // Compute the constant that would happen if we truncated to SrcTy then\n        // reextended to DstTy.\n        Constant *Trunc = ConstantExpr::getTrunc(CI, SrcTy);\n        Constant *RExt = ConstantExpr::getCast(CastInst::SExt, Trunc, DstTy);\n\n        // If the re-extended constant didn't change then this is effectively\n        // also a case of comparing two sign-extended values.\n        if (RExt == CI && MaxRecurse)\n          if (Value *V = SimplifyICmpInst(Pred, SrcOp, Trunc, Q, MaxRecurse-1))\n            return V;\n\n        // Otherwise the upper bits of LHS are all equal, while RHS has varying\n        // bits there.  Use this to work out the result of the comparison.\n        if (RExt != CI) {\n          switch (Pred) {\n          default: llvm_unreachable(\"Unknown ICmp predicate!\");\n          case ICmpInst::ICMP_EQ:\n            return ConstantInt::getFalse(CI->getContext());\n          case ICmpInst::ICMP_NE:\n            return ConstantInt::getTrue(CI->getContext());\n\n          // If RHS is non-negative then LHS <s RHS.  If RHS is negative then\n          // LHS >s RHS.\n          case ICmpInst::ICMP_SGT:\n          case ICmpInst::ICMP_SGE:\n            return CI->getValue().isNegative() ?\n              ConstantInt::getTrue(CI->getContext()) :\n              ConstantInt::getFalse(CI->getContext());\n          case ICmpInst::ICMP_SLT:\n          case ICmpInst::ICMP_SLE:\n            return CI->getValue().isNegative() ?\n              ConstantInt::getFalse(CI->getContext()) :\n              ConstantInt::getTrue(CI->getContext());\n\n          // If LHS is non-negative then LHS <u RHS.  If LHS is negative then\n          // LHS >u RHS.\n          case ICmpInst::ICMP_UGT:\n          case ICmpInst::ICMP_UGE:\n            // Comparison is true iff the LHS <s 0.\n            if (MaxRecurse)\n              if (Value *V = SimplifyICmpInst(ICmpInst::ICMP_SLT, SrcOp,\n                                              Constant::getNullValue(SrcTy),\n                                              Q, MaxRecurse-1))\n                return V;\n            break;\n          case ICmpInst::ICMP_ULT:\n          case ICmpInst::ICMP_ULE:\n            // Comparison is true iff the LHS >=s 0.\n            if (MaxRecurse)\n              if (Value *V = SimplifyICmpInst(ICmpInst::ICMP_SGE, SrcOp,\n                                              Constant::getNullValue(SrcTy),\n                                              Q, MaxRecurse-1))\n                return V;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // icmp eq|ne X, Y -> false|true if X != Y\n  if (ICmpInst::isEquality(Pred) &&\n      isKnownNonEqual(LHS, RHS, Q.DL, Q.AC, Q.CxtI, Q.DT, Q.IIQ.UseInstrInfo)) {\n    return Pred == ICmpInst::ICMP_NE ? getTrue(ITy) : getFalse(ITy);\n  }\n\n  if (Value *V = simplifyICmpWithBinOp(Pred, LHS, RHS, Q, MaxRecurse))\n    return V;\n\n  if (Value *V = simplifyICmpWithMinMax(Pred, LHS, RHS, Q, MaxRecurse))\n    return V;\n\n  if (Value *V = simplifyICmpWithDominatingAssume(Pred, LHS, RHS, Q))\n    return V;\n\n  // Simplify comparisons of related pointers using a powerful, recursive\n  // GEP-walk when we have target data available..\n  if (LHS->getType()->isPointerTy())\n    if (auto *C = computePointerICmp(Q.DL, Q.TLI, Q.DT, Pred, Q.AC, Q.CxtI,\n                                     Q.IIQ, LHS, RHS))\n      return C;\n  if (auto *CLHS = dyn_cast<PtrToIntOperator>(LHS))\n    if (auto *CRHS = dyn_cast<PtrToIntOperator>(RHS))\n      if (Q.DL.getTypeSizeInBits(CLHS->getPointerOperandType()) ==\n              Q.DL.getTypeSizeInBits(CLHS->getType()) &&\n          Q.DL.getTypeSizeInBits(CRHS->getPointerOperandType()) ==\n              Q.DL.getTypeSizeInBits(CRHS->getType()))\n        if (auto *C = computePointerICmp(Q.DL, Q.TLI, Q.DT, Pred, Q.AC, Q.CxtI,\n                                         Q.IIQ, CLHS->getPointerOperand(),\n                                         CRHS->getPointerOperand()))\n          return C;\n\n  if (GetElementPtrInst *GLHS = dyn_cast<GetElementPtrInst>(LHS)) {\n    if (GEPOperator *GRHS = dyn_cast<GEPOperator>(RHS)) {\n      if (GLHS->getPointerOperand() == GRHS->getPointerOperand() &&\n          GLHS->hasAllConstantIndices() && GRHS->hasAllConstantIndices() &&\n          (ICmpInst::isEquality(Pred) ||\n           (GLHS->isInBounds() && GRHS->isInBounds() &&\n            Pred == ICmpInst::getSignedPredicate(Pred)))) {\n        // The bases are equal and the indices are constant.  Build a constant\n        // expression GEP with the same indices and a null base pointer to see\n        // what constant folding can make out of it.\n        Constant *Null = Constant::getNullValue(GLHS->getPointerOperandType());\n        SmallVector<Value *, 4> IndicesLHS(GLHS->indices());\n        Constant *NewLHS = ConstantExpr::getGetElementPtr(\n            GLHS->getSourceElementType(), Null, IndicesLHS);\n\n        SmallVector<Value *, 4> IndicesRHS(GRHS->idx_begin(), GRHS->idx_end());\n        Constant *NewRHS = ConstantExpr::getGetElementPtr(\n            GLHS->getSourceElementType(), Null, IndicesRHS);\n        Constant *NewICmp = ConstantExpr::getICmp(Pred, NewLHS, NewRHS);\n        return ConstantFoldConstant(NewICmp, Q.DL);\n      }\n    }\n  }\n\n  // If the comparison is with the result of a select instruction, check whether\n  // comparing with either branch of the select always yields the same value.\n  if (isa<SelectInst>(LHS) || isa<SelectInst>(RHS))\n    if (Value *V = ThreadCmpOverSelect(Pred, LHS, RHS, Q, MaxRecurse))\n      return V;\n\n  // If the comparison is with the result of a phi instruction, check whether\n  // doing the compare with each incoming phi value yields a common result.\n  if (isa<PHINode>(LHS) || isa<PHINode>(RHS))\n    if (Value *V = ThreadCmpOverPHI(Pred, LHS, RHS, Q, MaxRecurse))\n      return V;\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyICmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyICmpInst(Predicate, LHS, RHS, Q, RecursionLimit);\n}\n\n/// Given operands for an FCmpInst, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                               FastMathFlags FMF, const SimplifyQuery &Q,\n                               unsigned MaxRecurse) {\n  CmpInst::Predicate Pred = (CmpInst::Predicate)Predicate;\n  assert(CmpInst::isFPPredicate(Pred) && \"Not an FP compare!\");\n\n  if (Constant *CLHS = dyn_cast<Constant>(LHS)) {\n    if (Constant *CRHS = dyn_cast<Constant>(RHS))\n      return ConstantFoldCompareInstOperands(Pred, CLHS, CRHS, Q.DL, Q.TLI);\n\n    // If we have a constant, make sure it is on the RHS.\n    std::swap(LHS, RHS);\n    Pred = CmpInst::getSwappedPredicate(Pred);\n  }\n\n  // Fold trivial predicates.\n  Type *RetTy = GetCompareTy(LHS);\n  if (Pred == FCmpInst::FCMP_FALSE)\n    return getFalse(RetTy);\n  if (Pred == FCmpInst::FCMP_TRUE)\n    return getTrue(RetTy);\n\n  // Fold (un)ordered comparison if we can determine there are no NaNs.\n  if (Pred == FCmpInst::FCMP_UNO || Pred == FCmpInst::FCMP_ORD)\n    if (FMF.noNaNs() ||\n        (isKnownNeverNaN(LHS, Q.TLI) && isKnownNeverNaN(RHS, Q.TLI)))\n      return ConstantInt::get(RetTy, Pred == FCmpInst::FCMP_ORD);\n\n  // NaN is unordered; NaN is not ordered.\n  assert((FCmpInst::isOrdered(Pred) || FCmpInst::isUnordered(Pred)) &&\n         \"Comparison must be either ordered or unordered\");\n  if (match(RHS, m_NaN()))\n    return ConstantInt::get(RetTy, CmpInst::isUnordered(Pred));\n\n  // fcmp pred x, undef  and  fcmp pred undef, x\n  // fold to true if unordered, false if ordered\n  if (Q.isUndefValue(LHS) || Q.isUndefValue(RHS)) {\n    // Choosing NaN for the undef will always make unordered comparison succeed\n    // and ordered comparison fail.\n    return ConstantInt::get(RetTy, CmpInst::isUnordered(Pred));\n  }\n\n  // fcmp x,x -> true/false.  Not all compares are foldable.\n  if (LHS == RHS) {\n    if (CmpInst::isTrueWhenEqual(Pred))\n      return getTrue(RetTy);\n    if (CmpInst::isFalseWhenEqual(Pred))\n      return getFalse(RetTy);\n  }\n\n  // Handle fcmp with constant RHS.\n  // TODO: Use match with a specific FP value, so these work with vectors with\n  // undef lanes.\n  const APFloat *C;\n  if (match(RHS, m_APFloat(C))) {\n    // Check whether the constant is an infinity.\n    if (C->isInfinity()) {\n      if (C->isNegative()) {\n        switch (Pred) {\n        case FCmpInst::FCMP_OLT:\n          // No value is ordered and less than negative infinity.\n          return getFalse(RetTy);\n        case FCmpInst::FCMP_UGE:\n          // All values are unordered with or at least negative infinity.\n          return getTrue(RetTy);\n        default:\n          break;\n        }\n      } else {\n        switch (Pred) {\n        case FCmpInst::FCMP_OGT:\n          // No value is ordered and greater than infinity.\n          return getFalse(RetTy);\n        case FCmpInst::FCMP_ULE:\n          // All values are unordered with and at most infinity.\n          return getTrue(RetTy);\n        default:\n          break;\n        }\n      }\n\n      // LHS == Inf\n      if (Pred == FCmpInst::FCMP_OEQ && isKnownNeverInfinity(LHS, Q.TLI))\n        return getFalse(RetTy);\n      // LHS != Inf\n      if (Pred == FCmpInst::FCMP_UNE && isKnownNeverInfinity(LHS, Q.TLI))\n        return getTrue(RetTy);\n      // LHS == Inf || LHS == NaN\n      if (Pred == FCmpInst::FCMP_UEQ && isKnownNeverInfinity(LHS, Q.TLI) &&\n          isKnownNeverNaN(LHS, Q.TLI))\n        return getFalse(RetTy);\n      // LHS != Inf && LHS != NaN\n      if (Pred == FCmpInst::FCMP_ONE && isKnownNeverInfinity(LHS, Q.TLI) &&\n          isKnownNeverNaN(LHS, Q.TLI))\n        return getTrue(RetTy);\n    }\n    if (C->isNegative() && !C->isNegZero()) {\n      assert(!C->isNaN() && \"Unexpected NaN constant!\");\n      // TODO: We can catch more cases by using a range check rather than\n      //       relying on CannotBeOrderedLessThanZero.\n      switch (Pred) {\n      case FCmpInst::FCMP_UGE:\n      case FCmpInst::FCMP_UGT:\n      case FCmpInst::FCMP_UNE:\n        // (X >= 0) implies (X > C) when (C < 0)\n        if (CannotBeOrderedLessThanZero(LHS, Q.TLI))\n          return getTrue(RetTy);\n        break;\n      case FCmpInst::FCMP_OEQ:\n      case FCmpInst::FCMP_OLE:\n      case FCmpInst::FCMP_OLT:\n        // (X >= 0) implies !(X < C) when (C < 0)\n        if (CannotBeOrderedLessThanZero(LHS, Q.TLI))\n          return getFalse(RetTy);\n        break;\n      default:\n        break;\n      }\n    }\n\n    // Check comparison of [minnum/maxnum with constant] with other constant.\n    const APFloat *C2;\n    if ((match(LHS, m_Intrinsic<Intrinsic::minnum>(m_Value(), m_APFloat(C2))) &&\n         *C2 < *C) ||\n        (match(LHS, m_Intrinsic<Intrinsic::maxnum>(m_Value(), m_APFloat(C2))) &&\n         *C2 > *C)) {\n      bool IsMaxNum =\n          cast<IntrinsicInst>(LHS)->getIntrinsicID() == Intrinsic::maxnum;\n      // The ordered relationship and minnum/maxnum guarantee that we do not\n      // have NaN constants, so ordered/unordered preds are handled the same.\n      switch (Pred) {\n      case FCmpInst::FCMP_OEQ: case FCmpInst::FCMP_UEQ:\n        // minnum(X, LesserC)  == C --> false\n        // maxnum(X, GreaterC) == C --> false\n        return getFalse(RetTy);\n      case FCmpInst::FCMP_ONE: case FCmpInst::FCMP_UNE:\n        // minnum(X, LesserC)  != C --> true\n        // maxnum(X, GreaterC) != C --> true\n        return getTrue(RetTy);\n      case FCmpInst::FCMP_OGE: case FCmpInst::FCMP_UGE:\n      case FCmpInst::FCMP_OGT: case FCmpInst::FCMP_UGT:\n        // minnum(X, LesserC)  >= C --> false\n        // minnum(X, LesserC)  >  C --> false\n        // maxnum(X, GreaterC) >= C --> true\n        // maxnum(X, GreaterC) >  C --> true\n        return ConstantInt::get(RetTy, IsMaxNum);\n      case FCmpInst::FCMP_OLE: case FCmpInst::FCMP_ULE:\n      case FCmpInst::FCMP_OLT: case FCmpInst::FCMP_ULT:\n        // minnum(X, LesserC)  <= C --> true\n        // minnum(X, LesserC)  <  C --> true\n        // maxnum(X, GreaterC) <= C --> false\n        // maxnum(X, GreaterC) <  C --> false\n        return ConstantInt::get(RetTy, !IsMaxNum);\n      default:\n        // TRUE/FALSE/ORD/UNO should be handled before this.\n        llvm_unreachable(\"Unexpected fcmp predicate\");\n      }\n    }\n  }\n\n  if (match(RHS, m_AnyZeroFP())) {\n    switch (Pred) {\n    case FCmpInst::FCMP_OGE:\n    case FCmpInst::FCMP_ULT:\n      // Positive or zero X >= 0.0 --> true\n      // Positive or zero X <  0.0 --> false\n      if ((FMF.noNaNs() || isKnownNeverNaN(LHS, Q.TLI)) &&\n          CannotBeOrderedLessThanZero(LHS, Q.TLI))\n        return Pred == FCmpInst::FCMP_OGE ? getTrue(RetTy) : getFalse(RetTy);\n      break;\n    case FCmpInst::FCMP_UGE:\n    case FCmpInst::FCMP_OLT:\n      // Positive or zero or nan X >= 0.0 --> true\n      // Positive or zero or nan X <  0.0 --> false\n      if (CannotBeOrderedLessThanZero(LHS, Q.TLI))\n        return Pred == FCmpInst::FCMP_UGE ? getTrue(RetTy) : getFalse(RetTy);\n      break;\n    default:\n      break;\n    }\n  }\n\n  // If the comparison is with the result of a select instruction, check whether\n  // comparing with either branch of the select always yields the same value.\n  if (isa<SelectInst>(LHS) || isa<SelectInst>(RHS))\n    if (Value *V = ThreadCmpOverSelect(Pred, LHS, RHS, Q, MaxRecurse))\n      return V;\n\n  // If the comparison is with the result of a phi instruction, check whether\n  // doing the compare with each incoming phi value yields a common result.\n  if (isa<PHINode>(LHS) || isa<PHINode>(RHS))\n    if (Value *V = ThreadCmpOverPHI(Pred, LHS, RHS, Q, MaxRecurse))\n      return V;\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                              FastMathFlags FMF, const SimplifyQuery &Q) {\n  return ::SimplifyFCmpInst(Predicate, LHS, RHS, FMF, Q, RecursionLimit);\n}\n\nstatic Value *SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,\n                                     const SimplifyQuery &Q,\n                                     bool AllowRefinement,\n                                     unsigned MaxRecurse) {\n  // Trivial replacement.\n  if (V == Op)\n    return RepOp;\n\n  // We cannot replace a constant, and shouldn't even try.\n  if (isa<Constant>(Op))\n    return nullptr;\n\n  auto *I = dyn_cast<Instruction>(V);\n  if (!I)\n    return nullptr;\n\n  // Consider:\n  //   %cmp = icmp eq i32 %x, 2147483647\n  //   %add = add nsw i32 %x, 1\n  //   %sel = select i1 %cmp, i32 -2147483648, i32 %add\n  //\n  // We can't replace %sel with %add unless we strip away the flags (which will\n  // be done in InstCombine).\n  // TODO: This is unsound, because it only catches some forms of refinement.\n  if (!AllowRefinement && canCreatePoison(cast<Operator>(I)))\n    return nullptr;\n\n  // The simplification queries below may return the original value. Consider:\n  //   %div = udiv i32 %arg, %arg2\n  //   %mul = mul nsw i32 %div, %arg2\n  //   %cmp = icmp eq i32 %mul, %arg\n  //   %sel = select i1 %cmp, i32 %div, i32 undef\n  // Replacing %arg by %mul, %div becomes \"udiv i32 %mul, %arg2\", which\n  // simplifies back to %arg. This can only happen because %mul does not\n  // dominate %div. To ensure a consistent return value contract, we make sure\n  // that this case returns nullptr as well.\n  auto PreventSelfSimplify = [V](Value *Simplified) {\n    return Simplified != V ? Simplified : nullptr;\n  };\n\n  // If this is a binary operator, try to simplify it with the replaced op.\n  if (auto *B = dyn_cast<BinaryOperator>(I)) {\n    if (MaxRecurse) {\n      if (B->getOperand(0) == Op)\n        return PreventSelfSimplify(SimplifyBinOp(B->getOpcode(), RepOp,\n                                                 B->getOperand(1), Q,\n                                                 MaxRecurse - 1));\n      if (B->getOperand(1) == Op)\n        return PreventSelfSimplify(SimplifyBinOp(B->getOpcode(),\n                                                 B->getOperand(0), RepOp, Q,\n                                                 MaxRecurse - 1));\n    }\n  }\n\n  // Same for CmpInsts.\n  if (CmpInst *C = dyn_cast<CmpInst>(I)) {\n    if (MaxRecurse) {\n      if (C->getOperand(0) == Op)\n        return PreventSelfSimplify(SimplifyCmpInst(C->getPredicate(), RepOp,\n                                                   C->getOperand(1), Q,\n                                                   MaxRecurse - 1));\n      if (C->getOperand(1) == Op)\n        return PreventSelfSimplify(SimplifyCmpInst(C->getPredicate(),\n                                                   C->getOperand(0), RepOp, Q,\n                                                   MaxRecurse - 1));\n    }\n  }\n\n  // Same for GEPs.\n  if (auto *GEP = dyn_cast<GetElementPtrInst>(I)) {\n    if (MaxRecurse) {\n      SmallVector<Value *, 8> NewOps(GEP->getNumOperands());\n      transform(GEP->operands(), NewOps.begin(),\n                [&](Value *V) { return V == Op ? RepOp : V; });\n      return PreventSelfSimplify(SimplifyGEPInst(GEP->getSourceElementType(),\n                                                 NewOps, Q, MaxRecurse - 1));\n    }\n  }\n\n  // TODO: We could hand off more cases to instsimplify here.\n\n  // If all operands are constant after substituting Op for RepOp then we can\n  // constant fold the instruction.\n  if (Constant *CRepOp = dyn_cast<Constant>(RepOp)) {\n    // Build a list of all constant operands.\n    SmallVector<Constant *, 8> ConstOps;\n    for (unsigned i = 0, e = I->getNumOperands(); i != e; ++i) {\n      if (I->getOperand(i) == Op)\n        ConstOps.push_back(CRepOp);\n      else if (Constant *COp = dyn_cast<Constant>(I->getOperand(i)))\n        ConstOps.push_back(COp);\n      else\n        break;\n    }\n\n    // All operands were constants, fold it.\n    if (ConstOps.size() == I->getNumOperands()) {\n      if (CmpInst *C = dyn_cast<CmpInst>(I))\n        return ConstantFoldCompareInstOperands(C->getPredicate(), ConstOps[0],\n                                               ConstOps[1], Q.DL, Q.TLI);\n\n      if (LoadInst *LI = dyn_cast<LoadInst>(I))\n        if (!LI->isVolatile())\n          return ConstantFoldLoadFromConstPtr(ConstOps[0], LI->getType(), Q.DL);\n\n      return ConstantFoldInstOperands(I, ConstOps, Q.DL, Q.TLI);\n    }\n  }\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,\n                                    const SimplifyQuery &Q,\n                                    bool AllowRefinement) {\n  return ::SimplifyWithOpReplaced(V, Op, RepOp, Q, AllowRefinement,\n                                  RecursionLimit);\n}\n\n/// Try to simplify a select instruction when its condition operand is an\n/// integer comparison where one operand of the compare is a constant.\nstatic Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,\n                                    const APInt *Y, bool TrueWhenUnset) {\n  const APInt *C;\n\n  // (X & Y) == 0 ? X & ~Y : X  --> X\n  // (X & Y) != 0 ? X & ~Y : X  --> X & ~Y\n  if (FalseVal == X && match(TrueVal, m_And(m_Specific(X), m_APInt(C))) &&\n      *Y == ~*C)\n    return TrueWhenUnset ? FalseVal : TrueVal;\n\n  // (X & Y) == 0 ? X : X & ~Y  --> X & ~Y\n  // (X & Y) != 0 ? X : X & ~Y  --> X\n  if (TrueVal == X && match(FalseVal, m_And(m_Specific(X), m_APInt(C))) &&\n      *Y == ~*C)\n    return TrueWhenUnset ? FalseVal : TrueVal;\n\n  if (Y->isPowerOf2()) {\n    // (X & Y) == 0 ? X | Y : X  --> X | Y\n    // (X & Y) != 0 ? X | Y : X  --> X\n    if (FalseVal == X && match(TrueVal, m_Or(m_Specific(X), m_APInt(C))) &&\n        *Y == *C)\n      return TrueWhenUnset ? TrueVal : FalseVal;\n\n    // (X & Y) == 0 ? X : X | Y  --> X\n    // (X & Y) != 0 ? X : X | Y  --> X | Y\n    if (TrueVal == X && match(FalseVal, m_Or(m_Specific(X), m_APInt(C))) &&\n        *Y == *C)\n      return TrueWhenUnset ? TrueVal : FalseVal;\n  }\n\n  return nullptr;\n}\n\n/// An alternative way to test if a bit is set or not uses sgt/slt instead of\n/// eq/ne.\nstatic Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,\n                                           ICmpInst::Predicate Pred,\n                                           Value *TrueVal, Value *FalseVal) {\n  Value *X;\n  APInt Mask;\n  if (!decomposeBitTestICmp(CmpLHS, CmpRHS, Pred, X, Mask))\n    return nullptr;\n\n  return simplifySelectBitTest(TrueVal, FalseVal, X, &Mask,\n                               Pred == ICmpInst::ICMP_EQ);\n}\n\n/// Try to simplify a select instruction when its condition operand is an\n/// integer comparison.\nstatic Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,\n                                         Value *FalseVal, const SimplifyQuery &Q,\n                                         unsigned MaxRecurse) {\n  ICmpInst::Predicate Pred;\n  Value *CmpLHS, *CmpRHS;\n  if (!match(CondVal, m_ICmp(Pred, m_Value(CmpLHS), m_Value(CmpRHS))))\n    return nullptr;\n\n  // Canonicalize ne to eq predicate.\n  if (Pred == ICmpInst::ICMP_NE) {\n    Pred = ICmpInst::ICMP_EQ;\n    std::swap(TrueVal, FalseVal);\n  }\n\n  if (Pred == ICmpInst::ICMP_EQ && match(CmpRHS, m_Zero())) {\n    Value *X;\n    const APInt *Y;\n    if (match(CmpLHS, m_And(m_Value(X), m_APInt(Y))))\n      if (Value *V = simplifySelectBitTest(TrueVal, FalseVal, X, Y,\n                                           /*TrueWhenUnset=*/true))\n        return V;\n\n    // Test for a bogus zero-shift-guard-op around funnel-shift or rotate.\n    Value *ShAmt;\n    auto isFsh = m_CombineOr(m_FShl(m_Value(X), m_Value(), m_Value(ShAmt)),\n                             m_FShr(m_Value(), m_Value(X), m_Value(ShAmt)));\n    // (ShAmt == 0) ? fshl(X, *, ShAmt) : X --> X\n    // (ShAmt == 0) ? fshr(*, X, ShAmt) : X --> X\n    if (match(TrueVal, isFsh) && FalseVal == X && CmpLHS == ShAmt)\n      return X;\n\n    // Test for a zero-shift-guard-op around rotates. These are used to\n    // avoid UB from oversized shifts in raw IR rotate patterns, but the\n    // intrinsics do not have that problem.\n    // We do not allow this transform for the general funnel shift case because\n    // that would not preserve the poison safety of the original code.\n    auto isRotate =\n        m_CombineOr(m_FShl(m_Value(X), m_Deferred(X), m_Value(ShAmt)),\n                    m_FShr(m_Value(X), m_Deferred(X), m_Value(ShAmt)));\n    // (ShAmt == 0) ? X : fshl(X, X, ShAmt) --> fshl(X, X, ShAmt)\n    // (ShAmt == 0) ? X : fshr(X, X, ShAmt) --> fshr(X, X, ShAmt)\n    if (match(FalseVal, isRotate) && TrueVal == X && CmpLHS == ShAmt &&\n        Pred == ICmpInst::ICMP_EQ)\n      return FalseVal;\n\n    // X == 0 ? abs(X) : -abs(X) --> -abs(X)\n    // X == 0 ? -abs(X) : abs(X) --> abs(X)\n    if (match(TrueVal, m_Intrinsic<Intrinsic::abs>(m_Specific(CmpLHS))) &&\n        match(FalseVal, m_Neg(m_Intrinsic<Intrinsic::abs>(m_Specific(CmpLHS)))))\n      return FalseVal;\n    if (match(TrueVal,\n              m_Neg(m_Intrinsic<Intrinsic::abs>(m_Specific(CmpLHS)))) &&\n        match(FalseVal, m_Intrinsic<Intrinsic::abs>(m_Specific(CmpLHS))))\n      return FalseVal;\n  }\n\n  // Check for other compares that behave like bit test.\n  if (Value *V = simplifySelectWithFakeICmpEq(CmpLHS, CmpRHS, Pred,\n                                              TrueVal, FalseVal))\n    return V;\n\n  // If we have an equality comparison, then we know the value in one of the\n  // arms of the select. See if substituting this value into the arm and\n  // simplifying the result yields the same value as the other arm.\n  if (Pred == ICmpInst::ICMP_EQ) {\n    if (SimplifyWithOpReplaced(FalseVal, CmpLHS, CmpRHS, Q,\n                               /* AllowRefinement */ false, MaxRecurse) ==\n            TrueVal ||\n        SimplifyWithOpReplaced(FalseVal, CmpRHS, CmpLHS, Q,\n                               /* AllowRefinement */ false, MaxRecurse) ==\n            TrueVal)\n      return FalseVal;\n    if (SimplifyWithOpReplaced(TrueVal, CmpLHS, CmpRHS, Q,\n                               /* AllowRefinement */ true, MaxRecurse) ==\n            FalseVal ||\n        SimplifyWithOpReplaced(TrueVal, CmpRHS, CmpLHS, Q,\n                               /* AllowRefinement */ true, MaxRecurse) ==\n            FalseVal)\n      return FalseVal;\n  }\n\n  return nullptr;\n}\n\n/// Try to simplify a select instruction when its condition operand is a\n/// floating-point comparison.\nstatic Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,\n                                     const SimplifyQuery &Q) {\n  FCmpInst::Predicate Pred;\n  if (!match(Cond, m_FCmp(Pred, m_Specific(T), m_Specific(F))) &&\n      !match(Cond, m_FCmp(Pred, m_Specific(F), m_Specific(T))))\n    return nullptr;\n\n  // This transform is safe if we do not have (do not care about) -0.0 or if\n  // at least one operand is known to not be -0.0. Otherwise, the select can\n  // change the sign of a zero operand.\n  bool HasNoSignedZeros = Q.CxtI && isa<FPMathOperator>(Q.CxtI) &&\n                          Q.CxtI->hasNoSignedZeros();\n  const APFloat *C;\n  if (HasNoSignedZeros || (match(T, m_APFloat(C)) && C->isNonZero()) ||\n                          (match(F, m_APFloat(C)) && C->isNonZero())) {\n    // (T == F) ? T : F --> F\n    // (F == T) ? T : F --> F\n    if (Pred == FCmpInst::FCMP_OEQ)\n      return F;\n\n    // (T != F) ? T : F --> T\n    // (F != T) ? T : F --> T\n    if (Pred == FCmpInst::FCMP_UNE)\n      return T;\n  }\n\n  return nullptr;\n}\n\n/// Given operands for a SelectInst, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,\n                                 const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (auto *CondC = dyn_cast<Constant>(Cond)) {\n    if (auto *TrueC = dyn_cast<Constant>(TrueVal))\n      if (auto *FalseC = dyn_cast<Constant>(FalseVal))\n        return ConstantFoldSelectInstruction(CondC, TrueC, FalseC);\n\n    // select undef, X, Y -> X or Y\n    if (Q.isUndefValue(CondC))\n      return isa<Constant>(FalseVal) ? FalseVal : TrueVal;\n\n    // TODO: Vector constants with undef elements don't simplify.\n\n    // select true, X, Y  -> X\n    if (CondC->isAllOnesValue())\n      return TrueVal;\n    // select false, X, Y -> Y\n    if (CondC->isNullValue())\n      return FalseVal;\n  }\n\n  // select i1 Cond, i1 true, i1 false --> i1 Cond\n  assert(Cond->getType()->isIntOrIntVectorTy(1) &&\n         \"Select must have bool or bool vector condition\");\n  assert(TrueVal->getType() == FalseVal->getType() &&\n         \"Select must have same types for true/false ops\");\n  if (Cond->getType() == TrueVal->getType() &&\n      match(TrueVal, m_One()) && match(FalseVal, m_ZeroInt()))\n    return Cond;\n\n  // select ?, X, X -> X\n  if (TrueVal == FalseVal)\n    return TrueVal;\n\n  // If the true or false value is undef, we can fold to the other value as\n  // long as the other value isn't poison.\n  // select ?, undef, X -> X\n  if (Q.isUndefValue(TrueVal) &&\n      isGuaranteedNotToBeUndefOrPoison(FalseVal, Q.AC, Q.CxtI, Q.DT))\n    return FalseVal;\n  // select ?, X, undef -> X\n  if (Q.isUndefValue(FalseVal) &&\n      isGuaranteedNotToBeUndefOrPoison(TrueVal, Q.AC, Q.CxtI, Q.DT))\n    return TrueVal;\n\n  // Deal with partial undef vector constants: select ?, VecC, VecC' --> VecC''\n  Constant *TrueC, *FalseC;\n  if (isa<FixedVectorType>(TrueVal->getType()) &&\n      match(TrueVal, m_Constant(TrueC)) &&\n      match(FalseVal, m_Constant(FalseC))) {\n    unsigned NumElts =\n        cast<FixedVectorType>(TrueC->getType())->getNumElements();\n    SmallVector<Constant *, 16> NewC;\n    for (unsigned i = 0; i != NumElts; ++i) {\n      // Bail out on incomplete vector constants.\n      Constant *TEltC = TrueC->getAggregateElement(i);\n      Constant *FEltC = FalseC->getAggregateElement(i);\n      if (!TEltC || !FEltC)\n        break;\n\n      // If the elements match (undef or not), that value is the result. If only\n      // one element is undef, choose the defined element as the safe result.\n      if (TEltC == FEltC)\n        NewC.push_back(TEltC);\n      else if (Q.isUndefValue(TEltC) &&\n               isGuaranteedNotToBeUndefOrPoison(FEltC))\n        NewC.push_back(FEltC);\n      else if (Q.isUndefValue(FEltC) &&\n               isGuaranteedNotToBeUndefOrPoison(TEltC))\n        NewC.push_back(TEltC);\n      else\n        break;\n    }\n    if (NewC.size() == NumElts)\n      return ConstantVector::get(NewC);\n  }\n\n  if (Value *V =\n          simplifySelectWithICmpCond(Cond, TrueVal, FalseVal, Q, MaxRecurse))\n    return V;\n\n  if (Value *V = simplifySelectWithFCmp(Cond, TrueVal, FalseVal, Q))\n    return V;\n\n  if (Value *V = foldSelectWithBinaryOp(Cond, TrueVal, FalseVal))\n    return V;\n\n  Optional<bool> Imp = isImpliedByDomCondition(Cond, Q.CxtI, Q.DL);\n  if (Imp)\n    return *Imp ? TrueVal : FalseVal;\n\n  return nullptr;\n}\n\nValue *llvm::SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,\n                                const SimplifyQuery &Q) {\n  return ::SimplifySelectInst(Cond, TrueVal, FalseVal, Q, RecursionLimit);\n}\n\n/// Given operands for an GetElementPtrInst, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,\n                              const SimplifyQuery &Q, unsigned) {\n  // The type of the GEP pointer operand.\n  unsigned AS =\n      cast<PointerType>(Ops[0]->getType()->getScalarType())->getAddressSpace();\n\n  // getelementptr P -> P.\n  if (Ops.size() == 1)\n    return Ops[0];\n\n  // Compute the (pointer) type returned by the GEP instruction.\n  Type *LastType = GetElementPtrInst::getIndexedType(SrcTy, Ops.slice(1));\n  Type *GEPTy = PointerType::get(LastType, AS);\n  if (VectorType *VT = dyn_cast<VectorType>(Ops[0]->getType()))\n    GEPTy = VectorType::get(GEPTy, VT->getElementCount());\n  else if (VectorType *VT = dyn_cast<VectorType>(Ops[1]->getType()))\n    GEPTy = VectorType::get(GEPTy, VT->getElementCount());\n\n  // getelementptr poison, idx -> poison\n  // getelementptr baseptr, poison -> poison\n  if (any_of(Ops, [](const auto *V) { return isa<PoisonValue>(V); }))\n    return PoisonValue::get(GEPTy);\n\n  if (Q.isUndefValue(Ops[0]))\n    return UndefValue::get(GEPTy);\n\n  bool IsScalableVec = isa<ScalableVectorType>(SrcTy);\n\n  if (Ops.size() == 2) {\n    // getelementptr P, 0 -> P.\n    if (match(Ops[1], m_Zero()) && Ops[0]->getType() == GEPTy)\n      return Ops[0];\n\n    Type *Ty = SrcTy;\n    if (!IsScalableVec && Ty->isSized()) {\n      Value *P;\n      uint64_t C;\n      uint64_t TyAllocSize = Q.DL.getTypeAllocSize(Ty);\n      // getelementptr P, N -> P if P points to a type of zero size.\n      if (TyAllocSize == 0 && Ops[0]->getType() == GEPTy)\n        return Ops[0];\n\n      // The following transforms are only safe if the ptrtoint cast\n      // doesn't truncate the pointers.\n      if (Ops[1]->getType()->getScalarSizeInBits() ==\n          Q.DL.getPointerSizeInBits(AS)) {\n        auto PtrToInt = [GEPTy](Value *P) -> Value * {\n          Value *Temp;\n          if (match(P, m_PtrToInt(m_Value(Temp))))\n            if (Temp->getType() == GEPTy)\n              return Temp;\n          return nullptr;\n        };\n\n        // FIXME: The following transforms are only legal if P and V have the\n        // same provenance (PR44403). Check whether getUnderlyingObject() is\n        // the same?\n\n        // getelementptr V, (sub P, V) -> P if P points to a type of size 1.\n        if (TyAllocSize == 1 &&\n            match(Ops[1], m_Sub(m_Value(P), m_PtrToInt(m_Specific(Ops[0])))))\n          if (Value *R = PtrToInt(P))\n            return R;\n\n        // getelementptr V, (ashr (sub P, V), C) -> Q\n        // if P points to a type of size 1 << C.\n        if (match(Ops[1],\n                  m_AShr(m_Sub(m_Value(P), m_PtrToInt(m_Specific(Ops[0]))),\n                         m_ConstantInt(C))) &&\n            TyAllocSize == 1ULL << C)\n          if (Value *R = PtrToInt(P))\n            return R;\n\n        // getelementptr V, (sdiv (sub P, V), C) -> Q\n        // if P points to a type of size C.\n        if (match(Ops[1],\n                  m_SDiv(m_Sub(m_Value(P), m_PtrToInt(m_Specific(Ops[0]))),\n                         m_SpecificInt(TyAllocSize))))\n          if (Value *R = PtrToInt(P))\n            return R;\n      }\n    }\n  }\n\n  if (!IsScalableVec && Q.DL.getTypeAllocSize(LastType) == 1 &&\n      all_of(Ops.slice(1).drop_back(1),\n             [](Value *Idx) { return match(Idx, m_Zero()); })) {\n    unsigned IdxWidth =\n        Q.DL.getIndexSizeInBits(Ops[0]->getType()->getPointerAddressSpace());\n    if (Q.DL.getTypeSizeInBits(Ops.back()->getType()) == IdxWidth) {\n      APInt BasePtrOffset(IdxWidth, 0);\n      Value *StrippedBasePtr =\n          Ops[0]->stripAndAccumulateInBoundsConstantOffsets(Q.DL,\n                                                            BasePtrOffset);\n\n      // Avoid creating inttoptr of zero here: While LLVMs treatment of\n      // inttoptr is generally conservative, this particular case is folded to\n      // a null pointer, which will have incorrect provenance.\n\n      // gep (gep V, C), (sub 0, V) -> C\n      if (match(Ops.back(),\n                m_Sub(m_Zero(), m_PtrToInt(m_Specific(StrippedBasePtr)))) &&\n          !BasePtrOffset.isNullValue()) {\n        auto *CI = ConstantInt::get(GEPTy->getContext(), BasePtrOffset);\n        return ConstantExpr::getIntToPtr(CI, GEPTy);\n      }\n      // gep (gep V, C), (xor V, -1) -> C-1\n      if (match(Ops.back(),\n                m_Xor(m_PtrToInt(m_Specific(StrippedBasePtr)), m_AllOnes())) &&\n          !BasePtrOffset.isOneValue()) {\n        auto *CI = ConstantInt::get(GEPTy->getContext(), BasePtrOffset - 1);\n        return ConstantExpr::getIntToPtr(CI, GEPTy);\n      }\n    }\n  }\n\n  // Check to see if this is constant foldable.\n  if (!all_of(Ops, [](Value *V) { return isa<Constant>(V); }))\n    return nullptr;\n\n  auto *CE = ConstantExpr::getGetElementPtr(SrcTy, cast<Constant>(Ops[0]),\n                                            Ops.slice(1));\n  return ConstantFoldConstant(CE, Q.DL);\n}\n\nValue *llvm::SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,\n                             const SimplifyQuery &Q) {\n  return ::SimplifyGEPInst(SrcTy, Ops, Q, RecursionLimit);\n}\n\n/// Given operands for an InsertValueInst, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyInsertValueInst(Value *Agg, Value *Val,\n                                      ArrayRef<unsigned> Idxs, const SimplifyQuery &Q,\n                                      unsigned) {\n  if (Constant *CAgg = dyn_cast<Constant>(Agg))\n    if (Constant *CVal = dyn_cast<Constant>(Val))\n      return ConstantFoldInsertValueInstruction(CAgg, CVal, Idxs);\n\n  // insertvalue x, undef, n -> x\n  if (Q.isUndefValue(Val))\n    return Agg;\n\n  // insertvalue x, (extractvalue y, n), n\n  if (ExtractValueInst *EV = dyn_cast<ExtractValueInst>(Val))\n    if (EV->getAggregateOperand()->getType() == Agg->getType() &&\n        EV->getIndices() == Idxs) {\n      // insertvalue undef, (extractvalue y, n), n -> y\n      if (Q.isUndefValue(Agg))\n        return EV->getAggregateOperand();\n\n      // insertvalue y, (extractvalue y, n), n -> y\n      if (Agg == EV->getAggregateOperand())\n        return Agg;\n    }\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyInsertValueInst(Value *Agg, Value *Val,\n                                     ArrayRef<unsigned> Idxs,\n                                     const SimplifyQuery &Q) {\n  return ::SimplifyInsertValueInst(Agg, Val, Idxs, Q, RecursionLimit);\n}\n\nValue *llvm::SimplifyInsertElementInst(Value *Vec, Value *Val, Value *Idx,\n                                       const SimplifyQuery &Q) {\n  // Try to constant fold.\n  auto *VecC = dyn_cast<Constant>(Vec);\n  auto *ValC = dyn_cast<Constant>(Val);\n  auto *IdxC = dyn_cast<Constant>(Idx);\n  if (VecC && ValC && IdxC)\n    return ConstantExpr::getInsertElement(VecC, ValC, IdxC);\n\n  // For fixed-length vector, fold into poison if index is out of bounds.\n  if (auto *CI = dyn_cast<ConstantInt>(Idx)) {\n    if (isa<FixedVectorType>(Vec->getType()) &&\n        CI->uge(cast<FixedVectorType>(Vec->getType())->getNumElements()))\n      return PoisonValue::get(Vec->getType());\n  }\n\n  // If index is undef, it might be out of bounds (see above case)\n  if (Q.isUndefValue(Idx))\n    return PoisonValue::get(Vec->getType());\n\n  // If the scalar is poison, or it is undef and there is no risk of\n  // propagating poison from the vector value, simplify to the vector value.\n  if (isa<PoisonValue>(Val) ||\n      (Q.isUndefValue(Val) && isGuaranteedNotToBePoison(Vec)))\n    return Vec;\n\n  // If we are extracting a value from a vector, then inserting it into the same\n  // place, that's the input vector:\n  // insertelt Vec, (extractelt Vec, Idx), Idx --> Vec\n  if (match(Val, m_ExtractElt(m_Specific(Vec), m_Specific(Idx))))\n    return Vec;\n\n  return nullptr;\n}\n\n/// Given operands for an ExtractValueInst, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyExtractValueInst(Value *Agg, ArrayRef<unsigned> Idxs,\n                                       const SimplifyQuery &, unsigned) {\n  if (auto *CAgg = dyn_cast<Constant>(Agg))\n    return ConstantFoldExtractValueInstruction(CAgg, Idxs);\n\n  // extractvalue x, (insertvalue y, elt, n), n -> elt\n  unsigned NumIdxs = Idxs.size();\n  for (auto *IVI = dyn_cast<InsertValueInst>(Agg); IVI != nullptr;\n       IVI = dyn_cast<InsertValueInst>(IVI->getAggregateOperand())) {\n    ArrayRef<unsigned> InsertValueIdxs = IVI->getIndices();\n    unsigned NumInsertValueIdxs = InsertValueIdxs.size();\n    unsigned NumCommonIdxs = std::min(NumInsertValueIdxs, NumIdxs);\n    if (InsertValueIdxs.slice(0, NumCommonIdxs) ==\n        Idxs.slice(0, NumCommonIdxs)) {\n      if (NumIdxs == NumInsertValueIdxs)\n        return IVI->getInsertedValueOperand();\n      break;\n    }\n  }\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyExtractValueInst(Value *Agg, ArrayRef<unsigned> Idxs,\n                                      const SimplifyQuery &Q) {\n  return ::SimplifyExtractValueInst(Agg, Idxs, Q, RecursionLimit);\n}\n\n/// Given operands for an ExtractElementInst, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyExtractElementInst(Value *Vec, Value *Idx,\n                                         const SimplifyQuery &Q, unsigned) {\n  auto *VecVTy = cast<VectorType>(Vec->getType());\n  if (auto *CVec = dyn_cast<Constant>(Vec)) {\n    if (auto *CIdx = dyn_cast<Constant>(Idx))\n      return ConstantExpr::getExtractElement(CVec, CIdx);\n\n    // The index is not relevant if our vector is a splat.\n    if (auto *Splat = CVec->getSplatValue())\n      return Splat;\n\n    if (Q.isUndefValue(Vec))\n      return UndefValue::get(VecVTy->getElementType());\n  }\n\n  // If extracting a specified index from the vector, see if we can recursively\n  // find a previously computed scalar that was inserted into the vector.\n  if (auto *IdxC = dyn_cast<ConstantInt>(Idx)) {\n    // For fixed-length vector, fold into undef if index is out of bounds.\n    if (isa<FixedVectorType>(VecVTy) &&\n        IdxC->getValue().uge(cast<FixedVectorType>(VecVTy)->getNumElements()))\n      return PoisonValue::get(VecVTy->getElementType());\n    if (Value *Elt = findScalarElement(Vec, IdxC->getZExtValue()))\n      return Elt;\n  }\n\n  // An undef extract index can be arbitrarily chosen to be an out-of-range\n  // index value, which would result in the instruction being poison.\n  if (Q.isUndefValue(Idx))\n    return PoisonValue::get(VecVTy->getElementType());\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyExtractElementInst(Value *Vec, Value *Idx,\n                                        const SimplifyQuery &Q) {\n  return ::SimplifyExtractElementInst(Vec, Idx, Q, RecursionLimit);\n}\n\n/// See if we can fold the given phi. If not, returns null.\nstatic Value *SimplifyPHINode(PHINode *PN, const SimplifyQuery &Q) {\n  // WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE\n  //          here, because the PHI we may succeed simplifying to was not\n  //          def-reachable from the original PHI!\n\n  // If all of the PHI's incoming values are the same then replace the PHI node\n  // with the common value.\n  Value *CommonValue = nullptr;\n  bool HasUndefInput = false;\n  for (Value *Incoming : PN->incoming_values()) {\n    // If the incoming value is the phi node itself, it can safely be skipped.\n    if (Incoming == PN) continue;\n    if (Q.isUndefValue(Incoming)) {\n      // Remember that we saw an undef value, but otherwise ignore them.\n      HasUndefInput = true;\n      continue;\n    }\n    if (CommonValue && Incoming != CommonValue)\n      return nullptr;  // Not the same, bail out.\n    CommonValue = Incoming;\n  }\n\n  // If CommonValue is null then all of the incoming values were either undef or\n  // equal to the phi node itself.\n  if (!CommonValue)\n    return UndefValue::get(PN->getType());\n\n  // If we have a PHI node like phi(X, undef, X), where X is defined by some\n  // instruction, we cannot return X as the result of the PHI node unless it\n  // dominates the PHI block.\n  if (HasUndefInput)\n    return valueDominatesPHI(CommonValue, PN, Q.DT) ? CommonValue : nullptr;\n\n  return CommonValue;\n}\n\nstatic Value *SimplifyCastInst(unsigned CastOpc, Value *Op,\n                               Type *Ty, const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (auto *C = dyn_cast<Constant>(Op))\n    return ConstantFoldCastOperand(CastOpc, C, Ty, Q.DL);\n\n  if (auto *CI = dyn_cast<CastInst>(Op)) {\n    auto *Src = CI->getOperand(0);\n    Type *SrcTy = Src->getType();\n    Type *MidTy = CI->getType();\n    Type *DstTy = Ty;\n    if (Src->getType() == Ty) {\n      auto FirstOp = static_cast<Instruction::CastOps>(CI->getOpcode());\n      auto SecondOp = static_cast<Instruction::CastOps>(CastOpc);\n      Type *SrcIntPtrTy =\n          SrcTy->isPtrOrPtrVectorTy() ? Q.DL.getIntPtrType(SrcTy) : nullptr;\n      Type *MidIntPtrTy =\n          MidTy->isPtrOrPtrVectorTy() ? Q.DL.getIntPtrType(MidTy) : nullptr;\n      Type *DstIntPtrTy =\n          DstTy->isPtrOrPtrVectorTy() ? Q.DL.getIntPtrType(DstTy) : nullptr;\n      if (CastInst::isEliminableCastPair(FirstOp, SecondOp, SrcTy, MidTy, DstTy,\n                                         SrcIntPtrTy, MidIntPtrTy,\n                                         DstIntPtrTy) == Instruction::BitCast)\n        return Src;\n    }\n  }\n\n  // bitcast x -> x\n  if (CastOpc == Instruction::BitCast)\n    if (Op->getType() == Ty)\n      return Op;\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyCastInst(unsigned CastOpc, Value *Op, Type *Ty,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyCastInst(CastOpc, Op, Ty, Q, RecursionLimit);\n}\n\n/// For the given destination element of a shuffle, peek through shuffles to\n/// match a root vector source operand that contains that element in the same\n/// vector lane (ie, the same mask index), so we can eliminate the shuffle(s).\nstatic Value *foldIdentityShuffles(int DestElt, Value *Op0, Value *Op1,\n                                   int MaskVal, Value *RootVec,\n                                   unsigned MaxRecurse) {\n  if (!MaxRecurse--)\n    return nullptr;\n\n  // Bail out if any mask value is undefined. That kind of shuffle may be\n  // simplified further based on demanded bits or other folds.\n  if (MaskVal == -1)\n    return nullptr;\n\n  // The mask value chooses which source operand we need to look at next.\n  int InVecNumElts = cast<FixedVectorType>(Op0->getType())->getNumElements();\n  int RootElt = MaskVal;\n  Value *SourceOp = Op0;\n  if (MaskVal >= InVecNumElts) {\n    RootElt = MaskVal - InVecNumElts;\n    SourceOp = Op1;\n  }\n\n  // If the source operand is a shuffle itself, look through it to find the\n  // matching root vector.\n  if (auto *SourceShuf = dyn_cast<ShuffleVectorInst>(SourceOp)) {\n    return foldIdentityShuffles(\n        DestElt, SourceShuf->getOperand(0), SourceShuf->getOperand(1),\n        SourceShuf->getMaskValue(RootElt), RootVec, MaxRecurse);\n  }\n\n  // TODO: Look through bitcasts? What if the bitcast changes the vector element\n  // size?\n\n  // The source operand is not a shuffle. Initialize the root vector value for\n  // this shuffle if that has not been done yet.\n  if (!RootVec)\n    RootVec = SourceOp;\n\n  // Give up as soon as a source operand does not match the existing root value.\n  if (RootVec != SourceOp)\n    return nullptr;\n\n  // The element must be coming from the same lane in the source vector\n  // (although it may have crossed lanes in intermediate shuffles).\n  if (RootElt != DestElt)\n    return nullptr;\n\n  return RootVec;\n}\n\nstatic Value *SimplifyShuffleVectorInst(Value *Op0, Value *Op1,\n                                        ArrayRef<int> Mask, Type *RetTy,\n                                        const SimplifyQuery &Q,\n                                        unsigned MaxRecurse) {\n  if (all_of(Mask, [](int Elem) { return Elem == UndefMaskElem; }))\n    return UndefValue::get(RetTy);\n\n  auto *InVecTy = cast<VectorType>(Op0->getType());\n  unsigned MaskNumElts = Mask.size();\n  ElementCount InVecEltCount = InVecTy->getElementCount();\n\n  bool Scalable = InVecEltCount.isScalable();\n\n  SmallVector<int, 32> Indices;\n  Indices.assign(Mask.begin(), Mask.end());\n\n  // Canonicalization: If mask does not select elements from an input vector,\n  // replace that input vector with poison.\n  if (!Scalable) {\n    bool MaskSelects0 = false, MaskSelects1 = false;\n    unsigned InVecNumElts = InVecEltCount.getKnownMinValue();\n    for (unsigned i = 0; i != MaskNumElts; ++i) {\n      if (Indices[i] == -1)\n        continue;\n      if ((unsigned)Indices[i] < InVecNumElts)\n        MaskSelects0 = true;\n      else\n        MaskSelects1 = true;\n    }\n    if (!MaskSelects0)\n      Op0 = PoisonValue::get(InVecTy);\n    if (!MaskSelects1)\n      Op1 = PoisonValue::get(InVecTy);\n  }\n\n  auto *Op0Const = dyn_cast<Constant>(Op0);\n  auto *Op1Const = dyn_cast<Constant>(Op1);\n\n  // If all operands are constant, constant fold the shuffle. This\n  // transformation depends on the value of the mask which is not known at\n  // compile time for scalable vectors\n  if (Op0Const && Op1Const)\n    return ConstantExpr::getShuffleVector(Op0Const, Op1Const, Mask);\n\n  // Canonicalization: if only one input vector is constant, it shall be the\n  // second one. This transformation depends on the value of the mask which\n  // is not known at compile time for scalable vectors\n  if (!Scalable && Op0Const && !Op1Const) {\n    std::swap(Op0, Op1);\n    ShuffleVectorInst::commuteShuffleMask(Indices,\n                                          InVecEltCount.getKnownMinValue());\n  }\n\n  // A splat of an inserted scalar constant becomes a vector constant:\n  // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>\n  // NOTE: We may have commuted above, so analyze the updated Indices, not the\n  //       original mask constant.\n  // NOTE: This transformation depends on the value of the mask which is not\n  // known at compile time for scalable vectors\n  Constant *C;\n  ConstantInt *IndexC;\n  if (!Scalable && match(Op0, m_InsertElt(m_Value(), m_Constant(C),\n                                          m_ConstantInt(IndexC)))) {\n    // Match a splat shuffle mask of the insert index allowing undef elements.\n    int InsertIndex = IndexC->getZExtValue();\n    if (all_of(Indices, [InsertIndex](int MaskElt) {\n          return MaskElt == InsertIndex || MaskElt == -1;\n        })) {\n      assert(isa<UndefValue>(Op1) && \"Expected undef operand 1 for splat\");\n\n      // Shuffle mask undefs become undefined constant result elements.\n      SmallVector<Constant *, 16> VecC(MaskNumElts, C);\n      for (unsigned i = 0; i != MaskNumElts; ++i)\n        if (Indices[i] == -1)\n          VecC[i] = UndefValue::get(C->getType());\n      return ConstantVector::get(VecC);\n    }\n  }\n\n  // A shuffle of a splat is always the splat itself. Legal if the shuffle's\n  // value type is same as the input vectors' type.\n  if (auto *OpShuf = dyn_cast<ShuffleVectorInst>(Op0))\n    if (Q.isUndefValue(Op1) && RetTy == InVecTy &&\n        is_splat(OpShuf->getShuffleMask()))\n      return Op0;\n\n  // All remaining transformation depend on the value of the mask, which is\n  // not known at compile time for scalable vectors.\n  if (Scalable)\n    return nullptr;\n\n  // Don't fold a shuffle with undef mask elements. This may get folded in a\n  // better way using demanded bits or other analysis.\n  // TODO: Should we allow this?\n  if (is_contained(Indices, -1))\n    return nullptr;\n\n  // Check if every element of this shuffle can be mapped back to the\n  // corresponding element of a single root vector. If so, we don't need this\n  // shuffle. This handles simple identity shuffles as well as chains of\n  // shuffles that may widen/narrow and/or move elements across lanes and back.\n  Value *RootVec = nullptr;\n  for (unsigned i = 0; i != MaskNumElts; ++i) {\n    // Note that recursion is limited for each vector element, so if any element\n    // exceeds the limit, this will fail to simplify.\n    RootVec =\n        foldIdentityShuffles(i, Op0, Op1, Indices[i], RootVec, MaxRecurse);\n\n    // We can't replace a widening/narrowing shuffle with one of its operands.\n    if (!RootVec || RootVec->getType() != RetTy)\n      return nullptr;\n  }\n  return RootVec;\n}\n\n/// Given operands for a ShuffleVectorInst, fold the result or return null.\nValue *llvm::SimplifyShuffleVectorInst(Value *Op0, Value *Op1,\n                                       ArrayRef<int> Mask, Type *RetTy,\n                                       const SimplifyQuery &Q) {\n  return ::SimplifyShuffleVectorInst(Op0, Op1, Mask, RetTy, Q, RecursionLimit);\n}\n\nstatic Constant *foldConstant(Instruction::UnaryOps Opcode,\n                              Value *&Op, const SimplifyQuery &Q) {\n  if (auto *C = dyn_cast<Constant>(Op))\n    return ConstantFoldUnaryOpOperand(Opcode, C, Q.DL);\n  return nullptr;\n}\n\n/// Given the operand for an FNeg, see if we can fold the result.  If not, this\n/// returns null.\nstatic Value *simplifyFNegInst(Value *Op, FastMathFlags FMF,\n                               const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldConstant(Instruction::FNeg, Op, Q))\n    return C;\n\n  Value *X;\n  // fneg (fneg X) ==> X\n  if (match(Op, m_FNeg(m_Value(X))))\n    return X;\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyFNegInst(Value *Op, FastMathFlags FMF,\n                              const SimplifyQuery &Q) {\n  return ::simplifyFNegInst(Op, FMF, Q, RecursionLimit);\n}\n\nstatic Constant *propagateNaN(Constant *In) {\n  // If the input is a vector with undef elements, just return a default NaN.\n  if (!In->isNaN())\n    return ConstantFP::getNaN(In->getType());\n\n  // Propagate the existing NaN constant when possible.\n  // TODO: Should we quiet a signaling NaN?\n  return In;\n}\n\n/// Perform folds that are common to any floating-point operation. This implies\n/// transforms based on undef/NaN because the operation itself makes no\n/// difference to the result.\nstatic Constant *simplifyFPOp(ArrayRef<Value *> Ops,\n                              FastMathFlags FMF,\n                              const SimplifyQuery &Q) {\n  for (Value *V : Ops) {\n    bool IsNan = match(V, m_NaN());\n    bool IsInf = match(V, m_Inf());\n    bool IsUndef = Q.isUndefValue(V);\n\n    // If this operation has 'nnan' or 'ninf' and at least 1 disallowed operand\n    // (an undef operand can be chosen to be Nan/Inf), then the result of\n    // this operation is poison.\n    if (FMF.noNaNs() && (IsNan || IsUndef))\n      return PoisonValue::get(V->getType());\n    if (FMF.noInfs() && (IsInf || IsUndef))\n      return PoisonValue::get(V->getType());\n\n    if (IsUndef || IsNan)\n      return propagateNaN(cast<Constant>(V));\n  }\n  return nullptr;\n}\n\n/// Given operands for an FAdd, see if we can fold the result.  If not, this\n/// returns null.\nstatic Value *SimplifyFAddInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                               const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::FAdd, Op0, Op1, Q))\n    return C;\n\n  if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))\n    return C;\n\n  // fadd X, -0 ==> X\n  if (match(Op1, m_NegZeroFP()))\n    return Op0;\n\n  // fadd X, 0 ==> X, when we know X is not -0\n  if (match(Op1, m_PosZeroFP()) &&\n      (FMF.noSignedZeros() || CannotBeNegativeZero(Op0, Q.TLI)))\n    return Op0;\n\n  // With nnan: -X + X --> 0.0 (and commuted variant)\n  // We don't have to explicitly exclude infinities (ninf): INF + -INF == NaN.\n  // Negative zeros are allowed because we always end up with positive zero:\n  // X = -0.0: (-0.0 - (-0.0)) + (-0.0) == ( 0.0) + (-0.0) == 0.0\n  // X = -0.0: ( 0.0 - (-0.0)) + (-0.0) == ( 0.0) + (-0.0) == 0.0\n  // X =  0.0: (-0.0 - ( 0.0)) + ( 0.0) == (-0.0) + ( 0.0) == 0.0\n  // X =  0.0: ( 0.0 - ( 0.0)) + ( 0.0) == ( 0.0) + ( 0.0) == 0.0\n  if (FMF.noNaNs()) {\n    if (match(Op0, m_FSub(m_AnyZeroFP(), m_Specific(Op1))) ||\n        match(Op1, m_FSub(m_AnyZeroFP(), m_Specific(Op0))))\n      return ConstantFP::getNullValue(Op0->getType());\n\n    if (match(Op0, m_FNeg(m_Specific(Op1))) ||\n        match(Op1, m_FNeg(m_Specific(Op0))))\n      return ConstantFP::getNullValue(Op0->getType());\n  }\n\n  // (X - Y) + Y --> X\n  // Y + (X - Y) --> X\n  Value *X;\n  if (FMF.noSignedZeros() && FMF.allowReassoc() &&\n      (match(Op0, m_FSub(m_Value(X), m_Specific(Op1))) ||\n       match(Op1, m_FSub(m_Value(X), m_Specific(Op0)))))\n    return X;\n\n  return nullptr;\n}\n\n/// Given operands for an FSub, see if we can fold the result.  If not, this\n/// returns null.\nstatic Value *SimplifyFSubInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                               const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::FSub, Op0, Op1, Q))\n    return C;\n\n  if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))\n    return C;\n\n  // fsub X, +0 ==> X\n  if (match(Op1, m_PosZeroFP()))\n    return Op0;\n\n  // fsub X, -0 ==> X, when we know X is not -0\n  if (match(Op1, m_NegZeroFP()) &&\n      (FMF.noSignedZeros() || CannotBeNegativeZero(Op0, Q.TLI)))\n    return Op0;\n\n  // fsub -0.0, (fsub -0.0, X) ==> X\n  // fsub -0.0, (fneg X) ==> X\n  Value *X;\n  if (match(Op0, m_NegZeroFP()) &&\n      match(Op1, m_FNeg(m_Value(X))))\n    return X;\n\n  // fsub 0.0, (fsub 0.0, X) ==> X if signed zeros are ignored.\n  // fsub 0.0, (fneg X) ==> X if signed zeros are ignored.\n  if (FMF.noSignedZeros() && match(Op0, m_AnyZeroFP()) &&\n      (match(Op1, m_FSub(m_AnyZeroFP(), m_Value(X))) ||\n       match(Op1, m_FNeg(m_Value(X)))))\n    return X;\n\n  // fsub nnan x, x ==> 0.0\n  if (FMF.noNaNs() && Op0 == Op1)\n    return Constant::getNullValue(Op0->getType());\n\n  // Y - (Y - X) --> X\n  // (X + Y) - Y --> X\n  if (FMF.noSignedZeros() && FMF.allowReassoc() &&\n      (match(Op1, m_FSub(m_Specific(Op0), m_Value(X))) ||\n       match(Op0, m_c_FAdd(m_Specific(Op1), m_Value(X)))))\n    return X;\n\n  return nullptr;\n}\n\nstatic Value *SimplifyFMAFMul(Value *Op0, Value *Op1, FastMathFlags FMF,\n                              const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))\n    return C;\n\n  // fmul X, 1.0 ==> X\n  if (match(Op1, m_FPOne()))\n    return Op0;\n\n  // fmul 1.0, X ==> X\n  if (match(Op0, m_FPOne()))\n    return Op1;\n\n  // fmul nnan nsz X, 0 ==> 0\n  if (FMF.noNaNs() && FMF.noSignedZeros() && match(Op1, m_AnyZeroFP()))\n    return ConstantFP::getNullValue(Op0->getType());\n\n  // fmul nnan nsz 0, X ==> 0\n  if (FMF.noNaNs() && FMF.noSignedZeros() && match(Op0, m_AnyZeroFP()))\n    return ConstantFP::getNullValue(Op1->getType());\n\n  // sqrt(X) * sqrt(X) --> X, if we can:\n  // 1. Remove the intermediate rounding (reassociate).\n  // 2. Ignore non-zero negative numbers because sqrt would produce NAN.\n  // 3. Ignore -0.0 because sqrt(-0.0) == -0.0, but -0.0 * -0.0 == 0.0.\n  Value *X;\n  if (Op0 == Op1 && match(Op0, m_Intrinsic<Intrinsic::sqrt>(m_Value(X))) &&\n      FMF.allowReassoc() && FMF.noNaNs() && FMF.noSignedZeros())\n    return X;\n\n  return nullptr;\n}\n\n/// Given the operands for an FMul, see if we can fold the result\nstatic Value *SimplifyFMulInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                               const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::FMul, Op0, Op1, Q))\n    return C;\n\n  // Now apply simplifications that do not require rounding.\n  return SimplifyFMAFMul(Op0, Op1, FMF, Q, MaxRecurse);\n}\n\nValue *llvm::SimplifyFAddInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyFAddInst(Op0, Op1, FMF, Q, RecursionLimit);\n}\n\n\nValue *llvm::SimplifyFSubInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyFSubInst(Op0, Op1, FMF, Q, RecursionLimit);\n}\n\nValue *llvm::SimplifyFMulInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyFMulInst(Op0, Op1, FMF, Q, RecursionLimit);\n}\n\nValue *llvm::SimplifyFMAFMul(Value *Op0, Value *Op1, FastMathFlags FMF,\n                             const SimplifyQuery &Q) {\n  return ::SimplifyFMAFMul(Op0, Op1, FMF, Q, RecursionLimit);\n}\n\nstatic Value *SimplifyFDivInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                               const SimplifyQuery &Q, unsigned) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::FDiv, Op0, Op1, Q))\n    return C;\n\n  if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))\n    return C;\n\n  // X / 1.0 -> X\n  if (match(Op1, m_FPOne()))\n    return Op0;\n\n  // 0 / X -> 0\n  // Requires that NaNs are off (X could be zero) and signed zeroes are\n  // ignored (X could be positive or negative, so the output sign is unknown).\n  if (FMF.noNaNs() && FMF.noSignedZeros() && match(Op0, m_AnyZeroFP()))\n    return ConstantFP::getNullValue(Op0->getType());\n\n  if (FMF.noNaNs()) {\n    // X / X -> 1.0 is legal when NaNs are ignored.\n    // We can ignore infinities because INF/INF is NaN.\n    if (Op0 == Op1)\n      return ConstantFP::get(Op0->getType(), 1.0);\n\n    // (X * Y) / Y --> X if we can reassociate to the above form.\n    Value *X;\n    if (FMF.allowReassoc() && match(Op0, m_c_FMul(m_Value(X), m_Specific(Op1))))\n      return X;\n\n    // -X /  X -> -1.0 and\n    //  X / -X -> -1.0 are legal when NaNs are ignored.\n    // We can ignore signed zeros because +-0.0/+-0.0 is NaN and ignored.\n    if (match(Op0, m_FNegNSZ(m_Specific(Op1))) ||\n        match(Op1, m_FNegNSZ(m_Specific(Op0))))\n      return ConstantFP::get(Op0->getType(), -1.0);\n  }\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyFDivInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyFDivInst(Op0, Op1, FMF, Q, RecursionLimit);\n}\n\nstatic Value *SimplifyFRemInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                               const SimplifyQuery &Q, unsigned) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::FRem, Op0, Op1, Q))\n    return C;\n\n  if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))\n    return C;\n\n  // Unlike fdiv, the result of frem always matches the sign of the dividend.\n  // The constant match may include undef elements in a vector, so return a full\n  // zero constant as the result.\n  if (FMF.noNaNs()) {\n    // +0 % X -> 0\n    if (match(Op0, m_PosZeroFP()))\n      return ConstantFP::getNullValue(Op0->getType());\n    // -0 % X -> -0\n    if (match(Op0, m_NegZeroFP()))\n      return ConstantFP::getNegativeZero(Op0->getType());\n  }\n\n  return nullptr;\n}\n\nValue *llvm::SimplifyFRemInst(Value *Op0, Value *Op1, FastMathFlags FMF,\n                              const SimplifyQuery &Q) {\n  return ::SimplifyFRemInst(Op0, Op1, FMF, Q, RecursionLimit);\n}\n\n//=== Helper functions for higher up the class hierarchy.\n\n/// Given the operand for a UnaryOperator, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,\n                           unsigned MaxRecurse) {\n  switch (Opcode) {\n  case Instruction::FNeg:\n    return simplifyFNegInst(Op, FastMathFlags(), Q, MaxRecurse);\n  default:\n    llvm_unreachable(\"Unexpected opcode\");\n  }\n}\n\n/// Given the operand for a UnaryOperator, see if we can fold the result.\n/// If not, this returns null.\n/// Try to use FastMathFlags when folding the result.\nstatic Value *simplifyFPUnOp(unsigned Opcode, Value *Op,\n                             const FastMathFlags &FMF,\n                             const SimplifyQuery &Q, unsigned MaxRecurse) {\n  switch (Opcode) {\n  case Instruction::FNeg:\n    return simplifyFNegInst(Op, FMF, Q, MaxRecurse);\n  default:\n    return simplifyUnOp(Opcode, Op, Q, MaxRecurse);\n  }\n}\n\nValue *llvm::SimplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q) {\n  return ::simplifyUnOp(Opcode, Op, Q, RecursionLimit);\n}\n\nValue *llvm::SimplifyUnOp(unsigned Opcode, Value *Op, FastMathFlags FMF,\n                          const SimplifyQuery &Q) {\n  return ::simplifyFPUnOp(Opcode, Op, FMF, Q, RecursionLimit);\n}\n\n/// Given operands for a BinaryOperator, see if we can fold the result.\n/// If not, this returns null.\nstatic Value *SimplifyBinOp(unsigned Opcode, Value *LHS, Value *RHS,\n                            const SimplifyQuery &Q, unsigned MaxRecurse) {\n  switch (Opcode) {\n  case Instruction::Add:\n    return SimplifyAddInst(LHS, RHS, false, false, Q, MaxRecurse);\n  case Instruction::Sub:\n    return SimplifySubInst(LHS, RHS, false, false, Q, MaxRecurse);\n  case Instruction::Mul:\n    return SimplifyMulInst(LHS, RHS, Q, MaxRecurse);\n  case Instruction::SDiv:\n    return SimplifySDivInst(LHS, RHS, Q, MaxRecurse);\n  case Instruction::UDiv:\n    return SimplifyUDivInst(LHS, RHS, Q, MaxRecurse);\n  case Instruction::SRem:\n    return SimplifySRemInst(LHS, RHS, Q, MaxRecurse);\n  case Instruction::URem:\n    return SimplifyURemInst(LHS, RHS, Q, MaxRecurse);\n  case Instruction::Shl:\n    return SimplifyShlInst(LHS, RHS, false, false, Q, MaxRecurse);\n  case Instruction::LShr:\n    return SimplifyLShrInst(LHS, RHS, false, Q, MaxRecurse);\n  case Instruction::AShr:\n    return SimplifyAShrInst(LHS, RHS, false, Q, MaxRecurse);\n  case Instruction::And:\n    return SimplifyAndInst(LHS, RHS, Q, MaxRecurse);\n  case Instruction::Or:\n    return SimplifyOrInst(LHS, RHS, Q, MaxRecurse);\n  case Instruction::Xor:\n    return SimplifyXorInst(LHS, RHS, Q, MaxRecurse);\n  case Instruction::FAdd:\n    return SimplifyFAddInst(LHS, RHS, FastMathFlags(), Q, MaxRecurse);\n  case Instruction::FSub:\n    return SimplifyFSubInst(LHS, RHS, FastMathFlags(), Q, MaxRecurse);\n  case Instruction::FMul:\n    return SimplifyFMulInst(LHS, RHS, FastMathFlags(), Q, MaxRecurse);\n  case Instruction::FDiv:\n    return SimplifyFDivInst(LHS, RHS, FastMathFlags(), Q, MaxRecurse);\n  case Instruction::FRem:\n    return SimplifyFRemInst(LHS, RHS, FastMathFlags(), Q, MaxRecurse);\n  default:\n    llvm_unreachable(\"Unexpected opcode\");\n  }\n}\n\n/// Given operands for a BinaryOperator, see if we can fold the result.\n/// If not, this returns null.\n/// Try to use FastMathFlags when folding the result.\nstatic Value *SimplifyBinOp(unsigned Opcode, Value *LHS, Value *RHS,\n                            const FastMathFlags &FMF, const SimplifyQuery &Q,\n                            unsigned MaxRecurse) {\n  switch (Opcode) {\n  case Instruction::FAdd:\n    return SimplifyFAddInst(LHS, RHS, FMF, Q, MaxRecurse);\n  case Instruction::FSub:\n    return SimplifyFSubInst(LHS, RHS, FMF, Q, MaxRecurse);\n  case Instruction::FMul:\n    return SimplifyFMulInst(LHS, RHS, FMF, Q, MaxRecurse);\n  case Instruction::FDiv:\n    return SimplifyFDivInst(LHS, RHS, FMF, Q, MaxRecurse);\n  default:\n    return SimplifyBinOp(Opcode, LHS, RHS, Q, MaxRecurse);\n  }\n}\n\nValue *llvm::SimplifyBinOp(unsigned Opcode, Value *LHS, Value *RHS,\n                           const SimplifyQuery &Q) {\n  return ::SimplifyBinOp(Opcode, LHS, RHS, Q, RecursionLimit);\n}\n\nValue *llvm::SimplifyBinOp(unsigned Opcode, Value *LHS, Value *RHS,\n                           FastMathFlags FMF, const SimplifyQuery &Q) {\n  return ::SimplifyBinOp(Opcode, LHS, RHS, FMF, Q, RecursionLimit);\n}\n\n/// Given operands for a CmpInst, see if we can fold the result.\nstatic Value *SimplifyCmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                              const SimplifyQuery &Q, unsigned MaxRecurse) {\n  if (CmpInst::isIntPredicate((CmpInst::Predicate)Predicate))\n    return SimplifyICmpInst(Predicate, LHS, RHS, Q, MaxRecurse);\n  return SimplifyFCmpInst(Predicate, LHS, RHS, FastMathFlags(), Q, MaxRecurse);\n}\n\nValue *llvm::SimplifyCmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                             const SimplifyQuery &Q) {\n  return ::SimplifyCmpInst(Predicate, LHS, RHS, Q, RecursionLimit);\n}\n\nstatic bool IsIdempotent(Intrinsic::ID ID) {\n  switch (ID) {\n  default: return false;\n\n  // Unary idempotent: f(f(x)) = f(x)\n  case Intrinsic::fabs:\n  case Intrinsic::floor:\n  case Intrinsic::ceil:\n  case Intrinsic::trunc:\n  case Intrinsic::rint:\n  case Intrinsic::nearbyint:\n  case Intrinsic::round:\n  case Intrinsic::roundeven:\n  case Intrinsic::canonicalize:\n    return true;\n  }\n}\n\nstatic Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,\n                                   const DataLayout &DL) {\n  GlobalValue *PtrSym;\n  APInt PtrOffset;\n  if (!IsConstantOffsetFromGlobal(Ptr, PtrSym, PtrOffset, DL))\n    return nullptr;\n\n  Type *Int8PtrTy = Type::getInt8PtrTy(Ptr->getContext());\n  Type *Int32Ty = Type::getInt32Ty(Ptr->getContext());\n  Type *Int32PtrTy = Int32Ty->getPointerTo();\n  Type *Int64Ty = Type::getInt64Ty(Ptr->getContext());\n\n  auto *OffsetConstInt = dyn_cast<ConstantInt>(Offset);\n  if (!OffsetConstInt || OffsetConstInt->getType()->getBitWidth() > 64)\n    return nullptr;\n\n  uint64_t OffsetInt = OffsetConstInt->getSExtValue();\n  if (OffsetInt % 4 != 0)\n    return nullptr;\n\n  Constant *C = ConstantExpr::getGetElementPtr(\n      Int32Ty, ConstantExpr::getBitCast(Ptr, Int32PtrTy),\n      ConstantInt::get(Int64Ty, OffsetInt / 4));\n  Constant *Loaded = ConstantFoldLoadFromConstPtr(C, Int32Ty, DL);\n  if (!Loaded)\n    return nullptr;\n\n  auto *LoadedCE = dyn_cast<ConstantExpr>(Loaded);\n  if (!LoadedCE)\n    return nullptr;\n\n  if (LoadedCE->getOpcode() == Instruction::Trunc) {\n    LoadedCE = dyn_cast<ConstantExpr>(LoadedCE->getOperand(0));\n    if (!LoadedCE)\n      return nullptr;\n  }\n\n  if (LoadedCE->getOpcode() != Instruction::Sub)\n    return nullptr;\n\n  auto *LoadedLHS = dyn_cast<ConstantExpr>(LoadedCE->getOperand(0));\n  if (!LoadedLHS || LoadedLHS->getOpcode() != Instruction::PtrToInt)\n    return nullptr;\n  auto *LoadedLHSPtr = LoadedLHS->getOperand(0);\n\n  Constant *LoadedRHS = LoadedCE->getOperand(1);\n  GlobalValue *LoadedRHSSym;\n  APInt LoadedRHSOffset;\n  if (!IsConstantOffsetFromGlobal(LoadedRHS, LoadedRHSSym, LoadedRHSOffset,\n                                  DL) ||\n      PtrSym != LoadedRHSSym || PtrOffset != LoadedRHSOffset)\n    return nullptr;\n\n  return ConstantExpr::getBitCast(LoadedLHSPtr, Int8PtrTy);\n}\n\nstatic Value *simplifyUnaryIntrinsic(Function *F, Value *Op0,\n                                     const SimplifyQuery &Q) {\n  // Idempotent functions return the same result when called repeatedly.\n  Intrinsic::ID IID = F->getIntrinsicID();\n  if (IsIdempotent(IID))\n    if (auto *II = dyn_cast<IntrinsicInst>(Op0))\n      if (II->getIntrinsicID() == IID)\n        return II;\n\n  Value *X;\n  switch (IID) {\n  case Intrinsic::fabs:\n    if (SignBitMustBeZero(Op0, Q.TLI)) return Op0;\n    break;\n  case Intrinsic::bswap:\n    // bswap(bswap(x)) -> x\n    if (match(Op0, m_BSwap(m_Value(X)))) return X;\n    break;\n  case Intrinsic::bitreverse:\n    // bitreverse(bitreverse(x)) -> x\n    if (match(Op0, m_BitReverse(m_Value(X)))) return X;\n    break;\n  case Intrinsic::ctpop: {\n    // If everything but the lowest bit is zero, that bit is the pop-count. Ex:\n    // ctpop(and X, 1) --> and X, 1\n    unsigned BitWidth = Op0->getType()->getScalarSizeInBits();\n    if (MaskedValueIsZero(Op0, APInt::getHighBitsSet(BitWidth, BitWidth - 1),\n                          Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n      return Op0;\n    break;\n  }\n  case Intrinsic::exp:\n    // exp(log(x)) -> x\n    if (Q.CxtI->hasAllowReassoc() &&\n        match(Op0, m_Intrinsic<Intrinsic::log>(m_Value(X)))) return X;\n    break;\n  case Intrinsic::exp2:\n    // exp2(log2(x)) -> x\n    if (Q.CxtI->hasAllowReassoc() &&\n        match(Op0, m_Intrinsic<Intrinsic::log2>(m_Value(X)))) return X;\n    break;\n  case Intrinsic::log:\n    // log(exp(x)) -> x\n    if (Q.CxtI->hasAllowReassoc() &&\n        match(Op0, m_Intrinsic<Intrinsic::exp>(m_Value(X)))) return X;\n    break;\n  case Intrinsic::log2:\n    // log2(exp2(x)) -> x\n    if (Q.CxtI->hasAllowReassoc() &&\n        (match(Op0, m_Intrinsic<Intrinsic::exp2>(m_Value(X))) ||\n         match(Op0, m_Intrinsic<Intrinsic::pow>(m_SpecificFP(2.0),\n                                                m_Value(X))))) return X;\n    break;\n  case Intrinsic::log10:\n    // log10(pow(10.0, x)) -> x\n    if (Q.CxtI->hasAllowReassoc() &&\n        match(Op0, m_Intrinsic<Intrinsic::pow>(m_SpecificFP(10.0),\n                                               m_Value(X)))) return X;\n    break;\n  case Intrinsic::floor:\n  case Intrinsic::trunc:\n  case Intrinsic::ceil:\n  case Intrinsic::round:\n  case Intrinsic::roundeven:\n  case Intrinsic::nearbyint:\n  case Intrinsic::rint: {\n    // floor (sitofp x) -> sitofp x\n    // floor (uitofp x) -> uitofp x\n    //\n    // Converting from int always results in a finite integral number or\n    // infinity. For either of those inputs, these rounding functions always\n    // return the same value, so the rounding can be eliminated.\n    if (match(Op0, m_SIToFP(m_Value())) || match(Op0, m_UIToFP(m_Value())))\n      return Op0;\n    break;\n  }\n  case Intrinsic::experimental_vector_reverse:\n    // experimental.vector.reverse(experimental.vector.reverse(x)) -> x\n    if (match(Op0,\n              m_Intrinsic<Intrinsic::experimental_vector_reverse>(m_Value(X))))\n      return X;\n    break;\n  default:\n    break;\n  }\n\n  return nullptr;\n}\n\nstatic Intrinsic::ID getMaxMinOpposite(Intrinsic::ID IID) {\n  switch (IID) {\n  case Intrinsic::smax: return Intrinsic::smin;\n  case Intrinsic::smin: return Intrinsic::smax;\n  case Intrinsic::umax: return Intrinsic::umin;\n  case Intrinsic::umin: return Intrinsic::umax;\n  default: llvm_unreachable(\"Unexpected intrinsic\");\n  }\n}\n\nstatic APInt getMaxMinLimit(Intrinsic::ID IID, unsigned BitWidth) {\n  switch (IID) {\n  case Intrinsic::smax: return APInt::getSignedMaxValue(BitWidth);\n  case Intrinsic::smin: return APInt::getSignedMinValue(BitWidth);\n  case Intrinsic::umax: return APInt::getMaxValue(BitWidth);\n  case Intrinsic::umin: return APInt::getMinValue(BitWidth);\n  default: llvm_unreachable(\"Unexpected intrinsic\");\n  }\n}\n\nstatic ICmpInst::Predicate getMaxMinPredicate(Intrinsic::ID IID) {\n  switch (IID) {\n  case Intrinsic::smax: return ICmpInst::ICMP_SGE;\n  case Intrinsic::smin: return ICmpInst::ICMP_SLE;\n  case Intrinsic::umax: return ICmpInst::ICMP_UGE;\n  case Intrinsic::umin: return ICmpInst::ICMP_ULE;\n  default: llvm_unreachable(\"Unexpected intrinsic\");\n  }\n}\n\n/// Given a min/max intrinsic, see if it can be removed based on having an\n/// operand that is another min/max intrinsic with shared operand(s). The caller\n/// is expected to swap the operand arguments to handle commutation.\nstatic Value *foldMinMaxSharedOp(Intrinsic::ID IID, Value *Op0, Value *Op1) {\n  Value *X, *Y;\n  if (!match(Op0, m_MaxOrMin(m_Value(X), m_Value(Y))))\n    return nullptr;\n\n  auto *MM0 = dyn_cast<IntrinsicInst>(Op0);\n  if (!MM0)\n    return nullptr;\n  Intrinsic::ID IID0 = MM0->getIntrinsicID();\n\n  if (Op1 == X || Op1 == Y ||\n      match(Op1, m_c_MaxOrMin(m_Specific(X), m_Specific(Y)))) {\n    // max (max X, Y), X --> max X, Y\n    if (IID0 == IID)\n      return MM0;\n    // max (min X, Y), X --> X\n    if (IID0 == getMaxMinOpposite(IID))\n      return Op1;\n  }\n  return nullptr;\n}\n\nstatic Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,\n                                      const SimplifyQuery &Q) {\n  Intrinsic::ID IID = F->getIntrinsicID();\n  Type *ReturnType = F->getReturnType();\n  unsigned BitWidth = ReturnType->getScalarSizeInBits();\n  switch (IID) {\n  case Intrinsic::abs:\n    // abs(abs(x)) -> abs(x). We don't need to worry about the nsw arg here.\n    // It is always ok to pick the earlier abs. We'll just lose nsw if its only\n    // on the outer abs.\n    if (match(Op0, m_Intrinsic<Intrinsic::abs>(m_Value(), m_Value())))\n      return Op0;\n    break;\n\n  case Intrinsic::smax:\n  case Intrinsic::smin:\n  case Intrinsic::umax:\n  case Intrinsic::umin: {\n    // If the arguments are the same, this is a no-op.\n    if (Op0 == Op1)\n      return Op0;\n\n    // Canonicalize constant operand as Op1.\n    if (isa<Constant>(Op0))\n      std::swap(Op0, Op1);\n\n    // Assume undef is the limit value.\n    if (Q.isUndefValue(Op1))\n      return ConstantInt::get(ReturnType, getMaxMinLimit(IID, BitWidth));\n\n    const APInt *C;\n    if (match(Op1, m_APIntAllowUndef(C))) {\n      // Clamp to limit value. For example:\n      // umax(i8 %x, i8 255) --> 255\n      if (*C == getMaxMinLimit(IID, BitWidth))\n        return ConstantInt::get(ReturnType, *C);\n\n      // If the constant op is the opposite of the limit value, the other must\n      // be larger/smaller or equal. For example:\n      // umin(i8 %x, i8 255) --> %x\n      if (*C == getMaxMinLimit(getMaxMinOpposite(IID), BitWidth))\n        return Op0;\n\n      // Remove nested call if constant operands allow it. Example:\n      // max (max X, 7), 5 -> max X, 7\n      auto *MinMax0 = dyn_cast<IntrinsicInst>(Op0);\n      if (MinMax0 && MinMax0->getIntrinsicID() == IID) {\n        // TODO: loosen undef/splat restrictions for vector constants.\n        Value *M00 = MinMax0->getOperand(0), *M01 = MinMax0->getOperand(1);\n        const APInt *InnerC;\n        if ((match(M00, m_APInt(InnerC)) || match(M01, m_APInt(InnerC))) &&\n            ((IID == Intrinsic::smax && InnerC->sge(*C)) ||\n             (IID == Intrinsic::smin && InnerC->sle(*C)) ||\n             (IID == Intrinsic::umax && InnerC->uge(*C)) ||\n             (IID == Intrinsic::umin && InnerC->ule(*C))))\n          return Op0;\n      }\n    }\n\n    if (Value *V = foldMinMaxSharedOp(IID, Op0, Op1))\n      return V;\n    if (Value *V = foldMinMaxSharedOp(IID, Op1, Op0))\n      return V;\n\n    ICmpInst::Predicate Pred = getMaxMinPredicate(IID);\n    if (isICmpTrue(Pred, Op0, Op1, Q.getWithoutUndef(), RecursionLimit))\n      return Op0;\n    if (isICmpTrue(Pred, Op1, Op0, Q.getWithoutUndef(), RecursionLimit))\n      return Op1;\n\n    if (Optional<bool> Imp =\n            isImpliedByDomCondition(Pred, Op0, Op1, Q.CxtI, Q.DL))\n      return *Imp ? Op0 : Op1;\n    if (Optional<bool> Imp =\n            isImpliedByDomCondition(Pred, Op1, Op0, Q.CxtI, Q.DL))\n      return *Imp ? Op1 : Op0;\n\n    break;\n  }\n  case Intrinsic::usub_with_overflow:\n  case Intrinsic::ssub_with_overflow:\n    // X - X -> { 0, false }\n    // X - undef -> { 0, false }\n    // undef - X -> { 0, false }\n    if (Op0 == Op1 || Q.isUndefValue(Op0) || Q.isUndefValue(Op1))\n      return Constant::getNullValue(ReturnType);\n    break;\n  case Intrinsic::uadd_with_overflow:\n  case Intrinsic::sadd_with_overflow:\n    // X + undef -> { -1, false }\n    // undef + x -> { -1, false }\n    if (Q.isUndefValue(Op0) || Q.isUndefValue(Op1)) {\n      return ConstantStruct::get(\n          cast<StructType>(ReturnType),\n          {Constant::getAllOnesValue(ReturnType->getStructElementType(0)),\n           Constant::getNullValue(ReturnType->getStructElementType(1))});\n    }\n    break;\n  case Intrinsic::umul_with_overflow:\n  case Intrinsic::smul_with_overflow:\n    // 0 * X -> { 0, false }\n    // X * 0 -> { 0, false }\n    if (match(Op0, m_Zero()) || match(Op1, m_Zero()))\n      return Constant::getNullValue(ReturnType);\n    // undef * X -> { 0, false }\n    // X * undef -> { 0, false }\n    if (Q.isUndefValue(Op0) || Q.isUndefValue(Op1))\n      return Constant::getNullValue(ReturnType);\n    break;\n  case Intrinsic::uadd_sat:\n    // sat(MAX + X) -> MAX\n    // sat(X + MAX) -> MAX\n    if (match(Op0, m_AllOnes()) || match(Op1, m_AllOnes()))\n      return Constant::getAllOnesValue(ReturnType);\n    LLVM_FALLTHROUGH;\n  case Intrinsic::sadd_sat:\n    // sat(X + undef) -> -1\n    // sat(undef + X) -> -1\n    // For unsigned: Assume undef is MAX, thus we saturate to MAX (-1).\n    // For signed: Assume undef is ~X, in which case X + ~X = -1.\n    if (Q.isUndefValue(Op0) || Q.isUndefValue(Op1))\n      return Constant::getAllOnesValue(ReturnType);\n\n    // X + 0 -> X\n    if (match(Op1, m_Zero()))\n      return Op0;\n    // 0 + X -> X\n    if (match(Op0, m_Zero()))\n      return Op1;\n    break;\n  case Intrinsic::usub_sat:\n    // sat(0 - X) -> 0, sat(X - MAX) -> 0\n    if (match(Op0, m_Zero()) || match(Op1, m_AllOnes()))\n      return Constant::getNullValue(ReturnType);\n    LLVM_FALLTHROUGH;\n  case Intrinsic::ssub_sat:\n    // X - X -> 0, X - undef -> 0, undef - X -> 0\n    if (Op0 == Op1 || Q.isUndefValue(Op0) || Q.isUndefValue(Op1))\n      return Constant::getNullValue(ReturnType);\n    // X - 0 -> X\n    if (match(Op1, m_Zero()))\n      return Op0;\n    break;\n  case Intrinsic::load_relative:\n    if (auto *C0 = dyn_cast<Constant>(Op0))\n      if (auto *C1 = dyn_cast<Constant>(Op1))\n        return SimplifyRelativeLoad(C0, C1, Q.DL);\n    break;\n  case Intrinsic::powi:\n    if (auto *Power = dyn_cast<ConstantInt>(Op1)) {\n      // powi(x, 0) -> 1.0\n      if (Power->isZero())\n        return ConstantFP::get(Op0->getType(), 1.0);\n      // powi(x, 1) -> x\n      if (Power->isOne())\n        return Op0;\n    }\n    break;\n  case Intrinsic::copysign:\n    // copysign X, X --> X\n    if (Op0 == Op1)\n      return Op0;\n    // copysign -X, X --> X\n    // copysign X, -X --> -X\n    if (match(Op0, m_FNeg(m_Specific(Op1))) ||\n        match(Op1, m_FNeg(m_Specific(Op0))))\n      return Op1;\n    break;\n  case Intrinsic::maxnum:\n  case Intrinsic::minnum:\n  case Intrinsic::maximum:\n  case Intrinsic::minimum: {\n    // If the arguments are the same, this is a no-op.\n    if (Op0 == Op1) return Op0;\n\n    // Canonicalize constant operand as Op1.\n    if (isa<Constant>(Op0))\n      std::swap(Op0, Op1);\n\n    // If an argument is undef, return the other argument.\n    if (Q.isUndefValue(Op1))\n      return Op0;\n\n    bool PropagateNaN = IID == Intrinsic::minimum || IID == Intrinsic::maximum;\n    bool IsMin = IID == Intrinsic::minimum || IID == Intrinsic::minnum;\n\n    // minnum(X, nan) -> X\n    // maxnum(X, nan) -> X\n    // minimum(X, nan) -> nan\n    // maximum(X, nan) -> nan\n    if (match(Op1, m_NaN()))\n      return PropagateNaN ? propagateNaN(cast<Constant>(Op1)) : Op0;\n\n    // In the following folds, inf can be replaced with the largest finite\n    // float, if the ninf flag is set.\n    const APFloat *C;\n    if (match(Op1, m_APFloat(C)) &&\n        (C->isInfinity() || (Q.CxtI->hasNoInfs() && C->isLargest()))) {\n      // minnum(X, -inf) -> -inf\n      // maxnum(X, +inf) -> +inf\n      // minimum(X, -inf) -> -inf if nnan\n      // maximum(X, +inf) -> +inf if nnan\n      if (C->isNegative() == IsMin && (!PropagateNaN || Q.CxtI->hasNoNaNs()))\n        return ConstantFP::get(ReturnType, *C);\n\n      // minnum(X, +inf) -> X if nnan\n      // maxnum(X, -inf) -> X if nnan\n      // minimum(X, +inf) -> X\n      // maximum(X, -inf) -> X\n      if (C->isNegative() != IsMin && (PropagateNaN || Q.CxtI->hasNoNaNs()))\n        return Op0;\n    }\n\n    // Min/max of the same operation with common operand:\n    // m(m(X, Y)), X --> m(X, Y) (4 commuted variants)\n    if (auto *M0 = dyn_cast<IntrinsicInst>(Op0))\n      if (M0->getIntrinsicID() == IID &&\n          (M0->getOperand(0) == Op1 || M0->getOperand(1) == Op1))\n        return Op0;\n    if (auto *M1 = dyn_cast<IntrinsicInst>(Op1))\n      if (M1->getIntrinsicID() == IID &&\n          (M1->getOperand(0) == Op0 || M1->getOperand(1) == Op0))\n        return Op1;\n\n    break;\n  }\n  default:\n    break;\n  }\n\n  return nullptr;\n}\n\nstatic Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {\n\n  // Intrinsics with no operands have some kind of side effect. Don't simplify.\n  unsigned NumOperands = Call->getNumArgOperands();\n  if (!NumOperands)\n    return nullptr;\n\n  Function *F = cast<Function>(Call->getCalledFunction());\n  Intrinsic::ID IID = F->getIntrinsicID();\n  if (NumOperands == 1)\n    return simplifyUnaryIntrinsic(F, Call->getArgOperand(0), Q);\n\n  if (NumOperands == 2)\n    return simplifyBinaryIntrinsic(F, Call->getArgOperand(0),\n                                   Call->getArgOperand(1), Q);\n\n  // Handle intrinsics with 3 or more arguments.\n  switch (IID) {\n  case Intrinsic::masked_load:\n  case Intrinsic::masked_gather: {\n    Value *MaskArg = Call->getArgOperand(2);\n    Value *PassthruArg = Call->getArgOperand(3);\n    // If the mask is all zeros or undef, the \"passthru\" argument is the result.\n    if (maskIsAllZeroOrUndef(MaskArg))\n      return PassthruArg;\n    return nullptr;\n  }\n  case Intrinsic::fshl:\n  case Intrinsic::fshr: {\n    Value *Op0 = Call->getArgOperand(0), *Op1 = Call->getArgOperand(1),\n          *ShAmtArg = Call->getArgOperand(2);\n\n    // If both operands are undef, the result is undef.\n    if (Q.isUndefValue(Op0) && Q.isUndefValue(Op1))\n      return UndefValue::get(F->getReturnType());\n\n    // If shift amount is undef, assume it is zero.\n    if (Q.isUndefValue(ShAmtArg))\n      return Call->getArgOperand(IID == Intrinsic::fshl ? 0 : 1);\n\n    const APInt *ShAmtC;\n    if (match(ShAmtArg, m_APInt(ShAmtC))) {\n      // If there's effectively no shift, return the 1st arg or 2nd arg.\n      APInt BitWidth = APInt(ShAmtC->getBitWidth(), ShAmtC->getBitWidth());\n      if (ShAmtC->urem(BitWidth).isNullValue())\n        return Call->getArgOperand(IID == Intrinsic::fshl ? 0 : 1);\n    }\n    return nullptr;\n  }\n  case Intrinsic::fma:\n  case Intrinsic::fmuladd: {\n    Value *Op0 = Call->getArgOperand(0);\n    Value *Op1 = Call->getArgOperand(1);\n    Value *Op2 = Call->getArgOperand(2);\n    if (Value *V = simplifyFPOp({ Op0, Op1, Op2 }, {}, Q))\n      return V;\n    return nullptr;\n  }\n  default:\n    return nullptr;\n  }\n}\n\nstatic Value *tryConstantFoldCall(CallBase *Call, const SimplifyQuery &Q) {\n  auto *F = dyn_cast<Function>(Call->getCalledOperand());\n  if (!F || !canConstantFoldCallTo(Call, F))\n    return nullptr;\n\n  SmallVector<Constant *, 4> ConstantArgs;\n  unsigned NumArgs = Call->getNumArgOperands();\n  ConstantArgs.reserve(NumArgs);\n  for (auto &Arg : Call->args()) {\n    Constant *C = dyn_cast<Constant>(&Arg);\n    if (!C) {\n      if (isa<MetadataAsValue>(Arg.get()))\n        continue;\n      return nullptr;\n    }\n    ConstantArgs.push_back(C);\n  }\n\n  return ConstantFoldCall(Call, F, ConstantArgs, Q.TLI);\n}\n\nValue *llvm::SimplifyCall(CallBase *Call, const SimplifyQuery &Q) {\n  // musttail calls can only be simplified if they are also DCEd.\n  // As we can't guarantee this here, don't simplify them.\n  if (Call->isMustTailCall())\n    return nullptr;\n\n  // call undef -> poison\n  // call null -> poison\n  Value *Callee = Call->getCalledOperand();\n  if (isa<UndefValue>(Callee) || isa<ConstantPointerNull>(Callee))\n    return PoisonValue::get(Call->getType());\n\n  if (Value *V = tryConstantFoldCall(Call, Q))\n    return V;\n\n  auto *F = dyn_cast<Function>(Callee);\n  if (F && F->isIntrinsic())\n    if (Value *Ret = simplifyIntrinsic(Call, Q))\n      return Ret;\n\n  return nullptr;\n}\n\n/// Given operands for a Freeze, see if we can fold the result.\nstatic Value *SimplifyFreezeInst(Value *Op0, const SimplifyQuery &Q) {\n  // Use a utility function defined in ValueTracking.\n  if (llvm::isGuaranteedNotToBeUndefOrPoison(Op0, Q.AC, Q.CxtI, Q.DT))\n    return Op0;\n  // We have room for improvement.\n  return nullptr;\n}\n\nValue *llvm::SimplifyFreezeInst(Value *Op0, const SimplifyQuery &Q) {\n  return ::SimplifyFreezeInst(Op0, Q);\n}\n\n/// See if we can compute a simplified version of this instruction.\n/// If not, this returns null.\n\nValue *llvm::SimplifyInstruction(Instruction *I, const SimplifyQuery &SQ,\n                                 OptimizationRemarkEmitter *ORE) {\n  const SimplifyQuery Q = SQ.CxtI ? SQ : SQ.getWithInstruction(I);\n  Value *Result;\n\n  switch (I->getOpcode()) {\n  default:\n    Result = ConstantFoldInstruction(I, Q.DL, Q.TLI);\n    break;\n  case Instruction::FNeg:\n    Result = SimplifyFNegInst(I->getOperand(0), I->getFastMathFlags(), Q);\n    break;\n  case Instruction::FAdd:\n    Result = SimplifyFAddInst(I->getOperand(0), I->getOperand(1),\n                              I->getFastMathFlags(), Q);\n    break;\n  case Instruction::Add:\n    Result =\n        SimplifyAddInst(I->getOperand(0), I->getOperand(1),\n                        Q.IIQ.hasNoSignedWrap(cast<BinaryOperator>(I)),\n                        Q.IIQ.hasNoUnsignedWrap(cast<BinaryOperator>(I)), Q);\n    break;\n  case Instruction::FSub:\n    Result = SimplifyFSubInst(I->getOperand(0), I->getOperand(1),\n                              I->getFastMathFlags(), Q);\n    break;\n  case Instruction::Sub:\n    Result =\n        SimplifySubInst(I->getOperand(0), I->getOperand(1),\n                        Q.IIQ.hasNoSignedWrap(cast<BinaryOperator>(I)),\n                        Q.IIQ.hasNoUnsignedWrap(cast<BinaryOperator>(I)), Q);\n    break;\n  case Instruction::FMul:\n    Result = SimplifyFMulInst(I->getOperand(0), I->getOperand(1),\n                              I->getFastMathFlags(), Q);\n    break;\n  case Instruction::Mul:\n    Result = SimplifyMulInst(I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::SDiv:\n    Result = SimplifySDivInst(I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::UDiv:\n    Result = SimplifyUDivInst(I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::FDiv:\n    Result = SimplifyFDivInst(I->getOperand(0), I->getOperand(1),\n                              I->getFastMathFlags(), Q);\n    break;\n  case Instruction::SRem:\n    Result = SimplifySRemInst(I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::URem:\n    Result = SimplifyURemInst(I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::FRem:\n    Result = SimplifyFRemInst(I->getOperand(0), I->getOperand(1),\n                              I->getFastMathFlags(), Q);\n    break;\n  case Instruction::Shl:\n    Result =\n        SimplifyShlInst(I->getOperand(0), I->getOperand(1),\n                        Q.IIQ.hasNoSignedWrap(cast<BinaryOperator>(I)),\n                        Q.IIQ.hasNoUnsignedWrap(cast<BinaryOperator>(I)), Q);\n    break;\n  case Instruction::LShr:\n    Result = SimplifyLShrInst(I->getOperand(0), I->getOperand(1),\n                              Q.IIQ.isExact(cast<BinaryOperator>(I)), Q);\n    break;\n  case Instruction::AShr:\n    Result = SimplifyAShrInst(I->getOperand(0), I->getOperand(1),\n                              Q.IIQ.isExact(cast<BinaryOperator>(I)), Q);\n    break;\n  case Instruction::And:\n    Result = SimplifyAndInst(I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::Or:\n    Result = SimplifyOrInst(I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::Xor:\n    Result = SimplifyXorInst(I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::ICmp:\n    Result = SimplifyICmpInst(cast<ICmpInst>(I)->getPredicate(),\n                              I->getOperand(0), I->getOperand(1), Q);\n    break;\n  case Instruction::FCmp:\n    Result =\n        SimplifyFCmpInst(cast<FCmpInst>(I)->getPredicate(), I->getOperand(0),\n                         I->getOperand(1), I->getFastMathFlags(), Q);\n    break;\n  case Instruction::Select:\n    Result = SimplifySelectInst(I->getOperand(0), I->getOperand(1),\n                                I->getOperand(2), Q);\n    break;\n  case Instruction::GetElementPtr: {\n    SmallVector<Value *, 8> Ops(I->operands());\n    Result = SimplifyGEPInst(cast<GetElementPtrInst>(I)->getSourceElementType(),\n                             Ops, Q);\n    break;\n  }\n  case Instruction::InsertValue: {\n    InsertValueInst *IV = cast<InsertValueInst>(I);\n    Result = SimplifyInsertValueInst(IV->getAggregateOperand(),\n                                     IV->getInsertedValueOperand(),\n                                     IV->getIndices(), Q);\n    break;\n  }\n  case Instruction::InsertElement: {\n    auto *IE = cast<InsertElementInst>(I);\n    Result = SimplifyInsertElementInst(IE->getOperand(0), IE->getOperand(1),\n                                       IE->getOperand(2), Q);\n    break;\n  }\n  case Instruction::ExtractValue: {\n    auto *EVI = cast<ExtractValueInst>(I);\n    Result = SimplifyExtractValueInst(EVI->getAggregateOperand(),\n                                      EVI->getIndices(), Q);\n    break;\n  }\n  case Instruction::ExtractElement: {\n    auto *EEI = cast<ExtractElementInst>(I);\n    Result = SimplifyExtractElementInst(EEI->getVectorOperand(),\n                                        EEI->getIndexOperand(), Q);\n    break;\n  }\n  case Instruction::ShuffleVector: {\n    auto *SVI = cast<ShuffleVectorInst>(I);\n    Result =\n        SimplifyShuffleVectorInst(SVI->getOperand(0), SVI->getOperand(1),\n                                  SVI->getShuffleMask(), SVI->getType(), Q);\n    break;\n  }\n  case Instruction::PHI:\n    Result = SimplifyPHINode(cast<PHINode>(I), Q);\n    break;\n  case Instruction::Call: {\n    Result = SimplifyCall(cast<CallInst>(I), Q);\n    break;\n  }\n  case Instruction::Freeze:\n    Result = SimplifyFreezeInst(I->getOperand(0), Q);\n    break;\n#define HANDLE_CAST_INST(num, opc, clas) case Instruction::opc:\n#include \"llvm/IR/Instruction.def\"\n#undef HANDLE_CAST_INST\n    Result =\n        SimplifyCastInst(I->getOpcode(), I->getOperand(0), I->getType(), Q);\n    break;\n  case Instruction::Alloca:\n    // No simplifications for Alloca and it can't be constant folded.\n    Result = nullptr;\n    break;\n  }\n\n  /// If called on unreachable code, the above logic may report that the\n  /// instruction simplified to itself.  Make life easier for users by\n  /// detecting that case here, returning a safe value instead.\n  return Result == I ? UndefValue::get(I->getType()) : Result;\n}\n\n/// Implementation of recursive simplification through an instruction's\n/// uses.\n///\n/// This is the common implementation of the recursive simplification routines.\n/// If we have a pre-simplified value in 'SimpleV', that is forcibly used to\n/// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of\n/// instructions to process and attempt to simplify it using\n/// InstructionSimplify. Recursively visited users which could not be\n/// simplified themselves are to the optional UnsimplifiedUsers set for\n/// further processing by the caller.\n///\n/// This routine returns 'true' only when *it* simplifies something. The passed\n/// in simplified value does not count toward this.\nstatic bool replaceAndRecursivelySimplifyImpl(\n    Instruction *I, Value *SimpleV, const TargetLibraryInfo *TLI,\n    const DominatorTree *DT, AssumptionCache *AC,\n    SmallSetVector<Instruction *, 8> *UnsimplifiedUsers = nullptr) {\n  bool Simplified = false;\n  SmallSetVector<Instruction *, 8> Worklist;\n  const DataLayout &DL = I->getModule()->getDataLayout();\n\n  // If we have an explicit value to collapse to, do that round of the\n  // simplification loop by hand initially.\n  if (SimpleV) {\n    for (User *U : I->users())\n      if (U != I)\n        Worklist.insert(cast<Instruction>(U));\n\n    // Replace the instruction with its simplified value.\n    I->replaceAllUsesWith(SimpleV);\n\n    // Gracefully handle edge cases where the instruction is not wired into any\n    // parent block.\n    if (I->getParent() && !I->isEHPad() && !I->isTerminator() &&\n        !I->mayHaveSideEffects())\n      I->eraseFromParent();\n  } else {\n    Worklist.insert(I);\n  }\n\n  // Note that we must test the size on each iteration, the worklist can grow.\n  for (unsigned Idx = 0; Idx != Worklist.size(); ++Idx) {\n    I = Worklist[Idx];\n\n    // See if this instruction simplifies.\n    SimpleV = SimplifyInstruction(I, {DL, TLI, DT, AC});\n    if (!SimpleV) {\n      if (UnsimplifiedUsers)\n        UnsimplifiedUsers->insert(I);\n      continue;\n    }\n\n    Simplified = true;\n\n    // Stash away all the uses of the old instruction so we can check them for\n    // recursive simplifications after a RAUW. This is cheaper than checking all\n    // uses of To on the recursive step in most cases.\n    for (User *U : I->users())\n      Worklist.insert(cast<Instruction>(U));\n\n    // Replace the instruction with its simplified value.\n    I->replaceAllUsesWith(SimpleV);\n\n    // Gracefully handle edge cases where the instruction is not wired into any\n    // parent block.\n    if (I->getParent() && !I->isEHPad() && !I->isTerminator() &&\n        !I->mayHaveSideEffects())\n      I->eraseFromParent();\n  }\n  return Simplified;\n}\n\nbool llvm::replaceAndRecursivelySimplify(\n    Instruction *I, Value *SimpleV, const TargetLibraryInfo *TLI,\n    const DominatorTree *DT, AssumptionCache *AC,\n    SmallSetVector<Instruction *, 8> *UnsimplifiedUsers) {\n  assert(I != SimpleV && \"replaceAndRecursivelySimplify(X,X) is not valid!\");\n  assert(SimpleV && \"Must provide a simplified value.\");\n  return replaceAndRecursivelySimplifyImpl(I, SimpleV, TLI, DT, AC,\n                                           UnsimplifiedUsers);\n}\n\nnamespace llvm {\nconst SimplifyQuery getBestSimplifyQuery(Pass &P, Function &F) {\n  auto *DTWP = P.getAnalysisIfAvailable<DominatorTreeWrapperPass>();\n  auto *DT = DTWP ? &DTWP->getDomTree() : nullptr;\n  auto *TLIWP = P.getAnalysisIfAvailable<TargetLibraryInfoWrapperPass>();\n  auto *TLI = TLIWP ? &TLIWP->getTLI(F) : nullptr;\n  auto *ACWP = P.getAnalysisIfAvailable<AssumptionCacheTracker>();\n  auto *AC = ACWP ? &ACWP->getAssumptionCache(F) : nullptr;\n  return {F.getParent()->getDataLayout(), TLI, DT, AC};\n}\n\nconst SimplifyQuery getBestSimplifyQuery(LoopStandardAnalysisResults &AR,\n                                         const DataLayout &DL) {\n  return {DL, &AR.TLI, &AR.DT, &AR.AC};\n}\n\ntemplate <class T, class... TArgs>\nconst SimplifyQuery getBestSimplifyQuery(AnalysisManager<T, TArgs...> &AM,\n                                         Function &F) {\n  auto *DT = AM.template getCachedResult<DominatorTreeAnalysis>(F);\n  auto *TLI = AM.template getCachedResult<TargetLibraryAnalysis>(F);\n  auto *AC = AM.template getCachedResult<AssumptionAnalysis>(F);\n  return {F.getParent()->getDataLayout(), TLI, DT, AC};\n}\ntemplate const SimplifyQuery getBestSimplifyQuery(AnalysisManager<Function> &,\n                                                  Function &);\n}\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "content": "//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares routines for folding instructions into simpler forms\n// that do not require creating new instructions.  This does constant folding\n// (\"add i32 1, 1\" -> \"2\") but can also handle non-constant operands, either\n// returning a constant (\"and i32 %x, 0\" -> \"0\") or an already existing value\n// (\"and i32 %x, %x\" -> \"%x\").  If the simplification is also an instruction\n// then it dominates the original instruction.\n//\n// These routines implicitly resolve undef uses. The easiest way to be safe when\n// using these routines to obtain simplified values for existing instructions is\n// to always replace all uses of the instructions with the resulting simplified\n// values. This will prevent other code from seeing the same undef uses and\n// resolving them to different values.\n//\n// These routines are designed to tolerate moderately incomplete IR, such as\n// instructions that are not connected to basic blocks yet. However, they do\n// require that all the IR that they encounter be valid. In particular, they\n// require that all non-constant values be defined in the same function, and the\n// same call context of that function (and not split between caller and callee\n// contexts of a directly recursive call, for example).\n//\n// Additionally, these routines can't simplify to the instructions that are not\n// def-reachable, meaning we can't just scan the basic block for instructions\n// to simplify to.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_INSTRUCTIONSIMPLIFY_H\n#define LLVM_ANALYSIS_INSTRUCTIONSIMPLIFY_H\n\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Operator.h\"\n\nnamespace llvm {\n\ntemplate <typename T, typename... TArgs> class AnalysisManager;\ntemplate <class T> class ArrayRef;\nclass AssumptionCache;\nclass BinaryOperator;\nclass CallBase;\nclass DataLayout;\nclass DominatorTree;\nclass Function;\nstruct LoopStandardAnalysisResults;\nclass MDNode;\nclass OptimizationRemarkEmitter;\nclass Pass;\ntemplate <class T, unsigned n> class SmallSetVector;\nclass TargetLibraryInfo;\nclass Type;\nclass Value;\n\n/// InstrInfoQuery provides an interface to query additional information for\n/// instructions like metadata or keywords like nsw, which provides conservative\n/// results if the users specified it is safe to use.\nstruct InstrInfoQuery {\n  InstrInfoQuery(bool UMD) : UseInstrInfo(UMD) {}\n  InstrInfoQuery() : UseInstrInfo(true) {}\n  bool UseInstrInfo = true;\n\n  MDNode *getMetadata(const Instruction *I, unsigned KindID) const {\n    if (UseInstrInfo)\n      return I->getMetadata(KindID);\n    return nullptr;\n  }\n\n  template <class InstT> bool hasNoUnsignedWrap(const InstT *Op) const {\n    if (UseInstrInfo)\n      return Op->hasNoUnsignedWrap();\n    return false;\n  }\n\n  template <class InstT> bool hasNoSignedWrap(const InstT *Op) const {\n    if (UseInstrInfo)\n      return Op->hasNoSignedWrap();\n    return false;\n  }\n\n  bool isExact(const BinaryOperator *Op) const {\n    if (UseInstrInfo && isa<PossiblyExactOperator>(Op))\n      return cast<PossiblyExactOperator>(Op)->isExact();\n    return false;\n  }\n};\n\nstruct SimplifyQuery {\n  const DataLayout &DL;\n  const TargetLibraryInfo *TLI = nullptr;\n  const DominatorTree *DT = nullptr;\n  AssumptionCache *AC = nullptr;\n  const Instruction *CxtI = nullptr;\n\n  // Wrapper to query additional information for instructions like metadata or\n  // keywords like nsw, which provides conservative results if those cannot\n  // be safely used.\n  const InstrInfoQuery IIQ;\n\n  /// Controls whether simplifications are allowed to constrain the range of\n  /// possible values for uses of undef. If it is false, simplifications are not\n  /// allowed to assume a particular value for a use of undef for example.\n  bool CanUseUndef = true;\n\n  SimplifyQuery(const DataLayout &DL, const Instruction *CXTI = nullptr)\n      : DL(DL), CxtI(CXTI) {}\n\n  SimplifyQuery(const DataLayout &DL, const TargetLibraryInfo *TLI,\n                const DominatorTree *DT = nullptr,\n                AssumptionCache *AC = nullptr,\n                const Instruction *CXTI = nullptr, bool UseInstrInfo = true,\n                bool CanUseUndef = true)\n      : DL(DL), TLI(TLI), DT(DT), AC(AC), CxtI(CXTI), IIQ(UseInstrInfo),\n        CanUseUndef(CanUseUndef) {}\n  SimplifyQuery getWithInstruction(Instruction *I) const {\n    SimplifyQuery Copy(*this);\n    Copy.CxtI = I;\n    return Copy;\n  }\n  SimplifyQuery getWithoutUndef() const {\n    SimplifyQuery Copy(*this);\n    Copy.CanUseUndef = false;\n    return Copy;\n  }\n\n  /// If CanUseUndef is true, returns whether \\p V is undef.\n  /// Otherwise always return false.\n  bool isUndefValue(Value *V) const {\n    if (!CanUseUndef)\n      return false;\n    return isa<UndefValue>(V);\n  }\n};\n\n// NOTE: the explicit multiple argument versions of these functions are\n// deprecated.\n// Please use the SimplifyQuery versions in new code.\n\n/// Given operand for an FNeg, fold the result or return null.\nValue *SimplifyFNegInst(Value *Op, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an Add, fold the result or return null.\nValue *SimplifyAddInst(Value *LHS, Value *RHS, bool isNSW, bool isNUW,\n                       const SimplifyQuery &Q);\n\n/// Given operands for a Sub, fold the result or return null.\nValue *SimplifySubInst(Value *LHS, Value *RHS, bool isNSW, bool isNUW,\n                       const SimplifyQuery &Q);\n\n/// Given operands for an FAdd, fold the result or return null.\nValue *SimplifyFAddInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an FSub, fold the result or return null.\nValue *SimplifyFSubInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an FMul, fold the result or return null.\nValue *SimplifyFMulInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for the multiplication of a FMA, fold the result or return\n/// null. In contrast to SimplifyFMulInst, this function will not perform\n/// simplifications whose unrounded results differ when rounded to the argument\n/// type.\nValue *SimplifyFMAFMul(Value *LHS, Value *RHS, FastMathFlags FMF,\n                       const SimplifyQuery &Q);\n\n/// Given operands for a Mul, fold the result or return null.\nValue *SimplifyMulInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an SDiv, fold the result or return null.\nValue *SimplifySDivInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for a UDiv, fold the result or return null.\nValue *SimplifyUDivInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an FDiv, fold the result or return null.\nValue *SimplifyFDivInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an SRem, fold the result or return null.\nValue *SimplifySRemInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for a URem, fold the result or return null.\nValue *SimplifyURemInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an FRem, fold the result or return null.\nValue *SimplifyFRemInst(Value *LHS, Value *RHS, FastMathFlags FMF,\n                        const SimplifyQuery &Q);\n\n/// Given operands for a Shl, fold the result or return null.\nValue *SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,\n                       const SimplifyQuery &Q);\n\n/// Given operands for a LShr, fold the result or return null.\nValue *SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,\n                        const SimplifyQuery &Q);\n\n/// Given operands for a AShr, fold the result or return nulll.\nValue *SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an And, fold the result or return null.\nValue *SimplifyAndInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an Or, fold the result or return null.\nValue *SimplifyOrInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an Xor, fold the result or return null.\nValue *SimplifyXorInst(Value *LHS, Value *RHS, const SimplifyQuery &Q);\n\n/// Given operands for an ICmpInst, fold the result or return null.\nValue *SimplifyICmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                        const SimplifyQuery &Q);\n\n/// Given operands for an FCmpInst, fold the result or return null.\nValue *SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                        FastMathFlags FMF, const SimplifyQuery &Q);\n\n/// Given operands for a SelectInst, fold the result or return null.\nValue *SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,\n                          const SimplifyQuery &Q);\n\n/// Given operands for a GetElementPtrInst, fold the result or return null.\nValue *SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,\n                       const SimplifyQuery &Q);\n\n/// Given operands for an InsertValueInst, fold the result or return null.\nValue *SimplifyInsertValueInst(Value *Agg, Value *Val, ArrayRef<unsigned> Idxs,\n                               const SimplifyQuery &Q);\n\n/// Given operands for an InsertElement, fold the result or return null.\nValue *SimplifyInsertElementInst(Value *Vec, Value *Elt, Value *Idx,\n                                 const SimplifyQuery &Q);\n\n/// Given operands for an ExtractValueInst, fold the result or return null.\nValue *SimplifyExtractValueInst(Value *Agg, ArrayRef<unsigned> Idxs,\n                                const SimplifyQuery &Q);\n\n/// Given operands for an ExtractElementInst, fold the result or return null.\nValue *SimplifyExtractElementInst(Value *Vec, Value *Idx,\n                                  const SimplifyQuery &Q);\n\n/// Given operands for a CastInst, fold the result or return null.\nValue *SimplifyCastInst(unsigned CastOpc, Value *Op, Type *Ty,\n                        const SimplifyQuery &Q);\n\n/// Given operands for a ShuffleVectorInst, fold the result or return null.\n/// See class ShuffleVectorInst for a description of the mask representation.\nValue *SimplifyShuffleVectorInst(Value *Op0, Value *Op1, ArrayRef<int> Mask,\n                                 Type *RetTy, const SimplifyQuery &Q);\n\n//=== Helper functions for higher up the class hierarchy.\n\n/// Given operands for a CmpInst, fold the result or return null.\nValue *SimplifyCmpInst(unsigned Predicate, Value *LHS, Value *RHS,\n                       const SimplifyQuery &Q);\n\n/// Given operand for a UnaryOperator, fold the result or return null.\nValue *SimplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q);\n\n/// Given operand for a UnaryOperator, fold the result or return null.\n/// Try to use FastMathFlags when folding the result.\nValue *SimplifyUnOp(unsigned Opcode, Value *Op, FastMathFlags FMF,\n                    const SimplifyQuery &Q);\n\n/// Given operands for a BinaryOperator, fold the result or return null.\nValue *SimplifyBinOp(unsigned Opcode, Value *LHS, Value *RHS,\n                     const SimplifyQuery &Q);\n\n/// Given operands for a BinaryOperator, fold the result or return null.\n/// Try to use FastMathFlags when folding the result.\nValue *SimplifyBinOp(unsigned Opcode, Value *LHS, Value *RHS,\n                     FastMathFlags FMF, const SimplifyQuery &Q);\n\n/// Given a callsite, fold the result or return null.\nValue *SimplifyCall(CallBase *Call, const SimplifyQuery &Q);\n\n/// Given an operand for a Freeze, see if we can fold the result.\n/// If not, this returns null.\nValue *SimplifyFreezeInst(Value *Op, const SimplifyQuery &Q);\n\n/// See if we can compute a simplified version of this instruction. If not,\n/// return null.\nValue *SimplifyInstruction(Instruction *I, const SimplifyQuery &Q,\n                           OptimizationRemarkEmitter *ORE = nullptr);\n\n/// See if V simplifies when its operand Op is replaced with RepOp. If not,\n/// return null.\n/// AllowRefinement specifies whether the simplification can be a refinement,\n/// or whether it needs to be strictly identical.\nValue *SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,\n                              const SimplifyQuery &Q, bool AllowRefinement);\n\n/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.\n///\n/// This first performs a normal RAUW of I with SimpleV. It then recursively\n/// attempts to simplify those users updated by the operation. The 'I'\n/// instruction must not be equal to the simplified value 'SimpleV'.\n/// If UnsimplifiedUsers is provided, instructions that could not be simplified\n/// are added to it.\n///\n/// The function returns true if any simplifications were performed.\nbool replaceAndRecursivelySimplify(\n    Instruction *I, Value *SimpleV, const TargetLibraryInfo *TLI = nullptr,\n    const DominatorTree *DT = nullptr, AssumptionCache *AC = nullptr,\n    SmallSetVector<Instruction *, 8> *UnsimplifiedUsers = nullptr);\n\n// These helper functions return a SimplifyQuery structure that contains as\n// many of the optional analysis we use as are currently valid.  This is the\n// strongly preferred way of constructing SimplifyQuery in passes.\nconst SimplifyQuery getBestSimplifyQuery(Pass &, Function &);\ntemplate <class T, class... TArgs>\nconst SimplifyQuery getBestSimplifyQuery(AnalysisManager<T, TArgs...> &,\n                                         Function &);\nconst SimplifyQuery getBestSimplifyQuery(LoopStandardAnalysisResults &,\n                                         const DataLayout &);\n} // end namespace llvm\n\n#endif\n\n"}}, "reports": [{"events": [{"location": {"col": 14, "file": 2, "line": 673}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 149}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 149}, "message": "function 'llvm::SimplifyAddInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "26147687a1e5aaed45854041167ca44f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 856}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 153}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 153}, "message": "function 'llvm::SimplifySubInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "3349eb5f318b8d168aaf2648a4732678", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 5006}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 157}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 157}, "message": "function 'llvm::SimplifyFAddInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "5c798b81c0e2041ba5d650bc1fd92f58", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 5012}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 161}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 161}, "message": "function 'llvm::SimplifyFSubInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "386b48c2557c5281cc66e338b2a66500", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 5017}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 165}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 165}, "message": "function 'llvm::SimplifyFMulInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "d2b21c50048106052ac98f973c3cce35", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 5022}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 172}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 172}, "message": "function 'llvm::SimplifyFMAFMul' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "e6f01b0092f75b1585951e6602f33e9d", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 917}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 176}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 176}, "message": "function 'llvm::SimplifyMulInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "d7af3087ddb723cd1abbd9728a63526f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 1153}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 179}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 179}, "message": "function 'llvm::SimplifySDivInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "b0f4132c190feea7d60c0eed6effd5c6", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 1164}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 182}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 182}, "message": "function 'llvm::SimplifyUDivInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "81d0a66cba31520036fa5e9ad52988d0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 5067}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 185}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 185}, "message": "function 'llvm::SimplifyFDivInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "d49f29c87ca54625b9c5b8168d537f80", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 1185}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 189}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 189}, "message": "function 'llvm::SimplifySRemInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "76b9f4335e1302f48161912a1e83d277", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 1196}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 192}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 192}, "message": "function 'llvm::SimplifyURemInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "3558d3f71cc3e74e342c44f1b763ce6d", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 5095}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 195}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 195}, "message": "function 'llvm::SimplifyFRemInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "6426ff7ea67ae8c0dff883babaaa40ff", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 2190}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 211}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 211}, "message": "function 'llvm::SimplifyAndInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "6e9cc2516a2a309737ff5fc8cd900bfe", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 2366}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 214}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 214}, "message": "function 'llvm::SimplifyOrInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "72aef733f8667efa982e69887fdad8aa", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 2414}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 217}, "message": "differing parameters are named here: ('LHS', 'RHS'), in definition: ('Op0', 'Op1')"}, {"location": {"col": 8, "file": 1, "line": 217}, "message": "function 'llvm::SimplifyXorInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "fa9e433c06fb9209fcf8396f9e7ec035", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 2, "line": 4452}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 240}, "message": "differing parameters are named here: ('Elt'), in definition: ('Val')"}, {"location": {"col": 8, "file": 1, "line": 240}, "message": "function 'llvm::SimplifyInsertElementInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h", "reportHash": "b6597d0aa91fb4554a57218827ec996f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
