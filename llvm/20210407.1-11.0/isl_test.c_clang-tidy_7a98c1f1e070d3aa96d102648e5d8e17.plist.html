<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/check_reparse_test_templ.c", "content": "#define xCAT(A,B) A ## B\n#define CAT(A,B) xCAT(A,B)\n#undef TYPE\n#define TYPE CAT(isl_,BASE)\n#define xFN(TYPE,NAME) TYPE ## _ ## NAME\n#define FN(TYPE,NAME) xFN(TYPE,NAME)\n\n#define TESTS CAT(reparse_,CAT(BASE,_tests))\n\n/* Test parsing of objects of type TYPE by printing\n * the expressions and checking that parsing the output results\n * in the same expression.\n * Do this for a set of expressions parsed from strings.\n */\nstatic isl_stat FN(check,TESTS)(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(TESTS); ++i) {\n\t\tTYPE *obj;\n\n\t\tobj = FN(TYPE,read_from_str)(ctx, TESTS[i]);\n\t\tif (FN(check_reparse,BASE)(ctx, obj) < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_factorization.h", "content": "#ifndef ISL_FACTORIZATION_H\n#define ISL_FACTORIZATION_H\n\n#include <isl/set.h>\n#include <isl_morph.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/* Data for factorizing the basic set \"bset\".\n * After applying \"morph\" to the basic set, there are \"n_group\"\n * groups of consecutive set variables, each of length \"len[i]\",\n * with 0 <= i < n_group.\n * If no factorization is possible, then \"n_group\" is set to 0.\n */\nstruct isl_factorizer {\n\tisl_basic_set\t*bset;\n\tisl_morph\t*morph;\n\tint\t\tn_group;\n\tint\t\t*len;\n};\ntypedef struct isl_factorizer isl_factorizer;\n\n__isl_give isl_factorizer *isl_basic_set_factorizer(\n\t__isl_keep isl_basic_set *bset);\n\nisl_ctx *isl_factorizer_get_ctx(__isl_keep isl_factorizer *f);\n\n__isl_null isl_factorizer *isl_factorizer_free(__isl_take isl_factorizer *f);\nvoid isl_factorizer_dump(__isl_take isl_factorizer *f);\n\n__isl_give isl_bool isl_factorizer_every_factor_basic_set(\n\t__isl_keep isl_factorizer *f,\n\tisl_bool (*test)(__isl_keep isl_basic_set *bset, void *user),\n\tvoid *user);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n * Copyright 2010      INRIA Saclay\n * Copyright 2012-2013 Ecole Normale Superieure\n * Copyright 2014      INRIA Rocquencourt\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,\n * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France\n * and Ecole Normale Superieure, 45 rue d\u2019Ulm, 75230 Paris, France\n * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,\n * B.P. 105 - 78153 Le Chesnay, France\n */\n\n#include <assert.h>\n#include <stdio.h>\n#include <limits.h>\n#include <isl_ctx_private.h>\n#include <isl_map_private.h>\n#include <isl_aff_private.h>\n#include <isl_space_private.h>\n#include <isl/id.h>\n#include <isl/set.h>\n#include <isl/flow.h>\n#include <isl_constraint_private.h>\n#include <isl/polynomial.h>\n#include <isl/union_set.h>\n#include <isl/union_map.h>\n#include <isl_factorization.h>\n#include <isl/schedule.h>\n#include <isl/schedule_node.h>\n#include <isl_options_private.h>\n#include <isl_vertices_private.h>\n#include <isl/ast_build.h>\n#include <isl/val.h>\n#include <isl/ilp.h>\n#include <isl_ast_build_expr.h>\n#include <isl/options.h>\n\n#include \"isl_srcdir.c\"\n\n#define ARRAY_SIZE(array) (sizeof(array)/sizeof(*array))\n\nstatic char *get_filename(isl_ctx *ctx, const char *name, const char *suffix) {\n\tchar *filename;\n\tint length;\n\tchar *pattern = \"%s/test_inputs/%s.%s\";\n\n\tlength = strlen(pattern) - 6 + strlen(srcdir) + strlen(name)\n\t\t+ strlen(suffix) + 1;\n\tfilename = isl_alloc_array(ctx, char, length);\n\n\tif (!filename)\n\t\treturn NULL;\n\n\tsprintf(filename, pattern, srcdir, name, suffix);\n\n\treturn filename;\n}\n\nvoid test_parse_map(isl_ctx *ctx, const char *str)\n{\n\tisl_map *map;\n\n\tmap = isl_map_read_from_str(ctx, str);\n\tassert(map);\n\tisl_map_free(map);\n}\n\nint test_parse_map_equal(isl_ctx *ctx, const char *str, const char *str2)\n{\n\tisl_map *map, *map2;\n\tint equal;\n\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap2 = isl_map_read_from_str(ctx, str2);\n\tequal = isl_map_is_equal(map, map2);\n\tisl_map_free(map);\n\tisl_map_free(map2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"maps not equal\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\nvoid test_parse_pwqp(isl_ctx *ctx, const char *str)\n{\n\tisl_pw_qpolynomial *pwqp;\n\n\tpwqp = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tassert(pwqp);\n\tisl_pw_qpolynomial_free(pwqp);\n}\n\nstatic void test_parse_pwaff(isl_ctx *ctx, const char *str)\n{\n\tisl_pw_aff *pwaff;\n\n\tpwaff = isl_pw_aff_read_from_str(ctx, str);\n\tassert(pwaff);\n\tisl_pw_aff_free(pwaff);\n}\n\n/* Check that we can read an isl_multi_val from \"str\" without errors.\n */\nstatic int test_parse_multi_val(isl_ctx *ctx, const char *str)\n{\n\tisl_multi_val *mv;\n\n\tmv = isl_multi_val_read_from_str(ctx, str);\n\tisl_multi_val_free(mv);\n\n\treturn mv ? 0 : -1;\n}\n\n/* String descriptions of multi piecewise affine expressions\n * that are used for testing printing and parsing.\n */\nstatic const char *reparse_multi_pw_aff_tests[] = {\n\t\"{ A[x, y] -> [] : x + y >= 0 }\",\n\t\"{ A[x, y] -> B[] : x + y >= 0 }\",\n\t\"{ A[x, y] -> [x] : x + y >= 0 }\",\n\t\"[N] -> { A[x, y] -> [x] : x + y <= N }\",\n\t\"{ A[x, y] -> [x, y] : x + y >= 0 }\",\n\t\"{ A[x, y] -> [(x : x >= 0), (y : y >= 0)] : x + y >= 0 }\",\n\t\"[N] -> { [] : N >= 0 }\",\n\t\"[N] -> { [] : N >= 0 }\",\n\t\"[N] -> { [N] : N >= 0 }\",\n\t\"[N] -> { [N, N + 1] : N >= 0 }\",\n\t\"[N, M] -> { [(N : N >= 0), (M : M >= 0)] : N + M >= 0 }\",\n};\n\n#undef BASE\n#define BASE multi_pw_aff\n\n#include \"check_reparse_templ.c\"\n#include \"check_reparse_test_templ.c\"\n\n/* String descriptions of piecewise multi affine expressions\n * that are used for testing printing and parsing.\n */\nstatic const char *reparse_pw_multi_aff_tests[] = {\n\t\"{ [x] -> [x] }\",\n\t\"{ [x] -> [x % 4] }\",\n\t\"{ [x] -> [x % 4] : x mod 3 = 1 }\",\n\t\"{ [x, x] -> [x % 4] }\",\n\t\"{ [x, x + 1] -> [x % 4] : x mod 3 = 1 }\",\n\t\"{ [x, x mod 2] -> [x % 4] }\",\n};\n\n#undef BASE\n#define BASE pw_multi_aff\n\n#include \"check_reparse_templ.c\"\n#include \"check_reparse_test_templ.c\"\n\n/* Test parsing of piecewise multi affine expressions by printing\n * the expressions and checking that parsing the output results\n * in the same expression.\n * Do this for an expression converted from a map with an output\n * dimension name that is equal to an automatically generated name, and\n * a set of expressions parsed from strings.\n */\nstatic isl_stat test_parse_pma(isl_ctx *ctx)\n{\n\tisl_map *map;\n\tisl_pw_multi_aff *pma;\n\n\tmap = isl_map_read_from_str(ctx, \"{ [a, a] -> [i1 = a + 1] }\");\n\tpma = isl_pw_multi_aff_from_map(map);\n\tif (check_reparse_pw_multi_aff(ctx, pma) < 0)\n\t\treturn isl_stat_error;\n\n\tif (check_reparse_pw_multi_aff_tests(ctx) < 0)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Test parsing of multi piecewise affine expressions by printing\n * the expressions and checking that parsing the output results\n * in the same expression.\n * Do this for a couple of manually constructed expressions,\n * an expression converted from a map with an output dimension name\n * that is equal to an automatically generated name, and\n * a set of expressions parsed from strings.\n */\nstatic int test_parse_mpa(isl_ctx *ctx)\n{\n\tisl_space *space;\n\tisl_set *dom;\n\tisl_map *map;\n\tisl_pw_multi_aff *pma;\n\tisl_multi_pw_aff *mpa;\n\tisl_stat r;\n\n\tspace = isl_space_set_alloc(ctx, 0, 0);\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"A\");\n\tmpa = isl_multi_pw_aff_zero(space);\n\tr = check_reparse_multi_pw_aff(ctx, mpa);\n\tif (r < 0)\n\t\treturn -1;\n\n\tspace = isl_space_set_alloc(ctx, 1, 0);\n\tspace = isl_space_set_dim_name(space, isl_dim_param, 0, \"N\");\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"A\");\n\tdom = isl_set_universe(isl_space_params(isl_space_copy(space)));\n\tdom = isl_set_lower_bound_si(dom, isl_dim_param, 0, 5);\n\tmpa = isl_multi_pw_aff_zero(space);\n\tmpa = isl_multi_pw_aff_intersect_domain(mpa, dom);\n\tr = check_reparse_multi_pw_aff(ctx, mpa);\n\tif (r < 0)\n\t\treturn -1;\n\n\tmap = isl_map_read_from_str(ctx, \"{ [a, a] -> [i1 = a + 1] }\");\n\tpma = isl_pw_multi_aff_from_map(map);\n\tmpa = isl_multi_pw_aff_from_pw_multi_aff(pma);\n\tif (check_reparse_multi_pw_aff(ctx, mpa) < 0)\n\t\treturn -1;\n\n\tif (check_reparse_multi_pw_aff_tests(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* String descriptions of multi union piecewise affine expressions\n * that are used for testing printing and parsing.\n */\nstatic const char *reparse_multi_union_pw_aff_tests[] = {\n\t\"[]\",\n\t\"A[]\",\n\t\"A[B[] -> C[]]\",\n\t\"(A[] : { S[x] : x > 0; T[y] : y >= 0 })\",\n\t\"(A[] : { })\",\n\t\"[N] -> (A[] : { })\",\n\t\"[N] -> (A[] : { : N >= 0 })\",\n\t\"[N] -> (A[] : { S[x] : x > N; T[y] : y >= 0 })\",\n\t\"(A[] : [N] -> { S[x] : x > N; T[y] : y >= 0 })\",\n\t\"A[{ S[x] -> [x + 1]; T[x] -> [x] }]\",\n\t\"(A[{ S[x] -> [x + 1]; T[x] -> [x] }] : \"\n\t\t\"{ S[x] : x > 0; T[y] : y >= 0 })\",\n};\n\n#undef BASE\n#define BASE multi_union_pw_aff\n\n#include \"check_reparse_templ.c\"\n#include \"check_reparse_test_templ.c\"\n\n/* Test parsing of multi union piecewise affine expressions by printing\n * the expressions and checking that parsing the output results\n * in the same expression.\n * Do this for a couple of manually constructed expressions and\n * a set of expressions parsed from strings.\n */\nstatic int test_parse_mupa(isl_ctx *ctx)\n{\n\tisl_space *space;\n\tisl_multi_union_pw_aff *mupa;\n\tisl_set *dom;\n\tisl_union_set *uset;\n\tisl_stat r;\n\n\tspace = isl_space_set_alloc(ctx, 0, 0);\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"A\");\n\tmupa = isl_multi_union_pw_aff_zero(space);\n\tr = check_reparse_multi_union_pw_aff(ctx, mupa);\n\tif (r < 0)\n\t\treturn -1;\n\n\tspace = isl_space_set_alloc(ctx, 1, 0);\n\tspace = isl_space_set_dim_name(space, isl_dim_param, 0, \"N\");\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"A\");\n\tdom = isl_set_universe(space);\n\tdom = isl_set_lower_bound_si(dom, isl_dim_param, 0, 5);\n\tuset = isl_union_set_from_set(dom);\n\tspace = isl_space_set_alloc(ctx, 1, 0);\n\tspace = isl_space_set_dim_name(space, isl_dim_param, 0, \"N\");\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"B\");\n\tmupa = isl_multi_union_pw_aff_zero(space);\n\tmupa = isl_multi_union_pw_aff_intersect_domain(mupa, uset);\n\tr = check_reparse_multi_union_pw_aff(ctx, mupa);\n\tif (r < 0)\n\t\treturn -1;\n\n\tif (check_reparse_multi_union_pw_aff_tests(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Test parsing of multi expressions.\n */\nstatic int test_parse_multi(isl_ctx *ctx)\n{\n\tif (test_parse_mpa(ctx) < 0)\n\t\treturn -1;\n\tif (test_parse_mupa(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Pairs of binary relation representations that should represent\n * the same binary relations.\n */\nstruct {\n\tconst char *map1;\n\tconst char *map2;\n} parse_map_equal_tests[] = {\n\t{ \"{ [x,y]  : [([x/2]+y)/3] >= 1 }\",\n\t  \"{ [x, y] : 2y >= 6 - x }\" },\n\t{ \"{ [x,y] : x <= min(y, 2*y+3) }\",\n\t  \"{ [x,y] : x <= y, 2*y + 3 }\" },\n\t{ \"{ [x,y] : x >= min(y, 2*y+3) }\",\n\t  \"{ [x, y] : (y <= x and y >= -3) or (2y <= -3 + x and y <= -4) }\" },\n\t{ \"[n] -> { [c1] : c1>=0 and c1<=floord(n-4,3) }\",\n\t  \"[n] -> { [c1] : c1 >= 0 and 3c1 <= -4 + n }\" },\n\t{ \"{ [i,j] -> [i] : i < j; [i,j] -> [j] : j <= i }\",\n\t  \"{ [i,j] -> [min(i,j)] }\" },\n\t{ \"{ [i,j] : i != j }\",\n\t  \"{ [i,j] : i < j or i > j }\" },\n\t{ \"{ [i,j] : (i+1)*2 >= j }\",\n\t  \"{ [i, j] : j <= 2 + 2i }\" },\n\t{ \"{ [i] -> [i > 0 ? 4 : 5] }\",\n\t  \"{ [i] -> [5] : i <= 0; [i] -> [4] : i >= 1 }\" },\n\t{ \"[N=2,M] -> { [i=[(M+N)/4]] }\",\n\t  \"[N, M] -> { [i] : N = 2 and 4i <= 2 + M and 4i >= -1 + M }\" },\n\t{ \"{ [x] : x >= 0 }\",\n\t  \"{ [x] : x-0 >= 0 }\" },\n\t{ \"{ [i] : ((i > 10)) }\",\n\t  \"{ [i] : i >= 11 }\" },\n\t{ \"{ [i] -> [0] }\",\n\t  \"{ [i] -> [0 * i] }\" },\n\t{ \"{ [a] -> [b] : (not false) }\",\n\t  \"{ [a] -> [b] : true }\" },\n\t{ \"{ [i] : i/2 <= 5 }\",\n\t  \"{ [i] : i <= 10 }\" },\n\t{ \"{Sym=[n] [i] : i <= n }\",\n\t  \"[n] -> { [i] : i <= n }\" },\n\t{ \"{ [*] }\",\n\t  \"{ [a] }\" },\n\t{ \"{ [i] : 2*floor(i/2) = i }\",\n\t  \"{ [i] : exists a : i = 2 a }\" },\n\t{ \"{ [a] -> [b] : a = 5 implies b = 5 }\",\n\t  \"{ [a] -> [b] : a != 5 or b = 5 }\" },\n\t{ \"{ [a] -> [a - 1 : a > 0] }\",\n\t  \"{ [a] -> [a - 1] : a > 0 }\" },\n\t{ \"{ [a] -> [a - 1 : a > 0; a : a <= 0] }\",\n\t  \"{ [a] -> [a - 1] : a > 0; [a] -> [a] : a <= 0 }\" },\n\t{ \"{ [a] -> [(a) * 2 : a >= 0; 0 : a < 0] }\",\n\t  \"{ [a] -> [2a] : a >= 0; [a] -> [0] : a < 0 }\" },\n\t{ \"{ [a] -> [(a * 2) : a >= 0; 0 : a < 0] }\",\n\t  \"{ [a] -> [2a] : a >= 0; [a] -> [0] : a < 0 }\" },\n\t{ \"{ [a] -> [(a * 2 : a >= 0); 0 : a < 0] }\",\n\t  \"{ [a] -> [2a] : a >= 0; [a] -> [0] : a < 0 }\" },\n\t{ \"{ [a] -> [(a * 2 : a >= 0; 0 : a < 0)] }\",\n\t  \"{ [a] -> [2a] : a >= 0; [a] -> [0] : a < 0 }\" },\n\t{ \"{ [a,b] -> [i,j] : a,b << i,j }\",\n\t  \"{ [a,b] -> [i,j] : a < i or (a = i and b < j) }\" },\n\t{ \"{ [a,b] -> [i,j] : a,b <<= i,j }\",\n\t  \"{ [a,b] -> [i,j] : a < i or (a = i and b <= j) }\" },\n\t{ \"{ [a,b] -> [i,j] : a,b >> i,j }\",\n\t  \"{ [a,b] -> [i,j] : a > i or (a = i and b > j) }\" },\n\t{ \"{ [a,b] -> [i,j] : a,b >>= i,j }\",\n\t  \"{ [a,b] -> [i,j] : a > i or (a = i and b >= j) }\" },\n\t{ \"{ [n] -> [i] : exists (a, b, c: 8b <= i - 32a and \"\n\t\t\t    \"8b >= -7 + i - 32 a and b >= 0 and b <= 3 and \"\n\t\t\t    \"8c < n - 32a and i < n and c >= 0 and \"\n\t\t\t    \"c <= 3 and c >= -4a) }\",\n\t  \"{ [n] -> [i] : 0 <= i < n }\" },\n\t{ \"{ [x] -> [] : exists (a, b: 0 <= a <= 1 and 0 <= b <= 3 and \"\n\t\t\t    \"2b <= x - 8a and 2b >= -1 + x - 8a) }\",\n\t  \"{ [x] -> [] : 0 <= x <= 15 }\" },\n\t{ \"{ [x] -> [x] : }\",\n\t  \"{ [x] -> [x] }\" },\n\t{ \"{ [x=4:5] -> [x + 1] }\",\n\t  \"{ [x] -> [x + 1] : 4 <= x <= 5 }\" },\n\t{ \"{ [x=4:5] -> [x + 1 : x + 1] }\",\n\t  \"{ [x=4:5] -> [x + 1] }\" },\n\t{ \"{ [x] -> [x - 1 : x + 1] }\",\n\t  \"{ [x] -> [y] : x - 1 <= y <= x + 1 }\" },\n\t{ \"{ [x=4:] -> [x + 1] }\",\n\t  \"{ [x] -> [x + 1] : 4 <= x }\" },\n\t{ \"{ [x=:5] -> [x + 1] }\",\n\t  \"{ [x] -> [x + 1] : x <= 5 }\" },\n\t{ \"{ [x=:] -> [x + 1] }\",\n\t  \"{ [x] -> [x + 1] }\" },\n\t{ \"{ [:] -> [:] }\",\n\t  \"{ [x] -> [y] }\" },\n\t{ \"{ [x, x//4] }\",\n\t  \"{ [x, floor(x/4)] }\" },\n\t{ \"{ [10//4] }\",\n\t  \"{ [2] }\" },\n};\n\nint test_parse(struct isl_ctx *ctx)\n{\n\tint i;\n\tisl_map *map, *map2;\n\tconst char *str, *str2;\n\n\tif (test_parse_multi_val(ctx, \"{ A[B[2] -> C[5, 7]] }\") < 0)\n\t\treturn -1;\n\tif (test_parse_multi_val(ctx, \"[n] -> { [2] }\") < 0)\n\t\treturn -1;\n\tif (test_parse_multi_val(ctx, \"{ A[4, infty, NaN, -1/2, 2/3] }\") < 0)\n\t\treturn -1;\n\tif (test_parse_multi(ctx) < 0)\n\t\treturn -1;\n\tif (test_parse_pma(ctx) < 0)\n\t\treturn -1;\n\n\tstr = \"{ [i] -> [-i] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tassert(map);\n\tisl_map_free(map);\n\n\tstr = \"{ A[i] -> L[([i/3])] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tassert(map);\n\tisl_map_free(map);\n\n\ttest_parse_map(ctx, \"{[[s] -> A[i]] -> [[s+1] -> A[i]]}\");\n\ttest_parse_map(ctx, \"{ [p1, y1, y2] -> [2, y1, y2] : \"\n\t\t\t\t\"p1 = 1 && (y1 <= y2 || y2 = 0) }\");\n\n\tfor (i = 0; i < ARRAY_SIZE(parse_map_equal_tests); ++i) {\n\t\tstr = parse_map_equal_tests[i].map1;\n\t\tstr2 = parse_map_equal_tests[i].map2;\n\t\tif (test_parse_map_equal(ctx, str, str2) < 0)\n\t\t\treturn -1;\n\t}\n\n\tstr = \"{[new,old] -> [new+1-2*[(new+1)/2],old+1-2*[(old+1)/2]]}\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tstr = \"{ [new, old] -> [o0, o1] : \"\n\t       \"exists (e0 = [(-1 - new + o0)/2], e1 = [(-1 - old + o1)/2]: \"\n\t       \"2e0 = -1 - new + o0 and 2e1 = -1 - old + o1 and o0 >= 0 and \"\n\t       \"o0 <= 1 and o1 >= 0 and o1 <= 1) }\";\n\tmap2 = isl_map_read_from_str(ctx, str);\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map);\n\tisl_map_free(map2);\n\n\tstr = \"{[new,old] -> [new+1-2*[(new+1)/2],old+1-2*[(old+1)/2]]}\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tstr = \"{[new,old] -> [(new+1)%2,(old+1)%2]}\";\n\tmap2 = isl_map_read_from_str(ctx, str);\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map);\n\tisl_map_free(map2);\n\n\ttest_parse_pwqp(ctx, \"{ [i] -> i + [ (i + [i/3])/2 ] }\");\n\ttest_parse_map(ctx, \"{ S1[i] -> [([i/10]),i%10] : 0 <= i <= 45 }\");\n\ttest_parse_pwaff(ctx, \"{ [i] -> [i + 1] : i > 0; [a] -> [a] : a < 0 }\");\n\ttest_parse_pwqp(ctx, \"{ [x] -> ([(x)/2] * [(x)/3]) }\");\n\ttest_parse_pwaff(ctx, \"{ [] -> [(100)] }\");\n\n\treturn 0;\n}\n\nstatic int test_read(isl_ctx *ctx)\n{\n\tchar *filename;\n\tFILE *input;\n\tisl_basic_set *bset1, *bset2;\n\tconst char *str = \"{[y]: Exists ( alpha : 2alpha = y)}\";\n\tint equal;\n\n\tfilename = get_filename(ctx, \"set\", \"omega\");\n\tassert(filename);\n\tinput = fopen(filename, \"r\");\n\tassert(input);\n\n\tbset1 = isl_basic_set_read_from_file(ctx, input);\n\tbset2 = isl_basic_set_read_from_str(ctx, str);\n\n\tequal = isl_basic_set_is_equal(bset1, bset2);\n\n\tisl_basic_set_free(bset1);\n\tisl_basic_set_free(bset2);\n\tfree(filename);\n\n\tfclose(input);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"read sets not equal\", return -1);\n\n\treturn 0;\n}\n\nstatic int test_bounded(isl_ctx *ctx)\n{\n\tisl_set *set;\n\tisl_bool bounded;\n\n\tset = isl_set_read_from_str(ctx, \"[n] -> {[i] : 0 <= i <= n }\");\n\tbounded = isl_set_is_bounded(set);\n\tisl_set_free(set);\n\n\tif (bounded < 0)\n\t\treturn -1;\n\tif (!bounded)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"set not considered bounded\", return -1);\n\n\tset = isl_set_read_from_str(ctx, \"{[n, i] : 0 <= i <= n }\");\n\tbounded = isl_set_is_bounded(set);\n\tassert(!bounded);\n\tisl_set_free(set);\n\n\tif (bounded < 0)\n\t\treturn -1;\n\tif (bounded)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"set considered bounded\", return -1);\n\n\tset = isl_set_read_from_str(ctx, \"[n] -> {[i] : i <= n }\");\n\tbounded = isl_set_is_bounded(set);\n\tisl_set_free(set);\n\n\tif (bounded < 0)\n\t\treturn -1;\n\tif (bounded)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"set considered bounded\", return -1);\n\n\treturn 0;\n}\n\n/* Construct the basic set { [i] : 5 <= i <= N } */\nstatic int test_construction_1(isl_ctx *ctx)\n{\n\tisl_space *space;\n\tisl_local_space *ls;\n\tisl_basic_set *bset;\n\tisl_constraint *c;\n\n\tspace = isl_space_set_alloc(ctx, 1, 1);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_inequality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_param, 0, 1);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_inequality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_constant_si(c, -5);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\treturn 0;\n}\n\n/* Construct the basic set { [x] : -100 <= x <= 100 }\n * using isl_basic_set_{lower,upper}_bound_val and\n * check that it is equal the same basic set parsed from a string.\n */\nstatic int test_construction_2(isl_ctx *ctx)\n{\n\tisl_bool equal;\n\tisl_val *v;\n\tisl_space *space;\n\tisl_basic_set *bset1, *bset2;\n\n\tv = isl_val_int_from_si(ctx, 100);\n\tspace = isl_space_set_alloc(ctx, 0, 1);\n\tbset1 = isl_basic_set_universe(space);\n\tbset1 = isl_basic_set_upper_bound_val(bset1, isl_dim_set, 0,\n\t\t\t\t\t\tisl_val_copy(v));\n\tbset1 = isl_basic_set_lower_bound_val(bset1, isl_dim_set, 0,\n\t\t\t\t\t\tisl_val_neg(v));\n\tbset2 = isl_basic_set_read_from_str(ctx, \"{ [x] : -100 <= x <= 100 }\");\n\tequal = isl_basic_set_is_equal(bset1, bset2);\n\tisl_basic_set_free(bset1);\n\tisl_basic_set_free(bset2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"failed construction\", return -1);\n\n\treturn 0;\n}\n\n/* Basic tests for constructing basic sets.\n */\nstatic int test_construction(isl_ctx *ctx)\n{\n\tif (test_construction_1(ctx) < 0)\n\t\treturn -1;\n\tif (test_construction_2(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int test_dim(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_map *map1, *map2;\n\tint equal;\n\n\tmap1 = isl_map_read_from_str(ctx,\n\t    \"[n] -> { [i] -> [j] : exists (a = [i/10] : i - 10a <= n ) }\");\n\tmap1 = isl_map_add_dims(map1, isl_dim_in, 1);\n\tmap2 = isl_map_read_from_str(ctx,\n\t    \"[n] -> { [i,k] -> [j] : exists (a = [i/10] : i - 10a <= n ) }\");\n\tequal = isl_map_is_equal(map1, map2);\n\tisl_map_free(map2);\n\n\tmap1 = isl_map_project_out(map1, isl_dim_in, 0, 1);\n\tmap2 = isl_map_read_from_str(ctx, \"[n] -> { [i] -> [j] : n >= 0 }\");\n\tif (equal >= 0 && equal)\n\t\tequal = isl_map_is_equal(map1, map2);\n\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected result\", return -1);\n\n\tstr = \"[n] -> { [i] -> [] : exists a : 0 <= i <= n and i = 2 a }\";\n\tmap1 = isl_map_read_from_str(ctx, str);\n\tstr = \"{ [i] -> [j] : exists a : 0 <= i <= j and i = 2 a }\";\n\tmap2 = isl_map_read_from_str(ctx, str);\n\tmap1 = isl_map_move_dims(map1, isl_dim_out, 0, isl_dim_param, 0, 1);\n\tequal = isl_map_is_equal(map1, map2);\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected result\", return -1);\n\n\treturn 0;\n}\n\n#undef BASE\n#define BASE\tmulti_val\n#include \"isl_test_plain_equal_templ.c\"\n\n#undef BASE\n#define BASE\tmulti_aff\n#include \"isl_test_plain_equal_templ.c\"\n\n/* Check that \"val\" is equal to the value described by \"str\".\n * If \"str\" is \"NaN\", then check for a NaN value explicitly.\n */\nstatic isl_stat val_check_equal(__isl_keep isl_val *val, const char *str)\n{\n\tisl_bool ok, is_nan;\n\tisl_ctx *ctx;\n\tisl_val *res;\n\n\tif (!val)\n\t\treturn isl_stat_error;\n\n\tctx = isl_val_get_ctx(val);\n\tres = isl_val_read_from_str(ctx, str);\n\tis_nan = isl_val_is_nan(res);\n\tif (is_nan < 0)\n\t\tok = isl_bool_error;\n\telse if (is_nan)\n\t\tok = isl_val_is_nan(val);\n\telse\n\t\tok = isl_val_eq(val, res);\n\tisl_val_free(res);\n\tif (ok < 0)\n\t\treturn isl_stat_error;\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected result\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\nstruct {\n\t__isl_give isl_val *(*op)(__isl_take isl_val *v);\n\tconst char *arg;\n\tconst char *res;\n} val_un_tests[] = {\n\t{ &isl_val_neg, \"0\", \"0\" },\n\t{ &isl_val_abs, \"0\", \"0\" },\n\t{ &isl_val_pow2, \"0\", \"1\" },\n\t{ &isl_val_floor, \"0\", \"0\" },\n\t{ &isl_val_ceil, \"0\", \"0\" },\n\t{ &isl_val_neg, \"1\", \"-1\" },\n\t{ &isl_val_neg, \"-1\", \"1\" },\n\t{ &isl_val_neg, \"1/2\", \"-1/2\" },\n\t{ &isl_val_neg, \"-1/2\", \"1/2\" },\n\t{ &isl_val_neg, \"infty\", \"-infty\" },\n\t{ &isl_val_neg, \"-infty\", \"infty\" },\n\t{ &isl_val_neg, \"NaN\", \"NaN\" },\n\t{ &isl_val_abs, \"1\", \"1\" },\n\t{ &isl_val_abs, \"-1\", \"1\" },\n\t{ &isl_val_abs, \"1/2\", \"1/2\" },\n\t{ &isl_val_abs, \"-1/2\", \"1/2\" },\n\t{ &isl_val_abs, \"infty\", \"infty\" },\n\t{ &isl_val_abs, \"-infty\", \"infty\" },\n\t{ &isl_val_abs, \"NaN\", \"NaN\" },\n\t{ &isl_val_floor, \"1\", \"1\" },\n\t{ &isl_val_floor, \"-1\", \"-1\" },\n\t{ &isl_val_floor, \"1/2\", \"0\" },\n\t{ &isl_val_floor, \"-1/2\", \"-1\" },\n\t{ &isl_val_floor, \"infty\", \"infty\" },\n\t{ &isl_val_floor, \"-infty\", \"-infty\" },\n\t{ &isl_val_floor, \"NaN\", \"NaN\" },\n\t{ &isl_val_ceil, \"1\", \"1\" },\n\t{ &isl_val_ceil, \"-1\", \"-1\" },\n\t{ &isl_val_ceil, \"1/2\", \"1\" },\n\t{ &isl_val_ceil, \"-1/2\", \"0\" },\n\t{ &isl_val_ceil, \"infty\", \"infty\" },\n\t{ &isl_val_ceil, \"-infty\", \"-infty\" },\n\t{ &isl_val_ceil, \"NaN\", \"NaN\" },\n\t{ &isl_val_pow2, \"-3\", \"1/8\" },\n\t{ &isl_val_pow2, \"-1\", \"1/2\" },\n\t{ &isl_val_pow2, \"1\", \"2\" },\n\t{ &isl_val_pow2, \"2\", \"4\" },\n\t{ &isl_val_pow2, \"3\", \"8\" },\n\t{ &isl_val_inv, \"1\", \"1\" },\n\t{ &isl_val_inv, \"2\", \"1/2\" },\n\t{ &isl_val_inv, \"1/2\", \"2\" },\n\t{ &isl_val_inv, \"-2\", \"-1/2\" },\n\t{ &isl_val_inv, \"-1/2\", \"-2\" },\n\t{ &isl_val_inv, \"0\", \"NaN\" },\n\t{ &isl_val_inv, \"NaN\", \"NaN\" },\n\t{ &isl_val_inv, \"infty\", \"0\" },\n\t{ &isl_val_inv, \"-infty\", \"0\" },\n};\n\n/* Perform some basic tests of unary operations on isl_val objects.\n */\nstatic int test_un_val(isl_ctx *ctx)\n{\n\tint i;\n\tisl_val *v;\n\t__isl_give isl_val *(*fn)(__isl_take isl_val *v);\n\n\tfor (i = 0; i < ARRAY_SIZE(val_un_tests); ++i) {\n\t\tisl_stat r;\n\n\t\tv = isl_val_read_from_str(ctx, val_un_tests[i].arg);\n\t\tfn = val_un_tests[i].op;\n\t\tv = fn(v);\n\t\tr = val_check_equal(v, val_un_tests[i].res);\n\t\tisl_val_free(v);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\t__isl_give isl_val *(*fn)(__isl_take isl_val *v1,\n\t\t\t\t__isl_take isl_val *v2);\n} val_bin_op[] = {\n\t['+'] = { &isl_val_add },\n\t['-'] = { &isl_val_sub },\n\t['*'] = { &isl_val_mul },\n\t['/'] = { &isl_val_div },\n\t['g'] = { &isl_val_gcd },\n\t['m'] = { &isl_val_min },\n\t['M'] = { &isl_val_max },\n};\n\nstruct {\n\tconst char *arg1;\n\tunsigned char op;\n\tconst char *arg2;\n\tconst char *res;\n} val_bin_tests[] = {\n\t{ \"0\", '+', \"0\", \"0\" },\n\t{ \"1\", '+', \"0\", \"1\" },\n\t{ \"1\", '+', \"1\", \"2\" },\n\t{ \"1\", '-', \"1\", \"0\" },\n\t{ \"1\", '*', \"1\", \"1\" },\n\t{ \"1\", '/', \"1\", \"1\" },\n\t{ \"2\", '*', \"3\", \"6\" },\n\t{ \"2\", '*', \"1/2\", \"1\" },\n\t{ \"2\", '*', \"1/3\", \"2/3\" },\n\t{ \"2/3\", '*', \"3/5\", \"2/5\" },\n\t{ \"2/3\", '*', \"7/5\", \"14/15\" },\n\t{ \"2\", '/', \"1/2\", \"4\" },\n\t{ \"-2\", '/', \"-1/2\", \"4\" },\n\t{ \"-2\", '/', \"1/2\", \"-4\" },\n\t{ \"2\", '/', \"-1/2\", \"-4\" },\n\t{ \"2\", '/', \"2\", \"1\" },\n\t{ \"2\", '/', \"3\", \"2/3\" },\n\t{ \"2/3\", '/', \"5/3\", \"2/5\" },\n\t{ \"2/3\", '/', \"5/7\", \"14/15\" },\n\t{ \"0\", '/', \"0\", \"NaN\" },\n\t{ \"42\", '/', \"0\", \"NaN\" },\n\t{ \"-42\", '/', \"0\", \"NaN\" },\n\t{ \"infty\", '/', \"0\", \"NaN\" },\n\t{ \"-infty\", '/', \"0\", \"NaN\" },\n\t{ \"NaN\", '/', \"0\", \"NaN\" },\n\t{ \"0\", '/', \"NaN\", \"NaN\" },\n\t{ \"42\", '/', \"NaN\", \"NaN\" },\n\t{ \"-42\", '/', \"NaN\", \"NaN\" },\n\t{ \"infty\", '/', \"NaN\", \"NaN\" },\n\t{ \"-infty\", '/', \"NaN\", \"NaN\" },\n\t{ \"NaN\", '/', \"NaN\", \"NaN\" },\n\t{ \"0\", '/', \"infty\", \"0\" },\n\t{ \"42\", '/', \"infty\", \"0\" },\n\t{ \"-42\", '/', \"infty\", \"0\" },\n\t{ \"infty\", '/', \"infty\", \"NaN\" },\n\t{ \"-infty\", '/', \"infty\", \"NaN\" },\n\t{ \"NaN\", '/', \"infty\", \"NaN\" },\n\t{ \"0\", '/', \"-infty\", \"0\" },\n\t{ \"42\", '/', \"-infty\", \"0\" },\n\t{ \"-42\", '/', \"-infty\", \"0\" },\n\t{ \"infty\", '/', \"-infty\", \"NaN\" },\n\t{ \"-infty\", '/', \"-infty\", \"NaN\" },\n\t{ \"NaN\", '/', \"-infty\", \"NaN\" },\n\t{ \"1\", '-', \"1/3\", \"2/3\" },\n\t{ \"1/3\", '+', \"1/2\", \"5/6\" },\n\t{ \"1/2\", '+', \"1/2\", \"1\" },\n\t{ \"3/4\", '-', \"1/4\", \"1/2\" },\n\t{ \"1/2\", '-', \"1/3\", \"1/6\" },\n\t{ \"infty\", '+', \"42\", \"infty\" },\n\t{ \"infty\", '+', \"infty\", \"infty\" },\n\t{ \"42\", '+', \"infty\", \"infty\" },\n\t{ \"infty\", '-', \"infty\", \"NaN\" },\n\t{ \"infty\", '*', \"infty\", \"infty\" },\n\t{ \"infty\", '*', \"-infty\", \"-infty\" },\n\t{ \"-infty\", '*', \"infty\", \"-infty\" },\n\t{ \"-infty\", '*', \"-infty\", \"infty\" },\n\t{ \"0\", '*', \"infty\", \"NaN\" },\n\t{ \"1\", '*', \"infty\", \"infty\" },\n\t{ \"infty\", '*', \"0\", \"NaN\" },\n\t{ \"infty\", '*', \"42\", \"infty\" },\n\t{ \"42\", '-', \"infty\", \"-infty\" },\n\t{ \"infty\", '+', \"-infty\", \"NaN\" },\n\t{ \"4\", 'g', \"6\", \"2\" },\n\t{ \"5\", 'g', \"6\", \"1\" },\n\t{ \"42\", 'm', \"3\", \"3\" },\n\t{ \"42\", 'M', \"3\", \"42\" },\n\t{ \"3\", 'm', \"42\", \"3\" },\n\t{ \"3\", 'M', \"42\", \"42\" },\n\t{ \"42\", 'm', \"infty\", \"42\" },\n\t{ \"42\", 'M', \"infty\", \"infty\" },\n\t{ \"42\", 'm', \"-infty\", \"-infty\" },\n\t{ \"42\", 'M', \"-infty\", \"42\" },\n\t{ \"42\", 'm', \"NaN\", \"NaN\" },\n\t{ \"42\", 'M', \"NaN\", \"NaN\" },\n\t{ \"infty\", 'm', \"-infty\", \"-infty\" },\n\t{ \"infty\", 'M', \"-infty\", \"infty\" },\n};\n\n/* Perform some basic tests of binary operations on isl_val objects.\n */\nstatic int test_bin_val(isl_ctx *ctx)\n{\n\tint i;\n\tisl_val *v1, *v2, *res;\n\t__isl_give isl_val *(*fn)(__isl_take isl_val *v1,\n\t\t\t\t__isl_take isl_val *v2);\n\tint ok;\n\n\tfor (i = 0; i < ARRAY_SIZE(val_bin_tests); ++i) {\n\t\tv1 = isl_val_read_from_str(ctx, val_bin_tests[i].arg1);\n\t\tv2 = isl_val_read_from_str(ctx, val_bin_tests[i].arg2);\n\t\tres = isl_val_read_from_str(ctx, val_bin_tests[i].res);\n\t\tfn = val_bin_op[val_bin_tests[i].op].fn;\n\t\tv1 = fn(v1, v2);\n\t\tif (isl_val_is_nan(res))\n\t\t\tok = isl_val_is_nan(v1);\n\t\telse\n\t\t\tok = isl_val_eq(v1, res);\n\t\tisl_val_free(v1);\n\t\tisl_val_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Perform some basic tests on isl_val objects.\n */\nstatic int test_val(isl_ctx *ctx)\n{\n\tif (test_un_val(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_val(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Sets described using existentially quantified variables that\n * can also be described without.\n */\nstatic const char *elimination_tests[] = {\n\t\"{ [i,j] : 2 * [i/2] + 3 * [j/4] <= 10 and 2 i = j }\",\n\t\"{ [m, w] : exists a : w - 2m - 5 <= 3a <= m - 2w }\",\n\t\"{ [m, w] : exists a : w >= 0 and a < m and -1 + w <= a <= 2m - w }\",\n};\n\n/* Check that redundant existentially quantified variables are\n * getting removed.\n */\nstatic int test_elimination(isl_ctx *ctx)\n{\n\tint i;\n\tisl_size n;\n\tisl_basic_set *bset;\n\n\tfor (i = 0; i < ARRAY_SIZE(elimination_tests); ++i) {\n\t\tbset = isl_basic_set_read_from_str(ctx, elimination_tests[i]);\n\t\tn = isl_basic_set_dim(bset, isl_dim_div);\n\t\tisl_basic_set_free(bset);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\t\tif (n != 0)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"expecting no existentials\", return -1);\n\t}\n\n\treturn 0;\n}\n\nstatic int test_div(isl_ctx *ctx)\n{\n\tconst char *str;\n\tint empty;\n\tisl_space *space;\n\tisl_set *set;\n\tisl_local_space *ls;\n\tstruct isl_basic_set *bset;\n\tstruct isl_constraint *c;\n\n\t/* test 1 */\n\tspace = isl_space_set_alloc(ctx, 0, 3);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_constant_si(c, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, 3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_constant_si(c, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, 3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 1, 2);\n\n\tassert(bset && bset->n_div == 1);\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\t/* test 2 */\n\tspace = isl_space_set_alloc(ctx, 0, 3);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_constant_si(c, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, 3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_constant_si(c, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, 3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 1, 2);\n\n\tassert(bset && bset->n_div == 1);\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\t/* test 3 */\n\tspace = isl_space_set_alloc(ctx, 0, 3);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_constant_si(c, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, 3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_constant_si(c, -3);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, 4);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 1, 2);\n\n\tassert(bset && bset->n_div == 1);\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\t/* test 4 */\n\tspace = isl_space_set_alloc(ctx, 0, 3);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_constant_si(c, 2);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, 3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_constant_si(c, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, 6);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 1, 2);\n\n\tassert(isl_basic_set_is_empty(bset));\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\t/* test 5 */\n\tspace = isl_space_set_alloc(ctx, 0, 3);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, 3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, -3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 2, 1);\n\n\tassert(bset && bset->n_div == 0);\n\tisl_basic_set_free(bset);\n\tisl_local_space_free(ls);\n\n\t/* test 6 */\n\tspace = isl_space_set_alloc(ctx, 0, 3);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, 6);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, -3);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 2, 1);\n\n\tassert(bset && bset->n_div == 1);\n\tisl_basic_set_free(bset);\n\tisl_local_space_free(ls);\n\n\t/* test 7 */\n\t/* This test is a bit tricky.  We set up an equality\n\t *\t\ta + 3b + 3c = 6 e0\n\t * Normalization of divs creates _two_ divs\n\t *\t\ta = 3 e0\n\t *\t\tc - b - e0 = 2 e1\n\t * Afterwards e0 is removed again because it has coefficient -1\n\t * and we end up with the original equality and div again.\n\t * Perhaps we can avoid the introduction of this temporary div.\n\t */\n\tspace = isl_space_set_alloc(ctx, 0, 4);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, -3);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, -3);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 3, 6);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 3, 1);\n\n\t/* Test disabled for now */\n\t/*\n\tassert(bset && bset->n_div == 1);\n\t*/\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\t/* test 8 */\n\tspace = isl_space_set_alloc(ctx, 0, 5);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, -3);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 3, -3);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 4, 6);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, 1);\n\tc = isl_constraint_set_constant_si(c, 1);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 4, 1);\n\n\t/* Test disabled for now */\n\t/*\n\tassert(bset && bset->n_div == 1);\n\t*/\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\t/* test 9 */\n\tspace = isl_space_set_alloc(ctx, 0, 4);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, -2);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 3, 3);\n\tc = isl_constraint_set_constant_si(c, 2);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 2, 2);\n\n\tbset = isl_basic_set_fix_si(bset, isl_dim_set, 0, 2);\n\n\tassert(!isl_basic_set_is_empty(bset));\n\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\t/* test 10 */\n\tspace = isl_space_set_alloc(ctx, 0, 3);\n\tbset = isl_basic_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\n\tc = isl_constraint_alloc_equality(isl_local_space_copy(ls));\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);\n\tc = isl_constraint_set_coefficient_si(c, isl_dim_set, 2, -2);\n\tbset = isl_basic_set_add_constraint(bset, c);\n\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 2, 1);\n\n\tbset = isl_basic_set_fix_si(bset, isl_dim_set, 0, 2);\n\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(bset);\n\n\tstr = \"{ [i] : exists (e0, e1: 3e1 >= 1 + 2e0 and \"\n\t    \"8e1 <= -1 + 5i - 5e0 and 2e1 >= 1 + 2i - 5e0) }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tset = isl_set_compute_divs(set);\n\tisl_set_free(set);\n\tif (!set)\n\t\treturn -1;\n\n\tif (test_elimination(ctx) < 0)\n\t\treturn -1;\n\n\tstr = \"{ [i,j,k] : 3 + i + 2j >= 0 and 2 * [(i+2j)/4] <= k }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tset = isl_set_remove_divs_involving_dims(set, isl_dim_set, 0, 2);\n\tset = isl_set_fix_si(set, isl_dim_set, 2, -3);\n\tempty = isl_set_is_empty(set);\n\tisl_set_free(set);\n\tif (empty < 0)\n\t\treturn -1;\n\tif (!empty)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"result not as accurate as expected\", return -1);\n\n\treturn 0;\n}\n\nvoid test_application_case(struct isl_ctx *ctx, const char *name)\n{\n\tchar *filename;\n\tFILE *input;\n\tstruct isl_basic_set *bset1, *bset2;\n\tstruct isl_basic_map *bmap;\n\n\tfilename = get_filename(ctx, name, \"omega\");\n\tassert(filename);\n\tinput = fopen(filename, \"r\");\n\tassert(input);\n\n\tbset1 = isl_basic_set_read_from_file(ctx, input);\n\tbmap = isl_basic_map_read_from_file(ctx, input);\n\n\tbset1 = isl_basic_set_apply(bset1, bmap);\n\n\tbset2 = isl_basic_set_read_from_file(ctx, input);\n\n\tassert(isl_basic_set_is_equal(bset1, bset2) == 1);\n\n\tisl_basic_set_free(bset1);\n\tisl_basic_set_free(bset2);\n\tfree(filename);\n\n\tfclose(input);\n}\n\nstatic int test_application(isl_ctx *ctx)\n{\n\ttest_application_case(ctx, \"application\");\n\ttest_application_case(ctx, \"application2\");\n\n\treturn 0;\n}\n\nvoid test_affine_hull_case(struct isl_ctx *ctx, const char *name)\n{\n\tchar *filename;\n\tFILE *input;\n\tstruct isl_basic_set *bset1, *bset2;\n\n\tfilename = get_filename(ctx, name, \"polylib\");\n\tassert(filename);\n\tinput = fopen(filename, \"r\");\n\tassert(input);\n\n\tbset1 = isl_basic_set_read_from_file(ctx, input);\n\tbset2 = isl_basic_set_read_from_file(ctx, input);\n\n\tbset1 = isl_basic_set_affine_hull(bset1);\n\n\tassert(isl_basic_set_is_equal(bset1, bset2) == 1);\n\n\tisl_basic_set_free(bset1);\n\tisl_basic_set_free(bset2);\n\tfree(filename);\n\n\tfclose(input);\n}\n\n/* Pairs of sets and the corresponding expected results of\n * isl_basic_set_recession_cone.\n */\nstruct {\n\tconst char *set;\n\tconst char *cone;\n} recession_cone_tests[] = {\n\t{ \"{ [i] : 0 <= i <= 10 }\", \"{ [0] }\" },\n\t{ \"{ [i] : 0 <= i }\", \"{ [i] : 0 <= i }\" },\n\t{ \"{ [i] : i <= 10 }\", \"{ [i] : i <= 0 }\" },\n\t{ \"{ [i] : false }\", \"{ [i] : false }\" },\n};\n\n/* Perform some basic isl_basic_set_recession_cone tests.\n */\nstatic int test_recession_cone(struct isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(recession_cone_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_basic_set *bset;\n\t\tisl_basic_set *cone, *expected;\n\t\tisl_bool equal;\n\n\t\tstr = recession_cone_tests[i].set;\n\t\tbset = isl_basic_set_read_from_str(ctx, str);\n\t\tstr = recession_cone_tests[i].cone;\n\t\texpected = isl_basic_set_read_from_str(ctx, str);\n\t\tcone = isl_basic_set_recession_cone(bset);\n\t\tequal = isl_basic_set_is_equal(cone, expected);\n\t\tisl_basic_set_free(cone);\n\t\tisl_basic_set_free(expected);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"unexpected cone\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\nint test_affine_hull(struct isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_basic_set *bset, *bset2;\n\tisl_size n;\n\tisl_bool subset;\n\n\ttest_affine_hull_case(ctx, \"affine2\");\n\ttest_affine_hull_case(ctx, \"affine\");\n\ttest_affine_hull_case(ctx, \"affine3\");\n\n\tstr = \"[m] -> { [i0] : exists (e0, e1: e1 <= 1 + i0 and \"\n\t\t\t\"m >= 3 and 4i0 <= 2 + m and e1 >= i0 and \"\n\t\t\t\"e1 >= 0 and e1 <= 2 and e1 >= 1 + 2e0 and \"\n\t\t\t\"2e1 <= 1 + m + 4e0 and 2e1 >= 2 - m + 4i0 - 4e0) }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tbset = isl_set_affine_hull(set);\n\tn = isl_basic_set_dim(bset, isl_dim_div);\n\tisl_basic_set_free(bset);\n\tif (n < 0)\n\t\treturn -1;\n\tif (n != 0)\n\t\tisl_die(ctx, isl_error_unknown, \"not expecting any divs\",\n\t\t\treturn -1);\n\n\t/* Check that isl_map_affine_hull is not confused by\n\t * the reordering of divs in isl_map_align_divs.\n\t */\n\tstr = \"{ [a, b, c, 0] : exists (e0 = [(b)/32], e1 = [(c)/32]: \"\n\t\t\t\t\"32e0 = b and 32e1 = c); \"\n\t\t\"[a, 0, c, 0] : exists (e0 = [(c)/32]: 32e0 = c) }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tbset = isl_set_affine_hull(set);\n\tisl_basic_set_free(bset);\n\tif (!bset)\n\t\treturn -1;\n\n\tstr = \"{ [a] : exists e0, e1, e2: 32e1 = 31 + 31a + 31e0 and \"\n\t\t\t\"32e2 = 31 + 31e0 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tbset = isl_set_affine_hull(set);\n\tstr = \"{ [a] : exists e : a = 32 e }\";\n\tbset2 = isl_basic_set_read_from_str(ctx, str);\n\tsubset = isl_basic_set_is_subset(bset, bset2);\n\tisl_basic_set_free(bset);\n\tisl_basic_set_free(bset2);\n\tif (subset < 0)\n\t\treturn -1;\n\tif (!subset)\n\t\tisl_die(ctx, isl_error_unknown, \"not as accurate as expected\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* Test a special case of isl_set_plain_unshifted_simple_hull\n * where older versions of isl would include a redundant constraint\n * in the result.\n * Check that the result does not have any constraints.\n */\nstatic isl_stat test_plain_unshifted_simple_hull_special(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_bool is_universe;\n\tisl_set *set;\n\tisl_basic_set *bset;\n\n\tstr = \"{[x, y] : x = 0 or 2*((x+y)//2) <= y + 2 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tbset = isl_set_plain_unshifted_simple_hull(set);\n\tis_universe = isl_basic_set_plain_is_universe(bset);\n\tisl_basic_set_free(bset);\n\n\tif (is_universe < 0)\n\t\treturn isl_stat_error;\n\tif (!is_universe)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"hull should not have any constraints\",\n\t\t\treturn isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for simple hull tests, consisting of\n * the specific simple hull function, the input set and the expected result.\n */\nstruct {\n\t__isl_give isl_basic_set *(*fn)(__isl_take isl_set *set);\n\tconst char *set;\n\tconst char *hull;\n} simple_hull_tests[] = {\n\t{ &isl_set_plain_unshifted_simple_hull,\n\t  \"{ [i,j] : i >= 1 and j >= 1 or i >= 2 and j <= 10 }\",\n\t  \"{ [i,j] : i >= 1 }\" },\n\t{ &isl_set_plain_unshifted_simple_hull,\n\t  \"{ [n,i,j,k] : (i mod 3 = 2 and j mod 4 = 2) or \"\n\t\t\"(j mod 4 = 2 and k mod 6 = n) }\",\n\t  \"{ [n,i,j,k] : j mod 4 = 2 }\" },\n\t{ &isl_set_unshifted_simple_hull,\n\t  \"{ [0,x,y] : x <= -1; [1,x,y] : x <= y <= -x; [2,x,y] : x <= 1 }\",\n\t  \"{ [t,x,y] : 0 <= t <= 2 and x <= 1 }\" },\n\t{ &isl_set_simple_hull,\n\t  \"{ [a, b] : b <= 0 and \"\n\t\t\t\"2*floor((-2*floor((b)/2))/5) >= a - floor((b)/2); \"\n\t    \"[a, b] : a mod 2 = 0 }\",\n\t  \"{ [a, b] }\" },\n};\n\n/* Basic tests for various simple hull functions.\n */\nstatic int test_various_simple_hull(isl_ctx *ctx)\n{\n\tint i;\n\tisl_set *set;\n\tisl_basic_set *hull, *expected;\n\tisl_bool equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(simple_hull_tests); ++i) {\n\t\tconst char *str;\n\t\tstr = simple_hull_tests[i].set;\n\t\tset = isl_set_read_from_str(ctx, str);\n\t\tstr = simple_hull_tests[i].hull;\n\t\texpected = isl_basic_set_read_from_str(ctx, str);\n\t\thull = simple_hull_tests[i].fn(set);\n\t\tequal = isl_basic_set_is_equal(hull, expected);\n\t\tisl_basic_set_free(hull);\n\t\tisl_basic_set_free(expected);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"unexpected hull\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\nstatic int test_simple_hull(struct isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_basic_set *bset;\n\tisl_bool is_empty;\n\n\tstr = \"{ [x, y] : 3y <= 2x and y >= -2 + 2x and 2y >= 2 - x;\"\n\t\t\"[y, x] : 3y <= 2x and y >= -2 + 2x and 2y >= 2 - x }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tbset = isl_set_simple_hull(set);\n\tis_empty = isl_basic_set_is_empty(bset);\n\tisl_basic_set_free(bset);\n\n\tif (is_empty == isl_bool_error)\n\t\treturn -1;\n\n\tif (is_empty == isl_bool_false)\n\t\tisl_die(ctx, isl_error_unknown, \"Empty set should be detected\",\n\t\t\treturn -1);\n\n\tif (test_plain_unshifted_simple_hull_special(ctx) < 0)\n\t\treturn -1;\n\tif (test_various_simple_hull(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Inputs for isl_set_get_simple_fixed_box_hull tests.\n * \"set\" is the input set.\n * \"offset\" is the expected box offset.\n * \"size\" is the expected box size.\n */\nstatic struct {\n\tconst char *set;\n\tconst char *offset;\n\tconst char *size;\n} box_hull_tests[] = {\n\t{ \"{ S[x, y] : 0 <= x, y < 10 }\", \"{ S[0, 0] }\", \"{ S[10, 10] }\" },\n\t{ \"[N] -> { S[x, y] : N <= x, y < N + 10 }\",\n\t  \"[N] -> { S[N, N] }\", \"{ S[10, 10] }\" },\n\t{ \"{ S[x, y] : 0 <= x + y, x - y < 10 }\",\n\t  \"{ S[0, -4] }\", \"{ S[10, 9] }\" },\n\t{ \"{ [i=0:10] : exists (e0, e1: 3e1 >= 1 + 2e0 and \"\n\t    \"8e1 <= -1 + 5i - 5e0 and 2e1 >= 1 + 2i - 5e0) }\",\n\t  \"{ [3] }\", \"{ [8] }\" },\n\t{ \"[N] -> { [w = 0:17] : exists (e0: w < 2N and \"\n\t    \"-1 + w <= e0 <= w and 2e0 >= N + w and w <= 2e0 <= 15 + w) }\",\n\t  \"[N] -> { [N] }\", \"{ [9] }\" },\n};\n\n/* Perform basic isl_set_get_simple_fixed_box_hull tests.\n */\nstatic int test_box_hull(struct isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(box_hull_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_stat r;\n\t\tisl_set *set;\n\t\tisl_multi_aff *offset;\n\t\tisl_multi_val *size;\n\t\tisl_fixed_box *box;\n\n\t\tset = isl_set_read_from_str(ctx, box_hull_tests[i].set);\n\t\tbox = isl_set_get_simple_fixed_box_hull(set);\n\t\toffset = isl_fixed_box_get_offset(box);\n\t\tsize = isl_fixed_box_get_size(box);\n\t\tstr = box_hull_tests[i].offset;\n\t\tr = multi_aff_check_plain_equal(offset, str);\n\t\tstr = box_hull_tests[i].size;\n\t\tif (r >= 0)\n\t\t\tr = multi_val_check_plain_equal(size, str);\n\t\tisl_multi_aff_free(offset);\n\t\tisl_multi_val_free(size);\n\t\tisl_fixed_box_free(box);\n\t\tisl_set_free(set);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid test_convex_hull_case(struct isl_ctx *ctx, const char *name)\n{\n\tchar *filename;\n\tFILE *input;\n\tstruct isl_basic_set *bset1, *bset2;\n\tstruct isl_set *set;\n\n\tfilename = get_filename(ctx, name, \"polylib\");\n\tassert(filename);\n\tinput = fopen(filename, \"r\");\n\tassert(input);\n\n\tbset1 = isl_basic_set_read_from_file(ctx, input);\n\tbset2 = isl_basic_set_read_from_file(ctx, input);\n\n\tset = isl_basic_set_union(bset1, bset2);\n\tbset1 = isl_set_convex_hull(set);\n\n\tbset2 = isl_basic_set_read_from_file(ctx, input);\n\n\tassert(isl_basic_set_is_equal(bset1, bset2) == 1);\n\n\tisl_basic_set_free(bset1);\n\tisl_basic_set_free(bset2);\n\tfree(filename);\n\n\tfclose(input);\n}\n\nstruct {\n\tconst char *set;\n\tconst char *hull;\n} convex_hull_tests[] = {\n\t{ \"{ [i0, i1, i2] : (i2 = 1 and i0 = 0 and i1 >= 0) or \"\n\t       \"(i0 = 1 and i1 = 0 and i2 = 1) or \"\n\t       \"(i0 = 0 and i1 = 0 and i2 = 0) }\",\n\t  \"{ [i0, i1, i2] : i0 >= 0 and i2 >= i0 and i2 <= 1 and i1 >= 0 }\" },\n\t{ \"[n] -> { [i0, i1, i0] : i0 <= -4 + n; \"\n\t    \"[i0, i0, i2] : n = 6 and i0 >= 0 and i2 <= 7 - i0 and \"\n\t    \"i2 <= 5 and i2 >= 4; \"\n\t    \"[3, i1, 3] : n = 5 and i1 <= 2 and i1 >= 0 }\",\n\t  \"[n] -> { [i0, i1, i2] : i2 <= -1 + n and 2i2 <= -6 + 3n - i0 and \"\n\t    \"i2 <= 5 + i0 and i2 >= i0 }\" },\n\t{ \"{ [x, y] : 3y <= 2x and y >= -2 + 2x and 2y >= 2 - x }\",\n\t    \"{ [x, y] : 1 = 0 }\" },\n\t{ \"{ [x, y, z] : 0 <= x, y, z <= 10; [x, y, 0] : x >= 0 and y > 0; \"\n\t    \"[x, y, 0] : x >= 0 and y < 0 }\",\n\t    \"{ [x, y, z] : x >= 0 and 0 <= z <= 10 }\" },\n\t{ \"{ [a, b, c] : a <= 1 and -a < b <= 1 and 0 <= c <= 2 - a - b and \"\n\t\t\t    \"c <= a; \"\n\t    \"[0, 2, 0]; [3, 1, 0] }\",\n\t    \"{ [a, b, c] : b > -a and 2b >= -1 + a and 0 <= c <= a and \"\n\t\t\t    \"5c <= 6 - a - 3b }\" },\n};\n\nstatic int test_convex_hull_algo(isl_ctx *ctx, int convex)\n{\n\tint i;\n\tint orig_convex = ctx->opt->convex;\n\tctx->opt->convex = convex;\n\n\ttest_convex_hull_case(ctx, \"convex0\");\n\ttest_convex_hull_case(ctx, \"convex1\");\n\ttest_convex_hull_case(ctx, \"convex2\");\n\ttest_convex_hull_case(ctx, \"convex3\");\n\ttest_convex_hull_case(ctx, \"convex4\");\n\ttest_convex_hull_case(ctx, \"convex5\");\n\ttest_convex_hull_case(ctx, \"convex6\");\n\ttest_convex_hull_case(ctx, \"convex7\");\n\ttest_convex_hull_case(ctx, \"convex8\");\n\ttest_convex_hull_case(ctx, \"convex9\");\n\ttest_convex_hull_case(ctx, \"convex10\");\n\ttest_convex_hull_case(ctx, \"convex11\");\n\ttest_convex_hull_case(ctx, \"convex12\");\n\ttest_convex_hull_case(ctx, \"convex13\");\n\ttest_convex_hull_case(ctx, \"convex14\");\n\ttest_convex_hull_case(ctx, \"convex15\");\n\n\tfor (i = 0; i < ARRAY_SIZE(convex_hull_tests); ++i) {\n\t\tisl_set *set1, *set2;\n\t\tint equal;\n\n\t\tset1 = isl_set_read_from_str(ctx, convex_hull_tests[i].set);\n\t\tset2 = isl_set_read_from_str(ctx, convex_hull_tests[i].hull);\n\t\tset1 = isl_set_from_basic_set(isl_set_convex_hull(set1));\n\t\tequal = isl_set_is_equal(set1, set2);\n\t\tisl_set_free(set1);\n\t\tisl_set_free(set2);\n\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected convex hull\", return -1);\n\t}\n\n\tctx->opt->convex = orig_convex;\n\n\treturn 0;\n}\n\nstatic int test_convex_hull(isl_ctx *ctx)\n{\n\tif (test_convex_hull_algo(ctx, ISL_CONVEX_HULL_FM) < 0)\n\t\treturn -1;\n\tif (test_convex_hull_algo(ctx, ISL_CONVEX_HULL_WRAP) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Check that computing the gist of \"map\" with respect to \"context\"\n * does not make any copy of \"map\" get marked empty.\n * Earlier versions of isl would end up doing that.\n */\nstatic isl_stat test_gist_empty_pair(isl_ctx *ctx, const char *map,\n\tconst char *context)\n{\n\tisl_map *m1, *m2, *m3;\n\tisl_bool empty_before, empty_after;\n\n\tm1 = isl_map_read_from_str(ctx, map);\n\tm2 = isl_map_read_from_str(ctx, context);\n\tm3 = isl_map_copy(m1);\n\tempty_before = isl_map_is_empty(m3);\n\tm1 = isl_map_gist(m1, m2);\n\tempty_after = isl_map_is_empty(m3);\n\tisl_map_free(m1);\n\tisl_map_free(m3);\n\n\tif (empty_before < 0 || empty_after < 0)\n\t\treturn isl_stat_error;\n\tif (empty_before)\n\t\tisl_die(ctx, isl_error_unknown, \"map should not be empty\",\n\t\t\treturn isl_stat_error);\n\tif (empty_after)\n\t\tisl_die(ctx, isl_error_unknown, \"map should still not be empty\",\n\t\t\treturn isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\n/* Check that computing a gist does not make any copy of the input\n * get marked empty.\n * Earlier versions of isl would end up doing that on some pairs of inputs.\n */\nstatic isl_stat test_gist_empty(isl_ctx *ctx)\n{\n\tconst char *map, *context;\n\n\tmap = \"{ [] -> [a, b, c] : 2b = 1 + a }\";\n\tcontext = \"{ [] -> [a, b, c] : 2c = 2 + a }\";\n\tif (test_gist_empty_pair(ctx, map, context) < 0)\n\t\treturn isl_stat_error;\n\tmap = \"{ [] -> [0, 0] }\";\n\tcontext = \"{ [] -> [a, b] : a > b }\";\n\tif (test_gist_empty_pair(ctx, map, context) < 0)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs to isl_map_plain_gist_basic_map, along with the expected output.\n */\nstruct {\n\tconst char *map;\n\tconst char *context;\n\tconst char *gist;\n} plain_gist_tests[] = {\n\t{ \"{ [i] -> [j] : i >= 1 and j >= 1 or i >= 2 and j <= 10 }\",\n\t  \"{ [i] -> [j] : i >= 1 }\",\n\t  \"{ [i] -> [j] : j >= 1 or i >= 2 and j <= 10 }\" },\n\t{ \"{ [n] -> [i,j,k] : (i mod 3 = 2 and j mod 4 = 2) or \"\n\t\t\"(j mod 4 = 2 and k mod 6 = n) }\",\n\t  \"{ [n] -> [i,j,k] : j mod 4 = 2 }\",\n\t  \"{ [n] -> [i,j,k] : (i mod 3 = 2) or (k mod 6 = n) }\" },\n\t{ \"{ [i] -> [j] : i > j and (exists a,b : i <= 2a + 5b <= 2) }\",\n\t  \"{ [i] -> [j] : i > j }\",\n\t  \"{ [i] -> [j] : exists a,b : i <= 2a + 5b <= 2 }\" },\n};\n\n/* Basic tests for isl_map_plain_gist_basic_map.\n */\nstatic int test_plain_gist(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(plain_gist_tests); ++i) {\n\t\tconst char *str;\n\t\tint equal;\n\t\tisl_map *map, *gist;\n\t\tisl_basic_map *context;\n\n\t\tmap = isl_map_read_from_str(ctx, plain_gist_tests[i].map);\n\t\tstr = plain_gist_tests[i].context;\n\t\tcontext = isl_basic_map_read_from_str(ctx, str);\n\t\tmap = isl_map_plain_gist_basic_map(map, context);\n\t\tgist = isl_map_read_from_str(ctx, plain_gist_tests[i].gist);\n\t\tequal = isl_map_is_equal(map, gist);\n\t\tisl_map_free(map);\n\t\tisl_map_free(gist);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"incorrect gist result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for isl_basic_set_gist tests that are expected to fail.\n */\nstruct {\n\tconst char *set;\n\tconst char *context;\n} gist_fail_tests[] = {\n\t{ \"{ [i] : exists (e0, e1: 3e1 >= 1 + 2e0 and \"\n\t    \"8e1 <= -1 + 5i - 5e0 and 2e1 >= 1 + 2i - 5e0) }\",\n\t  \"{ [i] : i >= 0 }\" },\n};\n\n/* Check that isl_basic_set_gist fails (gracefully) when expected.\n * In particular, the user should be able to recover from the failure.\n */\nstatic isl_stat test_gist_fail(struct isl_ctx *ctx)\n{\n\tint i, n;\n\tint on_error;\n\n\ton_error = isl_options_get_on_error(ctx);\n\tisl_options_set_on_error(ctx, ISL_ON_ERROR_CONTINUE);\n\tn = ARRAY_SIZE(gist_fail_tests);\n\tfor (i = 0; i < n; ++i) {\n\t\tconst char *str;\n\t\tisl_basic_set *bset, *context;\n\n\t\tbset = isl_basic_set_read_from_str(ctx, gist_fail_tests[i].set);\n\t\tstr = gist_fail_tests[i].context;\n\t\tcontext = isl_basic_set_read_from_str(ctx, str);\n\t\tbset = isl_basic_set_gist(bset, context);\n\t\tisl_basic_set_free(bset);\n\t\tif (bset)\n\t\t\tbreak;\n\t}\n\tisl_options_set_on_error(ctx, on_error);\n\tif (i < n)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"operation not expected to succeed\",\n\t\t\treturn isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\nstruct {\n\tconst char *set;\n\tconst char *context;\n\tconst char *gist;\n} gist_tests[] = {\n\t{ \"{ [1, -1, 3] }\",\n\t  \"{ [1, b, 2 - b] : -1 <= b <= 2 }\",\n\t  \"{ [a, -1, c] }\" },\n\t{ \"{ [a, b, c] : a <= 15 and a >= 1 }\",\n\t  \"{ [a, b, c] : exists (e0 = floor((-1 + a)/16): a >= 1 and \"\n\t\t\t\"c <= 30 and 32e0 >= -62 + 2a + 2b - c and b >= 0) }\",\n\t  \"{ [a, b, c] : a <= 15 }\" },\n\t{ \"{ : }\", \"{ : 1 = 0 }\", \"{ : }\" },\n\t{ \"{ : 1 = 0 }\", \"{ : 1 = 0 }\", \"{ : }\" },\n\t{ \"[M] -> { [x] : exists (e0 = floor((-2 + x)/3): 3e0 = -2 + x) }\",\n\t  \"[M] -> { [3M] }\" , \"[M] -> { [x] : 1 = 0 }\" },\n\t{ \"{ [m, n, a, b] : a <= 2147 + n }\",\n\t  \"{ [m, n, a, b] : (m >= 1 and n >= 1 and a <= 2148 - m and \"\n\t\t\t\"b <= 2148 - n and b >= 0 and b >= 2149 - n - a) or \"\n\t\t\t\"(n >= 1 and a >= 0 and b <= 2148 - n - a and \"\n\t\t\t\"b >= 0) }\",\n\t  \"{ [m, n, ku, kl] }\" },\n\t{ \"{ [a, a, b] : a >= 10 }\",\n\t  \"{ [a, b, c] : c >= a and c <= b and c >= 2 }\",\n\t  \"{ [a, a, b] : a >= 10 }\" },\n\t{ \"{ [i, j] : i >= 0 and i + j >= 0 }\", \"{ [i, j] : i <= 0 }\",\n\t  \"{ [0, j] : j >= 0 }\" },\n\t/* Check that no constraints on i6 are introduced in the gist */\n\t{ \"[t1] -> { [i4, i6] : exists (e0 = floor((1530 - 4t1 - 5i4)/20): \"\n\t\t\"20e0 <= 1530 - 4t1 - 5i4 and 20e0 >= 1511 - 4t1 - 5i4 and \"\n\t\t\"5e0 <= 381 - t1 and i4 <= 1) }\",\n\t  \"[t1] -> { [i4, i6] : exists (e0 = floor((-t1 + i6)/5): \"\n\t\t\"5e0 = -t1 + i6 and i6 <= 6 and i6 >= 3) }\",\n\t  \"[t1] -> { [i4, i6] : exists (e0 = floor((1530 - 4t1 - 5i4)/20): \"\n\t\t\"i4 <= 1 and 5e0 <= 381 - t1 and 20e0 <= 1530 - 4t1 - 5i4 and \"\n\t\t\"20e0 >= 1511 - 4t1 - 5i4) }\" },\n\t/* Check that no constraints on i6 are introduced in the gist */\n\t{ \"[t1, t2] -> { [i4, i5, i6] : exists (e0 = floor((1 + i4)/2), \"\n\t\t\"e1 = floor((1530 - 4t1 - 5i4)/20), \"\n\t\t\"e2 = floor((-4t1 - 5i4 + 10*floor((1 + i4)/2))/20), \"\n\t\t\"e3 = floor((-1 + i4)/2): t2 = 0 and 2e3 = -1 + i4 and \"\n\t\t\t\"20e2 >= -19 - 4t1 - 5i4 + 10e0 and 5e2 <= 1 - t1 and \"\n\t\t\t\"2e0 <= 1 + i4 and 2e0 >= i4 and \"\n\t\t\t\"20e1 <= 1530 - 4t1 - 5i4 and \"\n\t\t\t\"20e1 >= 1511 - 4t1 - 5i4 and i4 <= 1 and \"\n\t\t\t\"5e1 <= 381 - t1 and 20e2 <= -4t1 - 5i4 + 10e0) }\",\n\t  \"[t1, t2] -> { [i4, i5, i6] : exists (e0 = floor((-17 + i4)/2), \"\n\t\t\"e1 = floor((-t1 + i6)/5): 5e1 = -t1 + i6 and \"\n\t\t\t\"2e0 <= -17 + i4 and 2e0 >= -18 + i4 and \"\n\t\t\t\"10e0 <= -91 + 5i4 + 4i6 and \"\n\t\t\t\"10e0 >= -105 + 5i4 + 4i6) }\",\n\t  \"[t1, t2] -> { [i4, i5, i6] : exists (e0 = floor((381 - t1)/5), \"\n\t\t\"e1 = floor((-1 + i4)/2): t2 = 0 and 2e1 = -1 + i4 and \"\n\t\t\"i4 <= 1 and 5e0 <= 381 - t1 and 20e0 >= 1511 - 4t1 - 5i4) }\" },\n\t{ \"{ [0, 0, q, p] : -5 <= q <= 5 and p >= 0 }\",\n\t  \"{ [a, b, q, p] : b >= 1 + a }\",\n\t  \"{ [a, b, q, p] : false }\" },\n\t{ \"[n] -> { [x] : x = n && x mod 32 = 0 }\",\n\t  \"[n] -> { [x] : x mod 32 = 0 }\",\n\t  \"[n] -> { [x = n] }\" },\n\t{ \"{ [x] : x mod 6 = 0 }\", \"{ [x] : x mod 3 = 0 }\",\n\t  \"{ [x] : x mod 2 = 0 }\" },\n\t{ \"{ [x] : x mod 3200 = 0 }\", \"{ [x] : x mod 10000 = 0 }\",\n\t  \"{ [x] : x mod 128 = 0 }\" },\n\t{ \"{ [x] : x mod 3200 = 0 }\", \"{ [x] : x mod 10 = 0 }\",\n\t  \"{ [x] : x mod 3200 = 0 }\" },\n\t{ \"{ [a, b, c] : a mod 2 = 0 and a = c }\",\n\t  \"{ [a, b, c] : b mod 2 = 0 and b = c }\",\n\t  \"{ [a, b, c = a] }\" },\n\t{ \"{ [a, b, c] : a mod 6 = 0 and a = c }\",\n\t  \"{ [a, b, c] : b mod 2 = 0 and b = c }\",\n\t  \"{ [a, b, c = a] : a mod 3 = 0 }\" },\n\t{ \"{ [x] : 0 <= x <= 4 or 6 <= x <= 9 }\",\n\t  \"{ [x] : 1 <= x <= 3 or 7 <= x <= 8 }\",\n\t  \"{ [x] }\" },\n\t{ \"{ [x,y] : x < 0 and 0 <= y <= 4 or x >= -2 and -x <= y <= 10 + x }\",\n\t  \"{ [x,y] : 1 <= y <= 3 }\",\n\t  \"{ [x,y] }\" },\n};\n\n/* Check that isl_set_gist behaves as expected.\n *\n * For the test cases in gist_tests, besides checking that the result\n * is as expected, also check that applying the gist operation does\n * not modify the input set (an earlier version of isl would do that) and\n * that the test case is consistent, i.e., that the gist has the same\n * intersection with the context as the input set.\n */\nstatic int test_gist(struct isl_ctx *ctx)\n{\n\tint i;\n\tconst char *str;\n\tisl_basic_set *bset1, *bset2;\n\tisl_map *map1, *map2;\n\tisl_bool equal;\n\tisl_size n_div;\n\n\tfor (i = 0; i < ARRAY_SIZE(gist_tests); ++i) {\n\t\tisl_bool equal_input, equal_intersection;\n\t\tisl_set *set1, *set2, *copy, *context;\n\n\t\tset1 = isl_set_read_from_str(ctx, gist_tests[i].set);\n\t\tcontext = isl_set_read_from_str(ctx, gist_tests[i].context);\n\t\tcopy = isl_set_copy(set1);\n\t\tset1 = isl_set_gist(set1, isl_set_copy(context));\n\t\tset2 = isl_set_read_from_str(ctx, gist_tests[i].gist);\n\t\tequal = isl_set_is_equal(set1, set2);\n\t\tisl_set_free(set1);\n\t\tset1 = isl_set_read_from_str(ctx, gist_tests[i].set);\n\t\tequal_input = isl_set_is_equal(set1, copy);\n\t\tisl_set_free(copy);\n\t\tset1 = isl_set_intersect(set1, isl_set_copy(context));\n\t\tset2 = isl_set_intersect(set2, context);\n\t\tequal_intersection = isl_set_is_equal(set1, set2);\n\t\tisl_set_free(set2);\n\t\tisl_set_free(set1);\n\t\tif (equal < 0 || equal_input < 0 || equal_intersection < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"incorrect gist result\", return -1);\n\t\tif (!equal_input)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"gist modified input\", return -1);\n\t\tif (!equal_input)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"inconsistent gist test case\", return -1);\n\t}\n\n\tif (test_gist_fail(ctx) < 0)\n\t\treturn -1;\n\n\tstr = \"[p0, p2, p3, p5, p6, p10] -> { [] : \"\n\t    \"exists (e0 = [(15 + p0 + 15p6 + 15p10)/16], e1 = [(p5)/8], \"\n\t    \"e2 = [(p6)/128], e3 = [(8p2 - p5)/128], \"\n\t    \"e4 = [(128p3 - p6)/4096]: 8e1 = p5 and 128e2 = p6 and \"\n\t    \"128e3 = 8p2 - p5 and 4096e4 = 128p3 - p6 and p2 >= 0 and \"\n\t    \"16e0 >= 16 + 16p6 + 15p10 and  p2 <= 15 and p3 >= 0 and \"\n\t    \"p3 <= 31 and  p6 >= 128p3 and p5 >= 8p2 and p10 >= 0 and \"\n\t    \"16e0 <= 15 + p0 + 15p6 + 15p10 and 16e0 >= p0 + 15p6 + 15p10 and \"\n\t    \"p10 <= 15 and p10 <= -1 + p0 - p6) }\";\n\tbset1 = isl_basic_set_read_from_str(ctx, str);\n\tstr = \"[p0, p2, p3, p5, p6, p10] -> { [] : exists (e0 = [(p5)/8], \"\n\t    \"e1 = [(p6)/128], e2 = [(8p2 - p5)/128], \"\n\t    \"e3 = [(128p3 - p6)/4096]: 8e0 = p5 and 128e1 = p6 and \"\n\t    \"128e2 = 8p2 - p5 and 4096e3 = 128p3 - p6 and p5 >= -7 and \"\n\t    \"p2 >= 0 and 8p2 <= -1 + p0 and p2 <= 15 and p3 >= 0 and \"\n\t    \"p3 <= 31 and 128p3 <= -1 + p0 and p6 >= -127 and \"\n\t    \"p5 <= -1 + p0 and p6 <= -1 + p0 and p6 >= 128p3 and \"\n\t    \"p0 >= 1 and p5 >= 8p2 and p10 >= 0 and p10 <= 15 ) }\";\n\tbset2 = isl_basic_set_read_from_str(ctx, str);\n\tbset1 = isl_basic_set_gist(bset1, bset2);\n\tassert(bset1 && bset1->n_div == 0);\n\tisl_basic_set_free(bset1);\n\n\t/* Check that the integer divisions of the second disjunct\n\t * do not spread to the first disjunct.\n\t */\n\tstr = \"[t1] -> { S_0[] -> A[o0] : (exists (e0 = [(-t1 + o0)/16]: \"\n\t\t\"16e0 = -t1 + o0 and o0 >= 0 and o0 <= 15 and t1 >= 0)) or \"\n\t\t\"(exists (e0 = [(-1 + t1)/16], \"\n\t\t\t\"e1 = [(-16 + t1 - 16e0)/4294967296]: \"\n\t\t\t\"4294967296e1 = -16 + t1 - o0 - 16e0 and \"\n\t\t\t\"16e0 <= -1 + t1 and 16e0 >= -16 + t1 and o0 >= 0 and \"\n\t\t\t\"o0 <= 4294967295 and t1 <= -1)) }\";\n\tmap1 = isl_map_read_from_str(ctx, str);\n\tstr = \"[t1] -> { S_0[] -> A[o0] : t1 >= 0 and t1 <= 4294967295 }\";\n\tmap2 = isl_map_read_from_str(ctx, str);\n\tmap1 = isl_map_gist(map1, map2);\n\tif (!map1)\n\t\treturn -1;\n\tif (map1->n != 1)\n\t\tisl_die(ctx, isl_error_unknown, \"expecting single disjunct\",\n\t\t\tisl_map_free(map1); return -1);\n\tn_div = isl_basic_map_dim(map1->p[0], isl_dim_div);\n\tisl_map_free(map1);\n\tif (n_div < 0)\n\t\treturn -1;\n\tif (n_div != 1)\n\t\tisl_die(ctx, isl_error_unknown, \"expecting single div\",\n\t\t\treturn -1);\n\n\tif (test_gist_empty(ctx) < 0)\n\t\treturn -1;\n\tif (test_plain_gist(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint test_coalesce_set(isl_ctx *ctx, const char *str, int check_one)\n{\n\tisl_set *set, *set2;\n\tint equal;\n\tint one;\n\n\tset = isl_set_read_from_str(ctx, str);\n\tset = isl_set_coalesce(set);\n\tset2 = isl_set_read_from_str(ctx, str);\n\tequal = isl_set_is_equal(set, set2);\n\tone = set && set->n == 1;\n\tisl_set_free(set);\n\tisl_set_free(set2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"coalesced set not equal to input\", return -1);\n\tif (check_one && !one)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"coalesced set should not be a union\", return -1);\n\n\treturn 0;\n}\n\n/* Inputs for coalescing tests with unbounded wrapping.\n * \"str\" is a string representation of the input set.\n * \"single_disjunct\" is set if we expect the result to consist of\n *\ta single disjunct.\n */\nstruct {\n\tint single_disjunct;\n\tconst char *str;\n} coalesce_unbounded_tests[] = {\n\t{ 1, \"{ [x,y,z] : y + 2 >= 0 and x - y + 1 >= 0 and \"\n\t\t\t\"-x - y + 1 >= 0 and -3 <= z <= 3;\"\n\t\t\"[x,y,z] : -x+z + 20 >= 0 and -x-z + 20 >= 0 and \"\n\t\t\t\"x-z + 20 >= 0 and x+z + 20 >= 0 and \"\n\t\t\t\"-10 <= y <= 0}\" },\n\t{ 1, \"{ [x,y] : 0 <= x,y <= 10; [5,y]: 4 <= y <= 11 }\" },\n\t{ 1, \"{ [x,0,0] : -5 <= x <= 5; [0,y,1] : -5 <= y <= 5 }\" },\n\t{ 1, \"{ [x,y] : 0 <= x <= 10 and 0 >= y >= -1 and x+y >= 0; [0,1] }\" },\n\t{ 1, \"{ [x,y] : (0 <= x,y <= 4) or (2 <= x,y <= 5 and x + y <= 9) }\" },\n\t{ 0, \"{ [x, y, z] : 0 <= x,y,z <= 100 and 0 < z <= 2 + 2x + 2y; \"\n\t\t\"[x, y, 0] : x,y <= 100 and y <= 9 + 11x and x <= 9 + 11y }\" },\n\t{ 1, \"{ [0:1, 0:1]; [0, 2:3] }\" },\n\t{ 1, \"{ [0:1, 0:1]; [0, 2:3]; [1, -2:-1] }\" },\n\t{ 1, \"{ [0:3, 0:1]; [1:2, 2:5] }\" },\n\t{ 1, \"{ [0:3, 0:1]; [0:2, 2:5] }\" },\n\t{ 1, \"{ [0:3, 0:1]; [1:3, 2:5] }\" },\n\t{ 0, \"{ [0:3, 0:1]; [1:4, 2:5] }\" },\n\t{ 0, \"{ [0:3, 0:1]; [1:5, 2:5] }\" },\n};\n\n/* Test the functionality of isl_set_coalesce with the bounded wrapping\n * option turned off.\n */\nint test_coalesce_unbounded_wrapping(isl_ctx *ctx)\n{\n\tint i;\n\tint r = 0;\n\tint bounded;\n\n\tbounded = isl_options_get_coalesce_bounded_wrapping(ctx);\n\tisl_options_set_coalesce_bounded_wrapping(ctx, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(coalesce_unbounded_tests); ++i) {\n\t\tconst char *str = coalesce_unbounded_tests[i].str;\n\t\tint check_one = coalesce_unbounded_tests[i].single_disjunct;\n\t\tif (test_coalesce_set(ctx, str, check_one) >= 0)\n\t\t\tcontinue;\n\t\tr = -1;\n\t\tbreak;\n\t}\n\n\tisl_options_set_coalesce_bounded_wrapping(ctx, bounded);\n\n\treturn r;\n}\n\n/* Inputs for coalescing tests.\n * \"str\" is a string representation of the input set.\n * \"single_disjunct\" is set if we expect the result to consist of\n *\ta single disjunct.\n */\nstruct {\n\tint single_disjunct;\n\tconst char *str;\n} coalesce_tests[] = {\n\t{ 1, \"{[x,y]: x >= 0 & x <= 10 & y >= 0 & y <= 10 or \"\n\t\t       \"y >= x & x >= 2 & 5 >= y }\" },\n\t{ 1, \"{[x,y]: y >= 0 & 2x + y <= 30 & y <= 10 & x >= 0 or \"\n\t\t       \"x + y >= 10 & y <= x & x + y <= 20 & y >= 0}\" },\n\t{ 0, \"{[x,y]: y >= 0 & 2x + y <= 30 & y <= 10 & x >= 0 or \"\n\t\t       \"x + y >= 10 & y <= x & x + y <= 19 & y >= 0}\" },\n\t{ 1, \"{[x,y]: y >= 0 & x <= 5 & y <= x or \"\n\t\t       \"y >= 0 & x >= 6 & x <= 10 & y <= x}\" },\n\t{ 0, \"{[x,y]: y >= 0 & x <= 5 & y <= x or \"\n\t\t       \"y >= 0 & x >= 7 & x <= 10 & y <= x}\" },\n\t{ 0, \"{[x,y]: y >= 0 & x <= 5 & y <= x or \"\n\t\t       \"y >= 0 & x >= 6 & x <= 10 & y + 1 <= x}\" },\n\t{ 1, \"{[x,y]: y >= 0 & x <= 5 & y <= x or y >= 0 & x = 6 & y <= 6}\" },\n\t{ 0, \"{[x,y]: y >= 0 & x <= 5 & y <= x or y >= 0 & x = 7 & y <= 6}\" },\n\t{ 1, \"{[x,y]: y >= 0 & x <= 5 & y <= x or y >= 0 & x = 6 & y <= 5}\" },\n\t{ 0, \"{[x,y]: y >= 0 & x <= 5 & y <= x or y >= 0 & x = 6 & y <= 7}\" },\n\t{ 1, \"[n] -> { [i] : i = 1 and n >= 2 or 2 <= i and i <= n }\" },\n\t{ 0, \"{[x,y] : x >= 0 and y >= 0 or 0 <= y and y <= 5 and x = -1}\" },\n\t{ 1, \"[n] -> { [i] : 1 <= i and i <= n - 1 or 2 <= i and i <= n }\" },\n\t{ 0, \"[n] -> { [[i0] -> [o0]] : exists (e0 = [(i0)/4], e1 = [(o0)/4], \"\n\t\t\"e2 = [(n)/2], e3 = [(-2 + i0)/4], e4 = [(-2 + o0)/4], \"\n\t\t\"e5 = [(-2n + i0)/4]: 2e2 = n and 4e3 = -2 + i0 and \"\n\t\t\"4e4 = -2 + o0 and i0 >= 8 + 2n and o0 >= 2 + i0 and \"\n\t\t\"o0 <= 56 + 2n and o0 <= -12 + 4n and i0 <= 57 + 2n and \"\n\t\t\"i0 <= -11 + 4n and o0 >= 6 + 2n and 4e0 <= i0 and \"\n\t\t\"4e0 >= -3 + i0 and 4e1 <= o0 and 4e1 >= -3 + o0 and \"\n\t\t\"4e5 <= -2n + i0 and 4e5 >= -3 - 2n + i0);\"\n\t\t\"[[i0] -> [o0]] : exists (e0 = [(i0)/4], e1 = [(o0)/4], \"\n\t\t\"e2 = [(n)/2], e3 = [(-2 + i0)/4], e4 = [(-2 + o0)/4], \"\n\t\t\"e5 = [(-2n + i0)/4]: 2e2 = n and 4e3 = -2 + i0 and \"\n\t\t\"4e4 = -2 + o0 and 2e0 >= 3 + n and e0 <= -4 + n and \"\n\t\t\"2e0 <= 27 + n and e1 <= -4 + n and 2e1 <= 27 + n and \"\n\t\t\"2e1 >= 2 + n and e1 >= 1 + e0 and i0 >= 7 + 2n and \"\n\t\t\"i0 <= -11 + 4n and i0 <= 57 + 2n and 4e0 <= -2 + i0 and \"\n\t\t\"4e0 >= -3 + i0 and o0 >= 6 + 2n and o0 <= -11 + 4n and \"\n\t\t\"o0 <= 57 + 2n and 4e1 <= -2 + o0 and 4e1 >= -3 + o0 and \"\n\t\t\"4e5 <= -2n + i0 and 4e5 >= -3 - 2n + i0 ) }\" },\n\t{ 0, \"[n, m] -> { [o0, o2, o3] : (o3 = 1 and o0 >= 1 + m and \"\n\t      \"o0 <= n + m and o2 <= m and o0 >= 2 + n and o2 >= 3) or \"\n\t      \"(o0 >= 2 + n and o0 >= 1 + m and o0 <= n + m and n >= 1 and \"\n\t      \"o3 <= -1 + o2 and o3 >= 1 - m + o2 and o3 >= 2 and o3 <= n) }\" },\n\t{ 0, \"[M, N] -> { [[i0, i1, i2, i3, i4, i5, i6] -> \"\n\t  \"[o0, o1, o2, o3, o4, o5, o6]] : \"\n\t  \"(o6 <= -4 + 2M - 2N + i0 + i1 - i2 + i6 - o0 - o1 + o2 and \"\n\t  \"o3 <= -2 + i3 and o6 >= 2 + i0 + i3 + i6 - o0 - o3 and \"\n\t  \"o6 >= 2 - M + N + i3 + i4 + i6 - o3 - o4 and o0 <= -1 + i0 and \"\n\t  \"o4 >= 4 - 3M + 3N - i0 - i1 + i2 + 2i3 + i4 + o0 + o1 - o2 - 2o3 \"\n\t  \"and o6 <= -3 + 2M - 2N + i3 + i4 - i5 + i6 - o3 - o4 + o5 and \"\n\t  \"2o6 <= -5 + 5M - 5N + 2i0 + i1 - i2 - i5 + 2i6 - 2o0 - o1 + o2 + o5 \"\n\t  \"and o6 >= 2i0 + i1 + i6 - 2o0 - o1 and \"\n\t  \"3o6 <= -5 + 4M - 4N + 2i0 + i1 - i2 + 2i3 + i4 - i5 + 3i6 \"\n\t  \"- 2o0 - o1 + o2 - 2o3 - o4 + o5) or \"\n\t  \"(N >= 2 and o3 <= -1 + i3 and o0 <= -1 + i0 and \"\n\t  \"o6 >= i3 + i6 - o3 and M >= 0 and \"\n\t  \"2o6 >= 1 + i0 + i3 + 2i6 - o0 - o3 and \"\n\t  \"o6 >= 1 - M + i0 + i6 - o0 and N >= 2M and o6 >= i0 + i6 - o0) }\" },\n\t{ 0, \"[M, N] -> { [o0] : (o0 = 0 and M >= 1 and N >= 2) or \"\n\t\t\"(o0 = 0 and M >= 1 and N >= 2M and N >= 2 + M) or \"\n\t\t\"(o0 = 0 and M >= 2 and N >= 3) or \"\n\t\t\"(M = 0 and o0 = 0 and N >= 3) }\" },\n\t{ 0, \"{ [i0, i1, i2, i3] : (i1 = 10i0 and i0 >= 1 and 10i0 <= 100 and \"\n\t    \"i3 <= 9 + 10 i2 and i3 >= 1 + 10i2 and i3 >= 0) or \"\n\t    \"(i1 <= 9 + 10i0 and i1 >= 1 + 10i0 and i2 >= 0 and \"\n\t    \"i0 >= 0 and i1 <= 100 and i3 <= 9 + 10i2 and i3 >= 1 + 10i2) }\" },\n\t{ 0, \"[M] -> { [i1] : (i1 >= 2 and i1 <= M) or (i1 = M and M >= 1) }\" },\n\t{ 0, \"{[x,y] : x,y >= 0; [x,y] : 10 <= x <= 20 and y >= -1 }\" },\n\t{ 1, \"{ [x, y] : (x >= 1 and y >= 1 and x <= 2 and y <= 2) or \"\n\t\t\"(y = 3 and x = 1) }\" },\n\t{ 1, \"[M] -> { [i0, i1, i2, i3, i4] : (i1 >= 3 and i4 >= 2 + i2 and \"\n\t\t\"i2 >= 2 and i0 >= 2 and i3 >= 1 + i2 and i0 <= M and \"\n\t\t\"i1 <= M and i3 <= M and i4 <= M) or \"\n\t\t\"(i1 >= 2 and i4 >= 1 + i2 and i2 >= 2 and i0 >= 2 and \"\n\t\t\"i3 >= 1 + i2 and i0 <= M and i1 <= -1 + M and i3 <= M and \"\n\t\t\"i4 <= -1 + M) }\" },\n\t{ 1, \"{ [x, y] : (x >= 0 and y >= 0 and x <= 10 and y <= 10) or \"\n\t\t\"(x >= 1 and y >= 1 and x <= 11 and y <= 11) }\" },\n\t{ 0, \"{[x,0] : x >= 0; [x,1] : x <= 20}\" },\n\t{ 1, \"{ [x, 1 - x] : 0 <= x <= 1; [0,0] }\" },\n\t{ 1, \"{ [0,0]; [i,i] : 1 <= i <= 10 }\" },\n\t{ 0, \"{ [0,0]; [i,j] : 1 <= i,j <= 10 }\" },\n\t{ 1, \"{ [0,0]; [i,2i] : 1 <= i <= 10 }\" },\n\t{ 0, \"{ [0,0]; [i,2i] : 2 <= i <= 10 }\" },\n\t{ 0, \"{ [1,0]; [i,2i] : 1 <= i <= 10 }\" },\n\t{ 0, \"{ [0,1]; [i,2i] : 1 <= i <= 10 }\" },\n\t{ 0, \"{ [a, b] : exists e : 2e = a and \"\n\t\t    \"a >= 0 and (a <= 3 or (b <= 0 and b >= -4 + a)) }\" },\n\t{ 0, \"{ [i, j, i', j'] : i <= 2 and j <= 2 and \"\n\t\t\t\"j' >= -1 + 2i + j - 2i' and i' <= -1 + i and \"\n\t\t\t\"j >= 1 and j' <= i + j - i' and i >= 1; \"\n\t\t\"[1, 1, 1, 1] }\" },\n\t{ 1, \"{ [i,j] : exists a,b : i = 2a and j = 3b; \"\n\t\t \"[i,j] : exists a : j = 3a }\" },\n\t{ 1, \"{ [a, b, c] : (c <= 7 - b and b <= 1 and b >= 0 and \"\n\t\t\t\"c >= 3 + b and b <= 3 + 8a and b >= -26 + 8a and \"\n\t\t\t\"a >= 3) or \"\n\t\t    \"(b <= 1 and c <= 7 and b >= 0 and c >= 4 + b and \"\n\t\t\t\"b <= 3 + 8a and b >= -26 + 8a and a >= 3) }\" },\n\t{ 1, \"{ [a, 0, c] : c >= 1 and c <= 29 and c >= -1 + 8a and \"\n\t\t\t\t\"c <= 6 + 8a and a >= 3; \"\n\t\t\"[a, -1, c] : c >= 1 and c <= 30 and c >= 8a and \"\n\t\t\t\t\"c <= 7 + 8a and a >= 3 and a <= 4 }\" },\n\t{ 1, \"{ [x,y] : 0 <= x <= 2 and y >= 0 and x + 2y <= 4; \"\n\t\t\"[x,0] : 3 <= x <= 4 }\" },\n\t{ 1, \"{ [x,y] : 0 <= x <= 3 and y >= 0 and x + 3y <= 6; \"\n\t\t\"[x,0] : 4 <= x <= 5 }\" },\n\t{ 0, \"{ [x,y] : 0 <= x <= 2 and y >= 0 and x + 2y <= 4; \"\n\t\t\"[x,0] : 3 <= x <= 5 }\" },\n\t{ 0, \"{ [x,y] : 0 <= x <= 2 and y >= 0 and x + y <= 4; \"\n\t\t\"[x,0] : 3 <= x <= 4 }\" },\n\t{ 1, \"{ [i0, i1] : i0 <= 122 and i0 >= 1 and 128i1 >= -249 + i0 and \"\n\t\t\t\"i1 <= 0; \"\n\t\t\"[i0, 0] : i0 >= 123 and i0 <= 124 }\" },\n\t{ 1, \"{ [0,0]; [1,1] }\" },\n\t{ 1, \"[n] -> { [k] : 16k <= -1 + n and k >= 1; [0] : n >= 2 }\" },\n\t{ 1, \"{ [k, ii, k - ii] : ii >= -6 + k and ii <= 6 and ii >= 1 and \"\n\t\t\t\t\"ii <= k;\"\n\t\t\"[k, 0, k] : k <= 6 and k >= 1 }\" },\n\t{ 1, \"{ [i,j] : i = 4 j and 0 <= i <= 100;\"\n\t\t\"[i,j] : 1 <= i <= 100 and i >= 4j + 1 and i <= 4j + 2 }\" },\n\t{ 1, \"{ [x,y] : x % 2 = 0 and y % 2 = 0; [x,x] : x % 2 = 0 }\" },\n\t{ 1, \"[n] -> { [1] : n >= 0;\"\n\t\t    \"[x] : exists (e0 = floor((x)/2): x >= 2 and \"\n\t\t\t\"2e0 >= -1 + x and 2e0 <= x and 2e0 <= n) }\" },\n\t{ 1, \"[n] -> { [x, y] : exists (e0 = floor((x)/2), e1 = floor((y)/3): \"\n\t\t\t\"3e1 = y and x >= 2 and 2e0 >= -1 + x and \"\n\t\t\t\"2e0 <= x and 2e0 <= n);\"\n\t\t    \"[1, y] : exists (e0 = floor((y)/3): 3e0 = y and \"\n\t\t\t\"n >= 0) }\" },\n\t{ 1, \"[t1] -> { [i0] : (exists (e0 = floor((63t1)/64): \"\n\t\t\t\t\"128e0 >= -134 + 127t1 and t1 >= 2 and \"\n\t\t\t\t\"64e0 <= 63t1 and 64e0 >= -63 + 63t1)) or \"\n\t\t\t\t\"t1 = 1 }\" },\n\t{ 1, \"{ [i, i] : exists (e0 = floor((1 + 2i)/3): 3e0 <= 2i and \"\n\t\t\t\t\"3e0 >= -1 + 2i and i <= 9 and i >= 1);\"\n\t\t\"[0, 0] }\" },\n\t{ 1, \"{ [t1] : exists (e0 = floor((-11 + t1)/2): 2e0 = -11 + t1 and \"\n\t\t\t\t\"t1 >= 13 and t1 <= 16);\"\n\t\t\"[t1] : t1 <= 15 and t1 >= 12 }\" },\n\t{ 1, \"{ [x,y] : x = 3y and 0 <= y <= 2; [-3,-1] }\" },\n\t{ 1, \"{ [x,y] : 2x = 3y and 0 <= y <= 4; [-3,-2] }\" },\n\t{ 0, \"{ [x,y] : 2x = 3y and 0 <= y <= 4; [-2,-2] }\" },\n\t{ 0, \"{ [x,y] : 2x = 3y and 0 <= y <= 4; [-3,-1] }\" },\n\t{ 1, \"{ [i] : exists j : i = 4 j and 0 <= i <= 100;\"\n\t\t\"[i] : exists j : 1 <= i <= 100 and i >= 4j + 1 and \"\n\t\t\t\t\"i <= 4j + 2 }\" },\n\t{ 1, \"{ [c0] : (exists (e0 : c0 - 1 <= 3e0 <= c0)) or \"\n\t\t\"(exists (e0 : 3e0 = -2 + c0)) }\" },\n\t{ 0, \"[n, b0, t0] -> \"\n\t\t\"{ [i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12] : \"\n\t\t\"(exists (e0 = floor((-32b0 + i4)/1048576), \"\n\t\t\"e1 = floor((i8)/32): 1048576e0 = -32b0 + i4 and 32e1 = i8 and \"\n\t\t\"n <= 2147483647 and b0 <= 32767 and b0 >= 0 and \"\n\t\t\"32b0 <= -2 + n and t0 <= 31 and t0 >= 0 and i0 >= 8 + n and \"\n\t\t\"3i4 <= -96 + 3t0 + i0 and 3i4 >= -95 - n + 3t0 + i0 and \"\n\t\t\"i8 >= -157 + i0 - 4i4 and i8 >= 0 and \"\n\t\t\"i8 <= -33 + i0 - 4i4 and 3i8 <= -91 + 4n - i0)) or \"\n\t\t\"(exists (e0 = floor((-32b0 + i4)/1048576), \"\n\t\t\"e1 = floor((i8)/32): 1048576e0 = -32b0 + i4 and 32e1 = i8 and \"\n\t\t\"n <= 2147483647 and b0 <= 32767 and b0 >= 0 and \"\n\t\t\"32b0 <= -2 + n and t0 <= 31 and t0 >= 0 and i0 <= 7 + n and \"\n\t\t\"4i4 <= -3 + i0 and 3i4 <= -96 + 3t0 + i0 and \"\n\t\t\"3i4 >= -95 - n + 3t0 + i0 and i8 >= -157 + i0 - 4i4 and \"\n\t\t\"i8 >= 0 and i8 <= -4 + i0 - 3i4 and i8 <= -41 + i0));\"\n\t\t\"[i0, i1, i2, i3, 0, i5, i6, i7, i8, i9, i10, i11, i12] : \"\n\t\t\"(exists (e0 = floor((i8)/32): b0 = 0 and 32e0 = i8 and \"\n\t\t\"n <= 2147483647 and t0 <= 31 and t0 >= 0 and i0 >= 11 and \"\n\t\t\"i0 >= 96 - 3t0 and i0 <= 95 + n - 3t0 and i0 <= 7 + n and \"\n\t\t\"i8 >= -40 + i0 and i8 <= -10 + i0)) }\" },\n\t{ 0, \"{ [i0, i1, i2] : \"\n\t\t\"(exists (e0, e1 = floor((i0)/32), e2 = floor((i1)/32): \"\n\t\t\"32e1 = i0 and 32e2 = i1 and i1 >= -31 + i0 and \"\n\t\t\"i1 <= 31 + i0 and i2 >= -30 + i0 and i2 >= -30 + i1 and \"\n\t\t\"32e0 >= -30 + i0 and 32e0 >= -30 + i1 and \"\n\t\t\"32e0 >= -31 + i2 and 32e0 <= 30 + i2 and 32e0 <= 31 + i1 and \"\n\t\t\"32e0 <= 31 + i0)) or \"\n\t\t\"i0 >= 0 }\" },\n\t{ 1, \"{ [a, b, c] : 2b = 1 + a and 2c = 2 + a; [0, 0, 0] }\" },\n\t{ 1, \"{ [a, a, b, c] : 32*floor((a)/32) = a and 2*floor((b)/2) = b and \"\n\t\t\t\t\"2*floor((c)/2) = c and 0 <= a <= 192;\"\n\t\t\"[224, 224, b, c] : 2*floor((b)/2) = b and 2*floor((c)/2) = c }\"\n\t},\n\t{ 1, \"[n] -> { [a,b] : (exists e : 1 <= a <= 7e and 9e <= b <= n) or \"\n\t\t\t\t\"(0 <= a <= b <= n) }\" },\n\t{ 1, \"{ [a, b] : 0 <= a <= 2 and b >= 0 and \"\n\t\t\"((0 < b <= 13) or (2*floor((a + b)/2) >= -5 + a + 2b)) }\" },\n\t{ 1, \"{ [a] : (2 <= a <= 5) or (a mod 2 = 1 and 1 <= a <= 5) }\" },\n\t{ 1, \"{ [a, b, c] : (b = -1 + a and 0 < a <= 3 and \"\n\t\t\t\t\"9*floor((-4a + 2c)/9) <= -3 - 4a + 2c) or \"\n\t\t\t\"(exists (e0 = floor((-16 + 2c)/9): a = 4 and \"\n\t\t\t\t\"b = 3 and 9e0 <= -19 + 2c)) }\" },\n\t{ 1, \"{ [a, b, c] : (b = -1 + a and 0 < a <= 3 and \"\n\t\t\t\t\"9*floor((-4a + 2c)/9) <= -3 - 4a + 2c) or \"\n\t\t\t\"(a = 4 and b = 3 and \"\n\t\t\t\t\"9*floor((-16 + 2c)/9) <= -19 + 2c) }\" },\n\t{ 0, \"{ [a, b, c] : (b <= 2 and b <= -2 + a) or \"\n\t\t\t\"(b = -1 + a and 0 < a <= 3 and \"\n\t\t\t\t\"9*floor((-4a + 2c)/9) <= -3 - 4a + 2c) or \"\n\t\t\t\"(exists (e0 = floor((-16 + 2c)/9): a = 4 and \"\n\t\t\t\t\"b = 3 and 9e0 <= -19 + 2c)) }\" },\n\t{ 1, \"{ [y, x] : (x - y) mod 3 = 2 and 2 <= y <= 200 and 0 <= x <= 2;\"\n\t\t\"[1, 0] }\" },\n\t{ 1, \"{ [x, y] : (x - y) mod 3 = 2 and 2 <= y <= 200 and 0 <= x <= 2;\"\n\t\t\"[0, 1] }\" },\n\t{ 1, \"{ [1, y] : -1 <= y <= 1; [x, -x] : 0 <= x <= 1 }\" },\n\t{ 1, \"{ [1, y] : 0 <= y <= 1; [x, -x] : 0 <= x <= 1 }\" },\n\t{ 1, \"{ [x, y] : 0 <= x <= 10 and x - 4*floor(x/4) <= 1 and y <= 0; \"\n\t       \"[x, y] : 0 <= x <= 10 and x - 4*floor(x/4) > 1 and y <= 0; \"\n\t       \"[x, y] : 0 <= x <= 10 and x - 5*floor(x/5) <= 1 and 0 < y; \"\n\t       \"[x, y] : 0 <= x <= 10 and x - 5*floor(x/5) > 1 and 0 < y }\" },\n\t{ 1, \"{ [x, 0] : 0 <= x <= 10 and x mod 2 = 0; \"\n\t       \"[x, 0] : 0 <= x <= 10 and x mod 2 = 1; \"\n\t       \"[x, y] : 0 <= x <= 10 and 1 <= y <= 10 }\" },\n\t{ 1, \"{ [a] : a <= 8 and \"\n\t\t\t\"(a mod 10 = 7 or a mod 10 = 8 or a mod 10 = 9) }\" },\n\t{ 1, \"{ [x, y] : 2y = -x and x <= 0 or \"\n\t\t\t\"x <= -1 and 2y <= -x - 1 and 2y >= x - 1 }\" },\n\t{ 0, \"{ [x, y] : 2y = -x and x <= 0 or \"\n\t\t\t\"x <= -2 and 2y <= -x - 1 and 2y >= x - 1 }\" },\n\t{ 1, \"{ [a] : (a <= 0 and 3*floor((a)/3) = a) or \"\n\t\t\t\"(a < 0 and 3*floor((a)/3) < a) }\" },\n\t{ 1, \"{ [a] : (a <= 0 and 3*floor((a)/3) = a) or \"\n\t\t\t\"(a < -1 and 3*floor((a)/3) < a) }\" },\n\t{ 1, \"{ [a, b] : a <= 1024 and b >= 0 and \"\n\t\t\"((-31 - a + b <= 32*floor((-1 - a)/32) <= -33 + b and \"\n\t\t  \"32*floor((-1 - a)/32) <= -16 + b + 16*floor((-1 - a)/16))\"\n\t\t\"or (2 <= a <= 15 and b < a)) }\" },\n\t{ 1, \"{ [a] : a > 0 and ((16*floor((a)/16) < a and \"\n\t\t\t\"32*floor((a)/32) < a) or a <= 15) }\" },\n\t{ 1, \"{ [a, b, c, d] : (-a + d) mod 64 = 0 and a <= 8 and b <= 1 and \"\n\t\t\t\"10 - a <= c <= 3 and d >= 5 and 9 - 64b <= d <= 70;\"\n\t    \"[a, b = 1, c, d] : (-a + d) mod 64 = 0 and a <= 8 and c >= 4 and \"\n\t\t\t\"10 - a <= c <= 5 and 5 <= d <= 73 - c }\" },\n\t{ 1, \"[n, m] -> { S_0[i] : (-n + i) mod 3 = 0 and m >= 3 + n and \"\n\t\t\t    \"i >= n and 3*floor((2 + n + 2m)/3) <= n + 3m - i; \"\n\t\t\t \"S_0[n] : n <= m <= 2 + n }\" },\n\t{ 1, \"{ [a, b] : exists (e0: 0 <= a <= 1 and b >= 0 and \"\n\t\t\t\"2e0 >= -5 + a + 2b and 2e0 >= -1 + a + b and \"\n\t\t\t\"2e0 <= a + b); \"\n\t\t\"[a, b] : exists (e0: 0 <= a <= 1 and 2e0 >= -5 + a + 2b and \"\n\t\t\t\"2e0 >= -1 - a + b and 2e0 <= -a + b and \"\n\t\t\t\"2e0 < -a + 2b) }\" },\n\t{ 1, \"{ [i, j, i - 8j] : 8 <= i <= 63 and -7 + i <= 8j <= i; \"\n\t\t\"[i, 0, i] : 0 <= i <= 7 }\" },\n\t{ 1, \"{ [a, b] : a >= 0 and 0 <= b <= 1 - a; [1, 1] }\" },\n\t{ 0, \"{ [a, b] : a >= 0 and 0 <= b <= 1 - a; [0, 2] }\" },\n\t{ 0, \"{ [a, b] : a >= 0 and 0 <= b <= 1 - a; [-1, 3] }\" },\n\t{ 1, \"{ [a, b] : a, b >= 0 and a + 2b <= 2; [1, 1] }\" },\n\t{ 0, \"{ [a, b] : a, b >= 0 and a + 2b <= 2; [2, 1] }\" },\n\t{ 0, \"{ [a, c] : (2 + a) mod 4 = 0 or \"\n\t\t\"(c = 4 + a and 4 * floor((a)/4) = a and a >= 0 and a <= 4) or \"\n\t\t\"(c = 3 + a and 4 * floor((-1 + a)/4) = -1 + a and \"\n\t\t    \"a > 0 and a <= 5) }\" },\n\t{ 1, \"{ [1, 0, 0]; [a, b, c] : -1 <= -a < b <= 0 and 2c > b }\" },\n\t{ 0, \"{ [j, a, l] : a mod 2 = 0 and j <= 29 and a >= 2 and \"\n\t\t\t\"2a <= -5 + j and 32j + 2a + 2 <= 4l < 33j; \"\n\t\t\"[j, 0, l] : 4 <= j <= 29 and -3 + 33j <= 4l <= 33j }\" },\n\t{ 0, \"{ [0:1, 0:1]; [0, 2:3] }\" },\n\t{ 1, \"{ [a] : (a = 0 or ((1 + a) mod 2 = 0 and 0 < a <= 15) or \"\n\t\t\"((a) mod 2 = 0 and 0 < a <= 15)) }\" },\n};\n\n/* A specialized coalescing test case that would result\n * in a segmentation fault or a failed assertion in earlier versions of isl.\n */\nstatic int test_coalesce_special(struct isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_map *map1, *map2;\n\n\tstr = \"[y] -> { [S_L220_OUT[] -> T7[]] -> \"\n\t    \"[[S_L309_IN[] -> T11[]] -> ce_imag2[1, o1]] : \"\n\t    \"(y = 201 and o1 <= 239 and o1 >= 212) or \"\n\t    \"(exists (e0 = [(y)/3]: 3e0 = y and y <= 198 and y >= 3 and \"\n\t\t\"o1 <= 239 and o1 >= 212)) or \"\n\t    \"(exists (e0 = [(y)/3]: 3e0 = y and y <= 201 and y >= 3 and \"\n\t\t\"o1 <= 241 and o1 >= 240));\"\n\t    \"[S_L220_OUT[] -> T7[]] -> \"\n\t    \"[[S_L309_IN[] -> T11[]] -> ce_imag2[0, o1]] : \"\n\t    \"(y = 2 and o1 <= 241 and o1 >= 212) or \"\n\t    \"(exists (e0 = [(-2 + y)/3]: 3e0 = -2 + y and y <= 200 and \"\n\t\t\"y >= 5 and o1 <= 241 and o1 >= 212)) }\";\n\tmap1 = isl_map_read_from_str(ctx, str);\n\tmap1 = isl_map_align_divs_internal(map1);\n\tmap1 = isl_map_coalesce(map1);\n\tstr = \"[y] -> { [S_L220_OUT[] -> T7[]] -> \"\n\t    \"[[S_L309_IN[] -> T11[]] -> ce_imag2[o0, o1]] : \"\n\t    \"exists (e0 = [(-1 - y + o0)/3]: 3e0 = -1 - y + o0 and \"\n\t\t\"y <= 201 and o0 <= 2 and o1 >= 212 and o1 <= 241 and \"\n\t\t\"o0 >= 3 - y and o0 <= -2 + y and o0 >= 0) }\";\n\tmap2 = isl_map_read_from_str(ctx, str);\n\tmap2 = isl_map_union(map2, map1);\n\tmap2 = isl_map_align_divs_internal(map2);\n\tmap2 = isl_map_coalesce(map2);\n\tisl_map_free(map2);\n\tif (!map2)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* A specialized coalescing test case that would result in an assertion\n * in an earlier version of isl.\n * The explicit call to isl_basic_set_union prevents the implicit\n * equality constraints in the first basic map from being detected prior\n * to the call to isl_set_coalesce, at least at the point\n * where this test case was introduced.\n */\nstatic int test_coalesce_special2(struct isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset1, *bset2;\n\tisl_set *set;\n\n\tstr = \"{ [x, y] : x, y >= 0 and x + 2y <= 1 and 2x + y <= 1 }\";\n\tbset1 = isl_basic_set_read_from_str(ctx, str);\n\tstr = \"{ [x,0] : -1 <= x <= 1 and x mod 2 = 1 }\" ;\n\tbset2 = isl_basic_set_read_from_str(ctx, str);\n\tset = isl_basic_set_union(bset1, bset2);\n\tset = isl_set_coalesce(set);\n\tisl_set_free(set);\n\n\tif (!set)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Check that calling isl_set_coalesce does not leave other sets\n * that may share some information with the input to isl_set_coalesce\n * in an inconsistent state.\n * In particular, older versions of isl would modify all copies\n * of the basic sets in the isl_set_coalesce input in a way\n * that could leave them in an inconsistent state.\n * The result of printing any other set containing one of these\n * basic sets would then result in an invalid set description.\n */\nstatic int test_coalesce_special3(isl_ctx *ctx)\n{\n\tconst char *str;\n\tchar *s;\n\tisl_set *set1, *set2;\n\tisl_printer *p;\n\n\tset1 = isl_set_read_from_str(ctx, \"{ [0, 0, 0] }\");\n\tstr = \"{ [a, b, a + b] : a >= 0 and b >= 0 and 0 < a + b }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tset1 = isl_set_union(set1, isl_set_copy(set2));\n\tset1 = isl_set_coalesce(set1);\n\tisl_set_free(set1);\n\n\tp = isl_printer_to_str(ctx);\n\tp = isl_printer_print_set(p, set2);\n\tisl_set_free(set2);\n\ts = isl_printer_get_str(p);\n\tisl_printer_free(p);\n\tset1 = isl_set_read_from_str(ctx, s);\n\tfree(s);\n\tisl_set_free(set1);\n\n\tif (!set1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that calling isl_set_coalesce on the intersection of\n * the sets described by \"s1\" and \"s2\" does not leave other sets\n * that may share some information with the input to isl_set_coalesce\n * in an inconsistent state.\n * In particular, when isl_set_coalesce detects equality constraints,\n * it does not immediately perform Gaussian elimination on them,\n * but then it needs to ensure that it is performed at some point.\n * The input set has implicit equality constraints in the first disjunct.\n * It is constructed as an intersection, because otherwise\n * those equality constraints would already be detected during parsing.\n */\nstatic isl_stat test_coalesce_intersection(isl_ctx *ctx,\n\tconst char *s1, const char *s2)\n{\n\tisl_set *set1, *set2;\n\n\tset1 = isl_set_read_from_str(ctx, s1);\n\tset2 = isl_set_read_from_str(ctx, s2);\n\tset1 = isl_set_intersect(set1, set2);\n\tisl_set_free(isl_set_coalesce(isl_set_copy(set1)));\n\tset1 = isl_set_coalesce(set1);\n\tisl_set_free(set1);\n\n\tif (!set1)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Check that calling isl_set_coalesce does not leave other sets\n * that may share some information with the input to isl_set_coalesce\n * in an inconsistent state, for the case where one disjunct\n * is a subset of the other.\n */\nstatic isl_stat test_coalesce_special4(isl_ctx *ctx)\n{\n\tconst char *s1, *s2;\n\n\ts1 = \"{ [a, b] : b <= 0 or a <= 1 }\";\n\ts2 = \"{ [a, b] : -1 <= -a < b }\";\n\treturn test_coalesce_intersection(ctx, s1, s2);\n}\n\n/* Check that calling isl_set_coalesce does not leave other sets\n * that may share some information with the input to isl_set_coalesce\n * in an inconsistent state, for the case where two disjuncts\n * can be fused.\n */\nstatic isl_stat test_coalesce_special5(isl_ctx *ctx)\n{\n\tconst char *s1, *s2;\n\n\ts1 = \"{ [a, b, c] : b <= 0 }\";\n\ts2 = \"{ [a, b, c] : -1 <= -a < b and (c >= 0 or c < 0) }\";\n\treturn test_coalesce_intersection(ctx, s1, s2);\n}\n\n/* Check that calling isl_set_coalesce does not leave other sets\n * that may share some information with the input to isl_set_coalesce\n * in an inconsistent state, for the case where two disjuncts\n * can be fused and where both disjuncts have implicit equality constraints.\n */\nstatic isl_stat test_coalesce_special6(isl_ctx *ctx)\n{\n\tconst char *s1, *s2;\n\n\ts1 = \"{ [a, b, c] : c <= 0 }\";\n\ts2 = \"{ [a, b, c] : 0 <= a <= b <= c or (0 <= b <= c and a > 0) }\";\n\treturn test_coalesce_intersection(ctx, s1, s2);\n}\n\n/* Test the functionality of isl_set_coalesce.\n * That is, check that the output is always equal to the input\n * and in some cases that the result consists of a single disjunct.\n */\nstatic int test_coalesce(struct isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coalesce_tests); ++i) {\n\t\tconst char *str = coalesce_tests[i].str;\n\t\tint check_one = coalesce_tests[i].single_disjunct;\n\t\tif (test_coalesce_set(ctx, str, check_one) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (test_coalesce_unbounded_wrapping(ctx) < 0)\n\t\treturn -1;\n\tif (test_coalesce_special(ctx) < 0)\n\t\treturn -1;\n\tif (test_coalesce_special2(ctx) < 0)\n\t\treturn -1;\n\tif (test_coalesce_special3(ctx) < 0)\n\t\treturn -1;\n\tif (test_coalesce_special4(ctx) < 0)\n\t\treturn -1;\n\tif (test_coalesce_special5(ctx) < 0)\n\t\treturn -1;\n\tif (test_coalesce_special6(ctx) < 0)\n\t\treturn -1;\n\n\n\treturn 0;\n}\n\n/* Construct a representation of the graph on the right of Figure 1\n * in \"Computing the Transitive Closure of a Union of\n * Affine Integer Tuple Relations\".\n */\nstatic __isl_give isl_map *cocoa_fig_1_right_graph(isl_ctx *ctx)\n{\n\tisl_set *dom;\n\tisl_map *up, *right;\n\n\tdom = isl_set_read_from_str(ctx,\n\t\t\"{ [x,y] : x >= 0 and -2 x + 3 y >= 0 and x <= 3 and \"\n\t\t\t\"2 x - 3 y + 3 >= 0 }\");\n\tright = isl_map_read_from_str(ctx,\n\t\t\"{ [x,y] -> [x2,y2] : x2 = x + 1 and y2 = y }\");\n\tup = isl_map_read_from_str(ctx,\n\t\t\"{ [x,y] -> [x2,y2] : x2 = x and y2 = y + 1 }\");\n\tright = isl_map_intersect_domain(right, isl_set_copy(dom));\n\tright = isl_map_intersect_range(right, isl_set_copy(dom));\n\tup = isl_map_intersect_domain(up, isl_set_copy(dom));\n\tup = isl_map_intersect_range(up, dom);\n\treturn isl_map_union(up, right);\n}\n\n/* Construct a representation of the power of the graph\n * on the right of Figure 1 in \"Computing the Transitive Closure of\n * a Union of Affine Integer Tuple Relations\".\n */\nstatic __isl_give isl_map *cocoa_fig_1_right_power(isl_ctx *ctx)\n{\n\treturn isl_map_read_from_str(ctx,\n\t\t\"{ [1] -> [[0,0] -> [0,1]]; [2] -> [[0,0] -> [1,1]]; \"\n\t\t\"  [1] -> [[0,1] -> [1,1]]; [1] -> [[2,2] -> [3,2]]; \"\n\t\t\"  [2] -> [[2,2] -> [3,3]]; [1] -> [[3,2] -> [3,3]] }\");\n}\n\n/* Construct a representation of the transitive closure of the graph\n * on the right of Figure 1 in \"Computing the Transitive Closure of\n * a Union of Affine Integer Tuple Relations\".\n */\nstatic __isl_give isl_map *cocoa_fig_1_right_tc(isl_ctx *ctx)\n{\n\treturn isl_set_unwrap(isl_map_range(cocoa_fig_1_right_power(ctx)));\n}\n\nstatic int test_closure(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_map *map, *map2;\n\tisl_bool exact, equal;\n\n\t/* COCOA example 1 */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : i2 = i + 1 and j2 = j + 1 and \"\n\t\t\t\"1 <= i and i < n and 1 <= j and j < n or \"\n\t\t\t\"i2 = i + 1 and j2 = j - 1 and \"\n\t\t\t\"1 <= i and i < n and 2 <= j and j <= n }\");\n\tmap = isl_map_power(map, &exact);\n\tassert(exact);\n\tisl_map_free(map);\n\n\t/* COCOA example 1 */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : i2 = i + 1 and j2 = j + 1 and \"\n\t\t\t\"1 <= i and i < n and 1 <= j and j < n or \"\n\t\t\t\"i2 = i + 1 and j2 = j - 1 and \"\n\t\t\t\"1 <= i and i < n and 2 <= j and j <= n }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tmap2 = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : exists (k1,k2,k : \"\n\t\t\t\"1 <= i and i < n and 1 <= j and j <= n and \"\n\t\t\t\"2 <= i2 and i2 <= n and 1 <= j2 and j2 <= n and \"\n\t\t\t\"i2 = i + k1 + k2 and j2 = j + k1 - k2 and \"\n\t\t\t\"k1 >= 0 and k2 >= 0 and k1 + k2 = k and k >= 1 )}\");\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map2);\n\tisl_map_free(map);\n\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [x] -> [y] : y = x + 1 and 0 <= x and x <= n and \"\n\t\t\t\t     \" 0 <= y and y <= n }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tmap2 = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [x] -> [y] : y > x and 0 <= x and x <= n and \"\n\t\t\t\t     \" 0 <= y and y <= n }\");\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map2);\n\tisl_map_free(map);\n\n\t/* COCOA example 2 */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : i2 = i + 2 and j2 = j + 2 and \"\n\t\t\t\"1 <= i and i < n - 1 and 1 <= j and j < n - 1 or \"\n\t\t\t\"i2 = i + 2 and j2 = j - 2 and \"\n\t\t\t\"1 <= i and i < n - 1 and 3 <= j and j <= n }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tmap2 = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : exists (k1,k2,k : \"\n\t\t\t\"1 <= i and i < n - 1 and 1 <= j and j <= n and \"\n\t\t\t\"3 <= i2 and i2 <= n and 1 <= j2 and j2 <= n and \"\n\t\t\t\"i2 = i + 2 k1 + 2 k2 and j2 = j + 2 k1 - 2 k2 and \"\n\t\t\t\"k1 >= 0 and k2 >= 0 and k1 + k2 = k and k >= 1) }\");\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map);\n\tisl_map_free(map2);\n\n\t/* COCOA Fig.2 left */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : i2 = i + 2 and j2 = j and \"\n\t\t\t\"i <= 2 j - 3 and i <= n - 2 and j <= 2 i - 1 and \"\n\t\t\t\"j <= n or \"\n\t\t\t\"i2 = i and j2 = j + 2 and i <= 2 j - 1 and i <= n and \"\n\t\t\t\"j <= 2 i - 3 and j <= n - 2 or \"\n\t\t\t\"i2 = i + 1 and j2 = j + 1 and i <= 2 j - 1 and \"\n\t\t\t\"i <= n - 1 and j <= 2 i - 1 and j <= n - 1 }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tisl_map_free(map);\n\n\t/* COCOA Fig.2 right */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : i2 = i + 3 and j2 = j and \"\n\t\t\t\"i <= 2 j - 4 and i <= n - 3 and j <= 2 i - 1 and \"\n\t\t\t\"j <= n or \"\n\t\t\t\"i2 = i and j2 = j + 3 and i <= 2 j - 1 and i <= n and \"\n\t\t\t\"j <= 2 i - 4 and j <= n - 3 or \"\n\t\t\t\"i2 = i + 1 and j2 = j + 1 and i <= 2 j - 1 and \"\n\t\t\t\"i <= n - 1 and j <= 2 i - 1 and j <= n - 1 }\");\n\tmap = isl_map_power(map, &exact);\n\tassert(exact);\n\tisl_map_free(map);\n\n\t/* COCOA Fig.2 right */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : i2 = i + 3 and j2 = j and \"\n\t\t\t\"i <= 2 j - 4 and i <= n - 3 and j <= 2 i - 1 and \"\n\t\t\t\"j <= n or \"\n\t\t\t\"i2 = i and j2 = j + 3 and i <= 2 j - 1 and i <= n and \"\n\t\t\t\"j <= 2 i - 4 and j <= n - 3 or \"\n\t\t\t\"i2 = i + 1 and j2 = j + 1 and i <= 2 j - 1 and \"\n\t\t\t\"i <= n - 1 and j <= 2 i - 1 and j <= n - 1 }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tmap2 = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : exists (k1,k2,k3,k : \"\n\t\t\t\"i <= 2 j - 1 and i <= n and j <= 2 i - 1 and \"\n\t\t\t\"j <= n and 3 + i + 2 j <= 3 n and \"\n\t\t\t\"3 + 2 i + j <= 3n and i2 <= 2 j2 -1 and i2 <= n and \"\n\t\t\t\"i2 <= 3 j2 - 4 and j2 <= 2 i2 -1 and j2 <= n and \"\n\t\t\t\"13 + 4 j2 <= 11 i2 and i2 = i + 3 k1 + k3 and \"\n\t\t\t\"j2 = j + 3 k2 + k3 and k1 >= 0 and k2 >= 0 and \"\n\t\t\t\"k3 >= 0 and k1 + k2 + k3 = k and k > 0) }\");\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map2);\n\tisl_map_free(map);\n\n\tmap = cocoa_fig_1_right_graph(ctx);\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tmap2 = cocoa_fig_1_right_tc(ctx);\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map2);\n\tisl_map_free(map);\n\n\tmap = cocoa_fig_1_right_graph(ctx);\n\tmap = isl_map_power(map, &exact);\n\tmap2 = cocoa_fig_1_right_power(ctx);\n\tequal = isl_map_is_equal(map, map2);\n\tisl_map_free(map2);\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!exact)\n\t\tisl_die(ctx, isl_error_unknown, \"power not exact\", return -1);\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected power\", return -1);\n\n\t/* COCOA Theorem 1 counter example */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"{ [i,j] -> [i2,j2] : i = 0 and 0 <= j and j <= 1 and \"\n\t\t\t\"i2 = 1 and j2 = j or \"\n\t\t\t\"i = 0 and j = 0 and i2 = 0 and j2 = 1 }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tisl_map_free(map);\n\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[m,n] -> { [i,j] -> [i2,j2] : i2 = i and j2 = j + 2 and \"\n\t\t\t\"1 <= i,i2 <= n and 1 <= j,j2 <= m or \"\n\t\t\t\"i2 = i + 1 and 3 <= j2 - j <= 4 and \"\n\t\t\t\"1 <= i,i2 <= n and 1 <= j,j2 <= m }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tisl_map_free(map);\n\n\t/* Kelly et al 1996, fig 12 */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : i2 = i and j2 = j + 1 and \"\n\t\t\t\"1 <= i,j,j+1 <= n or \"\n\t\t\t\"j = n and j2 = 1 and i2 = i + 1 and \"\n\t\t\t\"1 <= i,i+1 <= n }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tmap2 = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [i,j] -> [i2,j2] : 1 <= j < j2 <= n and \"\n\t\t\t\"1 <= i <= n and i = i2 or \"\n\t\t\t\"1 <= i < i2 <= n and 1 <= j <= n and \"\n\t\t\t\"1 <= j2 <= n }\");\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map2);\n\tisl_map_free(map);\n\n\t/* Omega's closure4 */\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[m,n] -> { [x,y] -> [x2,y2] : x2 = x and y2 = y + 1 and \"\n\t\t\t\"1 <= x,y <= 10 or \"\n\t\t\t\"x2 = x + 1 and y2 = y and \"\n\t\t\t\"1 <= x <= 20 && 5 <= y <= 15 }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tisl_map_free(map);\n\n\tmap = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [x] -> [y]: 1 <= n <= y - x <= 10 }\");\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(!exact);\n\tmap2 = isl_map_read_from_str(ctx,\n\t\t\"[n] -> { [x] -> [y] : 1 <= n <= 10 and y >= n + x }\");\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map);\n\tisl_map_free(map2);\n\n\tstr = \"[n, m] -> { [i0, i1, i2, i3] -> [o0, o1, o2, o3] : \"\n\t    \"i3 = 1 and o0 = i0 and o1 = -1 + i1 and o2 = -1 + i2 and \"\n\t    \"o3 = -2 + i2 and i1 <= -1 + i0 and i1 >= 1 - m + i0 and \"\n\t    \"i1 >= 2 and i1 <= n and i2 >= 3 and i2 <= 1 + n and i2 <= m }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tmap2 = isl_map_read_from_str(ctx, str);\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map);\n\tisl_map_free(map2);\n\n\tstr = \"{[0] -> [1]; [2] -> [3]}\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_transitive_closure(map, &exact);\n\tassert(exact);\n\tmap2 = isl_map_read_from_str(ctx, str);\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map);\n\tisl_map_free(map2);\n\n\tstr = \"[n] -> { [[i0, i1, 1, 0, i0] -> [i5, 1]] -> \"\n\t    \"[[i0, -1 + i1, 2, 0, i0] -> [-1 + i5, 2]] : \"\n\t    \"exists (e0 = [(3 - n)/3]: i5 >= 2 and i1 >= 2 and \"\n\t    \"3i0 <= -1 + n and i1 <= -1 + n and i5 <= -1 + n and \"\n\t    \"3e0 >= 1 - n and 3e0 <= 2 - n and 3i0 >= -2 + n); \"\n\t    \"[[i0, i1, 2, 0, i0] -> [i5, 1]] -> \"\n\t    \"[[i0, i1, 1, 0, i0] -> [-1 + i5, 2]] : \"\n\t    \"exists (e0 = [(3 - n)/3]: i5 >= 2 and i1 >= 1 and \"\n\t    \"3i0 <= -1 + n and i1 <= -1 + n and i5 <= -1 + n and \"\n\t    \"3e0 >= 1 - n and 3e0 <= 2 - n and 3i0 >= -2 + n); \"\n\t    \"[[i0, i1, 1, 0, i0] -> [i5, 2]] -> \"\n\t    \"[[i0, -1 + i1, 2, 0, i0] -> [i5, 1]] : \"\n\t    \"exists (e0 = [(3 - n)/3]: i1 >= 2 and i5 >= 1 and \"\n\t    \"3i0 <= -1 + n and i1 <= -1 + n and i5 <= -1 + n and \"\n\t    \"3e0 >= 1 - n and 3e0 <= 2 - n and 3i0 >= -2 + n); \"\n\t    \"[[i0, i1, 2, 0, i0] -> [i5, 2]] -> \"\n\t    \"[[i0, i1, 1, 0, i0] -> [i5, 1]] : \"\n\t    \"exists (e0 = [(3 - n)/3]: i5 >= 1 and i1 >= 1 and \"\n\t    \"3i0 <= -1 + n and i1 <= -1 + n and i5 <= -1 + n and \"\n\t    \"3e0 >= 1 - n and 3e0 <= 2 - n and 3i0 >= -2 + n) }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_transitive_closure(map, NULL);\n\tassert(map);\n\tisl_map_free(map);\n\n\treturn 0;\n}\n\n/* Check that the actual result of a boolean operation is equal\n * to the expected result.\n */\nstatic isl_stat check_bool(isl_ctx *ctx, isl_bool actual, isl_bool expected)\n{\n\tif (actual != expected)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"incorrect boolean operation\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Test operations on isl_bool values.\n *\n * This tests:\n *\n * \tisl_bool_not\n * \tisl_bool_ok\n */\nstatic int test_isl_bool(isl_ctx *ctx)\n{\n\tif (check_bool(ctx, isl_bool_not(isl_bool_true), isl_bool_false) < 0)\n\t\treturn -1;\n\tif (check_bool(ctx, isl_bool_not(isl_bool_false), isl_bool_true) < 0)\n\t\treturn -1;\n\tif (check_bool(ctx, isl_bool_not(isl_bool_error), isl_bool_error) < 0)\n\t\treturn -1;\n\tif (check_bool(ctx, isl_bool_ok(0), isl_bool_false) < 0)\n\t\treturn -1;\n\tif (check_bool(ctx, isl_bool_ok(1), isl_bool_true) < 0)\n\t\treturn -1;\n\tif (check_bool(ctx, isl_bool_ok(-1), isl_bool_true) < 0)\n\t\treturn -1;\n\tif (check_bool(ctx, isl_bool_ok(2), isl_bool_true) < 0)\n\t\treturn -1;\n\tif (check_bool(ctx, isl_bool_ok(-2), isl_bool_true) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int test_lex(struct isl_ctx *ctx)\n{\n\tisl_space *space;\n\tisl_map *map;\n\tint empty;\n\n\tspace = isl_space_set_alloc(ctx, 0, 0);\n\tmap = isl_map_lex_le(space);\n\tempty = isl_map_is_empty(map);\n\tisl_map_free(map);\n\n\tif (empty < 0)\n\t\treturn -1;\n\tif (empty)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"expecting non-empty result\", return -1);\n\n\treturn 0;\n}\n\n/* Inputs for isl_map_lexmin tests.\n * \"map\" is the input and \"lexmin\" is the expected result.\n */\nstruct {\n\tconst char *map;\n\tconst char *lexmin;\n} lexmin_tests [] = {\n\t{ \"{ [x] -> [y] : x <= y <= 10; [x] -> [5] : -8 <= x <= 8 }\",\n\t  \"{ [x] -> [5] : 6 <= x <= 8; \"\n\t    \"[x] -> [x] : x <= 5 or (9 <= x <= 10) }\" },\n\t{ \"{ [x] -> [y] : 4y = x or 4y = -1 + x or 4y = -2 + x }\",\n\t  \"{ [x] -> [y] : 4y = x or 4y = -1 + x or 4y = -2 + x }\" },\n\t{ \"{ [x] -> [y] : x = 4y; [x] -> [y] : x = 2y }\",\n\t  \"{ [x] -> [y] : (4y = x and x >= 0) or \"\n\t\t\"(exists (e0 = [(x)/4], e1 = [(-2 + x)/4]: 2y = x and \"\n\t\t\"4e1 = -2 + x and 4e0 <= -1 + x and 4e0 >= -3 + x)) or \"\n\t\t\"(exists (e0 = [(x)/4]: 2y = x and 4e0 = x and x <= -4)) }\" },\n\t{ \"{ T[a] -> S[b, c] : a = 4b-2c and c >= b }\",\n\t  \"{ T[a] -> S[b, c] : 2b = a and 2c = a }\" },\n\t/* Check that empty pieces are properly combined. */\n\t{ \"[K, N] -> { [x, y] -> [a, b] : K+2<=N<=K+4 and x>=4 and \"\n\t\t\"2N-6<=x<K+N and N-1<=a<=K+N-1 and N+b-6<=a<=2N-4 and \"\n\t\t\"b<=2N-3K+a and 3b<=4N-K+1 and b>=N and a>=x+1 }\",\n\t  \"[K, N] -> { [x, y] -> [1 + x, N] : x >= -6 + 2N and \"\n\t\t\"x <= -5 + 2N and x >= -1 + 3K - N and x <= -2 + K + N and \"\n\t\t\"x >= 4 }\" },\n\t{ \"{ [i, k, j] -> [a, b, c, d] : 8*floor((b)/8) = b and k <= 255 and \"\n\t\t\"a <= 255 and c <= 255 and d <= 255 - j and \"\n\t\t\"255 - j <= 7d <= 7 - i and 240d <= 239 + a and \"\n\t\t\"247d <= 247 + k - j and 247d <= 247 + k - b and \"\n\t\t\"247d <= 247 + i and 248 - b <= 248d <= c and \"\n\t\t\"254d >= i - a + b and 254d >= -a + b and \"\n\t\t\"255d >= -i + a - b and 1792d >= -63736 + 257b }\",\n\t  \"{ [i, k, j] -> \"\n\t    \"[-127762 + i + 502j, -62992 + 248j, 63240 - 248j, 255 - j] : \"\n\t\t\"k <= 255 and 7j >= 1778 + i and 246j >= 62738 - k and \"\n\t\t\"247j >= 62738 - i and 509j <= 129795 + i and \"\n\t\t\"742j >= 188724 - i; \"\n\t    \"[0, k, j] -> [1, 0, 248, 1] : k <= 255 and 248 <= j <= 254, k }\" },\n\t{ \"{ [a] -> [b] : 0 <= b <= 255 and -509 + a <= 512b < a and \"\n\t\t\t\"16*floor((8 + b)/16) <= 7 + b; \"\n\t    \"[a] -> [1] }\",\n\t  \"{ [a] -> [b = 1] : a >= 510 or a <= 0; \"\n\t    \"[a] -> [b = 0] : 0 < a <= 509 }\" },\n\t{ \"{ rat: [i] : 1 <= 2i <= 9 }\", \"{ rat: [i] : 2i = 1 }\" },\n\t{ \"{ rat: [i] : 1 <= 2i <= 9 or i >= 10 }\", \"{ rat: [i] : 2i = 1 }\" },\n\t{ \"{ rat: [i] : 21 <= 2i <= 29 or i = 5 }\", \"{ rat: [5] }\" },\n};\n\nstatic int test_lexmin(struct isl_ctx *ctx)\n{\n\tint i;\n\tint equal;\n\tconst char *str;\n\tisl_basic_map *bmap;\n\tisl_map *map, *map2;\n\tisl_set *set;\n\tisl_set *set2;\n\tisl_pw_multi_aff *pma;\n\n\tstr = \"[p0, p1] -> { [] -> [] : \"\n\t    \"exists (e0 = [(2p1)/3], e1, e2, e3 = [(3 - p1 + 3e0)/3], \"\n\t    \"e4 = [(p1)/3], e5 = [(p1 + 3e4)/3]: \"\n\t    \"3e0 >= -2 + 2p1 and 3e0 >= p1 and 3e3 >= 1 - p1 + 3e0 and \"\n\t    \"3e0 <= 2p1 and 3e3 >= -2 + p1 and 3e3 <= -1 + p1 and p1 >= 3 and \"\n\t    \"3e5 >= -2 + 2p1 and 3e5 >= p1 and 3e5 <= -1 + p1 + 3e4 and \"\n\t    \"3e4 <= p1 and 3e4 >= -2 + p1 and e3 <= -1 + e0 and \"\n\t    \"3e4 >= 6 - p1 + 3e1 and 3e1 >= p1 and 3e5 >= -2 + p1 + 3e4 and \"\n\t    \"2e4 >= 3 - p1 + 2e1 and e4 <= e1 and 3e3 <= 2 - p1 + 3e0 and \"\n\t    \"e5 >= 1 + e1 and 3e4 >= 6 - 2p1 + 3e1 and \"\n\t    \"p0 >= 2 and p1 >= p0 and 3e2 >= p1 and 3e4 >= 6 - p1 + 3e2 and \"\n\t    \"e2 <= e1 and e3 >= 1 and e4 <= e2) }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_lexmin(map);\n\tisl_map_free(map);\n\tif (!map)\n\t\treturn -1;\n\n\tstr = \"[C] -> { [obj,a,b,c] : obj <= 38 a + 7 b + 10 c and \"\n\t    \"a + b <= 1 and c <= 10 b and c <= C and a,b,c,C >= 0 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tset = isl_set_lexmax(set);\n\tstr = \"[C] -> { [obj,a,b,c] : C = 8 }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tset = isl_set_intersect(set, set2);\n\tassert(!isl_set_is_empty(set));\n\tisl_set_free(set);\n\n\tfor (i = 0; i < ARRAY_SIZE(lexmin_tests); ++i) {\n\t\tmap = isl_map_read_from_str(ctx, lexmin_tests[i].map);\n\t\tmap = isl_map_lexmin(map);\n\t\tmap2 = isl_map_read_from_str(ctx, lexmin_tests[i].lexmin);\n\t\tequal = isl_map_is_equal(map, map2);\n\t\tisl_map_free(map);\n\t\tisl_map_free(map2);\n\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\tstr = \"{ [i] -> [i', j] : j = i - 8i' and i' >= 0 and i' <= 7 and \"\n\t\t\t\t\" 8i' <= i and 8i' >= -7 + i }\";\n\tbmap = isl_basic_map_read_from_str(ctx, str);\n\tpma = isl_basic_map_lexmin_pw_multi_aff(isl_basic_map_copy(bmap));\n\tmap2 = isl_map_from_pw_multi_aff(pma);\n\tmap = isl_map_from_basic_map(bmap);\n\tassert(isl_map_is_equal(map, map2));\n\tisl_map_free(map);\n\tisl_map_free(map2);\n\n\tstr = \"[i] -> { [i', j] : j = i - 8i' and i' >= 0 and i' <= 7 and \"\n\t\t\t\t\" 8i' <= i and 8i' >= -7 + i }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpma = isl_set_lexmin_pw_multi_aff(isl_set_copy(set));\n\tset2 = isl_set_from_pw_multi_aff(pma);\n\tequal = isl_set_is_equal(set, set2);\n\tisl_set_free(set);\n\tisl_set_free(set2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected difference between set and \"\n\t\t\t\"piecewise affine expression\", return -1);\n\n\treturn 0;\n}\n\n/* Inputs for isl_pw_multi_aff_max_multi_val tests.\n * \"pma\" is the input.\n * \"res\" is the expected result.\n */\nstatic struct {\n\tconst char *pma;\n\tconst char *res;\n} opt_pw_tests[] = {\n\t{ \"{ [-1] -> [-1]; [1] -> [1] }\", \"{ [1] }\" },\n\t{ \"{ [a, b] -> [floor((b - 2*floor((-a)/4))/5)] : \"\n\t    \"0 <= a, b <= 100 and b mod 2 = 0}\", \"{ [30] }\" },\n\t{ \"[N] -> { [i,j] -> A[i, -i, i + j] : 0 <= i,j <= N <= 10 }\",\n\t  \"{ A[10, 0, 20] }\" },\n\t{ \"[N] -> {A[N, -N, 2N] : 0 <= N }\", \"{ A[infty, 0, infty] }\" },\n};\n\n/* Perform basic isl_pw_multi_aff_max_multi_val tests.\n */\nstatic isl_stat test_pw_max(struct isl_ctx *ctx)\n{\n\tint i;\n\tisl_pw_multi_aff *pma;\n\tisl_multi_val *mv;\n\tisl_stat r;\n\n\tfor (i = 0; i < ARRAY_SIZE(opt_pw_tests); ++i) {\n\t\tpma = isl_pw_multi_aff_read_from_str(ctx, opt_pw_tests[i].pma);\n\t\tmv = isl_pw_multi_aff_max_multi_val(pma);\n\t\tr = multi_val_check_plain_equal(mv, opt_pw_tests[i].res);\n\t\tisl_multi_val_free(mv);\n\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* A specialized isl_set_min_val test case that would return the wrong result\n * in earlier versions of isl.\n * The explicit call to isl_basic_set_union prevents the second basic set\n * from being determined to be empty prior to the call to isl_set_min_val,\n * at least at the point where this test case was introduced.\n */\nstatic int test_min_special(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset1, *bset2;\n\tisl_set *set;\n\tisl_aff *obj;\n\tisl_val *res;\n\tint ok;\n\n\tstr = \"{ [a, b] : a >= 2 and b >= 0 and 14 - a <= b <= 9 }\";\n\tbset1 = isl_basic_set_read_from_str(ctx, str);\n\tstr = \"{ [a, b] : 1 <= a, b and a + b <= 1 }\";\n\tbset2 = isl_basic_set_read_from_str(ctx, str);\n\tset = isl_basic_set_union(bset1, bset2);\n\tobj = isl_aff_read_from_str(ctx, \"{ [a, b] -> [a] }\");\n\n\tres = isl_set_min_val(set, obj);\n\tok = isl_val_cmp_si(res, 5) == 0;\n\n\tisl_aff_free(obj);\n\tisl_set_free(set);\n\tisl_val_free(res);\n\n\tif (!res)\n\t\treturn -1;\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected minimum\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* A specialized isl_set_min_val test case that would return an error\n * in earlier versions of isl.\n */\nstatic int test_min_special2(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset;\n\tisl_aff *obj;\n\tisl_val *res;\n\n\tstr = \"{ [i, j, k] : 2j = i and 2k = i + 1 and i >= 2 }\";\n\tbset = isl_basic_set_read_from_str(ctx, str);\n\n\tobj = isl_aff_read_from_str(ctx, \"{ [i, j, k] -> [i] }\");\n\n\tres = isl_basic_set_max_val(bset, obj);\n\n\tisl_basic_set_free(bset);\n\tisl_aff_free(obj);\n\tisl_val_free(res);\n\n\tif (!res)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that the result of isl_set_min_multi_pw_aff\n * on the union of the sets with string descriptions \"s1\" and \"s2\"\n * consists of a single expression (on a single cell).\n */\nstatic isl_stat check_single_expr_min(isl_ctx *ctx, const char *s1,\n\tconst char *s2)\n{\n\tisl_size n;\n\tisl_set *set1, *set2;\n\tisl_multi_pw_aff *mpa;\n\tisl_pw_multi_aff *pma;\n\n\tset1 = isl_set_read_from_str(ctx, s1);\n\tset2 = isl_set_read_from_str(ctx, s2);\n\tset1 = isl_set_union(set1, set2);\n\tmpa = isl_set_min_multi_pw_aff(set1);\n\tpma = isl_pw_multi_aff_from_multi_pw_aff(mpa);\n\tn = isl_pw_multi_aff_n_piece(pma);\n\tisl_pw_multi_aff_free(pma);\n\n\tif (n < 0)\n\t\treturn isl_stat_error;\n\tif (n != 1)\n\t\tisl_die(ctx, isl_error_unknown, \"expecting single expression\",\n\t\t\treturn isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* A specialized isl_set_min_multi_pw_aff test that checks\n * that the minimum of 2N and 3N for N >= 0 is represented\n * by a single expression, without splitting off the special case N = 0.\n * Do this for both orderings.\n */\nstatic int test_min_mpa(isl_ctx *ctx)\n{\n\tconst char *s1, *s2;\n\n\ts1 = \"[N=0:] -> { [1, 3N:] }\";\n\ts2 = \"[N=0:] -> { [10, 2N:] }\";\n\tif (check_single_expr_min(ctx, s1, s2) < 0)\n\t\treturn -1;\n\tif (check_single_expr_min(ctx, s2, s1) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct {\n\tconst char *set;\n\tconst char *obj;\n\t__isl_give isl_val *(*fn)(__isl_keep isl_set *set,\n\t\t__isl_keep isl_aff *obj);\n\tconst char *res;\n} opt_tests[] = {\n\t{ \"{ [-1]; [1] }\", \"{ [x] -> [x] }\", &isl_set_min_val, \"-1\" },\n\t{ \"{ [-1]; [1] }\", \"{ [x] -> [x] }\", &isl_set_max_val, \"1\" },\n\t{ \"{ [a, b] : 0 <= a, b <= 100 and b mod 2 = 0}\",\n\t  \"{ [a, b] -> [floor((b - 2*floor((-a)/4))/5)] }\",\n\t  &isl_set_max_val, \"30\" },\n\n};\n\n/* Perform basic isl_set_min_val and isl_set_max_val tests.\n * In particular, check the results on non-convex inputs.\n */\nstatic int test_min(struct isl_ctx *ctx)\n{\n\tint i;\n\tisl_set *set;\n\tisl_aff *obj;\n\tisl_val *val, *res;\n\tisl_bool ok;\n\n\tfor (i = 0; i < ARRAY_SIZE(opt_tests); ++i) {\n\t\tset = isl_set_read_from_str(ctx, opt_tests[i].set);\n\t\tobj = isl_aff_read_from_str(ctx, opt_tests[i].obj);\n\t\tres = isl_val_read_from_str(ctx, opt_tests[i].res);\n\t\tval = opt_tests[i].fn(set, obj);\n\t\tok = isl_val_eq(res, val);\n\t\tisl_val_free(res);\n\t\tisl_val_free(val);\n\t\tisl_aff_free(obj);\n\t\tisl_set_free(set);\n\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected optimum\", return -1);\n\t}\n\n\tif (test_pw_max(ctx) < 0)\n\t\treturn -1;\n\tif (test_min_special(ctx) < 0)\n\t\treturn -1;\n\tif (test_min_special2(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct must_may {\n\tisl_map *must;\n\tisl_map *may;\n};\n\nstatic isl_stat collect_must_may(__isl_take isl_map *dep, int must,\n\tvoid *dep_user, void *user)\n{\n\tstruct must_may *mm = (struct must_may *)user;\n\n\tif (must)\n\t\tmm->must = isl_map_union(mm->must, dep);\n\telse\n\t\tmm->may = isl_map_union(mm->may, dep);\n\n\treturn isl_stat_ok;\n}\n\nstatic int common_space(void *first, void *second)\n{\n\tint depth = *(int *)first;\n\treturn 2 * depth;\n}\n\nstatic int map_is_equal(__isl_keep isl_map *map, const char *str)\n{\n\tisl_map *map2;\n\tint equal;\n\n\tif (!map)\n\t\treturn -1;\n\n\tmap2 = isl_map_read_from_str(map->ctx, str);\n\tequal = isl_map_is_equal(map, map2);\n\tisl_map_free(map2);\n\n\treturn equal;\n}\n\nstatic int map_check_equal(__isl_keep isl_map *map, const char *str)\n{\n\tint equal;\n\n\tequal = map_is_equal(map, str);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(isl_map_get_ctx(map), isl_error_unknown,\n\t\t\t\"result not as expected\", return -1);\n\treturn 0;\n}\n\n/* Is \"set\" equal to the set described by \"str\"?\n */\nstatic isl_bool set_is_equal(__isl_keep isl_set *set, const char *str)\n{\n\tisl_set *set2;\n\tisl_bool equal;\n\n\tif (!set)\n\t\treturn isl_bool_error;\n\n\tset2 = isl_set_read_from_str(isl_set_get_ctx(set), str);\n\tequal = isl_set_is_equal(set, set2);\n\tisl_set_free(set2);\n\n\treturn equal;\n}\n\n/* Check that \"set\" is equal to the set described by \"str\".\n */\nstatic isl_stat set_check_equal(__isl_keep isl_set *set, const char *str)\n{\n\tisl_bool equal;\n\n\tequal = set_is_equal(set, str);\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(isl_set_get_ctx(set), isl_error_unknown,\n\t\t\t\"result not as expected\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Is \"uset\" equal to the union set described by \"str\"?\n */\nstatic isl_bool uset_is_equal(__isl_keep isl_union_set *uset, const char *str)\n{\n\tisl_union_set *uset2;\n\tisl_bool equal;\n\n\tif (!uset)\n\t\treturn isl_bool_error;\n\n\tuset2 = isl_union_set_read_from_str(isl_union_set_get_ctx(uset), str);\n\tequal = isl_union_set_is_equal(uset, uset2);\n\tisl_union_set_free(uset2);\n\n\treturn equal;\n}\n\n/* Check that \"uset\" is equal to the union set described by \"str\".\n */\nstatic isl_stat uset_check_equal(__isl_keep isl_union_set *uset,\n\tconst char *str)\n{\n\tisl_bool equal;\n\n\tequal = uset_is_equal(uset, str);\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(isl_union_set_get_ctx(uset), isl_error_unknown,\n\t\t\t\"result not as expected\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\nstatic int test_dep(struct isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_space *space;\n\tisl_map *map;\n\tisl_access_info *ai;\n\tisl_flow *flow;\n\tint depth;\n\tstruct must_may mm;\n\n\tdepth = 3;\n\n\tstr = \"{ [2,i,0] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_alloc(map, &depth, &common_space, 2);\n\n\tstr = \"{ [0,i,0] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 1, &depth);\n\n\tstr = \"{ [1,i,0] -> [5] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 1, &depth);\n\n\tflow = isl_access_info_compute_flow(ai);\n\tspace = isl_space_alloc(ctx, 0, 3, 3);\n\tmm.must = isl_map_empty(isl_space_copy(space));\n\tmm.may = isl_map_empty(space);\n\n\tisl_flow_foreach(flow, collect_must_may, &mm);\n\n\tstr = \"{ [0,i,0] -> [2,i,0] : (0 <= i <= 4) or (6 <= i <= 10); \"\n\t      \"  [1,10,0] -> [2,5,0] }\";\n\tassert(map_is_equal(mm.must, str));\n\tstr = \"{ [i,j,k] -> [l,m,n] : 1 = 0 }\";\n\tassert(map_is_equal(mm.may, str));\n\n\tisl_map_free(mm.must);\n\tisl_map_free(mm.may);\n\tisl_flow_free(flow);\n\n\n\tstr = \"{ [2,i,0] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_alloc(map, &depth, &common_space, 2);\n\n\tstr = \"{ [0,i,0] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 1, &depth);\n\n\tstr = \"{ [1,i,0] -> [5] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 0, &depth);\n\n\tflow = isl_access_info_compute_flow(ai);\n\tspace = isl_space_alloc(ctx, 0, 3, 3);\n\tmm.must = isl_map_empty(isl_space_copy(space));\n\tmm.may = isl_map_empty(space);\n\n\tisl_flow_foreach(flow, collect_must_may, &mm);\n\n\tstr = \"{ [0,i,0] -> [2,i,0] : (0 <= i <= 4) or (6 <= i <= 10) }\";\n\tassert(map_is_equal(mm.must, str));\n\tstr = \"{ [0,5,0] -> [2,5,0]; [1,i,0] -> [2,5,0] : 0 <= i <= 10 }\";\n\tassert(map_is_equal(mm.may, str));\n\n\tisl_map_free(mm.must);\n\tisl_map_free(mm.may);\n\tisl_flow_free(flow);\n\n\n\tstr = \"{ [2,i,0] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_alloc(map, &depth, &common_space, 2);\n\n\tstr = \"{ [0,i,0] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 0, &depth);\n\n\tstr = \"{ [1,i,0] -> [5] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 0, &depth);\n\n\tflow = isl_access_info_compute_flow(ai);\n\tspace = isl_space_alloc(ctx, 0, 3, 3);\n\tmm.must = isl_map_empty(isl_space_copy(space));\n\tmm.may = isl_map_empty(space);\n\n\tisl_flow_foreach(flow, collect_must_may, &mm);\n\n\tstr = \"{ [0,i,0] -> [2,i,0] : 0 <= i <= 10; \"\n\t      \"  [1,i,0] -> [2,5,0] : 0 <= i <= 10 }\";\n\tassert(map_is_equal(mm.may, str));\n\tstr = \"{ [i,j,k] -> [l,m,n] : 1 = 0 }\";\n\tassert(map_is_equal(mm.must, str));\n\n\tisl_map_free(mm.must);\n\tisl_map_free(mm.may);\n\tisl_flow_free(flow);\n\n\n\tstr = \"{ [0,i,2] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_alloc(map, &depth, &common_space, 2);\n\n\tstr = \"{ [0,i,0] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 0, &depth);\n\n\tstr = \"{ [0,i,1] -> [5] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 0, &depth);\n\n\tflow = isl_access_info_compute_flow(ai);\n\tspace = isl_space_alloc(ctx, 0, 3, 3);\n\tmm.must = isl_map_empty(isl_space_copy(space));\n\tmm.may = isl_map_empty(space);\n\n\tisl_flow_foreach(flow, collect_must_may, &mm);\n\n\tstr = \"{ [0,i,0] -> [0,i,2] : 0 <= i <= 10; \"\n\t      \"  [0,i,1] -> [0,5,2] : 0 <= i <= 5 }\";\n\tassert(map_is_equal(mm.may, str));\n\tstr = \"{ [i,j,k] -> [l,m,n] : 1 = 0 }\";\n\tassert(map_is_equal(mm.must, str));\n\n\tisl_map_free(mm.must);\n\tisl_map_free(mm.may);\n\tisl_flow_free(flow);\n\n\n\tstr = \"{ [0,i,1] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_alloc(map, &depth, &common_space, 2);\n\n\tstr = \"{ [0,i,0] -> [i] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 0, &depth);\n\n\tstr = \"{ [0,i,2] -> [5] : 0 <= i <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 0, &depth);\n\n\tflow = isl_access_info_compute_flow(ai);\n\tspace = isl_space_alloc(ctx, 0, 3, 3);\n\tmm.must = isl_map_empty(isl_space_copy(space));\n\tmm.may = isl_map_empty(space);\n\n\tisl_flow_foreach(flow, collect_must_may, &mm);\n\n\tstr = \"{ [0,i,0] -> [0,i,1] : 0 <= i <= 10; \"\n\t      \"  [0,i,2] -> [0,5,1] : 0 <= i <= 4 }\";\n\tassert(map_is_equal(mm.may, str));\n\tstr = \"{ [i,j,k] -> [l,m,n] : 1 = 0 }\";\n\tassert(map_is_equal(mm.must, str));\n\n\tisl_map_free(mm.must);\n\tisl_map_free(mm.may);\n\tisl_flow_free(flow);\n\n\n\tdepth = 5;\n\n\tstr = \"{ [1,i,0,0,0] -> [i,j] : 0 <= i <= 10 and 0 <= j <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_alloc(map, &depth, &common_space, 1);\n\n\tstr = \"{ [0,i,0,j,0] -> [i,j] : 0 <= i <= 10 and 0 <= j <= 10 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tai = isl_access_info_add_source(ai, map, 1, &depth);\n\n\tflow = isl_access_info_compute_flow(ai);\n\tspace = isl_space_alloc(ctx, 0, 5, 5);\n\tmm.must = isl_map_empty(isl_space_copy(space));\n\tmm.may = isl_map_empty(space);\n\n\tisl_flow_foreach(flow, collect_must_may, &mm);\n\n\tstr = \"{ [0,i,0,j,0] -> [1,i,0,0,0] : 0 <= i,j <= 10 }\";\n\tassert(map_is_equal(mm.must, str));\n\tstr = \"{ [0,0,0,0,0] -> [0,0,0,0,0] : 1 = 0 }\";\n\tassert(map_is_equal(mm.may, str));\n\n\tisl_map_free(mm.must);\n\tisl_map_free(mm.may);\n\tisl_flow_free(flow);\n\n\treturn 0;\n}\n\n/* Check that the dependence analysis proceeds without errors.\n * Earlier versions of isl would break down during the analysis\n * due to the use of the wrong spaces.\n */\nstatic int test_flow(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_union_map *access, *schedule;\n\tisl_union_map *must_dep, *may_dep;\n\tint r;\n\n\tstr = \"{ S0[j] -> i[]; S1[j,i] -> i[]; S2[] -> i[]; S3[] -> i[] }\";\n\taccess = isl_union_map_read_from_str(ctx, str);\n\tstr = \"{ S0[j] -> [0,j,0,0] : 0 <= j < 10; \"\n\t\t\"S1[j,i] -> [0,j,1,i] : 0 <= j < i < 10; \"\n\t\t\"S2[] -> [1,0,0,0]; \"\n\t\t\"S3[] -> [-1,0,0,0] }\";\n\tschedule = isl_union_map_read_from_str(ctx, str);\n\tr = isl_union_map_compute_flow(access, isl_union_map_copy(access),\n\t\t\t\t\tisl_union_map_copy(access), schedule,\n\t\t\t\t\t&must_dep, &may_dep, NULL, NULL);\n\tisl_union_map_free(may_dep);\n\tisl_union_map_free(must_dep);\n\n\treturn r;\n}\n\nstruct {\n\tconst char *map;\n\tint sv;\n} sv_tests[] = {\n\t{ \"[N] -> { [i] -> [f] : 0 <= i <= N and 0 <= i - 10 f <= 9 }\", 1 },\n\t{ \"[N] -> { [i] -> [f] : 0 <= i <= N and 0 <= i - 10 f <= 10 }\", 0 },\n\t{ \"{ [i] -> [3*floor(i/2) + 5*floor(i/3)] }\", 1 },\n\t{ \"{ S1[i] -> [i] : 0 <= i <= 9; S2[i] -> [i] : 0 <= i <= 9 }\", 1 },\n\t{ \"{ [i] -> S1[i] : 0 <= i <= 9; [i] -> S2[i] : 0 <= i <= 9 }\", 0 },\n\t{ \"{ A[i] -> [i]; B[i] -> [i]; B[i] -> [i + 1] }\", 0 },\n\t{ \"{ A[i] -> [i]; B[i] -> [i] : i < 0; B[i] -> [i + 1] : i > 0 }\", 1 },\n\t{ \"{ A[i] -> [i]; B[i] -> A[i] : i < 0; B[i] -> [i + 1] : i > 0 }\", 1 },\n\t{ \"{ A[i] -> [i]; B[i] -> [j] : i - 1 <= j <= i }\", 0 },\n};\n\nint test_sv(isl_ctx *ctx)\n{\n\tisl_union_map *umap;\n\tint i;\n\tint sv;\n\n\tfor (i = 0; i < ARRAY_SIZE(sv_tests); ++i) {\n\t\tumap = isl_union_map_read_from_str(ctx, sv_tests[i].map);\n\t\tsv = isl_union_map_is_single_valued(umap);\n\t\tisl_union_map_free(umap);\n\t\tif (sv < 0)\n\t\t\treturn -1;\n\t\tif (sv_tests[i].sv && !sv)\n\t\t\tisl_die(ctx, isl_error_internal,\n\t\t\t\t\"map not detected as single valued\", return -1);\n\t\tif (!sv_tests[i].sv && sv)\n\t\t\tisl_die(ctx, isl_error_internal,\n\t\t\t\t\"map detected as single valued\", return -1);\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\tconst char *str;\n\tint bijective;\n} bijective_tests[] = {\n\t{ \"[N,M]->{[i,j] -> [i]}\", 0 },\n\t{ \"[N,M]->{[i,j] -> [i] : j=i}\", 1 },\n\t{ \"[N,M]->{[i,j] -> [i] : j=0}\", 1 },\n\t{ \"[N,M]->{[i,j] -> [i] : j=N}\", 1 },\n\t{ \"[N,M]->{[i,j] -> [j,i]}\", 1 },\n\t{ \"[N,M]->{[i,j] -> [i+j]}\", 0 },\n\t{ \"[N,M]->{[i,j] -> []}\", 0 },\n\t{ \"[N,M]->{[i,j] -> [i,j,N]}\", 1 },\n\t{ \"[N,M]->{[i,j] -> [2i]}\", 0 },\n\t{ \"[N,M]->{[i,j] -> [i,i]}\", 0 },\n\t{ \"[N,M]->{[i,j] -> [2i,i]}\", 0 },\n\t{ \"[N,M]->{[i,j] -> [2i,j]}\", 1 },\n\t{ \"[N,M]->{[i,j] -> [x,y] : 2x=i & y =j}\", 1 },\n};\n\nstatic int test_bijective(struct isl_ctx *ctx)\n{\n\tisl_map *map;\n\tint i;\n\tint bijective;\n\n\tfor (i = 0; i < ARRAY_SIZE(bijective_tests); ++i) {\n\t\tmap = isl_map_read_from_str(ctx, bijective_tests[i].str);\n\t\tbijective = isl_map_is_bijective(map);\n\t\tisl_map_free(map);\n\t\tif (bijective < 0)\n\t\t\treturn -1;\n\t\tif (bijective_tests[i].bijective && !bijective)\n\t\t\tisl_die(ctx, isl_error_internal,\n\t\t\t\t\"map not detected as bijective\", return -1);\n\t\tif (!bijective_tests[i].bijective && bijective)\n\t\t\tisl_die(ctx, isl_error_internal,\n\t\t\t\t\"map detected as bijective\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for isl_pw_qpolynomial_gist tests.\n * \"pwqp\" is the input, \"set\" is the context and \"gist\" is the expected result.\n */\nstruct {\n\tconst char *pwqp;\n\tconst char *set;\n\tconst char *gist;\n} pwqp_gist_tests[] = {\n\t{ \"{ [i] -> i }\", \"{ [k] : exists a : k = 2a }\", \"{ [i] -> i }\" },\n\t{ \"{ [i] -> i + [ (i + [i/3])/2 ] }\", \"{ [10] }\", \"{ [i] -> 16 }\" },\n\t{ \"{ [i] -> ([(i)/2]) }\", \"{ [k] : exists a : k = 2a+1 }\",\n\t  \"{ [i] -> -1/2 + 1/2 * i }\" },\n\t{ \"{ [i] -> i^2 : i != 0 }\", \"{ [i] : i != 0 }\", \"{ [i] -> i^2 }\" },\n};\n\n/* Perform some basic isl_pw_qpolynomial_gist tests.\n */\nstatic isl_stat test_pwqp_gist(isl_ctx *ctx)\n{\n\tint i;\n\tconst char *str;\n\tisl_set *set;\n\tisl_pw_qpolynomial *pwqp1, *pwqp2;\n\tisl_bool equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(pwqp_gist_tests); ++i) {\n\t\tstr = pwqp_gist_tests[i].pwqp;\n\t\tpwqp1 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\t\tstr = pwqp_gist_tests[i].set;\n\t\tset = isl_set_read_from_str(ctx, str);\n\t\tpwqp1 = isl_pw_qpolynomial_gist(pwqp1, set);\n\t\tstr = pwqp_gist_tests[i].gist;\n\t\tpwqp2 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\t\tpwqp1 = isl_pw_qpolynomial_sub(pwqp1, pwqp2);\n\t\tequal = isl_pw_qpolynomial_is_zero(pwqp1);\n\t\tisl_pw_qpolynomial_free(pwqp1);\n\n\t\tif (equal < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return isl_stat_error);\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Perform a basic isl_pw_qpolynomial_max test.\n */\nstatic isl_stat test_pwqp_max(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_pw_qpolynomial *pwqp;\n\tisl_val *v;\n\tint ok;\n\n\tstr = \"{ [x=2:9, y] -> floor((x + 1)/4)^3 - floor((2x)/3)^2 }\";\n\tpwqp = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tv = isl_pw_qpolynomial_max(pwqp);\n\tok = isl_val_cmp_si(v, -1) == 0;\n\tisl_val_free(v);\n\n\tif (!v)\n\t\treturn isl_stat_error;\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected maximum\",\n\t\t\treturn isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\nstatic int test_pwqp(struct isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_pw_qpolynomial *pwqp1, *pwqp2;\n\tint equal;\n\n\tstr = \"{ [i,j,k] -> 1 + 9 * [i/5] + 7 * [j/11] + 4 * [k/13] }\";\n\tpwqp1 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\n\tpwqp1 = isl_pw_qpolynomial_move_dims(pwqp1, isl_dim_param, 0,\n\t\t\t\t\t\tisl_dim_in, 1, 1);\n\n\tstr = \"[j] -> { [i,k] -> 1 + 9 * [i/5] + 7 * [j/11] + 4 * [k/13] }\";\n\tpwqp2 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\n\tpwqp1 = isl_pw_qpolynomial_sub(pwqp1, pwqp2);\n\n\tassert(isl_pw_qpolynomial_is_zero(pwqp1));\n\n\tisl_pw_qpolynomial_free(pwqp1);\n\n\tif (test_pwqp_gist(ctx) < 0)\n\t\treturn -1;\n\n\tstr = \"{ [i] -> ([([i/2] + [i/2])/5]) }\";\n\tpwqp1 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tstr = \"{ [i] -> ([(2 * [i/2])/5]) }\";\n\tpwqp2 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\n\tpwqp1 = isl_pw_qpolynomial_sub(pwqp1, pwqp2);\n\n\tassert(isl_pw_qpolynomial_is_zero(pwqp1));\n\n\tisl_pw_qpolynomial_free(pwqp1);\n\n\tstr = \"{ [x] -> ([x/2] + [(x+1)/2]) }\";\n\tpwqp1 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tstr = \"{ [x] -> x }\";\n\tpwqp2 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\n\tpwqp1 = isl_pw_qpolynomial_sub(pwqp1, pwqp2);\n\n\tassert(isl_pw_qpolynomial_is_zero(pwqp1));\n\n\tisl_pw_qpolynomial_free(pwqp1);\n\n\tstr = \"{ [i] -> ([i/2]) : i >= 0; [i] -> ([i/3]) : i < 0 }\";\n\tpwqp1 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tpwqp2 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tpwqp1 = isl_pw_qpolynomial_coalesce(pwqp1);\n\tpwqp1 = isl_pw_qpolynomial_sub(pwqp1, pwqp2);\n\tassert(isl_pw_qpolynomial_is_zero(pwqp1));\n\tisl_pw_qpolynomial_free(pwqp1);\n\n\tstr = \"{ [a,b,a] -> (([(2*[a/3]+b)/5]) * ([(2*[a/3]+b)/5])) }\";\n\tpwqp2 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tstr = \"{ [a,b,c] -> (([(2*[a/3]+b)/5]) * ([(2*[c/3]+b)/5])) }\";\n\tpwqp1 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tset = isl_set_read_from_str(ctx, \"{ [a,b,a] }\");\n\tpwqp1 = isl_pw_qpolynomial_intersect_domain(pwqp1, set);\n\tequal = isl_pw_qpolynomial_plain_is_equal(pwqp1, pwqp2);\n\tisl_pw_qpolynomial_free(pwqp1);\n\tisl_pw_qpolynomial_free(pwqp2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\tstr = \"{ [a,b,c] -> (([(2*[a/3]+1)/5]) * ([(2*[c/3]+1)/5])) : b = 1 }\";\n\tpwqp2 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tstr = \"{ [a,b,c] -> (([(2*[a/3]+b)/5]) * ([(2*[c/3]+b)/5])) }\";\n\tpwqp1 = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tpwqp1 = isl_pw_qpolynomial_fix_val(pwqp1, isl_dim_set, 1,\n\t\t\t\t\t\tisl_val_one(ctx));\n\tequal = isl_pw_qpolynomial_plain_is_equal(pwqp1, pwqp2);\n\tisl_pw_qpolynomial_free(pwqp1);\n\tisl_pw_qpolynomial_free(pwqp2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\tif (test_pwqp_max(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int test_split_periods(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_pw_qpolynomial *pwqp;\n\n\tstr = \"{ [U,V] -> 1/3 * U + 2/3 * V - [(U + 2V)/3] + [U/2] : \"\n\t\t\"U + 2V + 3 >= 0 and - U -2V  >= 0 and - U + 10 >= 0 and \"\n\t\t\"U  >= 0; [U,V] -> U^2 : U >= 100 }\";\n\tpwqp = isl_pw_qpolynomial_read_from_str(ctx, str);\n\n\tpwqp = isl_pw_qpolynomial_split_periods(pwqp, 2);\n\n\tisl_pw_qpolynomial_free(pwqp);\n\n\tif (!pwqp)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int test_union(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_union_set *uset1, *uset2;\n\tisl_union_map *umap1, *umap2;\n\tint equal;\n\n\tstr = \"{ [i] : 0 <= i <= 1 }\";\n\tuset1 = isl_union_set_read_from_str(ctx, str);\n\tstr = \"{ [1] -> [0] }\";\n\tumap1 = isl_union_map_read_from_str(ctx, str);\n\n\tumap2 = isl_union_set_lex_gt_union_set(isl_union_set_copy(uset1), uset1);\n\tequal = isl_union_map_is_equal(umap1, umap2);\n\n\tisl_union_map_free(umap1);\n\tisl_union_map_free(umap2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"union maps not equal\",\n\t\t\treturn -1);\n\n\tstr = \"{ A[i] -> B[i]; B[i] -> C[i]; A[0] -> C[1] }\";\n\tumap1 = isl_union_map_read_from_str(ctx, str);\n\tstr = \"{ A[i]; B[i] }\";\n\tuset1 = isl_union_set_read_from_str(ctx, str);\n\n\tuset2 = isl_union_map_domain(umap1);\n\n\tequal = isl_union_set_is_equal(uset1, uset2);\n\n\tisl_union_set_free(uset1);\n\tisl_union_set_free(uset2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"union sets not equal\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* Inputs for basic isl_pw_qpolynomial_bound tests.\n * \"type\" is the type of bound that should be computed.\n * \"poly\" is a string representation of the input.\n * \"bound\" is a string representation of the expected result.\n * \"tight\" is set if the result is expected to be tight.\n */\nstatic struct {\n\tint tight;\n\tenum isl_fold type;\n\tconst char *poly;\n\tconst char *bound;\n} bound_tests[] = {\n\t/* Check that computing a bound of a non-zero polynomial\n\t * over an unbounded domain does not produce a rational value.\n\t * In particular, check that the upper bound is infinity.\n\t */\n\t{ 0, isl_fold_max, \"{ [m, n] -> -m * n }\", \"{ max(infty) }\" },\n\t{ 1, isl_fold_max, \"{ [[a, b, c, d] -> [e]] -> 0 }\",\n\t  \"{ [a, b, c, d] -> max(0) }\" },\n\t{ 1, isl_fold_max, \"{ [[x] -> [x]] -> 1 : exists a : x = 2 a }\",\n\t  \"{ [x] -> max(1) : x mod 2 = 0 }\" },\n\t{ 1, isl_fold_min, \"{ [x=5:10] -> (x + 2)^2 }\", \"{ min(49) }\" },\n\t{ 1, isl_fold_max, \"{ [0:10] -> 1 }\", \"{ max(1) }\" },\n\t{ 1, isl_fold_max, \"{ [[m] -> [0:m]] -> m^2 }\",\n\t  \"{ [m] -> max(m^2) : m >= 0 }\" },\n};\n\n/* Check that the bound computation can handle differences\n * in domain dimension names of the input polynomial and its domain.\n */\nstatic isl_stat test_bound_space(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_pw_qpolynomial *pwqp;\n\tisl_pw_qpolynomial_fold *pwf;\n\n\tstr = \"{ [[c] -> [c]] }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tstr = \"{ [[a] -> [b]] -> 1 }\";\n\tpwqp = isl_pw_qpolynomial_read_from_str(ctx, str);\n\tpwqp = isl_pw_qpolynomial_intersect_domain(pwqp, set);\n\tpwf = isl_pw_qpolynomial_bound(pwqp, isl_fold_max, NULL);\n\tisl_pw_qpolynomial_fold_free(pwf);\n\n\treturn isl_stat_non_null(pwf);\n}\n\n/* Perform basic isl_pw_qpolynomial_bound tests.\n */\nstatic int test_bound(isl_ctx *ctx)\n{\n\tint i;\n\n\tif (test_bound_space(ctx) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(bound_tests); ++i) {\n\t\tconst char *str;\n\t\tenum isl_fold type;\n\t\tisl_bool equal, tight;\n\t\tisl_pw_qpolynomial *pwqp;\n\t\tisl_pw_qpolynomial_fold *pwf1, *pwf2;\n\n\t\tstr = bound_tests[i].poly;\n\t\tpwqp = isl_pw_qpolynomial_read_from_str(ctx, str);\n\t\ttype = bound_tests[i].type;\n\t\tpwf1 = isl_pw_qpolynomial_bound(pwqp, type, &tight);\n\t\tstr = bound_tests[i].bound;\n\t\tpwf2 = isl_pw_qpolynomial_fold_read_from_str(ctx, str);\n\t\tequal = isl_pw_qpolynomial_fold_plain_is_equal(pwf1, pwf2);\n\t\tisl_pw_qpolynomial_fold_free(pwf2);\n\t\tisl_pw_qpolynomial_fold_free(pwf1);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"incorrect bound result\", return -1);\n\t\tif (bound_tests[i].tight && !tight)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"bound unexpectedly not tight\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* isl_set is defined to isl_map internally, so the corresponding elements\n * are isl_basic_map objects.\n */\n#undef EL_BASE\n#undef SET_BASE\n#define EL_BASE\t\tbasic_map\n#define SET_BASE\tset\n#include \"isl_test_list_templ.c\"\n\n#undef EL_BASE\n#undef SET_BASE\n#define EL_BASE\t\tbasic_set\n#define SET_BASE\tunion_set\n#include \"isl_test_list_templ.c\"\n\n#undef EL_BASE\n#undef SET_BASE\n#define EL_BASE\t\tset\n#define SET_BASE\tunion_set\n#include \"isl_test_list_templ.c\"\n\n#undef EL_BASE\n#undef SET_BASE\n#define EL_BASE\t\tbasic_map\n#define SET_BASE\tmap\n#include \"isl_test_list_templ.c\"\n\n#undef EL_BASE\n#undef SET_BASE\n#define EL_BASE\t\tmap\n#define SET_BASE\tunion_map\n#include \"isl_test_list_templ.c\"\n\n/* Check that the conversion from isl objects to lists works as expected.\n */\nstatic int test_get_list(isl_ctx *ctx)\n{\n\tif (test_get_list_basic_map_from_set(ctx, \"{ [0]; [2]; [3] }\"))\n\t\treturn -1;\n\tif (test_get_list_basic_set_from_union_set(ctx, \"{ A[0]; B[2]; B[3] }\"))\n\t\treturn -1;\n\tif (test_get_list_set_from_union_set(ctx, \"{ A[0]; A[2]; B[3] }\"))\n\t\treturn -1;\n\tif (test_get_list_basic_map_from_map(ctx,\n\t\t\t\t\"{ [0] -> [0]; [2] -> [0]; [3] -> [0] }\"))\n\t\treturn -1;\n\tif (test_get_list_map_from_union_map(ctx,\n\t\t\t\t\"{ A[0] -> [0]; A[2] -> [0]; B[3] -> [0] }\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int test_lift(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_map *bmap;\n\tisl_basic_set *bset;\n\n\tstr = \"{ [i0] : exists e0 : i0 = 4e0 }\";\n\tbset = isl_basic_set_read_from_str(ctx, str);\n\tbset = isl_basic_set_lift(bset);\n\tbmap = isl_basic_map_from_range(bset);\n\tbset = isl_basic_map_domain(bmap);\n\tisl_basic_set_free(bset);\n\n\treturn 0;\n}\n\n/* Check that isl_set_is_subset is not confused by identical\n * integer divisions.\n * The call to isl_set_normalize ensures that the equality constraints\n * a = b = 0 are discovered, turning e0 and e1 into identical\n * integer divisions.  Any further simplification would remove\n * the duplicate integer divisions.\n */\nstatic isl_stat test_subset_duplicate_integer_divisions(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_bool is_subset;\n\tisl_set *set1, *set2;\n\n\tstr = \"{ [a, b, c, d] : \"\n\t    \"exists (e0 = floor((a + d)/4), e1 = floor((d)/4), \"\n\t\t    \"e2 = floor((-a - d + 4 *floor((a + d)/4))/10), \"\n\t\t    \"e3 = floor((-d + 4*floor((d)/4))/10): \"\n\t\t\"10e2 = -a - 2c - d + 4e0 and 10e3 = -2c - d + 4e1 and \"\n\t\t\"b >= 0 and a <= 0 and b <= a) }\";\n\tset1 = isl_set_read_from_str(ctx, str);\n\tset2 = isl_set_read_from_str(ctx, str);\n\tset2 = isl_set_normalize(set2);\n\n\tis_subset = isl_set_is_subset(set1, set2);\n\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\n\tif (is_subset < 0)\n\t\treturn isl_stat_error;\n\tif (!is_subset)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"set is not considered to be a subset of itself\",\n\t\t\treturn isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\nstruct {\n\tconst char *set1;\n\tconst char *set2;\n\tint subset;\n} subset_tests[] = {\n\t{ \"{ [112, 0] }\",\n\t  \"{ [i0, i1] : exists (e0 = [(i0 - i1)/16], e1: \"\n\t\t\"16e0 <= i0 - i1 and 16e0 >= -15 + i0 - i1 and \"\n\t\t\"16e1 <= i1 and 16e0 >= -i1 and 16e1 >= -i0 + i1) }\", 1 },\n\t{ \"{ [65] }\",\n\t  \"{ [i] : exists (e0 = [(255i)/256], e1 = [(127i + 65e0)/191], \"\n\t\t\"e2 = [(3i + 61e1)/65], e3 = [(52i + 12e2)/61], \"\n\t\t\"e4 = [(2i + e3)/3], e5 = [(4i + e3)/4], e6 = [(8i + e3)/12]: \"\n\t\t    \"3e4 = 2i + e3 and 4e5 = 4i + e3 and 12e6 = 8i + e3 and \"\n\t\t    \"i <= 255 and 64e3 >= -45 + 67i and i >= 0 and \"\n\t\t    \"256e0 <= 255i and 256e0 >= -255 + 255i and \"\n\t\t    \"191e1 <= 127i + 65e0 and 191e1 >= -190 + 127i + 65e0 and \"\n\t\t    \"65e2 <= 3i + 61e1 and 65e2 >= -64 + 3i + 61e1 and \"\n\t\t    \"61e3 <= 52i + 12e2 and 61e3 >= -60 + 52i + 12e2) }\", 1 },\n\t{ \"{ [i] : 0 <= i <= 10 }\", \"{ rat: [i] : 0 <= i <= 10 }\", 1 },\n\t{ \"{ rat: [i] : 0 <= i <= 10 }\", \"{ [i] : 0 <= i <= 10 }\", 0 },\n\t{ \"{ rat: [0] }\", \"{ [i] : 0 <= i <= 10 }\", 1 },\n\t{ \"{ rat: [(1)/2] }\", \"{ [i] : 0 <= i <= 10 }\", 0 },\n\t{ \"{ [t, i] : (exists (e0 = [(2 + t)/4]: 4e0 <= 2 + t and \"\n\t\t\t\"4e0 >= -1 + t and i >= 57 and i <= 62 and \"\n\t\t\t\"4e0 <= 62 + t - i and 4e0 >= -61 + t + i and \"\n\t\t\t\"t >= 0 and t <= 511 and 4e0 <= -57 + t + i and \"\n\t\t\t\"4e0 >= 58 + t - i and i >= 58 + t and i >= 62 - t)) }\",\n\t  \"{ [i0, i1] : (exists (e0 = [(4 + i0)/4]: 4e0 <= 62 + i0 - i1 and \"\n\t\t\t\"4e0 >= 1 + i0 and i0 >= 0 and i0 <= 511 and \"\n\t\t\t\"4e0 <= -57 + i0 + i1)) or \"\n\t\t\"(exists (e0 = [(2 + i0)/4]: 4e0 <= i0 and \"\n\t\t\t\"4e0 >= 58 + i0 - i1 and i0 >= 2 and i0 <= 511 and \"\n\t\t\t\"4e0 >= -61 + i0 + i1)) or \"\n\t\t\"(i1 <= 66 - i0 and i0 >= 2 and i1 >= 59 + i0) }\", 1 },\n\t{ \"[a, b] -> { : a = 0 and b = -1 }\", \"[b, a] -> { : b >= -10 }\", 1 },\n};\n\nstatic int test_subset(isl_ctx *ctx)\n{\n\tint i;\n\tisl_set *set1, *set2;\n\tint subset;\n\n\tif (test_subset_duplicate_integer_divisions(ctx) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(subset_tests); ++i) {\n\t\tset1 = isl_set_read_from_str(ctx, subset_tests[i].set1);\n\t\tset2 = isl_set_read_from_str(ctx, subset_tests[i].set2);\n\t\tsubset = isl_set_is_subset(set1, set2);\n\t\tisl_set_free(set1);\n\t\tisl_set_free(set2);\n\t\tif (subset < 0)\n\t\t\treturn -1;\n\t\tif (subset != subset_tests[i].subset)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"incorrect subset result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Perform a set subtraction with a set that has a non-obviously empty disjunct.\n * Older versions of isl would fail on such cases.\n */\nstatic isl_stat test_subtract_empty(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *s1, *s2;\n\n\ts1 = isl_set_read_from_str(ctx, \"{ [0] }\");\n\tstr = \"{ [a] : (exists (e0, e1, e2: 1056e1 <= 32 + a - 33e0 and \"\n\t\t\t\"1089e1 >= a - 33e0 and 1089e1 <= 1 + a - 33e0 and \"\n\t\t\t\"33e2 >= -a + 33e0 + 1056e1 and \"\n\t\t\t\"33e2 < -2a + 66e0 + 2112e1)) or a = 0 }\";\n\ts2 = isl_set_read_from_str(ctx, str);\n\ts1 = isl_set_subtract(s1, s2);\n\tisl_set_free(s1);\n\n\treturn isl_stat_non_null(s1);\n}\n\nstruct {\n\tconst char *minuend;\n\tconst char *subtrahend;\n\tconst char *difference;\n} subtract_domain_tests[] = {\n\t{ \"{ A[i] -> B[i] }\", \"{ A[i] }\", \"{ }\" },\n\t{ \"{ A[i] -> B[i] }\", \"{ B[i] }\", \"{ A[i] -> B[i] }\" },\n\t{ \"{ A[i] -> B[i] }\", \"{ A[i] : i > 0 }\", \"{ A[i] -> B[i] : i <= 0 }\" },\n};\n\nstatic int test_subtract(isl_ctx *ctx)\n{\n\tint i;\n\tisl_union_map *umap1, *umap2;\n\tisl_union_pw_multi_aff *upma1, *upma2;\n\tisl_union_set *uset;\n\tint equal;\n\n\tif (test_subtract_empty(ctx) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(subtract_domain_tests); ++i) {\n\t\tumap1 = isl_union_map_read_from_str(ctx,\n\t\t\t\tsubtract_domain_tests[i].minuend);\n\t\tuset = isl_union_set_read_from_str(ctx,\n\t\t\t\tsubtract_domain_tests[i].subtrahend);\n\t\tumap2 = isl_union_map_read_from_str(ctx,\n\t\t\t\tsubtract_domain_tests[i].difference);\n\t\tumap1 = isl_union_map_subtract_domain(umap1, uset);\n\t\tequal = isl_union_map_is_equal(umap1, umap2);\n\t\tisl_union_map_free(umap1);\n\t\tisl_union_map_free(umap2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"incorrect subtract domain result\", return -1);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(subtract_domain_tests); ++i) {\n\t\tupma1 = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\tsubtract_domain_tests[i].minuend);\n\t\tuset = isl_union_set_read_from_str(ctx,\n\t\t\t\tsubtract_domain_tests[i].subtrahend);\n\t\tupma2 = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\tsubtract_domain_tests[i].difference);\n\t\tupma1 = isl_union_pw_multi_aff_subtract_domain(upma1, uset);\n\t\tequal = isl_union_pw_multi_aff_plain_is_equal(upma1, upma2);\n\t\tisl_union_pw_multi_aff_free(upma1);\n\t\tisl_union_pw_multi_aff_free(upma2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"incorrect subtract domain result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Check that intersecting the empty basic set with another basic set\n * does not increase the number of constraints.  In particular,\n * the empty basic set should maintain its canonical representation.\n */\nstatic int test_intersect_1(isl_ctx *ctx)\n{\n\tisl_size n1, n2;\n\tisl_basic_set *bset1, *bset2;\n\n\tbset1 = isl_basic_set_read_from_str(ctx, \"{ [a,b,c] : 1 = 0 }\");\n\tbset2 = isl_basic_set_read_from_str(ctx, \"{ [1,2,3] }\");\n\tn1 = isl_basic_set_n_constraint(bset1);\n\tbset1 = isl_basic_set_intersect(bset1, bset2);\n\tn2 = isl_basic_set_n_constraint(bset1);\n\tisl_basic_set_free(bset1);\n\tif (n1 < 0 || n2 < 0)\n\t\treturn -1;\n\tif (n1 != n2)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"number of constraints of empty set changed\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* Check that intersecting a set with itself does not cause\n * an explosion in the number of disjuncts.\n */\nstatic isl_stat test_intersect_2(isl_ctx *ctx)\n{\n\tint i;\n\tisl_set *set;\n\n\tset = isl_set_read_from_str(ctx, \"{ [x,y] : x >= 0 or y >= 0 }\");\n\tfor (i = 0; i < 100; ++i)\n\t\tset = isl_set_intersect(set, isl_set_copy(set));\n\tisl_set_free(set);\n\tif (!set)\n\t\treturn isl_stat_error;\n\treturn isl_stat_ok;\n}\n\n/* Perform some intersection tests.\n */\nstatic int test_intersect(isl_ctx *ctx)\n{\n\tif (test_intersect_1(ctx) < 0)\n\t\treturn -1;\n\tif (test_intersect_2(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint test_factorize(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset;\n\tisl_factorizer *f;\n\n\tstr = \"{ [i0, i1, i2, i3, i4, i5, i6, i7] : 3i5 <= 2 - 2i0 and \"\n\t    \"i0 >= -2 and i6 >= 1 + i3 and i7 >= 0 and 3i5 >= -2i0 and \"\n\t    \"2i4 <= i2 and i6 >= 1 + 2i0 + 3i1 and i4 <= -1 and \"\n\t    \"i6 >= 1 + 2i0 + 3i5 and i6 <= 2 + 2i0 + 3i5 and \"\n\t    \"3i5 <= 2 - 2i0 - i2 + 3i4 and i6 <= 2 + 2i0 + 3i1 and \"\n\t    \"i0 <= -1 and i7 <= i2 + i3 - 3i4 - i6 and \"\n\t    \"3i5 >= -2i0 - i2 + 3i4 }\";\n\tbset = isl_basic_set_read_from_str(ctx, str);\n\tf = isl_basic_set_factorizer(bset);\n\tisl_basic_set_free(bset);\n\tisl_factorizer_free(f);\n\tif (!f)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"failed to construct factorizer\", return -1);\n\n\tstr = \"{ [i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12] : \"\n\t    \"i12 <= 2 + i0 - i11 and 2i8 >= -i4 and i11 >= i1 and \"\n\t    \"3i5 <= -i2 and 2i11 >= -i4 - 2i7 and i11 <= 3 + i0 + 3i9 and \"\n\t    \"i11 <= -i4 - 2i7 and i12 >= -i10 and i2 >= -2 and \"\n\t    \"i11 >= i1 + 3i10 and i11 >= 1 + i0 + 3i9 and \"\n\t    \"i11 <= 1 - i4 - 2i8 and 6i6 <= 6 - i2 and 3i6 >= 1 - i2 and \"\n\t    \"i11 <= 2 + i1 and i12 <= i4 + i11 and i12 >= i0 - i11 and \"\n\t    \"3i5 >= -2 - i2 and i12 >= -1 + i4 + i11 and 3i3 <= 3 - i2 and \"\n\t    \"9i6 <= 11 - i2 + 6i5 and 3i3 >= 1 - i2 and \"\n\t    \"9i6 <= 5 - i2 + 6i3 and i12 <= -1 and i2 <= 0 }\";\n\tbset = isl_basic_set_read_from_str(ctx, str);\n\tf = isl_basic_set_factorizer(bset);\n\tisl_basic_set_free(bset);\n\tisl_factorizer_free(f);\n\tif (!f)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"failed to construct factorizer\", return -1);\n\n\treturn 0;\n}\n\nstatic isl_stat check_injective(__isl_take isl_map *map, void *user)\n{\n\tint *injective = user;\n\n\t*injective = isl_map_is_injective(map);\n\tisl_map_free(map);\n\n\tif (*injective < 0 || !*injective)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\nint test_one_schedule(isl_ctx *ctx, const char *d, const char *w,\n\tconst char *r, const char *s, int tilable, int parallel)\n{\n\tint i;\n\tisl_union_set *D;\n\tisl_union_map *W, *R, *S;\n\tisl_union_map *empty;\n\tisl_union_map *dep_raw, *dep_war, *dep_waw, *dep;\n\tisl_union_map *validity, *proximity, *coincidence;\n\tisl_union_map *schedule;\n\tisl_union_map *test;\n\tisl_union_set *delta;\n\tisl_union_set *domain;\n\tisl_set *delta_set;\n\tisl_set *slice;\n\tisl_set *origin;\n\tisl_schedule_constraints *sc;\n\tisl_schedule *sched;\n\tint is_nonneg, is_parallel, is_tilable, is_injection, is_complete;\n\tisl_size n;\n\n\tD = isl_union_set_read_from_str(ctx, d);\n\tW = isl_union_map_read_from_str(ctx, w);\n\tR = isl_union_map_read_from_str(ctx, r);\n\tS = isl_union_map_read_from_str(ctx, s);\n\n\tW = isl_union_map_intersect_domain(W, isl_union_set_copy(D));\n\tR = isl_union_map_intersect_domain(R, isl_union_set_copy(D));\n\n\tempty = isl_union_map_empty(isl_union_map_get_space(S));\n        isl_union_map_compute_flow(isl_union_map_copy(R),\n\t\t\t\t   isl_union_map_copy(W), empty,\n\t\t\t\t   isl_union_map_copy(S),\n\t\t\t\t   &dep_raw, NULL, NULL, NULL);\n        isl_union_map_compute_flow(isl_union_map_copy(W),\n\t\t\t\t   isl_union_map_copy(W),\n\t\t\t\t   isl_union_map_copy(R),\n\t\t\t\t   isl_union_map_copy(S),\n\t\t\t\t   &dep_waw, &dep_war, NULL, NULL);\n\n\tdep = isl_union_map_union(dep_waw, dep_war);\n\tdep = isl_union_map_union(dep, dep_raw);\n\tvalidity = isl_union_map_copy(dep);\n\tcoincidence = isl_union_map_copy(dep);\n\tproximity = isl_union_map_copy(dep);\n\n\tsc = isl_schedule_constraints_on_domain(isl_union_set_copy(D));\n\tsc = isl_schedule_constraints_set_validity(sc, validity);\n\tsc = isl_schedule_constraints_set_coincidence(sc, coincidence);\n\tsc = isl_schedule_constraints_set_proximity(sc, proximity);\n\tsched = isl_schedule_constraints_compute_schedule(sc);\n\tschedule = isl_schedule_get_map(sched);\n\tisl_schedule_free(sched);\n\tisl_union_map_free(W);\n\tisl_union_map_free(R);\n\tisl_union_map_free(S);\n\n\tis_injection = 1;\n\tisl_union_map_foreach_map(schedule, &check_injective, &is_injection);\n\n\tdomain = isl_union_map_domain(isl_union_map_copy(schedule));\n\tis_complete = isl_union_set_is_subset(D, domain);\n\tisl_union_set_free(D);\n\tisl_union_set_free(domain);\n\n\ttest = isl_union_map_reverse(isl_union_map_copy(schedule));\n\ttest = isl_union_map_apply_range(test, dep);\n\ttest = isl_union_map_apply_range(test, schedule);\n\n\tdelta = isl_union_map_deltas(test);\n\tn = isl_union_set_n_set(delta);\n\tif (n < 0) {\n\t\tisl_union_set_free(delta);\n\t\treturn -1;\n\t}\n\tif (n == 0) {\n\t\tis_tilable = 1;\n\t\tis_parallel = 1;\n\t\tis_nonneg = 1;\n\t\tisl_union_set_free(delta);\n\t} else {\n\t\tisl_size dim;\n\n\t\tdelta_set = isl_set_from_union_set(delta);\n\n\t\tslice = isl_set_universe(isl_set_get_space(delta_set));\n\t\tfor (i = 0; i < tilable; ++i)\n\t\t\tslice = isl_set_lower_bound_si(slice, isl_dim_set, i, 0);\n\t\tis_tilable = isl_set_is_subset(delta_set, slice);\n\t\tisl_set_free(slice);\n\n\t\tslice = isl_set_universe(isl_set_get_space(delta_set));\n\t\tfor (i = 0; i < parallel; ++i)\n\t\t\tslice = isl_set_fix_si(slice, isl_dim_set, i, 0);\n\t\tis_parallel = isl_set_is_subset(delta_set, slice);\n\t\tisl_set_free(slice);\n\n\t\torigin = isl_set_universe(isl_set_get_space(delta_set));\n\t\tdim = isl_set_dim(origin, isl_dim_set);\n\t\tif (dim < 0)\n\t\t\torigin = isl_set_free(origin);\n\t\tfor (i = 0; i < dim; ++i)\n\t\t\torigin = isl_set_fix_si(origin, isl_dim_set, i, 0);\n\n\t\tdelta_set = isl_set_union(delta_set, isl_set_copy(origin));\n\t\tdelta_set = isl_set_lexmin(delta_set);\n\n\t\tis_nonneg = isl_set_is_equal(delta_set, origin);\n\n\t\tisl_set_free(origin);\n\t\tisl_set_free(delta_set);\n\t}\n\n\tif (is_nonneg < 0 || is_parallel < 0 || is_tilable < 0 ||\n\t    is_injection < 0 || is_complete < 0)\n\t\treturn -1;\n\tif (!is_complete)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"generated schedule incomplete\", return -1);\n\tif (!is_injection)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"generated schedule not injective on each statement\",\n\t\t\treturn -1);\n\tif (!is_nonneg)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"negative dependences in generated schedule\",\n\t\t\treturn -1);\n\tif (!is_tilable)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"generated schedule not as tilable as expected\",\n\t\t\treturn -1);\n\tif (!is_parallel)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"generated schedule not as parallel as expected\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* Compute a schedule for the given instance set, validity constraints,\n * proximity constraints and context and return a corresponding union map\n * representation.\n */\nstatic __isl_give isl_union_map *compute_schedule_with_context(isl_ctx *ctx,\n\tconst char *domain, const char *validity, const char *proximity,\n\tconst char *context)\n{\n\tisl_set *con;\n\tisl_union_set *dom;\n\tisl_union_map *dep;\n\tisl_union_map *prox;\n\tisl_schedule_constraints *sc;\n\tisl_schedule *schedule;\n\tisl_union_map *sched;\n\n\tcon = isl_set_read_from_str(ctx, context);\n\tdom = isl_union_set_read_from_str(ctx, domain);\n\tdep = isl_union_map_read_from_str(ctx, validity);\n\tprox = isl_union_map_read_from_str(ctx, proximity);\n\tsc = isl_schedule_constraints_on_domain(dom);\n\tsc = isl_schedule_constraints_set_context(sc, con);\n\tsc = isl_schedule_constraints_set_validity(sc, dep);\n\tsc = isl_schedule_constraints_set_proximity(sc, prox);\n\tschedule = isl_schedule_constraints_compute_schedule(sc);\n\tsched = isl_schedule_get_map(schedule);\n\tisl_schedule_free(schedule);\n\n\treturn sched;\n}\n\n/* Compute a schedule for the given instance set, validity constraints and\n * proximity constraints and return a corresponding union map representation.\n */\nstatic __isl_give isl_union_map *compute_schedule(isl_ctx *ctx,\n\tconst char *domain, const char *validity, const char *proximity)\n{\n\treturn compute_schedule_with_context(ctx, domain, validity, proximity,\n\t\t\t\t\t\t\"{ : }\");\n}\n\n/* Check that a schedule can be constructed on the given domain\n * with the given validity and proximity constraints.\n */\nstatic int test_has_schedule(isl_ctx *ctx, const char *domain,\n\tconst char *validity, const char *proximity)\n{\n\tisl_union_map *sched;\n\n\tsched = compute_schedule(ctx, domain, validity, proximity);\n\tif (!sched)\n\t\treturn -1;\n\n\tisl_union_map_free(sched);\n\treturn 0;\n}\n\nint test_special_schedule(isl_ctx *ctx, const char *domain,\n\tconst char *validity, const char *proximity, const char *expected_sched)\n{\n\tisl_union_map *sched1, *sched2;\n\tint equal;\n\n\tsched1 = compute_schedule(ctx, domain, validity, proximity);\n\tsched2 = isl_union_map_read_from_str(ctx, expected_sched);\n\n\tequal = isl_union_map_is_equal(sched1, sched2);\n\tisl_union_map_free(sched1);\n\tisl_union_map_free(sched2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected schedule\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* Check that the schedule map is properly padded, i.e., that the range\n * lives in a single space.\n */\nstatic int test_padded_schedule(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_union_set *D;\n\tisl_union_map *validity, *proximity;\n\tisl_schedule_constraints *sc;\n\tisl_schedule *sched;\n\tisl_union_map *umap;\n\tisl_union_set *range;\n\tisl_set *set;\n\n\tstr = \"[N] -> { S0[i] : 0 <= i <= N; S1[i, j] : 0 <= i, j <= N }\";\n\tD = isl_union_set_read_from_str(ctx, str);\n\tvalidity = isl_union_map_empty(isl_union_set_get_space(D));\n\tproximity = isl_union_map_copy(validity);\n\tsc = isl_schedule_constraints_on_domain(D);\n\tsc = isl_schedule_constraints_set_validity(sc, validity);\n\tsc = isl_schedule_constraints_set_proximity(sc, proximity);\n\tsched = isl_schedule_constraints_compute_schedule(sc);\n\tumap = isl_schedule_get_map(sched);\n\tisl_schedule_free(sched);\n\trange = isl_union_map_range(umap);\n\tset = isl_set_from_union_set(range);\n\tisl_set_free(set);\n\n\tif (!set)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that conditional validity constraints are also taken into\n * account across bands.\n * In particular, try to make sure that live ranges D[1,0]->C[2,1] and\n * D[2,0]->C[3,0] are not local in the outer band of the generated schedule\n * and then check that the adjacent order constraint C[2,1]->D[2,0]\n * is enforced by the rest of the schedule.\n */\nstatic int test_special_conditional_schedule_constraints(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_union_set *domain;\n\tisl_union_map *validity, *proximity, *condition;\n\tisl_union_map *sink, *source, *dep;\n\tisl_schedule_constraints *sc;\n\tisl_schedule *schedule;\n\tisl_union_access_info *access;\n\tisl_union_flow *flow;\n\tint empty;\n\n\tstr = \"[n] -> { C[k, i] : k <= -1 + n and i >= 0 and i <= -1 + k; \"\n\t    \"A[k] : k >= 1 and k <= -1 + n; \"\n\t    \"B[k, i] : k <= -1 + n and i >= 0 and i <= -1 + k; \"\n\t    \"D[k, i] : k <= -1 + n and i >= 0 and i <= -1 + k }\";\n\tdomain = isl_union_set_read_from_str(ctx, str);\n\tsc = isl_schedule_constraints_on_domain(domain);\n\tstr = \"[n] -> { D[k, i] -> C[1 + k, k - i] : \"\n\t\t\"k <= -2 + n and i >= 1 and i <= -1 + k; \"\n\t\t\"D[k, i] -> C[1 + k, i] : \"\n\t\t\"k <= -2 + n and i >= 1 and i <= -1 + k; \"\n\t\t\"D[k, 0] -> C[1 + k, k] : k >= 1 and k <= -2 + n; \"\n\t\t\"D[k, 0] -> C[1 + k, 0] : k >= 1 and k <= -2 + n }\";\n\tvalidity = isl_union_map_read_from_str(ctx, str);\n\tsc = isl_schedule_constraints_set_validity(sc, validity);\n\tstr = \"[n] -> { C[k, i] -> D[k, i] : \"\n\t\t\"0 <= i <= -1 + k and k <= -1 + n }\";\n\tproximity = isl_union_map_read_from_str(ctx, str);\n\tsc = isl_schedule_constraints_set_proximity(sc, proximity);\n\tstr = \"[n] -> { [D[k, i] -> a[]] -> [C[1 + k, k - i] -> b[]] : \"\n\t\t\"i <= -1 + k and i >= 1 and k <= -2 + n; \"\n\t\t\"[B[k, i] -> c[]] -> [B[k, 1 + i] -> c[]] : \"\n\t\t\"k <= -1 + n and i >= 0 and i <= -2 + k }\";\n\tcondition = isl_union_map_read_from_str(ctx, str);\n\tstr = \"[n] -> { [B[k, i] -> e[]] -> [D[k, i] -> a[]] : \"\n\t\t\"i >= 0 and i <= -1 + k and k <= -1 + n; \"\n\t\t\"[C[k, i] -> b[]] -> [D[k', -1 + k - i] -> a[]] : \"\n\t\t\"i >= 0 and i <= -1 + k and k <= -1 + n and \"\n\t\t\"k' <= -1 + n and k' >= k - i and k' >= 1 + k; \"\n\t\t\"[C[k, i] -> b[]] -> [D[k, -1 + k - i] -> a[]] : \"\n\t\t\"i >= 0 and i <= -1 + k and k <= -1 + n; \"\n\t\t\"[B[k, i] -> c[]] -> [A[k'] -> d[]] : \"\n\t\t\"k <= -1 + n and i >= 0 and i <= -1 + k and \"\n\t\t\"k' >= 1 and k' <= -1 + n and k' >= 1 + k }\";\n\tvalidity = isl_union_map_read_from_str(ctx, str);\n\tsc = isl_schedule_constraints_set_conditional_validity(sc, condition,\n\t\t\t\t\t\t\t\tvalidity);\n\tschedule = isl_schedule_constraints_compute_schedule(sc);\n\tstr = \"{ D[2,0] -> [] }\";\n\tsink = isl_union_map_read_from_str(ctx, str);\n\taccess = isl_union_access_info_from_sink(sink);\n\tstr = \"{ C[2,1] -> [] }\";\n\tsource = isl_union_map_read_from_str(ctx, str);\n\taccess = isl_union_access_info_set_must_source(access, source);\n\taccess = isl_union_access_info_set_schedule(access, schedule);\n\tflow = isl_union_access_info_compute_flow(access);\n\tdep = isl_union_flow_get_must_dependence(flow);\n\tisl_union_flow_free(flow);\n\tempty = isl_union_map_is_empty(dep);\n\tisl_union_map_free(dep);\n\n\tif (empty < 0)\n\t\treturn -1;\n\tif (empty)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"conditional validity not respected\", return -1);\n\n\treturn 0;\n}\n\n/* Check that the test for violated conditional validity constraints\n * is not confused by domain compression.\n * In particular, earlier versions of isl would apply\n * a schedule on the compressed domains to the original domains,\n * resulting in a failure to detect that the default schedule\n * violates the conditional validity constraints.\n */\nstatic int test_special_conditional_schedule_constraints_2(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_bool empty;\n\tisl_union_set *domain;\n\tisl_union_map *validity, *condition;\n\tisl_schedule_constraints *sc;\n\tisl_schedule *schedule;\n\tisl_union_map *umap;\n\tisl_map *map, *ge;\n\n\tstr = \"{ A[0, i] : 0 <= i <= 10; B[1, i] : 0 <= i <= 10 }\";\n\tdomain = isl_union_set_read_from_str(ctx, str);\n\tsc = isl_schedule_constraints_on_domain(domain);\n\tstr = \"{ B[1, i] -> A[0, i + 1] }\";\n\tcondition = isl_union_map_read_from_str(ctx, str);\n\tstr = \"{ A[0, i] -> B[1, i - 1] }\";\n\tvalidity = isl_union_map_read_from_str(ctx, str);\n\tsc = isl_schedule_constraints_set_conditional_validity(sc, condition,\n\t\t\t\t\t\tisl_union_map_copy(validity));\n\tschedule = isl_schedule_constraints_compute_schedule(sc);\n\tumap = isl_schedule_get_map(schedule);\n\tisl_schedule_free(schedule);\n\tvalidity = isl_union_map_apply_domain(validity,\n\t\t\t\t\t\tisl_union_map_copy(umap));\n\tvalidity = isl_union_map_apply_range(validity, umap);\n\tmap = isl_map_from_union_map(validity);\n\tge = isl_map_lex_ge(isl_space_domain(isl_map_get_space(map)));\n\tmap = isl_map_intersect(map, ge);\n\tempty = isl_map_is_empty(map);\n\tisl_map_free(map);\n\n\tif (empty < 0)\n\t\treturn -1;\n\tif (!empty)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"conditional validity constraints not satisfied\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* Input for testing of schedule construction based on\n * conditional constraints.\n *\n * domain is the iteration domain\n * flow are the flow dependences, which determine the validity and\n * \tproximity constraints\n * condition are the conditions on the conditional validity constraints\n * conditional_validity are the conditional validity constraints\n * outer_band_n is the expected number of members in the outer band\n */\nstruct {\n\tconst char *domain;\n\tconst char *flow;\n\tconst char *condition;\n\tconst char *conditional_validity;\n\tint outer_band_n;\n} live_range_tests[] = {\n\t/* Contrived example that illustrates that we need to keep\n\t * track of tagged condition dependences and\n\t * tagged conditional validity dependences\n\t * in isl_sched_edge separately.\n\t * In particular, the conditional validity constraints on A\n\t * cannot be satisfied,\n\t * but they can be ignored because there are no corresponding\n\t * condition constraints.  However, we do have an additional\n\t * conditional validity constraint that maps to the same\n\t * dependence relation\n\t * as the condition constraint on B.  If we did not make a distinction\n\t * between tagged condition and tagged conditional validity\n\t * dependences, then we\n\t * could end up treating this shared dependence as an condition\n\t * constraint on A, forcing a localization of the conditions,\n\t * which is impossible.\n\t */\n\t{ \"{ S[i] : 0 <= 1 < 100; T[i] : 0 <= 1 < 100 }\",\n\t  \"{ S[i] -> S[i+1] : 0 <= i < 99 }\",\n\t  \"{ [S[i] -> B[]] -> [S[i+1] -> B[]] : 0 <= i < 99 }\",\n\t  \"{ [S[i] -> A[]] -> [T[i'] -> A[]] : 0 <= i', i < 100 and i != i';\"\n\t    \"[T[i] -> A[]] -> [S[i'] -> A[]] : 0 <= i', i < 100 and i != i';\"\n\t    \"[S[i] -> A[]] -> [S[i+1] -> A[]] : 0 <= i < 99 }\",\n\t  1\n\t},\n\t/* TACO 2013 Fig. 7 */\n\t{ \"[n] -> { S1[i,j] : 0 <= i,j < n; S2[i,j] : 0 <= i,j < n }\",\n\t  \"[n] -> { S1[i,j] -> S2[i,j] : 0 <= i,j < n;\"\n\t\t   \"S2[i,j] -> S2[i,j+1] : 0 <= i < n and 0 <= j < n - 1 }\",\n\t  \"[n] -> { [S1[i,j] -> t[]] -> [S2[i,j] -> t[]] : 0 <= i,j < n;\"\n\t\t   \"[S2[i,j] -> x1[]] -> [S2[i,j+1] -> x1[]] : \"\n\t\t\t\t\"0 <= i < n and 0 <= j < n - 1 }\",\n\t  \"[n] -> { [S2[i,j] -> t[]] -> [S1[i,j'] -> t[]] : \"\n\t\t\t\t\"0 <= i < n and 0 <= j < j' < n;\"\n\t\t   \"[S2[i,j] -> t[]] -> [S1[i',j'] -> t[]] : \"\n\t\t\t\t\"0 <= i < i' < n and 0 <= j,j' < n;\"\n\t\t   \"[S2[i,j] -> x1[]] -> [S2[i,j'] -> x1[]] : \"\n\t\t\t\t\"0 <= i,j,j' < n and j < j' }\",\n\t    2\n\t},\n\t/* TACO 2013 Fig. 7, without tags */\n\t{ \"[n] -> { S1[i,j] : 0 <= i,j < n; S2[i,j] : 0 <= i,j < n }\",\n\t  \"[n] -> { S1[i,j] -> S2[i,j] : 0 <= i,j < n;\"\n\t\t   \"S2[i,j] -> S2[i,j+1] : 0 <= i < n and 0 <= j < n - 1 }\",\n\t  \"[n] -> { S1[i,j] -> S2[i,j] : 0 <= i,j < n;\"\n\t\t   \"S2[i,j] -> S2[i,j+1] : 0 <= i < n and 0 <= j < n - 1 }\",\n\t  \"[n] -> { S2[i,j] -> S1[i,j'] : 0 <= i < n and 0 <= j < j' < n;\"\n\t\t   \"S2[i,j] -> S1[i',j'] : 0 <= i < i' < n and 0 <= j,j' < n;\"\n\t\t   \"S2[i,j] -> S2[i,j'] : 0 <= i,j,j' < n and j < j' }\",\n\t   1\n\t},\n\t/* TACO 2013 Fig. 12 */\n\t{ \"{ S1[i,0] : 0 <= i <= 1; S2[i,j] : 0 <= i <= 1 and 1 <= j <= 2;\"\n\t    \"S3[i,3] : 0 <= i <= 1 }\",\n\t  \"{ S1[i,0] -> S2[i,1] : 0 <= i <= 1;\"\n\t    \"S2[i,1] -> S2[i,2] : 0 <= i <= 1;\"\n\t    \"S2[i,2] -> S3[i,3] : 0 <= i <= 1 }\",\n\t  \"{ [S1[i,0]->t[]] -> [S2[i,1]->t[]] : 0 <= i <= 1;\"\n\t    \"[S2[i,1]->t[]] -> [S2[i,2]->t[]] : 0 <= i <= 1;\"\n\t    \"[S2[i,2]->t[]] -> [S3[i,3]->t[]] : 0 <= i <= 1 }\",\n\t  \"{ [S2[i,1]->t[]] -> [S2[i,2]->t[]] : 0 <= i <= 1;\"\n\t    \"[S2[0,j]->t[]] -> [S2[1,j']->t[]] : 1 <= j,j' <= 2;\"\n\t    \"[S2[0,j]->t[]] -> [S1[1,0]->t[]] : 1 <= j <= 2;\"\n\t    \"[S3[0,3]->t[]] -> [S2[1,j]->t[]] : 1 <= j <= 2;\"\n\t    \"[S3[0,3]->t[]] -> [S1[1,0]->t[]] }\",\n\t   1\n\t}\n};\n\n/* Test schedule construction based on conditional constraints.\n * In particular, check the number of members in the outer band node\n * as an indication of whether tiling is possible or not.\n */\nstatic int test_conditional_schedule_constraints(isl_ctx *ctx)\n{\n\tint i;\n\tisl_union_set *domain;\n\tisl_union_map *condition;\n\tisl_union_map *flow;\n\tisl_union_map *validity;\n\tisl_schedule_constraints *sc;\n\tisl_schedule *schedule;\n\tisl_schedule_node *node;\n\tisl_size n_member;\n\n\tif (test_special_conditional_schedule_constraints(ctx) < 0)\n\t\treturn -1;\n\tif (test_special_conditional_schedule_constraints_2(ctx) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(live_range_tests); ++i) {\n\t\tdomain = isl_union_set_read_from_str(ctx,\n\t\t\t\tlive_range_tests[i].domain);\n\t\tflow = isl_union_map_read_from_str(ctx,\n\t\t\t\tlive_range_tests[i].flow);\n\t\tcondition = isl_union_map_read_from_str(ctx,\n\t\t\t\tlive_range_tests[i].condition);\n\t\tvalidity = isl_union_map_read_from_str(ctx,\n\t\t\t\tlive_range_tests[i].conditional_validity);\n\t\tsc = isl_schedule_constraints_on_domain(domain);\n\t\tsc = isl_schedule_constraints_set_validity(sc,\n\t\t\t\tisl_union_map_copy(flow));\n\t\tsc = isl_schedule_constraints_set_proximity(sc, flow);\n\t\tsc = isl_schedule_constraints_set_conditional_validity(sc,\n\t\t\t\tcondition, validity);\n\t\tschedule = isl_schedule_constraints_compute_schedule(sc);\n\t\tnode = isl_schedule_get_root(schedule);\n\t\twhile (node &&\n\t\t    isl_schedule_node_get_type(node) != isl_schedule_node_band)\n\t\t\tnode = isl_schedule_node_first_child(node);\n\t\tn_member = isl_schedule_node_band_n_member(node);\n\t\tisl_schedule_node_free(node);\n\t\tisl_schedule_free(schedule);\n\n\t\tif (!schedule || n_member < 0)\n\t\t\treturn -1;\n\t\tif (n_member != live_range_tests[i].outer_band_n)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected number of members in outer band\",\n\t\t\t\treturn -1);\n\t}\n\treturn 0;\n}\n\n/* Check that the schedule computed for the given instance set and\n * dependence relation strongly satisfies the dependences.\n * In particular, check that no instance is scheduled before\n * or together with an instance on which it depends.\n * Earlier versions of isl would produce a schedule that\n * only weakly satisfies the dependences.\n */\nstatic int test_strongly_satisfying_schedule(isl_ctx *ctx)\n{\n\tconst char *domain, *dep;\n\tisl_union_map *D, *schedule;\n\tisl_map *map, *ge;\n\tint empty;\n\n\tdomain = \"{ B[i0, i1] : 0 <= i0 <= 1 and 0 <= i1 <= 11; \"\n\t\t    \"A[i0] : 0 <= i0 <= 1 }\";\n\tdep = \"{ B[i0, i1] -> B[i0, 1 + i1] : 0 <= i0 <= 1 and 0 <= i1 <= 10; \"\n\t\t\"B[0, 11] -> A[1]; A[i0] -> B[i0, 0] : 0 <= i0 <= 1 }\";\n\tschedule = compute_schedule(ctx, domain, dep, dep);\n\tD = isl_union_map_read_from_str(ctx, dep);\n\tD = isl_union_map_apply_domain(D, isl_union_map_copy(schedule));\n\tD = isl_union_map_apply_range(D, schedule);\n\tmap = isl_map_from_union_map(D);\n\tge = isl_map_lex_ge(isl_space_domain(isl_map_get_space(map)));\n\tmap = isl_map_intersect(map, ge);\n\tempty = isl_map_is_empty(map);\n\tisl_map_free(map);\n\n\tif (empty < 0)\n\t\treturn -1;\n\tif (!empty)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"dependences not strongly satisfied\", return -1);\n\n\treturn 0;\n}\n\n/* Compute a schedule for input where the instance set constraints\n * conflict with the context constraints.\n * Earlier versions of isl did not properly handle this situation.\n */\nstatic int test_conflicting_context_schedule(isl_ctx *ctx)\n{\n\tisl_union_map *schedule;\n\tconst char *domain, *context;\n\n\tdomain = \"[n] -> { A[] : n >= 0 }\";\n\tcontext = \"[n] -> { : n < 0 }\";\n\tschedule = compute_schedule_with_context(ctx,\n\t\t\t\t\t\tdomain, \"{}\", \"{}\", context);\n\tisl_union_map_free(schedule);\n\n\tif (!schedule)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that a set of schedule constraints that only allow for\n * a coalescing schedule still produces a schedule even if the user\n * request a non-coalescing schedule.  Earlier versions of isl\n * would not handle this case correctly.\n */\nstatic int test_coalescing_schedule(isl_ctx *ctx)\n{\n\tconst char *domain, *dep;\n\tisl_union_set *I;\n\tisl_union_map *D;\n\tisl_schedule_constraints *sc;\n\tisl_schedule *schedule;\n\tint treat_coalescing;\n\n\tdomain = \"{ S[a, b] : 0 <= a <= 1 and 0 <= b <= 1 }\";\n\tdep = \"{ S[a, b] -> S[a + b, 1 - b] }\";\n\tI = isl_union_set_read_from_str(ctx, domain);\n\tD = isl_union_map_read_from_str(ctx, dep);\n\tsc = isl_schedule_constraints_on_domain(I);\n\tsc = isl_schedule_constraints_set_validity(sc, D);\n\ttreat_coalescing = isl_options_get_schedule_treat_coalescing(ctx);\n\tisl_options_set_schedule_treat_coalescing(ctx, 1);\n\tschedule = isl_schedule_constraints_compute_schedule(sc);\n\tisl_options_set_schedule_treat_coalescing(ctx, treat_coalescing);\n\tisl_schedule_free(schedule);\n\tif (!schedule)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Check that the scheduler does not perform any needless\n * compound skewing.  Earlier versions of isl would compute\n * schedules in terms of transformed schedule coefficients and\n * would not accurately keep track of the sum of the original\n * schedule coefficients.  It could then produce the schedule\n * S[t,i,j,k] -> [t, 2t + i, 2t + i + j, 2t + i + j + k]\n * for the input below instead of the schedule below.\n */\nstatic int test_skewing_schedule(isl_ctx *ctx)\n{\n\tconst char *D, *V, *P, *S;\n\n\tD = \"[n] -> { S[t,i,j,k] : 0 <= t,i,j,k < n }\";\n\tV = \"[n] -> { S[t,i,j,k] -> S[t+1,a,b,c] : 0 <= t,i,j,k,a,b,c < n and \"\n\t\t\"-2 <= a-i <= 2 and -1 <= a-i + b-j <= 1 and \"\n\t\t\"-1 <= a-i + b-j + c-k <= 1 }\";\n\tP = \"{ }\";\n\tS = \"{ S[t,i,j,k] -> [t, 2t + i, t + i + j, 2t + k] }\";\n\n\treturn test_special_schedule(ctx, D, V, P, S);\n}\n\nint test_schedule(isl_ctx *ctx)\n{\n\tconst char *D, *W, *R, *V, *P, *S;\n\tint max_coincidence;\n\tint treat_coalescing;\n\n\t/* Handle resulting schedule with zero bands. */\n\tif (test_one_schedule(ctx, \"{[]}\", \"{}\", \"{}\", \"{[] -> []}\", 0, 0) < 0)\n\t\treturn -1;\n\n\t/* Jacobi */\n\tD = \"[T,N] -> { S1[t,i] : 1 <= t <= T and 2 <= i <= N - 1 }\";\n\tW = \"{ S1[t,i] -> a[t,i] }\";\n\tR = \"{ S1[t,i] -> a[t-1,i]; S1[t,i] -> a[t-1,i-1]; \"\n\t    \t\"S1[t,i] -> a[t-1,i+1] }\";\n\tS = \"{ S1[t,i] -> [t,i] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 2, 0) < 0)\n\t\treturn -1;\n\n\t/* Fig. 5 of CC2008 */\n\tD = \"[N] -> { S_0[i, j] : i >= 0 and i <= -1 + N and j >= 2 and \"\n\t\t\t\t\"j <= -1 + N }\";\n\tW = \"[N] -> { S_0[i, j] -> a[i, j] : i >= 0 and i <= -1 + N and \"\n\t\t\t\t\"j >= 2 and j <= -1 + N }\";\n\tR = \"[N] -> { S_0[i, j] -> a[j, i] : i >= 0 and i <= -1 + N and \"\n\t\t\t\t\"j >= 2 and j <= -1 + N; \"\n\t\t    \"S_0[i, j] -> a[i, -1 + j] : i >= 0 and i <= -1 + N and \"\n\t\t\t\t\"j >= 2 and j <= -1 + N }\";\n\tS = \"[N] -> { S_0[i, j] -> [0, i, 0, j, 0] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 2, 0) < 0)\n\t\treturn -1;\n\n\tD = \"{ S1[i] : 0 <= i <= 10; S2[i] : 0 <= i <= 9 }\";\n\tW = \"{ S1[i] -> a[i] }\";\n\tR = \"{ S2[i] -> a[i+1] }\";\n\tS = \"{ S1[i] -> [0,i]; S2[i] -> [1,i] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 1, 1) < 0)\n\t\treturn -1;\n\n\tD = \"{ S1[i] : 0 <= i < 10; S2[i] : 0 <= i < 10 }\";\n\tW = \"{ S1[i] -> a[i] }\";\n\tR = \"{ S2[i] -> a[9-i] }\";\n\tS = \"{ S1[i] -> [0,i]; S2[i] -> [1,i] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 1, 1) < 0)\n\t\treturn -1;\n\n\tD = \"[N] -> { S1[i] : 0 <= i < N; S2[i] : 0 <= i < N }\";\n\tW = \"{ S1[i] -> a[i] }\";\n\tR = \"[N] -> { S2[i] -> a[N-1-i] }\";\n\tS = \"{ S1[i] -> [0,i]; S2[i] -> [1,i] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 1, 1) < 0)\n\t\treturn -1;\n\t\n\tD = \"{ S1[i] : 0 < i < 10; S2[i] : 0 <= i < 10 }\";\n\tW = \"{ S1[i] -> a[i]; S2[i] -> b[i] }\";\n\tR = \"{ S2[i] -> a[i]; S1[i] -> b[i-1] }\";\n\tS = \"{ S1[i] -> [i,0]; S2[i] -> [i,1] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 0, 0) < 0)\n\t\treturn -1;\n\n\tD = \"[N] -> { S1[i] : 1 <= i <= N; S2[i,j] : 1 <= i,j <= N }\";\n\tW = \"{ S1[i] -> a[0,i]; S2[i,j] -> a[i,j] }\";\n\tR = \"{ S2[i,j] -> a[i-1,j] }\";\n\tS = \"{ S1[i] -> [0,i,0]; S2[i,j] -> [1,i,j] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 2, 1) < 0)\n\t\treturn -1;\n\n\tD = \"[N] -> { S1[i] : 1 <= i <= N; S2[i,j] : 1 <= i,j <= N }\";\n\tW = \"{ S1[i] -> a[i,0]; S2[i,j] -> a[i,j] }\";\n\tR = \"{ S2[i,j] -> a[i,j-1] }\";\n\tS = \"{ S1[i] -> [0,i,0]; S2[i,j] -> [1,i,j] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 2, 1) < 0)\n\t\treturn -1;\n\n\tD = \"[N] -> { S_0[]; S_1[i] : i >= 0 and i <= -1 + N; S_2[] }\";\n\tW = \"[N] -> { S_0[] -> a[0]; S_2[] -> b[0]; \"\n\t\t    \"S_1[i] -> a[1 + i] : i >= 0 and i <= -1 + N }\";\n\tR = \"[N] -> { S_2[] -> a[N]; S_1[i] -> a[i] : i >= 0 and i <= -1 + N }\";\n\tS = \"[N] -> { S_1[i] -> [1, i, 0]; S_2[] -> [2, 0, 1]; \"\n\t\t    \"S_0[] -> [0, 0, 0] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 1, 0) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_parametric = 0;\n\tif (test_one_schedule(ctx, D, W, R, S, 0, 0) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_parametric = 1;\n\n\tD = \"[N] -> { S1[i] : 1 <= i <= N; S2[i] : 1 <= i <= N; \"\n\t\t    \"S3[i,j] : 1 <= i,j <= N; S4[i] : 1 <= i <= N }\";\n\tW = \"{ S1[i] -> a[i,0]; S2[i] -> a[0,i]; S3[i,j] -> a[i,j] }\";\n\tR = \"[N] -> { S3[i,j] -> a[i-1,j]; S3[i,j] -> a[i,j-1]; \"\n\t\t    \"S4[i] -> a[i,N] }\";\n\tS = \"{ S1[i] -> [0,i,0]; S2[i] -> [1,i,0]; S3[i,j] -> [2,i,j]; \"\n\t\t\"S4[i] -> [4,i,0] }\";\n\tmax_coincidence = isl_options_get_schedule_maximize_coincidence(ctx);\n\tisl_options_set_schedule_maximize_coincidence(ctx, 0);\n\tif (test_one_schedule(ctx, D, W, R, S, 2, 0) < 0)\n\t\treturn -1;\n\tisl_options_set_schedule_maximize_coincidence(ctx, max_coincidence);\n\n\tD = \"[N] -> { S_0[i, j] : i >= 1 and i <= N and j >= 1 and j <= N }\";\n\tW = \"[N] -> { S_0[i, j] -> s[0] : i >= 1 and i <= N and j >= 1 and \"\n\t\t\t\t\t\"j <= N }\";\n\tR = \"[N] -> { S_0[i, j] -> s[0] : i >= 1 and i <= N and j >= 1 and \"\n\t\t\t\t\t\"j <= N; \"\n\t\t    \"S_0[i, j] -> a[i, j] : i >= 1 and i <= N and j >= 1 and \"\n\t\t\t\t\t\"j <= N }\";\n\tS = \"[N] -> { S_0[i, j] -> [0, i, 0, j, 0] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 0, 0) < 0)\n\t\treturn -1;\n\n\tD = \"[N] -> { S_0[t] : t >= 0 and t <= -1 + N; \"\n\t\t    \" S_2[t] : t >= 0 and t <= -1 + N; \"\n\t\t    \" S_1[t, i] : t >= 0 and t <= -1 + N and i >= 0 and \"\n\t\t\t\t\"i <= -1 + N }\";\n\tW = \"[N] -> { S_0[t] -> a[t, 0] : t >= 0 and t <= -1 + N; \"\n\t\t    \" S_2[t] -> b[t] : t >= 0 and t <= -1 + N; \"\n\t\t    \" S_1[t, i] -> a[t, 1 + i] : t >= 0 and t <= -1 + N and \"\n\t\t\t\t\t\t\"i >= 0 and i <= -1 + N }\";\n\tR = \"[N] -> { S_1[t, i] -> a[t, i] : t >= 0 and t <= -1 + N and \"\n\t\t\t\t\t    \"i >= 0 and i <= -1 + N; \"\n\t\t    \" S_2[t] -> a[t, N] : t >= 0 and t <= -1 + N }\";\n\tS = \"[N] -> { S_2[t] -> [0, t, 2]; S_1[t, i] -> [0, t, 1, i, 0]; \"\n\t\t    \" S_0[t] -> [0, t, 0] }\";\n\n\tif (test_one_schedule(ctx, D, W, R, S, 2, 1) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_parametric = 0;\n\tif (test_one_schedule(ctx, D, W, R, S, 0, 0) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_parametric = 1;\n\n\tD = \"[N] -> { S1[i,j] : 0 <= i,j < N; S2[i,j] : 0 <= i,j < N }\";\n\tS = \"{ S1[i,j] -> [0,i,j]; S2[i,j] -> [1,i,j] }\";\n\tif (test_one_schedule(ctx, D, \"{}\", \"{}\", S, 2, 2) < 0)\n\t\treturn -1;\n\n\tD = \"[M, N] -> { S_1[i] : i >= 0 and i <= -1 + M; \"\n\t    \"S_0[i, j] : i >= 0 and i <= -1 + M and j >= 0 and j <= -1 + N }\";\n\tW = \"[M, N] -> { S_0[i, j] -> a[j] : i >= 0 and i <= -1 + M and \"\n\t\t\t\t\t    \"j >= 0 and j <= -1 + N; \"\n\t\t\t\"S_1[i] -> b[0] : i >= 0 and i <= -1 + M }\";\n\tR = \"[M, N] -> { S_0[i, j] -> a[0] : i >= 0 and i <= -1 + M and \"\n\t\t\t\t\t    \"j >= 0 and j <= -1 + N; \"\n\t\t\t\"S_1[i] -> b[0] : i >= 0 and i <= -1 + M }\";\n\tS = \"[M, N] -> { S_1[i] -> [1, i, 0]; S_0[i, j] -> [0, i, 0, j, 0] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 0, 0) < 0)\n\t\treturn -1;\n\n\tD = \"{ S_0[i] : i >= 0 }\";\n\tW = \"{ S_0[i] -> a[i] : i >= 0 }\";\n\tR = \"{ S_0[i] -> a[0] : i >= 0 }\";\n\tS = \"{ S_0[i] -> [0, i, 0] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 0, 0) < 0)\n\t\treturn -1;\n\n\tD = \"{ S_0[i] : i >= 0; S_1[i] : i >= 0 }\";\n\tW = \"{ S_0[i] -> a[i] : i >= 0; S_1[i] -> b[i] : i >= 0 }\";\n\tR = \"{ S_0[i] -> b[0] : i >= 0; S_1[i] -> a[i] : i >= 0 }\";\n\tS = \"{ S_1[i] -> [0, i, 1]; S_0[i] -> [0, i, 0] }\";\n\tif (test_one_schedule(ctx, D, W, R, S, 0, 0) < 0)\n\t\treturn -1;\n\n\tD = \"[n] -> { S_0[j, k] : j <= -1 + n and j >= 0 and \"\n\t\t\t\t\"k <= -1 + n and k >= 0 }\";\n\tW = \"[n] -> { S_0[j, k] -> B[j] : j <= -1 + n and j >= 0 and \"\t\t\t\t\t\t\t\"k <= -1 + n and k >= 0 }\";\n\tR = \"[n] -> { S_0[j, k] -> B[j] : j <= -1 + n and j >= 0 and \"\n\t\t\t\t\t\"k <= -1 + n and k >= 0; \"\n\t\t    \"S_0[j, k] -> B[k] : j <= -1 + n and j >= 0 and \"\n\t\t\t\t\t\"k <= -1 + n and k >= 0; \"\n\t\t    \"S_0[j, k] -> A[k] : j <= -1 + n and j >= 0 and \"\n\t\t\t\t\t\"k <= -1 + n and k >= 0 }\";\n\tS = \"[n] -> { S_0[j, k] -> [2, j, k] }\";\n\tctx->opt->schedule_outer_coincidence = 1;\n\tif (test_one_schedule(ctx, D, W, R, S, 0, 0) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_outer_coincidence = 0;\n\n\tD = \"{Stmt_for_body24[i0, i1, i2, i3]:\"\n\t\t\"i0 >= 0 and i0 <= 1 and i1 >= 0 and i1 <= 6 and i2 >= 2 and \"\n\t\t\"i2 <= 6 - i1 and i3 >= 0 and i3 <= -1 + i2;\"\n\t     \"Stmt_for_body24[i0, i1, 1, 0]:\"\n\t\t\"i0 >= 0 and i0 <= 1 and i1 >= 0 and i1 <= 5;\"\n\t     \"Stmt_for_body7[i0, i1, i2]:\"\n\t\t\"i0 >= 0 and i0 <= 1 and i1 >= 0 and i1 <= 7 and i2 >= 0 and \"\n\t\t\"i2 <= 7 }\";\n\n\tV = \"{Stmt_for_body24[0, i1, i2, i3] -> \"\n\t\t\"Stmt_for_body24[1, i1, i2, i3]:\"\n\t\t\"i3 >= 0 and i3 <= -1 + i2 and i1 >= 0 and i2 <= 6 - i1 and \"\n\t\t\"i2 >= 1;\"\n\t     \"Stmt_for_body24[0, i1, i2, i3] -> \"\n\t\t\"Stmt_for_body7[1, 1 + i1 + i3, 1 + i1 + i2]:\"\n\t\t\"i3 <= -1 + i2 and i2 <= 6 - i1 and i2 >= 1 and i1 >= 0 and \"\n\t\t\"i3 >= 0;\"\n\t      \"Stmt_for_body24[0, i1, i2, i3] ->\"\n\t\t\"Stmt_for_body7[1, i1, 1 + i1 + i3]:\"\n\t\t\"i3 >= 0 and i2 <= 6 - i1 and i1 >= 0 and i3 <= -1 + i2;\"\n\t      \"Stmt_for_body7[0, i1, i2] -> Stmt_for_body7[1, i1, i2]:\"\n\t\t\"(i2 >= 1 + i1 and i2 <= 6 and i1 >= 0 and i1 <= 4) or \"\n\t\t\"(i2 >= 3 and i2 <= 7 and i1 >= 1 and i2 >= 1 + i1) or \"\n\t\t\"(i2 >= 0 and i2 <= i1 and i2 >= -7 + i1 and i1 <= 7);\"\n\t      \"Stmt_for_body7[0, i1, 1 + i1] -> Stmt_for_body7[1, i1, 1 + i1]:\"\n\t\t\"i1 <= 6 and i1 >= 0;\"\n\t      \"Stmt_for_body7[0, 0, 7] -> Stmt_for_body7[1, 0, 7];\"\n\t      \"Stmt_for_body7[i0, i1, i2] -> \"\n\t\t\"Stmt_for_body24[i0, o1, -1 + i2 - o1, -1 + i1 - o1]:\"\n\t\t\"i0 >= 0 and i0 <= 1 and o1 >= 0 and i2 >= 1 + i1 and \"\n\t\t\"o1 <= -2 + i2 and i2 <= 7 and o1 <= -1 + i1;\"\n\t      \"Stmt_for_body7[i0, i1, i2] -> \"\n\t\t\"Stmt_for_body24[i0, i1, o2, -1 - i1 + i2]:\"\n\t\t\"i0 >= 0 and i0 <= 1 and i1 >= 0 and o2 >= -i1 + i2 and \"\n\t\t\"o2 >= 1 and o2 <= 6 - i1 and i2 >= 1 + i1 }\";\n\tP = V;\n\n\ttreat_coalescing = isl_options_get_schedule_treat_coalescing(ctx);\n\tisl_options_set_schedule_treat_coalescing(ctx, 0);\n\tif (test_has_schedule(ctx, D, V, P) < 0)\n\t\treturn -1;\n\tisl_options_set_schedule_treat_coalescing(ctx, treat_coalescing);\n\n\tD = \"{ S_0[i, j] : i >= 1 and i <= 10 and j >= 1 and j <= 8 }\";\n\tV = \"{ S_0[i, j] -> S_0[i, 1 + j] : i >= 1 and i <= 10 and \"\n\t\t\t\t\t   \"j >= 1 and j <= 7;\"\n\t\t\"S_0[i, j] -> S_0[1 + i, j] : i >= 1 and i <= 9 and \"\n\t\t\t\t\t     \"j >= 1 and j <= 8 }\";\n\tP = \"{ }\";\n\tS = \"{ S_0[i, j] -> [i + j, i] }\";\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_FEAUTRIER;\n\tif (test_special_schedule(ctx, D, V, P, S) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_ISL;\n\n\t/* Fig. 1 from Feautrier's \"Some Efficient Solutions...\" pt. 2, 1992 */\n\tD = \"[N] -> { S_0[i, j] : i >= 0 and i <= -1 + N and \"\n\t\t\t\t \"j >= 0 and j <= -1 + i }\";\n\tV = \"[N] -> { S_0[i, j] -> S_0[i, 1 + j] : j <= -2 + i and \"\n\t\t\t\t\t\"i <= -1 + N and j >= 0;\"\n\t\t     \"S_0[i, -1 + i] -> S_0[1 + i, 0] : i >= 1 and \"\n\t\t\t\t\t\"i <= -2 + N }\";\n\tP = \"{ }\";\n\tS = \"{ S_0[i, j] -> [i, j] }\";\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_FEAUTRIER;\n\tif (test_special_schedule(ctx, D, V, P, S) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_ISL;\n\n\t/* Test both algorithms on a case with only proximity dependences. */\n\tD = \"{ S[i,j] : 0 <= i <= 10 }\";\n\tV = \"{ }\";\n\tP = \"{ S[i,j] -> S[i+1,j] : 0 <= i,j <= 10 }\";\n\tS = \"{ S[i, j] -> [j, i] }\";\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_FEAUTRIER;\n\tif (test_special_schedule(ctx, D, V, P, S) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_ISL;\n\tif (test_special_schedule(ctx, D, V, P, S) < 0)\n\t\treturn -1;\n\t\n\tD = \"{ A[a]; B[] }\";\n\tV = \"{}\";\n\tP = \"{ A[a] -> B[] }\";\n\tif (test_has_schedule(ctx, D, V, P) < 0)\n\t\treturn -1;\n\n\tif (test_padded_schedule(ctx) < 0)\n\t\treturn -1;\n\n\t/* Check that check for progress is not confused by rational\n\t * solution.\n\t */\n\tD = \"[N] -> { S0[i, j] : i >= 0 and i <= N and j >= 0 and j <= N }\";\n\tV = \"[N] -> { S0[i0, -1 + N] -> S0[2 + i0, 0] : i0 >= 0 and \"\n\t\t\t\t\t\t\t\"i0 <= -2 + N; \"\n\t\t\t\"S0[i0, i1] -> S0[i0, 1 + i1] : i0 >= 0 and \"\n\t\t\t\t\"i0 <= N and i1 >= 0 and i1 <= -1 + N }\";\n\tP = \"{}\";\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_FEAUTRIER;\n\tif (test_has_schedule(ctx, D, V, P) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_ISL;\n\n\t/* Check that we allow schedule rows that are only non-trivial\n\t * on some full-dimensional domains.\n\t */\n\tD = \"{ S1[j] : 0 <= j <= 1; S0[]; S2[k] : 0 <= k <= 1 }\";\n\tV = \"{ S0[] -> S1[j] : 0 <= j <= 1; S2[0] -> S0[];\"\n\t\t\"S1[j] -> S2[1] : 0 <= j <= 1 }\";\n\tP = \"{}\";\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_FEAUTRIER;\n\tif (test_has_schedule(ctx, D, V, P) < 0)\n\t\treturn -1;\n\tctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_ISL;\n\n\tif (test_conditional_schedule_constraints(ctx) < 0)\n\t\treturn -1;\n\n\tif (test_strongly_satisfying_schedule(ctx) < 0)\n\t\treturn -1;\n\n\tif (test_conflicting_context_schedule(ctx) < 0)\n\t\treturn -1;\n\n\tif (test_coalescing_schedule(ctx) < 0)\n\t\treturn -1;\n\tif (test_skewing_schedule(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Perform scheduling tests using the whole component scheduler.\n */\nstatic int test_schedule_whole(isl_ctx *ctx)\n{\n\tint whole;\n\tint r;\n\n\twhole = isl_options_get_schedule_whole_component(ctx);\n\tisl_options_set_schedule_whole_component(ctx, 1);\n\tr = test_schedule(ctx);\n\tisl_options_set_schedule_whole_component(ctx, whole);\n\n\treturn r;\n}\n\n/* Perform scheduling tests using the incremental scheduler.\n */\nstatic int test_schedule_incremental(isl_ctx *ctx)\n{\n\tint whole;\n\tint r;\n\n\twhole = isl_options_get_schedule_whole_component(ctx);\n\tisl_options_set_schedule_whole_component(ctx, 0);\n\tr = test_schedule(ctx);\n\tisl_options_set_schedule_whole_component(ctx, whole);\n\n\treturn r;\n}\n\nint test_plain_injective(isl_ctx *ctx, const char *str, int injective)\n{\n\tisl_union_map *umap;\n\tint test;\n\n\tumap = isl_union_map_read_from_str(ctx, str);\n\ttest = isl_union_map_plain_is_injective(umap);\n\tisl_union_map_free(umap);\n\tif (test < 0)\n\t\treturn -1;\n\tif (test == injective)\n\t\treturn 0;\n\tif (injective)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"map not detected as injective\", return -1);\n\telse\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"map detected as injective\", return -1);\n}\n\nint test_injective(isl_ctx *ctx)\n{\n\tconst char *str;\n\n\tif (test_plain_injective(ctx, \"{S[i,j] -> A[0]; T[i,j] -> B[1]}\", 0))\n\t\treturn -1;\n\tif (test_plain_injective(ctx, \"{S[] -> A[0]; T[] -> B[0]}\", 1))\n\t\treturn -1;\n\tif (test_plain_injective(ctx, \"{S[] -> A[0]; T[] -> A[1]}\", 1))\n\t\treturn -1;\n\tif (test_plain_injective(ctx, \"{S[] -> A[0]; T[] -> A[0]}\", 0))\n\t\treturn -1;\n\tif (test_plain_injective(ctx, \"{S[i] -> A[i,0]; T[i] -> A[i,1]}\", 1))\n\t\treturn -1;\n\tif (test_plain_injective(ctx, \"{S[i] -> A[i]; T[i] -> A[i]}\", 0))\n\t\treturn -1;\n\tif (test_plain_injective(ctx, \"{S[] -> A[0,0]; T[] -> A[0,1]}\", 1))\n\t\treturn -1;\n\tif (test_plain_injective(ctx, \"{S[] -> A[0,0]; T[] -> A[1,0]}\", 1))\n\t\treturn -1;\n\n\tstr = \"{S[] -> A[0,0]; T[] -> A[0,1]; U[] -> A[1,0]}\";\n\tif (test_plain_injective(ctx, str, 1))\n\t\treturn -1;\n\tstr = \"{S[] -> A[0,0]; T[] -> A[0,1]; U[] -> A[0,0]}\";\n\tif (test_plain_injective(ctx, str, 0))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n#undef BASE\n#define BASE\taff\n#include \"isl_test_plain_equal_templ.c\"\n\n#undef BASE\n#define BASE\tpw_multi_aff\n#include \"isl_test_plain_equal_templ.c\"\n\n#undef BASE\n#define BASE\tunion_pw_aff\n#include \"isl_test_plain_equal_templ.c\"\n\n/* Basic tests on isl_union_pw_aff.\n *\n * In particular, check that isl_union_pw_aff_aff_on_domain\n * aligns the parameters of the input objects and\n * that isl_union_pw_aff_param_on_domain_id properly\n * introduces the parameter.\n */\nstatic int test_upa(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_id *id;\n\tisl_aff *aff;\n\tisl_union_set *domain;\n\tisl_union_pw_aff *upa;\n\tisl_stat ok;\n\n\taff = isl_aff_read_from_str(ctx, \"[N] -> { [N] }\");\n\tstr = \"[M] -> { A[i] : 0 <= i < M; B[] }\";\n\tdomain = isl_union_set_read_from_str(ctx, str);\n\tupa = isl_union_pw_aff_aff_on_domain(domain, aff);\n\tstr = \"[N, M] -> { A[i] -> [N] : 0 <= i < M; B[] -> [N] }\";\n\tok = union_pw_aff_check_plain_equal(upa, str);\n\tisl_union_pw_aff_free(upa);\n\tif (ok < 0)\n\t\treturn -1;\n\n\tid = isl_id_alloc(ctx, \"N\", NULL);\n\tstr = \"[M] -> { A[i] : 0 <= i < M; B[] }\";\n\tdomain = isl_union_set_read_from_str(ctx, str);\n\tupa = isl_union_pw_aff_param_on_domain_id(domain, id);\n\tstr = \"[N, M] -> { A[i] -> [N] : 0 <= i < M; B[] -> [N] }\";\n\tok = union_pw_aff_check_plain_equal(upa, str);\n\tisl_union_pw_aff_free(upa);\n\tif (ok < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct {\n\t__isl_give isl_aff *(*fn)(__isl_take isl_aff *aff1,\n\t\t\t\t__isl_take isl_aff *aff2);\n} aff_bin_op[] = {\n\t['+'] = { &isl_aff_add },\n\t['-'] = { &isl_aff_sub },\n\t['*'] = { &isl_aff_mul },\n\t['/'] = { &isl_aff_div },\n};\n\nstruct {\n\tconst char *arg1;\n\tunsigned char op;\n\tconst char *arg2;\n\tconst char *res;\n} aff_bin_tests[] = {\n\t{ \"{ [i] -> [i] }\", '+', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [2i] }\" },\n\t{ \"{ [i] -> [i] }\", '-', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [0] }\" },\n\t{ \"{ [i] -> [i] }\", '*', \"{ [i] -> [2] }\",\n\t  \"{ [i] -> [2i] }\" },\n\t{ \"{ [i] -> [2] }\", '*', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [2i] }\" },\n\t{ \"{ [i] -> [i] }\", '/', \"{ [i] -> [2] }\",\n\t  \"{ [i] -> [i/2] }\" },\n\t{ \"{ [i] -> [2i] }\", '/', \"{ [i] -> [2] }\",\n\t  \"{ [i] -> [i] }\" },\n\t{ \"{ [i] -> [i] }\", '+', \"{ [i] -> [NaN] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [i] }\", '-', \"{ [i] -> [NaN] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [i] }\", '*', \"{ [i] -> [NaN] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [2] }\", '*', \"{ [i] -> [NaN] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [i] }\", '/', \"{ [i] -> [NaN] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [2] }\", '/', \"{ [i] -> [NaN] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [NaN] }\", '+', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [NaN] }\", '-', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [NaN] }\", '*', \"{ [i] -> [2] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [NaN] }\", '*', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [NaN] }\", '/', \"{ [i] -> [2] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [NaN] }\", '/', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [i] }\", '/', \"{ [i] -> [0] }\",\n\t  \"{ [i] -> [NaN] }\" },\n};\n\n/* Perform some basic tests of binary operations on isl_aff objects.\n */\nstatic int test_bin_aff(isl_ctx *ctx)\n{\n\tint i;\n\tisl_aff *aff1, *aff2, *res;\n\t__isl_give isl_aff *(*fn)(__isl_take isl_aff *aff1,\n\t\t\t\t__isl_take isl_aff *aff2);\n\tint ok;\n\n\tfor (i = 0; i < ARRAY_SIZE(aff_bin_tests); ++i) {\n\t\taff1 = isl_aff_read_from_str(ctx, aff_bin_tests[i].arg1);\n\t\taff2 = isl_aff_read_from_str(ctx, aff_bin_tests[i].arg2);\n\t\tres = isl_aff_read_from_str(ctx, aff_bin_tests[i].res);\n\t\tfn = aff_bin_op[aff_bin_tests[i].op].fn;\n\t\taff1 = fn(aff1, aff2);\n\t\tif (isl_aff_is_nan(res))\n\t\t\tok = isl_aff_is_nan(aff1);\n\t\telse\n\t\t\tok = isl_aff_plain_is_equal(aff1, res);\n\t\tisl_aff_free(aff1);\n\t\tisl_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\t__isl_give isl_pw_aff *(*fn)(__isl_take isl_pw_aff *pa1,\n\t\t\t\t     __isl_take isl_pw_aff *pa2);\n} pw_aff_bin_op[] = {\n\t['m'] = { &isl_pw_aff_min },\n\t['M'] = { &isl_pw_aff_max },\n};\n\n/* Inputs for binary isl_pw_aff operation tests.\n * \"arg1\" and \"arg2\" are the two arguments, \"op\" identifies the operation\n * defined by pw_aff_bin_op, and \"res\" is the expected result.\n */\nstruct {\n\tconst char *arg1;\n\tunsigned char op;\n\tconst char *arg2;\n\tconst char *res;\n} pw_aff_bin_tests[] = {\n\t{ \"{ [i] -> [i] }\", 'm', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [i] }\" },\n\t{ \"{ [i] -> [i] }\", 'M', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [i] }\" },\n\t{ \"{ [i] -> [i] }\", 'm', \"{ [i] -> [0] }\",\n\t  \"{ [i] -> [i] : i <= 0; [i] -> [0] : i > 0 }\" },\n\t{ \"{ [i] -> [i] }\", 'M', \"{ [i] -> [0] }\",\n\t  \"{ [i] -> [i] : i >= 0; [i] -> [0] : i < 0 }\" },\n\t{ \"{ [i] -> [i] }\", 'm', \"{ [i] -> [NaN] }\",\n\t  \"{ [i] -> [NaN] }\" },\n\t{ \"{ [i] -> [NaN] }\", 'm', \"{ [i] -> [i] }\",\n\t  \"{ [i] -> [NaN] }\" },\n};\n\n/* Perform some basic tests of binary operations on isl_pw_aff objects.\n */\nstatic int test_bin_pw_aff(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_pw_aff *pa1, *pa2, *res;\n\n\tfor (i = 0; i < ARRAY_SIZE(pw_aff_bin_tests); ++i) {\n\t\tpa1 = isl_pw_aff_read_from_str(ctx, pw_aff_bin_tests[i].arg1);\n\t\tpa2 = isl_pw_aff_read_from_str(ctx, pw_aff_bin_tests[i].arg2);\n\t\tres = isl_pw_aff_read_from_str(ctx, pw_aff_bin_tests[i].res);\n\t\tpa1 = pw_aff_bin_op[pw_aff_bin_tests[i].op].fn(pa1, pa2);\n\t\tif (isl_pw_aff_involves_nan(res))\n\t\t\tok = isl_pw_aff_involves_nan(pa1);\n\t\telse\n\t\t\tok = isl_pw_aff_plain_is_equal(pa1, res);\n\t\tisl_pw_aff_free(pa1);\n\t\tisl_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of test operations on\n * isl_union_pw_multi_aff objects.\n * \"fn\" is the function that is being tested.\n * \"arg\" is a string description of the input.\n * \"res\" is the expected result.\n */\nstatic struct {\n\tisl_bool (*fn)(__isl_keep isl_union_pw_multi_aff *upma1);\n\tconst char *arg;\n\tisl_bool res;\n} upma_test_tests[] = {\n\t{ &isl_union_pw_multi_aff_involves_nan, \"{ A[] -> [0]; B[0] -> [1] }\",\n\t  isl_bool_false },\n\t{ &isl_union_pw_multi_aff_involves_nan, \"{ A[] -> [NaN]; B[0] -> [1] }\",\n\t  isl_bool_true },\n\t{ &isl_union_pw_multi_aff_involves_nan, \"{ A[] -> [0]; B[0] -> [NaN] }\",\n\t  isl_bool_true },\n\t{ &isl_union_pw_multi_aff_involves_nan,\n\t  \"{ A[] -> [0]; B[0] -> [1, NaN, 5] }\",\n\t  isl_bool_true },\n\t{ &isl_union_pw_multi_aff_involves_locals,\n\t  \"{ A[] -> [0]; B[0] -> [1] }\",\n\t  isl_bool_false },\n\t{ &isl_union_pw_multi_aff_involves_locals,\n\t  \"{ A[] -> [0]; B[x] -> [1] : x mod 2 = 0 }\",\n\t  isl_bool_true },\n\t{ &isl_union_pw_multi_aff_involves_locals,\n\t  \"{ A[] -> [0]; B[x] -> [x // 2] }\",\n\t  isl_bool_true },\n\t{ &isl_union_pw_multi_aff_involves_locals,\n\t  \"{ A[i] -> [i // 2]; B[0] -> [1] }\",\n\t  isl_bool_true },\n};\n\n/* Perform some basic tests of test operations on\n * isl_union_pw_multi_aff objects.\n */\nstatic isl_stat test_upma_test(isl_ctx *ctx)\n{\n\tint i;\n\tisl_union_pw_multi_aff *upma;\n\tisl_bool res;\n\n\tfor (i = 0; i < ARRAY_SIZE(upma_test_tests); ++i) {\n\t\tconst char *str;\n\n\t\tstr = upma_test_tests[i].arg;\n\t\tupma = isl_union_pw_multi_aff_read_from_str(ctx, str);\n\t\tres = upma_test_tests[i].fn(upma);\n\t\tisl_union_pw_multi_aff_free(upma);\n\t\tif (res < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (res != upma_test_tests[i].res)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return isl_stat_error);\n\t}\n\n\treturn isl_stat_ok;\n}\n\nstruct {\n\t__isl_give isl_union_pw_multi_aff *(*fn)(\n\t\t__isl_take isl_union_pw_multi_aff *upma1,\n\t\t__isl_take isl_union_pw_multi_aff *upma2);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} upma_bin_tests[] = {\n\t{ &isl_union_pw_multi_aff_add, \"{ A[] -> [0]; B[0] -> [1] }\",\n\t  \"{ B[x] -> [2] : x >= 0 }\", \"{ B[0] -> [3] }\" },\n\t{ &isl_union_pw_multi_aff_union_add, \"{ A[] -> [0]; B[0] -> [1] }\",\n\t  \"{ B[x] -> [2] : x >= 0 }\",\n\t  \"{ A[] -> [0]; B[0] -> [3]; B[x] -> [2] : x >= 1 }\" },\n\t{ &isl_union_pw_multi_aff_pullback_union_pw_multi_aff,\n\t  \"{ A[] -> B[0]; C[x] -> B[1] : x < 10; C[y] -> B[2] : y >= 10 }\",\n\t  \"{ D[i] -> A[] : i < 0; D[i] -> C[i + 5] : i >= 0 }\",\n\t  \"{ D[i] -> B[0] : i < 0; D[i] -> B[1] : 0 <= i < 5; \"\n\t    \"D[i] -> B[2] : i >= 5 }\" },\n\t{ &isl_union_pw_multi_aff_union_add, \"{ B[x] -> A[1] : x <= 0 }\",\n\t  \"{ B[x] -> C[2] : x > 0 }\",\n\t  \"{ B[x] -> A[1] : x <= 0; B[x] -> C[2] : x > 0 }\" },\n\t{ &isl_union_pw_multi_aff_union_add, \"{ B[x] -> A[1] : x <= 0 }\",\n\t  \"{ B[x] -> A[2] : x >= 0 }\",\n\t  \"{ B[x] -> A[1] : x < 0; B[x] -> A[2] : x > 0; B[0] -> A[3] }\" },\n\t{\n  &isl_union_pw_multi_aff_preimage_domain_wrapped_domain_union_pw_multi_aff,\n\t  \"{ B[x] -> C[x + 2] }\",\n\t  \"{ D[y] -> B[2y] }\",\n\t  \"{ }\" },\n\t{\n  &isl_union_pw_multi_aff_preimage_domain_wrapped_domain_union_pw_multi_aff,\n\t  \"{ [A[x] -> B[x + 1]] -> C[x + 2] }\",\n\t  \"{ D[y] -> B[2y] }\",\n\t  \"{ }\" },\n\t{\n  &isl_union_pw_multi_aff_preimage_domain_wrapped_domain_union_pw_multi_aff,\n\t  \"{ [A[x] -> B[x + 1]] -> C[x + 2]; B[x] -> C[x + 2] }\",\n\t  \"{ D[y] -> A[2y] }\",\n\t  \"{ [D[y] -> B[2y + 1]] -> C[2y + 2] }\" },\n\t{\n  &isl_union_pw_multi_aff_preimage_domain_wrapped_domain_union_pw_multi_aff,\n\t  \"{ T[A[x] -> B[x + 1]] -> C[x + 2]; B[x] -> C[x + 2] }\",\n\t  \"{ D[y] -> A[2y] }\",\n\t  \"{ T[D[y] -> B[2y + 1]] -> C[2y + 2] }\" },\n};\n\n/* Perform some basic tests of binary operations on\n * isl_union_pw_multi_aff objects.\n */\nstatic int test_bin_upma(isl_ctx *ctx)\n{\n\tint i;\n\tisl_union_pw_multi_aff *upma1, *upma2, *res;\n\tint ok;\n\n\tfor (i = 0; i < ARRAY_SIZE(upma_bin_tests); ++i) {\n\t\tupma1 = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tupma_bin_tests[i].arg1);\n\t\tupma2 = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tupma_bin_tests[i].arg2);\n\t\tres = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tupma_bin_tests[i].res);\n\t\tupma1 = upma_bin_tests[i].fn(upma1, upma2);\n\t\tok = isl_union_pw_multi_aff_plain_is_equal(upma1, res);\n\t\tisl_union_pw_multi_aff_free(upma1);\n\t\tisl_union_pw_multi_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\t__isl_give isl_union_pw_multi_aff *(*fn)(\n\t\t__isl_take isl_union_pw_multi_aff *upma1,\n\t\t__isl_take isl_union_pw_multi_aff *upma2);\n\tconst char *arg1;\n\tconst char *arg2;\n} upma_bin_fail_tests[] = {\n\t{ &isl_union_pw_multi_aff_union_add, \"{ B[x] -> A[1] : x <= 0 }\",\n\t  \"{ B[x] -> C[2] : x >= 0 }\" },\n};\n\n/* Perform some basic tests of binary operations on\n * isl_union_pw_multi_aff objects that are expected to fail.\n */\nstatic int test_bin_upma_fail(isl_ctx *ctx)\n{\n\tint i, n;\n\tisl_union_pw_multi_aff *upma1, *upma2;\n\tint on_error;\n\n\ton_error = isl_options_get_on_error(ctx);\n\tisl_options_set_on_error(ctx, ISL_ON_ERROR_CONTINUE);\n\tn = ARRAY_SIZE(upma_bin_fail_tests);\n\tfor (i = 0; i < n; ++i) {\n\t\tupma1 = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\tupma_bin_fail_tests[i].arg1);\n\t\tupma2 = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\tupma_bin_fail_tests[i].arg2);\n\t\tupma1 = upma_bin_fail_tests[i].fn(upma1, upma2);\n\t\tisl_union_pw_multi_aff_free(upma1);\n\t\tif (upma1)\n\t\t\tbreak;\n\t}\n\tisl_options_set_on_error(ctx, on_error);\n\tif (i < n)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"operation not expected to succeed\", return -1);\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on\n * pairs of isl_union_pw_multi_aff and isl_union_set objects.\n * \"fn\" is the function that is being tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_union_pw_multi_aff *(*fn)(\n\t\t__isl_take isl_union_pw_multi_aff *upma,\n\t\t__isl_take isl_union_set *uset);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} upma_uset_tests[] = {\n\t{ &isl_union_pw_multi_aff_intersect_domain_wrapped_range,\n\t  \"{ A[i] -> B[i] }\", \"{ B[0] }\",\n\t  \"{ }\" },\n\t{ &isl_union_pw_multi_aff_intersect_domain_wrapped_domain,\n\t  \"{ [A[i] -> B[i]] -> C[i + 1] }\", \"{ A[1]; B[0] }\",\n\t  \"{ [A[1] -> B[1]] -> C[2] }\" },\n\t{ &isl_union_pw_multi_aff_intersect_domain_wrapped_range,\n\t  \"{ [A[i] -> B[i]] -> C[i + 1] }\", \"{ A[1]; B[0] }\",\n\t  \"{ [A[0] -> B[0]] -> C[1] }\" },\n\t{ &isl_union_pw_multi_aff_intersect_domain_wrapped_range,\n\t  \"{ [A[i] -> B[i]] -> C[i + 1] }\", \"[N] -> { B[N] }\",\n\t  \"[N] -> { [A[N] -> B[N]] -> C[N + 1] }\" },\n\t{ &isl_union_pw_multi_aff_intersect_domain_wrapped_range,\n\t  \"[M] -> { [A[M] -> B[M]] -> C[M + 1] }\", \"[N] -> { B[N] }\",\n\t  \"[N, M] -> { [A[N] -> B[N]] -> C[N + 1] : N = M }\" },\n\t{ &isl_union_pw_multi_aff_intersect_domain_wrapped_range,\n\t  \"{ [A[] -> B[]] -> C[]; N[A[] -> B[]] -> D[]; [B[] -> A[]] -> E[] }\",\n\t  \"{ B[] }\",\n\t  \"{ [A[] -> B[]] -> C[]; N[A[] -> B[]] -> D[] }\" },\n};\n\n/* Perform some basic tests of binary operations on\n * pairs of isl_union_pw_multi_aff and isl_union_set objects.\n */\nstatic isl_stat test_upma_uset(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_union_pw_multi_aff *upma, *res;\n\tisl_union_set *uset;\n\n\tfor (i = 0; i < ARRAY_SIZE(upma_uset_tests); ++i) {\n\t\tupma = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\t    upma_uset_tests[i].arg1);\n\t\tuset = isl_union_set_read_from_str(ctx,\n\t\t\t\t\t\t    upma_uset_tests[i].arg2);\n\t\tres = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\t    upma_uset_tests[i].res);\n\t\tupma = upma_uset_tests[i].fn(upma, uset);\n\t\tok = isl_union_pw_multi_aff_plain_is_equal(upma, res);\n\t\tisl_union_pw_multi_aff_free(upma);\n\t\tisl_union_pw_multi_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return isl_stat_error);\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for basic tests of unary operations on isl_multi_pw_aff objects.\n * \"fn\" is the function that is tested.\n * \"arg\" is a string description of the input.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_pw_aff *(*fn)(__isl_take isl_multi_pw_aff *mpa);\n\tconst char *arg;\n\tconst char *res;\n} mpa_un_tests[] = {\n\t{ &isl_multi_pw_aff_range_factor_domain,\n\t  \"{ A[x] -> [B[(1 : x >= 5)] -> C[(2 : x <= 10)]] }\",\n\t  \"{ A[x] -> B[(1 : x >= 5)] }\" },\n\t{ &isl_multi_pw_aff_range_factor_range,\n\t  \"{ A[x] -> [B[(1 : x >= 5)] -> C[(2 : x <= 10)]] }\",\n\t  \"{ A[y] -> C[(2 : y <= 10)] }\" },\n\t{ &isl_multi_pw_aff_range_factor_domain,\n\t  \"{ A[x] -> [B[(1 : x >= 5)] -> C[]] }\",\n\t  \"{ A[x] -> B[(1 : x >= 5)] }\" },\n\t{ &isl_multi_pw_aff_range_factor_range,\n\t  \"{ A[x] -> [B[(1 : x >= 5)] -> C[]] }\",\n\t  \"{ A[y] -> C[] }\" },\n\t{ &isl_multi_pw_aff_range_factor_domain,\n\t  \"{ A[x] -> [B[] -> C[(2 : x <= 10)]] }\",\n\t  \"{ A[x] -> B[] }\" },\n\t{ &isl_multi_pw_aff_range_factor_range,\n\t  \"{ A[x] -> [B[] -> C[(2 : x <= 10)]] }\",\n\t  \"{ A[y] -> C[(2 : y <= 10)] }\" },\n\t{ &isl_multi_pw_aff_range_factor_domain,\n\t  \"{ A[x] -> [B[] -> C[]] }\",\n\t  \"{ A[x] -> B[] }\" },\n\t{ &isl_multi_pw_aff_range_factor_range,\n\t  \"{ A[x] -> [B[] -> C[]] }\",\n\t  \"{ A[y] -> C[] }\" },\n\t{ &isl_multi_pw_aff_factor_range,\n\t  \"{ [B[] -> C[]] }\",\n\t  \"{ C[] }\" },\n\t{ &isl_multi_pw_aff_range_factor_domain,\n\t  \"{ A[x] -> [B[] -> C[]] : x >= 0 }\",\n\t  \"{ A[x] -> B[] : x >= 0 }\" },\n\t{ &isl_multi_pw_aff_range_factor_range,\n\t  \"{ A[x] -> [B[] -> C[]] : x >= 0 }\",\n\t  \"{ A[y] -> C[] : y >= 0 }\" },\n\t{ &isl_multi_pw_aff_factor_range,\n\t  \"[N] -> { [B[] -> C[]] : N >= 0 }\",\n\t  \"[N] -> { C[] : N >= 0 }\" },\n};\n\n/* Perform some basic tests of unary operations on isl_multi_pw_aff objects.\n */\nstatic int test_un_mpa(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_pw_aff *mpa, *res;\n\n\tfor (i = 0; i < ARRAY_SIZE(mpa_un_tests); ++i) {\n\t\tmpa = isl_multi_pw_aff_read_from_str(ctx, mpa_un_tests[i].arg);\n\t\tres = isl_multi_pw_aff_read_from_str(ctx, mpa_un_tests[i].res);\n\t\tmpa = mpa_un_tests[i].fn(mpa);\n\t\tok = isl_multi_pw_aff_plain_is_equal(mpa, res);\n\t\tisl_multi_pw_aff_free(mpa);\n\t\tisl_multi_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on isl_multi_pw_aff objects.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_pw_aff *mpa1,\n\t\t__isl_take isl_multi_pw_aff *mpa2);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} mpa_bin_tests[] = {\n\t{ &isl_multi_pw_aff_add, \"{ A[] -> [1] }\", \"{ A[] -> [2] }\",\n\t  \"{ A[] -> [3] }\" },\n\t{ &isl_multi_pw_aff_add, \"{ A[x] -> [(1 : x >= 5)] }\",\n\t  \"{ A[x] -> [(x : x <= 10)] }\",\n\t  \"{ A[x] -> [(1 + x : 5 <= x <= 10)] }\" },\n\t{ &isl_multi_pw_aff_add, \"{ A[x] -> [] : x >= 5 }\",\n\t  \"{ A[x] -> [] : x <= 10 }\",\n\t  \"{ A[x] -> [] : 5 <= x <= 10 }\" },\n\t{ &isl_multi_pw_aff_add, \"{ A[x] -> [] : x >= 5 }\",\n\t  \"[N] -> { A[x] -> [] : x <= N }\",\n\t  \"[N] -> { A[x] -> [] : 5 <= x <= N }\" },\n\t{ &isl_multi_pw_aff_add,\n\t  \"[N] -> { A[x] -> [] : x <= N }\",\n\t  \"{ A[x] -> [] : x >= 5 }\",\n\t  \"[N] -> { A[x] -> [] : 5 <= x <= N }\" },\n\t{ &isl_multi_pw_aff_range_product, \"{ A[x] -> B[(1 : x >= 5)] }\",\n\t  \"{ A[y] -> C[(2 : y <= 10)] }\",\n\t  \"{ A[x] -> [B[(1 : x >= 5)] -> C[(2 : x <= 10)]] }\" },\n\t{ &isl_multi_pw_aff_range_product, \"{ A[x] -> B[1] : x >= 5 }\",\n\t  \"{ A[y] -> C[2] : y <= 10 }\",\n\t  \"{ A[x] -> [B[(1 : x >= 5)] -> C[(2 : x <= 10)]] }\" },\n\t{ &isl_multi_pw_aff_range_product, \"{ A[x] -> B[1] : x >= 5 }\",\n\t  \"[N] -> { A[y] -> C[2] : y <= N }\",\n\t  \"[N] -> { A[x] -> [B[(1 : x >= 5)] -> C[(2 : x <= N)]] }\" },\n\t{ &isl_multi_pw_aff_range_product, \"[N] -> { A[x] -> B[1] : x >= N }\",\n\t  \"{ A[y] -> C[2] : y <= 10 }\",\n\t  \"[N] -> { A[x] -> [B[(1 : x >= N)] -> C[(2 : x <= 10)]] }\" },\n\t{ &isl_multi_pw_aff_range_product, \"{ A[] -> B[1] }\", \"{ A[] -> C[2] }\",\n\t  \"{ A[] -> [B[1] -> C[2]] }\" },\n\t{ &isl_multi_pw_aff_range_product, \"{ A[] -> B[] }\", \"{ A[] -> C[] }\",\n\t  \"{ A[] -> [B[] -> C[]] }\" },\n\t{ &isl_multi_pw_aff_range_product, \"{ A[x] -> B[(1 : x >= 5)] }\",\n\t  \"{ A[y] -> C[] : y <= 10 }\",\n\t  \"{ A[x] -> [B[(1 : x >= 5)] -> C[]] : x <= 10 }\" },\n\t{ &isl_multi_pw_aff_range_product, \"{ A[y] -> C[] : y <= 10 }\",\n\t  \"{ A[x] -> B[(1 : x >= 5)] }\",\n\t  \"{ A[x] -> [C[] -> B[(1 : x >= 5)]] : x <= 10 }\" },\n\t{ &isl_multi_pw_aff_product, \"{ A[x] -> B[(1 : x >= 5)] }\",\n\t  \"{ A[y] -> C[(2 : y <= 10)] }\",\n\t  \"{ [A[x] -> A[y]] -> [B[(1 : x >= 5)] -> C[(2 : y <= 10)]] }\" },\n\t{ &isl_multi_pw_aff_product, \"{ A[x] -> B[(1 : x >= 5)] }\",\n\t  \"{ A[y] -> C[] : y <= 10 }\",\n\t  \"{ [A[x] -> A[y]] -> [B[(1 : x >= 5)] -> C[]] : y <= 10 }\" },\n\t{ &isl_multi_pw_aff_product, \"{ A[y] -> C[] : y <= 10 }\",\n\t  \"{ A[x] -> B[(1 : x >= 5)] }\",\n\t  \"{ [A[y] -> A[x]] -> [C[] -> B[(1 : x >= 5)]] : y <= 10 }\" },\n\t{ &isl_multi_pw_aff_product, \"{ A[x] -> B[(1 : x >= 5)] }\",\n\t  \"[N] -> { A[y] -> C[] : y <= N }\",\n\t  \"[N] -> { [A[x] -> A[y]] -> [B[(1 : x >= 5)] -> C[]] : y <= N }\" },\n\t{ &isl_multi_pw_aff_product, \"[N] -> { A[y] -> C[] : y <= N }\",\n\t  \"{ A[x] -> B[(1 : x >= 5)] }\",\n\t  \"[N] -> { [A[y] -> A[x]] -> [C[] -> B[(1 : x >= 5)]] : y <= N }\" },\n\t{ &isl_multi_pw_aff_product, \"{ A[x] -> B[] : x >= 5 }\",\n\t  \"{ A[y] -> C[] : y <= 10 }\",\n\t  \"{ [A[x] -> A[y]] -> [B[] -> C[]] : x >= 5 and y <= 10 }\" },\n\t{ &isl_multi_pw_aff_product, \"{ A[] -> B[1] }\", \"{ A[] -> C[2] }\",\n\t  \"{ [A[] -> A[]] -> [B[1] -> C[2]] }\" },\n\t{ &isl_multi_pw_aff_product, \"{ A[] -> B[] }\", \"{ A[] -> C[] }\",\n\t  \"{ [A[] -> A[]] -> [B[] -> C[]] }\" },\n\t{ &isl_multi_pw_aff_pullback_multi_pw_aff,\n\t  \"{ B[i,j] -> C[i + 2j] }\", \"{ A[a,b] -> B[b,a] }\",\n\t  \"{ A[a,b] -> C[b + 2a] }\" },\n\t{ &isl_multi_pw_aff_pullback_multi_pw_aff,\n\t  \"{ B[i,j] -> C[i + 2j] }\",\n\t  \"{ A[a,b] -> B[(b : b > a),(a : b > a)] }\",\n\t  \"{ A[a,b] -> C[(b + 2a : b > a)] }\" },\n\t{ &isl_multi_pw_aff_pullback_multi_pw_aff,\n\t  \"{ B[i,j] -> C[(i + 2j : j > 4)] }\",\n\t  \"{ A[a,b] -> B[(b : b > a),(a : b > a)] }\",\n\t  \"{ A[a,b] -> C[(b + 2a : b > a > 4)] }\" },\n\t{ &isl_multi_pw_aff_pullback_multi_pw_aff,\n\t  \"{ B[i,j] -> C[] }\",\n\t  \"{ A[a,b] -> B[(b : b > a),(a : b > a)] }\",\n\t  \"{ A[a,b] -> C[] }\" },\n\t{ &isl_multi_pw_aff_pullback_multi_pw_aff,\n\t  \"{ B[i,j] -> C[] : i > j }\",\n\t  \"{ A[a,b] -> B[b,a] }\",\n\t  \"{ A[a,b] -> C[] : b > a }\" },\n\t{ &isl_multi_pw_aff_pullback_multi_pw_aff,\n\t  \"{ B[i,j] -> C[] : j > 5 }\",\n\t  \"{ A[a,b] -> B[(b : b > a),(a : b > a)] }\",\n\t  \"{ A[a,b] -> C[] : b > a > 5 }\" },\n\t{ &isl_multi_pw_aff_pullback_multi_pw_aff,\n\t  \"[N] -> { B[i,j] -> C[] : j > N }\",\n\t  \"{ A[a,b] -> B[(b : b > a),(a : b > a)] }\",\n\t  \"[N] -> { A[a,b] -> C[] : b > a > N }\" },\n\t{ &isl_multi_pw_aff_pullback_multi_pw_aff,\n\t  \"[M,N] -> { B[] -> C[] : N > 5 }\",\n\t  \"[M,N] -> { A[] -> B[] : M > N }\",\n\t  \"[M,N] -> { A[] -> C[] : M > N > 5 }\" },\n};\n\n/* Perform some basic tests of binary operations on isl_multi_pw_aff objects.\n */\nstatic int test_bin_mpa(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_pw_aff *mpa1, *mpa2, *res;\n\n\tfor (i = 0; i < ARRAY_SIZE(mpa_bin_tests); ++i) {\n\t\tmpa1 = isl_multi_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tmpa_bin_tests[i].arg1);\n\t\tmpa2 = isl_multi_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tmpa_bin_tests[i].arg2);\n\t\tres = isl_multi_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tmpa_bin_tests[i].res);\n\t\tmpa1 = mpa_bin_tests[i].fn(mpa1, mpa2);\n\t\tok = isl_multi_pw_aff_plain_is_equal(mpa1, res);\n\t\tisl_multi_pw_aff_free(mpa1);\n\t\tisl_multi_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of unary operations on\n * isl_multi_union_pw_aff objects.\n * \"fn\" is the function that is tested.\n * \"arg\" is a string description of the input.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_union_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa);\n\tconst char *arg;\n\tconst char *res;\n} mupa_un_tests[] = {\n\t{ &isl_multi_union_pw_aff_factor_range,\n\t  \"[B[{ A[] -> [1] }] -> C[{ A[] -> [2] }]]\",\n\t  \"C[{ A[] -> [2] }]\" },\n\t{ &isl_multi_union_pw_aff_factor_range,\n\t  \"[B[] -> C[{ A[] -> [2] }]]\",\n\t  \"C[{ A[] -> [2] }]\" },\n\t{ &isl_multi_union_pw_aff_factor_range,\n\t  \"[B[{ A[] -> [1] }] -> C[]]\",\n\t  \"C[]\" },\n\t{ &isl_multi_union_pw_aff_factor_range,\n\t  \"[B[] -> C[]]\",\n\t  \"C[]\" },\n\t{ &isl_multi_union_pw_aff_factor_range,\n\t  \"([B[] -> C[]] : { A[x] : x >= 0 })\",\n\t  \"(C[] : { A[x] : x >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_factor_range,\n\t  \"[N] -> ([B[] -> C[]] : { A[x] : x <= N })\",\n\t  \"[N] -> (C[] : { A[x] : x <= N })\" },\n\t{ &isl_multi_union_pw_aff_factor_range,\n\t  \"[N] -> ([B[] -> C[]] : { : N >= 0 })\",\n\t  \"[N] -> (C[] : { : N >= 0 })\" },\n};\n\n/* Perform some basic tests of unary operations on\n * isl_multi_union_pw_aff objects.\n */\nstatic int test_un_mupa(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_union_pw_aff *mupa, *res;\n\n\tfor (i = 0; i < ARRAY_SIZE(mupa_un_tests); ++i) {\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tmupa_un_tests[i].arg);\n\t\tres = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tmupa_un_tests[i].res);\n\t\tmupa = mupa_un_tests[i].fn(mupa);\n\t\tok = isl_multi_union_pw_aff_plain_is_equal(mupa, res);\n\t\tisl_multi_union_pw_aff_free(mupa);\n\t\tisl_multi_union_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on\n * isl_multi_union_pw_aff objects.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_union_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa1,\n\t\t__isl_take isl_multi_union_pw_aff *mupa2);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} mupa_bin_tests[] = {\n\t{ &isl_multi_union_pw_aff_add, \"[{ A[] -> [1] }]\", \"[{ A[] -> [2] }]\",\n\t  \"[{ A[] -> [3] }]\" },\n\t{ &isl_multi_union_pw_aff_sub, \"[{ A[] -> [1] }]\", \"[{ A[] -> [2] }]\",\n\t  \"[{ A[] -> [-1] }]\" },\n\t{ &isl_multi_union_pw_aff_add,\n\t  \"[{ A[] -> [1]; B[] -> [4] }]\",\n\t  \"[{ A[] -> [2]; C[] -> [5] }]\",\n\t  \"[{ A[] -> [3] }]\" },\n\t{ &isl_multi_union_pw_aff_union_add,\n\t  \"[{ A[] -> [1]; B[] -> [4] }]\",\n\t  \"[{ A[] -> [2]; C[] -> [5] }]\",\n\t  \"[{ A[] -> [3]; B[] -> [4]; C[] -> [5] }]\" },\n\t{ &isl_multi_union_pw_aff_add, \"[{ A[x] -> [(1)] : x >= 5 }]\",\n\t  \"[{ A[x] -> [(x)] : x <= 10 }]\",\n\t  \"[{ A[x] -> [(1 + x)] : 5 <= x <= 10 }]\" },\n\t{ &isl_multi_union_pw_aff_add, \"([] : { A[x] : x >= 5 })\",\n\t  \"([] : { A[x] : x <= 10 })\",\n\t  \"([] : { A[x] : 5 <= x <= 10 })\" },\n\t{ &isl_multi_union_pw_aff_add, \"([] : { A[x] : x >= 5 })\",\n\t  \"[N] -> ([] : { A[x] : x <= N })\",\n\t  \"[N] -> ([] : { A[x] : 5 <= x <= N })\" },\n\t{ &isl_multi_union_pw_aff_add, \"[N] -> ([] : { A[x] : x >= N })\",\n\t  \"([] : { A[x] : x <= 10 })\",\n\t  \"[N] -> ([] : { A[x] : N <= x <= 10 })\" },\n\t{ &isl_multi_union_pw_aff_union_add, \"[{ A[x] -> [(1)] : x >= 5 }]\",\n\t  \"[{ A[x] -> [(x)] : x <= 10 }]\",\n\t  \"[{ A[x] -> [(1 + x)] : 5 <= x <= 10; \"\n\t     \"A[x] -> [(1)] : x > 10; A[x] -> [(x)] : x < 5 }]\" },\n\t{ &isl_multi_union_pw_aff_union_add, \"([] : { A[x] : x >= 5 })\",\n\t  \"([] : { A[x] : x <= 10 })\",\n\t  \"([] : { A[x] })\" },\n\t{ &isl_multi_union_pw_aff_union_add, \"([] : { A[x] : x >= 0 })\",\n\t  \"[N] -> ([] : { A[x] : x >= N })\",\n\t  \"[N] -> ([] : { A[x] : x >= 0 or x >= N })\" },\n\t{ &isl_multi_union_pw_aff_union_add,\n\t  \"[N] -> ([] : { A[] : N >= 0})\",\n\t  \"[N] -> ([] : { A[] : N <= 0})\",\n\t  \"[N] -> ([] : { A[] })\" },\n\t{ &isl_multi_union_pw_aff_union_add,\n\t  \"[N] -> ([] : { A[] })\",\n\t  \"[N] -> ([] : { : })\",\n\t  \"[N] -> ([] : { : })\" },\n\t{ &isl_multi_union_pw_aff_union_add,\n\t  \"[N] -> ([] : { : })\",\n\t  \"[N] -> ([] : { A[] })\",\n\t  \"[N] -> ([] : { : })\" },\n\t{ &isl_multi_union_pw_aff_union_add,\n\t  \"[N] -> ([] : { : N >= 0})\",\n\t  \"[N] -> ([] : { : N <= 0})\",\n\t  \"[N] -> ([] : { : })\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"B[{ A[] -> [1] }]\",\n\t  \"C[{ A[] -> [2] }]\",\n\t  \"[B[{ A[] -> [1] }] -> C[{ A[] -> [2] }]]\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"(B[] : { A[x] : x >= 5 })\",\n\t  \"(C[] : { A[x] : x <= 10 })\",\n\t  \"([B[] -> C[]] : { A[x] : 5 <= x <= 10 })\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"B[{ A[x] -> [x + 1] : x >= 5 }]\",\n\t  \"(C[] : { A[x] : x <= 10 })\",\n\t  \"[B[{ A[x] -> [x + 1] : 5 <= x <= 10 }] -> C[]]\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"(C[] : { A[x] : x <= 10 })\",\n\t  \"B[{ A[x] -> [x + 1] : x >= 5 }]\",\n\t  \"[C[] -> B[{ A[x] -> [x + 1] : 5 <= x <= 10 }]]\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"B[{ A[x] -> [x + 1] : x >= 5 }]\",\n\t  \"[N] -> (C[] : { A[x] : x <= N })\",\n\t  \"[N] -> [B[{ A[x] -> [x + 1] : 5 <= x <= N }] -> C[]]\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"[N] -> (C[] : { A[x] : x <= N })\",\n\t  \"B[{ A[x] -> [x + 1] : x >= 5 }]\",\n\t  \"[N] -> [C[] -> B[{ A[x] -> [x + 1] : 5 <= x <= N }]]\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"B[{ A[] -> [1]; D[] -> [3] }]\",\n\t  \"C[{ A[] -> [2] }]\",\n\t  \"[B[{ A[] -> [1]; D[] -> [3] }] -> C[{ A[] -> [2] }]]\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"B[] }]\",\n\t  \"(C[] : { A[x] })\",\n\t  \"([B[] -> C[]] : { A[x] })\" },\n\t{ &isl_multi_union_pw_aff_range_product,\n\t  \"(B[] : { A[x] })\",\n\t  \"C[] }]\",\n\t  \"([B[] -> C[]] : { A[x] })\" },\n};\n\n/* Perform some basic tests of binary operations on\n * isl_multi_union_pw_aff objects.\n */\nstatic int test_bin_mupa(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_union_pw_aff *mupa1, *mupa2, *res;\n\n\tfor (i = 0; i < ARRAY_SIZE(mupa_bin_tests); ++i) {\n\t\tmupa1 = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tmupa_bin_tests[i].arg1);\n\t\tmupa2 = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tmupa_bin_tests[i].arg2);\n\t\tres = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t\tmupa_bin_tests[i].res);\n\t\tmupa1 = mupa_bin_tests[i].fn(mupa1, mupa2);\n\t\tok = isl_multi_union_pw_aff_plain_is_equal(mupa1, res);\n\t\tisl_multi_union_pw_aff_free(mupa1);\n\t\tisl_multi_union_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_set objects.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_union_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa,\n\t\t__isl_take isl_set *set);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} mupa_set_tests[] = {\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"C[{ B[i,j] -> [i + 2j] }]\", \"{ C[1] }\",\n\t  \"C[{ B[i,j] -> [i + 2j] : i + 2j = 1 }]\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"C[{ B[i,j] -> [i + 2j] }]\", \"[N] -> { C[N] }\",\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j] : i + 2j = N }]\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j + N] }]\", \"{ C[1] }\",\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j + N] : i + 2j + N = 1 }]\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"C[{ B[i,j] -> [i + 2j] }]\", \"[N] -> { C[x] : N >= 0 }\",\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j] : N >= 0 }]\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"C[]\", \"{ C[] }\", \"C[]\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"{ C[] }\",\n\t  \"[N] -> (C[] : { : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"(C[] : { A[a,b] })\",\n\t  \"{ C[] }\",\n\t  \"(C[] : { A[a,b] })\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"[N] -> (C[] : { A[a,b] : a,b <= N })\",\n\t  \"{ C[] }\",\n\t  \"[N] -> (C[] : { A[a,b] : a,b <= N })\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"C[]\",\n\t  \"[N] -> { C[] : N >= 0 }\",\n\t  \"[N] -> (C[] : { : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"(C[] : { A[a,b] })\",\n\t  \"[N] -> { C[] : N >= 0 }\",\n\t  \"[N] -> (C[] : { A[a,b] : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_intersect_range,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"[N] -> { C[] : N < 1024 }\",\n\t  \"[N] -> (C[] : { : 0 <= N < 1024 })\" },\n\t{ &isl_multi_union_pw_aff_intersect_params,\n\t  \"C[{ B[i,j] -> [i + 2j] }]\", \"[N] -> { : N >= 0 }\",\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j] : N >= 0}]\" },\n\t{ &isl_multi_union_pw_aff_intersect_params,\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j] : N <= 256 }]\", \"[N] -> { : N >= 0 }\",\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j] : 0 <= N <= 256 }]\" },\n\t{ &isl_multi_union_pw_aff_intersect_params,\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j] : N <= 256 }]\", \"{ : }\",\n\t  \"[N] -> C[{ B[i,j] -> [i + 2j] : N <= 256 }]\" },\n\t{ &isl_multi_union_pw_aff_intersect_params,\n\t  \"C[]\", \"[N] -> { : N >= 0 }\",\n\t  \"[N] -> (C[] : { : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_intersect_params,\n\t  \"(C[] : { A[a,b] })\", \"[N] -> { : N >= 0 }\",\n\t  \"[N] -> (C[] : { A[a,b] : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_intersect_params,\n\t  \"[N] -> (C[] : { A[a,N] })\", \"{ : }\",\n\t  \"[N] -> (C[] : { A[a,N] })\" },\n\t{ &isl_multi_union_pw_aff_intersect_params,\n\t  \"[N] -> (C[] : { A[a,b] : N <= 256 })\", \"[N] -> { : N >= 0 }\",\n\t  \"[N] -> (C[] : { A[a,b] : 0 <= N <= 256 })\" },\n};\n\n/* Perform some basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_set objects.\n */\nstatic int test_mupa_set(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_union_pw_aff *mupa, *res;\n\tisl_set *set;\n\n\tfor (i = 0; i < ARRAY_SIZE(mupa_set_tests); ++i) {\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_set_tests[i].arg1);\n\t\tset = isl_set_read_from_str(ctx, mupa_set_tests[i].arg2);\n\t\tres = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_set_tests[i].res);\n\t\tmupa = mupa_set_tests[i].fn(mupa, set);\n\t\tok = isl_multi_union_pw_aff_plain_is_equal(mupa, res);\n\t\tisl_multi_union_pw_aff_free(mupa);\n\t\tisl_multi_union_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_union_set objects.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_union_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa,\n\t\t__isl_take isl_union_set *uset);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} mupa_uset_tests[] = {\n\t{ &isl_multi_union_pw_aff_intersect_domain,\n\t  \"C[{ B[i,j] -> [i + 2j] }]\", \"{ B[i,i] }\",\n\t  \"C[{ B[i,i] -> [3i] }]\" },\n\t{ &isl_multi_union_pw_aff_intersect_domain,\n\t  \"(C[] : { B[i,j] })\", \"{ B[i,i] }\",\n\t  \"(C[] : { B[i,i] })\" },\n\t{ &isl_multi_union_pw_aff_intersect_domain,\n\t  \"(C[] : { B[i,j] })\", \"[N] -> { B[N,N] }\",\n\t  \"[N] -> (C[] : { B[N,N] })\" },\n\t{ &isl_multi_union_pw_aff_intersect_domain,\n\t  \"C[]\", \"{ B[i,i] }\",\n\t  \"(C[] : { B[i,i] })\" },\n\t{ &isl_multi_union_pw_aff_intersect_domain,\n\t  \"[N] -> (C[] : { : N >= 0 })\", \"{ B[i,i] }\",\n\t  \"[N] -> (C[] : { B[i,i] : N >= 0 })\" },\n};\n\n/* Perform some basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_union_set objects.\n */\nstatic int test_mupa_uset(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_union_pw_aff *mupa, *res;\n\tisl_union_set *uset;\n\n\tfor (i = 0; i < ARRAY_SIZE(mupa_uset_tests); ++i) {\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_uset_tests[i].arg1);\n\t\tuset = isl_union_set_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_uset_tests[i].arg2);\n\t\tres = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_uset_tests[i].res);\n\t\tmupa = mupa_uset_tests[i].fn(mupa, uset);\n\t\tok = isl_multi_union_pw_aff_plain_is_equal(mupa, res);\n\t\tisl_multi_union_pw_aff_free(mupa);\n\t\tisl_multi_union_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_multi_aff objects.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_union_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa,\n\t\t__isl_take isl_multi_aff *ma);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} mupa_ma_tests[] = {\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"C[{ A[i,j] -> [i]; B[i,j] -> [j] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [i] }]\",\n\t  \"{ C[a,b] -> D[b,a] }\",\n\t  \"D[{ A[i,j] -> [j]; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [i]; B[i,j] -> [j] }]\" },\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"C[{ A[i,j] -> [i] : i >= 0; B[i,j] -> [j] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [i] }]\",\n\t  \"{ C[a,b] -> D[b,a] }\",\n\t  \"D[{ A[i,j] -> [j] : i >= 0; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [i] : i >= 0; B[i,j] -> [j] }]\" },\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"C[{ A[i,j] -> [i]; B[i,j] -> [j] }]\",\n\t  \"[N] -> { C[a] -> D[a + N] }\",\n\t  \"[N] -> D[{ A[i,j] -> [i + N]; B[i,j] -> [j + N] }] \" },\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"C[]\",\n\t  \"{ C[] -> D[] }\",\n\t  \"D[]\" },\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"{ C[] -> D[] }\",\n\t  \"[N] -> (D[] : { : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"C[]\",\n\t  \"[N] -> { C[] -> D[N] }\",\n\t  \"[N] -> D[{ [N] }]\" },\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"(C[] : { A[i,j] : i >= j })\",\n\t  \"{ C[] -> D[] }\",\n\t  \"(D[] : { A[i,j] : i >= j })\" },\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"[N] -> (C[] : { A[i,j] : N >= 0 })\",\n\t  \"{ C[] -> D[] }\",\n\t  \"[N] -> (D[] : { A[i,j] : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_apply_multi_aff,\n\t  \"(C[] : { A[i,j] : i >= j })\",\n\t  \"[N] -> { C[] -> D[N] }\",\n\t  \"[N] -> (D[{ A[i,j] -> [N] : i >= j }])\" },\n};\n\n/* Perform some basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_multi_aff objects.\n */\nstatic int test_mupa_ma(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_union_pw_aff *mupa, *res;\n\tisl_multi_aff *ma;\n\n\tfor (i = 0; i < ARRAY_SIZE(mupa_ma_tests); ++i) {\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_ma_tests[i].arg1);\n\t\tma = isl_multi_aff_read_from_str(ctx, mupa_ma_tests[i].arg2);\n\t\tres = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_ma_tests[i].res);\n\t\tmupa = mupa_ma_tests[i].fn(mupa, ma);\n\t\tok = isl_multi_union_pw_aff_plain_is_equal(mupa, res);\n\t\tisl_multi_union_pw_aff_free(mupa);\n\t\tisl_multi_union_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_pw_aff objects.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_union_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa,\n\t\t__isl_take isl_pw_aff *pa);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} mupa_pa_tests[] = {\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"C[{ A[i,j] -> [i]; B[i,j] -> [j] }]\",\n\t  \"[N] -> { C[a] -> [a + N] }\",\n\t  \"[N] -> { A[i,j] -> [i + N]; B[i,j] -> [j + N] }\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"C[{ A[i,j] -> [i]; B[i,j] -> [j] }]\",\n\t  \"{ C[a] -> [a] : a >= 0; C[a] -> [-a] : a < 0 }\",\n\t  \"{ A[i,j] -> [i] : i >= 0; A[i,j] -> [-i] : i < 0; \"\n\t    \"B[i,j] -> [j] : j >= 0; B[i,j] -> [-j] : j < 0 }\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"C[]\",\n\t  \"[N] -> { C[] -> [N] }\",\n\t  \"[N] -> { [N] }\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"C[]\",\n\t  \"[N] -> { C[] -> [N] : N >= 0; C[] -> [-N] : N < 0 }\",\n\t  \"[N] -> { [N] : N >= 0; [-N] : N < 0 }\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"[N] -> { C[] -> [N] }\",\n\t  \"[N] -> { [N] : N >= 0 }\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"[N] -> { C[] -> [N] : N >= 0; C[] -> [-N] : N < 0 }\",\n\t  \"[N] -> { [N] : N >= 0 }\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"{ C[] -> [0] }\",\n\t  \"[N] -> { [0] : N >= 0 }\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"(C[] : { A[i,j] : i >= j })\",\n\t  \"[N] -> { C[] -> [N] }\",\n\t  \"[N] -> { A[i,j] -> [N] : i >= j }\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_aff,\n\t  \"(C[] : { A[i,j] : i >= j })\",\n\t  \"[N] -> { C[] -> [N] : N >= 0 }\",\n\t  \"[N] -> { A[i,j] -> [N] : i >= j and N >= 0 }\" },\n};\n\n/* Perform some basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_pw_aff objects.\n */\nstatic int test_mupa_pa(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_union_pw_aff *mupa;\n\tisl_union_pw_aff *upa, *res;\n\tisl_pw_aff *pa;\n\n\tfor (i = 0; i < ARRAY_SIZE(mupa_pa_tests); ++i) {\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_pa_tests[i].arg1);\n\t\tpa = isl_pw_aff_read_from_str(ctx, mupa_pa_tests[i].arg2);\n\t\tres = isl_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_pa_tests[i].res);\n\t\tupa = mupa_pa_tests[i].fn(mupa, pa);\n\t\tok = isl_union_pw_aff_plain_is_equal(upa, res);\n\t\tisl_union_pw_aff_free(upa);\n\t\tisl_union_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_pw_multi_aff objects.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_union_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa,\n\t\t__isl_take isl_pw_multi_aff *pma);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} mupa_pma_tests[] = {\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"C[{ A[i,j] -> [i]; B[i,j] -> [j] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [i] }]\",\n\t  \"{ C[a,b] -> D[b,a] }\",\n\t  \"D[{ A[i,j] -> [j]; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [i]; B[i,j] -> [j] }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"C[{ A[i,j] -> [i] : i >= 0; B[i,j] -> [j] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [i] }]\",\n\t  \"{ C[a,b] -> D[b,a] }\",\n\t  \"D[{ A[i,j] -> [j] : i >= 0; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [i] : i >= 0; B[i,j] -> [j] }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"C[{ A[i,j] -> [i]; B[i,j] -> [j] }]\",\n\t  \"[N] -> { C[a] -> D[a + N] }\",\n\t  \"[N] -> D[{ A[i,j] -> [i + N]; B[i,j] -> [j + N] }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"C[{ A[i,j] -> [i]; B[i,j] -> [j] }]\",\n\t  \"{ C[a] -> D[a] : a >= 0; C[a] -> D[-a] : a < 0 }\",\n\t  \"D[{ A[i,j] -> [i] : i >= 0; A[i,j] -> [-i] : i < 0; \"\n\t      \"B[i,j] -> [j] : j >= 0; B[i,j] -> [-j] : j < 0 }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"C[{ A[i,j] -> [i]; B[i,j] -> [j] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [i] }]\",\n\t  \"{ C[a,b] -> D[a,b] : a >= b; C[a,b] -> D[b,a] : a < b }\",\n\t  \"D[{ A[i,j] -> [i] : i >= j; A[i,j] -> [j] : i < j; \"\n\t      \"B[i,j] -> [j] : i <= j; B[i,j] -> [i] : i > j }, \"\n\t    \"{ A[i,j] -> [j] : i >= j; A[i,j] -> [i] : i < j; \"\n\t      \"B[i,j] -> [i] : i <= j; B[i,j] -> [j] : i > j }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"C[]\",\n\t  \"{ C[] -> D[] }\",\n\t  \"D[]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"{ C[] -> D[] }\",\n\t  \"[N] -> (D[] : { : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"C[]\",\n\t  \"[N] -> { C[] -> D[N] }\",\n\t  \"[N] -> D[{ [N] }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"(C[] : { A[i,j] : i >= j })\",\n\t  \"{ C[] -> D[] }\",\n\t  \"(D[] : { A[i,j] : i >= j })\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"[N] -> (C[] : { A[i,j] : N >= 0 })\",\n\t  \"{ C[] -> D[] }\",\n\t  \"[N] -> (D[] : { A[i,j] : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"(C[] : { A[i,j] : i >= j })\",\n\t  \"[N] -> { C[] -> D[N] }\",\n\t  \"[N] -> (D[{ A[i,j] -> [N] : i >= j }])\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"C[]\",\n\t  \"[N] -> { C[] -> D[N] : N >= 0; C[] -> D[-N] : N < 0 }\",\n\t  \"[N] -> D[{ [N] : N >= 0; [-N] : N < 0 }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"[N] -> { C[] -> D[N] }\",\n\t  \"[N] -> D[{ [N] : N >= 0 }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"[N] -> { C[] -> D[N] : N >= 0; C[] -> D[-N] : N < 0 }\",\n\t  \"[N] -> D[{ [N] : N >= 0 }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"{ C[] -> D[0] }\",\n\t  \"[N] -> D[{ [0] : N >= 0 }]\" },\n\t{ &isl_multi_union_pw_aff_apply_pw_multi_aff,\n\t  \"(C[] : { A[i,j] : i >= j })\",\n\t  \"[N] -> { C[] -> D[N] : N >= 0 }\",\n\t  \"[N] -> D[{ A[i,j] -> [N] : i >= j and N >= 0 }]\" },\n};\n\n/* Perform some basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_pw_multi_aff objects.\n */\nstatic int test_mupa_pma(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_union_pw_aff *mupa, *res;\n\tisl_pw_multi_aff *pma;\n\n\tfor (i = 0; i < ARRAY_SIZE(mupa_pma_tests); ++i) {\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_pma_tests[i].arg1);\n\t\tpma = isl_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_pma_tests[i].arg2);\n\t\tres = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_pma_tests[i].res);\n\t\tmupa = mupa_pma_tests[i].fn(mupa, pma);\n\t\tok = isl_multi_union_pw_aff_plain_is_equal(mupa, res);\n\t\tisl_multi_union_pw_aff_free(mupa);\n\t\tisl_multi_union_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_union_pw_multi_aff objects.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_multi_union_pw_aff *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa,\n\t\t__isl_take isl_union_pw_multi_aff *upma);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} mupa_upma_tests[] = {\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"C[{ B[i,j] -> [i + 2j] }]\", \"{ A[a,b] -> B[b,a] }\",\n\t  \"C[{ A[a,b] -> [b + 2a] }]\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"C[{ B[i,j] -> [i + 2j] }]\",\n\t  \"{ A[a,b] -> B[b,a] : b > a }\",\n\t  \"C[{ A[a,b] -> [b + 2a] : b > a }]\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"C[{ B[i,j] -> [i + 2j] : j > 4 }]\",\n\t  \"{ A[a,b] -> B[b,a] : b > a }\",\n\t  \"C[{ A[a,b] -> [b + 2a] : b > a > 4 }]\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"C[{ B[i,j] -> [i + 2j] }]\",\n\t  \"{ A[a,b] -> B[b,a] : a > b; A[a,b] -> B[a,b] : a <= b }\",\n\t  \"C[{ A[a,b] -> [b + 2a] : a > b; A[a,b] -> [a + 2b] : a <= b }]\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"(C[] : { B[a,b] })\",\n\t  \"{ A[a,b] -> B[b,a] }\",\n\t  \"(C[] : { A[a,b] })\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"(C[] : { B[a,b] })\",\n\t  \"{ B[a,b] -> A[b,a] }\",\n\t  \"(C[] : { })\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"(C[] : { B[a,b] })\",\n\t  \"{ A[a,b] -> B[b,a] : a > b }\",\n\t  \"(C[] : { A[a,b] : a > b })\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"(C[] : { B[a,b] : a > b })\",\n\t  \"{ A[a,b] -> B[b,a] }\",\n\t  \"(C[] : { A[a,b] : b > a })\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"[N] -> (C[] : { B[a,b] : a > N })\",\n\t  \"{ A[a,b] -> B[b,a] : a > b }\",\n\t  \"[N] -> (C[] : { A[a,b] : a > b > N })\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"(C[] : { B[a,b] : a > b })\",\n\t  \"[N] -> { A[a,b] -> B[b,a] : a > N }\",\n\t  \"[N] -> (C[] : { A[a,b] : b > a > N })\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"C[]\",\n\t  \"{ A[a,b] -> B[b,a] }\",\n\t  \"C[]\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"[N] -> (C[] : { : N >= 0 })\",\n\t  \"{ A[a,b] -> B[b,a] }\",\n\t  \"[N] -> (C[] : { : N >= 0 })\" },\n\t{ &isl_multi_union_pw_aff_pullback_union_pw_multi_aff,\n\t  \"C[]\",\n\t  \"[N] -> { A[a,b] -> B[b,a] : N >= 0 }\",\n\t  \"[N] -> (C[] : { : N >= 0 })\" },\n};\n\n/* Perform some basic tests of binary operations on\n * pairs of isl_multi_union_pw_aff and isl_union_pw_multi_aff objects.\n */\nstatic int test_mupa_upma(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_multi_union_pw_aff *mupa, *res;\n\tisl_union_pw_multi_aff *upma;\n\n\tfor (i = 0; i < ARRAY_SIZE(mupa_upma_tests); ++i) {\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_upma_tests[i].arg1);\n\t\tupma = isl_union_pw_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_upma_tests[i].arg2);\n\t\tres = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    mupa_upma_tests[i].res);\n\t\tmupa = mupa_upma_tests[i].fn(mupa, upma);\n\t\tok = isl_multi_union_pw_aff_plain_is_equal(mupa, res);\n\t\tisl_multi_union_pw_aff_free(mupa);\n\t\tisl_multi_union_pw_aff_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Check that the input tuple of an isl_aff can be set properly.\n */\nstatic isl_stat test_aff_set_tuple_id(isl_ctx *ctx)\n{\n\tisl_id *id;\n\tisl_aff *aff;\n\tisl_stat equal;\n\n\taff = isl_aff_read_from_str(ctx, \"{ [x] -> [x + 1] }\");\n\tid = isl_id_alloc(ctx, \"A\", NULL);\n\taff = isl_aff_set_tuple_id(aff, isl_dim_in, id);\n\tequal = aff_check_plain_equal(aff, \"{ A[x] -> [x + 1] }\");\n\tisl_aff_free(aff);\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Check that affine expressions get normalized on addition/subtraction.\n * In particular, check that (final) unused integer divisions get removed\n * such that an expression derived from expressions with integer divisions\n * is found to be obviously equal to one that is created directly.\n */\nstatic isl_stat test_aff_normalize(isl_ctx *ctx)\n{\n\tisl_aff *aff, *aff2;\n\tisl_stat ok;\n\n\taff = isl_aff_read_from_str(ctx, \"{ [x] -> [x//2] }\");\n\taff2 = isl_aff_read_from_str(ctx, \"{ [x] -> [1 + x//2] }\");\n\taff = isl_aff_sub(aff2, aff);\n\tok = aff_check_plain_equal(aff, \"{ [x] -> [1] }\");\n\tisl_aff_free(aff);\n\n\treturn ok;\n}\n\nint test_aff(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_space *space;\n\tisl_local_space *ls;\n\tisl_aff *aff;\n\tint zero;\n\tisl_stat equal;\n\n\tif (test_upa(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_aff(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_pw_aff(ctx) < 0)\n\t\treturn -1;\n\tif (test_upma_test(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_upma(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_upma_fail(ctx) < 0)\n\t\treturn -1;\n\tif (test_upma_uset(ctx) < 0)\n\t\treturn -1;\n\tif (test_un_mpa(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_mpa(ctx) < 0)\n\t\treturn -1;\n\tif (test_un_mupa(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_mupa(ctx) < 0)\n\t\treturn -1;\n\tif (test_mupa_set(ctx) < 0)\n\t\treturn -1;\n\tif (test_mupa_uset(ctx) < 0)\n\t\treturn -1;\n\tif (test_mupa_ma(ctx) < 0)\n\t\treturn -1;\n\tif (test_mupa_pa(ctx) < 0)\n\t\treturn -1;\n\tif (test_mupa_pma(ctx) < 0)\n\t\treturn -1;\n\tif (test_mupa_upma(ctx) < 0)\n\t\treturn -1;\n\n\tspace = isl_space_set_alloc(ctx, 0, 1);\n\tls = isl_local_space_from_space(space);\n\taff = isl_aff_zero_on_domain(ls);\n\n\taff = isl_aff_add_coefficient_si(aff, isl_dim_in, 0, 1);\n\taff = isl_aff_scale_down_ui(aff, 3);\n\taff = isl_aff_floor(aff);\n\taff = isl_aff_add_coefficient_si(aff, isl_dim_in, 0, 1);\n\taff = isl_aff_scale_down_ui(aff, 2);\n\taff = isl_aff_floor(aff);\n\taff = isl_aff_add_coefficient_si(aff, isl_dim_in, 0, 1);\n\n\tstr = \"{ [10] }\";\n\tset = isl_set_read_from_str(ctx, str);\n\taff = isl_aff_gist(aff, set);\n\n\taff = isl_aff_add_constant_si(aff, -16);\n\tzero = isl_aff_plain_is_zero(aff);\n\tisl_aff_free(aff);\n\n\tif (zero < 0)\n\t\treturn -1;\n\tif (!zero)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\taff = isl_aff_read_from_str(ctx, \"{ [-1] }\");\n\taff = isl_aff_scale_down_ui(aff, 64);\n\taff = isl_aff_floor(aff);\n\tequal = aff_check_plain_equal(aff, \"{ [-1] }\");\n\tisl_aff_free(aff);\n\tif (equal < 0)\n\t\treturn -1;\n\n\tif (test_aff_set_tuple_id(ctx) < 0)\n\t\treturn -1;\n\tif (test_aff_normalize(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Inputs for isl_set_bind tests.\n * \"set\" is the input set.\n * \"tuple\" is the binding tuple.\n * \"res\" is the expected result.\n */\nstatic\nstruct {\n\tconst char *set;\n\tconst char *tuple;\n\tconst char *res;\n} bind_set_tests[] = {\n\t{ \"{ A[M, N] : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ A[M, N] }\",\n\t  \"[M, N] -> { : M mod 2 = 0 and N mod 8 = 3 }\" },\n\t{ \"{ B[N, M] : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ B[N, M] }\",\n\t  \"[M, N] -> { : M mod 2 = 0 and N mod 8 = 3 }\" },\n\t{ \"[M] -> { C[N] : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ C[N] }\",\n\t  \"[M, N] -> { : M mod 2 = 0 and N mod 8 = 3 }\" },\n\t{ \"[M] -> { D[x, N] : x mod 2 = 0 and N mod 8 = 3 and M >= 0 }\",\n\t  \"{ D[M, N] }\",\n\t  \"[M, N] -> { : M mod 2 = 0 and N mod 8 = 3 and M >= 0 }\" },\n};\n\n/* Perform basic isl_set_bind tests.\n */\nstatic isl_stat test_bind_set(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bind_set_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_set *set;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\tset = isl_set_read_from_str(ctx, bind_set_tests[i].set);\n\t\tstr = bind_set_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\tset = isl_set_bind(set, tuple);\n\t\tr = set_check_equal(set, bind_set_tests[i].res);\n\t\tisl_set_free(set);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_map_bind_domain tests.\n * \"map\" is the input map.\n * \"tuple\" is the binding tuple.\n * \"res\" is the expected result.\n */\nstruct {\n\tconst char *map;\n\tconst char *tuple;\n\tconst char *res;\n} bind_map_domain_tests[] = {\n\t{ \"{ A[M, N] -> [M + floor(N/2)] }\",\n\t  \"{ A[M, N] }\",\n\t  \"[M, N] -> { [M + floor(N/2)] }\" },\n\t{ \"{ B[N, M] -> [M + floor(N/2)] }\",\n\t  \"{ B[N, M] }\",\n\t  \"[N, M] -> { [M + floor(N/2)] }\" },\n\t{ \"[M] -> { C[N] -> [M + floor(N/2)] }\",\n\t  \"{ C[N] }\",\n\t  \"[M, N] -> { [M + floor(N/2)] }\" },\n\t{ \"[M] -> { C[x, N] -> [x + floor(N/2)] }\",\n\t  \"{ C[M, N] }\",\n\t  \"[M, N] -> { [M + floor(N/2)] }\" },\n\t{ \"[M] -> { C[x, N] -> [M + floor(N/2)] }\",\n\t  \"{ C[M, N] }\",\n\t  \"[M, N] -> { [M + floor(N/2)] }\" },\n\t{ \"[A, M] -> { C[N, x] -> [x + floor(N/2)] }\",\n\t  \"{ C[N, M] }\",\n\t  \"[A, N, M] -> { [M + floor(N/2)] }\" },\n};\n\n/* Perform basic isl_map_bind_domain tests.\n */\nstatic isl_stat test_bind_map_domain(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bind_map_domain_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_map *map;\n\t\tisl_set *set;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\tstr = bind_map_domain_tests[i].map;\n\t\tmap = isl_map_read_from_str(ctx, str);\n\t\tstr = bind_map_domain_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\tset = isl_map_bind_domain(map, tuple);\n\t\tstr = bind_map_domain_tests[i].res;\n\t\tr = set_check_equal(set, str);\n\t\tisl_set_free(set);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_union_map_bind_range tests.\n * \"map\" is the input union map.\n * \"tuple\" is the binding tuple.\n * \"res\" is the expected result.\n */\nstruct {\n\tconst char *map;\n\tconst char *tuple;\n\tconst char *res;\n} bind_umap_range_tests[] = {\n\t{ \"{ B[N, M] -> A[M, N] : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ A[M, N] }\",\n\t  \"[M, N] -> { B[N, M] : M mod 2 = 0 and N mod 8 = 3 }\" },\n\t{ \"{ B[N, M] -> A[M, N] : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ B[M, N] }\",\n\t  \"{ }\" },\n\t{ \"{ A[] -> B[]; C[] -> D[]; E[] -> B[] }\",\n\t  \"{ B[] }\",\n\t  \"{ A[]; E[] }\" },\n};\n\n/* Perform basic isl_union_map_bind_range tests.\n */\nstatic isl_stat test_bind_umap_range(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bind_umap_range_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_union_map *umap;\n\t\tisl_union_set *uset;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\tstr = bind_umap_range_tests[i].map;\n\t\tumap = isl_union_map_read_from_str(ctx, str);\n\t\tstr = bind_umap_range_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\tuset = isl_union_map_bind_range(umap, tuple);\n\t\tstr = bind_umap_range_tests[i].res;\n\t\tr = uset_check_equal(uset, str);\n\t\tisl_union_set_free(uset);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_pw_multi_aff_bind_domain tests.\n * \"pma\" is the input expression.\n * \"tuple\" is the binding tuple.\n * \"res\" is the expected result.\n */\nstruct {\n\tconst char *pma;\n\tconst char *tuple;\n\tconst char *res;\n} bind_pma_domain_tests[] = {\n\t{ \"{ A[M, N] -> [M + floor(N/2)] }\",\n\t  \"{ A[M, N] }\",\n\t  \"[M, N] -> { [M + floor(N/2)] }\" },\n\t{ \"{ B[N, M] -> [M + floor(N/2)] }\",\n\t  \"{ B[N, M] }\",\n\t  \"[N, M] -> { [M + floor(N/2)] }\" },\n\t{ \"[M] -> { C[N] -> [M + floor(N/2)] }\",\n\t  \"{ C[N] }\",\n\t  \"[M, N] -> { [M + floor(N/2)] }\" },\n\t{ \"[M] -> { C[x, N] -> [x + floor(N/2)] }\",\n\t  \"{ C[M, N] }\",\n\t  \"[M, N] -> { [M + floor(N/2)] }\" },\n\t{ \"[M] -> { C[x, N] -> [M + floor(N/2)] }\",\n\t  \"{ C[M, N] }\",\n\t  \"[M, N] -> { [M + floor(N/2)] }\" },\n\t{ \"[A, M] -> { C[N, x] -> [x + floor(N/2)] }\",\n\t  \"{ C[N, M] }\",\n\t  \"[A, N, M] -> { [M + floor(N/2)] }\" },\n};\n\n/* Perform basic isl_pw_multi_aff_bind_domain tests.\n */\nstatic isl_stat test_bind_pma_domain(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bind_pma_domain_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_pw_multi_aff *pma;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\tstr = bind_pma_domain_tests[i].pma;\n\t\tpma = isl_pw_multi_aff_read_from_str(ctx, str);\n\t\tstr = bind_pma_domain_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\tpma = isl_pw_multi_aff_bind_domain(pma, tuple);\n\t\tstr = bind_pma_domain_tests[i].res;\n\t\tr = pw_multi_aff_check_plain_equal(pma, str);\n\t\tisl_pw_multi_aff_free(pma);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_pw_multi_aff_bind_domain_wrapped_domain tests.\n * \"pma\" is the input expression.\n * \"tuple\" is the binding tuple.\n * \"res\" is the expected result.\n */\nstruct {\n\tconst char *pma;\n\tconst char *tuple;\n\tconst char *res;\n} bind_pma_domain_wrapped_tests[] = {\n\t{ \"{ [A[M, N] -> B[]] -> [M + floor(N/2)] }\",\n\t  \"{ A[M, N] }\",\n\t  \"[M, N] -> { B[] -> [M + floor(N/2)] }\" },\n\t{ \"{ [B[N, M] -> D[]] -> [M + floor(N/2)] }\",\n\t  \"{ B[N, M] }\",\n\t  \"[N, M] -> { D[] -> [M + floor(N/2)] }\" },\n\t{ \"[M] -> { [C[N] -> B[x]] -> [x + M + floor(N/2)] }\",\n\t  \"{ C[N] }\",\n\t  \"[M, N] -> { B[x] -> [x + M + floor(N/2)] }\" },\n\t{ \"[M] -> { [C[x, N] -> B[]] -> [x + floor(N/2)] }\",\n\t  \"{ C[M, N] }\",\n\t  \"[M, N] -> { B[] -> [M + floor(N/2)] }\" },\n\t{ \"[M] -> { [C[x, N] -> B[]] -> [M + floor(N/2)] }\",\n\t  \"{ C[M, N] }\",\n\t  \"[M, N] -> { B[] -> [M + floor(N/2)] }\" },\n\t{ \"[A, M] -> { [C[N, x] -> B[]] -> [x + floor(N/2)] }\",\n\t  \"{ C[N, M] }\",\n\t  \"[A, N, M] -> { B[] -> [M + floor(N/2)] }\" },\n};\n\n/* Perform basic isl_pw_multi_aff_bind_domain_wrapped_domain tests.\n */\nstatic isl_stat test_bind_pma_domain_wrapped(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bind_pma_domain_wrapped_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_pw_multi_aff *pma;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\tstr = bind_pma_domain_wrapped_tests[i].pma;\n\t\tpma = isl_pw_multi_aff_read_from_str(ctx, str);\n\t\tstr = bind_pma_domain_wrapped_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\tpma = isl_pw_multi_aff_bind_domain_wrapped_domain(pma, tuple);\n\t\tstr = bind_pma_domain_wrapped_tests[i].res;\n\t\tr = pw_multi_aff_check_plain_equal(pma, str);\n\t\tisl_pw_multi_aff_free(pma);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_aff_bind_id tests.\n * \"aff\" is the input expression.\n * \"id\" is the binding id.\n * \"res\" is the expected result.\n */\nstatic\nstruct {\n\tconst char *aff;\n\tconst char *id;\n\tconst char *res;\n} bind_aff_tests[] = {\n\t{ \"{ [4] }\", \"M\", \"[M = 4] -> { : }\" },\n\t{ \"{ B[x] -> [floor(x/2)] }\", \"M\", \"[M] -> { B[x] : M = floor(x/2) }\" },\n\t{ \"[M] -> { [4] }\", \"M\", \"[M = 4] -> { : }\" },\n\t{ \"[M] -> { [floor(M/2)] }\", \"M\", \"[M] -> { : floor(M/2) = M }\" },\n\t{ \"{ [NaN] }\", \"M\", \"{ : false }\" },\n\t{ \"{ A[x] -> [NaN] }\", \"M\", \"{ A[x] : false }\" },\n};\n\n/* Perform basic isl_aff_bind_id tests.\n */\nstatic isl_stat test_bind_aff(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bind_aff_tests); ++i) {\n\t\tisl_aff *aff;\n\t\tisl_set *res;\n\t\tisl_id *id;\n\t\tisl_stat r;\n\n\t\taff = isl_aff_read_from_str(ctx, bind_aff_tests[i].aff);\n\t\tid = isl_id_read_from_str(ctx, bind_aff_tests[i].id);\n\t\tres = isl_set_from_basic_set(isl_aff_bind_id(aff, id));\n\t\tr = set_check_equal(res, bind_aff_tests[i].res);\n\t\tisl_set_free(res);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_pw_aff_bind_id tests.\n * \"pa\" is the input expression.\n * \"id\" is the binding id.\n * \"res\" is the expected result.\n */\nstatic\nstruct {\n\tconst char *pa;\n\tconst char *id;\n\tconst char *res;\n} bind_pa_tests[] = {\n\t{ \"{ [4] }\", \"M\", \"[M = 4] -> { : }\" },\n\t{ \"{ B[x] -> [floor(x/2)] }\", \"M\", \"[M] -> { B[x] : M = floor(x/2) }\" },\n\t{ \"[M] -> { [4] }\", \"M\", \"[M = 4] -> { : }\" },\n\t{ \"[M] -> { [floor(M/2)] }\", \"M\", \"[M] -> { : floor(M/2) = M }\" },\n\t{ \"[M] -> { [M] : M >= 0; [-M] : M < 0 }\", \"M\", \"[M] -> { : M >= 0 }\" },\n\t{ \"{ [NaN] }\", \"M\", \"{ : false }\" },\n\t{ \"{ A[x] -> [NaN] }\", \"M\", \"{ A[x] : false }\" },\n};\n\n/* Perform basic isl_pw_aff_bind_id tests.\n */\nstatic isl_stat test_bind_pa(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bind_pa_tests); ++i) {\n\t\tisl_pw_aff *pa;\n\t\tisl_set *res;\n\t\tisl_id *id;\n\t\tisl_stat r;\n\n\t\tpa = isl_pw_aff_read_from_str(ctx, bind_pa_tests[i].pa);\n\t\tid = isl_id_read_from_str(ctx, bind_pa_tests[i].id);\n\t\tres = isl_pw_aff_bind_id(pa, id);\n\t\tr = set_check_equal(res, bind_pa_tests[i].res);\n\t\tisl_set_free(res);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_multi_union_pw_aff_bind tests.\n * \"mupa\" is the input expression.\n * \"tuple\" is the binding tuple.\n * \"res\" is the expected result.\n */\nstatic\nstruct {\n\tconst char *mupa;\n\tconst char *tuple;\n\tconst char *res;\n} bind_mupa_tests[] = {\n\t{ \"A[{ [4] }, { [5] }]\",\n\t  \"{ A[M, N] }\",\n\t  \"[M = 4, N = 5] -> { : }\" },\n\t{ \"A[{ B[x] -> [floor(x/2)] }, { B[y] -> [y + 5] }]\",\n\t  \"{ A[M, N] }\",\n\t  \"[M, N] -> { B[x] : M = floor(x/2) and N = x + 5 }\" },\n\t{ \"[M] -> A[{ [4] }, { [M + 1] }]\",\n\t  \"{ A[M, N] }\",\n\t  \"[M = 4, N = 5] -> { : }\" },\n};\n\n/* Perform basic isl_multi_union_pw_aff_bind tests.\n */\nstatic isl_stat test_bind_mupa(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bind_mupa_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_multi_union_pw_aff *mupa;\n\t\tisl_union_set *res;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\tstr = bind_mupa_tests[i].mupa;\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx, str);\n\t\tstr = bind_mupa_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\tres = isl_multi_union_pw_aff_bind(mupa, tuple);\n\t\tr = uset_check_equal(res, bind_mupa_tests[i].res);\n\t\tisl_union_set_free(res);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Perform tests that reinterpret dimensions as parameters.\n */\nstatic int test_bind(isl_ctx *ctx)\n{\n\tif (test_bind_set(ctx) < 0)\n\t\treturn -1;\n\tif (test_bind_map_domain(ctx) < 0)\n\t\treturn -1;\n\tif (test_bind_umap_range(ctx) < 0)\n\t\treturn -1;\n\tif (test_bind_pma_domain(ctx) < 0)\n\t\treturn -1;\n\tif (test_bind_pma_domain_wrapped(ctx) < 0)\n\t\treturn -1;\n\tif (test_bind_aff(ctx) < 0)\n\t\treturn -1;\n\tif (test_bind_pa(ctx) < 0)\n\t\treturn -1;\n\tif (test_bind_mupa(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Inputs for isl_set_unbind_params tests.\n * \"set\" is the input parameter domain.\n * \"tuple\" is the tuple of the constructed set.\n * \"res\" is the expected result.\n */\nstruct {\n\tconst char *set;\n\tconst char *tuple;\n\tconst char *res;\n} unbind_set_tests[] = {\n\t{ \"[M, N] -> { : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ A[M, N] }\",\n\t  \"{ A[M, N] : M mod 2 = 0 and N mod 8 = 3 }\" },\n\t{ \"[M, N] -> { : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ B[N, M] }\",\n\t  \"{ B[N, M] : M mod 2 = 0 and N mod 8 = 3 }\" },\n\t{ \"[M, N] -> { : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ C[N] }\",\n\t  \"[M] -> { C[N] : M mod 2 = 0 and N mod 8 = 3 }\" },\n\t{ \"[M, N] -> { : M mod 2 = 0 and N mod 8 = 3 }\",\n\t  \"{ D[T, N] }\",\n\t  \"[M] -> { D[x, N] : M mod 2 = 0 and N mod 8 = 3 }\" },\n};\n\n/* Perform basic isl_set_unbind_params tests.\n */\nstatic isl_stat test_unbind_set(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(unbind_set_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_set *set;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\tset = isl_set_read_from_str(ctx, unbind_set_tests[i].set);\n\t\tstr = unbind_set_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\tset = isl_set_unbind_params(set, tuple);\n\t\tr = set_check_equal(set, unbind_set_tests[i].res);\n\t\tisl_set_free(set);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_aff_unbind_params_insert_domain tests.\n * \"aff\" is the input affine expression defined over a parameter domain.\n * \"tuple\" is the tuple of the domain that gets introduced.\n * \"res\" is the expected result.\n */\nstruct {\n\tconst char *aff;\n\tconst char *tuple;\n\tconst char *res;\n} unbind_aff_tests[] = {\n\t{ \"[M, N] -> { [M + floor(N/2)] }\",\n\t  \"{ A[M, N] }\",\n\t  \"{ A[M, N] -> [M + floor(N/2)] }\" },\n\t{ \"[M, N] -> { [M + floor(N/2)] }\",\n\t  \"{ B[N, M] }\",\n\t  \"{ B[N, M] -> [M + floor(N/2)] }\" },\n\t{ \"[M, N] -> { [M + floor(N/2)] }\",\n\t  \"{ C[N] }\",\n\t  \"[M] -> { C[N] -> [M + floor(N/2)] }\" },\n\t{ \"[M, N] -> { [M + floor(N/2)] }\",\n\t  \"{ D[A, B, C, N, Z] }\",\n\t  \"[M] -> { D[A, B, C, N, Z] -> [M + floor(N/2)] }\" },\n};\n\n/* Perform basic isl_aff_unbind_params_insert_domain tests.\n */\nstatic isl_stat test_unbind_aff(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(unbind_aff_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_aff *aff;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\taff = isl_aff_read_from_str(ctx, unbind_aff_tests[i].aff);\n\t\tstr = unbind_aff_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\taff = isl_aff_unbind_params_insert_domain(aff, tuple);\n\t\tr = aff_check_plain_equal(aff, unbind_aff_tests[i].res);\n\t\tisl_aff_free(aff);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for isl_multi_aff_unbind_params_insert_domain tests.\n * \"ma\" is the input multi affine expression defined over a parameter domain.\n * \"tuple\" is the tuple of the domain that gets introduced.\n * \"res\" is the expected result.\n */\nstatic struct {\n\tconst char *ma;\n\tconst char *tuple;\n\tconst char *res;\n} unbind_multi_aff_tests[] = {\n\t{ \"[M, N] -> { T[M + floor(N/2)] }\",\n\t  \"{ A[M, N] }\",\n\t  \"{ A[M, N] -> T[M + floor(N/2)] }\" },\n\t{ \"[M, N] -> { [M + floor(N/2)] }\",\n\t  \"{ B[N, M] }\",\n\t  \"{ B[N, M] -> [M + floor(N/2)] }\" },\n\t{ \"[M, N] -> { [M + floor(N/2)] }\",\n\t  \"{ C[N] }\",\n\t  \"[M] -> { C[N] -> [M + floor(N/2)] }\" },\n\t{ \"[M, N] -> { [M + floor(N/2)] }\",\n\t  \"{ D[A, B, C, N, Z] }\",\n\t  \"[M] -> { D[A, B, C, N, Z] -> [M + floor(N/2)] }\" },\n\t{ \"[M, N] -> { T[M + floor(N/2), N + floor(M/3)] }\",\n\t  \"{ A[M, N] }\",\n\t  \"{ A[M, N] -> T[M + floor(N/2), N + floor(M/3)] }\" },\n};\n\n/* Perform basic isl_multi_aff_unbind_params_insert_domain tests.\n */\nstatic isl_stat test_unbind_multi_aff(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(unbind_multi_aff_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_multi_aff *ma;\n\t\tisl_multi_id *tuple;\n\t\tisl_stat r;\n\n\t\tstr = unbind_multi_aff_tests[i].ma;\n\t\tma = isl_multi_aff_read_from_str(ctx, str);\n\t\tstr = unbind_multi_aff_tests[i].tuple;\n\t\ttuple = isl_multi_id_read_from_str(ctx, str);\n\t\tma = isl_multi_aff_unbind_params_insert_domain(ma, tuple);\n\t\tstr = unbind_multi_aff_tests[i].res;\n\t\tr = multi_aff_check_plain_equal(ma, str);\n\t\tisl_multi_aff_free(ma);\n\t\tif (r < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Perform tests that reinterpret parameters.\n */\nstatic int test_unbind(isl_ctx *ctx)\n{\n\tif (test_unbind_set(ctx) < 0)\n\t\treturn -1;\n\tif (test_unbind_aff(ctx) < 0)\n\t\treturn -1;\n\tif (test_unbind_multi_aff(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that \"pa\" consists of a single expression.\n */\nstatic int check_single_piece(isl_ctx *ctx, __isl_take isl_pw_aff *pa)\n{\n\tisl_size n;\n\n\tn = isl_pw_aff_n_piece(pa);\n\tisl_pw_aff_free(pa);\n\n\tif (n < 0)\n\t\treturn -1;\n\tif (n != 1)\n\t\tisl_die(ctx, isl_error_unknown, \"expecting single expression\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* Check that the computation below results in a single expression.\n * One or two expressions may result depending on which constraint\n * ends up being considered as redundant with respect to the other\n * constraints after the projection that is performed internally\n * by isl_set_dim_min.\n */\nstatic int test_dim_max_1(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_pw_aff *pa;\n\n\tstr = \"[n] -> { [a, b] : n >= 0 and 4a >= -4 + n and b >= 0 and \"\n\t\t\t\t\"-4a <= b <= 3 and b < n - 4a }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpa = isl_set_dim_min(set, 0);\n\treturn check_single_piece(ctx, pa);\n}\n\n/* Check that the computation below results in a single expression.\n * The PIP problem corresponding to these constraints has a row\n * that causes a split of the solution domain.  The solver should\n * first pick rows that split off empty parts such that the actual\n * solution domain does not get split.\n * Note that the description contains some redundant constraints.\n * If these constraints get removed first, then the row mentioned\n * above does not appear in the PIP problem.\n */\nstatic int test_dim_max_2(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_pw_aff *pa;\n\n\tstr = \"[P, N] -> { [a] : a < N and a >= 0 and N > P and a <= P and \"\n\t\t\t\t\"N > 0 and P >= 0 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpa = isl_set_dim_max(set, 0);\n\treturn check_single_piece(ctx, pa);\n}\n\nint test_dim_max(isl_ctx *ctx)\n{\n\tint equal;\n\tconst char *str;\n\tisl_set *set1, *set2;\n\tisl_set *set;\n\tisl_map *map;\n\tisl_pw_aff *pwaff;\n\n\tif (test_dim_max_1(ctx) < 0)\n\t\treturn -1;\n\tif (test_dim_max_2(ctx) < 0)\n\t\treturn -1;\n\n\tstr = \"[N] -> { [i] : 0 <= i <= min(N,10) }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpwaff = isl_set_dim_max(set, 0);\n\tset1 = isl_set_from_pw_aff(pwaff);\n\tstr = \"[N] -> { [10] : N >= 10; [N] : N <= 9 and N >= 0 }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tequal = isl_set_is_equal(set1, set2);\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\tstr = \"[N] -> { [i] : 0 <= i <= max(2N,N+6) }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpwaff = isl_set_dim_max(set, 0);\n\tset1 = isl_set_from_pw_aff(pwaff);\n\tstr = \"[N] -> { [6 + N] : -6 <= N <= 5; [2N] : N >= 6 }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tequal = isl_set_is_equal(set1, set2);\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\tstr = \"[N] -> { [i] : 0 <= i <= 2N or 0 <= i <= N+6 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpwaff = isl_set_dim_max(set, 0);\n\tset1 = isl_set_from_pw_aff(pwaff);\n\tstr = \"[N] -> { [6 + N] : -6 <= N <= 5; [2N] : N >= 6 }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tequal = isl_set_is_equal(set1, set2);\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\tstr = \"[N,M] -> { [i,j] -> [([i/16]), i%16, ([j/16]), j%16] : \"\n\t\t\t\"0 <= i < N and 0 <= j < M }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tset = isl_map_range(map);\n\n\tpwaff = isl_set_dim_max(isl_set_copy(set), 0);\n\tset1 = isl_set_from_pw_aff(pwaff);\n\tstr = \"[N,M] -> { [([(N-1)/16])] : M,N > 0 }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tequal = isl_set_is_equal(set1, set2);\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\n\tpwaff = isl_set_dim_max(isl_set_copy(set), 3);\n\tset1 = isl_set_from_pw_aff(pwaff);\n\tstr = \"[N,M] -> { [t] : t = min(M-1,15) and M,N > 0 }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tif (equal >= 0 && equal)\n\t\tequal = isl_set_is_equal(set1, set2);\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\n\tisl_set_free(set);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\t/* Check that solutions are properly merged. */\n\tstr = \"[n] -> { [a, b, c] : c >= -4a - 2b and \"\n\t\t\t\t\"c <= -1 + n - 4a - 2b and c >= -2b and \"\n\t\t\t\t\"4a >= -4 + n and c >= 0 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpwaff = isl_set_dim_min(set, 2);\n\tset1 = isl_set_from_pw_aff(pwaff);\n\tstr = \"[n] -> { [(0)] : n >= 1 }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tequal = isl_set_is_equal(set1, set2);\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\t/* Check that empty solution lie in the right space. */\n\tstr = \"[n] -> { [t,a] : 1 = 0 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpwaff = isl_set_dim_max(set, 0);\n\tset1 = isl_set_from_pw_aff(pwaff);\n\tstr = \"[n] -> { [t] : 1 = 0 }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tequal = isl_set_is_equal(set1, set2);\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\treturn 0;\n}\n\n/* Basic test for isl_pw_multi_aff_product.\n *\n * Check that multiple pieces are properly handled.\n */\nstatic int test_product_pma(isl_ctx *ctx)\n{\n\tisl_stat equal;\n\tconst char *str;\n\tisl_pw_multi_aff *pma1, *pma2;\n\n\tstr = \"{ A[i] -> B[1] : i < 0; A[i] -> B[2] : i >= 0 }\";\n\tpma1 = isl_pw_multi_aff_read_from_str(ctx, str);\n\tstr = \"{ C[] -> D[] }\";\n\tpma2 = isl_pw_multi_aff_read_from_str(ctx, str);\n\tpma1 = isl_pw_multi_aff_product(pma1, pma2);\n\tstr = \"{ [A[i] -> C[]] -> [B[(1)] -> D[]] : i < 0;\"\n\t\t\"[A[i] -> C[]] -> [B[(2)] -> D[]] : i >= 0 }\";\n\tequal = pw_multi_aff_check_plain_equal(pma1, str);\n\tisl_pw_multi_aff_free(pma1);\n\tif (equal < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint test_product(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_union_set *uset1, *uset2;\n\tint ok;\n\n\tstr = \"{ A[i] }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tset = isl_set_product(set, isl_set_copy(set));\n\tok = isl_set_is_wrapping(set);\n\tisl_set_free(set);\n\tif (ok < 0)\n\t\treturn -1;\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\tstr = \"{ [] }\";\n\tuset1 = isl_union_set_read_from_str(ctx, str);\n\tuset1 = isl_union_set_product(uset1, isl_union_set_copy(uset1));\n\tstr = \"{ [[] -> []] }\";\n\tuset2 = isl_union_set_read_from_str(ctx, str);\n\tok = isl_union_set_is_equal(uset1, uset2);\n\tisl_union_set_free(uset1);\n\tisl_union_set_free(uset2);\n\tif (ok < 0)\n\t\treturn -1;\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\tif (test_product_pma(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that two sets are not considered disjoint just because\n * they have a different set of (named) parameters.\n */\nstatic int test_disjoint(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set, *set2;\n\tint disjoint;\n\n\tstr = \"[n] -> { [[]->[]] }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tstr = \"{ [[]->[]] }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tdisjoint = isl_set_is_disjoint(set, set2);\n\tisl_set_free(set);\n\tisl_set_free(set2);\n\tif (disjoint < 0)\n\t\treturn -1;\n\tif (disjoint)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\treturn 0;\n}\n\n/* Inputs for isl_pw_multi_aff_is_equal tests.\n * \"f1\" and \"f2\" are the two function that need to be compared.\n * \"equal\" is the expected result.\n */\nstruct {\n\tint equal;\n\tconst char *f1;\n\tconst char *f2;\n} pma_equal_tests[] = {\n\t{ 1, \"[N] -> { [floor(N/2)] : 0 <= N <= 1 }\",\n\t     \"[N] -> { [0] : 0 <= N <= 1 }\" },\n\t{ 1, \"[N] -> { [floor(N/2)] : 0 <= N <= 2 }\",\n\t     \"[N] -> { [0] : 0 <= N <= 1; [1] : N = 2 }\" },\n\t{ 0, \"[N] -> { [floor(N/2)] : 0 <= N <= 2 }\",\n\t     \"[N] -> { [0] : 0 <= N <= 1 }\" },\n\t{ 0, \"{ [NaN] }\", \"{ [NaN] }\" },\n};\n\nint test_equal(isl_ctx *ctx)\n{\n\tint i;\n\tconst char *str;\n\tisl_set *set, *set2;\n\tint equal;\n\n\tstr = \"{ S_6[i] }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tstr = \"{ S_7[i] }\";\n\tset2 = isl_set_read_from_str(ctx, str);\n\tequal = isl_set_is_equal(set, set2);\n\tisl_set_free(set);\n\tisl_set_free(set2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\tfor (i = 0; i < ARRAY_SIZE(pma_equal_tests); ++i) {\n\t\tint expected = pma_equal_tests[i].equal;\n\t\tisl_pw_multi_aff *f1, *f2;\n\n\t\tf1 = isl_pw_multi_aff_read_from_str(ctx, pma_equal_tests[i].f1);\n\t\tf2 = isl_pw_multi_aff_read_from_str(ctx, pma_equal_tests[i].f2);\n\t\tequal = isl_pw_multi_aff_is_equal(f1, f2);\n\t\tisl_pw_multi_aff_free(f1);\n\t\tisl_pw_multi_aff_free(f2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (equal != expected)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected equality result\", return -1);\n\t}\n\n\treturn 0;\n}\n\nstatic int test_plain_fixed(isl_ctx *ctx, __isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, int fixed)\n{\n\tisl_bool test;\n\n\ttest = isl_map_plain_is_fixed(map, type, pos, NULL);\n\tisl_map_free(map);\n\tif (test < 0)\n\t\treturn -1;\n\tif (test == fixed)\n\t\treturn 0;\n\tif (fixed)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"map not detected as fixed\", return -1);\n\telse\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"map detected as fixed\", return -1);\n}\n\nint test_fixed(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_map *map;\n\n\tstr = \"{ [i] -> [i] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tif (test_plain_fixed(ctx, map, isl_dim_out, 0, 0))\n\t\treturn -1;\n\tstr = \"{ [i] -> [1] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tif (test_plain_fixed(ctx, map, isl_dim_out, 0, 1))\n\t\treturn -1;\n\tstr = \"{ S_1[p1] -> [o0] : o0 = -2 and p1 >= 1 and p1 <= 7 }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tif (test_plain_fixed(ctx, map, isl_dim_out, 0, 1))\n\t\treturn -1;\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_neg(map);\n\tif (test_plain_fixed(ctx, map, isl_dim_out, 0, 1))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct isl_vertices_test_data {\n\tconst char *set;\n\tint n;\n\tconst char *vertex[6];\n} vertices_tests[] = {\n\t{ \"{ A[t, i] : t = 12 and i >= 4 and i <= 12 }\",\n\t  2, { \"{ A[12, 4] }\", \"{ A[12, 12] }\" } },\n\t{ \"{ A[t, i] : t = 14 and i = 1 }\",\n\t  1, { \"{ A[14, 1] }\" } },\n\t{ \"[n, m] -> { [a, b, c] : b <= a and a <= n and b > 0 and c >= b and \"\n\t\t\t\t\"c <= m and m <= n and m > 0 }\",\n\t  6, {\n\t\t\"[n, m] -> { [n, m, m] : 0 < m <= n }\",\n\t\t\"[n, m] -> { [n, 1, m] : 0 < m <= n }\",\n\t\t\"[n, m] -> { [n, 1, 1] : 0 < m <= n }\",\n\t\t\"[n, m] -> { [m, m, m] : 0 < m <= n }\",\n\t\t\"[n, m] -> { [1, 1, m] : 0 < m <= n }\",\n\t\t\"[n, m] -> { [1, 1, 1] : 0 < m <= n }\"\n\t    } },\n};\n\n/* Check that \"vertex\" corresponds to one of the vertices in data->vertex.\n */\nstatic isl_stat find_vertex(__isl_take isl_vertex *vertex, void *user)\n{\n\tstruct isl_vertices_test_data *data = user;\n\tisl_ctx *ctx;\n\tisl_multi_aff *ma;\n\tisl_basic_set *bset;\n\tisl_pw_multi_aff *pma;\n\tint i;\n\tisl_bool equal;\n\n\tctx = isl_vertex_get_ctx(vertex);\n\tbset = isl_vertex_get_domain(vertex);\n\tma = isl_vertex_get_expr(vertex);\n\tpma = isl_pw_multi_aff_alloc(isl_set_from_basic_set(bset), ma);\n\n\tfor (i = 0; i < data->n; ++i) {\n\t\tisl_pw_multi_aff *pma_i;\n\n\t\tpma_i = isl_pw_multi_aff_read_from_str(ctx, data->vertex[i]);\n\t\tequal = isl_pw_multi_aff_plain_is_equal(pma, pma_i);\n\t\tisl_pw_multi_aff_free(pma_i);\n\n\t\tif (equal < 0 || equal)\n\t\t\tbreak;\n\t}\n\n\tisl_pw_multi_aff_free(pma);\n\tisl_vertex_free(vertex);\n\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\n\treturn equal ? isl_stat_ok : isl_stat_error;\n}\n\nint test_vertices(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vertices_tests); ++i) {\n\t\tisl_basic_set *bset;\n\t\tisl_vertices *vertices;\n\t\tint ok = 1;\n\t\tisl_size n;\n\n\t\tbset = isl_basic_set_read_from_str(ctx, vertices_tests[i].set);\n\t\tvertices = isl_basic_set_compute_vertices(bset);\n\t\tn = isl_vertices_get_n_vertices(vertices);\n\t\tif (vertices_tests[i].n != n)\n\t\t\tok = 0;\n\t\tif (isl_vertices_foreach_vertex(vertices, &find_vertex,\n\t\t\t\t\t\t&vertices_tests[i]) < 0)\n\t\t\tok = 0;\n\t\tisl_vertices_free(vertices);\n\t\tisl_basic_set_free(bset);\n\n\t\tif (n < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown, \"unexpected vertices\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of unary operations on isl_union_map.\n * \"fn\" is the function that is being tested.\n * \"arg\" is a string description of the input.\n * \"res\" is a string description of the expected result.\n */\nstatic struct {\n\t__isl_give isl_union_map *(*fn)(__isl_take isl_union_map *umap);\n\tconst char *arg;\n\tconst char *res;\n} umap_un_tests[] = {\n\t{ &isl_union_map_range_reverse,\n\t  \"{ A[] -> [B[] -> C[]]; A[] -> B[]; A[0] -> N[B[1] -> B[2]] }\",\n\t  \"{ A[] -> [C[] -> B[]]; A[0] -> N[B[2] -> B[1]] }\" },\n\t{ &isl_union_map_range_reverse,\n\t  \"{ A[] -> N[B[] -> C[]] }\",\n\t  \"{ A[] -> [C[] -> B[]] }\" },\n\t{ &isl_union_map_range_reverse,\n\t  \"{ A[] -> N[B[x] -> B[y]] }\",\n\t  \"{ A[] -> N[B[*] -> B[*]] }\" },\n};\n\n/* Perform basic tests of unary operations on isl_union_map.\n */\nstatic isl_stat test_un_union_map(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(umap_un_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_union_map *umap, *res;\n\t\tisl_bool equal;\n\n\t\tstr = umap_un_tests[i].arg;\n\t\tumap = isl_union_map_read_from_str(ctx, str);\n\t\tstr = umap_un_tests[i].res;\n\t\tres = isl_union_map_read_from_str(ctx, str);\n\t\tumap = umap_un_tests[i].fn(umap);\n\t\tequal = isl_union_map_is_equal(umap, res);\n\t\tisl_union_map_free(umap);\n\t\tisl_union_map_free(res);\n\t\tif (equal < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return isl_stat_error);\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Inputs for basic tests of binary operations on isl_union_map.\n * \"fn\" is the function that is being tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstatic struct {\n\t__isl_give isl_union_map *(*fn)(__isl_take isl_union_map *umap1,\n\t\t\t\t__isl_take isl_union_map *umap2);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} umap_bin_tests[] = {\n\t{ &isl_union_map_intersect,\n\t  \"[n] -> { A[i] -> [] : 0 <= i <= n; B[] -> [] }\",\n\t  \"[m] -> { A[i] -> [] : 0 <= i <= m; C[] -> [] }\",\n\t  \"[m, n] -> { A[i] -> [] : 0 <= i <= n and i <= m }\" },\n\t{ &isl_union_map_intersect_domain_factor_domain,\n\t  \"{ [A[i] -> B[i + 1]] -> C[i + 2] }\",\n\t  \"[N] -> { B[i] -> C[N] }\",\n\t  \"{ }\" },\n\t{ &isl_union_map_intersect_domain_factor_domain,\n\t  \"{ [A[i] -> B[i + 1]] -> C[i + 2] }\",\n\t  \"[N] -> { A[i] -> C[N] }\",\n\t  \"[N] -> { [A[N - 2] -> B[N - 1]] -> C[N] }\" },\n\t{ &isl_union_map_intersect_domain_factor_domain,\n\t  \"{ T[A[i] -> B[i + 1]] -> C[i + 2] }\",\n\t  \"[N] -> { A[i] -> C[N] }\",\n\t  \"[N] -> { T[A[N - 2] -> B[N - 1]] -> C[N] }\" },\n\t{ &isl_union_map_intersect_domain_factor_range,\n\t  \"{ [A[i] -> B[i + 1]] -> C[i + 2] }\",\n\t  \"[N] -> { B[i] -> C[N] }\",\n\t  \"[N] -> { [A[N - 2] -> B[N - 1]] -> C[N] }\" },\n\t{ &isl_union_map_intersect_domain_factor_range,\n\t  \"{ T[A[i] -> B[i + 1]] -> C[i + 2] }\",\n\t  \"[N] -> { B[i] -> C[N] }\",\n\t  \"[N] -> { T[A[N - 2] -> B[N - 1]] -> C[N] }\" },\n\t{ &isl_union_map_intersect_domain_factor_range,\n\t  \"{ [A[i] -> B[i + 1]] -> C[i + 2] }\",\n\t  \"[N] -> { A[i] -> C[N] }\",\n\t  \"{ }\" },\n\t{ &isl_union_map_intersect_range_factor_domain,\n\t  \"{ A[i] -> [B[i + 1] -> C[i + 2]] }\",\n\t  \"[N] -> { A[i] -> B[N] }\",\n\t  \"[N] -> { A[N - 1] -> [B[N] -> C[N + 1]] }\" },\n\t{ &isl_union_map_intersect_range_factor_domain,\n\t  \"{ A[i] -> T[B[i + 1] -> C[i + 2]] }\",\n\t  \"[N] -> { A[i] -> B[N] }\",\n\t  \"[N] -> { A[N - 1] -> T[B[N] -> C[N + 1]] }\" },\n\t{ &isl_union_map_intersect_range_factor_domain,\n\t  \"{ A[i] -> [B[i + 1] -> C[i + 2]] }\",\n\t  \"[N] -> { A[i] -> C[N] }\",\n\t  \"{ }\" },\n\t{ &isl_union_map_intersect_range_factor_range,\n\t  \"{ A[i] -> [B[i + 1] -> C[i + 2]] }\",\n\t  \"[N] -> { A[i] -> C[N] }\",\n\t  \"[N] -> { A[N - 2] -> [B[N - 1] -> C[N]] }\" },\n\t{ &isl_union_map_intersect_range_factor_range,\n\t  \"{ A[i] -> T[B[i + 1] -> C[i + 2]] }\",\n\t  \"[N] -> { A[i] -> C[N] }\",\n\t  \"[N] -> { A[N - 2] -> T[B[N - 1] -> C[N]] }\" },\n\t{ &isl_union_map_intersect_range_factor_range,\n\t  \"{ A[i] -> [B[i + 1] -> C[i + 2]] }\",\n\t  \"[N] -> { A[i] -> B[N] }\",\n\t  \"{ }\" },\n};\n\n/* Perform basic tests of binary operations on isl_union_map.\n */\nstatic isl_stat test_bin_union_map(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(umap_bin_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_union_map *umap1, *umap2, *res;\n\t\tisl_bool equal;\n\n\t\tstr = umap_bin_tests[i].arg1;\n\t\tumap1 = isl_union_map_read_from_str(ctx, str);\n\t\tstr = umap_bin_tests[i].arg2;\n\t\tumap2 = isl_union_map_read_from_str(ctx, str);\n\t\tstr = umap_bin_tests[i].res;\n\t\tres = isl_union_map_read_from_str(ctx, str);\n\t\tumap1 = umap_bin_tests[i].fn(umap1, umap2);\n\t\tequal = isl_union_map_is_equal(umap1, res);\n\t\tisl_union_map_free(umap1);\n\t\tisl_union_map_free(res);\n\t\tif (equal < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return isl_stat_error);\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Check that isl_union_set_contains finds space independently\n * of the parameters.\n */\nstatic isl_stat test_union_set_contains(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_bool ok;\n\tisl_space *space;\n\tisl_id *id;\n\tisl_union_set *uset;\n\n\tstr = \"[N] -> { A[0:N]; B[*,*] }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tspace = isl_space_unit(ctx);\n\tid = isl_id_alloc(ctx, \"A\", NULL);\n\tspace = isl_space_add_named_tuple_id_ui(space, id, 1);\n\tok = isl_union_set_contains(uset, space);\n\tisl_space_free(space);\n\tisl_union_set_free(uset);\n\n\tif (ok < 0)\n\t\treturn isl_stat_error;\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected result\", return isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\n/* Perform basic tests of operations on isl_union_map or isl_union_set.\n */\nstatic int test_union_map(isl_ctx *ctx)\n{\n\tif (test_un_union_map(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_union_map(ctx) < 0)\n\t\treturn -1;\n\tif (test_union_set_contains(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nint test_union_pw(isl_ctx *ctx)\n{\n\tint equal;\n\tconst char *str;\n\tisl_union_set *uset;\n\tisl_union_pw_qpolynomial *upwqp1, *upwqp2;\n\n\tstr = \"{ [x] -> x^2 }\";\n\tupwqp1 = isl_union_pw_qpolynomial_read_from_str(ctx, str);\n\tupwqp2 = isl_union_pw_qpolynomial_copy(upwqp1);\n\tuset = isl_union_pw_qpolynomial_domain(upwqp1);\n\tupwqp1 = isl_union_pw_qpolynomial_copy(upwqp2);\n\tupwqp1 = isl_union_pw_qpolynomial_intersect_domain(upwqp1, uset);\n\tequal = isl_union_pw_qpolynomial_plain_is_equal(upwqp1, upwqp2);\n\tisl_union_pw_qpolynomial_free(upwqp1);\n\tisl_union_pw_qpolynomial_free(upwqp2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of functions that select\n * subparts of the domain of an isl_multi_union_pw_aff.\n * \"fn\" is the function that is tested.\n * \"arg\" is a string description of the input.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_union_set *(*fn)(\n\t\t__isl_take isl_multi_union_pw_aff *mupa);\n\tconst char *arg;\n\tconst char *res;\n} un_locus_tests[] = {\n\t{ &isl_multi_union_pw_aff_zero_union_set,\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i] }]\",\n\t  \"{ A[0,j]; B[0,j] }\" },\n\t{ &isl_multi_union_pw_aff_zero_union_set,\n\t  \"F[{ A[i,j] -> [i-j]; B[i,j] -> [i-j] : i >= 0 }]\",\n\t  \"{ A[i,i]; B[i,i] : i >= 0 }\" },\n\t{ &isl_multi_union_pw_aff_zero_union_set,\n\t  \"(F[] : { A[i,j]; B[i,i] : i >= 0 })\",\n\t  \"{ A[i,j]; B[i,i] : i >= 0 }\" },\n};\n\n/* Perform some basic tests of functions that select\n * subparts of the domain of an isl_multi_union_pw_aff.\n */\nstatic int test_un_locus(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_union_set *uset, *res;\n\tisl_multi_union_pw_aff *mupa;\n\n\tfor (i = 0; i < ARRAY_SIZE(un_locus_tests); ++i) {\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    un_locus_tests[i].arg);\n\t\tres = isl_union_set_read_from_str(ctx, un_locus_tests[i].res);\n\t\tuset = un_locus_tests[i].fn(mupa);\n\t\tok = isl_union_set_is_equal(uset, res);\n\t\tisl_union_set_free(uset);\n\t\tisl_union_set_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of functions that select\n * subparts of an isl_union_map based on a relation\n * specified by an isl_multi_union_pw_aff.\n * \"fn\" is the function that is tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstruct {\n\t__isl_give isl_union_map *(*fn)(\n\t\t__isl_take isl_union_map *umap,\n\t\t__isl_take isl_multi_union_pw_aff *mupa);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} bin_locus_tests[] = {\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i] }]\",\n\t  \"{ A[i,j] -> B[i,j'] }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [j] }]\",\n\t  \"{ A[i,j] -> B[i,j] }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j']; A[i,j] -> C[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i] }]\",\n\t  \"{ A[i,j] -> B[i,j'] }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j']; A[i,j] -> C[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i]; C[i,j] -> [0] }]\",\n\t  \"{ A[i,j] -> B[i,j']; A[0,j] -> C[i',j'] }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i] : i > j; B[i,j] -> [i] }]\",\n\t  \"{ A[i,j] -> B[i,j'] : i > j }\" },\n\t{ &isl_union_map_lex_le_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [j] }]\",\n\t  \"{ A[i,j] -> B[i',j'] : i,j <<= i',j' }\" },\n\t{ &isl_union_map_lex_lt_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [j] }]\",\n\t  \"{ A[i,j] -> B[i',j'] : i,j << i',j' }\" },\n\t{ &isl_union_map_lex_ge_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [j] }]\",\n\t  \"{ A[i,j] -> B[i',j'] : i,j >>= i',j' }\" },\n\t{ &isl_union_map_lex_gt_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"F[{ A[i,j] -> [i]; B[i,j] -> [i] }, \"\n\t    \"{ A[i,j] -> [j]; B[i,j] -> [j] }]\",\n\t  \"{ A[i,j] -> B[i',j'] : i,j >> i',j' }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j']; A[i,j] -> C[i',j'] }\",\n\t  \"(F[] : { A[i,j]; B[i,j] })\",\n\t  \"{ A[i,j] -> B[i',j'] }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"(F[] : { A[i,j] : i > j; B[i,j] : i < j })\",\n\t  \"{ A[i,j] -> B[i',j'] : i > j and i' < j' }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"[N] -> { A[i,j] -> B[i',j'] : i,i' <= N }\",\n\t  \"(F[] : { A[i,j] : i > j; B[i,j] : i < j })\",\n\t  \"[N] -> { A[i,j] -> B[i',j'] : i > j and i' < j' and i,i' <= N }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"[N] -> (F[] : { A[i,j] : i < N; B[i,j] : i < N })\",\n\t  \"[N] -> { A[i,j] -> B[i',j'] : i,i' < N }\" },\n\t{ &isl_union_map_eq_at_multi_union_pw_aff,\n\t  \"{ A[i,j] -> B[i',j'] }\",\n\t  \"[N] -> (F[] : { : N >= 0 })\",\n\t  \"[N] -> { A[i,j] -> B[i',j'] : N >= 0 }\" },\n};\n\n/* Perform some basic tests of functions that select\n * subparts of an isl_union_map based on a relation\n * specified by an isl_multi_union_pw_aff.\n */\nstatic int test_bin_locus(isl_ctx *ctx)\n{\n\tint i;\n\tisl_bool ok;\n\tisl_union_map *umap, *res;\n\tisl_multi_union_pw_aff *mupa;\n\n\tfor (i = 0; i < ARRAY_SIZE(bin_locus_tests); ++i) {\n\t\tumap = isl_union_map_read_from_str(ctx,\n\t\t\t\t\t\t    bin_locus_tests[i].arg1);\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx,\n\t\t\t\t\t\t    bin_locus_tests[i].arg2);\n\t\tres = isl_union_map_read_from_str(ctx, bin_locus_tests[i].res);\n\t\tumap = bin_locus_tests[i].fn(umap, mupa);\n\t\tok = isl_union_map_is_equal(umap, res);\n\t\tisl_union_map_free(umap);\n\t\tisl_union_map_free(res);\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Inputs for basic tests of functions that determine\n * the part of the domain where two isl_multi_aff objects\n * related to each other in a specific way.\n * \"fn\" is the function that is being tested.\n * \"arg1\" and \"arg2\" are string descriptions of the inputs.\n * \"res\" is a string description of the expected result.\n */\nstatic struct {\n\t__isl_give isl_set *(*fn)(__isl_take isl_multi_aff *ma1,\n\t\t__isl_take isl_multi_aff *ma2);\n\tconst char *arg1;\n\tconst char *arg2;\n\tconst char *res;\n} bin_locus_ma_tests[] = {\n\t{ &isl_multi_aff_lex_le_set, \"{ [] }\", \"{ [] }\", \"{ : }\" },\n\t{ &isl_multi_aff_lex_lt_set, \"{ [] }\", \"{ [] }\", \"{ : false }\" },\n\t{ &isl_multi_aff_lex_le_set,\n\t  \"{ A[i] -> [i] }\", \"{ A[i] -> [0] }\",\n\t  \"{ A[i] : i <= 0 }\" },\n\t{ &isl_multi_aff_lex_lt_set,\n\t  \"{ A[i] -> [i] }\", \"{ A[i] -> [0] }\",\n\t  \"{ A[i] : i < 0 }\" },\n\t{ &isl_multi_aff_lex_le_set,\n\t  \"{ A[i] -> [i, i] }\", \"{ A[i] -> [0, 0] }\",\n\t  \"{ A[i] : i <= 0 }\" },\n\t{ &isl_multi_aff_lex_le_set,\n\t  \"{ A[i] -> [i, 0] }\", \"{ A[i] -> [0, 0] }\",\n\t  \"{ A[i] : i <= 0 }\" },\n\t{ &isl_multi_aff_lex_le_set,\n\t  \"{ A[i] -> [i, 1] }\", \"{ A[i] -> [0, 0] }\",\n\t  \"{ A[i] : i < 0 }\" },\n};\n\n/* Perform some basic tests of functions that determine\n * the part of the domain where two isl_multi_aff objects\n * related to each other in a specific way.\n */\nstatic isl_stat test_bin_locus_ma(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bin_locus_ma_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_bool ok;\n\t\tisl_multi_aff *ma1, *ma2;\n\t\tisl_set *set, *res;\n\n\t\tstr = bin_locus_ma_tests[i].arg1;\n\t\tma1 = isl_multi_aff_read_from_str(ctx, str);\n\t\tstr = bin_locus_ma_tests[i].arg2;\n\t\tma2 = isl_multi_aff_read_from_str(ctx, str);\n\t\tres = isl_set_read_from_str(ctx, bin_locus_ma_tests[i].res);\n\t\tset = bin_locus_ma_tests[i].fn(ma1, ma2);\n\t\tok = isl_set_is_equal(set, res);\n\t\tisl_set_free(set);\n\t\tisl_set_free(res);\n\t\tif (ok < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!ok)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return isl_stat_error);\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Perform basic locus tests.\n */\nstatic int test_locus(isl_ctx *ctx)\n{\n\tif (test_un_locus(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_locus(ctx) < 0)\n\t\treturn -1;\n\tif (test_bin_locus_ma(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Test that isl_union_pw_qpolynomial_eval picks up the function\n * defined over the correct domain space.\n */\nstatic int test_eval_1(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_point *pnt;\n\tisl_set *set;\n\tisl_union_pw_qpolynomial *upwqp;\n\tisl_val *v;\n\tint cmp;\n\n\tstr = \"{ A[x] -> x^2; B[x] -> -x^2 }\";\n\tupwqp = isl_union_pw_qpolynomial_read_from_str(ctx, str);\n\tstr = \"{ A[6] }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpnt = isl_set_sample_point(set);\n\tv = isl_union_pw_qpolynomial_eval(upwqp, pnt);\n\tcmp = isl_val_cmp_si(v, 36);\n\tisl_val_free(v);\n\n\tif (!v)\n\t\treturn -1;\n\tif (cmp != 0)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected value\", return -1);\n\n\treturn 0;\n}\n\n/* Check that isl_qpolynomial_eval handles getting called on a void point.\n */\nstatic int test_eval_2(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_point *pnt;\n\tisl_set *set;\n\tisl_qpolynomial *qp;\n\tisl_val *v;\n\tisl_bool ok;\n\n\tstr = \"{ A[x] -> [x] }\";\n\tqp = isl_qpolynomial_from_aff(isl_aff_read_from_str(ctx, str));\n\tstr = \"{ A[x] : false }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tpnt = isl_set_sample_point(set);\n\tv = isl_qpolynomial_eval(qp, pnt);\n\tok = isl_val_is_nan(v);\n\tisl_val_free(v);\n\n\tif (ok < 0)\n\t\treturn -1;\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown, \"expecting NaN\", return -1);\n\n\treturn 0;\n}\n\n/* Check that a polynomial (without local variables) can be evaluated\n * in a rational point.\n */\nstatic isl_stat test_eval_3(isl_ctx *ctx)\n{\n\tisl_pw_qpolynomial *pwqp;\n\tisl_point *pnt;\n\tisl_val *v;\n\tisl_stat r;\n\n\tpwqp = isl_pw_qpolynomial_read_from_str(ctx, \"{ [x] -> x^2 }\");\n\tpnt = isl_point_zero(isl_pw_qpolynomial_get_domain_space(pwqp));\n\tv = isl_val_read_from_str(ctx, \"1/2\");\n\tpnt = isl_point_set_coordinate_val(pnt, isl_dim_set, 0, v);\n\tv = isl_pw_qpolynomial_eval(pwqp, pnt);\n\tr = val_check_equal(v, \"1/4\");\n\tisl_val_free(v);\n\n\treturn r;\n}\n\n/* Inputs for isl_pw_aff_eval test.\n * \"f\" is the affine function.\n * \"p\" is the point where the function should be evaluated.\n * \"res\" is the expected result.\n */\nstruct {\n\tconst char *f;\n\tconst char *p;\n\tconst char *res;\n} aff_eval_tests[] = {\n\t{ \"{ [i] -> [2 * i] }\", \"{ [4] }\", \"8\" },\n\t{ \"{ [i] -> [2 * i] }\", \"{ [x] : false }\", \"NaN\" },\n\t{ \"{ [i] -> [i + floor(i/2) + floor(i/3)] }\", \"{ [0] }\", \"0\" },\n\t{ \"{ [i] -> [i + floor(i/2) + floor(i/3)] }\", \"{ [1] }\", \"1\" },\n\t{ \"{ [i] -> [i + floor(i/2) + floor(i/3)] }\", \"{ [2] }\", \"3\" },\n\t{ \"{ [i] -> [i + floor(i/2) + floor(i/3)] }\", \"{ [3] }\", \"5\" },\n\t{ \"{ [i] -> [i + floor(i/2) + floor(i/3)] }\", \"{ [4] }\", \"7\" },\n\t{ \"{ [i] -> [floor((3 * floor(i/2))/5)] }\", \"{ [0] }\", \"0\" },\n\t{ \"{ [i] -> [floor((3 * floor(i/2))/5)] }\", \"{ [1] }\", \"0\" },\n\t{ \"{ [i] -> [floor((3 * floor(i/2))/5)] }\", \"{ [2] }\", \"0\" },\n\t{ \"{ [i] -> [floor((3 * floor(i/2))/5)] }\", \"{ [3] }\", \"0\" },\n\t{ \"{ [i] -> [floor((3 * floor(i/2))/5)] }\", \"{ [4] }\", \"1\" },\n\t{ \"{ [i] -> [floor((3 * floor(i/2))/5)] }\", \"{ [6] }\", \"1\" },\n\t{ \"{ [i] -> [floor((3 * floor(i/2))/5)] }\", \"{ [8] }\", \"2\" },\n\t{ \"{ [i] -> [i] : i > 0; [i] -> [-i] : i < 0 }\", \"{ [4] }\", \"4\" },\n\t{ \"{ [i] -> [i] : i > 0; [i] -> [-i] : i < 0 }\", \"{ [-2] }\", \"2\" },\n\t{ \"{ [i] -> [i] : i > 0; [i] -> [-i] : i < 0 }\", \"{ [0] }\", \"NaN\" },\n\t{ \"[N] -> { [2 * N] }\", \"[N] -> { : N = 4 }\", \"8\" },\n\t{ \"{ [i, j] -> [(i + j)/2] }\", \"{ [1, 1] }\", \"1\" },\n\t{ \"{ [i, j] -> [(i + j)/2] }\", \"{ [1, 2] }\", \"3/2\" },\n\t{ \"{ [i] -> [i] : i mod 2 = 0 }\", \"{ [4] }\", \"4\" },\n\t{ \"{ [i] -> [i] : i mod 2 = 0 }\", \"{ [3] }\", \"NaN\" },\n\t{ \"{ [i] -> [i] : i mod 2 = 0 }\", \"{ [x] : false }\", \"NaN\" },\n};\n\n/* Perform basic isl_pw_aff_eval tests.\n */\nstatic int test_eval_aff(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(aff_eval_tests); ++i) {\n\t\tisl_stat r;\n\t\tisl_pw_aff *pa;\n\t\tisl_set *set;\n\t\tisl_point *pnt;\n\t\tisl_val *v;\n\n\t\tpa = isl_pw_aff_read_from_str(ctx, aff_eval_tests[i].f);\n\t\tset = isl_set_read_from_str(ctx, aff_eval_tests[i].p);\n\t\tpnt = isl_set_sample_point(set);\n\t\tv = isl_pw_aff_eval(pa, pnt);\n\t\tr = val_check_equal(v, aff_eval_tests[i].res);\n\t\tisl_val_free(v);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* Perform basic evaluation tests.\n */\nstatic int test_eval(isl_ctx *ctx)\n{\n\tif (test_eval_1(ctx) < 0)\n\t\treturn -1;\n\tif (test_eval_2(ctx) < 0)\n\t\treturn -1;\n\tif (test_eval_3(ctx) < 0)\n\t\treturn -1;\n\tif (test_eval_aff(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Descriptions of sets that are tested for reparsing after printing.\n */\nconst char *output_tests[] = {\n\t\"{ [1, y] : 0 <= y <= 1; [x, -x] : 0 <= x <= 1 }\",\n\t\"{ [x] : 1 = 0 }\",\n\t\"{ [x] : false }\",\n\t\"{ [x] : x mod 2 = 0 }\",\n\t\"{ [x] : x mod 2 = 1 }\",\n\t\"{ [x, y] : x mod 2 = 0 and 3*floor(y/2) < x }\",\n\t\"{ [y, x] : x mod 2 = 0 and 3*floor(y/2) < x }\",\n\t\"{ [x, y] : x mod 2 = 0 and 3*floor(y/2) = x + y }\",\n\t\"{ [y, x] : x mod 2 = 0 and 3*floor(y/2) = x + y }\",\n\t\"[n] -> { [y, x] : 2*((x + 2y) mod 3) = n }\",\n\t\"{ [x, y] : (2*floor(x/3) + 3*floor(y/4)) mod 5 = x }\",\n};\n\n/* Check that printing a set and reparsing a set from the printed output\n * results in the same set.\n */\nstatic int test_output_set(isl_ctx *ctx)\n{\n\tint i;\n\tchar *str;\n\tisl_set *set1, *set2;\n\tisl_bool equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(output_tests); ++i) {\n\t\tset1 = isl_set_read_from_str(ctx, output_tests[i]);\n\t\tstr = isl_set_to_str(set1);\n\t\tset2 = isl_set_read_from_str(ctx, str);\n\t\tfree(str);\n\t\tequal = isl_set_is_equal(set1, set2);\n\t\tisl_set_free(set1);\n\t\tisl_set_free(set2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"parsed output not the same\", return -1);\n\t}\n\n\treturn 0;\n}\n\n/* Check that an isl_multi_aff is printed using a consistent space.\n */\nstatic isl_stat test_output_ma(isl_ctx *ctx)\n{\n\tchar *str;\n\tisl_bool equal;\n\tisl_aff *aff;\n\tisl_multi_aff *ma, *ma2;\n\n\tma = isl_multi_aff_read_from_str(ctx, \"{ [a, b] -> [a + b] }\");\n\taff = isl_aff_read_from_str(ctx, \"{ [c, d] -> [c + d] }\");\n\tma = isl_multi_aff_set_aff(ma, 0, aff);\n\tstr = isl_multi_aff_to_str(ma);\n\tma2 = isl_multi_aff_read_from_str(ctx, str);\n\tfree(str);\n\tequal = isl_multi_aff_plain_is_equal(ma, ma2);\n\tisl_multi_aff_free(ma2);\n\tisl_multi_aff_free(ma);\n\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"bad conversion\",\n\t\t\treturn isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\n/* Check that an isl_multi_pw_aff is printed using a consistent space.\n */\nstatic isl_stat test_output_mpa(isl_ctx *ctx)\n{\n\tchar *str;\n\tisl_bool equal;\n\tisl_pw_aff *pa;\n\tisl_multi_pw_aff *mpa, *mpa2;\n\n\tmpa = isl_multi_pw_aff_read_from_str(ctx, \"{ [a, b] -> [a + b] }\");\n\tpa = isl_pw_aff_read_from_str(ctx, \"{ [c, d] -> [c + d] }\");\n\tmpa = isl_multi_pw_aff_set_pw_aff(mpa, 0, pa);\n\tstr = isl_multi_pw_aff_to_str(mpa);\n\tmpa2 = isl_multi_pw_aff_read_from_str(ctx, str);\n\tfree(str);\n\tequal = isl_multi_pw_aff_plain_is_equal(mpa, mpa2);\n\tisl_multi_pw_aff_free(mpa2);\n\tisl_multi_pw_aff_free(mpa);\n\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"bad conversion\",\n\t\t\treturn isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\nint test_output(isl_ctx *ctx)\n{\n\tchar *s;\n\tconst char *str;\n\tisl_pw_aff *pa;\n\tisl_printer *p;\n\tint equal;\n\n\tif (test_output_set(ctx) < 0)\n\t\treturn -1;\n\tif (test_output_ma(ctx) < 0)\n\t\treturn -1;\n\tif (test_output_mpa(ctx) < 0)\n\t\treturn -1;\n\n\tstr = \"[x] -> { [1] : x % 4 <= 2; [2] : x = 3 }\";\n\tpa = isl_pw_aff_read_from_str(ctx, str);\n\n\tp = isl_printer_to_str(ctx);\n\tp = isl_printer_set_output_format(p, ISL_FORMAT_C);\n\tp = isl_printer_print_pw_aff(p, pa);\n\ts = isl_printer_get_str(p);\n\tisl_printer_free(p);\n\tisl_pw_aff_free(pa);\n\tif (!s)\n\t\tequal = -1;\n\telse\n\t\tequal = !strcmp(s, \"4 * floord(x, 4) + 2 >= x ? 1 : 2\");\n\tfree(s);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected result\", return -1);\n\n\treturn 0;\n}\n\nint test_sample(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset1, *bset2;\n\tint empty, subset;\n\n\tstr = \"{ [a, b, c, d, e, f, g, h, i, j, k] : \"\n\t    \"3i >= 1073741823b - c - 1073741823e + f and c >= 0 and \"\n\t    \"3i >= -1 + 3221225466b + c + d - 3221225466e - f and \"\n\t    \"2e >= a - b and 3e <= 2a and 3k <= -a and f <= -1 + a and \"\n\t    \"3i <= 4 - a + 4b + 2c - e - 2f and 3k <= -a + c - f and \"\n\t    \"3h >= -2 + a and 3g >= -3 - a and 3k >= -2 - a and \"\n\t    \"3i >= -2 - a - 2c + 3e + 2f and 3h <= a + c - f and \"\n\t    \"3h >= a + 2147483646b + 2c - 2147483646e - 2f and \"\n\t    \"3g <= -1 - a and 3i <= 1 + c + d - f and a <= 1073741823 and \"\n\t    \"f >= 1 - a + 1073741822b + c + d - 1073741822e and \"\n\t    \"3i >= 1 + 2b - 2c + e + 2f + 3g and \"\n\t    \"1073741822f <= 1073741822 - a + 1073741821b + 1073741822c +\"\n\t\t\"d - 1073741821e and \"\n\t    \"3j <= 3 - a + 3b and 3g <= -2 - 2b + c + d - e - f and \"\n\t    \"3j >= 1 - a + b + 2e and \"\n\t    \"3f >= -3 + a + 3221225462b + 3c + d - 3221225465e and \"\n\t    \"3i <= 4 - a + 4b - e and \"\n\t    \"f <= 1073741822 + 1073741822b - 1073741822e and 3h <= a and \"\n\t    \"f >= 0 and 2e <= 4 - a + 5b - d and 2e <= a - b + d and \"\n\t    \"c <= -1 + a and 3i >= -2 - a + 3e and \"\n\t    \"1073741822e <= 1073741823 - a + 1073741822b + c and \"\n\t    \"3g >= -4 + 3221225464b + 3c + d - 3221225467e - 3f and \"\n\t    \"3i >= -1 + 3221225466b + 3c + d - 3221225466e - 3f and \"\n\t    \"1073741823e >= 1 + 1073741823b - d and \"\n\t    \"3i >= 1073741823b + c - 1073741823e - f and \"\n\t    \"3i >= 1 + 2b + e + 3g }\";\n\tbset1 = isl_basic_set_read_from_str(ctx, str);\n\tbset2 = isl_basic_set_sample(isl_basic_set_copy(bset1));\n\tempty = isl_basic_set_is_empty(bset2);\n\tsubset = isl_basic_set_is_subset(bset2, bset1);\n\tisl_basic_set_free(bset1);\n\tisl_basic_set_free(bset2);\n\tif (empty < 0 || subset < 0)\n\t\treturn -1;\n\tif (empty)\n\t\tisl_die(ctx, isl_error_unknown, \"point not found\", return -1);\n\tif (!subset)\n\t\tisl_die(ctx, isl_error_unknown, \"bad point found\", return -1);\n\n\treturn 0;\n}\n\nint test_fixed_power(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_map *map;\n\tisl_val *exp;\n\tint equal;\n\n\tstr = \"{ [i] -> [i + 1] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\texp = isl_val_int_from_si(ctx, 23);\n\tmap = isl_map_fixed_power_val(map, exp);\n\tequal = map_check_equal(map, \"{ [i] -> [i + 23] }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint test_slice(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_map *map;\n\tint equal;\n\n\tstr = \"{ [i] -> [j] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_equate(map, isl_dim_in, 0, isl_dim_out, 0);\n\tequal = map_check_equal(map, \"{ [i] -> [i] }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\tstr = \"{ [i] -> [j] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_equate(map, isl_dim_in, 0, isl_dim_in, 0);\n\tequal = map_check_equal(map, \"{ [i] -> [j] }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\tstr = \"{ [i] -> [j] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_oppose(map, isl_dim_in, 0, isl_dim_out, 0);\n\tequal = map_check_equal(map, \"{ [i] -> [-i] }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\tstr = \"{ [i] -> [j] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_oppose(map, isl_dim_in, 0, isl_dim_in, 0);\n\tequal = map_check_equal(map, \"{ [0] -> [j] }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\tstr = \"{ [i] -> [j] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_order_gt(map, isl_dim_in, 0, isl_dim_out, 0);\n\tequal = map_check_equal(map, \"{ [i] -> [j] : i > j }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\tstr = \"{ [i] -> [j] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_order_gt(map, isl_dim_in, 0, isl_dim_in, 0);\n\tequal = map_check_equal(map, \"{ [i] -> [j] : false }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint test_eliminate(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_map *map;\n\tint equal;\n\n\tstr = \"{ [i] -> [j] : i = 2j }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_eliminate(map, isl_dim_out, 0, 1);\n\tequal = map_check_equal(map, \"{ [i] -> [j] : exists a : i = 2a }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check basic functionality of isl_map_deltas_map.\n */\nstatic int test_deltas_map(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_map *map;\n\tint equal;\n\n\tstr = \"{ A[i] -> A[i + 1] }\";\n\tmap = isl_map_read_from_str(ctx, str);\n\tmap = isl_map_deltas_map(map);\n\tequal = map_check_equal(map, \"{ [A[i] -> A[i + 1]] -> A[1] }\");\n\tisl_map_free(map);\n\tif (equal < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that isl_set_dim_residue_class detects that the values of j\n * in the set below are all odd and that it does not detect any spurious\n * strides.\n */\nstatic int test_residue_class(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_int m, r;\n\tisl_stat res;\n\n\tstr = \"{ [i,j] : j = 4 i + 1 and 0 <= i <= 100; \"\n\t\t\"[i,j] : j = 4 i + 3 and 500 <= i <= 600 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tisl_int_init(m);\n\tisl_int_init(r);\n\tres = isl_set_dim_residue_class(set, 1, &m, &r);\n\tif (res >= 0 &&\n\t    (isl_int_cmp_si(m, 2) != 0 || isl_int_cmp_si(r, 1) != 0))\n\t\tisl_die(ctx, isl_error_unknown, \"incorrect residue class\",\n\t\t\tres = isl_stat_error);\n\tisl_int_clear(r);\n\tisl_int_clear(m);\n\tisl_set_free(set);\n\n\treturn res;\n}\n\nstatic int test_align_parameters_1(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_space *space;\n\tisl_multi_aff *ma1, *ma2;\n\tint equal;\n\n\tstr = \"{ A[B[] -> C[]] -> D[E[] -> F[]] }\";\n\tma1 = isl_multi_aff_read_from_str(ctx, str);\n\n\tspace = isl_space_params_alloc(ctx, 1);\n\tspace = isl_space_set_dim_name(space, isl_dim_param, 0, \"N\");\n\tma1 = isl_multi_aff_align_params(ma1, space);\n\n\tstr = \"[N] -> { A[B[] -> C[]] -> D[E[] -> F[]] }\";\n\tma2 = isl_multi_aff_read_from_str(ctx, str);\n\n\tequal = isl_multi_aff_plain_is_equal(ma1, ma2);\n\n\tisl_multi_aff_free(ma1);\n\tisl_multi_aff_free(ma2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"result not as expected\", return -1);\n\n\treturn 0;\n}\n\n/* Check the isl_multi_*_from_*_list operation in case inputs\n * have unaligned parameters.\n * In particular, older versions of isl would simply fail\n * (without printing any error message).\n */\nstatic isl_stat test_align_parameters_2(isl_ctx *ctx)\n{\n\tisl_space *space;\n\tisl_map *map;\n\tisl_aff *aff;\n\tisl_multi_aff *ma;\n\n\tmap = isl_map_read_from_str(ctx, \"{ A[] -> M[x] }\");\n\tspace = isl_map_get_space(map);\n\tisl_map_free(map);\n\n\taff = isl_aff_read_from_str(ctx, \"[N] -> { A[] -> [N] }\");\n\tma = isl_multi_aff_from_aff_list(space, isl_aff_list_from_aff(aff));\n\tisl_multi_aff_free(ma);\n\n\tif (!ma)\n\t\treturn isl_stat_error;\n\treturn isl_stat_ok;\n}\n\n/* Perform basic parameter alignment tests.\n */\nstatic int test_align_parameters(isl_ctx *ctx)\n{\n\tif (test_align_parameters_1(ctx) < 0)\n\t\treturn -1;\n\tif (test_align_parameters_2(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that isl_*_drop_unused_params actually drops the unused parameters\n * by comparing the result using isl_*_plain_is_equal.\n * Note that this assumes that isl_*_plain_is_equal does not consider\n * objects that only differ by unused parameters to be equal.\n */\nint test_drop_unused_parameters(isl_ctx *ctx)\n{\n\tconst char *str_with, *str_without;\n\tisl_basic_set *bset1, *bset2;\n\tisl_set *set1, *set2;\n\tisl_pw_aff *pwa1, *pwa2;\n\tint equal;\n\n\tstr_with = \"[n, m, o] -> { [m] }\";\n\tstr_without = \"[m] -> { [m] }\";\n\n\tbset1 = isl_basic_set_read_from_str(ctx, str_with);\n\tbset2 = isl_basic_set_read_from_str(ctx, str_without);\n\tbset1 = isl_basic_set_drop_unused_params(bset1);\n\tequal = isl_basic_set_plain_is_equal(bset1, bset2);\n\tisl_basic_set_free(bset1);\n\tisl_basic_set_free(bset2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"result not as expected\", return -1);\n\n\tset1 = isl_set_read_from_str(ctx, str_with);\n\tset2 = isl_set_read_from_str(ctx, str_without);\n\tset1 = isl_set_drop_unused_params(set1);\n\tequal = isl_set_plain_is_equal(set1, set2);\n\tisl_set_free(set1);\n\tisl_set_free(set2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"result not as expected\", return -1);\n\n\tpwa1 = isl_pw_aff_read_from_str(ctx, str_with);\n\tpwa2 = isl_pw_aff_read_from_str(ctx, str_without);\n\tpwa1 = isl_pw_aff_drop_unused_params(pwa1);\n\tequal = isl_pw_aff_plain_is_equal(pwa1, pwa2);\n\tisl_pw_aff_free(pwa1);\n\tisl_pw_aff_free(pwa2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"result not as expected\", return -1);\n\n\treturn 0;\n}\n\nstatic int test_list(isl_ctx *ctx)\n{\n\tisl_id *a, *b, *c, *d, *id;\n\tisl_id_list *list;\n\tisl_size n;\n\tint ok;\n\n\ta = isl_id_alloc(ctx, \"a\", NULL);\n\tb = isl_id_alloc(ctx, \"b\", NULL);\n\tc = isl_id_alloc(ctx, \"c\", NULL);\n\td = isl_id_alloc(ctx, \"d\", NULL);\n\n\tlist = isl_id_list_alloc(ctx, 4);\n\tlist = isl_id_list_add(list, b);\n\tlist = isl_id_list_insert(list, 0, a);\n\tlist = isl_id_list_add(list, c);\n\tlist = isl_id_list_add(list, d);\n\tlist = isl_id_list_drop(list, 1, 1);\n\n\tn = isl_id_list_n_id(list);\n\tif (n < 0)\n\t\treturn -1;\n\tif (n != 3) {\n\t\tisl_id_list_free(list);\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected number of elements in list\", return -1);\n\t}\n\n\tid = isl_id_list_get_id(list, 0);\n\tok = id == a;\n\tisl_id_free(id);\n\tid = isl_id_list_get_id(list, 1);\n\tok = ok && id == c;\n\tisl_id_free(id);\n\tid = isl_id_list_get_id(list, 2);\n\tok = ok && id == d;\n\tisl_id_free(id);\n\n\tisl_id_list_free(list);\n\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected elements in list\", return -1);\n\n\treturn 0;\n}\n\n/* Check the conversion from an isl_multi_aff to an isl_basic_set.\n */\nstatic isl_stat test_ma_conversion(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_bool equal;\n\tisl_multi_aff *ma;\n\tisl_basic_set *bset1, *bset2;\n\n\tstr = \"[N] -> { A[0, N + 1] }\";\n\tma = isl_multi_aff_read_from_str(ctx, str);\n\tbset1 = isl_basic_set_read_from_str(ctx, str);\n\tbset2 = isl_basic_set_from_multi_aff(ma);\n\tequal = isl_basic_set_is_equal(bset1, bset2);\n\tisl_basic_set_free(bset1);\n\tisl_basic_set_free(bset2);\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"bad conversion\",\n\t\t\treturn isl_stat_error);\n\treturn isl_stat_ok;\n}\n\nconst char *set_conversion_tests[] = {\n\t\"[N] -> { [i] : N - 1 <= 2 i <= N }\",\n\t\"[N] -> { [i] : exists a : i = 4 a and N - 1 <= i <= N }\",\n\t\"[N] -> { [i,j] : exists a : i = 4 a and N - 1 <= i, 2j <= N }\",\n\t\"[N] -> { [[i]->[j]] : exists a : i = 4 a and N - 1 <= i, 2j <= N }\",\n\t\"[N] -> { [3*floor(N/2) + 5*floor(N/3)] }\",\n\t\"[a, b] -> { [c, d] : (4*floor((-a + c)/4) = -a + c and \"\n\t\t\t\"32*floor((-b + d)/32) = -b + d and 5 <= c <= 8 and \"\n\t\t\t\"-3 + c <= d <= 28 + c) }\",\n};\n\n/* Check that converting from isl_set to isl_pw_multi_aff and back\n * to isl_set produces the original isl_set.\n */\nstatic int test_set_conversion(isl_ctx *ctx)\n{\n\tint i;\n\tconst char *str;\n\tisl_set *set1, *set2;\n\tisl_pw_multi_aff *pma;\n\tint equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(set_conversion_tests); ++i) {\n\t\tstr = set_conversion_tests[i];\n\t\tset1 = isl_set_read_from_str(ctx, str);\n\t\tpma = isl_pw_multi_aff_from_set(isl_set_copy(set1));\n\t\tset2 = isl_set_from_pw_multi_aff(pma);\n\t\tequal = isl_set_is_equal(set1, set2);\n\t\tisl_set_free(set1);\n\t\tisl_set_free(set2);\n\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"bad conversion\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\nconst char *conversion_tests[] = {\n\t\"{ [a, b, c, d] -> s0[a, b, e, f] : \"\n\t    \"exists (e0 = [(a - 2c)/3], e1 = [(-4 + b - 5d)/9], \"\n\t    \"e2 = [(-d + f)/9]: 3e0 = a - 2c and 9e1 = -4 + b - 5d and \"\n\t    \"9e2 = -d + f and f >= 0 and f <= 8 and 9e >= -5 - 2a and \"\n\t    \"9e <= -2 - 2a) }\",\n\t\"{ [a, b] -> [c] : exists (e0 = floor((-a - b + c)/5): \"\n\t    \"5e0 = -a - b + c and c >= -a and c <= 4 - a) }\",\n\t\"{ [a, b] -> [c] : exists d : 18 * d = -3 - a + 2c and 1 <= c <= 3 }\",\n};\n\n/* Check that converting from isl_map to isl_pw_multi_aff and back\n * to isl_map produces the original isl_map.\n */\nstatic int test_map_conversion(isl_ctx *ctx)\n{\n\tint i;\n\tisl_map *map1, *map2;\n\tisl_pw_multi_aff *pma;\n\tint equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(conversion_tests); ++i) {\n\t\tmap1 = isl_map_read_from_str(ctx, conversion_tests[i]);\n\t\tpma = isl_pw_multi_aff_from_map(isl_map_copy(map1));\n\t\tmap2 = isl_map_from_pw_multi_aff(pma);\n\t\tequal = isl_map_is_equal(map1, map2);\n\t\tisl_map_free(map1);\n\t\tisl_map_free(map2);\n\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"bad conversion\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\n/* Descriptions of isl_pw_multi_aff objects for testing conversion\n * to isl_multi_pw_aff and back.\n */\nconst char *mpa_conversion_tests[] = {\n\t\"{ [x] -> A[x] }\",\n\t\"{ [x] -> A[x] : x >= 0 }\",\n\t\"{ [x] -> A[x] : x >= 0; [x] -> A[-x] : x < 0 }\",\n\t\"{ [x] -> A[x, x + 1] }\",\n\t\"{ [x] -> A[] }\",\n\t\"{ [x] -> A[] : x >= 0 }\",\n};\n\n/* Check that conversion from isl_pw_multi_aff to isl_multi_pw_aff and\n * back to isl_pw_multi_aff preserves the original meaning.\n */\nstatic int test_mpa_conversion(isl_ctx *ctx)\n{\n\tint i;\n\tisl_pw_multi_aff *pma1, *pma2;\n\tisl_multi_pw_aff *mpa;\n\tint equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(mpa_conversion_tests); ++i) {\n\t\tconst char *str;\n\t\tstr = mpa_conversion_tests[i];\n\t\tpma1 = isl_pw_multi_aff_read_from_str(ctx, str);\n\t\tpma2 = isl_pw_multi_aff_copy(pma1);\n\t\tmpa = isl_multi_pw_aff_from_pw_multi_aff(pma1);\n\t\tpma1 = isl_pw_multi_aff_from_multi_pw_aff(mpa);\n\t\tequal = isl_pw_multi_aff_plain_is_equal(pma1, pma2);\n\t\tisl_pw_multi_aff_free(pma1);\n\t\tisl_pw_multi_aff_free(pma2);\n\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"bad conversion\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\n/* Descriptions of union maps that should be convertible\n * to an isl_multi_union_pw_aff.\n */\nconst char *umap_mupa_conversion_tests[] = {\n\t\"{ [a, b, c, d] -> s0[a, b, e, f] : \"\n\t    \"exists (e0 = [(a - 2c)/3], e1 = [(-4 + b - 5d)/9], \"\n\t    \"e2 = [(-d + f)/9]: 3e0 = a - 2c and 9e1 = -4 + b - 5d and \"\n\t    \"9e2 = -d + f and f >= 0 and f <= 8 and 9e >= -5 - 2a and \"\n\t    \"9e <= -2 - 2a) }\",\n\t\"{ [a, b] -> [c] : exists (e0 = floor((-a - b + c)/5): \"\n\t    \"5e0 = -a - b + c and c >= -a and c <= 4 - a) }\",\n\t\"{ [a, b] -> [c] : exists d : 18 * d = -3 - a + 2c and 1 <= c <= 3 }\",\n\t\"{ A[] -> B[0]; C[] -> B[1] }\",\n\t\"{ A[] -> B[]; C[] -> B[] }\",\n};\n\n/* Check that converting from isl_union_map to isl_multi_union_pw_aff and back\n * to isl_union_map produces the original isl_union_map.\n */\nstatic int test_union_map_mupa_conversion(isl_ctx *ctx)\n{\n\tint i;\n\tisl_union_map *umap1, *umap2;\n\tisl_multi_union_pw_aff *mupa;\n\tint equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(umap_mupa_conversion_tests); ++i) {\n\t\tconst char *str;\n\t\tstr = umap_mupa_conversion_tests[i];\n\t\tumap1 = isl_union_map_read_from_str(ctx, str);\n\t\tumap2 = isl_union_map_copy(umap1);\n\t\tmupa = isl_multi_union_pw_aff_from_union_map(umap2);\n\t\tumap2 = isl_union_map_from_multi_union_pw_aff(mupa);\n\t\tequal = isl_union_map_is_equal(umap1, umap2);\n\t\tisl_union_map_free(umap1);\n\t\tisl_union_map_free(umap2);\n\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"bad conversion\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\nstatic int test_conversion(isl_ctx *ctx)\n{\n\tif (test_ma_conversion(ctx) < 0)\n\t\treturn -1;\n\tif (test_set_conversion(ctx) < 0)\n\t\treturn -1;\n\tif (test_map_conversion(ctx) < 0)\n\t\treturn -1;\n\tif (test_mpa_conversion(ctx) < 0)\n\t\treturn -1;\n\tif (test_union_map_mupa_conversion(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Check that isl_basic_map_curry does not modify input.\n */\nstatic int test_curry(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_map *bmap1, *bmap2;\n\tint equal;\n\n\tstr = \"{ [A[] -> B[]] -> C[] }\";\n\tbmap1 = isl_basic_map_read_from_str(ctx, str);\n\tbmap2 = isl_basic_map_curry(isl_basic_map_copy(bmap1));\n\tequal = isl_basic_map_is_equal(bmap1, bmap2);\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"curried map should not be equal to original\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\nstruct {\n\tconst char *set;\n\tconst char *ma;\n\tconst char *res;\n} preimage_tests[] = {\n\t{ \"{ B[i,j] : 0 <= i < 10 and 0 <= j < 100 }\",\n\t  \"{ A[j,i] -> B[i,j] }\",\n\t  \"{ A[j,i] : 0 <= i < 10 and 0 <= j < 100 }\" },\n\t{ \"{ rat: B[i,j] : 0 <= i, j and 3 i + 5 j <= 100 }\",\n\t  \"{ A[a,b] -> B[a/2,b/6] }\",\n\t  \"{ rat: A[a,b] : 0 <= a, b and 9 a + 5 b <= 600 }\" },\n\t{ \"{ B[i,j] : 0 <= i, j and 3 i + 5 j <= 100 }\",\n\t  \"{ A[a,b] -> B[a/2,b/6] }\",\n\t  \"{ A[a,b] : 0 <= a, b and 9 a + 5 b <= 600 and \"\n\t\t    \"exists i,j : a = 2 i and b = 6 j }\" },\n\t{ \"[n] -> { S[i] : 0 <= i <= 100 }\", \"[n] -> { S[n] }\",\n\t  \"[n] -> { : 0 <= n <= 100 }\" },\n\t{ \"{ B[i] : 0 <= i < 100 and exists a : i = 4 a }\",\n\t  \"{ A[a] -> B[2a] }\",\n\t  \"{ A[a] : 0 <= a < 50 and exists b : a = 2 b }\" },\n\t{ \"{ B[i] : 0 <= i < 100 and exists a : i = 4 a }\",\n\t  \"{ A[a] -> B[([a/2])] }\",\n\t  \"{ A[a] : 0 <= a < 200 and exists b : [a/2] = 4 b }\" },\n\t{ \"{ B[i,j,k] : 0 <= i,j,k <= 100 }\",\n\t  \"{ A[a] -> B[a,a,a/3] }\",\n\t  \"{ A[a] : 0 <= a <= 100 and exists b : a = 3 b }\" },\n\t{ \"{ B[i,j] : j = [(i)/2] } \", \"{ A[i,j] -> B[i/3,j] }\",\n\t  \"{ A[i,j] : j = [(i)/6] and exists a : i = 3 a }\" },\n};\n\nstatic int test_preimage_basic_set(isl_ctx *ctx)\n{\n\tint i;\n\tisl_basic_set *bset1, *bset2;\n\tisl_multi_aff *ma;\n\tint equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(preimage_tests); ++i) {\n\t\tbset1 = isl_basic_set_read_from_str(ctx, preimage_tests[i].set);\n\t\tma = isl_multi_aff_read_from_str(ctx, preimage_tests[i].ma);\n\t\tbset2 = isl_basic_set_read_from_str(ctx, preimage_tests[i].res);\n\t\tbset1 = isl_basic_set_preimage_multi_aff(bset1, ma);\n\t\tequal = isl_basic_set_is_equal(bset1, bset2);\n\t\tisl_basic_set_free(bset1);\n\t\tisl_basic_set_free(bset2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"bad preimage\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\tconst char *map;\n\tconst char *ma;\n\tconst char *res;\n} preimage_domain_tests[] = {\n\t{ \"{ B[i,j] -> C[2i + 3j] : 0 <= i < 10 and 0 <= j < 100 }\",\n\t  \"{ A[j,i] -> B[i,j] }\",\n\t  \"{ A[j,i] -> C[2i + 3j] : 0 <= i < 10 and 0 <= j < 100 }\" },\n\t{ \"{ B[i] -> C[i]; D[i] -> E[i] }\",\n\t  \"{ A[i] -> B[i + 1] }\",\n\t  \"{ A[i] -> C[i + 1] }\" },\n\t{ \"{ B[i] -> C[i]; B[i] -> E[i] }\",\n\t  \"{ A[i] -> B[i + 1] }\",\n\t  \"{ A[i] -> C[i + 1]; A[i] -> E[i + 1] }\" },\n\t{ \"{ B[i] -> C[([i/2])] }\",\n\t  \"{ A[i] -> B[2i] }\",\n\t  \"{ A[i] -> C[i] }\" },\n\t{ \"{ B[i,j] -> C[([i/2]), ([(i+j)/3])] }\",\n\t  \"{ A[i] -> B[([i/5]), ([i/7])] }\",\n\t  \"{ A[i] -> C[([([i/5])/2]), ([(([i/5])+([i/7]))/3])] }\" },\n\t{ \"[N] -> { B[i] -> C[([N/2]), i, ([N/3])] }\",\n\t  \"[N] -> { A[] -> B[([N/5])] }\",\n\t  \"[N] -> { A[] -> C[([N/2]), ([N/5]), ([N/3])] }\" },\n\t{ \"{ B[i] -> C[i] : exists a : i = 5 a }\",\n\t  \"{ A[i] -> B[2i] }\",\n\t  \"{ A[i] -> C[2i] : exists a : 2i = 5 a }\" },\n\t{ \"{ B[i] -> C[i] : exists a : i = 2 a; \"\n\t    \"B[i] -> D[i] : exists a : i = 2 a + 1 }\",\n\t  \"{ A[i] -> B[2i] }\",\n\t  \"{ A[i] -> C[2i] }\" },\n\t{ \"{ A[i] -> B[i] }\", \"{ C[i] -> A[(i + floor(i/3))/2] }\",\n\t  \"{ C[i] -> B[j] : 2j = i + floor(i/3) }\" },\n};\n\nstatic int test_preimage_union_map(isl_ctx *ctx)\n{\n\tint i;\n\tisl_union_map *umap1, *umap2;\n\tisl_multi_aff *ma;\n\tint equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(preimage_domain_tests); ++i) {\n\t\tumap1 = isl_union_map_read_from_str(ctx,\n\t\t\t\t\t\tpreimage_domain_tests[i].map);\n\t\tma = isl_multi_aff_read_from_str(ctx,\n\t\t\t\t\t\tpreimage_domain_tests[i].ma);\n\t\tumap2 = isl_union_map_read_from_str(ctx,\n\t\t\t\t\t\tpreimage_domain_tests[i].res);\n\t\tumap1 = isl_union_map_preimage_domain_multi_aff(umap1, ma);\n\t\tequal = isl_union_map_is_equal(umap1, umap2);\n\t\tisl_union_map_free(umap1);\n\t\tisl_union_map_free(umap2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"bad preimage\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\nstatic int test_preimage(isl_ctx *ctx)\n{\n\tif (test_preimage_basic_set(ctx) < 0)\n\t\treturn -1;\n\tif (test_preimage_union_map(ctx) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct {\n\tconst char *ma1;\n\tconst char *ma;\n\tconst char *res;\n} pullback_tests[] = {\n\t{ \"{ B[i,j] -> C[i + 2j] }\" , \"{ A[a,b] -> B[b,a] }\",\n\t  \"{ A[a,b] -> C[b + 2a] }\" },\n\t{ \"{ B[i] -> C[2i] }\", \"{ A[a] -> B[(a)/2] }\", \"{ A[a] -> C[a] }\" },\n\t{ \"{ B[i] -> C[(i)/2] }\", \"{ A[a] -> B[2a] }\", \"{ A[a] -> C[a] }\" },\n\t{ \"{ B[i] -> C[(i)/2] }\", \"{ A[a] -> B[(a)/3] }\",\n\t  \"{ A[a] -> C[(a)/6] }\" },\n\t{ \"{ B[i] -> C[2i] }\", \"{ A[a] -> B[5a] }\", \"{ A[a] -> C[10a] }\" },\n\t{ \"{ B[i] -> C[2i] }\", \"{ A[a] -> B[(a)/3] }\",\n\t  \"{ A[a] -> C[(2a)/3] }\" },\n\t{ \"{ B[i,j] -> C[i + j] }\", \"{ A[a] -> B[a,a] }\", \"{ A[a] -> C[2a] }\"},\n\t{ \"{ B[a] -> C[a,a] }\", \"{ A[i,j] -> B[i + j] }\",\n\t  \"{ A[i,j] -> C[i + j, i + j] }\"},\n\t{ \"{ B[i] -> C[([i/2])] }\", \"{ B[5] }\", \"{ C[2] }\" },\n\t{ \"[n] -> { B[i,j] -> C[([i/2]) + 2j] }\",\n\t  \"[n] -> { B[n,[n/3]] }\", \"[n] -> { C[([n/2]) + 2*[n/3]] }\", },\n\t{ \"{ [i, j] -> [floor((i)/4) + floor((2*i+j)/5)] }\",\n\t  \"{ [i, j] -> [floor((i)/3), j] }\",\n\t  \"{ [i, j] -> [(floor((i)/12) + floor((j + 2*floor((i)/3))/5))] }\" },\n};\n\nstatic int test_pullback(isl_ctx *ctx)\n{\n\tint i;\n\tisl_multi_aff *ma1, *ma2;\n\tisl_multi_aff *ma;\n\tint equal;\n\n\tfor (i = 0; i < ARRAY_SIZE(pullback_tests); ++i) {\n\t\tma1 = isl_multi_aff_read_from_str(ctx, pullback_tests[i].ma1);\n\t\tma = isl_multi_aff_read_from_str(ctx, pullback_tests[i].ma);\n\t\tma2 = isl_multi_aff_read_from_str(ctx, pullback_tests[i].res);\n\t\tma1 = isl_multi_aff_pullback_multi_aff(ma1, ma);\n\t\tequal = isl_multi_aff_plain_is_equal(ma1, ma2);\n\t\tisl_multi_aff_free(ma1);\n\t\tisl_multi_aff_free(ma2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown, \"bad pullback\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\n/* Check that negation is printed correctly and that equal expressions\n * are correctly identified.\n */\nstatic int test_ast(isl_ctx *ctx)\n{\n\tisl_ast_expr *expr, *expr1, *expr2, *expr3;\n\tchar *str;\n\tint ok, equal;\n\n\texpr1 = isl_ast_expr_from_id(isl_id_alloc(ctx, \"A\", NULL));\n\texpr2 = isl_ast_expr_from_id(isl_id_alloc(ctx, \"B\", NULL));\n\texpr = isl_ast_expr_add(expr1, expr2);\n\texpr2 = isl_ast_expr_copy(expr);\n\texpr = isl_ast_expr_neg(expr);\n\texpr2 = isl_ast_expr_neg(expr2);\n\tequal = isl_ast_expr_is_equal(expr, expr2);\n\tstr = isl_ast_expr_to_C_str(expr);\n\tok = str ? !strcmp(str, \"-(A + B)\") : -1;\n\tfree(str);\n\tisl_ast_expr_free(expr);\n\tisl_ast_expr_free(expr2);\n\n\tif (ok < 0 || equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"equal expressions not considered equal\", return -1);\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"isl_ast_expr printed incorrectly\", return -1);\n\n\texpr1 = isl_ast_expr_from_id(isl_id_alloc(ctx, \"A\", NULL));\n\texpr2 = isl_ast_expr_from_id(isl_id_alloc(ctx, \"B\", NULL));\n\texpr = isl_ast_expr_add(expr1, expr2);\n\texpr3 = isl_ast_expr_from_id(isl_id_alloc(ctx, \"C\", NULL));\n\texpr = isl_ast_expr_sub(expr3, expr);\n\tstr = isl_ast_expr_to_C_str(expr);\n\tok = str ? !strcmp(str, \"C - (A + B)\") : -1;\n\tfree(str);\n\tisl_ast_expr_free(expr);\n\n\tif (ok < 0)\n\t\treturn -1;\n\tif (!ok)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"isl_ast_expr printed incorrectly\", return -1);\n\n\treturn 0;\n}\n\n/* Check that isl_ast_build_expr_from_set returns a valid expression\n * for an empty set.  Note that isl_ast_build_expr_from_set getting\n * called on an empty set probably indicates a bug in the caller.\n */\nstatic int test_ast_build(isl_ctx *ctx)\n{\n\tisl_set *set;\n\tisl_ast_build *build;\n\tisl_ast_expr *expr;\n\n\tset = isl_set_universe(isl_space_params_alloc(ctx, 0));\n\tbuild = isl_ast_build_from_context(set);\n\n\tset = isl_set_empty(isl_space_params_alloc(ctx, 0));\n\texpr = isl_ast_build_expr_from_set(build, set);\n\n\tisl_ast_expr_free(expr);\n\tisl_ast_build_free(build);\n\n\tif (!expr)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Internal data structure for before_for and after_for callbacks.\n *\n * depth is the current depth\n * before is the number of times before_for has been called\n * after is the number of times after_for has been called\n */\nstruct isl_test_codegen_data {\n\tint depth;\n\tint before;\n\tint after;\n};\n\n/* This function is called before each for loop in the AST generated\n * from test_ast_gen1.\n *\n * Increment the number of calls and the depth.\n * Check that the space returned by isl_ast_build_get_schedule_space\n * matches the target space of the schedule returned by\n * isl_ast_build_get_schedule.\n * Return an isl_id that is checked by the corresponding call\n * to after_for.\n */\nstatic __isl_give isl_id *before_for(__isl_keep isl_ast_build *build,\n\tvoid *user)\n{\n\tstruct isl_test_codegen_data *data = user;\n\tisl_ctx *ctx;\n\tisl_space *space;\n\tisl_union_map *schedule;\n\tisl_union_set *uset;\n\tisl_set *set;\n\tisl_bool empty;\n\tisl_size n;\n\tchar name[] = \"d0\";\n\n\tctx = isl_ast_build_get_ctx(build);\n\n\tif (data->before >= 3)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected number of for nodes\", return NULL);\n\tif (data->depth < 0 || data->depth >= 2)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected depth\", return NULL);\n\n\tsnprintf(name, sizeof(name), \"d%d\", data->depth);\n\tdata->before++;\n\tdata->depth++;\n\n\tschedule = isl_ast_build_get_schedule(build);\n\tuset = isl_union_map_range(schedule);\n\tn = isl_union_set_n_set(uset);\n\tif (n != 1) {\n\t\tisl_union_set_free(uset);\n\t\tif (n < 0)\n\t\t\treturn NULL;\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"expecting single range space\", return NULL);\n\t}\n\n\tspace = isl_ast_build_get_schedule_space(build);\n\tset = isl_union_set_extract_set(uset, space);\n\tisl_union_set_free(uset);\n\tempty = isl_set_is_empty(set);\n\tisl_set_free(set);\n\n\tif (empty < 0)\n\t\treturn NULL;\n\tif (empty)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"spaces don't match\", return NULL);\n\n\treturn isl_id_alloc(ctx, name, NULL);\n}\n\n/* This function is called after each for loop in the AST generated\n * from test_ast_gen1.\n *\n * Increment the number of calls and decrement the depth.\n * Check that the annotation attached to the node matches\n * the isl_id returned by the corresponding call to before_for.\n */\nstatic __isl_give isl_ast_node *after_for(__isl_take isl_ast_node *node,\n\t__isl_keep isl_ast_build *build, void *user)\n{\n\tstruct isl_test_codegen_data *data = user;\n\tisl_id *id;\n\tconst char *name;\n\tint valid;\n\n\tdata->after++;\n\tdata->depth--;\n\n\tif (data->after > data->before)\n\t\tisl_die(isl_ast_node_get_ctx(node), isl_error_unknown,\n\t\t\t\"mismatch in number of for nodes\",\n\t\t\treturn isl_ast_node_free(node));\n\n\tid = isl_ast_node_get_annotation(node);\n\tif (!id)\n\t\tisl_die(isl_ast_node_get_ctx(node), isl_error_unknown,\n\t\t\t\"missing annotation\", return isl_ast_node_free(node));\n\n\tname = isl_id_get_name(id);\n\tvalid = name && atoi(name + 1) == data->depth;\n\tisl_id_free(id);\n\n\tif (!valid)\n\t\tisl_die(isl_ast_node_get_ctx(node), isl_error_unknown,\n\t\t\t\"wrong annotation\", return isl_ast_node_free(node));\n\n\treturn node;\n}\n\n/* Check that the before_each_for and after_each_for callbacks\n * are called for each for loop in the generated code,\n * that they are called in the right order and that the isl_id\n * returned from the before_each_for callback is attached to\n * the isl_ast_node passed to the corresponding after_each_for call.\n */\nstatic int test_ast_gen1(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_union_map *schedule;\n\tisl_ast_build *build;\n\tisl_ast_node *tree;\n\tstruct isl_test_codegen_data data;\n\n\tstr = \"[N] -> { : N >= 10 }\";\n\tset = isl_set_read_from_str(ctx, str);\n\tstr = \"[N] -> { A[i,j] -> S[8,i,3,j] : 0 <= i,j <= N; \"\n\t\t    \"B[i,j] -> S[8,j,9,i] : 0 <= i,j <= N }\";\n\tschedule = isl_union_map_read_from_str(ctx, str);\n\n\tdata.before = 0;\n\tdata.after = 0;\n\tdata.depth = 0;\n\tbuild = isl_ast_build_from_context(set);\n\tbuild = isl_ast_build_set_before_each_for(build,\n\t\t\t&before_for, &data);\n\tbuild = isl_ast_build_set_after_each_for(build,\n\t\t\t&after_for, &data);\n\ttree = isl_ast_build_node_from_schedule_map(build, schedule);\n\tisl_ast_build_free(build);\n\tif (!tree)\n\t\treturn -1;\n\n\tisl_ast_node_free(tree);\n\n\tif (data.before != 3 || data.after != 3)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected number of for nodes\", return -1);\n\n\treturn 0;\n}\n\n/* Check that the AST generator handles domains that are integrally disjoint\n * but not rationally disjoint.\n */\nstatic int test_ast_gen2(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_union_map *schedule;\n\tisl_union_map *options;\n\tisl_ast_build *build;\n\tisl_ast_node *tree;\n\n\tstr = \"{ A[i,j] -> [i,j] : 0 <= i,j <= 1 }\";\n\tschedule = isl_union_map_read_from_str(ctx, str);\n\tset = isl_set_universe(isl_space_params_alloc(ctx, 0));\n\tbuild = isl_ast_build_from_context(set);\n\n\tstr = \"{ [i,j] -> atomic[1] : i + j = 1; [i,j] -> unroll[1] : i = j }\";\n\toptions = isl_union_map_read_from_str(ctx, str);\n\tbuild = isl_ast_build_set_options(build, options);\n\ttree = isl_ast_build_node_from_schedule_map(build, schedule);\n\tisl_ast_build_free(build);\n\tif (!tree)\n\t\treturn -1;\n\tisl_ast_node_free(tree);\n\n\treturn 0;\n}\n\n/* Increment *user on each call.\n */\nstatic __isl_give isl_ast_node *count_domains(__isl_take isl_ast_node *node,\n\t__isl_keep isl_ast_build *build, void *user)\n{\n\tint *n = user;\n\n\t(*n)++;\n\n\treturn node;\n}\n\n/* Test that unrolling tries to minimize the number of instances.\n * In particular, for the schedule given below, make sure it generates\n * 3 nodes (rather than 101).\n */\nstatic int test_ast_gen3(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_union_map *schedule;\n\tisl_union_map *options;\n\tisl_ast_build *build;\n\tisl_ast_node *tree;\n\tint n_domain = 0;\n\n\tstr = \"[n] -> { A[i] -> [i] : 0 <= i <= 100 and n <= i <= n + 2 }\";\n\tschedule = isl_union_map_read_from_str(ctx, str);\n\tset = isl_set_universe(isl_space_params_alloc(ctx, 0));\n\n\tstr = \"{ [i] -> unroll[0] }\";\n\toptions = isl_union_map_read_from_str(ctx, str);\n\n\tbuild = isl_ast_build_from_context(set);\n\tbuild = isl_ast_build_set_options(build, options);\n\tbuild = isl_ast_build_set_at_each_domain(build,\n\t\t\t&count_domains, &n_domain);\n\ttree = isl_ast_build_node_from_schedule_map(build, schedule);\n\tisl_ast_build_free(build);\n\tif (!tree)\n\t\treturn -1;\n\n\tisl_ast_node_free(tree);\n\n\tif (n_domain != 3)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected number of for nodes\", return -1);\n\n\treturn 0;\n}\n\n/* Check that if the ast_build_exploit_nested_bounds options is set,\n * we do not get an outer if node in the generated AST,\n * while we do get such an outer if node if the options is not set.\n */\nstatic int test_ast_gen4(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_union_map *schedule;\n\tisl_ast_build *build;\n\tisl_ast_node *tree;\n\tenum isl_ast_node_type type;\n\tint enb;\n\n\tenb = isl_options_get_ast_build_exploit_nested_bounds(ctx);\n\tstr = \"[N,M] -> { A[i,j] -> [i,j] : 0 <= i <= N and 0 <= j <= M }\";\n\n\tisl_options_set_ast_build_exploit_nested_bounds(ctx, 1);\n\n\tschedule = isl_union_map_read_from_str(ctx, str);\n\tset = isl_set_universe(isl_space_params_alloc(ctx, 0));\n\tbuild = isl_ast_build_from_context(set);\n\ttree = isl_ast_build_node_from_schedule_map(build, schedule);\n\tisl_ast_build_free(build);\n\tif (!tree)\n\t\treturn -1;\n\n\ttype = isl_ast_node_get_type(tree);\n\tisl_ast_node_free(tree);\n\n\tif (type == isl_ast_node_if)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"not expecting if node\", return -1);\n\n\tisl_options_set_ast_build_exploit_nested_bounds(ctx, 0);\n\n\tschedule = isl_union_map_read_from_str(ctx, str);\n\tset = isl_set_universe(isl_space_params_alloc(ctx, 0));\n\tbuild = isl_ast_build_from_context(set);\n\ttree = isl_ast_build_node_from_schedule_map(build, schedule);\n\tisl_ast_build_free(build);\n\tif (!tree)\n\t\treturn -1;\n\n\ttype = isl_ast_node_get_type(tree);\n\tisl_ast_node_free(tree);\n\n\tif (type != isl_ast_node_if)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"expecting if node\", return -1);\n\n\tisl_options_set_ast_build_exploit_nested_bounds(ctx, enb);\n\n\treturn 0;\n}\n\n/* This function is called for each leaf in the AST generated\n * from test_ast_gen5.\n *\n * We finalize the AST generation by extending the outer schedule\n * with a zero-dimensional schedule.  If this results in any for loops,\n * then this means that we did not pass along enough information\n * about the outer schedule to the inner AST generation.\n */\nstatic __isl_give isl_ast_node *create_leaf(__isl_take isl_ast_build *build,\n\tvoid *user)\n{\n\tisl_union_map *schedule, *extra;\n\tisl_ast_node *tree;\n\n\tschedule = isl_ast_build_get_schedule(build);\n\textra = isl_union_map_copy(schedule);\n\textra = isl_union_map_from_domain(isl_union_map_domain(extra));\n\tschedule = isl_union_map_range_product(schedule, extra);\n\ttree = isl_ast_build_node_from_schedule_map(build, schedule);\n\tisl_ast_build_free(build);\n\n\tif (!tree)\n\t\treturn NULL;\n\n\tif (isl_ast_node_get_type(tree) == isl_ast_node_for)\n\t\tisl_die(isl_ast_node_get_ctx(tree), isl_error_unknown,\n\t\t\t\"code should not contain any for loop\",\n\t\t\treturn isl_ast_node_free(tree));\n\n\treturn tree;\n}\n\n/* Check that we do not lose any information when going back and\n * forth between internal and external schedule.\n *\n * In particular, we create an AST where we unroll the only\n * non-constant dimension in the schedule.  We therefore do\n * not expect any for loops in the AST.  However, older versions\n * of isl would not pass along enough information about the outer\n * schedule when performing an inner code generation from a create_leaf\n * callback, resulting in the inner code generation producing a for loop.\n */\nstatic int test_ast_gen5(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *set;\n\tisl_union_map *schedule, *options;\n\tisl_ast_build *build;\n\tisl_ast_node *tree;\n\n\tstr = \"{ A[] -> [1, 1, 2]; B[i] -> [1, i, 0] : i >= 1 and i <= 2 }\";\n\tschedule = isl_union_map_read_from_str(ctx, str);\n\n\tstr = \"{ [a, b, c] -> unroll[1] : exists (e0 = [(a)/4]: \"\n\t\t\t\t\"4e0 >= -1 + a - b and 4e0 <= -2 + a + b) }\";\n\toptions = isl_union_map_read_from_str(ctx, str);\n\n\tset = isl_set_universe(isl_space_params_alloc(ctx, 0));\n\tbuild = isl_ast_build_from_context(set);\n\tbuild = isl_ast_build_set_options(build, options);\n        build = isl_ast_build_set_create_leaf(build, &create_leaf, NULL);\n\ttree = isl_ast_build_node_from_schedule_map(build, schedule);\n\tisl_ast_build_free(build);\n\tisl_ast_node_free(tree);\n\tif (!tree)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that the expression\n *\n *\t[n] -> { [n/2] : n <= 0 and n % 2 = 0; [0] : n > 0 }\n *\n * is not combined into\n *\n *\tmin(n/2, 0)\n *\n * as this would result in n/2 being evaluated in parts of\n * the definition domain where n is not a multiple of 2.\n */\nstatic int test_ast_expr(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_pw_aff *pa;\n\tisl_ast_build *build;\n\tisl_ast_expr *expr;\n\tint min_max;\n\tint is_min;\n\n\tmin_max = isl_options_get_ast_build_detect_min_max(ctx);\n\tisl_options_set_ast_build_detect_min_max(ctx, 1);\n\n\tstr = \"[n] -> { [n/2] : n <= 0 and n % 2 = 0; [0] : n > 0 }\";\n\tpa = isl_pw_aff_read_from_str(ctx, str);\n\tbuild = isl_ast_build_alloc(ctx);\n\texpr = isl_ast_build_expr_from_pw_aff(build, pa);\n\tis_min = isl_ast_expr_get_type(expr) == isl_ast_expr_op &&\n\t\t isl_ast_expr_get_op_type(expr) == isl_ast_expr_op_min;\n\tisl_ast_build_free(build);\n\tisl_ast_expr_free(expr);\n\n\tisl_options_set_ast_build_detect_min_max(ctx, min_max);\n\n\tif (!expr)\n\t\treturn -1;\n\tif (is_min)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"expressions should not be combined\", return -1);\n\n\treturn 0;\n}\n\nstatic int test_ast_gen(isl_ctx *ctx)\n{\n\tif (test_ast_gen1(ctx) < 0)\n\t\treturn -1;\n\tif (test_ast_gen2(ctx) < 0)\n\t\treturn -1;\n\tif (test_ast_gen3(ctx) < 0)\n\t\treturn -1;\n\tif (test_ast_gen4(ctx) < 0)\n\t\treturn -1;\n\tif (test_ast_gen5(ctx) < 0)\n\t\treturn -1;\n\tif (test_ast_expr(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* Check if dropping output dimensions from an isl_pw_multi_aff\n * works properly.\n */\nstatic int test_pw_multi_aff(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_pw_multi_aff *pma1, *pma2;\n\tint equal;\n\n\tstr = \"{ [i,j] -> [i+j, 4i-j] }\";\n\tpma1 = isl_pw_multi_aff_read_from_str(ctx, str);\n\tstr = \"{ [i,j] -> [4i-j] }\";\n\tpma2 = isl_pw_multi_aff_read_from_str(ctx, str);\n\n\tpma1 = isl_pw_multi_aff_drop_dims(pma1, isl_dim_out, 0, 1);\n\n\tequal = isl_pw_multi_aff_plain_is_equal(pma1, pma2);\n\n\tisl_pw_multi_aff_free(pma1);\n\tisl_pw_multi_aff_free(pma2);\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"expressions not equal\", return -1);\n\n\treturn 0;\n}\n\n/* Check that we can properly parse multi piecewise affine expressions\n * where the piecewise affine expressions have different domains.\n */\nstatic int test_multi_pw_aff_1(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_set *dom, *dom2;\n\tisl_multi_pw_aff *mpa1, *mpa2;\n\tisl_pw_aff *pa;\n\tint equal;\n\tint equal_domain;\n\n\tmpa1 = isl_multi_pw_aff_read_from_str(ctx, \"{ [i] -> [i] }\");\n\tdom = isl_set_read_from_str(ctx, \"{ [i] : i > 0 }\");\n\tmpa1 = isl_multi_pw_aff_intersect_domain(mpa1, dom);\n\tmpa2 = isl_multi_pw_aff_read_from_str(ctx, \"{ [i] -> [2i] }\");\n\tmpa2 = isl_multi_pw_aff_flat_range_product(mpa1, mpa2);\n\tstr = \"{ [i] -> [(i : i > 0), 2i] }\";\n\tmpa1 = isl_multi_pw_aff_read_from_str(ctx, str);\n\n\tequal = isl_multi_pw_aff_plain_is_equal(mpa1, mpa2);\n\n\tpa = isl_multi_pw_aff_get_pw_aff(mpa1, 0);\n\tdom = isl_pw_aff_domain(pa);\n\tpa = isl_multi_pw_aff_get_pw_aff(mpa1, 1);\n\tdom2 = isl_pw_aff_domain(pa);\n\tequal_domain = isl_set_is_equal(dom, dom2);\n\n\tisl_set_free(dom);\n\tisl_set_free(dom2);\n\tisl_multi_pw_aff_free(mpa1);\n\tisl_multi_pw_aff_free(mpa2);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"expressions not equal\", return -1);\n\n\tif (equal_domain < 0)\n\t\treturn -1;\n\tif (equal_domain)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"domains unexpectedly equal\", return -1);\n\n\treturn 0;\n}\n\n/* Check that the dimensions in the explicit domain\n * of a multi piecewise affine expression are properly\n * taken into account.\n */\nstatic int test_multi_pw_aff_2(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_bool involves1, involves2, involves3, equal;\n\tisl_multi_pw_aff *mpa, *mpa1, *mpa2;\n\n\tstr = \"{ A[x,y] -> B[] : x >= y }\";\n\tmpa = isl_multi_pw_aff_read_from_str(ctx, str);\n\tinvolves1 = isl_multi_pw_aff_involves_dims(mpa, isl_dim_in, 0, 2);\n\tmpa1 = isl_multi_pw_aff_copy(mpa);\n\n\tmpa = isl_multi_pw_aff_insert_dims(mpa, isl_dim_in, 0, 1);\n\tinvolves2 = isl_multi_pw_aff_involves_dims(mpa, isl_dim_in, 0, 1);\n\tinvolves3 = isl_multi_pw_aff_involves_dims(mpa, isl_dim_in, 1, 2);\n\tstr = \"{ [a,x,y] -> B[] : x >= y }\";\n\tmpa2 = isl_multi_pw_aff_read_from_str(ctx, str);\n\tequal = isl_multi_pw_aff_plain_is_equal(mpa, mpa2);\n\tisl_multi_pw_aff_free(mpa2);\n\n\tmpa = isl_multi_pw_aff_drop_dims(mpa, isl_dim_in, 0, 1);\n\tmpa = isl_multi_pw_aff_set_tuple_name(mpa, isl_dim_in, \"A\");\n\tif (equal >= 0 && equal)\n\t\tequal = isl_multi_pw_aff_plain_is_equal(mpa, mpa1);\n\tisl_multi_pw_aff_free(mpa1);\n\tisl_multi_pw_aff_free(mpa);\n\n\tif (involves1 < 0 || involves2 < 0 || involves3 < 0 || equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"incorrect result of dimension insertion/removal\",\n\t\t\treturn isl_stat_error);\n\tif (!involves1 || involves2 || !involves3)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"incorrect characterization of involved dimensions\",\n\t\t\treturn isl_stat_error);\n\n\treturn 0;\n}\n\n/* Check that isl_multi_union_pw_aff_multi_val_on_domain\n * sets the explicit domain of a zero-dimensional result,\n * such that it can be converted to an isl_union_map.\n */\nstatic isl_stat test_multi_pw_aff_3(isl_ctx *ctx)\n{\n\tisl_space *space;\n\tisl_union_set *dom;\n\tisl_multi_val *mv;\n\tisl_multi_union_pw_aff *mupa;\n\tisl_union_map *umap;\n\n\tdom = isl_union_set_read_from_str(ctx, \"{ A[]; B[] }\");\n\tspace = isl_union_set_get_space(dom);\n\tmv = isl_multi_val_zero(isl_space_set_from_params(space));\n\tmupa = isl_multi_union_pw_aff_multi_val_on_domain(dom, mv);\n\tumap = isl_union_map_from_multi_union_pw_aff(mupa);\n\tisl_union_map_free(umap);\n\tif (!umap)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* String descriptions of boxes that\n * are used for reconstructing box maps from their lower and upper bounds.\n */\nstatic const char *multi_pw_aff_box_tests[] = {\n\t\"{ A[x, y] -> [] : x + y >= 0 }\",\n\t\"[N] -> { A[x, y] -> [x] : x + y <= N }\",\n\t\"[N] -> { A[x, y] -> [x : y] : x + y <= N }\",\n};\n\n/* Check that map representations of boxes can be reconstructed\n * from their lower and upper bounds.\n */\nstatic isl_stat test_multi_pw_aff_box(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(multi_pw_aff_box_tests); ++i) {\n\t\tconst char *str;\n\t\tisl_bool equal;\n\t\tisl_map *map, *box;\n\t\tisl_multi_pw_aff *min, *max;\n\n\t\tstr = multi_pw_aff_box_tests[i];\n\t\tmap = isl_map_read_from_str(ctx, str);\n\t\tmin = isl_map_min_multi_pw_aff(isl_map_copy(map));\n\t\tmax = isl_map_max_multi_pw_aff(isl_map_copy(map));\n\t\tbox = isl_map_universe(isl_map_get_space(map));\n\t\tbox = isl_map_lower_bound_multi_pw_aff(box, min);\n\t\tbox = isl_map_upper_bound_multi_pw_aff(box, max);\n\t\tequal = isl_map_is_equal(map, box);\n\t\tisl_map_free(map);\n\t\tisl_map_free(box);\n\t\tif (equal < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return isl_stat_error);\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Perform some tests on multi piecewise affine expressions.\n */\nstatic int test_multi_pw_aff(isl_ctx *ctx)\n{\n\tif (test_multi_pw_aff_1(ctx) < 0)\n\t\treturn -1;\n\tif (test_multi_pw_aff_2(ctx) < 0)\n\t\treturn -1;\n\tif (test_multi_pw_aff_3(ctx) < 0)\n\t\treturn -1;\n\tif (test_multi_pw_aff_box(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* This is a regression test for a bug where isl_basic_map_simplify\n * would end up in an infinite loop.  In particular, we construct\n * an empty basic set that is not obviously empty.\n * isl_basic_set_is_empty marks the basic set as empty.\n * After projecting out i3, the variable can be dropped completely,\n * but isl_basic_map_simplify refrains from doing so if the basic set\n * is empty and would end up in an infinite loop if it didn't test\n * explicitly for empty basic maps in the outer loop.\n */\nstatic int test_simplify_1(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset;\n\tint empty;\n\n\tstr = \"{ [i0, i1, i2, i3] : i0 >= -2 and 6i2 <= 4 + i0 + 5i1 and \"\n\t\t\"i2 <= 22 and 75i2 <= 111 + 13i0 + 60i1 and \"\n\t\t\"25i2 >= 38 + 6i0 + 20i1 and i0 <= -1 and i2 >= 20 and \"\n\t\t\"i3 >= i2 }\";\n\tbset = isl_basic_set_read_from_str(ctx, str);\n\tempty = isl_basic_set_is_empty(bset);\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 3, 1);\n\tisl_basic_set_free(bset);\n\tif (!bset)\n\t\treturn -1;\n\tif (!empty)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"basic set should be empty\", return -1);\n\n\treturn 0;\n}\n\n/* Check that the equality in the set description below\n * is simplified away.\n */\nstatic int test_simplify_2(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset;\n\tisl_bool universe;\n\n\tstr = \"{ [a] : exists e0, e1: 32e1 = 31 + 31a + 31e0 }\";\n\tbset = isl_basic_set_read_from_str(ctx, str);\n\tuniverse = isl_basic_set_plain_is_universe(bset);\n\tisl_basic_set_free(bset);\n\n\tif (universe < 0)\n\t\treturn -1;\n\tif (!universe)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"equality not simplified away\", return -1);\n\treturn 0;\n}\n\n/* Some simplification tests.\n */\nstatic int test_simplify(isl_ctx *ctx)\n{\n\tif (test_simplify_1(ctx) < 0)\n\t\treturn -1;\n\tif (test_simplify_2(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n/* This is a regression test for a bug where isl_tab_basic_map_partial_lexopt\n * with gbr context would fail to disable the use of the shifted tableau\n * when transferring equalities for the input to the context, resulting\n * in invalid sample values.\n */\nstatic int test_partial_lexmin(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset;\n\tisl_basic_map *bmap;\n\tisl_map *map;\n\n\tstr = \"{ [1, b, c, 1 - c] -> [e] : 2e <= -c and 2e >= -3 + c }\";\n\tbmap = isl_basic_map_read_from_str(ctx, str);\n\tstr = \"{ [a, b, c, d] : c <= 1 and 2d >= 6 - 4b - c }\";\n\tbset = isl_basic_set_read_from_str(ctx, str);\n\tmap = isl_basic_map_partial_lexmin(bmap, bset, NULL);\n\tisl_map_free(map);\n\n\tif (!map)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that the variable compression performed on the existentially\n * quantified variables inside isl_basic_set_compute_divs is not confused\n * by the implicit equalities among the parameters.\n */\nstatic int test_compute_divs(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_basic_set *bset;\n\tisl_set *set;\n\n\tstr = \"[a, b, c, d, e] -> { [] : exists (e0: 2d = b and a <= 124 and \"\n\t\t\"b <= 2046 and b >= 0 and b <= 60 + 64a and 2e >= b + 2c and \"\n\t\t\"2e >= b and 2e <= 1 + b and 2e <= 1 + b + 2c and \"\n\t\t\"32768e0 >= -124 + a and 2097152e0 <= 60 + 64a - b) }\";\n\tbset = isl_basic_set_read_from_str(ctx, str);\n\tset = isl_basic_set_compute_divs(bset);\n\tisl_set_free(set);\n\tif (!set)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that isl_schedule_get_map is not confused by a schedule tree\n * with divergent filter node parameters, as can result from a call\n * to isl_schedule_intersect_domain.\n */\nstatic int test_schedule_tree(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_union_set *uset;\n\tisl_schedule *sched1, *sched2;\n\tisl_union_map *umap;\n\n\tuset = isl_union_set_read_from_str(ctx, \"{ A[i] }\");\n\tsched1 = isl_schedule_from_domain(uset);\n\tuset = isl_union_set_read_from_str(ctx, \"{ B[] }\");\n\tsched2 = isl_schedule_from_domain(uset);\n\n\tsched1 = isl_schedule_sequence(sched1, sched2);\n\tstr = \"[n] -> { A[i] : 0 <= i < n; B[] }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tsched1 = isl_schedule_intersect_domain(sched1, uset);\n\tumap = isl_schedule_get_map(sched1);\n\tisl_schedule_free(sched1);\n\tisl_union_map_free(umap);\n\tif (!umap)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Check that a zero-dimensional prefix schedule keeps track\n * of the domain and outer filters.\n */\nstatic int test_schedule_tree_prefix(isl_ctx *ctx)\n{\n\tconst char *str;\n\tisl_bool equal;\n\tisl_union_set *uset;\n\tisl_union_set_list *filters;\n\tisl_multi_union_pw_aff *mupa, *mupa2;\n\tisl_schedule_node *node;\n\n\tstr = \"{ S1[i,j] : 0 <= i,j < 10; S2[i,j] : 0 <= i,j < 10 }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tnode = isl_schedule_node_from_domain(uset);\n\tnode = isl_schedule_node_child(node, 0);\n\n\tstr = \"{ S1[i,j] : i > j }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tfilters = isl_union_set_list_from_union_set(uset);\n\tstr = \"{ S1[i,j] : i <= j; S2[i,j] }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tfilters = isl_union_set_list_add(filters, uset);\n\tnode = isl_schedule_node_insert_sequence(node, filters);\n\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = isl_schedule_node_child(node, 0);\n\tmupa = isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(node);\n\tstr = \"([] : { S1[i,j] : i > j })\";\n\tmupa2 = isl_multi_union_pw_aff_read_from_str(ctx, str);\n\tequal = isl_multi_union_pw_aff_plain_is_equal(mupa, mupa2);\n\tisl_multi_union_pw_aff_free(mupa2);\n\tisl_multi_union_pw_aff_free(mupa);\n\tisl_schedule_node_free(node);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown, \"unexpected prefix schedule\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\n/* Check that the reaching domain elements and the prefix schedule\n * at a leaf node are the same before and after grouping.\n */\nstatic int test_schedule_tree_group_1(isl_ctx *ctx)\n{\n\tint equal;\n\tconst char *str;\n\tisl_id *id;\n\tisl_union_set *uset;\n\tisl_multi_union_pw_aff *mupa;\n\tisl_union_pw_multi_aff *upma1, *upma2;\n\tisl_union_set *domain1, *domain2;\n\tisl_union_map *umap1, *umap2;\n\tisl_schedule_node *node;\n\n\tstr = \"{ S1[i,j] : 0 <= i,j < 10; S2[i,j] : 0 <= i,j < 10 }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tnode = isl_schedule_node_from_domain(uset);\n\tnode = isl_schedule_node_child(node, 0);\n\tstr = \"[{ S1[i,j] -> [i]; S2[i,j] -> [9 - i] }]\";\n\tmupa = isl_multi_union_pw_aff_read_from_str(ctx, str);\n\tnode = isl_schedule_node_insert_partial_schedule(node, mupa);\n\tnode = isl_schedule_node_child(node, 0);\n\tstr = \"[{ S1[i,j] -> [j]; S2[i,j] -> [j] }]\";\n\tmupa = isl_multi_union_pw_aff_read_from_str(ctx, str);\n\tnode = isl_schedule_node_insert_partial_schedule(node, mupa);\n\tnode = isl_schedule_node_child(node, 0);\n\tumap1 = isl_schedule_node_get_prefix_schedule_union_map(node);\n\tupma1 = isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(node);\n\tdomain1 = isl_schedule_node_get_domain(node);\n\tid = isl_id_alloc(ctx, \"group\", NULL);\n\tnode = isl_schedule_node_parent(node);\n\tnode = isl_schedule_node_group(node, id);\n\tnode = isl_schedule_node_child(node, 0);\n\tumap2 = isl_schedule_node_get_prefix_schedule_union_map(node);\n\tupma2 = isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(node);\n\tdomain2 = isl_schedule_node_get_domain(node);\n\tequal = isl_union_pw_multi_aff_plain_is_equal(upma1, upma2);\n\tif (equal >= 0 && equal)\n\t\tequal = isl_union_set_is_equal(domain1, domain2);\n\tif (equal >= 0 && equal)\n\t\tequal = isl_union_map_is_equal(umap1, umap2);\n\tisl_union_map_free(umap1);\n\tisl_union_map_free(umap2);\n\tisl_union_set_free(domain1);\n\tisl_union_set_free(domain2);\n\tisl_union_pw_multi_aff_free(upma1);\n\tisl_union_pw_multi_aff_free(upma2);\n\tisl_schedule_node_free(node);\n\n\tif (equal < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"expressions not equal\", return -1);\n\n\treturn 0;\n}\n\n/* Check that we can have nested groupings and that the union map\n * schedule representation is the same before and after the grouping.\n * Note that after the grouping, the union map representation contains\n * the domain constraints from the ranges of the expansion nodes,\n * while they are missing from the union map representation of\n * the tree without expansion nodes.\n *\n * Also check that the global expansion is as expected.\n */\nstatic int test_schedule_tree_group_2(isl_ctx *ctx)\n{\n\tint equal, equal_expansion;\n\tconst char *str;\n\tisl_id *id;\n\tisl_union_set *uset;\n\tisl_union_map *umap1, *umap2;\n\tisl_union_map *expansion1, *expansion2;\n\tisl_union_set_list *filters;\n\tisl_multi_union_pw_aff *mupa;\n\tisl_schedule *schedule;\n\tisl_schedule_node *node;\n\n\tstr = \"{ S1[i,j] : 0 <= i,j < 10; S2[i,j] : 0 <= i,j < 10; \"\n\t\t\"S3[i,j] : 0 <= i,j < 10 }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tnode = isl_schedule_node_from_domain(uset);\n\tnode = isl_schedule_node_child(node, 0);\n\tstr = \"[{ S1[i,j] -> [i]; S2[i,j] -> [i]; S3[i,j] -> [i] }]\";\n\tmupa = isl_multi_union_pw_aff_read_from_str(ctx, str);\n\tnode = isl_schedule_node_insert_partial_schedule(node, mupa);\n\tnode = isl_schedule_node_child(node, 0);\n\tstr = \"{ S1[i,j] }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tfilters = isl_union_set_list_from_union_set(uset);\n\tstr = \"{ S2[i,j]; S3[i,j] }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tfilters = isl_union_set_list_add(filters, uset);\n\tnode = isl_schedule_node_insert_sequence(node, filters);\n\tnode = isl_schedule_node_child(node, 1);\n\tnode = isl_schedule_node_child(node, 0);\n\tstr = \"{ S2[i,j] }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tfilters = isl_union_set_list_from_union_set(uset);\n\tstr = \"{ S3[i,j] }\";\n\tuset = isl_union_set_read_from_str(ctx, str);\n\tfilters = isl_union_set_list_add(filters, uset);\n\tnode = isl_schedule_node_insert_sequence(node, filters);\n\n\tschedule = isl_schedule_node_get_schedule(node);\n\tumap1 = isl_schedule_get_map(schedule);\n\tuset = isl_schedule_get_domain(schedule);\n\tumap1 = isl_union_map_intersect_domain(umap1, uset);\n\tisl_schedule_free(schedule);\n\n\tnode = isl_schedule_node_parent(node);\n\tnode = isl_schedule_node_parent(node);\n\tid = isl_id_alloc(ctx, \"group1\", NULL);\n\tnode = isl_schedule_node_group(node, id);\n\tnode = isl_schedule_node_child(node, 1);\n\tnode = isl_schedule_node_child(node, 0);\n\tid = isl_id_alloc(ctx, \"group2\", NULL);\n\tnode = isl_schedule_node_group(node, id);\n\n\tschedule = isl_schedule_node_get_schedule(node);\n\tumap2 = isl_schedule_get_map(schedule);\n\tisl_schedule_free(schedule);\n\n\tnode = isl_schedule_node_root(node);\n\tnode = isl_schedule_node_child(node, 0);\n\texpansion1 = isl_schedule_node_get_subtree_expansion(node);\n\tisl_schedule_node_free(node);\n\n\tstr = \"{ group1[i] -> S1[i,j] : 0 <= i,j < 10; \"\n\t\t\"group1[i] -> S2[i,j] : 0 <= i,j < 10; \"\n\t\t\"group1[i] -> S3[i,j] : 0 <= i,j < 10 }\";\n\n\texpansion2 = isl_union_map_read_from_str(ctx, str);\n\n\tequal = isl_union_map_is_equal(umap1, umap2);\n\tequal_expansion = isl_union_map_is_equal(expansion1, expansion2);\n\n\tisl_union_map_free(umap1);\n\tisl_union_map_free(umap2);\n\tisl_union_map_free(expansion1);\n\tisl_union_map_free(expansion2);\n\n\tif (equal < 0 || equal_expansion < 0)\n\t\treturn -1;\n\tif (!equal)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"expressions not equal\", return -1);\n\tif (!equal_expansion)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"unexpected expansion\", return -1);\n\n\treturn 0;\n}\n\n/* Some tests for the isl_schedule_node_group function.\n */\nstatic int test_schedule_tree_group(isl_ctx *ctx)\n{\n\tif (test_schedule_tree_group_1(ctx) < 0)\n\t\treturn -1;\n\tif (test_schedule_tree_group_2(ctx) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstruct {\n\tconst char *set;\n\tconst char *dual;\n} coef_tests[] = {\n\t{ \"{ rat: [i] : 0 <= i <= 10 }\",\n\t  \"{ rat: coefficients[[cst] -> [a]] : cst >= 0 and 10a + cst >= 0 }\" },\n\t{ \"{ rat: [i] : FALSE }\",\n\t  \"{ rat: coefficients[[cst] -> [a]] }\" },\n\t{ \"{ rat: [i] : }\",\n\t  \"{ rat: coefficients[[cst] -> [0]] : cst >= 0 }\" },\n\t{ \"{ [0:,1,2:3] }\",\n\t  \"{ rat: coefficients[[c_cst] -> [a, b, c]] : \"\n\t\t\"a >= 0 and 2c >= -c_cst - b and 3c >= -c_cst - b }\" },\n\t{ \"[M, N] -> { [x = (1 - N):-1, -4x:(M - 4x)] }\",\n\t  \"{ rat: coefficients[[c_cst, c_M = 0:, c_N = 0:] -> [a, b = -c_M:]] :\"\n\t\t\"4b >= -c_N + a and 4b >= -c_cst - 2c_N + a }\" },\n\t{ \"{ rat : [x, y] : 1 <= 2x <= 9 and 2 <= 3y <= 16 }\",\n\t  \"{ rat: coefficients[[c_cst] -> [c_x, c_y]] : \"\n\t\t\"4c_y >= -6c_cst - 3c_x and 4c_y >= -6c_cst - 27c_x and \"\n\t\t\"32c_y >= -6c_cst - 3c_x and 32c_y >= -6c_cst - 27c_x }\" },\n\t{ \"{ [x, y, z] : 3y <= 2x - 2 and y >= -2 + 2x and 2y >= 2 - x }\",\n\t  \"{ rat: coefficients[[cst] -> [a, b, c]] }\" },\n};\n\nstruct {\n\tconst char *set;\n\tconst char *dual;\n} sol_tests[] = {\n\t{ \"{ rat: coefficients[[cst] -> [a]] : cst >= 0 and 10a + cst >= 0 }\",\n\t  \"{ rat: [i] : 0 <= i <= 10 }\" },\n\t{ \"{ rat: coefficients[[cst] -> [a]] : FALSE }\",\n\t  \"{ rat: [i] }\" },\n\t{ \"{ rat: coefficients[[cst] -> [a]] }\",\n\t  \"{ rat: [i] : FALSE }\" },\n};\n\n/* Test the basic functionality of isl_basic_set_coefficients and\n * isl_basic_set_solutions.\n */\nstatic int test_dual(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coef_tests); ++i) {\n\t\tint equal;\n\t\tisl_basic_set *bset1, *bset2;\n\n\t\tbset1 = isl_basic_set_read_from_str(ctx, coef_tests[i].set);\n\t\tbset2 = isl_basic_set_read_from_str(ctx, coef_tests[i].dual);\n\t\tbset1 = isl_basic_set_coefficients(bset1);\n\t\tequal = isl_basic_set_is_equal(bset1, bset2);\n\t\tisl_basic_set_free(bset1);\n\t\tisl_basic_set_free(bset2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"incorrect dual\", return -1);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sol_tests); ++i) {\n\t\tint equal;\n\t\tisl_basic_set *bset1, *bset2;\n\n\t\tbset1 = isl_basic_set_read_from_str(ctx, sol_tests[i].set);\n\t\tbset2 = isl_basic_set_read_from_str(ctx, sol_tests[i].dual);\n\t\tbset1 = isl_basic_set_solutions(bset1);\n\t\tequal = isl_basic_set_is_equal(bset1, bset2);\n\t\tisl_basic_set_free(bset1);\n\t\tisl_basic_set_free(bset2);\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"incorrect dual\", return -1);\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\tint scale_tile;\n\tint shift_point;\n\tconst char *domain;\n\tconst char *schedule;\n\tconst char *sizes;\n\tconst char *tile;\n\tconst char *point;\n} tile_tests[] = {\n\t{ 0, 0, \"[n] -> { S[i,j] : 0 <= i,j < n }\",\n\t  \"[{ S[i,j] -> [i] }, { S[i,j] -> [j] }]\",\n\t  \"{ [32,32] }\",\n\t  \"[{ S[i,j] -> [floor(i/32)] }, { S[i,j] -> [floor(j/32)] }]\",\n\t  \"[{ S[i,j] -> [i] }, { S[i,j] -> [j] }]\",\n\t},\n\t{ 1, 0, \"[n] -> { S[i,j] : 0 <= i,j < n }\",\n\t  \"[{ S[i,j] -> [i] }, { S[i,j] -> [j] }]\",\n\t  \"{ [32,32] }\",\n\t  \"[{ S[i,j] -> [32*floor(i/32)] }, { S[i,j] -> [32*floor(j/32)] }]\",\n\t  \"[{ S[i,j] -> [i] }, { S[i,j] -> [j] }]\",\n\t},\n\t{ 0, 1, \"[n] -> { S[i,j] : 0 <= i,j < n }\",\n\t  \"[{ S[i,j] -> [i] }, { S[i,j] -> [j] }]\",\n\t  \"{ [32,32] }\",\n\t  \"[{ S[i,j] -> [floor(i/32)] }, { S[i,j] -> [floor(j/32)] }]\",\n\t  \"[{ S[i,j] -> [i%32] }, { S[i,j] -> [j%32] }]\",\n\t},\n\t{ 1, 1, \"[n] -> { S[i,j] : 0 <= i,j < n }\",\n\t  \"[{ S[i,j] -> [i] }, { S[i,j] -> [j] }]\",\n\t  \"{ [32,32] }\",\n\t  \"[{ S[i,j] -> [32*floor(i/32)] }, { S[i,j] -> [32*floor(j/32)] }]\",\n\t  \"[{ S[i,j] -> [i%32] }, { S[i,j] -> [j%32] }]\",\n\t},\n};\n\n/* Basic tiling tests.  Create a schedule tree with a domain and a band node,\n * tile the band and then check if the tile and point bands have the\n * expected partial schedule.\n */\nstatic int test_tile(isl_ctx *ctx)\n{\n\tint i;\n\tint scale;\n\tint shift;\n\n\tscale = isl_options_get_tile_scale_tile_loops(ctx);\n\tshift = isl_options_get_tile_shift_point_loops(ctx);\n\n\tfor (i = 0; i < ARRAY_SIZE(tile_tests); ++i) {\n\t\tint opt;\n\t\tint equal;\n\t\tconst char *str;\n\t\tisl_union_set *domain;\n\t\tisl_multi_union_pw_aff *mupa, *mupa2;\n\t\tisl_schedule_node *node;\n\t\tisl_multi_val *sizes;\n\n\t\topt = tile_tests[i].scale_tile;\n\t\tisl_options_set_tile_scale_tile_loops(ctx, opt);\n\t\topt = tile_tests[i].shift_point;\n\t\tisl_options_set_tile_shift_point_loops(ctx, opt);\n\n\t\tstr = tile_tests[i].domain;\n\t\tdomain = isl_union_set_read_from_str(ctx, str);\n\t\tnode = isl_schedule_node_from_domain(domain);\n\t\tnode = isl_schedule_node_child(node, 0);\n\t\tstr = tile_tests[i].schedule;\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx, str);\n\t\tnode = isl_schedule_node_insert_partial_schedule(node, mupa);\n\t\tstr = tile_tests[i].sizes;\n\t\tsizes = isl_multi_val_read_from_str(ctx, str);\n\t\tnode = isl_schedule_node_band_tile(node, sizes);\n\n\t\tstr = tile_tests[i].tile;\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx, str);\n\t\tmupa2 = isl_schedule_node_band_get_partial_schedule(node);\n\t\tequal = isl_multi_union_pw_aff_plain_is_equal(mupa, mupa2);\n\t\tisl_multi_union_pw_aff_free(mupa);\n\t\tisl_multi_union_pw_aff_free(mupa2);\n\n\t\tnode = isl_schedule_node_child(node, 0);\n\n\t\tstr = tile_tests[i].point;\n\t\tmupa = isl_multi_union_pw_aff_read_from_str(ctx, str);\n\t\tmupa2 = isl_schedule_node_band_get_partial_schedule(node);\n\t\tif (equal >= 0 && equal)\n\t\t\tequal = isl_multi_union_pw_aff_plain_is_equal(mupa,\n\t\t\t\t\t\t\t\t\tmupa2);\n\t\tisl_multi_union_pw_aff_free(mupa);\n\t\tisl_multi_union_pw_aff_free(mupa2);\n\n\t\tisl_schedule_node_free(node);\n\n\t\tif (equal < 0)\n\t\t\treturn -1;\n\t\tif (!equal)\n\t\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\t\"unexpected result\", return -1);\n\t}\n\n\tisl_options_set_tile_scale_tile_loops(ctx, scale);\n\tisl_options_set_tile_shift_point_loops(ctx, shift);\n\n\treturn 0;\n}\n\n/* Check that the domain hash of a space is equal to the hash\n * of the domain of the space, both ignoring parameters.\n */\nstatic int test_domain_hash(isl_ctx *ctx)\n{\n\tisl_map *map;\n\tisl_space *space;\n\tuint32_t hash1, hash2;\n\n\tmap = isl_map_read_from_str(ctx, \"[n] -> { A[B[x] -> C[]] -> D[] }\");\n\tspace = isl_map_get_space(map);\n\tisl_map_free(map);\n\thash1 = isl_space_get_tuple_domain_hash(space);\n\tspace = isl_space_domain(space);\n\thash2 = isl_space_get_tuple_hash(space);\n\tisl_space_free(space);\n\n\tif (!space)\n\t\treturn -1;\n\tif (hash1 != hash2)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"domain hash not equal to hash of domain\", return -1);\n\n\treturn 0;\n}\n\n/* Check that a universe basic set that is not obviously equal to the universe\n * is still recognized as being equal to the universe.\n */\nstatic int test_universe(isl_ctx *ctx)\n{\n\tconst char *s;\n\tisl_basic_set *bset;\n\tisl_bool is_univ;\n\n\ts = \"{ [] : exists x, y : 3y <= 2x and y >= -3 + 2x and 2y >= 2 - x }\";\n\tbset = isl_basic_set_read_from_str(ctx, s);\n\tis_univ = isl_basic_set_is_universe(bset);\n\tisl_basic_set_free(bset);\n\n\tif (is_univ < 0)\n\t\treturn -1;\n\tif (!is_univ)\n\t\tisl_die(ctx, isl_error_unknown,\n\t\t\t\"not recognized as universe set\", return -1);\n\n\treturn 0;\n}\n\n/* Sets for which chambers are computed and checked.\n */\nconst char *chambers_tests[] = {\n\t\"[A, B, C] -> { [x, y, z] : x >= 0 and y >= 0 and y <= A - x and \"\n\t\t\t\t\"z >= 0 and z <= C - y and z <= B - x - y }\",\n};\n\n/* Add the domain of \"cell\" to \"cells\".\n */\nstatic isl_stat add_cell(__isl_take isl_cell *cell, void *user)\n{\n\tisl_basic_set_list **cells = user;\n\tisl_basic_set *dom;\n\n\tdom = isl_cell_get_domain(cell);\n\tisl_cell_free(cell);\n\t*cells = isl_basic_set_list_add(*cells, dom);\n\n\treturn *cells ? isl_stat_ok : isl_stat_error;\n}\n\n/* Check that the elements of \"list\" are pairwise disjoint.\n */\nstatic isl_stat check_pairwise_disjoint(__isl_keep isl_basic_set_list *list)\n{\n\tint i, j;\n\tisl_size n;\n\n\tn = isl_basic_set_list_n_basic_set(list);\n\tif (n < 0)\n\t\treturn isl_stat_error;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_basic_set *bset_i;\n\n\t\tbset_i = isl_basic_set_list_get_basic_set(list, i);\n\t\tfor (j = i + 1; j < n; ++j) {\n\t\t\tisl_basic_set *bset_j;\n\t\t\tisl_bool disjoint;\n\n\t\t\tbset_j = isl_basic_set_list_get_basic_set(list, j);\n\t\t\tdisjoint = isl_basic_set_is_disjoint(bset_i, bset_j);\n\t\t\tisl_basic_set_free(bset_j);\n\t\t\tif (!disjoint)\n\t\t\t\tisl_die(isl_basic_set_list_get_ctx(list),\n\t\t\t\t\tisl_error_unknown, \"not disjoint\",\n\t\t\t\t\tbreak);\n\t\t\tif (disjoint < 0 || !disjoint)\n\t\t\t\tbreak;\n\t\t}\n\t\tisl_basic_set_free(bset_i);\n\t\tif (j < n)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Check that the chambers computed by isl_vertices_foreach_disjoint_cell\n * are pairwise disjoint.\n */\nstatic int test_chambers(isl_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chambers_tests); ++i) {\n\t\tisl_basic_set *bset;\n\t\tisl_vertices *vertices;\n\t\tisl_basic_set_list *cells;\n\t\tisl_stat ok;\n\n\t\tbset = isl_basic_set_read_from_str(ctx, chambers_tests[i]);\n\t\tvertices = isl_basic_set_compute_vertices(bset);\n\t\tcells = isl_basic_set_list_alloc(ctx, 0);\n\t\tif (isl_vertices_foreach_disjoint_cell(vertices, &add_cell,\n\t\t\t\t\t\t\t&cells) < 0)\n\t\t\tcells = isl_basic_set_list_free(cells);\n\t\tok = check_pairwise_disjoint(cells);\n\t\tisl_basic_set_list_free(cells);\n\t\tisl_vertices_free(vertices);\n\t\tisl_basic_set_free(bset);\n\n\t\tif (ok < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\tconst char *name;\n\tint (*fn)(isl_ctx *ctx);\n} tests [] = {\n\t{ \"universe\", &test_universe },\n\t{ \"domain hash\", &test_domain_hash },\n\t{ \"dual\", &test_dual },\n\t{ \"dependence analysis\", &test_flow },\n\t{ \"val\", &test_val },\n\t{ \"compute divs\", &test_compute_divs },\n\t{ \"partial lexmin\", &test_partial_lexmin },\n\t{ \"simplify\", &test_simplify },\n\t{ \"curry\", &test_curry },\n\t{ \"piecewise multi affine expressions\", &test_pw_multi_aff },\n\t{ \"multi piecewise affine expressions\", &test_multi_pw_aff },\n\t{ \"conversion\", &test_conversion },\n\t{ \"list\", &test_list },\n\t{ \"align parameters\", &test_align_parameters },\n\t{ \"drop unused parameters\", &test_drop_unused_parameters },\n\t{ \"preimage\", &test_preimage },\n\t{ \"pullback\", &test_pullback },\n\t{ \"AST\", &test_ast },\n\t{ \"AST build\", &test_ast_build },\n\t{ \"AST generation\", &test_ast_gen },\n\t{ \"eliminate\", &test_eliminate },\n\t{ \"deltas_map\", &test_deltas_map },\n\t{ \"residue class\", &test_residue_class },\n\t{ \"div\", &test_div },\n\t{ \"slice\", &test_slice },\n\t{ \"fixed power\", &test_fixed_power },\n\t{ \"sample\", &test_sample },\n\t{ \"output\", &test_output },\n\t{ \"vertices\", &test_vertices },\n\t{ \"chambers\", &test_chambers },\n\t{ \"fixed\", &test_fixed },\n\t{ \"equal\", &test_equal },\n\t{ \"disjoint\", &test_disjoint },\n\t{ \"product\", &test_product },\n\t{ \"dim_max\", &test_dim_max },\n\t{ \"affine\", &test_aff },\n\t{ \"injective\", &test_injective },\n\t{ \"schedule (whole component)\", &test_schedule_whole },\n\t{ \"schedule (incremental)\", &test_schedule_incremental },\n\t{ \"schedule tree\", &test_schedule_tree },\n\t{ \"schedule tree prefix\", &test_schedule_tree_prefix },\n\t{ \"schedule tree grouping\", &test_schedule_tree_group },\n\t{ \"tile\", &test_tile },\n\t{ \"union map\", &test_union_map },\n\t{ \"union_pw\", &test_union_pw },\n\t{ \"locus\", &test_locus },\n\t{ \"eval\", &test_eval },\n\t{ \"parse\", &test_parse },\n\t{ \"single-valued\", &test_sv },\n\t{ \"recession cone\", &test_recession_cone },\n\t{ \"affine hull\", &test_affine_hull },\n\t{ \"simple_hull\", &test_simple_hull },\n\t{ \"box hull\", &test_box_hull },\n\t{ \"coalesce\", &test_coalesce },\n\t{ \"factorize\", &test_factorize },\n\t{ \"subset\", &test_subset },\n\t{ \"subtract\", &test_subtract },\n\t{ \"intersect\", &test_intersect },\n\t{ \"lexmin\", &test_lexmin },\n\t{ \"min\", &test_min },\n\t{ \"set lower bounds\", &test_min_mpa },\n\t{ \"gist\", &test_gist },\n\t{ \"piecewise quasi-polynomials\", &test_pwqp },\n\t{ \"lift\", &test_lift },\n\t{ \"bind parameters\", &test_bind },\n\t{ \"unbind parameters\", &test_unbind },\n\t{ \"bound\", &test_bound },\n\t{ \"get lists\", &test_get_list },\n\t{ \"union\", &test_union },\n\t{ \"split periods\", &test_split_periods },\n\t{ \"lexicographic order\", &test_lex },\n\t{ \"bijectivity\", &test_bijective },\n\t{ \"dataflow analysis\", &test_dep },\n\t{ \"reading\", &test_read },\n\t{ \"bounded\", &test_bounded },\n\t{ \"construction\", &test_construction },\n\t{ \"dimension manipulation\", &test_dim },\n\t{ \"map application\", &test_application },\n\t{ \"convex hull\", &test_convex_hull },\n\t{ \"transitive closure\", &test_closure },\n\t{ \"isl_bool\", &test_isl_bool},\n};\n\nint main(int argc, char **argv)\n{\n\tint i;\n\tstruct isl_ctx *ctx;\n\tstruct isl_options *options;\n\n\toptions = isl_options_new_with_defaults();\n\tassert(options);\n\targc = isl_options_parse(options, argc, argv, ISL_ARG_ALL);\n\n\tctx = isl_ctx_alloc_with_options(&isl_options_args, options);\n\tfor (i = 0; i < ARRAY_SIZE(tests); ++i) {\n\t\tprintf(\"%s\\n\", tests[i].name);\n\t\tif (tests[i].fn(ctx) < 0)\n\t\t\tgoto error;\n\t}\n\tisl_ctx_free(ctx);\n\treturn 0;\nerror:\n\tisl_ctx_free(ctx);\n\treturn -1;\n}\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 2, "line": 19}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/check_reparse_test_templ.c", "reportHash": "839afdbcf6530d18fb5994b6b439e90e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 14, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_FACTORIZATION_H (fixit)"}, {"location": {"col": 9, "file": 14, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_factorization.h", "reportHash": "4f056a72639675389cc6e0efa40a43e5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 2, "file": 29, "line": 248}, "message": "place parentheses around the string literal to silence warning"}, {"location": {"col": 3, "file": 29, "line": 249}, "message": "suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "41b390982096cf1e394105dd5cccc809", "checkerName": "clang-diagnostic-string-concatenation", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 436}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "50f2c4a554b8e2ace0d3b69a1833bcc7", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 760}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "fec303697880404f998003c223cc0d6a", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 882}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "d5a9eeddf341ab75e28d40b3f3775f91", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 933}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "1727a46c14167d4cca2e1920c3494dca", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 1297}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "5f5e28c2df09cc831cc78b37d9780582", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 1439}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "8d58537e8fea0c1131fea09d938b83ca", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 1517}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "ccb5acac208623aa9868f92d852e7b31", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 1623}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "2f3a61f7bf2d2874f5aed16add0c012b", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 1731}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "b001bb5d5bd830fec68bb226b54b4b0e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 1895}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "9c9d0a3a955c40bc60874bc70042e24a", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 2055}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "e2c2e0dd63254df789948fa43c295492", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 2521}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "7ff63578409f7bb753e1ac4a048514ea", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 2977}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "fbd1b8aa9382e5da94d3030228f59b39", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 3045}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "b90efb355c5bdcda5eb1bc5854985d30", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 3196}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "32582cd2624259865c040ee9dbe52799", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 3579}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "2afebb1f000b511fda42146c8b1b6995", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 3621}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "f0982e4e5354feac558ed5d10fbd43c3", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 3663}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "af7eee3925c5433a00e63c724dd5bf1c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 3920}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "b1c83c0d61fbba3f716309b3c705b336", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 4103}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "1eba753f8a2dde0325503b70965d2a9d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 4160}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "fe379e9d82540a29013e45759b3468da", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 4178}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "fe379e9d82540a29013e45759b3468da", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 4794}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "0356f349b781b764145570c94641f8e3", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 5447}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "6c22bcb8356baeaed939b57c4763e19e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 5509}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "f62b2a62d2e861914ca0bca47a12b645", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 5573}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "29eb37ec3b3bf375d04e2799eb2cd734", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 5645}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "87ba3a6a2f01a3946bf29b30dde48e94", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 5752}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "e9aa9a7dcf477ca2589b8d1a97f8b948", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 5829}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "70fca47315aafdaf2adfff35ca4e05e1", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 5959}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "699cd331d7785dffe38995bc3f8fd633", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6024}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "51912a7d860f027691db70d262b0a96c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6154}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "2ec364f9da59dcee70bcc5817da2a43c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6260}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "b1d06f56951ec01ecb1cc44a643e89b3", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6321}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "d3d6ee84482ac4ff08f36f80acf7bb93", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6408}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "e7c6b85cf5c9c80b8686323c2532a35e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6492}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "6b03bf111f524108bf0fb08a590ddd8c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6611}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "aa8ce8f14596a84004aed64c0364c835", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6709}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "58054476c86f7a0a6c2d2834b0bc9cf6", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6885}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "756714da30cedd8ebbd01854e38a8e44", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6940}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "7553f21973be2574caddb8331d210d6f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 6989}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "8a772ff4e43369e2ca0796cfecbc5760", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7047}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "b2271803a27e797dd04659a3cf626fb8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7104}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "06b933c2c40597438002d8ff73710189", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7150}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "73b0bf5063b1b3bf078d98da580fc874", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7194}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "9c5d5cfcc193cbb8b34a5a2a232f42a8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7240}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "6132635305ad0400d630f49f382bfe97", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7315}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "72ff7316eb6349e99c193ca5f9955fa8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7364}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "2823c47dcb37a7463621e16125e3f5f3", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7416}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "140dc9985afde5ac11932a4e9ffb8663", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7754}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "01b97509d7983422ed23be199837624d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7879}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "ed0b46507d3b54139761b752e62c0657", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 7933}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "9be54dd0ec4bb45a18c64633a2089b40", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 8028}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "ae1c2ae28b14cd2e758745a7ffd7a17f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 8152}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "bdf0c7ac4cf4842e4b4203d999b3a0a2", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 8259}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "7f56658b34ad2554904c47d6f86fe513", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 8320}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "93f2c9fbfd051d35ae665c5d8dbbc14f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 8477}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "22366b257cd749f77d380cad391a522f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 8537}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "20f99c53ced3f3aa8c41a63b6a224d9f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 9055}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "c804a4f2e1ec6456c644fb8bfadf4aee", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 2, "file": 29, "line": 9080}, "message": "place parentheses around the string literal to silence warning"}, {"location": {"col": 6, "file": 29, "line": 9081}, "message": "suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "5db75fd3151708f410ac277220e956eb", "checkerName": "clang-diagnostic-string-concatenation", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 9095}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "39ca599dcf9128f60fe7c102233746f3", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 9135}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "02d28422547d091ca2c5dacf87463695", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 2, "file": 29, "line": 9165}, "message": "place parentheses around the string literal to silence warning"}, {"location": {"col": 6, "file": 29, "line": 9166}, "message": "suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "5db75fd3151708f410ac277220e956eb", "checkerName": "clang-diagnostic-string-concatenation", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 9182}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "c3686d0088bc8b71add2dbb45efb6aa6", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 9280}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "33081d45b31127a3f8c102a240147690", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 9339}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "7810c7850cdcf888ddcc6c2a76e549d8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 9402}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "80b170250ef7d82e837abc9c9d16581f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 10078}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "4fe5506b033039a81247ab78039bcc20", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 10516}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "40d6acdff77c8be5e7897a8f6e571dd0", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 10533}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "0578cd4f335d04d3cfd5721ad1e572e8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 10601}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "ccf2cbd0378ff37356b5cfd52f43676f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 10773}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "9f4cc36ecf6b157d7c509073a48814e1", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 10895}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_test.c", "reportHash": "6e7d80b6a4fab367d18ea25d1fde6767", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
