<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp", "content": "//===---------------- SemaCodeComplete.cpp - Code Completion ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the code-completion semantic actions.\n//\n//===----------------------------------------------------------------------===//\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprConcepts.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/QualTypeNames.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/CodeCompleteConsumer.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/Designator.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Overload.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <list>\n#include <map>\n#include <string>\n#include <vector>\n\nusing namespace clang;\nusing namespace sema;\n\nnamespace {\n/// A container of code-completion results.\nclass ResultBuilder {\npublic:\n  /// The type of a name-lookup filter, which can be provided to the\n  /// name-lookup routines to specify which declarations should be included in\n  /// the result set (when it returns true) and which declarations should be\n  /// filtered out (returns false).\n  typedef bool (ResultBuilder::*LookupFilter)(const NamedDecl *) const;\n\n  typedef CodeCompletionResult Result;\n\nprivate:\n  /// The actual results we have found.\n  std::vector<Result> Results;\n\n  /// A record of all of the declarations we have found and placed\n  /// into the result set, used to ensure that no declaration ever gets into\n  /// the result set twice.\n  llvm::SmallPtrSet<const Decl *, 16> AllDeclsFound;\n\n  typedef std::pair<const NamedDecl *, unsigned> DeclIndexPair;\n\n  /// An entry in the shadow map, which is optimized to store\n  /// a single (declaration, index) mapping (the common case) but\n  /// can also store a list of (declaration, index) mappings.\n  class ShadowMapEntry {\n    typedef SmallVector<DeclIndexPair, 4> DeclIndexPairVector;\n\n    /// Contains either the solitary NamedDecl * or a vector\n    /// of (declaration, index) pairs.\n    llvm::PointerUnion<const NamedDecl *, DeclIndexPairVector *> DeclOrVector;\n\n    /// When the entry contains a single declaration, this is\n    /// the index associated with that entry.\n    unsigned SingleDeclIndex;\n\n  public:\n    ShadowMapEntry() : DeclOrVector(), SingleDeclIndex(0) {}\n    ShadowMapEntry(const ShadowMapEntry &) = delete;\n    ShadowMapEntry(ShadowMapEntry &&Move) { *this = std::move(Move); }\n    ShadowMapEntry &operator=(const ShadowMapEntry &) = delete;\n    ShadowMapEntry &operator=(ShadowMapEntry &&Move) {\n      SingleDeclIndex = Move.SingleDeclIndex;\n      DeclOrVector = Move.DeclOrVector;\n      Move.DeclOrVector = nullptr;\n      return *this;\n    }\n\n    void Add(const NamedDecl *ND, unsigned Index) {\n      if (DeclOrVector.isNull()) {\n        // 0 - > 1 elements: just set the single element information.\n        DeclOrVector = ND;\n        SingleDeclIndex = Index;\n        return;\n      }\n\n      if (const NamedDecl *PrevND =\n              DeclOrVector.dyn_cast<const NamedDecl *>()) {\n        // 1 -> 2 elements: create the vector of results and push in the\n        // existing declaration.\n        DeclIndexPairVector *Vec = new DeclIndexPairVector;\n        Vec->push_back(DeclIndexPair(PrevND, SingleDeclIndex));\n        DeclOrVector = Vec;\n      }\n\n      // Add the new element to the end of the vector.\n      DeclOrVector.get<DeclIndexPairVector *>()->push_back(\n          DeclIndexPair(ND, Index));\n    }\n\n    ~ShadowMapEntry() {\n      if (DeclIndexPairVector *Vec =\n              DeclOrVector.dyn_cast<DeclIndexPairVector *>()) {\n        delete Vec;\n        DeclOrVector = ((NamedDecl *)nullptr);\n      }\n    }\n\n    // Iteration.\n    class iterator;\n    iterator begin() const;\n    iterator end() const;\n  };\n\n  /// A mapping from declaration names to the declarations that have\n  /// this name within a particular scope and their index within the list of\n  /// results.\n  typedef llvm::DenseMap<DeclarationName, ShadowMapEntry> ShadowMap;\n\n  /// The semantic analysis object for which results are being\n  /// produced.\n  Sema &SemaRef;\n\n  /// The allocator used to allocate new code-completion strings.\n  CodeCompletionAllocator &Allocator;\n\n  CodeCompletionTUInfo &CCTUInfo;\n\n  /// If non-NULL, a filter function used to remove any code-completion\n  /// results that are not desirable.\n  LookupFilter Filter;\n\n  /// Whether we should allow declarations as\n  /// nested-name-specifiers that would otherwise be filtered out.\n  bool AllowNestedNameSpecifiers;\n\n  /// If set, the type that we would prefer our resulting value\n  /// declarations to have.\n  ///\n  /// Closely matching the preferred type gives a boost to a result's\n  /// priority.\n  CanQualType PreferredType;\n\n  /// A list of shadow maps, which is used to model name hiding at\n  /// different levels of, e.g., the inheritance hierarchy.\n  std::list<ShadowMap> ShadowMaps;\n\n  /// Overloaded C++ member functions found by SemaLookup.\n  /// Used to determine when one overload is dominated by another.\n  llvm::DenseMap<std::pair<DeclContext *, /*Name*/uintptr_t>, ShadowMapEntry>\n      OverloadMap;\n\n  /// If we're potentially referring to a C++ member function, the set\n  /// of qualifiers applied to the object type.\n  Qualifiers ObjectTypeQualifiers;\n  /// The kind of the object expression, for rvalue/lvalue overloads.\n  ExprValueKind ObjectKind;\n\n  /// Whether the \\p ObjectTypeQualifiers field is active.\n  bool HasObjectTypeQualifiers;\n\n  /// The selector that we prefer.\n  Selector PreferredSelector;\n\n  /// The completion context in which we are gathering results.\n  CodeCompletionContext CompletionContext;\n\n  /// If we are in an instance method definition, the \\@implementation\n  /// object.\n  ObjCImplementationDecl *ObjCImplementation;\n\n  void AdjustResultPriorityForDecl(Result &R);\n\n  void MaybeAddConstructorResults(Result R);\n\npublic:\n  explicit ResultBuilder(Sema &SemaRef, CodeCompletionAllocator &Allocator,\n                         CodeCompletionTUInfo &CCTUInfo,\n                         const CodeCompletionContext &CompletionContext,\n                         LookupFilter Filter = nullptr)\n      : SemaRef(SemaRef), Allocator(Allocator), CCTUInfo(CCTUInfo),\n        Filter(Filter), AllowNestedNameSpecifiers(false),\n        HasObjectTypeQualifiers(false), CompletionContext(CompletionContext),\n        ObjCImplementation(nullptr) {\n    // If this is an Objective-C instance method definition, dig out the\n    // corresponding implementation.\n    switch (CompletionContext.getKind()) {\n    case CodeCompletionContext::CCC_Expression:\n    case CodeCompletionContext::CCC_ObjCMessageReceiver:\n    case CodeCompletionContext::CCC_ParenthesizedExpression:\n    case CodeCompletionContext::CCC_Statement:\n    case CodeCompletionContext::CCC_Recovery:\n      if (ObjCMethodDecl *Method = SemaRef.getCurMethodDecl())\n        if (Method->isInstanceMethod())\n          if (ObjCInterfaceDecl *Interface = Method->getClassInterface())\n            ObjCImplementation = Interface->getImplementation();\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  /// Determine the priority for a reference to the given declaration.\n  unsigned getBasePriority(const NamedDecl *D);\n\n  /// Whether we should include code patterns in the completion\n  /// results.\n  bool includeCodePatterns() const {\n    return SemaRef.CodeCompleter &&\n           SemaRef.CodeCompleter->includeCodePatterns();\n  }\n\n  /// Set the filter used for code-completion results.\n  void setFilter(LookupFilter Filter) { this->Filter = Filter; }\n\n  Result *data() { return Results.empty() ? nullptr : &Results.front(); }\n  unsigned size() const { return Results.size(); }\n  bool empty() const { return Results.empty(); }\n\n  /// Specify the preferred type.\n  void setPreferredType(QualType T) {\n    PreferredType = SemaRef.Context.getCanonicalType(T);\n  }\n\n  /// Set the cv-qualifiers on the object type, for us in filtering\n  /// calls to member functions.\n  ///\n  /// When there are qualifiers in this set, they will be used to filter\n  /// out member functions that aren't available (because there will be a\n  /// cv-qualifier mismatch) or prefer functions with an exact qualifier\n  /// match.\n  void setObjectTypeQualifiers(Qualifiers Quals, ExprValueKind Kind) {\n    ObjectTypeQualifiers = Quals;\n    ObjectKind = Kind;\n    HasObjectTypeQualifiers = true;\n  }\n\n  /// Set the preferred selector.\n  ///\n  /// When an Objective-C method declaration result is added, and that\n  /// method's selector matches this preferred selector, we give that method\n  /// a slight priority boost.\n  void setPreferredSelector(Selector Sel) { PreferredSelector = Sel; }\n\n  /// Retrieve the code-completion context for which results are\n  /// being collected.\n  const CodeCompletionContext &getCompletionContext() const {\n    return CompletionContext;\n  }\n\n  /// Specify whether nested-name-specifiers are allowed.\n  void allowNestedNameSpecifiers(bool Allow = true) {\n    AllowNestedNameSpecifiers = Allow;\n  }\n\n  /// Return the semantic analysis object for which we are collecting\n  /// code completion results.\n  Sema &getSema() const { return SemaRef; }\n\n  /// Retrieve the allocator used to allocate code completion strings.\n  CodeCompletionAllocator &getAllocator() const { return Allocator; }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() const { return CCTUInfo; }\n\n  /// Determine whether the given declaration is at all interesting\n  /// as a code-completion result.\n  ///\n  /// \\param ND the declaration that we are inspecting.\n  ///\n  /// \\param AsNestedNameSpecifier will be set true if this declaration is\n  /// only interesting when it is a nested-name-specifier.\n  bool isInterestingDecl(const NamedDecl *ND,\n                         bool &AsNestedNameSpecifier) const;\n\n  /// Check whether the result is hidden by the Hiding declaration.\n  ///\n  /// \\returns true if the result is hidden and cannot be found, false if\n  /// the hidden result could still be found. When false, \\p R may be\n  /// modified to describe how the result can be found (e.g., via extra\n  /// qualification).\n  bool CheckHiddenResult(Result &R, DeclContext *CurContext,\n                         const NamedDecl *Hiding);\n\n  /// Add a new result to this result set (if it isn't already in one\n  /// of the shadow maps), or replace an existing result (for, e.g., a\n  /// redeclaration).\n  ///\n  /// \\param R the result to add (if it is unique).\n  ///\n  /// \\param CurContext the context in which this result will be named.\n  void MaybeAddResult(Result R, DeclContext *CurContext = nullptr);\n\n  /// Add a new result to this result set, where we already know\n  /// the hiding declaration (if any).\n  ///\n  /// \\param R the result to add (if it is unique).\n  ///\n  /// \\param CurContext the context in which this result will be named.\n  ///\n  /// \\param Hiding the declaration that hides the result.\n  ///\n  /// \\param InBaseClass whether the result was found in a base\n  /// class of the searched context.\n  void AddResult(Result R, DeclContext *CurContext, NamedDecl *Hiding,\n                 bool InBaseClass);\n\n  /// Add a new non-declaration result to this result set.\n  void AddResult(Result R);\n\n  /// Enter into a new scope.\n  void EnterNewScope();\n\n  /// Exit from the current scope.\n  void ExitScope();\n\n  /// Ignore this declaration, if it is seen again.\n  void Ignore(const Decl *D) { AllDeclsFound.insert(D->getCanonicalDecl()); }\n\n  /// Add a visited context.\n  void addVisitedContext(DeclContext *Ctx) {\n    CompletionContext.addVisitedContext(Ctx);\n  }\n\n  /// \\name Name lookup predicates\n  ///\n  /// These predicates can be passed to the name lookup functions to filter the\n  /// results of name lookup. All of the predicates have the same type, so that\n  ///\n  //@{\n  bool IsOrdinaryName(const NamedDecl *ND) const;\n  bool IsOrdinaryNonTypeName(const NamedDecl *ND) const;\n  bool IsIntegralConstantValue(const NamedDecl *ND) const;\n  bool IsOrdinaryNonValueName(const NamedDecl *ND) const;\n  bool IsNestedNameSpecifier(const NamedDecl *ND) const;\n  bool IsEnum(const NamedDecl *ND) const;\n  bool IsClassOrStruct(const NamedDecl *ND) const;\n  bool IsUnion(const NamedDecl *ND) const;\n  bool IsNamespace(const NamedDecl *ND) const;\n  bool IsNamespaceOrAlias(const NamedDecl *ND) const;\n  bool IsType(const NamedDecl *ND) const;\n  bool IsMember(const NamedDecl *ND) const;\n  bool IsObjCIvar(const NamedDecl *ND) const;\n  bool IsObjCMessageReceiver(const NamedDecl *ND) const;\n  bool IsObjCMessageReceiverOrLambdaCapture(const NamedDecl *ND) const;\n  bool IsObjCCollection(const NamedDecl *ND) const;\n  bool IsImpossibleToSatisfy(const NamedDecl *ND) const;\n  //@}\n};\n} // namespace\n\nvoid PreferredTypeBuilder::enterReturn(Sema &S, SourceLocation Tok) {\n  if (isa<BlockDecl>(S.CurContext)) {\n    if (sema::BlockScopeInfo *BSI = S.getCurBlock()) {\n      ComputeType = nullptr;\n      Type = BSI->ReturnType;\n      ExpectedLoc = Tok;\n    }\n  } else if (const auto *Function = dyn_cast<FunctionDecl>(S.CurContext)) {\n    ComputeType = nullptr;\n    Type = Function->getReturnType();\n    ExpectedLoc = Tok;\n  } else if (const auto *Method = dyn_cast<ObjCMethodDecl>(S.CurContext)) {\n    ComputeType = nullptr;\n    Type = Method->getReturnType();\n    ExpectedLoc = Tok;\n  }\n}\n\nvoid PreferredTypeBuilder::enterVariableInit(SourceLocation Tok, Decl *D) {\n  auto *VD = llvm::dyn_cast_or_null<ValueDecl>(D);\n  ComputeType = nullptr;\n  Type = VD ? VD->getType() : QualType();\n  ExpectedLoc = Tok;\n}\n\nstatic QualType getDesignatedType(QualType BaseType, const Designation &Desig);\n\nvoid PreferredTypeBuilder::enterDesignatedInitializer(SourceLocation Tok,\n                                                      QualType BaseType,\n                                                      const Designation &D) {\n  ComputeType = nullptr;\n  Type = getDesignatedType(BaseType, D);\n  ExpectedLoc = Tok;\n}\n\nvoid PreferredTypeBuilder::enterFunctionArgument(\n    SourceLocation Tok, llvm::function_ref<QualType()> ComputeType) {\n  this->ComputeType = ComputeType;\n  Type = QualType();\n  ExpectedLoc = Tok;\n}\n\nvoid PreferredTypeBuilder::enterParenExpr(SourceLocation Tok,\n                                          SourceLocation LParLoc) {\n  // expected type for parenthesized expression does not change.\n  if (ExpectedLoc == LParLoc)\n    ExpectedLoc = Tok;\n}\n\nstatic QualType getPreferredTypeOfBinaryRHS(Sema &S, Expr *LHS,\n                                            tok::TokenKind Op) {\n  if (!LHS)\n    return QualType();\n\n  QualType LHSType = LHS->getType();\n  if (LHSType->isPointerType()) {\n    if (Op == tok::plus || Op == tok::plusequal || Op == tok::minusequal)\n      return S.getASTContext().getPointerDiffType();\n    // Pointer difference is more common than subtracting an int from a pointer.\n    if (Op == tok::minus)\n      return LHSType;\n  }\n\n  switch (Op) {\n  // No way to infer the type of RHS from LHS.\n  case tok::comma:\n    return QualType();\n  // Prefer the type of the left operand for all of these.\n  // Arithmetic operations.\n  case tok::plus:\n  case tok::plusequal:\n  case tok::minus:\n  case tok::minusequal:\n  case tok::percent:\n  case tok::percentequal:\n  case tok::slash:\n  case tok::slashequal:\n  case tok::star:\n  case tok::starequal:\n  // Assignment.\n  case tok::equal:\n  // Comparison operators.\n  case tok::equalequal:\n  case tok::exclaimequal:\n  case tok::less:\n  case tok::lessequal:\n  case tok::greater:\n  case tok::greaterequal:\n  case tok::spaceship:\n    return LHS->getType();\n  // Binary shifts are often overloaded, so don't try to guess those.\n  case tok::greatergreater:\n  case tok::greatergreaterequal:\n  case tok::lessless:\n  case tok::lesslessequal:\n    if (LHSType->isIntegralOrEnumerationType())\n      return S.getASTContext().IntTy;\n    return QualType();\n  // Logical operators, assume we want bool.\n  case tok::ampamp:\n  case tok::pipepipe:\n  case tok::caretcaret:\n    return S.getASTContext().BoolTy;\n  // Operators often used for bit manipulation are typically used with the type\n  // of the left argument.\n  case tok::pipe:\n  case tok::pipeequal:\n  case tok::caret:\n  case tok::caretequal:\n  case tok::amp:\n  case tok::ampequal:\n    if (LHSType->isIntegralOrEnumerationType())\n      return LHSType;\n    return QualType();\n  // RHS should be a pointer to a member of the 'LHS' type, but we can't give\n  // any particular type here.\n  case tok::periodstar:\n  case tok::arrowstar:\n    return QualType();\n  default:\n    // FIXME(ibiryukov): handle the missing op, re-add the assertion.\n    // assert(false && \"unhandled binary op\");\n    return QualType();\n  }\n}\n\n/// Get preferred type for an argument of an unary expression. \\p ContextType is\n/// preferred type of the whole unary expression.\nstatic QualType getPreferredTypeOfUnaryArg(Sema &S, QualType ContextType,\n                                           tok::TokenKind Op) {\n  switch (Op) {\n  case tok::exclaim:\n    return S.getASTContext().BoolTy;\n  case tok::amp:\n    if (!ContextType.isNull() && ContextType->isPointerType())\n      return ContextType->getPointeeType();\n    return QualType();\n  case tok::star:\n    if (ContextType.isNull())\n      return QualType();\n    return S.getASTContext().getPointerType(ContextType.getNonReferenceType());\n  case tok::plus:\n  case tok::minus:\n  case tok::tilde:\n  case tok::minusminus:\n  case tok::plusplus:\n    if (ContextType.isNull())\n      return S.getASTContext().IntTy;\n    // leave as is, these operators typically return the same type.\n    return ContextType;\n  case tok::kw___real:\n  case tok::kw___imag:\n    return QualType();\n  default:\n    assert(false && \"unhandled unary op\");\n    return QualType();\n  }\n}\n\nvoid PreferredTypeBuilder::enterBinary(Sema &S, SourceLocation Tok, Expr *LHS,\n                                       tok::TokenKind Op) {\n  ComputeType = nullptr;\n  Type = getPreferredTypeOfBinaryRHS(S, LHS, Op);\n  ExpectedLoc = Tok;\n}\n\nvoid PreferredTypeBuilder::enterMemAccess(Sema &S, SourceLocation Tok,\n                                          Expr *Base) {\n  if (!Base)\n    return;\n  // Do we have expected type for Base?\n  if (ExpectedLoc != Base->getBeginLoc())\n    return;\n  // Keep the expected type, only update the location.\n  ExpectedLoc = Tok;\n  return;\n}\n\nvoid PreferredTypeBuilder::enterUnary(Sema &S, SourceLocation Tok,\n                                      tok::TokenKind OpKind,\n                                      SourceLocation OpLoc) {\n  ComputeType = nullptr;\n  Type = getPreferredTypeOfUnaryArg(S, this->get(OpLoc), OpKind);\n  ExpectedLoc = Tok;\n}\n\nvoid PreferredTypeBuilder::enterSubscript(Sema &S, SourceLocation Tok,\n                                          Expr *LHS) {\n  ComputeType = nullptr;\n  Type = S.getASTContext().IntTy;\n  ExpectedLoc = Tok;\n}\n\nvoid PreferredTypeBuilder::enterTypeCast(SourceLocation Tok,\n                                         QualType CastType) {\n  ComputeType = nullptr;\n  Type = !CastType.isNull() ? CastType.getCanonicalType() : QualType();\n  ExpectedLoc = Tok;\n}\n\nvoid PreferredTypeBuilder::enterCondition(Sema &S, SourceLocation Tok) {\n  ComputeType = nullptr;\n  Type = S.getASTContext().BoolTy;\n  ExpectedLoc = Tok;\n}\n\nclass ResultBuilder::ShadowMapEntry::iterator {\n  llvm::PointerUnion<const NamedDecl *, const DeclIndexPair *> DeclOrIterator;\n  unsigned SingleDeclIndex;\n\npublic:\n  typedef DeclIndexPair value_type;\n  typedef value_type reference;\n  typedef std::ptrdiff_t difference_type;\n  typedef std::input_iterator_tag iterator_category;\n\n  class pointer {\n    DeclIndexPair Value;\n\n  public:\n    pointer(const DeclIndexPair &Value) : Value(Value) {}\n\n    const DeclIndexPair *operator->() const { return &Value; }\n  };\n\n  iterator() : DeclOrIterator((NamedDecl *)nullptr), SingleDeclIndex(0) {}\n\n  iterator(const NamedDecl *SingleDecl, unsigned Index)\n      : DeclOrIterator(SingleDecl), SingleDeclIndex(Index) {}\n\n  iterator(const DeclIndexPair *Iterator)\n      : DeclOrIterator(Iterator), SingleDeclIndex(0) {}\n\n  iterator &operator++() {\n    if (DeclOrIterator.is<const NamedDecl *>()) {\n      DeclOrIterator = (NamedDecl *)nullptr;\n      SingleDeclIndex = 0;\n      return *this;\n    }\n\n    const DeclIndexPair *I = DeclOrIterator.get<const DeclIndexPair *>();\n    ++I;\n    DeclOrIterator = I;\n    return *this;\n  }\n\n  /*iterator operator++(int) {\n    iterator tmp(*this);\n    ++(*this);\n    return tmp;\n  }*/\n\n  reference operator*() const {\n    if (const NamedDecl *ND = DeclOrIterator.dyn_cast<const NamedDecl *>())\n      return reference(ND, SingleDeclIndex);\n\n    return *DeclOrIterator.get<const DeclIndexPair *>();\n  }\n\n  pointer operator->() const { return pointer(**this); }\n\n  friend bool operator==(const iterator &X, const iterator &Y) {\n    return X.DeclOrIterator.getOpaqueValue() ==\n               Y.DeclOrIterator.getOpaqueValue() &&\n           X.SingleDeclIndex == Y.SingleDeclIndex;\n  }\n\n  friend bool operator!=(const iterator &X, const iterator &Y) {\n    return !(X == Y);\n  }\n};\n\nResultBuilder::ShadowMapEntry::iterator\nResultBuilder::ShadowMapEntry::begin() const {\n  if (DeclOrVector.isNull())\n    return iterator();\n\n  if (const NamedDecl *ND = DeclOrVector.dyn_cast<const NamedDecl *>())\n    return iterator(ND, SingleDeclIndex);\n\n  return iterator(DeclOrVector.get<DeclIndexPairVector *>()->begin());\n}\n\nResultBuilder::ShadowMapEntry::iterator\nResultBuilder::ShadowMapEntry::end() const {\n  if (DeclOrVector.is<const NamedDecl *>() || DeclOrVector.isNull())\n    return iterator();\n\n  return iterator(DeclOrVector.get<DeclIndexPairVector *>()->end());\n}\n\n/// Compute the qualification required to get from the current context\n/// (\\p CurContext) to the target context (\\p TargetContext).\n///\n/// \\param Context the AST context in which the qualification will be used.\n///\n/// \\param CurContext the context where an entity is being named, which is\n/// typically based on the current scope.\n///\n/// \\param TargetContext the context in which the named entity actually\n/// resides.\n///\n/// \\returns a nested name specifier that refers into the target context, or\n/// NULL if no qualification is needed.\nstatic NestedNameSpecifier *\ngetRequiredQualification(ASTContext &Context, const DeclContext *CurContext,\n                         const DeclContext *TargetContext) {\n  SmallVector<const DeclContext *, 4> TargetParents;\n\n  for (const DeclContext *CommonAncestor = TargetContext;\n       CommonAncestor && !CommonAncestor->Encloses(CurContext);\n       CommonAncestor = CommonAncestor->getLookupParent()) {\n    if (CommonAncestor->isTransparentContext() ||\n        CommonAncestor->isFunctionOrMethod())\n      continue;\n\n    TargetParents.push_back(CommonAncestor);\n  }\n\n  NestedNameSpecifier *Result = nullptr;\n  while (!TargetParents.empty()) {\n    const DeclContext *Parent = TargetParents.pop_back_val();\n\n    if (const auto *Namespace = dyn_cast<NamespaceDecl>(Parent)) {\n      if (!Namespace->getIdentifier())\n        continue;\n\n      Result = NestedNameSpecifier::Create(Context, Result, Namespace);\n    } else if (const auto *TD = dyn_cast<TagDecl>(Parent))\n      Result = NestedNameSpecifier::Create(\n          Context, Result, false, Context.getTypeDeclType(TD).getTypePtr());\n  }\n  return Result;\n}\n\n// Some declarations have reserved names that we don't want to ever show.\n// Filter out names reserved for the implementation if they come from a\n// system header.\nstatic bool shouldIgnoreDueToReservedName(const NamedDecl *ND, Sema &SemaRef) {\n  const IdentifierInfo *Id = ND->getIdentifier();\n  if (!Id)\n    return false;\n\n  // Ignore reserved names for compiler provided decls.\n  if (Id->isReservedName() && ND->getLocation().isInvalid())\n    return true;\n\n  // For system headers ignore only double-underscore names.\n  // This allows for system headers providing private symbols with a single\n  // underscore.\n  if (Id->isReservedName(/*doubleUnderscoreOnly=*/true) &&\n      SemaRef.SourceMgr.isInSystemHeader(\n          SemaRef.SourceMgr.getSpellingLoc(ND->getLocation())))\n    return true;\n\n  return false;\n}\n\nbool ResultBuilder::isInterestingDecl(const NamedDecl *ND,\n                                      bool &AsNestedNameSpecifier) const {\n  AsNestedNameSpecifier = false;\n\n  auto *Named = ND;\n  ND = ND->getUnderlyingDecl();\n\n  // Skip unnamed entities.\n  if (!ND->getDeclName())\n    return false;\n\n  // Friend declarations and declarations introduced due to friends are never\n  // added as results.\n  if (ND->getFriendObjectKind() == Decl::FOK_Undeclared)\n    return false;\n\n  // Class template (partial) specializations are never added as results.\n  if (isa<ClassTemplateSpecializationDecl>(ND) ||\n      isa<ClassTemplatePartialSpecializationDecl>(ND))\n    return false;\n\n  // Using declarations themselves are never added as results.\n  if (isa<UsingDecl>(ND))\n    return false;\n\n  if (shouldIgnoreDueToReservedName(ND, SemaRef))\n    return false;\n\n  if (Filter == &ResultBuilder::IsNestedNameSpecifier ||\n      (isa<NamespaceDecl>(ND) && Filter != &ResultBuilder::IsNamespace &&\n       Filter != &ResultBuilder::IsNamespaceOrAlias && Filter != nullptr))\n    AsNestedNameSpecifier = true;\n\n  // Filter out any unwanted results.\n  if (Filter && !(this->*Filter)(Named)) {\n    // Check whether it is interesting as a nested-name-specifier.\n    if (AllowNestedNameSpecifiers && SemaRef.getLangOpts().CPlusPlus &&\n        IsNestedNameSpecifier(ND) &&\n        (Filter != &ResultBuilder::IsMember ||\n         (isa<CXXRecordDecl>(ND) &&\n          cast<CXXRecordDecl>(ND)->isInjectedClassName()))) {\n      AsNestedNameSpecifier = true;\n      return true;\n    }\n\n    return false;\n  }\n  // ... then it must be interesting!\n  return true;\n}\n\nbool ResultBuilder::CheckHiddenResult(Result &R, DeclContext *CurContext,\n                                      const NamedDecl *Hiding) {\n  // In C, there is no way to refer to a hidden name.\n  // FIXME: This isn't true; we can find a tag name hidden by an ordinary\n  // name if we introduce the tag type.\n  if (!SemaRef.getLangOpts().CPlusPlus)\n    return true;\n\n  const DeclContext *HiddenCtx =\n      R.Declaration->getDeclContext()->getRedeclContext();\n\n  // There is no way to qualify a name declared in a function or method.\n  if (HiddenCtx->isFunctionOrMethod())\n    return true;\n\n  if (HiddenCtx == Hiding->getDeclContext()->getRedeclContext())\n    return true;\n\n  // We can refer to the result with the appropriate qualification. Do it.\n  R.Hidden = true;\n  R.QualifierIsInformative = false;\n\n  if (!R.Qualifier)\n    R.Qualifier = getRequiredQualification(SemaRef.Context, CurContext,\n                                           R.Declaration->getDeclContext());\n  return false;\n}\n\n/// A simplified classification of types used to determine whether two\n/// types are \"similar enough\" when adjusting priorities.\nSimplifiedTypeClass clang::getSimplifiedTypeClass(CanQualType T) {\n  switch (T->getTypeClass()) {\n  case Type::Builtin:\n    switch (cast<BuiltinType>(T)->getKind()) {\n    case BuiltinType::Void:\n      return STC_Void;\n\n    case BuiltinType::NullPtr:\n      return STC_Pointer;\n\n    case BuiltinType::Overload:\n    case BuiltinType::Dependent:\n      return STC_Other;\n\n    case BuiltinType::ObjCId:\n    case BuiltinType::ObjCClass:\n    case BuiltinType::ObjCSel:\n      return STC_ObjectiveC;\n\n    default:\n      return STC_Arithmetic;\n    }\n\n  case Type::Complex:\n    return STC_Arithmetic;\n\n  case Type::Pointer:\n    return STC_Pointer;\n\n  case Type::BlockPointer:\n    return STC_Block;\n\n  case Type::LValueReference:\n  case Type::RValueReference:\n    return getSimplifiedTypeClass(T->getAs<ReferenceType>()->getPointeeType());\n\n  case Type::ConstantArray:\n  case Type::IncompleteArray:\n  case Type::VariableArray:\n  case Type::DependentSizedArray:\n    return STC_Array;\n\n  case Type::DependentSizedExtVector:\n  case Type::Vector:\n  case Type::ExtVector:\n    return STC_Arithmetic;\n\n  case Type::FunctionProto:\n  case Type::FunctionNoProto:\n    return STC_Function;\n\n  case Type::Record:\n    return STC_Record;\n\n  case Type::Enum:\n    return STC_Arithmetic;\n\n  case Type::ObjCObject:\n  case Type::ObjCInterface:\n  case Type::ObjCObjectPointer:\n    return STC_ObjectiveC;\n\n  default:\n    return STC_Other;\n  }\n}\n\n/// Get the type that a given expression will have if this declaration\n/// is used as an expression in its \"typical\" code-completion form.\nQualType clang::getDeclUsageType(ASTContext &C, const NamedDecl *ND) {\n  ND = ND->getUnderlyingDecl();\n\n  if (const auto *Type = dyn_cast<TypeDecl>(ND))\n    return C.getTypeDeclType(Type);\n  if (const auto *Iface = dyn_cast<ObjCInterfaceDecl>(ND))\n    return C.getObjCInterfaceType(Iface);\n\n  QualType T;\n  if (const FunctionDecl *Function = ND->getAsFunction())\n    T = Function->getCallResultType();\n  else if (const auto *Method = dyn_cast<ObjCMethodDecl>(ND))\n    T = Method->getSendResultType();\n  else if (const auto *Enumerator = dyn_cast<EnumConstantDecl>(ND))\n    T = C.getTypeDeclType(cast<EnumDecl>(Enumerator->getDeclContext()));\n  else if (const auto *Property = dyn_cast<ObjCPropertyDecl>(ND))\n    T = Property->getType();\n  else if (const auto *Value = dyn_cast<ValueDecl>(ND))\n    T = Value->getType();\n\n  if (T.isNull())\n    return QualType();\n\n  // Dig through references, function pointers, and block pointers to\n  // get down to the likely type of an expression when the entity is\n  // used.\n  do {\n    if (const auto *Ref = T->getAs<ReferenceType>()) {\n      T = Ref->getPointeeType();\n      continue;\n    }\n\n    if (const auto *Pointer = T->getAs<PointerType>()) {\n      if (Pointer->getPointeeType()->isFunctionType()) {\n        T = Pointer->getPointeeType();\n        continue;\n      }\n\n      break;\n    }\n\n    if (const auto *Block = T->getAs<BlockPointerType>()) {\n      T = Block->getPointeeType();\n      continue;\n    }\n\n    if (const auto *Function = T->getAs<FunctionType>()) {\n      T = Function->getReturnType();\n      continue;\n    }\n\n    break;\n  } while (true);\n\n  return T;\n}\n\nunsigned ResultBuilder::getBasePriority(const NamedDecl *ND) {\n  if (!ND)\n    return CCP_Unlikely;\n\n  // Context-based decisions.\n  const DeclContext *LexicalDC = ND->getLexicalDeclContext();\n  if (LexicalDC->isFunctionOrMethod()) {\n    // _cmd is relatively rare\n    if (const auto *ImplicitParam = dyn_cast<ImplicitParamDecl>(ND))\n      if (ImplicitParam->getIdentifier() &&\n          ImplicitParam->getIdentifier()->isStr(\"_cmd\"))\n        return CCP_ObjC_cmd;\n\n    return CCP_LocalDeclaration;\n  }\n\n  const DeclContext *DC = ND->getDeclContext()->getRedeclContext();\n  if (DC->isRecord() || isa<ObjCContainerDecl>(DC)) {\n    // Explicit destructor calls are very rare.\n    if (isa<CXXDestructorDecl>(ND))\n      return CCP_Unlikely;\n    // Explicit operator and conversion function calls are also very rare.\n    auto DeclNameKind = ND->getDeclName().getNameKind();\n    if (DeclNameKind == DeclarationName::CXXOperatorName ||\n        DeclNameKind == DeclarationName::CXXLiteralOperatorName ||\n        DeclNameKind == DeclarationName::CXXConversionFunctionName)\n      return CCP_Unlikely;\n    return CCP_MemberDeclaration;\n  }\n\n  // Content-based decisions.\n  if (isa<EnumConstantDecl>(ND))\n    return CCP_Constant;\n\n  // Use CCP_Type for type declarations unless we're in a statement, Objective-C\n  // message receiver, or parenthesized expression context. There, it's as\n  // likely that the user will want to write a type as other declarations.\n  if ((isa<TypeDecl>(ND) || isa<ObjCInterfaceDecl>(ND)) &&\n      !(CompletionContext.getKind() == CodeCompletionContext::CCC_Statement ||\n        CompletionContext.getKind() ==\n            CodeCompletionContext::CCC_ObjCMessageReceiver ||\n        CompletionContext.getKind() ==\n            CodeCompletionContext::CCC_ParenthesizedExpression))\n    return CCP_Type;\n\n  return CCP_Declaration;\n}\n\nvoid ResultBuilder::AdjustResultPriorityForDecl(Result &R) {\n  // If this is an Objective-C method declaration whose selector matches our\n  // preferred selector, give it a priority boost.\n  if (!PreferredSelector.isNull())\n    if (const auto *Method = dyn_cast<ObjCMethodDecl>(R.Declaration))\n      if (PreferredSelector == Method->getSelector())\n        R.Priority += CCD_SelectorMatch;\n\n  // If we have a preferred type, adjust the priority for results with exactly-\n  // matching or nearly-matching types.\n  if (!PreferredType.isNull()) {\n    QualType T = getDeclUsageType(SemaRef.Context, R.Declaration);\n    if (!T.isNull()) {\n      CanQualType TC = SemaRef.Context.getCanonicalType(T);\n      // Check for exactly-matching types (modulo qualifiers).\n      if (SemaRef.Context.hasSameUnqualifiedType(PreferredType, TC))\n        R.Priority /= CCF_ExactTypeMatch;\n      // Check for nearly-matching types, based on classification of each.\n      else if ((getSimplifiedTypeClass(PreferredType) ==\n                getSimplifiedTypeClass(TC)) &&\n               !(PreferredType->isEnumeralType() && TC->isEnumeralType()))\n        R.Priority /= CCF_SimilarTypeMatch;\n    }\n  }\n}\n\nstatic DeclContext::lookup_result getConstructors(ASTContext &Context,\n                                                  const CXXRecordDecl *Record) {\n  QualType RecordTy = Context.getTypeDeclType(Record);\n  DeclarationName ConstructorName =\n      Context.DeclarationNames.getCXXConstructorName(\n          Context.getCanonicalType(RecordTy));\n  return Record->lookup(ConstructorName);\n}\n\nvoid ResultBuilder::MaybeAddConstructorResults(Result R) {\n  if (!SemaRef.getLangOpts().CPlusPlus || !R.Declaration ||\n      !CompletionContext.wantConstructorResults())\n    return;\n\n  const NamedDecl *D = R.Declaration;\n  const CXXRecordDecl *Record = nullptr;\n  if (const ClassTemplateDecl *ClassTemplate = dyn_cast<ClassTemplateDecl>(D))\n    Record = ClassTemplate->getTemplatedDecl();\n  else if ((Record = dyn_cast<CXXRecordDecl>(D))) {\n    // Skip specializations and partial specializations.\n    if (isa<ClassTemplateSpecializationDecl>(Record))\n      return;\n  } else {\n    // There are no constructors here.\n    return;\n  }\n\n  Record = Record->getDefinition();\n  if (!Record)\n    return;\n\n  for (NamedDecl *Ctor : getConstructors(SemaRef.Context, Record)) {\n    R.Declaration = Ctor;\n    R.CursorKind = getCursorKindForDecl(R.Declaration);\n    Results.push_back(R);\n  }\n}\n\nstatic bool isConstructor(const Decl *ND) {\n  if (const auto *Tmpl = dyn_cast<FunctionTemplateDecl>(ND))\n    ND = Tmpl->getTemplatedDecl();\n  return isa<CXXConstructorDecl>(ND);\n}\n\nvoid ResultBuilder::MaybeAddResult(Result R, DeclContext *CurContext) {\n  assert(!ShadowMaps.empty() && \"Must enter into a results scope\");\n\n  if (R.Kind != Result::RK_Declaration) {\n    // For non-declaration results, just add the result.\n    Results.push_back(R);\n    return;\n  }\n\n  // Look through using declarations.\n  if (const UsingShadowDecl *Using = dyn_cast<UsingShadowDecl>(R.Declaration)) {\n    CodeCompletionResult Result(Using->getTargetDecl(),\n                                getBasePriority(Using->getTargetDecl()),\n                                R.Qualifier);\n    Result.ShadowDecl = Using;\n    MaybeAddResult(Result, CurContext);\n    return;\n  }\n\n  const Decl *CanonDecl = R.Declaration->getCanonicalDecl();\n  unsigned IDNS = CanonDecl->getIdentifierNamespace();\n\n  bool AsNestedNameSpecifier = false;\n  if (!isInterestingDecl(R.Declaration, AsNestedNameSpecifier))\n    return;\n\n  // C++ constructors are never found by name lookup.\n  if (isConstructor(R.Declaration))\n    return;\n\n  ShadowMap &SMap = ShadowMaps.back();\n  ShadowMapEntry::iterator I, IEnd;\n  ShadowMap::iterator NamePos = SMap.find(R.Declaration->getDeclName());\n  if (NamePos != SMap.end()) {\n    I = NamePos->second.begin();\n    IEnd = NamePos->second.end();\n  }\n\n  for (; I != IEnd; ++I) {\n    const NamedDecl *ND = I->first;\n    unsigned Index = I->second;\n    if (ND->getCanonicalDecl() == CanonDecl) {\n      // This is a redeclaration. Always pick the newer declaration.\n      Results[Index].Declaration = R.Declaration;\n\n      // We're done.\n      return;\n    }\n  }\n\n  // This is a new declaration in this scope. However, check whether this\n  // declaration name is hidden by a similarly-named declaration in an outer\n  // scope.\n  std::list<ShadowMap>::iterator SM, SMEnd = ShadowMaps.end();\n  --SMEnd;\n  for (SM = ShadowMaps.begin(); SM != SMEnd; ++SM) {\n    ShadowMapEntry::iterator I, IEnd;\n    ShadowMap::iterator NamePos = SM->find(R.Declaration->getDeclName());\n    if (NamePos != SM->end()) {\n      I = NamePos->second.begin();\n      IEnd = NamePos->second.end();\n    }\n    for (; I != IEnd; ++I) {\n      // A tag declaration does not hide a non-tag declaration.\n      if (I->first->hasTagIdentifierNamespace() &&\n          (IDNS & (Decl::IDNS_Member | Decl::IDNS_Ordinary |\n                   Decl::IDNS_LocalExtern | Decl::IDNS_ObjCProtocol)))\n        continue;\n\n      // Protocols are in distinct namespaces from everything else.\n      if (((I->first->getIdentifierNamespace() & Decl::IDNS_ObjCProtocol) ||\n           (IDNS & Decl::IDNS_ObjCProtocol)) &&\n          I->first->getIdentifierNamespace() != IDNS)\n        continue;\n\n      // The newly-added result is hidden by an entry in the shadow map.\n      if (CheckHiddenResult(R, CurContext, I->first))\n        return;\n\n      break;\n    }\n  }\n\n  // Make sure that any given declaration only shows up in the result set once.\n  if (!AllDeclsFound.insert(CanonDecl).second)\n    return;\n\n  // If the filter is for nested-name-specifiers, then this result starts a\n  // nested-name-specifier.\n  if (AsNestedNameSpecifier) {\n    R.StartsNestedNameSpecifier = true;\n    R.Priority = CCP_NestedNameSpecifier;\n  } else\n    AdjustResultPriorityForDecl(R);\n\n  // If this result is supposed to have an informative qualifier, add one.\n  if (R.QualifierIsInformative && !R.Qualifier &&\n      !R.StartsNestedNameSpecifier) {\n    const DeclContext *Ctx = R.Declaration->getDeclContext();\n    if (const NamespaceDecl *Namespace = dyn_cast<NamespaceDecl>(Ctx))\n      R.Qualifier =\n          NestedNameSpecifier::Create(SemaRef.Context, nullptr, Namespace);\n    else if (const TagDecl *Tag = dyn_cast<TagDecl>(Ctx))\n      R.Qualifier = NestedNameSpecifier::Create(\n          SemaRef.Context, nullptr, false,\n          SemaRef.Context.getTypeDeclType(Tag).getTypePtr());\n    else\n      R.QualifierIsInformative = false;\n  }\n\n  // Insert this result into the set of results and into the current shadow\n  // map.\n  SMap[R.Declaration->getDeclName()].Add(R.Declaration, Results.size());\n  Results.push_back(R);\n\n  if (!AsNestedNameSpecifier)\n    MaybeAddConstructorResults(R);\n}\n\nstatic void setInBaseClass(ResultBuilder::Result &R) {\n  R.Priority += CCD_InBaseClass;\n  R.InBaseClass = true;\n}\n\nenum class OverloadCompare { BothViable, Dominates, Dominated };\n// Will Candidate ever be called on the object, when overloaded with Incumbent?\n// Returns Dominates if Candidate is always called, Dominated if Incumbent is\n// always called, BothViable if either may be called dependending on arguments.\n// Precondition: must actually be overloads!\nstatic OverloadCompare compareOverloads(const CXXMethodDecl &Candidate,\n                                        const CXXMethodDecl &Incumbent,\n                                        const Qualifiers &ObjectQuals,\n                                        ExprValueKind ObjectKind) {\n  // Base/derived shadowing is handled elsewhere.\n  if (Candidate.getDeclContext() != Incumbent.getDeclContext())\n    return OverloadCompare::BothViable;\n  if (Candidate.isVariadic() != Incumbent.isVariadic() ||\n      Candidate.getNumParams() != Incumbent.getNumParams() ||\n      Candidate.getMinRequiredArguments() !=\n          Incumbent.getMinRequiredArguments())\n    return OverloadCompare::BothViable;\n  for (unsigned I = 0, E = Candidate.getNumParams(); I != E; ++I)\n    if (Candidate.parameters()[I]->getType().getCanonicalType() !=\n        Incumbent.parameters()[I]->getType().getCanonicalType())\n      return OverloadCompare::BothViable;\n  if (!llvm::empty(Candidate.specific_attrs<EnableIfAttr>()) ||\n      !llvm::empty(Incumbent.specific_attrs<EnableIfAttr>()))\n    return OverloadCompare::BothViable;\n  // At this point, we know calls can't pick one or the other based on\n  // arguments, so one of the two must win. (Or both fail, handled elsewhere).\n  RefQualifierKind CandidateRef = Candidate.getRefQualifier();\n  RefQualifierKind IncumbentRef = Incumbent.getRefQualifier();\n  if (CandidateRef != IncumbentRef) {\n    // If the object kind is LValue/RValue, there's one acceptable ref-qualifier\n    // and it can't be mixed with ref-unqualified overloads (in valid code).\n\n    // For xvalue objects, we prefer the rvalue overload even if we have to\n    // add qualifiers (which is rare, because const&& is rare).\n    if (ObjectKind == clang::VK_XValue)\n      return CandidateRef == RQ_RValue ? OverloadCompare::Dominates\n                                       : OverloadCompare::Dominated;\n  }\n  // Now the ref qualifiers are the same (or we're in some invalid state).\n  // So make some decision based on the qualifiers.\n  Qualifiers CandidateQual = Candidate.getMethodQualifiers();\n  Qualifiers IncumbentQual = Incumbent.getMethodQualifiers();\n  bool CandidateSuperset = CandidateQual.compatiblyIncludes(IncumbentQual);\n  bool IncumbentSuperset = IncumbentQual.compatiblyIncludes(CandidateQual);\n  if (CandidateSuperset == IncumbentSuperset)\n    return OverloadCompare::BothViable;\n  return IncumbentSuperset ? OverloadCompare::Dominates\n                           : OverloadCompare::Dominated;\n}\n\nvoid ResultBuilder::AddResult(Result R, DeclContext *CurContext,\n                              NamedDecl *Hiding, bool InBaseClass = false) {\n  if (R.Kind != Result::RK_Declaration) {\n    // For non-declaration results, just add the result.\n    Results.push_back(R);\n    return;\n  }\n\n  // Look through using declarations.\n  if (const auto *Using = dyn_cast<UsingShadowDecl>(R.Declaration)) {\n    CodeCompletionResult Result(Using->getTargetDecl(),\n                                getBasePriority(Using->getTargetDecl()),\n                                R.Qualifier);\n    Result.ShadowDecl = Using;\n    AddResult(Result, CurContext, Hiding);\n    return;\n  }\n\n  bool AsNestedNameSpecifier = false;\n  if (!isInterestingDecl(R.Declaration, AsNestedNameSpecifier))\n    return;\n\n  // C++ constructors are never found by name lookup.\n  if (isConstructor(R.Declaration))\n    return;\n\n  if (Hiding && CheckHiddenResult(R, CurContext, Hiding))\n    return;\n\n  // Make sure that any given declaration only shows up in the result set once.\n  if (!AllDeclsFound.insert(R.Declaration->getCanonicalDecl()).second)\n    return;\n\n  // If the filter is for nested-name-specifiers, then this result starts a\n  // nested-name-specifier.\n  if (AsNestedNameSpecifier) {\n    R.StartsNestedNameSpecifier = true;\n    R.Priority = CCP_NestedNameSpecifier;\n  } else if (Filter == &ResultBuilder::IsMember && !R.Qualifier &&\n             InBaseClass &&\n             isa<CXXRecordDecl>(\n                 R.Declaration->getDeclContext()->getRedeclContext()))\n    R.QualifierIsInformative = true;\n\n  // If this result is supposed to have an informative qualifier, add one.\n  if (R.QualifierIsInformative && !R.Qualifier &&\n      !R.StartsNestedNameSpecifier) {\n    const DeclContext *Ctx = R.Declaration->getDeclContext();\n    if (const auto *Namespace = dyn_cast<NamespaceDecl>(Ctx))\n      R.Qualifier =\n          NestedNameSpecifier::Create(SemaRef.Context, nullptr, Namespace);\n    else if (const auto *Tag = dyn_cast<TagDecl>(Ctx))\n      R.Qualifier = NestedNameSpecifier::Create(\n          SemaRef.Context, nullptr, false,\n          SemaRef.Context.getTypeDeclType(Tag).getTypePtr());\n    else\n      R.QualifierIsInformative = false;\n  }\n\n  // Adjust the priority if this result comes from a base class.\n  if (InBaseClass)\n    setInBaseClass(R);\n\n  AdjustResultPriorityForDecl(R);\n\n  if (HasObjectTypeQualifiers)\n    if (const auto *Method = dyn_cast<CXXMethodDecl>(R.Declaration))\n      if (Method->isInstance()) {\n        Qualifiers MethodQuals = Method->getMethodQualifiers();\n        if (ObjectTypeQualifiers == MethodQuals)\n          R.Priority += CCD_ObjectQualifierMatch;\n        else if (ObjectTypeQualifiers - MethodQuals) {\n          // The method cannot be invoked, because doing so would drop\n          // qualifiers.\n          return;\n        }\n        // Detect cases where a ref-qualified method cannot be invoked.\n        switch (Method->getRefQualifier()) {\n          case RQ_LValue:\n            if (ObjectKind != VK_LValue && !MethodQuals.hasConst())\n              return;\n            break;\n          case RQ_RValue:\n            if (ObjectKind == VK_LValue)\n              return;\n            break;\n          case RQ_None:\n            break;\n        }\n\n        /// Check whether this dominates another overloaded method, which should\n        /// be suppressed (or vice versa).\n        /// Motivating case is const_iterator begin() const vs iterator begin().\n        auto &OverloadSet = OverloadMap[std::make_pair(\n            CurContext, Method->getDeclName().getAsOpaqueInteger())];\n        for (const DeclIndexPair Entry : OverloadSet) {\n          Result &Incumbent = Results[Entry.second];\n          switch (compareOverloads(*Method,\n                                   *cast<CXXMethodDecl>(Incumbent.Declaration),\n                                   ObjectTypeQualifiers, ObjectKind)) {\n          case OverloadCompare::Dominates:\n            // Replace the dominated overload with this one.\n            // FIXME: if the overload dominates multiple incumbents then we\n            // should remove all. But two overloads is by far the common case.\n            Incumbent = std::move(R);\n            return;\n          case OverloadCompare::Dominated:\n            // This overload can't be called, drop it.\n            return;\n          case OverloadCompare::BothViable:\n            break;\n          }\n        }\n        OverloadSet.Add(Method, Results.size());\n      }\n\n  // Insert this result into the set of results.\n  Results.push_back(R);\n\n  if (!AsNestedNameSpecifier)\n    MaybeAddConstructorResults(R);\n}\n\nvoid ResultBuilder::AddResult(Result R) {\n  assert(R.Kind != Result::RK_Declaration &&\n         \"Declaration results need more context\");\n  Results.push_back(R);\n}\n\n/// Enter into a new scope.\nvoid ResultBuilder::EnterNewScope() { ShadowMaps.emplace_back(); }\n\n/// Exit from the current scope.\nvoid ResultBuilder::ExitScope() {\n  ShadowMaps.pop_back();\n}\n\n/// Determines whether this given declaration will be found by\n/// ordinary name lookup.\nbool ResultBuilder::IsOrdinaryName(const NamedDecl *ND) const {\n  ND = ND->getUnderlyingDecl();\n\n  // If name lookup finds a local extern declaration, then we are in a\n  // context where it behaves like an ordinary name.\n  unsigned IDNS = Decl::IDNS_Ordinary | Decl::IDNS_LocalExtern;\n  if (SemaRef.getLangOpts().CPlusPlus)\n    IDNS |= Decl::IDNS_Tag | Decl::IDNS_Namespace | Decl::IDNS_Member;\n  else if (SemaRef.getLangOpts().ObjC) {\n    if (isa<ObjCIvarDecl>(ND))\n      return true;\n  }\n\n  return ND->getIdentifierNamespace() & IDNS;\n}\n\n/// Determines whether this given declaration will be found by\n/// ordinary name lookup but is not a type name.\nbool ResultBuilder::IsOrdinaryNonTypeName(const NamedDecl *ND) const {\n  ND = ND->getUnderlyingDecl();\n  if (isa<TypeDecl>(ND))\n    return false;\n  // Objective-C interfaces names are not filtered by this method because they\n  // can be used in a class property expression. We can still filter out\n  // @class declarations though.\n  if (const auto *ID = dyn_cast<ObjCInterfaceDecl>(ND)) {\n    if (!ID->getDefinition())\n      return false;\n  }\n\n  unsigned IDNS = Decl::IDNS_Ordinary | Decl::IDNS_LocalExtern;\n  if (SemaRef.getLangOpts().CPlusPlus)\n    IDNS |= Decl::IDNS_Tag | Decl::IDNS_Namespace | Decl::IDNS_Member;\n  else if (SemaRef.getLangOpts().ObjC) {\n    if (isa<ObjCIvarDecl>(ND))\n      return true;\n  }\n\n  return ND->getIdentifierNamespace() & IDNS;\n}\n\nbool ResultBuilder::IsIntegralConstantValue(const NamedDecl *ND) const {\n  if (!IsOrdinaryNonTypeName(ND))\n    return 0;\n\n  if (const auto *VD = dyn_cast<ValueDecl>(ND->getUnderlyingDecl()))\n    if (VD->getType()->isIntegralOrEnumerationType())\n      return true;\n\n  return false;\n}\n\n/// Determines whether this given declaration will be found by\n/// ordinary name lookup.\nbool ResultBuilder::IsOrdinaryNonValueName(const NamedDecl *ND) const {\n  ND = ND->getUnderlyingDecl();\n\n  unsigned IDNS = Decl::IDNS_Ordinary | Decl::IDNS_LocalExtern;\n  if (SemaRef.getLangOpts().CPlusPlus)\n    IDNS |= Decl::IDNS_Tag | Decl::IDNS_Namespace;\n\n  return (ND->getIdentifierNamespace() & IDNS) && !isa<ValueDecl>(ND) &&\n         !isa<FunctionTemplateDecl>(ND) && !isa<ObjCPropertyDecl>(ND);\n}\n\n/// Determines whether the given declaration is suitable as the\n/// start of a C++ nested-name-specifier, e.g., a class or namespace.\nbool ResultBuilder::IsNestedNameSpecifier(const NamedDecl *ND) const {\n  // Allow us to find class templates, too.\n  if (const auto *ClassTemplate = dyn_cast<ClassTemplateDecl>(ND))\n    ND = ClassTemplate->getTemplatedDecl();\n\n  return SemaRef.isAcceptableNestedNameSpecifier(ND);\n}\n\n/// Determines whether the given declaration is an enumeration.\nbool ResultBuilder::IsEnum(const NamedDecl *ND) const {\n  return isa<EnumDecl>(ND);\n}\n\n/// Determines whether the given declaration is a class or struct.\nbool ResultBuilder::IsClassOrStruct(const NamedDecl *ND) const {\n  // Allow us to find class templates, too.\n  if (const auto *ClassTemplate = dyn_cast<ClassTemplateDecl>(ND))\n    ND = ClassTemplate->getTemplatedDecl();\n\n  // For purposes of this check, interfaces match too.\n  if (const auto *RD = dyn_cast<RecordDecl>(ND))\n    return RD->getTagKind() == TTK_Class || RD->getTagKind() == TTK_Struct ||\n           RD->getTagKind() == TTK_Interface;\n\n  return false;\n}\n\n/// Determines whether the given declaration is a union.\nbool ResultBuilder::IsUnion(const NamedDecl *ND) const {\n  // Allow us to find class templates, too.\n  if (const auto *ClassTemplate = dyn_cast<ClassTemplateDecl>(ND))\n    ND = ClassTemplate->getTemplatedDecl();\n\n  if (const auto *RD = dyn_cast<RecordDecl>(ND))\n    return RD->getTagKind() == TTK_Union;\n\n  return false;\n}\n\n/// Determines whether the given declaration is a namespace.\nbool ResultBuilder::IsNamespace(const NamedDecl *ND) const {\n  return isa<NamespaceDecl>(ND);\n}\n\n/// Determines whether the given declaration is a namespace or\n/// namespace alias.\nbool ResultBuilder::IsNamespaceOrAlias(const NamedDecl *ND) const {\n  return isa<NamespaceDecl>(ND->getUnderlyingDecl());\n}\n\n/// Determines whether the given declaration is a type.\nbool ResultBuilder::IsType(const NamedDecl *ND) const {\n  ND = ND->getUnderlyingDecl();\n  return isa<TypeDecl>(ND) || isa<ObjCInterfaceDecl>(ND);\n}\n\n/// Determines which members of a class should be visible via\n/// \".\" or \"->\".  Only value declarations, nested name specifiers, and\n/// using declarations thereof should show up.\nbool ResultBuilder::IsMember(const NamedDecl *ND) const {\n  ND = ND->getUnderlyingDecl();\n  return isa<ValueDecl>(ND) || isa<FunctionTemplateDecl>(ND) ||\n         isa<ObjCPropertyDecl>(ND);\n}\n\nstatic bool isObjCReceiverType(ASTContext &C, QualType T) {\n  T = C.getCanonicalType(T);\n  switch (T->getTypeClass()) {\n  case Type::ObjCObject:\n  case Type::ObjCInterface:\n  case Type::ObjCObjectPointer:\n    return true;\n\n  case Type::Builtin:\n    switch (cast<BuiltinType>(T)->getKind()) {\n    case BuiltinType::ObjCId:\n    case BuiltinType::ObjCClass:\n    case BuiltinType::ObjCSel:\n      return true;\n\n    default:\n      break;\n    }\n    return false;\n\n  default:\n    break;\n  }\n\n  if (!C.getLangOpts().CPlusPlus)\n    return false;\n\n  // FIXME: We could perform more analysis here to determine whether a\n  // particular class type has any conversions to Objective-C types. For now,\n  // just accept all class types.\n  return T->isDependentType() || T->isRecordType();\n}\n\nbool ResultBuilder::IsObjCMessageReceiver(const NamedDecl *ND) const {\n  QualType T = getDeclUsageType(SemaRef.Context, ND);\n  if (T.isNull())\n    return false;\n\n  T = SemaRef.Context.getBaseElementType(T);\n  return isObjCReceiverType(SemaRef.Context, T);\n}\n\nbool ResultBuilder::IsObjCMessageReceiverOrLambdaCapture(\n    const NamedDecl *ND) const {\n  if (IsObjCMessageReceiver(ND))\n    return true;\n\n  const auto *Var = dyn_cast<VarDecl>(ND);\n  if (!Var)\n    return false;\n\n  return Var->hasLocalStorage() && !Var->hasAttr<BlocksAttr>();\n}\n\nbool ResultBuilder::IsObjCCollection(const NamedDecl *ND) const {\n  if ((SemaRef.getLangOpts().CPlusPlus && !IsOrdinaryName(ND)) ||\n      (!SemaRef.getLangOpts().CPlusPlus && !IsOrdinaryNonTypeName(ND)))\n    return false;\n\n  QualType T = getDeclUsageType(SemaRef.Context, ND);\n  if (T.isNull())\n    return false;\n\n  T = SemaRef.Context.getBaseElementType(T);\n  return T->isObjCObjectType() || T->isObjCObjectPointerType() ||\n         T->isObjCIdType() ||\n         (SemaRef.getLangOpts().CPlusPlus && T->isRecordType());\n}\n\nbool ResultBuilder::IsImpossibleToSatisfy(const NamedDecl *ND) const {\n  return false;\n}\n\n/// Determines whether the given declaration is an Objective-C\n/// instance variable.\nbool ResultBuilder::IsObjCIvar(const NamedDecl *ND) const {\n  return isa<ObjCIvarDecl>(ND);\n}\n\nnamespace {\n\n/// Visible declaration consumer that adds a code-completion result\n/// for each visible declaration.\nclass CodeCompletionDeclConsumer : public VisibleDeclConsumer {\n  ResultBuilder &Results;\n  DeclContext *InitialLookupCtx;\n  // NamingClass and BaseType are used for access-checking. See\n  // Sema::IsSimplyAccessible for details.\n  CXXRecordDecl *NamingClass;\n  QualType BaseType;\n  std::vector<FixItHint> FixIts;\n\npublic:\n  CodeCompletionDeclConsumer(\n      ResultBuilder &Results, DeclContext *InitialLookupCtx,\n      QualType BaseType = QualType(),\n      std::vector<FixItHint> FixIts = std::vector<FixItHint>())\n      : Results(Results), InitialLookupCtx(InitialLookupCtx),\n        FixIts(std::move(FixIts)) {\n    NamingClass = llvm::dyn_cast<CXXRecordDecl>(InitialLookupCtx);\n    // If BaseType was not provided explicitly, emulate implicit 'this->'.\n    if (BaseType.isNull()) {\n      auto ThisType = Results.getSema().getCurrentThisType();\n      if (!ThisType.isNull()) {\n        assert(ThisType->isPointerType());\n        BaseType = ThisType->getPointeeType();\n        if (!NamingClass)\n          NamingClass = BaseType->getAsCXXRecordDecl();\n      }\n    }\n    this->BaseType = BaseType;\n  }\n\n  void FoundDecl(NamedDecl *ND, NamedDecl *Hiding, DeclContext *Ctx,\n                 bool InBaseClass) override {\n    ResultBuilder::Result Result(ND, Results.getBasePriority(ND), nullptr,\n                                 false, IsAccessible(ND, Ctx), FixIts);\n    Results.AddResult(Result, InitialLookupCtx, Hiding, InBaseClass);\n  }\n\n  void EnteredContext(DeclContext *Ctx) override {\n    Results.addVisitedContext(Ctx);\n  }\n\nprivate:\n  bool IsAccessible(NamedDecl *ND, DeclContext *Ctx) {\n    // Naming class to use for access check. In most cases it was provided\n    // explicitly (e.g. member access (lhs.foo) or qualified lookup (X::)),\n    // for unqualified lookup we fallback to the \\p Ctx in which we found the\n    // member.\n    auto *NamingClass = this->NamingClass;\n    QualType BaseType = this->BaseType;\n    if (auto *Cls = llvm::dyn_cast_or_null<CXXRecordDecl>(Ctx)) {\n      if (!NamingClass)\n        NamingClass = Cls;\n      // When we emulate implicit 'this->' in an unqualified lookup, we might\n      // end up with an invalid naming class. In that case, we avoid emulating\n      // 'this->' qualifier to satisfy preconditions of the access checking.\n      if (NamingClass->getCanonicalDecl() != Cls->getCanonicalDecl() &&\n          !NamingClass->isDerivedFrom(Cls)) {\n        NamingClass = Cls;\n        BaseType = QualType();\n      }\n    } else {\n      // The decl was found outside the C++ class, so only ObjC access checks\n      // apply. Those do not rely on NamingClass and BaseType, so we clear them\n      // out.\n      NamingClass = nullptr;\n      BaseType = QualType();\n    }\n    return Results.getSema().IsSimplyAccessible(ND, NamingClass, BaseType);\n  }\n};\n} // namespace\n\n/// Add type specifiers for the current language as keyword results.\nstatic void AddTypeSpecifierResults(const LangOptions &LangOpts,\n                                    ResultBuilder &Results) {\n  typedef CodeCompletionResult Result;\n  Results.AddResult(Result(\"short\", CCP_Type));\n  Results.AddResult(Result(\"long\", CCP_Type));\n  Results.AddResult(Result(\"signed\", CCP_Type));\n  Results.AddResult(Result(\"unsigned\", CCP_Type));\n  Results.AddResult(Result(\"void\", CCP_Type));\n  Results.AddResult(Result(\"char\", CCP_Type));\n  Results.AddResult(Result(\"int\", CCP_Type));\n  Results.AddResult(Result(\"float\", CCP_Type));\n  Results.AddResult(Result(\"double\", CCP_Type));\n  Results.AddResult(Result(\"enum\", CCP_Type));\n  Results.AddResult(Result(\"struct\", CCP_Type));\n  Results.AddResult(Result(\"union\", CCP_Type));\n  Results.AddResult(Result(\"const\", CCP_Type));\n  Results.AddResult(Result(\"volatile\", CCP_Type));\n\n  if (LangOpts.C99) {\n    // C99-specific\n    Results.AddResult(Result(\"_Complex\", CCP_Type));\n    Results.AddResult(Result(\"_Imaginary\", CCP_Type));\n    Results.AddResult(Result(\"_Bool\", CCP_Type));\n    Results.AddResult(Result(\"restrict\", CCP_Type));\n  }\n\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n  if (LangOpts.CPlusPlus) {\n    // C++-specific\n    Results.AddResult(\n        Result(\"bool\", CCP_Type + (LangOpts.ObjC ? CCD_bool_in_ObjC : 0)));\n    Results.AddResult(Result(\"class\", CCP_Type));\n    Results.AddResult(Result(\"wchar_t\", CCP_Type));\n\n    // typename name\n    Builder.AddTypedTextChunk(\"typename\");\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"name\");\n    Results.AddResult(Result(Builder.TakeString()));\n\n    if (LangOpts.CPlusPlus11) {\n      Results.AddResult(Result(\"auto\", CCP_Type));\n      Results.AddResult(Result(\"char16_t\", CCP_Type));\n      Results.AddResult(Result(\"char32_t\", CCP_Type));\n\n      Builder.AddTypedTextChunk(\"decltype\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n    }\n  } else\n    Results.AddResult(Result(\"__auto_type\", CCP_Type));\n\n  // GNU keywords\n  if (LangOpts.GNUKeywords) {\n    // FIXME: Enable when we actually support decimal floating point.\n    //    Results.AddResult(Result(\"_Decimal32\"));\n    //    Results.AddResult(Result(\"_Decimal64\"));\n    //    Results.AddResult(Result(\"_Decimal128\"));\n\n    Builder.AddTypedTextChunk(\"typeof\");\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"expression\");\n    Results.AddResult(Result(Builder.TakeString()));\n\n    Builder.AddTypedTextChunk(\"typeof\");\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    Builder.AddPlaceholderChunk(\"type\");\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    Results.AddResult(Result(Builder.TakeString()));\n  }\n\n  // Nullability\n  Results.AddResult(Result(\"_Nonnull\", CCP_Type));\n  Results.AddResult(Result(\"_Null_unspecified\", CCP_Type));\n  Results.AddResult(Result(\"_Nullable\", CCP_Type));\n}\n\nstatic void AddStorageSpecifiers(Sema::ParserCompletionContext CCC,\n                                 const LangOptions &LangOpts,\n                                 ResultBuilder &Results) {\n  typedef CodeCompletionResult Result;\n  // Note: we don't suggest either \"auto\" or \"register\", because both\n  // are pointless as storage specifiers. Elsewhere, we suggest \"auto\"\n  // in C++0x as a type specifier.\n  Results.AddResult(Result(\"extern\"));\n  Results.AddResult(Result(\"static\"));\n\n  if (LangOpts.CPlusPlus11) {\n    CodeCompletionAllocator &Allocator = Results.getAllocator();\n    CodeCompletionBuilder Builder(Allocator, Results.getCodeCompletionTUInfo());\n\n    // alignas\n    Builder.AddTypedTextChunk(\"alignas\");\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    Builder.AddPlaceholderChunk(\"expression\");\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    Results.AddResult(Result(Builder.TakeString()));\n\n    Results.AddResult(Result(\"constexpr\"));\n    Results.AddResult(Result(\"thread_local\"));\n  }\n}\n\nstatic void AddFunctionSpecifiers(Sema::ParserCompletionContext CCC,\n                                  const LangOptions &LangOpts,\n                                  ResultBuilder &Results) {\n  typedef CodeCompletionResult Result;\n  switch (CCC) {\n  case Sema::PCC_Class:\n  case Sema::PCC_MemberTemplate:\n    if (LangOpts.CPlusPlus) {\n      Results.AddResult(Result(\"explicit\"));\n      Results.AddResult(Result(\"friend\"));\n      Results.AddResult(Result(\"mutable\"));\n      Results.AddResult(Result(\"virtual\"));\n    }\n    LLVM_FALLTHROUGH;\n\n  case Sema::PCC_ObjCInterface:\n  case Sema::PCC_ObjCImplementation:\n  case Sema::PCC_Namespace:\n  case Sema::PCC_Template:\n    if (LangOpts.CPlusPlus || LangOpts.C99)\n      Results.AddResult(Result(\"inline\"));\n    break;\n\n  case Sema::PCC_ObjCInstanceVariableList:\n  case Sema::PCC_Expression:\n  case Sema::PCC_Statement:\n  case Sema::PCC_ForInit:\n  case Sema::PCC_Condition:\n  case Sema::PCC_RecoveryInFunction:\n  case Sema::PCC_Type:\n  case Sema::PCC_ParenthesizedExpression:\n  case Sema::PCC_LocalDeclarationSpecifiers:\n    break;\n  }\n}\n\nstatic void AddObjCExpressionResults(ResultBuilder &Results, bool NeedAt);\nstatic void AddObjCStatementResults(ResultBuilder &Results, bool NeedAt);\nstatic void AddObjCVisibilityResults(const LangOptions &LangOpts,\n                                     ResultBuilder &Results, bool NeedAt);\nstatic void AddObjCImplementationResults(const LangOptions &LangOpts,\n                                         ResultBuilder &Results, bool NeedAt);\nstatic void AddObjCInterfaceResults(const LangOptions &LangOpts,\n                                    ResultBuilder &Results, bool NeedAt);\nstatic void AddObjCTopLevelResults(ResultBuilder &Results, bool NeedAt);\n\nstatic void AddTypedefResult(ResultBuilder &Results) {\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n  Builder.AddTypedTextChunk(\"typedef\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"type\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"name\");\n  Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n  Results.AddResult(CodeCompletionResult(Builder.TakeString()));\n}\n\n// using name = type\nstatic void AddUsingAliasResult(CodeCompletionBuilder &Builder,\n                                ResultBuilder &Results) {\n  Builder.AddTypedTextChunk(\"using\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"name\");\n  Builder.AddChunk(CodeCompletionString::CK_Equal);\n  Builder.AddPlaceholderChunk(\"type\");\n  Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n  Results.AddResult(CodeCompletionResult(Builder.TakeString()));\n}\n\nstatic bool WantTypesInContext(Sema::ParserCompletionContext CCC,\n                               const LangOptions &LangOpts) {\n  switch (CCC) {\n  case Sema::PCC_Namespace:\n  case Sema::PCC_Class:\n  case Sema::PCC_ObjCInstanceVariableList:\n  case Sema::PCC_Template:\n  case Sema::PCC_MemberTemplate:\n  case Sema::PCC_Statement:\n  case Sema::PCC_RecoveryInFunction:\n  case Sema::PCC_Type:\n  case Sema::PCC_ParenthesizedExpression:\n  case Sema::PCC_LocalDeclarationSpecifiers:\n    return true;\n\n  case Sema::PCC_Expression:\n  case Sema::PCC_Condition:\n    return LangOpts.CPlusPlus;\n\n  case Sema::PCC_ObjCInterface:\n  case Sema::PCC_ObjCImplementation:\n    return false;\n\n  case Sema::PCC_ForInit:\n    return LangOpts.CPlusPlus || LangOpts.ObjC || LangOpts.C99;\n  }\n\n  llvm_unreachable(\"Invalid ParserCompletionContext!\");\n}\n\nstatic PrintingPolicy getCompletionPrintingPolicy(const ASTContext &Context,\n                                                  const Preprocessor &PP) {\n  PrintingPolicy Policy = Sema::getPrintingPolicy(Context, PP);\n  Policy.AnonymousTagLocations = false;\n  Policy.SuppressStrongLifetime = true;\n  Policy.SuppressUnwrittenScope = true;\n  Policy.SuppressScope = true;\n  return Policy;\n}\n\n/// Retrieve a printing policy suitable for code completion.\nstatic PrintingPolicy getCompletionPrintingPolicy(Sema &S) {\n  return getCompletionPrintingPolicy(S.Context, S.PP);\n}\n\n/// Retrieve the string representation of the given type as a string\n/// that has the appropriate lifetime for code completion.\n///\n/// This routine provides a fast path where we provide constant strings for\n/// common type names.\nstatic const char *GetCompletionTypeString(QualType T, ASTContext &Context,\n                                           const PrintingPolicy &Policy,\n                                           CodeCompletionAllocator &Allocator) {\n  if (!T.getLocalQualifiers()) {\n    // Built-in type names are constant strings.\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(T))\n      return BT->getNameAsCString(Policy);\n\n    // Anonymous tag types are constant strings.\n    if (const TagType *TagT = dyn_cast<TagType>(T))\n      if (TagDecl *Tag = TagT->getDecl())\n        if (!Tag->hasNameForLinkage()) {\n          switch (Tag->getTagKind()) {\n          case TTK_Struct:\n            return \"struct <anonymous>\";\n          case TTK_Interface:\n            return \"__interface <anonymous>\";\n          case TTK_Class:\n            return \"class <anonymous>\";\n          case TTK_Union:\n            return \"union <anonymous>\";\n          case TTK_Enum:\n            return \"enum <anonymous>\";\n          }\n        }\n  }\n\n  // Slow path: format the type as a string.\n  std::string Result;\n  T.getAsStringInternal(Result, Policy);\n  return Allocator.CopyString(Result);\n}\n\n/// Add a completion for \"this\", if we're in a member function.\nstatic void addThisCompletion(Sema &S, ResultBuilder &Results) {\n  QualType ThisTy = S.getCurrentThisType();\n  if (ThisTy.isNull())\n    return;\n\n  CodeCompletionAllocator &Allocator = Results.getAllocator();\n  CodeCompletionBuilder Builder(Allocator, Results.getCodeCompletionTUInfo());\n  PrintingPolicy Policy = getCompletionPrintingPolicy(S);\n  Builder.AddResultTypeChunk(\n      GetCompletionTypeString(ThisTy, S.Context, Policy, Allocator));\n  Builder.AddTypedTextChunk(\"this\");\n  Results.AddResult(CodeCompletionResult(Builder.TakeString()));\n}\n\nstatic void AddStaticAssertResult(CodeCompletionBuilder &Builder,\n                                  ResultBuilder &Results,\n                                  const LangOptions &LangOpts) {\n  if (!LangOpts.CPlusPlus11)\n    return;\n\n  Builder.AddTypedTextChunk(\"static_assert\");\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n  Builder.AddPlaceholderChunk(\"expression\");\n  Builder.AddChunk(CodeCompletionString::CK_Comma);\n  Builder.AddPlaceholderChunk(\"message\");\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n  Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n  Results.AddResult(CodeCompletionResult(Builder.TakeString()));\n}\n\nstatic void AddOverrideResults(ResultBuilder &Results,\n                               const CodeCompletionContext &CCContext,\n                               CodeCompletionBuilder &Builder) {\n  Sema &S = Results.getSema();\n  const auto *CR = llvm::dyn_cast<CXXRecordDecl>(S.CurContext);\n  // If not inside a class/struct/union return empty.\n  if (!CR)\n    return;\n  // First store overrides within current class.\n  // These are stored by name to make querying fast in the later step.\n  llvm::StringMap<std::vector<FunctionDecl *>> Overrides;\n  for (auto *Method : CR->methods()) {\n    if (!Method->isVirtual() || !Method->getIdentifier())\n      continue;\n    Overrides[Method->getName()].push_back(Method);\n  }\n\n  for (const auto &Base : CR->bases()) {\n    const auto *BR = Base.getType().getTypePtr()->getAsCXXRecordDecl();\n    if (!BR)\n      continue;\n    for (auto *Method : BR->methods()) {\n      if (!Method->isVirtual() || !Method->getIdentifier())\n        continue;\n      const auto it = Overrides.find(Method->getName());\n      bool IsOverriden = false;\n      if (it != Overrides.end()) {\n        for (auto *MD : it->second) {\n          // If the method in current body is not an overload of this virtual\n          // function, then it overrides this one.\n          if (!S.IsOverload(MD, Method, false)) {\n            IsOverriden = true;\n            break;\n          }\n        }\n      }\n      if (!IsOverriden) {\n        // Generates a new CodeCompletionResult by taking this function and\n        // converting it into an override declaration with only one chunk in the\n        // final CodeCompletionString as a TypedTextChunk.\n        std::string OverrideSignature;\n        llvm::raw_string_ostream OS(OverrideSignature);\n        CodeCompletionResult CCR(Method, 0);\n        PrintingPolicy Policy =\n            getCompletionPrintingPolicy(S.getASTContext(), S.getPreprocessor());\n        auto *CCS = CCR.createCodeCompletionStringForOverride(\n            S.getPreprocessor(), S.getASTContext(), Builder,\n            /*IncludeBriefComments=*/false, CCContext, Policy);\n        Results.AddResult(CodeCompletionResult(CCS, Method, CCP_CodePattern));\n      }\n    }\n  }\n}\n\n/// Add language constructs that show up for \"ordinary\" names.\nstatic void AddOrdinaryNameResults(Sema::ParserCompletionContext CCC, Scope *S,\n                                   Sema &SemaRef, ResultBuilder &Results) {\n  CodeCompletionAllocator &Allocator = Results.getAllocator();\n  CodeCompletionBuilder Builder(Allocator, Results.getCodeCompletionTUInfo());\n\n  typedef CodeCompletionResult Result;\n  switch (CCC) {\n  case Sema::PCC_Namespace:\n    if (SemaRef.getLangOpts().CPlusPlus) {\n      if (Results.includeCodePatterns()) {\n        // namespace <identifier> { declarations }\n        Builder.AddTypedTextChunk(\"namespace\");\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddPlaceholderChunk(\"identifier\");\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n        Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n        Builder.AddPlaceholderChunk(\"declarations\");\n        Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n        Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n\n      // namespace identifier = identifier ;\n      Builder.AddTypedTextChunk(\"namespace\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"name\");\n      Builder.AddChunk(CodeCompletionString::CK_Equal);\n      Builder.AddPlaceholderChunk(\"namespace\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // Using directives\n      Builder.AddTypedTextChunk(\"using namespace\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"identifier\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // asm(string-literal)\n      Builder.AddTypedTextChunk(\"asm\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"string-literal\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      if (Results.includeCodePatterns()) {\n        // Explicit template instantiation\n        Builder.AddTypedTextChunk(\"template\");\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddPlaceholderChunk(\"declaration\");\n        Results.AddResult(Result(Builder.TakeString()));\n      } else {\n        Results.AddResult(Result(\"template\", CodeCompletionResult::RK_Keyword));\n      }\n    }\n\n    if (SemaRef.getLangOpts().ObjC)\n      AddObjCTopLevelResults(Results, true);\n\n    AddTypedefResult(Results);\n    LLVM_FALLTHROUGH;\n\n  case Sema::PCC_Class:\n    if (SemaRef.getLangOpts().CPlusPlus) {\n      // Using declaration\n      Builder.AddTypedTextChunk(\"using\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"qualifier\");\n      Builder.AddTextChunk(\"::\");\n      Builder.AddPlaceholderChunk(\"name\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      if (SemaRef.getLangOpts().CPlusPlus11)\n        AddUsingAliasResult(Builder, Results);\n\n      // using typename qualifier::name (only in a dependent context)\n      if (SemaRef.CurContext->isDependentContext()) {\n        Builder.AddTypedTextChunk(\"using typename\");\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddPlaceholderChunk(\"qualifier\");\n        Builder.AddTextChunk(\"::\");\n        Builder.AddPlaceholderChunk(\"name\");\n        Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n\n      AddStaticAssertResult(Builder, Results, SemaRef.getLangOpts());\n\n      if (CCC == Sema::PCC_Class) {\n        AddTypedefResult(Results);\n\n        bool IsNotInheritanceScope =\n            !(S->getFlags() & Scope::ClassInheritanceScope);\n        // public:\n        Builder.AddTypedTextChunk(\"public\");\n        if (IsNotInheritanceScope && Results.includeCodePatterns())\n          Builder.AddChunk(CodeCompletionString::CK_Colon);\n        Results.AddResult(Result(Builder.TakeString()));\n\n        // protected:\n        Builder.AddTypedTextChunk(\"protected\");\n        if (IsNotInheritanceScope && Results.includeCodePatterns())\n          Builder.AddChunk(CodeCompletionString::CK_Colon);\n        Results.AddResult(Result(Builder.TakeString()));\n\n        // private:\n        Builder.AddTypedTextChunk(\"private\");\n        if (IsNotInheritanceScope && Results.includeCodePatterns())\n          Builder.AddChunk(CodeCompletionString::CK_Colon);\n        Results.AddResult(Result(Builder.TakeString()));\n\n        // FIXME: This adds override results only if we are at the first word of\n        // the declaration/definition. Also call this from other sides to have\n        // more use-cases.\n        AddOverrideResults(Results, CodeCompletionContext::CCC_ClassStructUnion,\n                           Builder);\n      }\n    }\n    LLVM_FALLTHROUGH;\n\n  case Sema::PCC_Template:\n  case Sema::PCC_MemberTemplate:\n    if (SemaRef.getLangOpts().CPlusPlus && Results.includeCodePatterns()) {\n      // template < parameters >\n      Builder.AddTypedTextChunk(\"template\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftAngle);\n      Builder.AddPlaceholderChunk(\"parameters\");\n      Builder.AddChunk(CodeCompletionString::CK_RightAngle);\n      Results.AddResult(Result(Builder.TakeString()));\n    } else {\n      Results.AddResult(Result(\"template\", CodeCompletionResult::RK_Keyword));\n    }\n\n    AddStorageSpecifiers(CCC, SemaRef.getLangOpts(), Results);\n    AddFunctionSpecifiers(CCC, SemaRef.getLangOpts(), Results);\n    break;\n\n  case Sema::PCC_ObjCInterface:\n    AddObjCInterfaceResults(SemaRef.getLangOpts(), Results, true);\n    AddStorageSpecifiers(CCC, SemaRef.getLangOpts(), Results);\n    AddFunctionSpecifiers(CCC, SemaRef.getLangOpts(), Results);\n    break;\n\n  case Sema::PCC_ObjCImplementation:\n    AddObjCImplementationResults(SemaRef.getLangOpts(), Results, true);\n    AddStorageSpecifiers(CCC, SemaRef.getLangOpts(), Results);\n    AddFunctionSpecifiers(CCC, SemaRef.getLangOpts(), Results);\n    break;\n\n  case Sema::PCC_ObjCInstanceVariableList:\n    AddObjCVisibilityResults(SemaRef.getLangOpts(), Results, true);\n    break;\n\n  case Sema::PCC_RecoveryInFunction:\n  case Sema::PCC_Statement: {\n    if (SemaRef.getLangOpts().CPlusPlus11)\n      AddUsingAliasResult(Builder, Results);\n\n    AddTypedefResult(Results);\n\n    if (SemaRef.getLangOpts().CPlusPlus && Results.includeCodePatterns() &&\n        SemaRef.getLangOpts().CXXExceptions) {\n      Builder.AddTypedTextChunk(\"try\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddPlaceholderChunk(\"statements\");\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddTextChunk(\"catch\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"declaration\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddPlaceholderChunk(\"statements\");\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n      Results.AddResult(Result(Builder.TakeString()));\n    }\n    if (SemaRef.getLangOpts().ObjC)\n      AddObjCStatementResults(Results, true);\n\n    if (Results.includeCodePatterns()) {\n      // if (condition) { statements }\n      Builder.AddTypedTextChunk(\"if\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      if (SemaRef.getLangOpts().CPlusPlus)\n        Builder.AddPlaceholderChunk(\"condition\");\n      else\n        Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddPlaceholderChunk(\"statements\");\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // switch (condition) { }\n      Builder.AddTypedTextChunk(\"switch\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      if (SemaRef.getLangOpts().CPlusPlus)\n        Builder.AddPlaceholderChunk(\"condition\");\n      else\n        Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddPlaceholderChunk(\"cases\");\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n      Results.AddResult(Result(Builder.TakeString()));\n    }\n\n    // Switch-specific statements.\n    if (SemaRef.getCurFunction() &&\n        !SemaRef.getCurFunction()->SwitchStack.empty()) {\n      // case expression:\n      Builder.AddTypedTextChunk(\"case\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_Colon);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // default:\n      Builder.AddTypedTextChunk(\"default\");\n      Builder.AddChunk(CodeCompletionString::CK_Colon);\n      Results.AddResult(Result(Builder.TakeString()));\n    }\n\n    if (Results.includeCodePatterns()) {\n      /// while (condition) { statements }\n      Builder.AddTypedTextChunk(\"while\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      if (SemaRef.getLangOpts().CPlusPlus)\n        Builder.AddPlaceholderChunk(\"condition\");\n      else\n        Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddPlaceholderChunk(\"statements\");\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // do { statements } while ( expression );\n      Builder.AddTypedTextChunk(\"do\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddPlaceholderChunk(\"statements\");\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n      Builder.AddTextChunk(\"while\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // for ( for-init-statement ; condition ; expression ) { statements }\n      Builder.AddTypedTextChunk(\"for\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      if (SemaRef.getLangOpts().CPlusPlus || SemaRef.getLangOpts().C99)\n        Builder.AddPlaceholderChunk(\"init-statement\");\n      else\n        Builder.AddPlaceholderChunk(\"init-expression\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"condition\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"inc-expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddPlaceholderChunk(\"statements\");\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      if (SemaRef.getLangOpts().CPlusPlus11 || SemaRef.getLangOpts().ObjC) {\n        // for ( range_declaration (:|in) range_expression ) { statements }\n        Builder.AddTypedTextChunk(\"for\");\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddPlaceholderChunk(\"range-declaration\");\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        if (SemaRef.getLangOpts().ObjC)\n          Builder.AddTextChunk(\"in\");\n        else\n          Builder.AddChunk(CodeCompletionString::CK_Colon);\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddPlaceholderChunk(\"range-expression\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n        Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n        Builder.AddPlaceholderChunk(\"statements\");\n        Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n        Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n    }\n\n    if (S->getContinueParent()) {\n      // continue ;\n      Builder.AddTypedTextChunk(\"continue\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Results.AddResult(Result(Builder.TakeString()));\n    }\n\n    if (S->getBreakParent()) {\n      // break ;\n      Builder.AddTypedTextChunk(\"break\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Results.AddResult(Result(Builder.TakeString()));\n    }\n\n    // \"return expression ;\" or \"return ;\", depending on the return type.\n    QualType ReturnType;\n    if (const auto *Function = dyn_cast<FunctionDecl>(SemaRef.CurContext))\n      ReturnType = Function->getReturnType();\n    else if (const auto *Method = dyn_cast<ObjCMethodDecl>(SemaRef.CurContext))\n      ReturnType = Method->getReturnType();\n    else if (SemaRef.getCurBlock() &&\n             !SemaRef.getCurBlock()->ReturnType.isNull())\n      ReturnType = SemaRef.getCurBlock()->ReturnType;;\n    if (ReturnType.isNull() || ReturnType->isVoidType()) {\n      Builder.AddTypedTextChunk(\"return\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Results.AddResult(Result(Builder.TakeString()));\n    } else {\n      assert(!ReturnType.isNull());\n      // \"return expression ;\"\n      Builder.AddTypedTextChunk(\"return\");\n      Builder.AddChunk(clang::CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      Results.AddResult(Result(Builder.TakeString()));\n      // When boolean, also add 'return true;' and 'return false;'.\n      if (ReturnType->isBooleanType()) {\n        Builder.AddTypedTextChunk(\"return true\");\n        Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n        Results.AddResult(Result(Builder.TakeString()));\n\n        Builder.AddTypedTextChunk(\"return false\");\n        Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n      // For pointers, suggest 'return nullptr' in C++.\n      if (SemaRef.getLangOpts().CPlusPlus11 &&\n          (ReturnType->isPointerType() || ReturnType->isMemberPointerType())) {\n        Builder.AddTypedTextChunk(\"return nullptr\");\n        Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n    }\n\n    // goto identifier ;\n    Builder.AddTypedTextChunk(\"goto\");\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"label\");\n    Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n    Results.AddResult(Result(Builder.TakeString()));\n\n    // Using directives\n    Builder.AddTypedTextChunk(\"using namespace\");\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"identifier\");\n    Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n    Results.AddResult(Result(Builder.TakeString()));\n\n    AddStaticAssertResult(Builder, Results, SemaRef.getLangOpts());\n  }\n    LLVM_FALLTHROUGH;\n\n  // Fall through (for statement expressions).\n  case Sema::PCC_ForInit:\n  case Sema::PCC_Condition:\n    AddStorageSpecifiers(CCC, SemaRef.getLangOpts(), Results);\n    // Fall through: conditions and statements can have expressions.\n    LLVM_FALLTHROUGH;\n\n  case Sema::PCC_ParenthesizedExpression:\n    if (SemaRef.getLangOpts().ObjCAutoRefCount &&\n        CCC == Sema::PCC_ParenthesizedExpression) {\n      // (__bridge <type>)<expression>\n      Builder.AddTypedTextChunk(\"__bridge\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"type\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // (__bridge_transfer <Objective-C type>)<expression>\n      Builder.AddTypedTextChunk(\"__bridge_transfer\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"Objective-C type\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // (__bridge_retained <CF type>)<expression>\n      Builder.AddTypedTextChunk(\"__bridge_retained\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"CF type\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Results.AddResult(Result(Builder.TakeString()));\n    }\n    // Fall through\n    LLVM_FALLTHROUGH;\n\n  case Sema::PCC_Expression: {\n    if (SemaRef.getLangOpts().CPlusPlus) {\n      // 'this', if we're in a non-static member function.\n      addThisCompletion(SemaRef, Results);\n\n      // true\n      Builder.AddResultTypeChunk(\"bool\");\n      Builder.AddTypedTextChunk(\"true\");\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // false\n      Builder.AddResultTypeChunk(\"bool\");\n      Builder.AddTypedTextChunk(\"false\");\n      Results.AddResult(Result(Builder.TakeString()));\n\n      if (SemaRef.getLangOpts().RTTI) {\n        // dynamic_cast < type-id > ( expression )\n        Builder.AddTypedTextChunk(\"dynamic_cast\");\n        Builder.AddChunk(CodeCompletionString::CK_LeftAngle);\n        Builder.AddPlaceholderChunk(\"type\");\n        Builder.AddChunk(CodeCompletionString::CK_RightAngle);\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddPlaceholderChunk(\"expression\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n\n      // static_cast < type-id > ( expression )\n      Builder.AddTypedTextChunk(\"static_cast\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftAngle);\n      Builder.AddPlaceholderChunk(\"type\");\n      Builder.AddChunk(CodeCompletionString::CK_RightAngle);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // reinterpret_cast < type-id > ( expression )\n      Builder.AddTypedTextChunk(\"reinterpret_cast\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftAngle);\n      Builder.AddPlaceholderChunk(\"type\");\n      Builder.AddChunk(CodeCompletionString::CK_RightAngle);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // const_cast < type-id > ( expression )\n      Builder.AddTypedTextChunk(\"const_cast\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftAngle);\n      Builder.AddPlaceholderChunk(\"type\");\n      Builder.AddChunk(CodeCompletionString::CK_RightAngle);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      if (SemaRef.getLangOpts().RTTI) {\n        // typeid ( expression-or-type )\n        Builder.AddResultTypeChunk(\"std::type_info\");\n        Builder.AddTypedTextChunk(\"typeid\");\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddPlaceholderChunk(\"expression-or-type\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n\n      // new T ( ... )\n      Builder.AddTypedTextChunk(\"new\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"type\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"expressions\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // new T [ ] ( ... )\n      Builder.AddTypedTextChunk(\"new\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"type\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftBracket);\n      Builder.AddPlaceholderChunk(\"size\");\n      Builder.AddChunk(CodeCompletionString::CK_RightBracket);\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"expressions\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // delete expression\n      Builder.AddResultTypeChunk(\"void\");\n      Builder.AddTypedTextChunk(\"delete\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Results.AddResult(Result(Builder.TakeString()));\n\n      // delete [] expression\n      Builder.AddResultTypeChunk(\"void\");\n      Builder.AddTypedTextChunk(\"delete\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBracket);\n      Builder.AddChunk(CodeCompletionString::CK_RightBracket);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"expression\");\n      Results.AddResult(Result(Builder.TakeString()));\n\n      if (SemaRef.getLangOpts().CXXExceptions) {\n        // throw expression\n        Builder.AddResultTypeChunk(\"void\");\n        Builder.AddTypedTextChunk(\"throw\");\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddPlaceholderChunk(\"expression\");\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n\n      // FIXME: Rethrow?\n\n      if (SemaRef.getLangOpts().CPlusPlus11) {\n        // nullptr\n        Builder.AddResultTypeChunk(\"std::nullptr_t\");\n        Builder.AddTypedTextChunk(\"nullptr\");\n        Results.AddResult(Result(Builder.TakeString()));\n\n        // alignof\n        Builder.AddResultTypeChunk(\"size_t\");\n        Builder.AddTypedTextChunk(\"alignof\");\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddPlaceholderChunk(\"type\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n        Results.AddResult(Result(Builder.TakeString()));\n\n        // noexcept\n        Builder.AddResultTypeChunk(\"bool\");\n        Builder.AddTypedTextChunk(\"noexcept\");\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddPlaceholderChunk(\"expression\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n        Results.AddResult(Result(Builder.TakeString()));\n\n        // sizeof... expression\n        Builder.AddResultTypeChunk(\"size_t\");\n        Builder.AddTypedTextChunk(\"sizeof...\");\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddPlaceholderChunk(\"parameter-pack\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n        Results.AddResult(Result(Builder.TakeString()));\n      }\n    }\n\n    if (SemaRef.getLangOpts().ObjC) {\n      // Add \"super\", if we're in an Objective-C class with a superclass.\n      if (ObjCMethodDecl *Method = SemaRef.getCurMethodDecl()) {\n        // The interface can be NULL.\n        if (ObjCInterfaceDecl *ID = Method->getClassInterface())\n          if (ID->getSuperClass()) {\n            std::string SuperType;\n            SuperType = ID->getSuperClass()->getNameAsString();\n            if (Method->isInstanceMethod())\n              SuperType += \" *\";\n\n            Builder.AddResultTypeChunk(Allocator.CopyString(SuperType));\n            Builder.AddTypedTextChunk(\"super\");\n            Results.AddResult(Result(Builder.TakeString()));\n          }\n      }\n\n      AddObjCExpressionResults(Results, true);\n    }\n\n    if (SemaRef.getLangOpts().C11) {\n      // _Alignof\n      Builder.AddResultTypeChunk(\"size_t\");\n      if (SemaRef.PP.isMacroDefined(\"alignof\"))\n        Builder.AddTypedTextChunk(\"alignof\");\n      else\n        Builder.AddTypedTextChunk(\"_Alignof\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"type\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Results.AddResult(Result(Builder.TakeString()));\n    }\n\n    // sizeof expression\n    Builder.AddResultTypeChunk(\"size_t\");\n    Builder.AddTypedTextChunk(\"sizeof\");\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    Builder.AddPlaceholderChunk(\"expression-or-type\");\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    Results.AddResult(Result(Builder.TakeString()));\n    break;\n  }\n\n  case Sema::PCC_Type:\n  case Sema::PCC_LocalDeclarationSpecifiers:\n    break;\n  }\n\n  if (WantTypesInContext(CCC, SemaRef.getLangOpts()))\n    AddTypeSpecifierResults(SemaRef.getLangOpts(), Results);\n\n  if (SemaRef.getLangOpts().CPlusPlus && CCC != Sema::PCC_Type)\n    Results.AddResult(Result(\"operator\"));\n}\n\n/// If the given declaration has an associated type, add it as a result\n/// type chunk.\nstatic void AddResultTypeChunk(ASTContext &Context,\n                               const PrintingPolicy &Policy,\n                               const NamedDecl *ND, QualType BaseType,\n                               CodeCompletionBuilder &Result) {\n  if (!ND)\n    return;\n\n  // Skip constructors and conversion functions, which have their return types\n  // built into their names.\n  if (isConstructor(ND) || isa<CXXConversionDecl>(ND))\n    return;\n\n  // Determine the type of the declaration (if it has a type).\n  QualType T;\n  if (const FunctionDecl *Function = ND->getAsFunction())\n    T = Function->getReturnType();\n  else if (const auto *Method = dyn_cast<ObjCMethodDecl>(ND)) {\n    if (!BaseType.isNull())\n      T = Method->getSendResultType(BaseType);\n    else\n      T = Method->getReturnType();\n  } else if (const auto *Enumerator = dyn_cast<EnumConstantDecl>(ND)) {\n    T = Context.getTypeDeclType(cast<TypeDecl>(Enumerator->getDeclContext()));\n    T = clang::TypeName::getFullyQualifiedType(T, Context);\n  } else if (isa<UnresolvedUsingValueDecl>(ND)) {\n    /* Do nothing: ignore unresolved using declarations*/\n  } else if (const auto *Ivar = dyn_cast<ObjCIvarDecl>(ND)) {\n    if (!BaseType.isNull())\n      T = Ivar->getUsageType(BaseType);\n    else\n      T = Ivar->getType();\n  } else if (const auto *Value = dyn_cast<ValueDecl>(ND)) {\n    T = Value->getType();\n  } else if (const auto *Property = dyn_cast<ObjCPropertyDecl>(ND)) {\n    if (!BaseType.isNull())\n      T = Property->getUsageType(BaseType);\n    else\n      T = Property->getType();\n  }\n\n  if (T.isNull() || Context.hasSameType(T, Context.DependentTy))\n    return;\n\n  Result.AddResultTypeChunk(\n      GetCompletionTypeString(T, Context, Policy, Result.getAllocator()));\n}\n\nstatic void MaybeAddSentinel(Preprocessor &PP,\n                             const NamedDecl *FunctionOrMethod,\n                             CodeCompletionBuilder &Result) {\n  if (SentinelAttr *Sentinel = FunctionOrMethod->getAttr<SentinelAttr>())\n    if (Sentinel->getSentinel() == 0) {\n      if (PP.getLangOpts().ObjC && PP.isMacroDefined(\"nil\"))\n        Result.AddTextChunk(\", nil\");\n      else if (PP.isMacroDefined(\"NULL\"))\n        Result.AddTextChunk(\", NULL\");\n      else\n        Result.AddTextChunk(\", (void*)0\");\n    }\n}\n\nstatic std::string formatObjCParamQualifiers(unsigned ObjCQuals,\n                                             QualType &Type) {\n  std::string Result;\n  if (ObjCQuals & Decl::OBJC_TQ_In)\n    Result += \"in \";\n  else if (ObjCQuals & Decl::OBJC_TQ_Inout)\n    Result += \"inout \";\n  else if (ObjCQuals & Decl::OBJC_TQ_Out)\n    Result += \"out \";\n  if (ObjCQuals & Decl::OBJC_TQ_Bycopy)\n    Result += \"bycopy \";\n  else if (ObjCQuals & Decl::OBJC_TQ_Byref)\n    Result += \"byref \";\n  if (ObjCQuals & Decl::OBJC_TQ_Oneway)\n    Result += \"oneway \";\n  if (ObjCQuals & Decl::OBJC_TQ_CSNullability) {\n    if (auto nullability = AttributedType::stripOuterNullability(Type)) {\n      switch (*nullability) {\n      case NullabilityKind::NonNull:\n        Result += \"nonnull \";\n        break;\n\n      case NullabilityKind::Nullable:\n        Result += \"nullable \";\n        break;\n\n      case NullabilityKind::Unspecified:\n        Result += \"null_unspecified \";\n        break;\n\n      case NullabilityKind::NullableResult:\n        llvm_unreachable(\"Not supported as a context-sensitive keyword!\");\n        break;\n      }\n    }\n  }\n  return Result;\n}\n\n/// Tries to find the most appropriate type location for an Objective-C\n/// block placeholder.\n///\n/// This function ignores things like typedefs and qualifiers in order to\n/// present the most relevant and accurate block placeholders in code completion\n/// results.\nstatic void findTypeLocationForBlockDecl(const TypeSourceInfo *TSInfo,\n                                         FunctionTypeLoc &Block,\n                                         FunctionProtoTypeLoc &BlockProto,\n                                         bool SuppressBlock = false) {\n  if (!TSInfo)\n    return;\n  TypeLoc TL = TSInfo->getTypeLoc().getUnqualifiedLoc();\n  while (true) {\n    // Look through typedefs.\n    if (!SuppressBlock) {\n      if (TypedefTypeLoc TypedefTL = TL.getAs<TypedefTypeLoc>()) {\n        if (TypeSourceInfo *InnerTSInfo =\n                TypedefTL.getTypedefNameDecl()->getTypeSourceInfo()) {\n          TL = InnerTSInfo->getTypeLoc().getUnqualifiedLoc();\n          continue;\n        }\n      }\n\n      // Look through qualified types\n      if (QualifiedTypeLoc QualifiedTL = TL.getAs<QualifiedTypeLoc>()) {\n        TL = QualifiedTL.getUnqualifiedLoc();\n        continue;\n      }\n\n      if (AttributedTypeLoc AttrTL = TL.getAs<AttributedTypeLoc>()) {\n        TL = AttrTL.getModifiedLoc();\n        continue;\n      }\n    }\n\n    // Try to get the function prototype behind the block pointer type,\n    // then we're done.\n    if (BlockPointerTypeLoc BlockPtr = TL.getAs<BlockPointerTypeLoc>()) {\n      TL = BlockPtr.getPointeeLoc().IgnoreParens();\n      Block = TL.getAs<FunctionTypeLoc>();\n      BlockProto = TL.getAs<FunctionProtoTypeLoc>();\n    }\n    break;\n  }\n}\n\nstatic std::string\nformatBlockPlaceholder(const PrintingPolicy &Policy, const NamedDecl *BlockDecl,\n                       FunctionTypeLoc &Block, FunctionProtoTypeLoc &BlockProto,\n                       bool SuppressBlockName = false,\n                       bool SuppressBlock = false,\n                       Optional<ArrayRef<QualType>> ObjCSubsts = None);\n\nstatic std::string\nFormatFunctionParameter(const PrintingPolicy &Policy, const ParmVarDecl *Param,\n                        bool SuppressName = false, bool SuppressBlock = false,\n                        Optional<ArrayRef<QualType>> ObjCSubsts = None) {\n  // Params are unavailable in FunctionTypeLoc if the FunctionType is invalid.\n  // It would be better to pass in the param Type, which is usually avaliable.\n  // But this case is rare, so just pretend we fell back to int as elsewhere.\n  if (!Param)\n    return \"int\";\n  bool ObjCMethodParam = isa<ObjCMethodDecl>(Param->getDeclContext());\n  if (Param->getType()->isDependentType() ||\n      !Param->getType()->isBlockPointerType()) {\n    // The argument for a dependent or non-block parameter is a placeholder\n    // containing that parameter's type.\n    std::string Result;\n\n    if (Param->getIdentifier() && !ObjCMethodParam && !SuppressName)\n      Result = std::string(Param->getIdentifier()->getName());\n\n    QualType Type = Param->getType();\n    if (ObjCSubsts)\n      Type = Type.substObjCTypeArgs(Param->getASTContext(), *ObjCSubsts,\n                                    ObjCSubstitutionContext::Parameter);\n    if (ObjCMethodParam) {\n      Result =\n          \"(\" + formatObjCParamQualifiers(Param->getObjCDeclQualifier(), Type);\n      Result += Type.getAsString(Policy) + \")\";\n      if (Param->getIdentifier() && !SuppressName)\n        Result += Param->getIdentifier()->getName();\n    } else {\n      Type.getAsStringInternal(Result, Policy);\n    }\n    return Result;\n  }\n\n  // The argument for a block pointer parameter is a block literal with\n  // the appropriate type.\n  FunctionTypeLoc Block;\n  FunctionProtoTypeLoc BlockProto;\n  findTypeLocationForBlockDecl(Param->getTypeSourceInfo(), Block, BlockProto,\n                               SuppressBlock);\n  // Try to retrieve the block type information from the property if this is a\n  // parameter in a setter.\n  if (!Block && ObjCMethodParam &&\n      cast<ObjCMethodDecl>(Param->getDeclContext())->isPropertyAccessor()) {\n    if (const auto *PD = cast<ObjCMethodDecl>(Param->getDeclContext())\n                             ->findPropertyDecl(/*CheckOverrides=*/false))\n      findTypeLocationForBlockDecl(PD->getTypeSourceInfo(), Block, BlockProto,\n                                   SuppressBlock);\n  }\n\n  if (!Block) {\n    // We were unable to find a FunctionProtoTypeLoc with parameter names\n    // for the block; just use the parameter type as a placeholder.\n    std::string Result;\n    if (!ObjCMethodParam && Param->getIdentifier())\n      Result = std::string(Param->getIdentifier()->getName());\n\n    QualType Type = Param->getType().getUnqualifiedType();\n\n    if (ObjCMethodParam) {\n      Result = Type.getAsString(Policy);\n      std::string Quals =\n          formatObjCParamQualifiers(Param->getObjCDeclQualifier(), Type);\n      if (!Quals.empty())\n        Result = \"(\" + Quals + \" \" + Result + \")\";\n      if (Result.back() != ')')\n        Result += \" \";\n      if (Param->getIdentifier())\n        Result += Param->getIdentifier()->getName();\n    } else {\n      Type.getAsStringInternal(Result, Policy);\n    }\n\n    return Result;\n  }\n\n  // We have the function prototype behind the block pointer type, as it was\n  // written in the source.\n  return formatBlockPlaceholder(Policy, Param, Block, BlockProto,\n                                /*SuppressBlockName=*/false, SuppressBlock,\n                                ObjCSubsts);\n}\n\n/// Returns a placeholder string that corresponds to an Objective-C block\n/// declaration.\n///\n/// \\param BlockDecl A declaration with an Objective-C block type.\n///\n/// \\param Block The most relevant type location for that block type.\n///\n/// \\param SuppressBlockName Determines whether or not the name of the block\n/// declaration is included in the resulting string.\nstatic std::string\nformatBlockPlaceholder(const PrintingPolicy &Policy, const NamedDecl *BlockDecl,\n                       FunctionTypeLoc &Block, FunctionProtoTypeLoc &BlockProto,\n                       bool SuppressBlockName, bool SuppressBlock,\n                       Optional<ArrayRef<QualType>> ObjCSubsts) {\n  std::string Result;\n  QualType ResultType = Block.getTypePtr()->getReturnType();\n  if (ObjCSubsts)\n    ResultType =\n        ResultType.substObjCTypeArgs(BlockDecl->getASTContext(), *ObjCSubsts,\n                                     ObjCSubstitutionContext::Result);\n  if (!ResultType->isVoidType() || SuppressBlock)\n    ResultType.getAsStringInternal(Result, Policy);\n\n  // Format the parameter list.\n  std::string Params;\n  if (!BlockProto || Block.getNumParams() == 0) {\n    if (BlockProto && BlockProto.getTypePtr()->isVariadic())\n      Params = \"(...)\";\n    else\n      Params = \"(void)\";\n  } else {\n    Params += \"(\";\n    for (unsigned I = 0, N = Block.getNumParams(); I != N; ++I) {\n      if (I)\n        Params += \", \";\n      Params += FormatFunctionParameter(Policy, Block.getParam(I),\n                                        /*SuppressName=*/false,\n                                        /*SuppressBlock=*/true, ObjCSubsts);\n\n      if (I == N - 1 && BlockProto.getTypePtr()->isVariadic())\n        Params += \", ...\";\n    }\n    Params += \")\";\n  }\n\n  if (SuppressBlock) {\n    // Format as a parameter.\n    Result = Result + \" (^\";\n    if (!SuppressBlockName && BlockDecl->getIdentifier())\n      Result += BlockDecl->getIdentifier()->getName();\n    Result += \")\";\n    Result += Params;\n  } else {\n    // Format as a block literal argument.\n    Result = '^' + Result;\n    Result += Params;\n\n    if (!SuppressBlockName && BlockDecl->getIdentifier())\n      Result += BlockDecl->getIdentifier()->getName();\n  }\n\n  return Result;\n}\n\nstatic std::string GetDefaultValueString(const ParmVarDecl *Param,\n                                         const SourceManager &SM,\n                                         const LangOptions &LangOpts) {\n  const SourceRange SrcRange = Param->getDefaultArgRange();\n  CharSourceRange CharSrcRange = CharSourceRange::getTokenRange(SrcRange);\n  bool Invalid = CharSrcRange.isInvalid();\n  if (Invalid)\n    return \"\";\n  StringRef srcText =\n      Lexer::getSourceText(CharSrcRange, SM, LangOpts, &Invalid);\n  if (Invalid)\n    return \"\";\n\n  if (srcText.empty() || srcText == \"=\") {\n    // Lexer can't determine the value.\n    // This happens if the code is incorrect (for example class is forward\n    // declared).\n    return \"\";\n  }\n  std::string DefValue(srcText.str());\n  // FIXME: remove this check if the Lexer::getSourceText value is fixed and\n  // this value always has (or always does not have) '=' in front of it\n  if (DefValue.at(0) != '=') {\n    // If we don't have '=' in front of value.\n    // Lexer returns built-in types values without '=' and user-defined types\n    // values with it.\n    return \" = \" + DefValue;\n  }\n  return \" \" + DefValue;\n}\n\n/// Add function parameter chunks to the given code completion string.\nstatic void AddFunctionParameterChunks(Preprocessor &PP,\n                                       const PrintingPolicy &Policy,\n                                       const FunctionDecl *Function,\n                                       CodeCompletionBuilder &Result,\n                                       unsigned Start = 0,\n                                       bool InOptional = false) {\n  bool FirstParameter = true;\n\n  for (unsigned P = Start, N = Function->getNumParams(); P != N; ++P) {\n    const ParmVarDecl *Param = Function->getParamDecl(P);\n\n    if (Param->hasDefaultArg() && !InOptional) {\n      // When we see an optional default argument, put that argument and\n      // the remaining default arguments into a new, optional string.\n      CodeCompletionBuilder Opt(Result.getAllocator(),\n                                Result.getCodeCompletionTUInfo());\n      if (!FirstParameter)\n        Opt.AddChunk(CodeCompletionString::CK_Comma);\n      AddFunctionParameterChunks(PP, Policy, Function, Opt, P, true);\n      Result.AddOptionalChunk(Opt.TakeString());\n      break;\n    }\n\n    if (FirstParameter)\n      FirstParameter = false;\n    else\n      Result.AddChunk(CodeCompletionString::CK_Comma);\n\n    InOptional = false;\n\n    // Format the placeholder string.\n    std::string PlaceholderStr = FormatFunctionParameter(Policy, Param);\n    if (Param->hasDefaultArg())\n      PlaceholderStr +=\n          GetDefaultValueString(Param, PP.getSourceManager(), PP.getLangOpts());\n\n    if (Function->isVariadic() && P == N - 1)\n      PlaceholderStr += \", ...\";\n\n    // Add the placeholder string.\n    Result.AddPlaceholderChunk(\n        Result.getAllocator().CopyString(PlaceholderStr));\n  }\n\n  if (const auto *Proto = Function->getType()->getAs<FunctionProtoType>())\n    if (Proto->isVariadic()) {\n      if (Proto->getNumParams() == 0)\n        Result.AddPlaceholderChunk(\"...\");\n\n      MaybeAddSentinel(PP, Function, Result);\n    }\n}\n\n/// Add template parameter chunks to the given code completion string.\nstatic void AddTemplateParameterChunks(\n    ASTContext &Context, const PrintingPolicy &Policy,\n    const TemplateDecl *Template, CodeCompletionBuilder &Result,\n    unsigned MaxParameters = 0, unsigned Start = 0, bool InDefaultArg = false) {\n  bool FirstParameter = true;\n\n  // Prefer to take the template parameter names from the first declaration of\n  // the template.\n  Template = cast<TemplateDecl>(Template->getCanonicalDecl());\n\n  TemplateParameterList *Params = Template->getTemplateParameters();\n  TemplateParameterList::iterator PEnd = Params->end();\n  if (MaxParameters)\n    PEnd = Params->begin() + MaxParameters;\n  for (TemplateParameterList::iterator P = Params->begin() + Start; P != PEnd;\n       ++P) {\n    bool HasDefaultArg = false;\n    std::string PlaceholderStr;\n    if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(*P)) {\n      if (TTP->wasDeclaredWithTypename())\n        PlaceholderStr = \"typename\";\n      else if (const auto *TC = TTP->getTypeConstraint()) {\n        llvm::raw_string_ostream OS(PlaceholderStr);\n        TC->print(OS, Policy);\n        OS.flush();\n      } else\n        PlaceholderStr = \"class\";\n\n      if (TTP->getIdentifier()) {\n        PlaceholderStr += ' ';\n        PlaceholderStr += TTP->getIdentifier()->getName();\n      }\n\n      HasDefaultArg = TTP->hasDefaultArgument();\n    } else if (NonTypeTemplateParmDecl *NTTP =\n                   dyn_cast<NonTypeTemplateParmDecl>(*P)) {\n      if (NTTP->getIdentifier())\n        PlaceholderStr = std::string(NTTP->getIdentifier()->getName());\n      NTTP->getType().getAsStringInternal(PlaceholderStr, Policy);\n      HasDefaultArg = NTTP->hasDefaultArgument();\n    } else {\n      assert(isa<TemplateTemplateParmDecl>(*P));\n      TemplateTemplateParmDecl *TTP = cast<TemplateTemplateParmDecl>(*P);\n\n      // Since putting the template argument list into the placeholder would\n      // be very, very long, we just use an abbreviation.\n      PlaceholderStr = \"template<...> class\";\n      if (TTP->getIdentifier()) {\n        PlaceholderStr += ' ';\n        PlaceholderStr += TTP->getIdentifier()->getName();\n      }\n\n      HasDefaultArg = TTP->hasDefaultArgument();\n    }\n\n    if (HasDefaultArg && !InDefaultArg) {\n      // When we see an optional default argument, put that argument and\n      // the remaining default arguments into a new, optional string.\n      CodeCompletionBuilder Opt(Result.getAllocator(),\n                                Result.getCodeCompletionTUInfo());\n      if (!FirstParameter)\n        Opt.AddChunk(CodeCompletionString::CK_Comma);\n      AddTemplateParameterChunks(Context, Policy, Template, Opt, MaxParameters,\n                                 P - Params->begin(), true);\n      Result.AddOptionalChunk(Opt.TakeString());\n      break;\n    }\n\n    InDefaultArg = false;\n\n    if (FirstParameter)\n      FirstParameter = false;\n    else\n      Result.AddChunk(CodeCompletionString::CK_Comma);\n\n    // Add the placeholder string.\n    Result.AddPlaceholderChunk(\n        Result.getAllocator().CopyString(PlaceholderStr));\n  }\n}\n\n/// Add a qualifier to the given code-completion string, if the\n/// provided nested-name-specifier is non-NULL.\nstatic void AddQualifierToCompletionString(CodeCompletionBuilder &Result,\n                                           NestedNameSpecifier *Qualifier,\n                                           bool QualifierIsInformative,\n                                           ASTContext &Context,\n                                           const PrintingPolicy &Policy) {\n  if (!Qualifier)\n    return;\n\n  std::string PrintedNNS;\n  {\n    llvm::raw_string_ostream OS(PrintedNNS);\n    Qualifier->print(OS, Policy);\n  }\n  if (QualifierIsInformative)\n    Result.AddInformativeChunk(Result.getAllocator().CopyString(PrintedNNS));\n  else\n    Result.AddTextChunk(Result.getAllocator().CopyString(PrintedNNS));\n}\n\nstatic void\nAddFunctionTypeQualsToCompletionString(CodeCompletionBuilder &Result,\n                                       const FunctionDecl *Function) {\n  const auto *Proto = Function->getType()->getAs<FunctionProtoType>();\n  if (!Proto || !Proto->getMethodQuals())\n    return;\n\n  // FIXME: Add ref-qualifier!\n\n  // Handle single qualifiers without copying\n  if (Proto->getMethodQuals().hasOnlyConst()) {\n    Result.AddInformativeChunk(\" const\");\n    return;\n  }\n\n  if (Proto->getMethodQuals().hasOnlyVolatile()) {\n    Result.AddInformativeChunk(\" volatile\");\n    return;\n  }\n\n  if (Proto->getMethodQuals().hasOnlyRestrict()) {\n    Result.AddInformativeChunk(\" restrict\");\n    return;\n  }\n\n  // Handle multiple qualifiers.\n  std::string QualsStr;\n  if (Proto->isConst())\n    QualsStr += \" const\";\n  if (Proto->isVolatile())\n    QualsStr += \" volatile\";\n  if (Proto->isRestrict())\n    QualsStr += \" restrict\";\n  Result.AddInformativeChunk(Result.getAllocator().CopyString(QualsStr));\n}\n\n/// Add the name of the given declaration\nstatic void AddTypedNameChunk(ASTContext &Context, const PrintingPolicy &Policy,\n                              const NamedDecl *ND,\n                              CodeCompletionBuilder &Result) {\n  DeclarationName Name = ND->getDeclName();\n  if (!Name)\n    return;\n\n  switch (Name.getNameKind()) {\n  case DeclarationName::CXXOperatorName: {\n    const char *OperatorName = nullptr;\n    switch (Name.getCXXOverloadedOperator()) {\n    case OO_None:\n    case OO_Conditional:\n    case NUM_OVERLOADED_OPERATORS:\n      OperatorName = \"operator\";\n      break;\n\n#define OVERLOADED_OPERATOR(Name, Spelling, Token, Unary, Binary, MemberOnly)  \\\n  case OO_##Name:                                                              \\\n    OperatorName = \"operator\" Spelling;                                        \\\n    break;\n#define OVERLOADED_OPERATOR_MULTI(Name, Spelling, Unary, Binary, MemberOnly)\n#include \"clang/Basic/OperatorKinds.def\"\n\n    case OO_New:\n      OperatorName = \"operator new\";\n      break;\n    case OO_Delete:\n      OperatorName = \"operator delete\";\n      break;\n    case OO_Array_New:\n      OperatorName = \"operator new[]\";\n      break;\n    case OO_Array_Delete:\n      OperatorName = \"operator delete[]\";\n      break;\n    case OO_Call:\n      OperatorName = \"operator()\";\n      break;\n    case OO_Subscript:\n      OperatorName = \"operator[]\";\n      break;\n    }\n    Result.AddTypedTextChunk(OperatorName);\n    break;\n  }\n\n  case DeclarationName::Identifier:\n  case DeclarationName::CXXConversionFunctionName:\n  case DeclarationName::CXXDestructorName:\n  case DeclarationName::CXXLiteralOperatorName:\n    Result.AddTypedTextChunk(\n        Result.getAllocator().CopyString(ND->getNameAsString()));\n    break;\n\n  case DeclarationName::CXXDeductionGuideName:\n  case DeclarationName::CXXUsingDirective:\n  case DeclarationName::ObjCZeroArgSelector:\n  case DeclarationName::ObjCOneArgSelector:\n  case DeclarationName::ObjCMultiArgSelector:\n    break;\n\n  case DeclarationName::CXXConstructorName: {\n    CXXRecordDecl *Record = nullptr;\n    QualType Ty = Name.getCXXNameType();\n    if (const auto *RecordTy = Ty->getAs<RecordType>())\n      Record = cast<CXXRecordDecl>(RecordTy->getDecl());\n    else if (const auto *InjectedTy = Ty->getAs<InjectedClassNameType>())\n      Record = InjectedTy->getDecl();\n    else {\n      Result.AddTypedTextChunk(\n          Result.getAllocator().CopyString(ND->getNameAsString()));\n      break;\n    }\n\n    Result.AddTypedTextChunk(\n        Result.getAllocator().CopyString(Record->getNameAsString()));\n    if (ClassTemplateDecl *Template = Record->getDescribedClassTemplate()) {\n      Result.AddChunk(CodeCompletionString::CK_LeftAngle);\n      AddTemplateParameterChunks(Context, Policy, Template, Result);\n      Result.AddChunk(CodeCompletionString::CK_RightAngle);\n    }\n    break;\n  }\n  }\n}\n\nCodeCompletionString *CodeCompletionResult::CreateCodeCompletionString(\n    Sema &S, const CodeCompletionContext &CCContext,\n    CodeCompletionAllocator &Allocator, CodeCompletionTUInfo &CCTUInfo,\n    bool IncludeBriefComments) {\n  return CreateCodeCompletionString(S.Context, S.PP, CCContext, Allocator,\n                                    CCTUInfo, IncludeBriefComments);\n}\n\nCodeCompletionString *CodeCompletionResult::CreateCodeCompletionStringForMacro(\n    Preprocessor &PP, CodeCompletionAllocator &Allocator,\n    CodeCompletionTUInfo &CCTUInfo) {\n  assert(Kind == RK_Macro);\n  CodeCompletionBuilder Result(Allocator, CCTUInfo, Priority, Availability);\n  const MacroInfo *MI = PP.getMacroInfo(Macro);\n  Result.AddTypedTextChunk(Result.getAllocator().CopyString(Macro->getName()));\n\n  if (!MI || !MI->isFunctionLike())\n    return Result.TakeString();\n\n  // Format a function-like macro with placeholders for the arguments.\n  Result.AddChunk(CodeCompletionString::CK_LeftParen);\n  MacroInfo::param_iterator A = MI->param_begin(), AEnd = MI->param_end();\n\n  // C99 variadic macros add __VA_ARGS__ at the end. Skip it.\n  if (MI->isC99Varargs()) {\n    --AEnd;\n\n    if (A == AEnd) {\n      Result.AddPlaceholderChunk(\"...\");\n    }\n  }\n\n  for (MacroInfo::param_iterator A = MI->param_begin(); A != AEnd; ++A) {\n    if (A != MI->param_begin())\n      Result.AddChunk(CodeCompletionString::CK_Comma);\n\n    if (MI->isVariadic() && (A + 1) == AEnd) {\n      SmallString<32> Arg = (*A)->getName();\n      if (MI->isC99Varargs())\n        Arg += \", ...\";\n      else\n        Arg += \"...\";\n      Result.AddPlaceholderChunk(Result.getAllocator().CopyString(Arg));\n      break;\n    }\n\n    // Non-variadic macros are simple.\n    Result.AddPlaceholderChunk(\n        Result.getAllocator().CopyString((*A)->getName()));\n  }\n  Result.AddChunk(CodeCompletionString::CK_RightParen);\n  return Result.TakeString();\n}\n\n/// If possible, create a new code completion string for the given\n/// result.\n///\n/// \\returns Either a new, heap-allocated code completion string describing\n/// how to use this result, or NULL to indicate that the string or name of the\n/// result is all that is needed.\nCodeCompletionString *CodeCompletionResult::CreateCodeCompletionString(\n    ASTContext &Ctx, Preprocessor &PP, const CodeCompletionContext &CCContext,\n    CodeCompletionAllocator &Allocator, CodeCompletionTUInfo &CCTUInfo,\n    bool IncludeBriefComments) {\n  if (Kind == RK_Macro)\n    return CreateCodeCompletionStringForMacro(PP, Allocator, CCTUInfo);\n\n  CodeCompletionBuilder Result(Allocator, CCTUInfo, Priority, Availability);\n\n  PrintingPolicy Policy = getCompletionPrintingPolicy(Ctx, PP);\n  if (Kind == RK_Pattern) {\n    Pattern->Priority = Priority;\n    Pattern->Availability = Availability;\n\n    if (Declaration) {\n      Result.addParentContext(Declaration->getDeclContext());\n      Pattern->ParentName = Result.getParentName();\n      if (const RawComment *RC =\n              getPatternCompletionComment(Ctx, Declaration)) {\n        Result.addBriefComment(RC->getBriefText(Ctx));\n        Pattern->BriefComment = Result.getBriefComment();\n      }\n    }\n\n    return Pattern;\n  }\n\n  if (Kind == RK_Keyword) {\n    Result.AddTypedTextChunk(Keyword);\n    return Result.TakeString();\n  }\n  assert(Kind == RK_Declaration && \"Missed a result kind?\");\n  return createCodeCompletionStringForDecl(\n      PP, Ctx, Result, IncludeBriefComments, CCContext, Policy);\n}\n\nstatic void printOverrideString(const CodeCompletionString &CCS,\n                                std::string &BeforeName,\n                                std::string &NameAndSignature) {\n  bool SeenTypedChunk = false;\n  for (auto &Chunk : CCS) {\n    if (Chunk.Kind == CodeCompletionString::CK_Optional) {\n      assert(SeenTypedChunk && \"optional parameter before name\");\n      // Note that we put all chunks inside into NameAndSignature.\n      printOverrideString(*Chunk.Optional, NameAndSignature, NameAndSignature);\n      continue;\n    }\n    SeenTypedChunk |= Chunk.Kind == CodeCompletionString::CK_TypedText;\n    if (SeenTypedChunk)\n      NameAndSignature += Chunk.Text;\n    else\n      BeforeName += Chunk.Text;\n  }\n}\n\nCodeCompletionString *\nCodeCompletionResult::createCodeCompletionStringForOverride(\n    Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n    bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n    PrintingPolicy &Policy) {\n  auto *CCS = createCodeCompletionStringForDecl(PP, Ctx, Result,\n                                                /*IncludeBriefComments=*/false,\n                                                CCContext, Policy);\n  std::string BeforeName;\n  std::string NameAndSignature;\n  // For overrides all chunks go into the result, none are informative.\n  printOverrideString(*CCS, BeforeName, NameAndSignature);\n  NameAndSignature += \" override\";\n\n  Result.AddTextChunk(Result.getAllocator().CopyString(BeforeName));\n  Result.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Result.AddTypedTextChunk(Result.getAllocator().CopyString(NameAndSignature));\n  return Result.TakeString();\n}\n\n// FIXME: Right now this works well with lambdas. Add support for other functor\n// types like std::function.\nstatic const NamedDecl *extractFunctorCallOperator(const NamedDecl *ND) {\n  const auto *VD = dyn_cast<VarDecl>(ND);\n  if (!VD)\n    return nullptr;\n  const auto *RecordDecl = VD->getType()->getAsCXXRecordDecl();\n  if (!RecordDecl || !RecordDecl->isLambda())\n    return nullptr;\n  return RecordDecl->getLambdaCallOperator();\n}\n\nCodeCompletionString *CodeCompletionResult::createCodeCompletionStringForDecl(\n    Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n    bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n    PrintingPolicy &Policy) {\n  const NamedDecl *ND = Declaration;\n  Result.addParentContext(ND->getDeclContext());\n\n  if (IncludeBriefComments) {\n    // Add documentation comment, if it exists.\n    if (const RawComment *RC = getCompletionComment(Ctx, Declaration)) {\n      Result.addBriefComment(RC->getBriefText(Ctx));\n    }\n  }\n\n  if (StartsNestedNameSpecifier) {\n    Result.AddTypedTextChunk(\n        Result.getAllocator().CopyString(ND->getNameAsString()));\n    Result.AddTextChunk(\"::\");\n    return Result.TakeString();\n  }\n\n  for (const auto *I : ND->specific_attrs<AnnotateAttr>())\n    Result.AddAnnotation(Result.getAllocator().CopyString(I->getAnnotation()));\n\n  auto AddFunctionTypeAndResult = [&](const FunctionDecl *Function) {\n    AddResultTypeChunk(Ctx, Policy, Function, CCContext.getBaseType(), Result);\n    AddQualifierToCompletionString(Result, Qualifier, QualifierIsInformative,\n                                   Ctx, Policy);\n    AddTypedNameChunk(Ctx, Policy, ND, Result);\n    Result.AddChunk(CodeCompletionString::CK_LeftParen);\n    AddFunctionParameterChunks(PP, Policy, Function, Result);\n    Result.AddChunk(CodeCompletionString::CK_RightParen);\n    AddFunctionTypeQualsToCompletionString(Result, Function);\n  };\n\n  if (const auto *Function = dyn_cast<FunctionDecl>(ND)) {\n    AddFunctionTypeAndResult(Function);\n    return Result.TakeString();\n  }\n\n  if (const auto *CallOperator =\n          dyn_cast_or_null<FunctionDecl>(extractFunctorCallOperator(ND))) {\n    AddFunctionTypeAndResult(CallOperator);\n    return Result.TakeString();\n  }\n\n  AddResultTypeChunk(Ctx, Policy, ND, CCContext.getBaseType(), Result);\n\n  if (const FunctionTemplateDecl *FunTmpl =\n          dyn_cast<FunctionTemplateDecl>(ND)) {\n    AddQualifierToCompletionString(Result, Qualifier, QualifierIsInformative,\n                                   Ctx, Policy);\n    FunctionDecl *Function = FunTmpl->getTemplatedDecl();\n    AddTypedNameChunk(Ctx, Policy, Function, Result);\n\n    // Figure out which template parameters are deduced (or have default\n    // arguments).\n    llvm::SmallBitVector Deduced;\n    Sema::MarkDeducedTemplateParameters(Ctx, FunTmpl, Deduced);\n    unsigned LastDeducibleArgument;\n    for (LastDeducibleArgument = Deduced.size(); LastDeducibleArgument > 0;\n         --LastDeducibleArgument) {\n      if (!Deduced[LastDeducibleArgument - 1]) {\n        // C++0x: Figure out if the template argument has a default. If so,\n        // the user doesn't need to type this argument.\n        // FIXME: We need to abstract template parameters better!\n        bool HasDefaultArg = false;\n        NamedDecl *Param = FunTmpl->getTemplateParameters()->getParam(\n            LastDeducibleArgument - 1);\n        if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(Param))\n          HasDefaultArg = TTP->hasDefaultArgument();\n        else if (NonTypeTemplateParmDecl *NTTP =\n                     dyn_cast<NonTypeTemplateParmDecl>(Param))\n          HasDefaultArg = NTTP->hasDefaultArgument();\n        else {\n          assert(isa<TemplateTemplateParmDecl>(Param));\n          HasDefaultArg =\n              cast<TemplateTemplateParmDecl>(Param)->hasDefaultArgument();\n        }\n\n        if (!HasDefaultArg)\n          break;\n      }\n    }\n\n    if (LastDeducibleArgument) {\n      // Some of the function template arguments cannot be deduced from a\n      // function call, so we introduce an explicit template argument list\n      // containing all of the arguments up to the first deducible argument.\n      Result.AddChunk(CodeCompletionString::CK_LeftAngle);\n      AddTemplateParameterChunks(Ctx, Policy, FunTmpl, Result,\n                                 LastDeducibleArgument);\n      Result.AddChunk(CodeCompletionString::CK_RightAngle);\n    }\n\n    // Add the function parameters\n    Result.AddChunk(CodeCompletionString::CK_LeftParen);\n    AddFunctionParameterChunks(PP, Policy, Function, Result);\n    Result.AddChunk(CodeCompletionString::CK_RightParen);\n    AddFunctionTypeQualsToCompletionString(Result, Function);\n    return Result.TakeString();\n  }\n\n  if (const auto *Template = dyn_cast<TemplateDecl>(ND)) {\n    AddQualifierToCompletionString(Result, Qualifier, QualifierIsInformative,\n                                   Ctx, Policy);\n    Result.AddTypedTextChunk(\n        Result.getAllocator().CopyString(Template->getNameAsString()));\n    Result.AddChunk(CodeCompletionString::CK_LeftAngle);\n    AddTemplateParameterChunks(Ctx, Policy, Template, Result);\n    Result.AddChunk(CodeCompletionString::CK_RightAngle);\n    return Result.TakeString();\n  }\n\n  if (const auto *Method = dyn_cast<ObjCMethodDecl>(ND)) {\n    Selector Sel = Method->getSelector();\n    if (Sel.isUnarySelector()) {\n      Result.AddTypedTextChunk(\n          Result.getAllocator().CopyString(Sel.getNameForSlot(0)));\n      return Result.TakeString();\n    }\n\n    std::string SelName = Sel.getNameForSlot(0).str();\n    SelName += ':';\n    if (StartParameter == 0)\n      Result.AddTypedTextChunk(Result.getAllocator().CopyString(SelName));\n    else {\n      Result.AddInformativeChunk(Result.getAllocator().CopyString(SelName));\n\n      // If there is only one parameter, and we're past it, add an empty\n      // typed-text chunk since there is nothing to type.\n      if (Method->param_size() == 1)\n        Result.AddTypedTextChunk(\"\");\n    }\n    unsigned Idx = 0;\n    // The extra Idx < Sel.getNumArgs() check is needed due to legacy C-style\n    // method parameters.\n    for (ObjCMethodDecl::param_const_iterator P = Method->param_begin(),\n                                              PEnd = Method->param_end();\n         P != PEnd && Idx < Sel.getNumArgs(); (void)++P, ++Idx) {\n      if (Idx > 0) {\n        std::string Keyword;\n        if (Idx > StartParameter)\n          Result.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        if (IdentifierInfo *II = Sel.getIdentifierInfoForSlot(Idx))\n          Keyword += II->getName();\n        Keyword += \":\";\n        if (Idx < StartParameter || AllParametersAreInformative)\n          Result.AddInformativeChunk(Result.getAllocator().CopyString(Keyword));\n        else\n          Result.AddTypedTextChunk(Result.getAllocator().CopyString(Keyword));\n      }\n\n      // If we're before the starting parameter, skip the placeholder.\n      if (Idx < StartParameter)\n        continue;\n\n      std::string Arg;\n      QualType ParamType = (*P)->getType();\n      Optional<ArrayRef<QualType>> ObjCSubsts;\n      if (!CCContext.getBaseType().isNull())\n        ObjCSubsts = CCContext.getBaseType()->getObjCSubstitutions(Method);\n\n      if (ParamType->isBlockPointerType() && !DeclaringEntity)\n        Arg = FormatFunctionParameter(Policy, *P, true,\n                                      /*SuppressBlock=*/false, ObjCSubsts);\n      else {\n        if (ObjCSubsts)\n          ParamType = ParamType.substObjCTypeArgs(\n              Ctx, *ObjCSubsts, ObjCSubstitutionContext::Parameter);\n        Arg = \"(\" + formatObjCParamQualifiers((*P)->getObjCDeclQualifier(),\n                                              ParamType);\n        Arg += ParamType.getAsString(Policy) + \")\";\n        if (IdentifierInfo *II = (*P)->getIdentifier())\n          if (DeclaringEntity || AllParametersAreInformative)\n            Arg += II->getName();\n      }\n\n      if (Method->isVariadic() && (P + 1) == PEnd)\n        Arg += \", ...\";\n\n      if (DeclaringEntity)\n        Result.AddTextChunk(Result.getAllocator().CopyString(Arg));\n      else if (AllParametersAreInformative)\n        Result.AddInformativeChunk(Result.getAllocator().CopyString(Arg));\n      else\n        Result.AddPlaceholderChunk(Result.getAllocator().CopyString(Arg));\n    }\n\n    if (Method->isVariadic()) {\n      if (Method->param_size() == 0) {\n        if (DeclaringEntity)\n          Result.AddTextChunk(\", ...\");\n        else if (AllParametersAreInformative)\n          Result.AddInformativeChunk(\", ...\");\n        else\n          Result.AddPlaceholderChunk(\", ...\");\n      }\n\n      MaybeAddSentinel(PP, Method, Result);\n    }\n\n    return Result.TakeString();\n  }\n\n  if (Qualifier)\n    AddQualifierToCompletionString(Result, Qualifier, QualifierIsInformative,\n                                   Ctx, Policy);\n\n  Result.AddTypedTextChunk(\n      Result.getAllocator().CopyString(ND->getNameAsString()));\n  return Result.TakeString();\n}\n\nconst RawComment *clang::getCompletionComment(const ASTContext &Ctx,\n                                              const NamedDecl *ND) {\n  if (!ND)\n    return nullptr;\n  if (auto *RC = Ctx.getRawCommentForAnyRedecl(ND))\n    return RC;\n\n  // Try to find comment from a property for ObjC methods.\n  const auto *M = dyn_cast<ObjCMethodDecl>(ND);\n  if (!M)\n    return nullptr;\n  const ObjCPropertyDecl *PDecl = M->findPropertyDecl();\n  if (!PDecl)\n    return nullptr;\n\n  return Ctx.getRawCommentForAnyRedecl(PDecl);\n}\n\nconst RawComment *clang::getPatternCompletionComment(const ASTContext &Ctx,\n                                                     const NamedDecl *ND) {\n  const auto *M = dyn_cast_or_null<ObjCMethodDecl>(ND);\n  if (!M || !M->isPropertyAccessor())\n    return nullptr;\n\n  // Provide code completion comment for self.GetterName where\n  // GetterName is the getter method for a property with name\n  // different from the property name (declared via a property\n  // getter attribute.\n  const ObjCPropertyDecl *PDecl = M->findPropertyDecl();\n  if (!PDecl)\n    return nullptr;\n  if (PDecl->getGetterName() == M->getSelector() &&\n      PDecl->getIdentifier() != M->getIdentifier()) {\n    if (auto *RC = Ctx.getRawCommentForAnyRedecl(M))\n      return RC;\n    if (auto *RC = Ctx.getRawCommentForAnyRedecl(PDecl))\n      return RC;\n  }\n  return nullptr;\n}\n\nconst RawComment *clang::getParameterComment(\n    const ASTContext &Ctx,\n    const CodeCompleteConsumer::OverloadCandidate &Result, unsigned ArgIndex) {\n  auto FDecl = Result.getFunction();\n  if (!FDecl)\n    return nullptr;\n  if (ArgIndex < FDecl->getNumParams())\n    return Ctx.getRawCommentForAnyRedecl(FDecl->getParamDecl(ArgIndex));\n  return nullptr;\n}\n\n/// Add function overload parameter chunks to the given code completion\n/// string.\nstatic void AddOverloadParameterChunks(ASTContext &Context,\n                                       const PrintingPolicy &Policy,\n                                       const FunctionDecl *Function,\n                                       const FunctionProtoType *Prototype,\n                                       CodeCompletionBuilder &Result,\n                                       unsigned CurrentArg, unsigned Start = 0,\n                                       bool InOptional = false) {\n  bool FirstParameter = true;\n  unsigned NumParams =\n      Function ? Function->getNumParams() : Prototype->getNumParams();\n\n  for (unsigned P = Start; P != NumParams; ++P) {\n    if (Function && Function->getParamDecl(P)->hasDefaultArg() && !InOptional) {\n      // When we see an optional default argument, put that argument and\n      // the remaining default arguments into a new, optional string.\n      CodeCompletionBuilder Opt(Result.getAllocator(),\n                                Result.getCodeCompletionTUInfo());\n      if (!FirstParameter)\n        Opt.AddChunk(CodeCompletionString::CK_Comma);\n      // Optional sections are nested.\n      AddOverloadParameterChunks(Context, Policy, Function, Prototype, Opt,\n                                 CurrentArg, P, /*InOptional=*/true);\n      Result.AddOptionalChunk(Opt.TakeString());\n      return;\n    }\n\n    if (FirstParameter)\n      FirstParameter = false;\n    else\n      Result.AddChunk(CodeCompletionString::CK_Comma);\n\n    InOptional = false;\n\n    // Format the placeholder string.\n    std::string Placeholder;\n    if (Function) {\n      const ParmVarDecl *Param = Function->getParamDecl(P);\n      Placeholder = FormatFunctionParameter(Policy, Param);\n      if (Param->hasDefaultArg())\n        Placeholder += GetDefaultValueString(Param, Context.getSourceManager(),\n                                             Context.getLangOpts());\n    } else {\n      Placeholder = Prototype->getParamType(P).getAsString(Policy);\n    }\n\n    if (P == CurrentArg)\n      Result.AddCurrentParameterChunk(\n          Result.getAllocator().CopyString(Placeholder));\n    else\n      Result.AddPlaceholderChunk(Result.getAllocator().CopyString(Placeholder));\n  }\n\n  if (Prototype && Prototype->isVariadic()) {\n    CodeCompletionBuilder Opt(Result.getAllocator(),\n                              Result.getCodeCompletionTUInfo());\n    if (!FirstParameter)\n      Opt.AddChunk(CodeCompletionString::CK_Comma);\n\n    if (CurrentArg < NumParams)\n      Opt.AddPlaceholderChunk(\"...\");\n    else\n      Opt.AddCurrentParameterChunk(\"...\");\n\n    Result.AddOptionalChunk(Opt.TakeString());\n  }\n}\n\nCodeCompletionString *\nCodeCompleteConsumer::OverloadCandidate::CreateSignatureString(\n    unsigned CurrentArg, Sema &S, CodeCompletionAllocator &Allocator,\n    CodeCompletionTUInfo &CCTUInfo, bool IncludeBriefComments) const {\n  PrintingPolicy Policy = getCompletionPrintingPolicy(S);\n  // Show signatures of constructors as they are declared:\n  //   vector(int n) rather than vector<string>(int n)\n  // This is less noisy without being less clear, and avoids tricky cases.\n  Policy.SuppressTemplateArgsInCXXConstructors = true;\n\n  // FIXME: Set priority, availability appropriately.\n  CodeCompletionBuilder Result(Allocator, CCTUInfo, 1,\n                               CXAvailability_Available);\n  FunctionDecl *FDecl = getFunction();\n  const FunctionProtoType *Proto =\n      dyn_cast<FunctionProtoType>(getFunctionType());\n  if (!FDecl && !Proto) {\n    // Function without a prototype. Just give the return type and a\n    // highlighted ellipsis.\n    const FunctionType *FT = getFunctionType();\n    Result.AddResultTypeChunk(Result.getAllocator().CopyString(\n        FT->getReturnType().getAsString(Policy)));\n    Result.AddChunk(CodeCompletionString::CK_LeftParen);\n    Result.AddChunk(CodeCompletionString::CK_CurrentParameter, \"...\");\n    Result.AddChunk(CodeCompletionString::CK_RightParen);\n    return Result.TakeString();\n  }\n\n  if (FDecl) {\n    if (IncludeBriefComments) {\n      if (auto RC = getParameterComment(S.getASTContext(), *this, CurrentArg))\n        Result.addBriefComment(RC->getBriefText(S.getASTContext()));\n    }\n    AddResultTypeChunk(S.Context, Policy, FDecl, QualType(), Result);\n\n    std::string Name;\n    llvm::raw_string_ostream OS(Name);\n    FDecl->getDeclName().print(OS, Policy);\n    Result.AddTextChunk(Result.getAllocator().CopyString(OS.str()));\n  } else {\n    Result.AddResultTypeChunk(Result.getAllocator().CopyString(\n        Proto->getReturnType().getAsString(Policy)));\n  }\n\n  Result.AddChunk(CodeCompletionString::CK_LeftParen);\n  AddOverloadParameterChunks(S.getASTContext(), Policy, FDecl, Proto, Result,\n                             CurrentArg);\n  Result.AddChunk(CodeCompletionString::CK_RightParen);\n\n  return Result.TakeString();\n}\n\nunsigned clang::getMacroUsagePriority(StringRef MacroName,\n                                      const LangOptions &LangOpts,\n                                      bool PreferredTypeIsPointer) {\n  unsigned Priority = CCP_Macro;\n\n  // Treat the \"nil\", \"Nil\" and \"NULL\" macros as null pointer constants.\n  if (MacroName.equals(\"nil\") || MacroName.equals(\"NULL\") ||\n      MacroName.equals(\"Nil\")) {\n    Priority = CCP_Constant;\n    if (PreferredTypeIsPointer)\n      Priority = Priority / CCF_SimilarTypeMatch;\n  }\n  // Treat \"YES\", \"NO\", \"true\", and \"false\" as constants.\n  else if (MacroName.equals(\"YES\") || MacroName.equals(\"NO\") ||\n           MacroName.equals(\"true\") || MacroName.equals(\"false\"))\n    Priority = CCP_Constant;\n  // Treat \"bool\" as a type.\n  else if (MacroName.equals(\"bool\"))\n    Priority = CCP_Type + (LangOpts.ObjC ? CCD_bool_in_ObjC : 0);\n\n  return Priority;\n}\n\nCXCursorKind clang::getCursorKindForDecl(const Decl *D) {\n  if (!D)\n    return CXCursor_UnexposedDecl;\n\n  switch (D->getKind()) {\n  case Decl::Enum:\n    return CXCursor_EnumDecl;\n  case Decl::EnumConstant:\n    return CXCursor_EnumConstantDecl;\n  case Decl::Field:\n    return CXCursor_FieldDecl;\n  case Decl::Function:\n    return CXCursor_FunctionDecl;\n  case Decl::ObjCCategory:\n    return CXCursor_ObjCCategoryDecl;\n  case Decl::ObjCCategoryImpl:\n    return CXCursor_ObjCCategoryImplDecl;\n  case Decl::ObjCImplementation:\n    return CXCursor_ObjCImplementationDecl;\n\n  case Decl::ObjCInterface:\n    return CXCursor_ObjCInterfaceDecl;\n  case Decl::ObjCIvar:\n    return CXCursor_ObjCIvarDecl;\n  case Decl::ObjCMethod:\n    return cast<ObjCMethodDecl>(D)->isInstanceMethod()\n               ? CXCursor_ObjCInstanceMethodDecl\n               : CXCursor_ObjCClassMethodDecl;\n  case Decl::CXXMethod:\n    return CXCursor_CXXMethod;\n  case Decl::CXXConstructor:\n    return CXCursor_Constructor;\n  case Decl::CXXDestructor:\n    return CXCursor_Destructor;\n  case Decl::CXXConversion:\n    return CXCursor_ConversionFunction;\n  case Decl::ObjCProperty:\n    return CXCursor_ObjCPropertyDecl;\n  case Decl::ObjCProtocol:\n    return CXCursor_ObjCProtocolDecl;\n  case Decl::ParmVar:\n    return CXCursor_ParmDecl;\n  case Decl::Typedef:\n    return CXCursor_TypedefDecl;\n  case Decl::TypeAlias:\n    return CXCursor_TypeAliasDecl;\n  case Decl::TypeAliasTemplate:\n    return CXCursor_TypeAliasTemplateDecl;\n  case Decl::Var:\n    return CXCursor_VarDecl;\n  case Decl::Namespace:\n    return CXCursor_Namespace;\n  case Decl::NamespaceAlias:\n    return CXCursor_NamespaceAlias;\n  case Decl::TemplateTypeParm:\n    return CXCursor_TemplateTypeParameter;\n  case Decl::NonTypeTemplateParm:\n    return CXCursor_NonTypeTemplateParameter;\n  case Decl::TemplateTemplateParm:\n    return CXCursor_TemplateTemplateParameter;\n  case Decl::FunctionTemplate:\n    return CXCursor_FunctionTemplate;\n  case Decl::ClassTemplate:\n    return CXCursor_ClassTemplate;\n  case Decl::AccessSpec:\n    return CXCursor_CXXAccessSpecifier;\n  case Decl::ClassTemplatePartialSpecialization:\n    return CXCursor_ClassTemplatePartialSpecialization;\n  case Decl::UsingDirective:\n    return CXCursor_UsingDirective;\n  case Decl::StaticAssert:\n    return CXCursor_StaticAssert;\n  case Decl::Friend:\n    return CXCursor_FriendDecl;\n  case Decl::TranslationUnit:\n    return CXCursor_TranslationUnit;\n\n  case Decl::Using:\n  case Decl::UnresolvedUsingValue:\n  case Decl::UnresolvedUsingTypename:\n    return CXCursor_UsingDeclaration;\n\n  case Decl::ObjCPropertyImpl:\n    switch (cast<ObjCPropertyImplDecl>(D)->getPropertyImplementation()) {\n    case ObjCPropertyImplDecl::Dynamic:\n      return CXCursor_ObjCDynamicDecl;\n\n    case ObjCPropertyImplDecl::Synthesize:\n      return CXCursor_ObjCSynthesizeDecl;\n    }\n    llvm_unreachable(\"Unexpected Kind!\");\n\n  case Decl::Import:\n    return CXCursor_ModuleImportDecl;\n\n  case Decl::ObjCTypeParam:\n    return CXCursor_TemplateTypeParameter;\n\n  default:\n    if (const auto *TD = dyn_cast<TagDecl>(D)) {\n      switch (TD->getTagKind()) {\n      case TTK_Interface: // fall through\n      case TTK_Struct:\n        return CXCursor_StructDecl;\n      case TTK_Class:\n        return CXCursor_ClassDecl;\n      case TTK_Union:\n        return CXCursor_UnionDecl;\n      case TTK_Enum:\n        return CXCursor_EnumDecl;\n      }\n    }\n  }\n\n  return CXCursor_UnexposedDecl;\n}\n\nstatic void AddMacroResults(Preprocessor &PP, ResultBuilder &Results,\n                            bool LoadExternal, bool IncludeUndefined,\n                            bool TargetTypeIsPointer = false) {\n  typedef CodeCompletionResult Result;\n\n  Results.EnterNewScope();\n\n  for (Preprocessor::macro_iterator M = PP.macro_begin(LoadExternal),\n                                    MEnd = PP.macro_end(LoadExternal);\n       M != MEnd; ++M) {\n    auto MD = PP.getMacroDefinition(M->first);\n    if (IncludeUndefined || MD) {\n      MacroInfo *MI = MD.getMacroInfo();\n      if (MI && MI->isUsedForHeaderGuard())\n        continue;\n\n      Results.AddResult(\n          Result(M->first, MI,\n                 getMacroUsagePriority(M->first->getName(), PP.getLangOpts(),\n                                       TargetTypeIsPointer)));\n    }\n  }\n\n  Results.ExitScope();\n}\n\nstatic void AddPrettyFunctionResults(const LangOptions &LangOpts,\n                                     ResultBuilder &Results) {\n  typedef CodeCompletionResult Result;\n\n  Results.EnterNewScope();\n\n  Results.AddResult(Result(\"__PRETTY_FUNCTION__\", CCP_Constant));\n  Results.AddResult(Result(\"__FUNCTION__\", CCP_Constant));\n  if (LangOpts.C99 || LangOpts.CPlusPlus11)\n    Results.AddResult(Result(\"__func__\", CCP_Constant));\n  Results.ExitScope();\n}\n\nstatic void HandleCodeCompleteResults(Sema *S,\n                                      CodeCompleteConsumer *CodeCompleter,\n                                      CodeCompletionContext Context,\n                                      CodeCompletionResult *Results,\n                                      unsigned NumResults) {\n  if (CodeCompleter)\n    CodeCompleter->ProcessCodeCompleteResults(*S, Context, Results, NumResults);\n}\n\nstatic CodeCompletionContext\nmapCodeCompletionContext(Sema &S, Sema::ParserCompletionContext PCC) {\n  switch (PCC) {\n  case Sema::PCC_Namespace:\n    return CodeCompletionContext::CCC_TopLevel;\n\n  case Sema::PCC_Class:\n    return CodeCompletionContext::CCC_ClassStructUnion;\n\n  case Sema::PCC_ObjCInterface:\n    return CodeCompletionContext::CCC_ObjCInterface;\n\n  case Sema::PCC_ObjCImplementation:\n    return CodeCompletionContext::CCC_ObjCImplementation;\n\n  case Sema::PCC_ObjCInstanceVariableList:\n    return CodeCompletionContext::CCC_ObjCIvarList;\n\n  case Sema::PCC_Template:\n  case Sema::PCC_MemberTemplate:\n    if (S.CurContext->isFileContext())\n      return CodeCompletionContext::CCC_TopLevel;\n    if (S.CurContext->isRecord())\n      return CodeCompletionContext::CCC_ClassStructUnion;\n    return CodeCompletionContext::CCC_Other;\n\n  case Sema::PCC_RecoveryInFunction:\n    return CodeCompletionContext::CCC_Recovery;\n\n  case Sema::PCC_ForInit:\n    if (S.getLangOpts().CPlusPlus || S.getLangOpts().C99 ||\n        S.getLangOpts().ObjC)\n      return CodeCompletionContext::CCC_ParenthesizedExpression;\n    else\n      return CodeCompletionContext::CCC_Expression;\n\n  case Sema::PCC_Expression:\n    return CodeCompletionContext::CCC_Expression;\n  case Sema::PCC_Condition:\n    return CodeCompletionContext(CodeCompletionContext::CCC_Expression,\n                                 S.getASTContext().BoolTy);\n\n  case Sema::PCC_Statement:\n    return CodeCompletionContext::CCC_Statement;\n\n  case Sema::PCC_Type:\n    return CodeCompletionContext::CCC_Type;\n\n  case Sema::PCC_ParenthesizedExpression:\n    return CodeCompletionContext::CCC_ParenthesizedExpression;\n\n  case Sema::PCC_LocalDeclarationSpecifiers:\n    return CodeCompletionContext::CCC_Type;\n  }\n\n  llvm_unreachable(\"Invalid ParserCompletionContext!\");\n}\n\n/// If we're in a C++ virtual member function, add completion results\n/// that invoke the functions we override, since it's common to invoke the\n/// overridden function as well as adding new functionality.\n///\n/// \\param S The semantic analysis object for which we are generating results.\n///\n/// \\param InContext This context in which the nested-name-specifier preceding\n/// the code-completion point\nstatic void MaybeAddOverrideCalls(Sema &S, DeclContext *InContext,\n                                  ResultBuilder &Results) {\n  // Look through blocks.\n  DeclContext *CurContext = S.CurContext;\n  while (isa<BlockDecl>(CurContext))\n    CurContext = CurContext->getParent();\n\n  CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(CurContext);\n  if (!Method || !Method->isVirtual())\n    return;\n\n  // We need to have names for all of the parameters, if we're going to\n  // generate a forwarding call.\n  for (auto P : Method->parameters())\n    if (!P->getDeclName())\n      return;\n\n  PrintingPolicy Policy = getCompletionPrintingPolicy(S);\n  for (const CXXMethodDecl *Overridden : Method->overridden_methods()) {\n    CodeCompletionBuilder Builder(Results.getAllocator(),\n                                  Results.getCodeCompletionTUInfo());\n    if (Overridden->getCanonicalDecl() == Method->getCanonicalDecl())\n      continue;\n\n    // If we need a nested-name-specifier, add one now.\n    if (!InContext) {\n      NestedNameSpecifier *NNS = getRequiredQualification(\n          S.Context, CurContext, Overridden->getDeclContext());\n      if (NNS) {\n        std::string Str;\n        llvm::raw_string_ostream OS(Str);\n        NNS->print(OS, Policy);\n        Builder.AddTextChunk(Results.getAllocator().CopyString(OS.str()));\n      }\n    } else if (!InContext->Equals(Overridden->getDeclContext()))\n      continue;\n\n    Builder.AddTypedTextChunk(\n        Results.getAllocator().CopyString(Overridden->getNameAsString()));\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    bool FirstParam = true;\n    for (auto P : Method->parameters()) {\n      if (FirstParam)\n        FirstParam = false;\n      else\n        Builder.AddChunk(CodeCompletionString::CK_Comma);\n\n      Builder.AddPlaceholderChunk(\n          Results.getAllocator().CopyString(P->getIdentifier()->getName()));\n    }\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    Results.AddResult(CodeCompletionResult(\n        Builder.TakeString(), CCP_SuperCompletion, CXCursor_CXXMethod,\n        CXAvailability_Available, Overridden));\n    Results.Ignore(Overridden);\n  }\n}\n\nvoid Sema::CodeCompleteModuleImport(SourceLocation ImportLoc,\n                                    ModuleIdPath Path) {\n  typedef CodeCompletionResult Result;\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n\n  CodeCompletionAllocator &Allocator = Results.getAllocator();\n  CodeCompletionBuilder Builder(Allocator, Results.getCodeCompletionTUInfo());\n  typedef CodeCompletionResult Result;\n  if (Path.empty()) {\n    // Enumerate all top-level modules.\n    SmallVector<Module *, 8> Modules;\n    PP.getHeaderSearchInfo().collectAllModules(Modules);\n    for (unsigned I = 0, N = Modules.size(); I != N; ++I) {\n      Builder.AddTypedTextChunk(\n          Builder.getAllocator().CopyString(Modules[I]->Name));\n      Results.AddResult(Result(\n          Builder.TakeString(), CCP_Declaration, CXCursor_ModuleImportDecl,\n          Modules[I]->isAvailable() ? CXAvailability_Available\n                                    : CXAvailability_NotAvailable));\n    }\n  } else if (getLangOpts().Modules) {\n    // Load the named module.\n    Module *Mod =\n        PP.getModuleLoader().loadModule(ImportLoc, Path, Module::AllVisible,\n                                        /*IsInclusionDirective=*/false);\n    // Enumerate submodules.\n    if (Mod) {\n      for (Module::submodule_iterator Sub = Mod->submodule_begin(),\n                                      SubEnd = Mod->submodule_end();\n           Sub != SubEnd; ++Sub) {\n\n        Builder.AddTypedTextChunk(\n            Builder.getAllocator().CopyString((*Sub)->Name));\n        Results.AddResult(Result(\n            Builder.TakeString(), CCP_Declaration, CXCursor_ModuleImportDecl,\n            (*Sub)->isAvailable() ? CXAvailability_Available\n                                  : CXAvailability_NotAvailable));\n      }\n    }\n  }\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteOrdinaryName(Scope *S,\n                                    ParserCompletionContext CompletionContext) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        mapCodeCompletionContext(*this, CompletionContext));\n  Results.EnterNewScope();\n\n  // Determine how to filter results, e.g., so that the names of\n  // values (functions, enumerators, function templates, etc.) are\n  // only allowed where we can have an expression.\n  switch (CompletionContext) {\n  case PCC_Namespace:\n  case PCC_Class:\n  case PCC_ObjCInterface:\n  case PCC_ObjCImplementation:\n  case PCC_ObjCInstanceVariableList:\n  case PCC_Template:\n  case PCC_MemberTemplate:\n  case PCC_Type:\n  case PCC_LocalDeclarationSpecifiers:\n    Results.setFilter(&ResultBuilder::IsOrdinaryNonValueName);\n    break;\n\n  case PCC_Statement:\n  case PCC_ParenthesizedExpression:\n  case PCC_Expression:\n  case PCC_ForInit:\n  case PCC_Condition:\n    if (WantTypesInContext(CompletionContext, getLangOpts()))\n      Results.setFilter(&ResultBuilder::IsOrdinaryName);\n    else\n      Results.setFilter(&ResultBuilder::IsOrdinaryNonTypeName);\n\n    if (getLangOpts().CPlusPlus)\n      MaybeAddOverrideCalls(*this, /*InContext=*/nullptr, Results);\n    break;\n\n  case PCC_RecoveryInFunction:\n    // Unfiltered\n    break;\n  }\n\n  // If we are in a C++ non-static member function, check the qualifiers on\n  // the member function to filter/prioritize the results list.\n  auto ThisType = getCurrentThisType();\n  if (!ThisType.isNull())\n    Results.setObjectTypeQualifiers(ThisType->getPointeeType().getQualifiers(),\n                                    VK_LValue);\n\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n\n  AddOrdinaryNameResults(CompletionContext, S, *this, Results);\n  Results.ExitScope();\n\n  switch (CompletionContext) {\n  case PCC_ParenthesizedExpression:\n  case PCC_Expression:\n  case PCC_Statement:\n  case PCC_RecoveryInFunction:\n    if (S->getFnParent())\n      AddPrettyFunctionResults(getLangOpts(), Results);\n    break;\n\n  case PCC_Namespace:\n  case PCC_Class:\n  case PCC_ObjCInterface:\n  case PCC_ObjCImplementation:\n  case PCC_ObjCInstanceVariableList:\n  case PCC_Template:\n  case PCC_MemberTemplate:\n  case PCC_ForInit:\n  case PCC_Condition:\n  case PCC_Type:\n  case PCC_LocalDeclarationSpecifiers:\n    break;\n  }\n\n  if (CodeCompleter->includeMacros())\n    AddMacroResults(PP, Results, CodeCompleter->loadExternal(), false);\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nstatic void AddClassMessageCompletions(Sema &SemaRef, Scope *S,\n                                       ParsedType Receiver,\n                                       ArrayRef<IdentifierInfo *> SelIdents,\n                                       bool AtArgumentExpression, bool IsSuper,\n                                       ResultBuilder &Results);\n\nvoid Sema::CodeCompleteDeclSpec(Scope *S, DeclSpec &DS,\n                                bool AllowNonIdentifiers,\n                                bool AllowNestedNameSpecifiers) {\n  typedef CodeCompletionResult Result;\n  ResultBuilder Results(\n      *this, CodeCompleter->getAllocator(),\n      CodeCompleter->getCodeCompletionTUInfo(),\n      AllowNestedNameSpecifiers\n          // FIXME: Try to separate codepath leading here to deduce whether we\n          // need an existing symbol or a new one.\n          ? CodeCompletionContext::CCC_SymbolOrNewName\n          : CodeCompletionContext::CCC_NewName);\n  Results.EnterNewScope();\n\n  // Type qualifiers can come after names.\n  Results.AddResult(Result(\"const\"));\n  Results.AddResult(Result(\"volatile\"));\n  if (getLangOpts().C99)\n    Results.AddResult(Result(\"restrict\"));\n\n  if (getLangOpts().CPlusPlus) {\n    if (getLangOpts().CPlusPlus11 &&\n        (DS.getTypeSpecType() == DeclSpec::TST_class ||\n         DS.getTypeSpecType() == DeclSpec::TST_struct))\n      Results.AddResult(\"final\");\n\n    if (AllowNonIdentifiers) {\n      Results.AddResult(Result(\"operator\"));\n    }\n\n    // Add nested-name-specifiers.\n    if (AllowNestedNameSpecifiers) {\n      Results.allowNestedNameSpecifiers();\n      Results.setFilter(&ResultBuilder::IsImpossibleToSatisfy);\n      CodeCompletionDeclConsumer Consumer(Results, CurContext);\n      LookupVisibleDecls(S, LookupNestedNameSpecifierName, Consumer,\n                         CodeCompleter->includeGlobals(),\n                         CodeCompleter->loadExternal());\n      Results.setFilter(nullptr);\n    }\n  }\n  Results.ExitScope();\n\n  // If we're in a context where we might have an expression (rather than a\n  // declaration), and what we've seen so far is an Objective-C type that could\n  // be a receiver of a class message, this may be a class message send with\n  // the initial opening bracket '[' missing. Add appropriate completions.\n  if (AllowNonIdentifiers && !AllowNestedNameSpecifiers &&\n      DS.getParsedSpecifiers() == DeclSpec::PQ_TypeSpecifier &&\n      DS.getTypeSpecType() == DeclSpec::TST_typename &&\n      DS.getTypeSpecComplex() == DeclSpec::TSC_unspecified &&\n      DS.getTypeSpecSign() == TypeSpecifierSign::Unspecified &&\n      !DS.isTypeAltiVecVector() && S &&\n      (S->getFlags() & Scope::DeclScope) != 0 &&\n      (S->getFlags() & (Scope::ClassScope | Scope::TemplateParamScope |\n                        Scope::FunctionPrototypeScope | Scope::AtCatchScope)) ==\n          0) {\n    ParsedType T = DS.getRepAsType();\n    if (!T.get().isNull() && T.get()->isObjCObjectOrInterfaceType())\n      AddClassMessageCompletions(*this, S, T, None, false, false, Results);\n  }\n\n  // Note that we intentionally suppress macro results here, since we do not\n  // encourage using macros to produce the names of entities.\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nstruct Sema::CodeCompleteExpressionData {\n  CodeCompleteExpressionData(QualType PreferredType = QualType(),\n                             bool IsParenthesized = false)\n      : PreferredType(PreferredType), IntegralConstantExpression(false),\n        ObjCCollection(false), IsParenthesized(IsParenthesized) {}\n\n  QualType PreferredType;\n  bool IntegralConstantExpression;\n  bool ObjCCollection;\n  bool IsParenthesized;\n  SmallVector<Decl *, 4> IgnoreDecls;\n};\n\nnamespace {\n/// Information that allows to avoid completing redundant enumerators.\nstruct CoveredEnumerators {\n  llvm::SmallPtrSet<EnumConstantDecl *, 8> Seen;\n  NestedNameSpecifier *SuggestedQualifier = nullptr;\n};\n} // namespace\n\nstatic void AddEnumerators(ResultBuilder &Results, ASTContext &Context,\n                           EnumDecl *Enum, DeclContext *CurContext,\n                           const CoveredEnumerators &Enumerators) {\n  NestedNameSpecifier *Qualifier = Enumerators.SuggestedQualifier;\n  if (Context.getLangOpts().CPlusPlus && !Qualifier && Enumerators.Seen.empty()) {\n    // If there are no prior enumerators in C++, check whether we have to\n    // qualify the names of the enumerators that we suggest, because they\n    // may not be visible in this scope.\n    Qualifier = getRequiredQualification(Context, CurContext, Enum);\n  }\n\n  Results.EnterNewScope();\n  for (auto *E : Enum->enumerators()) {\n    if (Enumerators.Seen.count(E))\n      continue;\n\n    CodeCompletionResult R(E, CCP_EnumInCase, Qualifier);\n    Results.AddResult(R, CurContext, nullptr, false);\n  }\n  Results.ExitScope();\n}\n\n/// Try to find a corresponding FunctionProtoType for function-like types (e.g.\n/// function pointers, std::function, etc).\nstatic const FunctionProtoType *TryDeconstructFunctionLike(QualType T) {\n  assert(!T.isNull());\n  // Try to extract first template argument from std::function<> and similar.\n  // Note we only handle the sugared types, they closely match what users wrote.\n  // We explicitly choose to not handle ClassTemplateSpecializationDecl.\n  if (auto *Specialization = T->getAs<TemplateSpecializationType>()) {\n    if (Specialization->getNumArgs() != 1)\n      return nullptr;\n    const TemplateArgument &Argument = Specialization->getArg(0);\n    if (Argument.getKind() != TemplateArgument::Type)\n      return nullptr;\n    return Argument.getAsType()->getAs<FunctionProtoType>();\n  }\n  // Handle other cases.\n  if (T->isPointerType())\n    T = T->getPointeeType();\n  return T->getAs<FunctionProtoType>();\n}\n\n/// Adds a pattern completion for a lambda expression with the specified\n/// parameter types and placeholders for parameter names.\nstatic void AddLambdaCompletion(ResultBuilder &Results,\n                                llvm::ArrayRef<QualType> Parameters,\n                                const LangOptions &LangOpts) {\n  if (!Results.includeCodePatterns())\n    return;\n  CodeCompletionBuilder Completion(Results.getAllocator(),\n                                   Results.getCodeCompletionTUInfo());\n  // [](<parameters>) {}\n  Completion.AddChunk(CodeCompletionString::CK_LeftBracket);\n  Completion.AddPlaceholderChunk(\"=\");\n  Completion.AddChunk(CodeCompletionString::CK_RightBracket);\n  if (!Parameters.empty()) {\n    Completion.AddChunk(CodeCompletionString::CK_LeftParen);\n    bool First = true;\n    for (auto Parameter : Parameters) {\n      if (!First)\n        Completion.AddChunk(CodeCompletionString::ChunkKind::CK_Comma);\n      else\n        First = false;\n\n      constexpr llvm::StringLiteral NamePlaceholder = \"!#!NAME_GOES_HERE!#!\";\n      std::string Type = std::string(NamePlaceholder);\n      Parameter.getAsStringInternal(Type, PrintingPolicy(LangOpts));\n      llvm::StringRef Prefix, Suffix;\n      std::tie(Prefix, Suffix) = llvm::StringRef(Type).split(NamePlaceholder);\n      Prefix = Prefix.rtrim();\n      Suffix = Suffix.ltrim();\n\n      Completion.AddTextChunk(Completion.getAllocator().CopyString(Prefix));\n      Completion.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Completion.AddPlaceholderChunk(\"parameter\");\n      Completion.AddTextChunk(Completion.getAllocator().CopyString(Suffix));\n    };\n    Completion.AddChunk(CodeCompletionString::CK_RightParen);\n  }\n  Completion.AddChunk(clang::CodeCompletionString::CK_HorizontalSpace);\n  Completion.AddChunk(CodeCompletionString::CK_LeftBrace);\n  Completion.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Completion.AddPlaceholderChunk(\"body\");\n  Completion.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Completion.AddChunk(CodeCompletionString::CK_RightBrace);\n\n  Results.AddResult(Completion.TakeString());\n}\n\n/// Perform code-completion in an expression context when we know what\n/// type we're looking for.\nvoid Sema::CodeCompleteExpression(Scope *S,\n                                  const CodeCompleteExpressionData &Data) {\n  ResultBuilder Results(\n      *this, CodeCompleter->getAllocator(),\n      CodeCompleter->getCodeCompletionTUInfo(),\n      CodeCompletionContext(\n          Data.IsParenthesized\n              ? CodeCompletionContext::CCC_ParenthesizedExpression\n              : CodeCompletionContext::CCC_Expression,\n          Data.PreferredType));\n  auto PCC =\n      Data.IsParenthesized ? PCC_ParenthesizedExpression : PCC_Expression;\n  if (Data.ObjCCollection)\n    Results.setFilter(&ResultBuilder::IsObjCCollection);\n  else if (Data.IntegralConstantExpression)\n    Results.setFilter(&ResultBuilder::IsIntegralConstantValue);\n  else if (WantTypesInContext(PCC, getLangOpts()))\n    Results.setFilter(&ResultBuilder::IsOrdinaryName);\n  else\n    Results.setFilter(&ResultBuilder::IsOrdinaryNonTypeName);\n\n  if (!Data.PreferredType.isNull())\n    Results.setPreferredType(Data.PreferredType.getNonReferenceType());\n\n  // Ignore any declarations that we were told that we don't care about.\n  for (unsigned I = 0, N = Data.IgnoreDecls.size(); I != N; ++I)\n    Results.Ignore(Data.IgnoreDecls[I]);\n\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n\n  Results.EnterNewScope();\n  AddOrdinaryNameResults(PCC, S, *this, Results);\n  Results.ExitScope();\n\n  bool PreferredTypeIsPointer = false;\n  if (!Data.PreferredType.isNull()) {\n    PreferredTypeIsPointer = Data.PreferredType->isAnyPointerType() ||\n                             Data.PreferredType->isMemberPointerType() ||\n                             Data.PreferredType->isBlockPointerType();\n    if (Data.PreferredType->isEnumeralType()) {\n      EnumDecl *Enum = Data.PreferredType->castAs<EnumType>()->getDecl();\n      if (auto *Def = Enum->getDefinition())\n        Enum = Def;\n      // FIXME: collect covered enumerators in cases like:\n      //        if (x == my_enum::one) { ... } else if (x == ^) {}\n      AddEnumerators(Results, Context, Enum, CurContext, CoveredEnumerators());\n    }\n  }\n\n  if (S->getFnParent() && !Data.ObjCCollection &&\n      !Data.IntegralConstantExpression)\n    AddPrettyFunctionResults(getLangOpts(), Results);\n\n  if (CodeCompleter->includeMacros())\n    AddMacroResults(PP, Results, CodeCompleter->loadExternal(), false,\n                    PreferredTypeIsPointer);\n\n  // Complete a lambda expression when preferred type is a function.\n  if (!Data.PreferredType.isNull() && getLangOpts().CPlusPlus11) {\n    if (const FunctionProtoType *F =\n            TryDeconstructFunctionLike(Data.PreferredType))\n      AddLambdaCompletion(Results, F->getParamTypes(), getLangOpts());\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteExpression(Scope *S, QualType PreferredType,\n                                  bool IsParenthesized) {\n  return CodeCompleteExpression(\n      S, CodeCompleteExpressionData(PreferredType, IsParenthesized));\n}\n\nvoid Sema::CodeCompletePostfixExpression(Scope *S, ExprResult E,\n                                         QualType PreferredType) {\n  if (E.isInvalid())\n    CodeCompleteExpression(S, PreferredType);\n  else if (getLangOpts().ObjC)\n    CodeCompleteObjCInstanceMessage(S, E.get(), None, false);\n}\n\n/// The set of properties that have already been added, referenced by\n/// property name.\ntypedef llvm::SmallPtrSet<IdentifierInfo *, 16> AddedPropertiesSet;\n\n/// Retrieve the container definition, if any?\nstatic ObjCContainerDecl *getContainerDef(ObjCContainerDecl *Container) {\n  if (ObjCInterfaceDecl *Interface = dyn_cast<ObjCInterfaceDecl>(Container)) {\n    if (Interface->hasDefinition())\n      return Interface->getDefinition();\n\n    return Interface;\n  }\n\n  if (ObjCProtocolDecl *Protocol = dyn_cast<ObjCProtocolDecl>(Container)) {\n    if (Protocol->hasDefinition())\n      return Protocol->getDefinition();\n\n    return Protocol;\n  }\n  return Container;\n}\n\n/// Adds a block invocation code completion result for the given block\n/// declaration \\p BD.\nstatic void AddObjCBlockCall(ASTContext &Context, const PrintingPolicy &Policy,\n                             CodeCompletionBuilder &Builder,\n                             const NamedDecl *BD,\n                             const FunctionTypeLoc &BlockLoc,\n                             const FunctionProtoTypeLoc &BlockProtoLoc) {\n  Builder.AddResultTypeChunk(\n      GetCompletionTypeString(BlockLoc.getReturnLoc().getType(), Context,\n                              Policy, Builder.getAllocator()));\n\n  AddTypedNameChunk(Context, Policy, BD, Builder);\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n\n  if (BlockProtoLoc && BlockProtoLoc.getTypePtr()->isVariadic()) {\n    Builder.AddPlaceholderChunk(\"...\");\n  } else {\n    for (unsigned I = 0, N = BlockLoc.getNumParams(); I != N; ++I) {\n      if (I)\n        Builder.AddChunk(CodeCompletionString::CK_Comma);\n\n      // Format the placeholder string.\n      std::string PlaceholderStr =\n          FormatFunctionParameter(Policy, BlockLoc.getParam(I));\n\n      if (I == N - 1 && BlockProtoLoc &&\n          BlockProtoLoc.getTypePtr()->isVariadic())\n        PlaceholderStr += \", ...\";\n\n      // Add the placeholder string.\n      Builder.AddPlaceholderChunk(\n          Builder.getAllocator().CopyString(PlaceholderStr));\n    }\n  }\n\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n}\n\nstatic void\nAddObjCProperties(const CodeCompletionContext &CCContext,\n                  ObjCContainerDecl *Container, bool AllowCategories,\n                  bool AllowNullaryMethods, DeclContext *CurContext,\n                  AddedPropertiesSet &AddedProperties, ResultBuilder &Results,\n                  bool IsBaseExprStatement = false,\n                  bool IsClassProperty = false, bool InOriginalClass = true) {\n  typedef CodeCompletionResult Result;\n\n  // Retrieve the definition.\n  Container = getContainerDef(Container);\n\n  // Add properties in this container.\n  const auto AddProperty = [&](const ObjCPropertyDecl *P) {\n    if (!AddedProperties.insert(P->getIdentifier()).second)\n      return;\n\n    // FIXME: Provide block invocation completion for non-statement\n    // expressions.\n    if (!P->getType().getTypePtr()->isBlockPointerType() ||\n        !IsBaseExprStatement) {\n      Result R = Result(P, Results.getBasePriority(P), nullptr);\n      if (!InOriginalClass)\n        setInBaseClass(R);\n      Results.MaybeAddResult(R, CurContext);\n      return;\n    }\n\n    // Block setter and invocation completion is provided only when we are able\n    // to find the FunctionProtoTypeLoc with parameter names for the block.\n    FunctionTypeLoc BlockLoc;\n    FunctionProtoTypeLoc BlockProtoLoc;\n    findTypeLocationForBlockDecl(P->getTypeSourceInfo(), BlockLoc,\n                                 BlockProtoLoc);\n    if (!BlockLoc) {\n      Result R = Result(P, Results.getBasePriority(P), nullptr);\n      if (!InOriginalClass)\n        setInBaseClass(R);\n      Results.MaybeAddResult(R, CurContext);\n      return;\n    }\n\n    // The default completion result for block properties should be the block\n    // invocation completion when the base expression is a statement.\n    CodeCompletionBuilder Builder(Results.getAllocator(),\n                                  Results.getCodeCompletionTUInfo());\n    AddObjCBlockCall(Container->getASTContext(),\n                     getCompletionPrintingPolicy(Results.getSema()), Builder, P,\n                     BlockLoc, BlockProtoLoc);\n    Result R = Result(Builder.TakeString(), P, Results.getBasePriority(P));\n    if (!InOriginalClass)\n      setInBaseClass(R);\n    Results.MaybeAddResult(R, CurContext);\n\n    // Provide additional block setter completion iff the base expression is a\n    // statement and the block property is mutable.\n    if (!P->isReadOnly()) {\n      CodeCompletionBuilder Builder(Results.getAllocator(),\n                                    Results.getCodeCompletionTUInfo());\n      AddResultTypeChunk(Container->getASTContext(),\n                         getCompletionPrintingPolicy(Results.getSema()), P,\n                         CCContext.getBaseType(), Builder);\n      Builder.AddTypedTextChunk(\n          Results.getAllocator().CopyString(P->getName()));\n      Builder.AddChunk(CodeCompletionString::CK_Equal);\n\n      std::string PlaceholderStr = formatBlockPlaceholder(\n          getCompletionPrintingPolicy(Results.getSema()), P, BlockLoc,\n          BlockProtoLoc, /*SuppressBlockName=*/true);\n      // Add the placeholder string.\n      Builder.AddPlaceholderChunk(\n          Builder.getAllocator().CopyString(PlaceholderStr));\n\n      // When completing blocks properties that return void the default\n      // property completion result should show up before the setter,\n      // otherwise the setter completion should show up before the default\n      // property completion, as we normally want to use the result of the\n      // call.\n      Result R =\n          Result(Builder.TakeString(), P,\n                 Results.getBasePriority(P) +\n                     (BlockLoc.getTypePtr()->getReturnType()->isVoidType()\n                          ? CCD_BlockPropertySetter\n                          : -CCD_BlockPropertySetter));\n      if (!InOriginalClass)\n        setInBaseClass(R);\n      Results.MaybeAddResult(R, CurContext);\n    }\n  };\n\n  if (IsClassProperty) {\n    for (const auto *P : Container->class_properties())\n      AddProperty(P);\n  } else {\n    for (const auto *P : Container->instance_properties())\n      AddProperty(P);\n  }\n\n  // Add nullary methods or implicit class properties\n  if (AllowNullaryMethods) {\n    ASTContext &Context = Container->getASTContext();\n    PrintingPolicy Policy = getCompletionPrintingPolicy(Results.getSema());\n    // Adds a method result\n    const auto AddMethod = [&](const ObjCMethodDecl *M) {\n      IdentifierInfo *Name = M->getSelector().getIdentifierInfoForSlot(0);\n      if (!Name)\n        return;\n      if (!AddedProperties.insert(Name).second)\n        return;\n      CodeCompletionBuilder Builder(Results.getAllocator(),\n                                    Results.getCodeCompletionTUInfo());\n      AddResultTypeChunk(Context, Policy, M, CCContext.getBaseType(), Builder);\n      Builder.AddTypedTextChunk(\n          Results.getAllocator().CopyString(Name->getName()));\n      Result R = Result(Builder.TakeString(), M,\n                        CCP_MemberDeclaration + CCD_MethodAsProperty);\n      if (!InOriginalClass)\n        setInBaseClass(R);\n      Results.MaybeAddResult(R, CurContext);\n    };\n\n    if (IsClassProperty) {\n      for (const auto *M : Container->methods()) {\n        // Gather the class method that can be used as implicit property\n        // getters. Methods with arguments or methods that return void aren't\n        // added to the results as they can't be used as a getter.\n        if (!M->getSelector().isUnarySelector() ||\n            M->getReturnType()->isVoidType() || M->isInstanceMethod())\n          continue;\n        AddMethod(M);\n      }\n    } else {\n      for (auto *M : Container->methods()) {\n        if (M->getSelector().isUnarySelector())\n          AddMethod(M);\n      }\n    }\n  }\n\n  // Add properties in referenced protocols.\n  if (ObjCProtocolDecl *Protocol = dyn_cast<ObjCProtocolDecl>(Container)) {\n    for (auto *P : Protocol->protocols())\n      AddObjCProperties(CCContext, P, AllowCategories, AllowNullaryMethods,\n                        CurContext, AddedProperties, Results,\n                        IsBaseExprStatement, IsClassProperty,\n                        /*InOriginalClass*/ false);\n  } else if (ObjCInterfaceDecl *IFace =\n                 dyn_cast<ObjCInterfaceDecl>(Container)) {\n    if (AllowCategories) {\n      // Look through categories.\n      for (auto *Cat : IFace->known_categories())\n        AddObjCProperties(CCContext, Cat, AllowCategories, AllowNullaryMethods,\n                          CurContext, AddedProperties, Results,\n                          IsBaseExprStatement, IsClassProperty,\n                          InOriginalClass);\n    }\n\n    // Look through protocols.\n    for (auto *I : IFace->all_referenced_protocols())\n      AddObjCProperties(CCContext, I, AllowCategories, AllowNullaryMethods,\n                        CurContext, AddedProperties, Results,\n                        IsBaseExprStatement, IsClassProperty,\n                        /*InOriginalClass*/ false);\n\n    // Look in the superclass.\n    if (IFace->getSuperClass())\n      AddObjCProperties(CCContext, IFace->getSuperClass(), AllowCategories,\n                        AllowNullaryMethods, CurContext, AddedProperties,\n                        Results, IsBaseExprStatement, IsClassProperty,\n                        /*InOriginalClass*/ false);\n  } else if (const auto *Category =\n                 dyn_cast<ObjCCategoryDecl>(Container)) {\n    // Look through protocols.\n    for (auto *P : Category->protocols())\n      AddObjCProperties(CCContext, P, AllowCategories, AllowNullaryMethods,\n                        CurContext, AddedProperties, Results,\n                        IsBaseExprStatement, IsClassProperty,\n                        /*InOriginalClass*/ false);\n  }\n}\n\nstatic void AddRecordMembersCompletionResults(\n    Sema &SemaRef, ResultBuilder &Results, Scope *S, QualType BaseType,\n    ExprValueKind BaseKind, RecordDecl *RD, Optional<FixItHint> AccessOpFixIt) {\n  // Indicate that we are performing a member access, and the cv-qualifiers\n  // for the base object type.\n  Results.setObjectTypeQualifiers(BaseType.getQualifiers(), BaseKind);\n\n  // Access to a C/C++ class, struct, or union.\n  Results.allowNestedNameSpecifiers();\n  std::vector<FixItHint> FixIts;\n  if (AccessOpFixIt)\n    FixIts.emplace_back(AccessOpFixIt.getValue());\n  CodeCompletionDeclConsumer Consumer(Results, RD, BaseType, std::move(FixIts));\n  SemaRef.LookupVisibleDecls(RD, Sema::LookupMemberName, Consumer,\n                             SemaRef.CodeCompleter->includeGlobals(),\n                             /*IncludeDependentBases=*/true,\n                             SemaRef.CodeCompleter->loadExternal());\n\n  if (SemaRef.getLangOpts().CPlusPlus) {\n    if (!Results.empty()) {\n      // The \"template\" keyword can follow \"->\" or \".\" in the grammar.\n      // However, we only want to suggest the template keyword if something\n      // is dependent.\n      bool IsDependent = BaseType->isDependentType();\n      if (!IsDependent) {\n        for (Scope *DepScope = S; DepScope; DepScope = DepScope->getParent())\n          if (DeclContext *Ctx = DepScope->getEntity()) {\n            IsDependent = Ctx->isDependentContext();\n            break;\n          }\n      }\n\n      if (IsDependent)\n        Results.AddResult(CodeCompletionResult(\"template\"));\n    }\n  }\n}\n\n// Returns the RecordDecl inside the BaseType, falling back to primary template\n// in case of specializations. Since we might not have a decl for the\n// instantiation/specialization yet, e.g. dependent code.\nstatic RecordDecl *getAsRecordDecl(const QualType BaseType) {\n  if (auto *RD = BaseType->getAsRecordDecl()) {\n    if (const auto *CTSD =\n            llvm::dyn_cast<ClassTemplateSpecializationDecl>(RD)) {\n      // Template might not be instantiated yet, fall back to primary template\n      // in such cases.\n      if (CTSD->getTemplateSpecializationKind() == TSK_Undeclared)\n        RD = CTSD->getSpecializedTemplate()->getTemplatedDecl();\n    }\n    return RD;\n  }\n\n  if (const auto *TST = BaseType->getAs<TemplateSpecializationType>()) {\n    if (const auto *TD = dyn_cast_or_null<ClassTemplateDecl>(\n            TST->getTemplateName().getAsTemplateDecl())) {\n      return TD->getTemplatedDecl();\n    }\n  }\n\n  return nullptr;\n}\n\nnamespace {\n// Collects completion-relevant information about a concept-constrainted type T.\n// In particular, examines the constraint expressions to find members of T.\n//\n// The design is very simple: we walk down each constraint looking for\n// expressions of the form T.foo().\n// If we're extra lucky, the return type is specified.\n// We don't do any clever handling of && or || in constraint expressions, we\n// take members from both branches.\n//\n// For example, given:\n//   template <class T> concept X = requires (T t, string& s) { t.print(s); };\n//   template <X U> void foo(U u) { u.^ }\n// We want to suggest the inferred member function 'print(string)'.\n// We see that u has type U, so X<U> holds.\n// X<U> requires t.print(s) to be valid, where t has type U (substituted for T).\n// By looking at the CallExpr we find the signature of print().\n//\n// While we tend to know in advance which kind of members (access via . -> ::)\n// we want, it's simpler just to gather them all and post-filter.\n//\n// FIXME: some of this machinery could be used for non-concept type-parms too,\n// enabling completion for type parameters based on other uses of that param.\n//\n// FIXME: there are other cases where a type can be constrained by a concept,\n// e.g. inside `if constexpr(ConceptSpecializationExpr) { ... }`\nclass ConceptInfo {\npublic:\n  // Describes a likely member of a type, inferred by concept constraints.\n  // Offered as a code completion for T. T-> and T:: contexts.\n  struct Member {\n    // Always non-null: we only handle members with ordinary identifier names.\n    const IdentifierInfo *Name = nullptr;\n    // Set for functions we've seen called.\n    // We don't have the declared parameter types, only the actual types of\n    // arguments we've seen. These are still valuable, as it's hard to render\n    // a useful function completion with neither parameter types nor names!\n    llvm::Optional<SmallVector<QualType, 1>> ArgTypes;\n    // Whether this is accessed as T.member, T->member, or T::member.\n    enum AccessOperator {\n      Colons,\n      Arrow,\n      Dot,\n    } Operator = Dot;\n    // What's known about the type of a variable or return type of a function.\n    const TypeConstraint *ResultType = nullptr;\n    // FIXME: also track:\n    //   - kind of entity (function/variable/type), to expose structured results\n    //   - template args kinds/types, as a proxy for template params\n\n    // For now we simply return these results as \"pattern\" strings.\n    CodeCompletionString *render(Sema &S, CodeCompletionAllocator &Alloc,\n                                 CodeCompletionTUInfo &Info) const {\n      CodeCompletionBuilder B(Alloc, Info);\n      // Result type\n      if (ResultType) {\n        std::string AsString;\n        {\n          llvm::raw_string_ostream OS(AsString);\n          QualType ExactType = deduceType(*ResultType);\n          if (!ExactType.isNull())\n            ExactType.print(OS, getCompletionPrintingPolicy(S));\n          else\n            ResultType->print(OS, getCompletionPrintingPolicy(S));\n        }\n        B.AddResultTypeChunk(Alloc.CopyString(AsString));\n      }\n      // Member name\n      B.AddTypedTextChunk(Alloc.CopyString(Name->getName()));\n      // Function argument list\n      if (ArgTypes) {\n        B.AddChunk(clang::CodeCompletionString::CK_LeftParen);\n        bool First = true;\n        for (QualType Arg : *ArgTypes) {\n          if (First)\n            First = false;\n          else {\n            B.AddChunk(clang::CodeCompletionString::CK_Comma);\n            B.AddChunk(clang::CodeCompletionString::CK_HorizontalSpace);\n          }\n          B.AddPlaceholderChunk(Alloc.CopyString(\n              Arg.getAsString(getCompletionPrintingPolicy(S))));\n        }\n        B.AddChunk(clang::CodeCompletionString::CK_RightParen);\n      }\n      return B.TakeString();\n    }\n  };\n\n  // BaseType is the type parameter T to infer members from.\n  // T must be accessible within S, as we use it to find the template entity\n  // that T is attached to in order to gather the relevant constraints.\n  ConceptInfo(const TemplateTypeParmType &BaseType, Scope *S) {\n    auto *TemplatedEntity = getTemplatedEntity(BaseType.getDecl(), S);\n    for (const Expr *E : constraintsForTemplatedEntity(TemplatedEntity))\n      believe(E, &BaseType);\n  }\n\n  std::vector<Member> members() {\n    std::vector<Member> Results;\n    for (const auto &E : this->Results)\n      Results.push_back(E.second);\n    llvm::sort(Results, [](const Member &L, const Member &R) {\n      return L.Name->getName() < R.Name->getName();\n    });\n    return Results;\n  }\n\nprivate:\n  // Infer members of T, given that the expression E (dependent on T) is true.\n  void believe(const Expr *E, const TemplateTypeParmType *T) {\n    if (!E || !T)\n      return;\n    if (auto *CSE = dyn_cast<ConceptSpecializationExpr>(E)) {\n      // If the concept is\n      //   template <class A, class B> concept CD = f<A, B>();\n      // And the concept specialization is\n      //   CD<int, T>\n      // Then we're substituting T for B, so we want to make f<A, B>() true\n      // by adding members to B - i.e. believe(f<A, B>(), B);\n      //\n      // For simplicity:\n      // - we don't attempt to substitute int for A\n      // - when T is used in other ways (like CD<T*>) we ignore it\n      ConceptDecl *CD = CSE->getNamedConcept();\n      TemplateParameterList *Params = CD->getTemplateParameters();\n      unsigned Index = 0;\n      for (const auto &Arg : CSE->getTemplateArguments()) {\n        if (Index >= Params->size())\n          break; // Won't happen in valid code.\n        if (isApprox(Arg, T)) {\n          auto *TTPD = dyn_cast<TemplateTypeParmDecl>(Params->getParam(Index));\n          if (!TTPD)\n            continue;\n          // T was used as an argument, and bound to the parameter TT.\n          auto *TT = cast<TemplateTypeParmType>(TTPD->getTypeForDecl());\n          // So now we know the constraint as a function of TT is true.\n          believe(CD->getConstraintExpr(), TT);\n          // (concepts themselves have no associated constraints to require)\n        }\n\n        ++Index;\n      }\n    } else if (auto *BO = dyn_cast<BinaryOperator>(E)) {\n      // For A && B, we can infer members from both branches.\n      // For A || B, the union is still more useful than the intersection.\n      if (BO->getOpcode() == BO_LAnd || BO->getOpcode() == BO_LOr) {\n        believe(BO->getLHS(), T);\n        believe(BO->getRHS(), T);\n      }\n    } else if (auto *RE = dyn_cast<RequiresExpr>(E)) {\n      // A requires(){...} lets us infer members from each requirement.\n      for (const concepts::Requirement *Req : RE->getRequirements()) {\n        if (!Req->isDependent())\n          continue; // Can't tell us anything about T.\n        // Now Req cannot a substitution-error: those aren't dependent.\n\n        if (auto *TR = dyn_cast<concepts::TypeRequirement>(Req)) {\n          // Do a full traversal so we get `foo` from `typename T::foo::bar`.\n          QualType AssertedType = TR->getType()->getType();\n          ValidVisitor(this, T).TraverseType(AssertedType);\n        } else if (auto *ER = dyn_cast<concepts::ExprRequirement>(Req)) {\n          ValidVisitor Visitor(this, T);\n          // If we have a type constraint on the value of the expression,\n          // AND the whole outer expression describes a member, then we'll\n          // be able to use the constraint to provide the return type.\n          if (ER->getReturnTypeRequirement().isTypeConstraint()) {\n            Visitor.OuterType =\n                ER->getReturnTypeRequirement().getTypeConstraint();\n            Visitor.OuterExpr = ER->getExpr();\n          }\n          Visitor.TraverseStmt(ER->getExpr());\n        } else if (auto *NR = dyn_cast<concepts::NestedRequirement>(Req)) {\n          believe(NR->getConstraintExpr(), T);\n        }\n      }\n    }\n  }\n\n  // This visitor infers members of T based on traversing expressions/types\n  // that involve T. It is invoked with code known to be valid for T.\n  class ValidVisitor : public RecursiveASTVisitor<ValidVisitor> {\n    ConceptInfo *Outer;\n    const TemplateTypeParmType *T;\n\n    CallExpr *Caller = nullptr;\n    Expr *Callee = nullptr;\n\n  public:\n    // If set, OuterExpr is constrained by OuterType.\n    Expr *OuterExpr = nullptr;\n    const TypeConstraint *OuterType = nullptr;\n\n    ValidVisitor(ConceptInfo *Outer, const TemplateTypeParmType *T)\n        : Outer(Outer), T(T) {\n      assert(T);\n    }\n\n    // In T.foo or T->foo, `foo` is a member function/variable.\n    bool VisitCXXDependentScopeMemberExpr(CXXDependentScopeMemberExpr *E) {\n      const Type *Base = E->getBaseType().getTypePtr();\n      bool IsArrow = E->isArrow();\n      if (Base->isPointerType() && IsArrow) {\n        IsArrow = false;\n        Base = Base->getPointeeType().getTypePtr();\n      }\n      if (isApprox(Base, T))\n        addValue(E, E->getMember(), IsArrow ? Member::Arrow : Member::Dot);\n      return true;\n    }\n\n    // In T::foo, `foo` is a static member function/variable.\n    bool VisitDependentScopeDeclRefExpr(DependentScopeDeclRefExpr *E) {\n      if (E->getQualifier() && isApprox(E->getQualifier()->getAsType(), T))\n        addValue(E, E->getDeclName(), Member::Colons);\n      return true;\n    }\n\n    // In T::typename foo, `foo` is a type.\n    bool VisitDependentNameType(DependentNameType *DNT) {\n      const auto *Q = DNT->getQualifier();\n      if (Q && isApprox(Q->getAsType(), T))\n        addType(DNT->getIdentifier());\n      return true;\n    }\n\n    // In T::foo::bar, `foo` must be a type.\n    // VisitNNS() doesn't exist, and TraverseNNS isn't always called :-(\n    bool TraverseNestedNameSpecifierLoc(NestedNameSpecifierLoc NNSL) {\n      if (NNSL) {\n        NestedNameSpecifier *NNS = NNSL.getNestedNameSpecifier();\n        const auto *Q = NNS->getPrefix();\n        if (Q && isApprox(Q->getAsType(), T))\n          addType(NNS->getAsIdentifier());\n      }\n      // FIXME: also handle T::foo<X>::bar\n      return RecursiveASTVisitor::TraverseNestedNameSpecifierLoc(NNSL);\n    }\n\n    // FIXME also handle T::foo<X>\n\n    // Track the innermost caller/callee relationship so we can tell if a\n    // nested expr is being called as a function.\n    bool VisitCallExpr(CallExpr *CE) {\n      Caller = CE;\n      Callee = CE->getCallee();\n      return true;\n    }\n\n  private:\n    void addResult(Member &&M) {\n      auto R = Outer->Results.try_emplace(M.Name);\n      Member &O = R.first->second;\n      // Overwrite existing if the new member has more info.\n      // The preference of . vs :: vs -> is fairly arbitrary.\n      if (/*Inserted*/ R.second ||\n          std::make_tuple(M.ArgTypes.hasValue(), M.ResultType != nullptr,\n                          M.Operator) > std::make_tuple(O.ArgTypes.hasValue(),\n                                                        O.ResultType != nullptr,\n                                                        O.Operator))\n        O = std::move(M);\n    }\n\n    void addType(const IdentifierInfo *Name) {\n      if (!Name)\n        return;\n      Member M;\n      M.Name = Name;\n      M.Operator = Member::Colons;\n      addResult(std::move(M));\n    }\n\n    void addValue(Expr *E, DeclarationName Name,\n                  Member::AccessOperator Operator) {\n      if (!Name.isIdentifier())\n        return;\n      Member Result;\n      Result.Name = Name.getAsIdentifierInfo();\n      Result.Operator = Operator;\n      // If this is the callee of an immediately-enclosing CallExpr, then\n      // treat it as a method, otherwise it's a variable.\n      if (Caller != nullptr && Callee == E) {\n        Result.ArgTypes.emplace();\n        for (const auto *Arg : Caller->arguments())\n          Result.ArgTypes->push_back(Arg->getType());\n        if (Caller == OuterExpr) {\n          Result.ResultType = OuterType;\n        }\n      } else {\n        if (E == OuterExpr)\n          Result.ResultType = OuterType;\n      }\n      addResult(std::move(Result));\n    }\n  };\n\n  static bool isApprox(const TemplateArgument &Arg, const Type *T) {\n    return Arg.getKind() == TemplateArgument::Type &&\n           isApprox(Arg.getAsType().getTypePtr(), T);\n  }\n\n  static bool isApprox(const Type *T1, const Type *T2) {\n    return T1 && T2 &&\n           T1->getCanonicalTypeUnqualified() ==\n               T2->getCanonicalTypeUnqualified();\n  }\n\n  // Returns the DeclContext immediately enclosed by the template parameter\n  // scope. For primary templates, this is the templated (e.g.) CXXRecordDecl.\n  // For specializations, this is e.g. ClassTemplatePartialSpecializationDecl.\n  static DeclContext *getTemplatedEntity(const TemplateTypeParmDecl *D,\n                                         Scope *S) {\n    if (D == nullptr)\n      return nullptr;\n    Scope *Inner = nullptr;\n    while (S) {\n      if (S->isTemplateParamScope() && S->isDeclScope(D))\n        return Inner ? Inner->getEntity() : nullptr;\n      Inner = S;\n      S = S->getParent();\n    }\n    return nullptr;\n  }\n\n  // Gets all the type constraint expressions that might apply to the type\n  // variables associated with DC (as returned by getTemplatedEntity()).\n  static SmallVector<const Expr *, 1>\n  constraintsForTemplatedEntity(DeclContext *DC) {\n    SmallVector<const Expr *, 1> Result;\n    if (DC == nullptr)\n      return Result;\n    // Primary templates can have constraints.\n    if (const auto *TD = cast<Decl>(DC)->getDescribedTemplate())\n      TD->getAssociatedConstraints(Result);\n    // Partial specializations may have constraints.\n    if (const auto *CTPSD =\n            dyn_cast<ClassTemplatePartialSpecializationDecl>(DC))\n      CTPSD->getAssociatedConstraints(Result);\n    if (const auto *VTPSD = dyn_cast<VarTemplatePartialSpecializationDecl>(DC))\n      VTPSD->getAssociatedConstraints(Result);\n    return Result;\n  }\n\n  // Attempt to find the unique type satisfying a constraint.\n  // This lets us show e.g. `int` instead of `std::same_as<int>`.\n  static QualType deduceType(const TypeConstraint &T) {\n    // Assume a same_as<T> return type constraint is std::same_as or equivalent.\n    // In this case the return type is T.\n    DeclarationName DN = T.getNamedConcept()->getDeclName();\n    if (DN.isIdentifier() && DN.getAsIdentifierInfo()->isStr(\"same_as\"))\n      if (const auto *Args = T.getTemplateArgsAsWritten())\n        if (Args->getNumTemplateArgs() == 1) {\n          const auto &Arg = Args->arguments().front().getArgument();\n          if (Arg.getKind() == TemplateArgument::Type)\n            return Arg.getAsType();\n        }\n    return {};\n  }\n\n  llvm::DenseMap<const IdentifierInfo *, Member> Results;\n};\n\n// Returns a type for E that yields acceptable member completions.\n// In particular, when E->getType() is DependentTy, try to guess a likely type.\n// We accept some lossiness (like dropping parameters).\n// We only try to handle common expressions on the LHS of MemberExpr.\nQualType getApproximateType(const Expr *E) {\n  QualType Unresolved = E->getType();\n  if (Unresolved.isNull() ||\n      !Unresolved->isSpecificBuiltinType(BuiltinType::Dependent))\n    return Unresolved;\n  E = E->IgnoreParens();\n  // A call: approximate-resolve callee to a function type, get its return type\n  if (const CallExpr *CE = llvm::dyn_cast<CallExpr>(E)) {\n    QualType Callee = getApproximateType(CE->getCallee());\n    if (Callee.isNull() ||\n        Callee->isSpecificPlaceholderType(BuiltinType::BoundMember))\n      Callee = Expr::findBoundMemberType(CE->getCallee());\n    if (Callee.isNull())\n      return Unresolved;\n\n    if (const auto *FnTypePtr = Callee->getAs<PointerType>()) {\n      Callee = FnTypePtr->getPointeeType();\n    } else if (const auto *BPT = Callee->getAs<BlockPointerType>()) {\n      Callee = BPT->getPointeeType();\n    }\n    if (const FunctionType *FnType = Callee->getAs<FunctionType>())\n      return FnType->getReturnType().getNonReferenceType();\n\n    // Unresolved call: try to guess the return type.\n    if (const auto *OE = llvm::dyn_cast<OverloadExpr>(CE->getCallee())) {\n      // If all candidates have the same approximate return type, use it.\n      // Discard references and const to allow more to be \"the same\".\n      // (In particular, if there's one candidate + ADL, resolve it).\n      const Type *Common = nullptr;\n      for (const auto *D : OE->decls()) {\n        QualType ReturnType;\n        if (const auto *FD = llvm::dyn_cast<FunctionDecl>(D))\n          ReturnType = FD->getReturnType();\n        else if (const auto *FTD = llvm::dyn_cast<FunctionTemplateDecl>(D))\n          ReturnType = FTD->getTemplatedDecl()->getReturnType();\n        if (ReturnType.isNull())\n          continue;\n        const Type *Candidate =\n            ReturnType.getNonReferenceType().getCanonicalType().getTypePtr();\n        if (Common && Common != Candidate)\n          return Unresolved; // Multiple candidates.\n        Common = Candidate;\n      }\n      if (Common != nullptr)\n        return QualType(Common, 0);\n    }\n  }\n  // A dependent member: approximate-resolve the base, then lookup.\n  if (const auto *CDSME = llvm::dyn_cast<CXXDependentScopeMemberExpr>(E)) {\n    QualType Base = CDSME->isImplicitAccess()\n                        ? CDSME->getBaseType()\n                        : getApproximateType(CDSME->getBase());\n    if (CDSME->isArrow() && !Base.isNull())\n      Base = Base->getPointeeType(); // could handle unique_ptr etc here?\n    RecordDecl *RD = Base.isNull() ? nullptr : getAsRecordDecl(Base);\n    if (RD && RD->isCompleteDefinition()) {\n      for (const auto &Member : RD->lookup(CDSME->getMember()))\n        if (const ValueDecl *VD = llvm::dyn_cast<ValueDecl>(Member))\n          return VD->getType().getNonReferenceType();\n    }\n  }\n  return Unresolved;\n}\n\n// If \\p Base is ParenListExpr, assume a chain of comma operators and pick the\n// last expr. We expect other ParenListExprs to be resolved to e.g. constructor\n// calls before here. (So the ParenListExpr should be nonempty, but check just\n// in case)\nExpr *unwrapParenList(Expr *Base) {\n  if (auto *PLE = llvm::dyn_cast_or_null<ParenListExpr>(Base)) {\n    if (PLE->getNumExprs() == 0)\n      return nullptr;\n    Base = PLE->getExpr(PLE->getNumExprs() - 1);\n  }\n  return Base;\n}\n\n} // namespace\n\nvoid Sema::CodeCompleteMemberReferenceExpr(Scope *S, Expr *Base,\n                                           Expr *OtherOpBase,\n                                           SourceLocation OpLoc, bool IsArrow,\n                                           bool IsBaseExprStatement,\n                                           QualType PreferredType) {\n  Base = unwrapParenList(Base);\n  OtherOpBase = unwrapParenList(OtherOpBase);\n  if (!Base || !CodeCompleter)\n    return;\n\n  ExprResult ConvertedBase = PerformMemberExprBaseConversion(Base, IsArrow);\n  if (ConvertedBase.isInvalid())\n    return;\n  QualType ConvertedBaseType = getApproximateType(ConvertedBase.get());\n\n  enum CodeCompletionContext::Kind contextKind;\n\n  if (IsArrow) {\n    if (const auto *Ptr = ConvertedBaseType->getAs<PointerType>())\n      ConvertedBaseType = Ptr->getPointeeType();\n  }\n\n  if (IsArrow) {\n    contextKind = CodeCompletionContext::CCC_ArrowMemberAccess;\n  } else {\n    if (ConvertedBaseType->isObjCObjectPointerType() ||\n        ConvertedBaseType->isObjCObjectOrInterfaceType()) {\n      contextKind = CodeCompletionContext::CCC_ObjCPropertyAccess;\n    } else {\n      contextKind = CodeCompletionContext::CCC_DotMemberAccess;\n    }\n  }\n\n  CodeCompletionContext CCContext(contextKind, ConvertedBaseType);\n  CCContext.setPreferredType(PreferredType);\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(), CCContext,\n                        &ResultBuilder::IsMember);\n\n  auto DoCompletion = [&](Expr *Base, bool IsArrow,\n                          Optional<FixItHint> AccessOpFixIt) -> bool {\n    if (!Base)\n      return false;\n\n    ExprResult ConvertedBase = PerformMemberExprBaseConversion(Base, IsArrow);\n    if (ConvertedBase.isInvalid())\n      return false;\n    Base = ConvertedBase.get();\n\n    QualType BaseType = getApproximateType(Base);\n    if (BaseType.isNull())\n      return false;\n    ExprValueKind BaseKind = Base->getValueKind();\n\n    if (IsArrow) {\n      if (const PointerType *Ptr = BaseType->getAs<PointerType>()) {\n        BaseType = Ptr->getPointeeType();\n        BaseKind = VK_LValue;\n      } else if (BaseType->isObjCObjectPointerType() ||\n                 BaseType->isTemplateTypeParmType()) {\n        // Both cases (dot/arrow) handled below.\n      } else {\n        return false;\n      }\n    }\n\n    if (RecordDecl *RD = getAsRecordDecl(BaseType)) {\n      AddRecordMembersCompletionResults(*this, Results, S, BaseType, BaseKind,\n                                        RD, std::move(AccessOpFixIt));\n    } else if (const auto *TTPT =\n                   dyn_cast<TemplateTypeParmType>(BaseType.getTypePtr())) {\n      auto Operator =\n          IsArrow ? ConceptInfo::Member::Arrow : ConceptInfo::Member::Dot;\n      for (const auto &R : ConceptInfo(*TTPT, S).members()) {\n        if (R.Operator != Operator)\n          continue;\n        CodeCompletionResult Result(\n            R.render(*this, CodeCompleter->getAllocator(),\n                     CodeCompleter->getCodeCompletionTUInfo()));\n        if (AccessOpFixIt)\n          Result.FixIts.push_back(*AccessOpFixIt);\n        Results.AddResult(std::move(Result));\n      }\n    } else if (!IsArrow && BaseType->isObjCObjectPointerType()) {\n      // Objective-C property reference. Bail if we're performing fix-it code\n      // completion since Objective-C properties are normally backed by ivars,\n      // most Objective-C fix-its here would have little value.\n      if (AccessOpFixIt.hasValue()) {\n        return false;\n      }\n      AddedPropertiesSet AddedProperties;\n\n      if (const ObjCObjectPointerType *ObjCPtr =\n              BaseType->getAsObjCInterfacePointerType()) {\n        // Add property results based on our interface.\n        assert(ObjCPtr && \"Non-NULL pointer guaranteed above!\");\n        AddObjCProperties(CCContext, ObjCPtr->getInterfaceDecl(), true,\n                          /*AllowNullaryMethods=*/true, CurContext,\n                          AddedProperties, Results, IsBaseExprStatement);\n      }\n\n      // Add properties from the protocols in a qualified interface.\n      for (auto *I : BaseType->castAs<ObjCObjectPointerType>()->quals())\n        AddObjCProperties(CCContext, I, true, /*AllowNullaryMethods=*/true,\n                          CurContext, AddedProperties, Results,\n                          IsBaseExprStatement, /*IsClassProperty*/ false,\n                          /*InOriginalClass*/ false);\n    } else if ((IsArrow && BaseType->isObjCObjectPointerType()) ||\n               (!IsArrow && BaseType->isObjCObjectType())) {\n      // Objective-C instance variable access. Bail if we're performing fix-it\n      // code completion since Objective-C properties are normally backed by\n      // ivars, most Objective-C fix-its here would have little value.\n      if (AccessOpFixIt.hasValue()) {\n        return false;\n      }\n      ObjCInterfaceDecl *Class = nullptr;\n      if (const ObjCObjectPointerType *ObjCPtr =\n              BaseType->getAs<ObjCObjectPointerType>())\n        Class = ObjCPtr->getInterfaceDecl();\n      else\n        Class = BaseType->castAs<ObjCObjectType>()->getInterface();\n\n      // Add all ivars from this class and its superclasses.\n      if (Class) {\n        CodeCompletionDeclConsumer Consumer(Results, Class, BaseType);\n        Results.setFilter(&ResultBuilder::IsObjCIvar);\n        LookupVisibleDecls(\n            Class, LookupMemberName, Consumer, CodeCompleter->includeGlobals(),\n            /*IncludeDependentBases=*/false, CodeCompleter->loadExternal());\n      }\n    }\n\n    // FIXME: How do we cope with isa?\n    return true;\n  };\n\n  Results.EnterNewScope();\n\n  bool CompletionSucceded = DoCompletion(Base, IsArrow, None);\n  if (CodeCompleter->includeFixIts()) {\n    const CharSourceRange OpRange =\n        CharSourceRange::getTokenRange(OpLoc, OpLoc);\n    CompletionSucceded |= DoCompletion(\n        OtherOpBase, !IsArrow,\n        FixItHint::CreateReplacement(OpRange, IsArrow ? \".\" : \"->\"));\n  }\n\n  Results.ExitScope();\n\n  if (!CompletionSucceded)\n    return;\n\n  // Hand off the results found for code completion.\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCClassPropertyRefExpr(Scope *S,\n                                                IdentifierInfo &ClassName,\n                                                SourceLocation ClassNameLoc,\n                                                bool IsBaseExprStatement) {\n  IdentifierInfo *ClassNamePtr = &ClassName;\n  ObjCInterfaceDecl *IFace = getObjCInterfaceDecl(ClassNamePtr, ClassNameLoc);\n  if (!IFace)\n    return;\n  CodeCompletionContext CCContext(\n      CodeCompletionContext::CCC_ObjCPropertyAccess);\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(), CCContext,\n                        &ResultBuilder::IsMember);\n  Results.EnterNewScope();\n  AddedPropertiesSet AddedProperties;\n  AddObjCProperties(CCContext, IFace, true,\n                    /*AllowNullaryMethods=*/true, CurContext, AddedProperties,\n                    Results, IsBaseExprStatement,\n                    /*IsClassProperty=*/true);\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteTag(Scope *S, unsigned TagSpec) {\n  if (!CodeCompleter)\n    return;\n\n  ResultBuilder::LookupFilter Filter = nullptr;\n  enum CodeCompletionContext::Kind ContextKind =\n      CodeCompletionContext::CCC_Other;\n  switch ((DeclSpec::TST)TagSpec) {\n  case DeclSpec::TST_enum:\n    Filter = &ResultBuilder::IsEnum;\n    ContextKind = CodeCompletionContext::CCC_EnumTag;\n    break;\n\n  case DeclSpec::TST_union:\n    Filter = &ResultBuilder::IsUnion;\n    ContextKind = CodeCompletionContext::CCC_UnionTag;\n    break;\n\n  case DeclSpec::TST_struct:\n  case DeclSpec::TST_class:\n  case DeclSpec::TST_interface:\n    Filter = &ResultBuilder::IsClassOrStruct;\n    ContextKind = CodeCompletionContext::CCC_ClassOrStructTag;\n    break;\n\n  default:\n    llvm_unreachable(\"Unknown type specifier kind in CodeCompleteTag\");\n  }\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(), ContextKind);\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n\n  // First pass: look for tags.\n  Results.setFilter(Filter);\n  LookupVisibleDecls(S, LookupTagName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n\n  if (CodeCompleter->includeGlobals()) {\n    // Second pass: look for nested name specifiers.\n    Results.setFilter(&ResultBuilder::IsNestedNameSpecifier);\n    LookupVisibleDecls(S, LookupNestedNameSpecifierName, Consumer,\n                       CodeCompleter->includeGlobals(),\n                       CodeCompleter->loadExternal());\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nstatic void AddTypeQualifierResults(DeclSpec &DS, ResultBuilder &Results,\n                                    const LangOptions &LangOpts) {\n  if (!(DS.getTypeQualifiers() & DeclSpec::TQ_const))\n    Results.AddResult(\"const\");\n  if (!(DS.getTypeQualifiers() & DeclSpec::TQ_volatile))\n    Results.AddResult(\"volatile\");\n  if (LangOpts.C99 && !(DS.getTypeQualifiers() & DeclSpec::TQ_restrict))\n    Results.AddResult(\"restrict\");\n  if (LangOpts.C11 && !(DS.getTypeQualifiers() & DeclSpec::TQ_atomic))\n    Results.AddResult(\"_Atomic\");\n  if (LangOpts.MSVCCompat && !(DS.getTypeQualifiers() & DeclSpec::TQ_unaligned))\n    Results.AddResult(\"__unaligned\");\n}\n\nvoid Sema::CodeCompleteTypeQualifiers(DeclSpec &DS) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_TypeQualifiers);\n  Results.EnterNewScope();\n  AddTypeQualifierResults(DS, Results, LangOpts);\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteFunctionQualifiers(DeclSpec &DS, Declarator &D,\n                                          const VirtSpecifiers *VS) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_TypeQualifiers);\n  Results.EnterNewScope();\n  AddTypeQualifierResults(DS, Results, LangOpts);\n  if (LangOpts.CPlusPlus11) {\n    Results.AddResult(\"noexcept\");\n    if (D.getContext() == DeclaratorContext::Member && !D.isCtorOrDtor() &&\n        !D.isStaticMember()) {\n      if (!VS || !VS->isFinalSpecified())\n        Results.AddResult(\"final\");\n      if (!VS || !VS->isOverrideSpecified())\n        Results.AddResult(\"override\");\n    }\n  }\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteBracketDeclarator(Scope *S) {\n  CodeCompleteExpression(S, QualType(getASTContext().getSizeType()));\n}\n\nvoid Sema::CodeCompleteCase(Scope *S) {\n  if (getCurFunction()->SwitchStack.empty() || !CodeCompleter)\n    return;\n\n  SwitchStmt *Switch = getCurFunction()->SwitchStack.back().getPointer();\n  // Condition expression might be invalid, do not continue in this case.\n  if (!Switch->getCond())\n    return;\n  QualType type = Switch->getCond()->IgnoreImplicit()->getType();\n  if (!type->isEnumeralType()) {\n    CodeCompleteExpressionData Data(type);\n    Data.IntegralConstantExpression = true;\n    CodeCompleteExpression(S, Data);\n    return;\n  }\n\n  // Code-complete the cases of a switch statement over an enumeration type\n  // by providing the list of\n  EnumDecl *Enum = type->castAs<EnumType>()->getDecl();\n  if (EnumDecl *Def = Enum->getDefinition())\n    Enum = Def;\n\n  // Determine which enumerators we have already seen in the switch statement.\n  // FIXME: Ideally, we would also be able to look *past* the code-completion\n  // token, in case we are code-completing in the middle of the switch and not\n  // at the end. However, we aren't able to do so at the moment.\n  CoveredEnumerators Enumerators;\n  for (SwitchCase *SC = Switch->getSwitchCaseList(); SC;\n       SC = SC->getNextSwitchCase()) {\n    CaseStmt *Case = dyn_cast<CaseStmt>(SC);\n    if (!Case)\n      continue;\n\n    Expr *CaseVal = Case->getLHS()->IgnoreParenCasts();\n    if (auto *DRE = dyn_cast<DeclRefExpr>(CaseVal))\n      if (auto *Enumerator =\n              dyn_cast<EnumConstantDecl>(DRE->getDecl())) {\n        // We look into the AST of the case statement to determine which\n        // enumerator was named. Alternatively, we could compute the value of\n        // the integral constant expression, then compare it against the\n        // values of each enumerator. However, value-based approach would not\n        // work as well with C++ templates where enumerators declared within a\n        // template are type- and value-dependent.\n        Enumerators.Seen.insert(Enumerator);\n\n        // If this is a qualified-id, keep track of the nested-name-specifier\n        // so that we can reproduce it as part of code completion, e.g.,\n        //\n        //   switch (TagD.getKind()) {\n        //     case TagDecl::TK_enum:\n        //       break;\n        //     case XXX\n        //\n        // At the XXX, our completions are TagDecl::TK_union,\n        // TagDecl::TK_struct, and TagDecl::TK_class, rather than TK_union,\n        // TK_struct, and TK_class.\n        Enumerators.SuggestedQualifier = DRE->getQualifier();\n      }\n  }\n\n  // Add any enumerators that have not yet been mentioned.\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Expression);\n  AddEnumerators(Results, Context, Enum, CurContext, Enumerators);\n\n  if (CodeCompleter->includeMacros()) {\n    AddMacroResults(PP, Results, CodeCompleter->loadExternal(), false);\n  }\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nstatic bool anyNullArguments(ArrayRef<Expr *> Args) {\n  if (Args.size() && !Args.data())\n    return true;\n\n  for (unsigned I = 0; I != Args.size(); ++I)\n    if (!Args[I])\n      return true;\n\n  return false;\n}\n\ntypedef CodeCompleteConsumer::OverloadCandidate ResultCandidate;\n\nstatic void mergeCandidatesWithResults(\n    Sema &SemaRef, SmallVectorImpl<ResultCandidate> &Results,\n    OverloadCandidateSet &CandidateSet, SourceLocation Loc, size_t ArgSize) {\n  // Sort the overload candidate set by placing the best overloads first.\n  llvm::stable_sort(CandidateSet, [&](const OverloadCandidate &X,\n                                      const OverloadCandidate &Y) {\n    return isBetterOverloadCandidate(SemaRef, X, Y, Loc,\n                                     CandidateSet.getKind());\n  });\n\n  // Add the remaining viable overload candidates as code-completion results.\n  for (OverloadCandidate &Candidate : CandidateSet) {\n    if (Candidate.Function) {\n      if (Candidate.Function->isDeleted())\n        continue;\n      if (!Candidate.Function->isVariadic() &&\n          Candidate.Function->getNumParams() <= ArgSize &&\n          // Having zero args is annoying, normally we don't surface a function\n          // with 2 params, if you already have 2 params, because you are\n          // inserting the 3rd now. But with zero, it helps the user to figure\n          // out there are no overloads that take any arguments. Hence we are\n          // keeping the overload.\n          ArgSize > 0)\n        continue;\n    }\n    if (Candidate.Viable)\n      Results.push_back(ResultCandidate(Candidate.Function));\n  }\n}\n\n/// Get the type of the Nth parameter from a given set of overload\n/// candidates.\nstatic QualType getParamType(Sema &SemaRef,\n                             ArrayRef<ResultCandidate> Candidates, unsigned N) {\n\n  // Given the overloads 'Candidates' for a function call matching all arguments\n  // up to N, return the type of the Nth parameter if it is the same for all\n  // overload candidates.\n  QualType ParamType;\n  for (auto &Candidate : Candidates) {\n    if (const auto *FType = Candidate.getFunctionType())\n      if (const auto *Proto = dyn_cast<FunctionProtoType>(FType))\n        if (N < Proto->getNumParams()) {\n          if (ParamType.isNull())\n            ParamType = Proto->getParamType(N);\n          else if (!SemaRef.Context.hasSameUnqualifiedType(\n                       ParamType.getNonReferenceType(),\n                       Proto->getParamType(N).getNonReferenceType()))\n            // Otherwise return a default-constructed QualType.\n            return QualType();\n        }\n  }\n\n  return ParamType;\n}\n\nstatic QualType\nProduceSignatureHelp(Sema &SemaRef, Scope *S,\n                     MutableArrayRef<ResultCandidate> Candidates,\n                     unsigned CurrentArg, SourceLocation OpenParLoc) {\n  if (Candidates.empty())\n    return QualType();\n  SemaRef.CodeCompleter->ProcessOverloadCandidates(\n      SemaRef, CurrentArg, Candidates.data(), Candidates.size(), OpenParLoc);\n  return getParamType(SemaRef, Candidates, CurrentArg);\n}\n\nQualType Sema::ProduceCallSignatureHelp(Scope *S, Expr *Fn,\n                                        ArrayRef<Expr *> Args,\n                                        SourceLocation OpenParLoc) {\n  Fn = unwrapParenList(Fn);\n  if (!CodeCompleter || !Fn)\n    return QualType();\n\n  // FIXME: Provide support for variadic template functions.\n  // Ignore type-dependent call expressions entirely.\n  if (Fn->isTypeDependent() || anyNullArguments(Args))\n    return QualType();\n  // In presence of dependent args we surface all possible signatures using the\n  // non-dependent args in the prefix. Afterwards we do a post filtering to make\n  // sure provided candidates satisfy parameter count restrictions.\n  auto ArgsWithoutDependentTypes =\n      Args.take_while([](Expr *Arg) { return !Arg->isTypeDependent(); });\n\n  SmallVector<ResultCandidate, 8> Results;\n\n  Expr *NakedFn = Fn->IgnoreParenCasts();\n  // Build an overload candidate set based on the functions we find.\n  SourceLocation Loc = Fn->getExprLoc();\n  OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);\n\n  if (auto ULE = dyn_cast<UnresolvedLookupExpr>(NakedFn)) {\n    AddOverloadedCallCandidates(ULE, ArgsWithoutDependentTypes, CandidateSet,\n                                /*PartialOverloading=*/true);\n  } else if (auto UME = dyn_cast<UnresolvedMemberExpr>(NakedFn)) {\n    TemplateArgumentListInfo TemplateArgsBuffer, *TemplateArgs = nullptr;\n    if (UME->hasExplicitTemplateArgs()) {\n      UME->copyTemplateArgumentsInto(TemplateArgsBuffer);\n      TemplateArgs = &TemplateArgsBuffer;\n    }\n\n    // Add the base as first argument (use a nullptr if the base is implicit).\n    SmallVector<Expr *, 12> ArgExprs(\n        1, UME->isImplicitAccess() ? nullptr : UME->getBase());\n    ArgExprs.append(ArgsWithoutDependentTypes.begin(),\n                    ArgsWithoutDependentTypes.end());\n    UnresolvedSet<8> Decls;\n    Decls.append(UME->decls_begin(), UME->decls_end());\n    const bool FirstArgumentIsBase = !UME->isImplicitAccess() && UME->getBase();\n    AddFunctionCandidates(Decls, ArgExprs, CandidateSet, TemplateArgs,\n                          /*SuppressUserConversions=*/false,\n                          /*PartialOverloading=*/true, FirstArgumentIsBase);\n  } else {\n    FunctionDecl *FD = nullptr;\n    if (auto *MCE = dyn_cast<MemberExpr>(NakedFn))\n      FD = dyn_cast<FunctionDecl>(MCE->getMemberDecl());\n    else if (auto *DRE = dyn_cast<DeclRefExpr>(NakedFn))\n      FD = dyn_cast<FunctionDecl>(DRE->getDecl());\n    if (FD) { // We check whether it's a resolved function declaration.\n      if (!getLangOpts().CPlusPlus ||\n          !FD->getType()->getAs<FunctionProtoType>())\n        Results.push_back(ResultCandidate(FD));\n      else\n        AddOverloadCandidate(FD, DeclAccessPair::make(FD, FD->getAccess()),\n                             ArgsWithoutDependentTypes, CandidateSet,\n                             /*SuppressUserConversions=*/false,\n                             /*PartialOverloading=*/true);\n\n    } else if (auto DC = NakedFn->getType()->getAsCXXRecordDecl()) {\n      // If expression's type is CXXRecordDecl, it may overload the function\n      // call operator, so we check if it does and add them as candidates.\n      // A complete type is needed to lookup for member function call operators.\n      if (isCompleteType(Loc, NakedFn->getType())) {\n        DeclarationName OpName =\n            Context.DeclarationNames.getCXXOperatorName(OO_Call);\n        LookupResult R(*this, OpName, Loc, LookupOrdinaryName);\n        LookupQualifiedName(R, DC);\n        R.suppressDiagnostics();\n        SmallVector<Expr *, 12> ArgExprs(1, NakedFn);\n        ArgExprs.append(ArgsWithoutDependentTypes.begin(),\n                        ArgsWithoutDependentTypes.end());\n        AddFunctionCandidates(R.asUnresolvedSet(), ArgExprs, CandidateSet,\n                              /*ExplicitArgs=*/nullptr,\n                              /*SuppressUserConversions=*/false,\n                              /*PartialOverloading=*/true);\n      }\n    } else {\n      // Lastly we check whether expression's type is function pointer or\n      // function.\n      QualType T = NakedFn->getType();\n      if (!T->getPointeeType().isNull())\n        T = T->getPointeeType();\n\n      if (auto FP = T->getAs<FunctionProtoType>()) {\n        if (!TooManyArguments(FP->getNumParams(),\n                              ArgsWithoutDependentTypes.size(),\n                              /*PartialOverloading=*/true) ||\n            FP->isVariadic())\n          Results.push_back(ResultCandidate(FP));\n      } else if (auto FT = T->getAs<FunctionType>())\n        // No prototype and declaration, it may be a K & R style function.\n        Results.push_back(ResultCandidate(FT));\n    }\n  }\n  mergeCandidatesWithResults(*this, Results, CandidateSet, Loc, Args.size());\n  QualType ParamType =\n      ProduceSignatureHelp(*this, S, Results, Args.size(), OpenParLoc);\n  return !CandidateSet.empty() ? ParamType : QualType();\n}\n\nQualType Sema::ProduceConstructorSignatureHelp(Scope *S, QualType Type,\n                                               SourceLocation Loc,\n                                               ArrayRef<Expr *> Args,\n                                               SourceLocation OpenParLoc) {\n  if (!CodeCompleter)\n    return QualType();\n\n  // A complete type is needed to lookup for constructors.\n  CXXRecordDecl *RD =\n      isCompleteType(Loc, Type) ? Type->getAsCXXRecordDecl() : nullptr;\n  if (!RD)\n    return Type;\n\n  // FIXME: Provide support for member initializers.\n  // FIXME: Provide support for variadic template constructors.\n\n  OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);\n\n  for (NamedDecl *C : LookupConstructors(RD)) {\n    if (auto *FD = dyn_cast<FunctionDecl>(C)) {\n      AddOverloadCandidate(FD, DeclAccessPair::make(FD, C->getAccess()), Args,\n                           CandidateSet,\n                           /*SuppressUserConversions=*/false,\n                           /*PartialOverloading=*/true,\n                           /*AllowExplicit*/ true);\n    } else if (auto *FTD = dyn_cast<FunctionTemplateDecl>(C)) {\n      AddTemplateOverloadCandidate(\n          FTD, DeclAccessPair::make(FTD, C->getAccess()),\n          /*ExplicitTemplateArgs=*/nullptr, Args, CandidateSet,\n          /*SuppressUserConversions=*/false,\n          /*PartialOverloading=*/true);\n    }\n  }\n\n  SmallVector<ResultCandidate, 8> Results;\n  mergeCandidatesWithResults(*this, Results, CandidateSet, Loc, Args.size());\n  return ProduceSignatureHelp(*this, S, Results, Args.size(), OpenParLoc);\n}\n\nQualType Sema::ProduceCtorInitMemberSignatureHelp(\n    Scope *S, Decl *ConstructorDecl, CXXScopeSpec SS, ParsedType TemplateTypeTy,\n    ArrayRef<Expr *> ArgExprs, IdentifierInfo *II, SourceLocation OpenParLoc) {\n  if (!CodeCompleter)\n    return QualType();\n\n  CXXConstructorDecl *Constructor =\n      dyn_cast<CXXConstructorDecl>(ConstructorDecl);\n  if (!Constructor)\n    return QualType();\n  // FIXME: Add support for Base class constructors as well.\n  if (ValueDecl *MemberDecl = tryLookupCtorInitMemberDecl(\n          Constructor->getParent(), SS, TemplateTypeTy, II))\n    return ProduceConstructorSignatureHelp(getCurScope(), MemberDecl->getType(),\n                                           MemberDecl->getLocation(), ArgExprs,\n                                           OpenParLoc);\n  return QualType();\n}\n\nstatic QualType getDesignatedType(QualType BaseType, const Designation &Desig) {\n  for (unsigned I = 0; I < Desig.getNumDesignators(); ++I) {\n    if (BaseType.isNull())\n      break;\n    QualType NextType;\n    const auto &D = Desig.getDesignator(I);\n    if (D.isArrayDesignator() || D.isArrayRangeDesignator()) {\n      if (BaseType->isArrayType())\n        NextType = BaseType->getAsArrayTypeUnsafe()->getElementType();\n    } else {\n      assert(D.isFieldDesignator());\n      auto *RD = getAsRecordDecl(BaseType);\n      if (RD && RD->isCompleteDefinition()) {\n        for (const auto &Member : RD->lookup(D.getField()))\n          if (const FieldDecl *FD = llvm::dyn_cast<FieldDecl>(Member)) {\n            NextType = FD->getType();\n            break;\n          }\n      }\n    }\n    BaseType = NextType;\n  }\n  return BaseType;\n}\n\nvoid Sema::CodeCompleteDesignator(QualType BaseType,\n                                  llvm::ArrayRef<Expr *> InitExprs,\n                                  const Designation &D) {\n  BaseType = getDesignatedType(BaseType, D);\n  if (BaseType.isNull())\n    return;\n  const auto *RD = getAsRecordDecl(BaseType);\n  if (!RD || RD->fields().empty())\n    return;\n\n  CodeCompletionContext CCC(CodeCompletionContext::CCC_DotMemberAccess,\n                            BaseType);\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(), CCC);\n\n  Results.EnterNewScope();\n  for (const auto *FD : RD->fields()) {\n    // FIXME: Make use of previous designators to mark any fields before those\n    // inaccessible, and also compute the next initializer priority.\n    ResultBuilder::Result Result(FD, Results.getBasePriority(FD));\n    Results.AddResult(Result, CurContext, /*Hiding=*/nullptr);\n  }\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteInitializer(Scope *S, Decl *D) {\n  ValueDecl *VD = dyn_cast_or_null<ValueDecl>(D);\n  if (!VD) {\n    CodeCompleteOrdinaryName(S, PCC_Expression);\n    return;\n  }\n\n  CodeCompleteExpressionData Data;\n  Data.PreferredType = VD->getType();\n  // Ignore VD to avoid completing the variable itself, e.g. in 'int foo = ^'.\n  Data.IgnoreDecls.push_back(VD);\n\n  CodeCompleteExpression(S, Data);\n}\n\nvoid Sema::CodeCompleteAfterIf(Scope *S, bool IsBracedThen) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        mapCodeCompletionContext(*this, PCC_Statement));\n  Results.setFilter(&ResultBuilder::IsOrdinaryName);\n  Results.EnterNewScope();\n\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n\n  AddOrdinaryNameResults(PCC_Statement, S, *this, Results);\n\n  // \"else\" block\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n\n  auto AddElseBodyPattern = [&] {\n    if (IsBracedThen) {\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddPlaceholderChunk(\"statements\");\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n    } else {\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddPlaceholderChunk(\"statement\");\n      Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n    }\n  };\n  Builder.AddTypedTextChunk(\"else\");\n  if (Results.includeCodePatterns())\n    AddElseBodyPattern();\n  Results.AddResult(Builder.TakeString());\n\n  // \"else if\" block\n  Builder.AddTypedTextChunk(\"else if\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n  if (getLangOpts().CPlusPlus)\n    Builder.AddPlaceholderChunk(\"condition\");\n  else\n    Builder.AddPlaceholderChunk(\"expression\");\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n  if (Results.includeCodePatterns()) {\n    AddElseBodyPattern();\n  }\n  Results.AddResult(Builder.TakeString());\n\n  Results.ExitScope();\n\n  if (S->getFnParent())\n    AddPrettyFunctionResults(getLangOpts(), Results);\n\n  if (CodeCompleter->includeMacros())\n    AddMacroResults(PP, Results, CodeCompleter->loadExternal(), false);\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteQualifiedId(Scope *S, CXXScopeSpec &SS,\n                                   bool EnteringContext,\n                                   bool IsUsingDeclaration, QualType BaseType,\n                                   QualType PreferredType) {\n  if (SS.isEmpty() || !CodeCompleter)\n    return;\n\n  CodeCompletionContext CC(CodeCompletionContext::CCC_Symbol, PreferredType);\n  CC.setIsUsingDeclaration(IsUsingDeclaration);\n  CC.setCXXScopeSpecifier(SS);\n\n  // We want to keep the scope specifier even if it's invalid (e.g. the scope\n  // \"a::b::\" is not corresponding to any context/namespace in the AST), since\n  // it can be useful for global code completion which have information about\n  // contexts/symbols that are not in the AST.\n  if (SS.isInvalid()) {\n    // As SS is invalid, we try to collect accessible contexts from the current\n    // scope with a dummy lookup so that the completion consumer can try to\n    // guess what the specified scope is.\n    ResultBuilder DummyResults(*this, CodeCompleter->getAllocator(),\n                               CodeCompleter->getCodeCompletionTUInfo(), CC);\n    if (!PreferredType.isNull())\n      DummyResults.setPreferredType(PreferredType);\n    if (S->getEntity()) {\n      CodeCompletionDeclConsumer Consumer(DummyResults, S->getEntity(),\n                                          BaseType);\n      LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                         /*IncludeGlobalScope=*/false,\n                         /*LoadExternal=*/false);\n    }\n    HandleCodeCompleteResults(this, CodeCompleter,\n                              DummyResults.getCompletionContext(), nullptr, 0);\n    return;\n  }\n  // Always pretend to enter a context to ensure that a dependent type\n  // resolves to a dependent record.\n  DeclContext *Ctx = computeDeclContext(SS, /*EnteringContext=*/true);\n\n  // Try to instantiate any non-dependent declaration contexts before\n  // we look in them. Bail out if we fail.\n  NestedNameSpecifier *NNS = SS.getScopeRep();\n  if (NNS != nullptr && SS.isValid() && !NNS->isDependent()) {\n    if (Ctx == nullptr || RequireCompleteDeclContext(SS, Ctx))\n      return;\n  }\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(), CC);\n  if (!PreferredType.isNull())\n    Results.setPreferredType(PreferredType);\n  Results.EnterNewScope();\n\n  // The \"template\" keyword can follow \"::\" in the grammar, but only\n  // put it into the grammar if the nested-name-specifier is dependent.\n  // FIXME: results is always empty, this appears to be dead.\n  if (!Results.empty() && NNS->isDependent())\n    Results.AddResult(\"template\");\n\n  // If the scope is a concept-constrained type parameter, infer nested\n  // members based on the constraints.\n  if (const auto *TTPT =\n          dyn_cast_or_null<TemplateTypeParmType>(NNS->getAsType())) {\n    for (const auto &R : ConceptInfo(*TTPT, S).members()) {\n      if (R.Operator != ConceptInfo::Member::Colons)\n        continue;\n      Results.AddResult(CodeCompletionResult(\n          R.render(*this, CodeCompleter->getAllocator(),\n                   CodeCompleter->getCodeCompletionTUInfo())));\n    }\n  }\n\n  // Add calls to overridden virtual functions, if there are any.\n  //\n  // FIXME: This isn't wonderful, because we don't know whether we're actually\n  // in a context that permits expressions. This is a general issue with\n  // qualified-id completions.\n  if (Ctx && !EnteringContext)\n    MaybeAddOverrideCalls(*this, Ctx, Results);\n  Results.ExitScope();\n\n  if (Ctx &&\n      (CodeCompleter->includeNamespaceLevelDecls() || !Ctx->isFileContext())) {\n    CodeCompletionDeclConsumer Consumer(Results, Ctx, BaseType);\n    LookupVisibleDecls(Ctx, LookupOrdinaryName, Consumer,\n                       /*IncludeGlobalScope=*/true,\n                       /*IncludeDependentBases=*/true,\n                       CodeCompleter->loadExternal());\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteUsing(Scope *S) {\n  if (!CodeCompleter)\n    return;\n\n  // This can be both a using alias or using declaration, in the former we\n  // expect a new name and a symbol in the latter case.\n  CodeCompletionContext Context(CodeCompletionContext::CCC_SymbolOrNewName);\n  Context.setIsUsingDeclaration(true);\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(), Context,\n                        &ResultBuilder::IsNestedNameSpecifier);\n  Results.EnterNewScope();\n\n  // If we aren't in class scope, we could see the \"namespace\" keyword.\n  if (!S->isClassScope())\n    Results.AddResult(CodeCompletionResult(\"namespace\"));\n\n  // After \"using\", we can see anything that would start a\n  // nested-name-specifier.\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteUsingDirective(Scope *S) {\n  if (!CodeCompleter)\n    return;\n\n  // After \"using namespace\", we expect to see a namespace name or namespace\n  // alias.\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Namespace,\n                        &ResultBuilder::IsNamespaceOrAlias);\n  Results.EnterNewScope();\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteNamespaceDecl(Scope *S) {\n  if (!CodeCompleter)\n    return;\n\n  DeclContext *Ctx = S->getEntity();\n  if (!S->getParent())\n    Ctx = Context.getTranslationUnitDecl();\n\n  bool SuppressedGlobalResults =\n      Ctx && !CodeCompleter->includeGlobals() && isa<TranslationUnitDecl>(Ctx);\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        SuppressedGlobalResults\n                            ? CodeCompletionContext::CCC_Namespace\n                            : CodeCompletionContext::CCC_Other,\n                        &ResultBuilder::IsNamespace);\n\n  if (Ctx && Ctx->isFileContext() && !SuppressedGlobalResults) {\n    // We only want to see those namespaces that have already been defined\n    // within this scope, because its likely that the user is creating an\n    // extended namespace declaration. Keep track of the most recent\n    // definition of each namespace.\n    std::map<NamespaceDecl *, NamespaceDecl *> OrigToLatest;\n    for (DeclContext::specific_decl_iterator<NamespaceDecl>\n             NS(Ctx->decls_begin()),\n         NSEnd(Ctx->decls_end());\n         NS != NSEnd; ++NS)\n      OrigToLatest[NS->getOriginalNamespace()] = *NS;\n\n    // Add the most recent definition (or extended definition) of each\n    // namespace to the list of results.\n    Results.EnterNewScope();\n    for (std::map<NamespaceDecl *, NamespaceDecl *>::iterator\n             NS = OrigToLatest.begin(),\n             NSEnd = OrigToLatest.end();\n         NS != NSEnd; ++NS)\n      Results.AddResult(\n          CodeCompletionResult(NS->second, Results.getBasePriority(NS->second),\n                               nullptr),\n          CurContext, nullptr, false);\n    Results.ExitScope();\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteNamespaceAliasDecl(Scope *S) {\n  if (!CodeCompleter)\n    return;\n\n  // After \"namespace\", we expect to see a namespace or alias.\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Namespace,\n                        &ResultBuilder::IsNamespaceOrAlias);\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteOperatorName(Scope *S) {\n  if (!CodeCompleter)\n    return;\n\n  typedef CodeCompletionResult Result;\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Type,\n                        &ResultBuilder::IsType);\n  Results.EnterNewScope();\n\n  // Add the names of overloadable operators. Note that OO_Conditional is not\n  // actually overloadable.\n#define OVERLOADED_OPERATOR(Name, Spelling, Token, Unary, Binary, MemberOnly)  \\\n  if (OO_##Name != OO_Conditional)                                             \\\n    Results.AddResult(Result(Spelling));\n#include \"clang/Basic/OperatorKinds.def\"\n\n  // Add any type names visible from the current scope\n  Results.allowNestedNameSpecifiers();\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n\n  // Add any type specifiers\n  AddTypeSpecifierResults(getLangOpts(), Results);\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteConstructorInitializer(\n    Decl *ConstructorD, ArrayRef<CXXCtorInitializer *> Initializers) {\n  if (!ConstructorD)\n    return;\n\n  AdjustDeclIfTemplate(ConstructorD);\n\n  auto *Constructor = dyn_cast<CXXConstructorDecl>(ConstructorD);\n  if (!Constructor)\n    return;\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Symbol);\n  Results.EnterNewScope();\n\n  // Fill in any already-initialized fields or base classes.\n  llvm::SmallPtrSet<FieldDecl *, 4> InitializedFields;\n  llvm::SmallPtrSet<CanQualType, 4> InitializedBases;\n  for (unsigned I = 0, E = Initializers.size(); I != E; ++I) {\n    if (Initializers[I]->isBaseInitializer())\n      InitializedBases.insert(Context.getCanonicalType(\n          QualType(Initializers[I]->getBaseClass(), 0)));\n    else\n      InitializedFields.insert(\n          cast<FieldDecl>(Initializers[I]->getAnyMember()));\n  }\n\n  // Add completions for base classes.\n  PrintingPolicy Policy = getCompletionPrintingPolicy(*this);\n  bool SawLastInitializer = Initializers.empty();\n  CXXRecordDecl *ClassDecl = Constructor->getParent();\n\n  auto GenerateCCS = [&](const NamedDecl *ND, const char *Name) {\n    CodeCompletionBuilder Builder(Results.getAllocator(),\n                                  Results.getCodeCompletionTUInfo());\n    Builder.AddTypedTextChunk(Name);\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    if (const auto *Function = dyn_cast<FunctionDecl>(ND))\n      AddFunctionParameterChunks(PP, Policy, Function, Builder);\n    else if (const auto *FunTemplDecl = dyn_cast<FunctionTemplateDecl>(ND))\n      AddFunctionParameterChunks(PP, Policy, FunTemplDecl->getTemplatedDecl(),\n                                 Builder);\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    return Builder.TakeString();\n  };\n  auto AddDefaultCtorInit = [&](const char *Name, const char *Type,\n                                const NamedDecl *ND) {\n    CodeCompletionBuilder Builder(Results.getAllocator(),\n                                  Results.getCodeCompletionTUInfo());\n    Builder.AddTypedTextChunk(Name);\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    Builder.AddPlaceholderChunk(Type);\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    if (ND) {\n      auto CCR = CodeCompletionResult(\n          Builder.TakeString(), ND,\n          SawLastInitializer ? CCP_NextInitializer : CCP_MemberDeclaration);\n      if (isa<FieldDecl>(ND))\n        CCR.CursorKind = CXCursor_MemberRef;\n      return Results.AddResult(CCR);\n    }\n    return Results.AddResult(CodeCompletionResult(\n        Builder.TakeString(),\n        SawLastInitializer ? CCP_NextInitializer : CCP_MemberDeclaration));\n  };\n  auto AddCtorsWithName = [&](const CXXRecordDecl *RD, unsigned int Priority,\n                              const char *Name, const FieldDecl *FD) {\n    if (!RD)\n      return AddDefaultCtorInit(Name,\n                                FD ? Results.getAllocator().CopyString(\n                                         FD->getType().getAsString(Policy))\n                                   : Name,\n                                FD);\n    auto Ctors = getConstructors(Context, RD);\n    if (Ctors.begin() == Ctors.end())\n      return AddDefaultCtorInit(Name, Name, RD);\n    for (const NamedDecl *Ctor : Ctors) {\n      auto CCR = CodeCompletionResult(GenerateCCS(Ctor, Name), RD, Priority);\n      CCR.CursorKind = getCursorKindForDecl(Ctor);\n      Results.AddResult(CCR);\n    }\n  };\n  auto AddBase = [&](const CXXBaseSpecifier &Base) {\n    const char *BaseName =\n        Results.getAllocator().CopyString(Base.getType().getAsString(Policy));\n    const auto *RD = Base.getType()->getAsCXXRecordDecl();\n    AddCtorsWithName(\n        RD, SawLastInitializer ? CCP_NextInitializer : CCP_MemberDeclaration,\n        BaseName, nullptr);\n  };\n  auto AddField = [&](const FieldDecl *FD) {\n    const char *FieldName =\n        Results.getAllocator().CopyString(FD->getIdentifier()->getName());\n    const CXXRecordDecl *RD = FD->getType()->getAsCXXRecordDecl();\n    AddCtorsWithName(\n        RD, SawLastInitializer ? CCP_NextInitializer : CCP_MemberDeclaration,\n        FieldName, FD);\n  };\n\n  for (const auto &Base : ClassDecl->bases()) {\n    if (!InitializedBases.insert(Context.getCanonicalType(Base.getType()))\n             .second) {\n      SawLastInitializer =\n          !Initializers.empty() && Initializers.back()->isBaseInitializer() &&\n          Context.hasSameUnqualifiedType(\n              Base.getType(), QualType(Initializers.back()->getBaseClass(), 0));\n      continue;\n    }\n\n    AddBase(Base);\n    SawLastInitializer = false;\n  }\n\n  // Add completions for virtual base classes.\n  for (const auto &Base : ClassDecl->vbases()) {\n    if (!InitializedBases.insert(Context.getCanonicalType(Base.getType()))\n             .second) {\n      SawLastInitializer =\n          !Initializers.empty() && Initializers.back()->isBaseInitializer() &&\n          Context.hasSameUnqualifiedType(\n              Base.getType(), QualType(Initializers.back()->getBaseClass(), 0));\n      continue;\n    }\n\n    AddBase(Base);\n    SawLastInitializer = false;\n  }\n\n  // Add completions for members.\n  for (auto *Field : ClassDecl->fields()) {\n    if (!InitializedFields.insert(cast<FieldDecl>(Field->getCanonicalDecl()))\n             .second) {\n      SawLastInitializer = !Initializers.empty() &&\n                           Initializers.back()->isAnyMemberInitializer() &&\n                           Initializers.back()->getAnyMember() == Field;\n      continue;\n    }\n\n    if (!Field->getDeclName())\n      continue;\n\n    AddField(Field);\n    SawLastInitializer = false;\n  }\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\n/// Determine whether this scope denotes a namespace.\nstatic bool isNamespaceScope(Scope *S) {\n  DeclContext *DC = S->getEntity();\n  if (!DC)\n    return false;\n\n  return DC->isFileContext();\n}\n\nvoid Sema::CodeCompleteLambdaIntroducer(Scope *S, LambdaIntroducer &Intro,\n                                        bool AfterAmpersand) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n\n  // Note what has already been captured.\n  llvm::SmallPtrSet<IdentifierInfo *, 4> Known;\n  bool IncludedThis = false;\n  for (const auto &C : Intro.Captures) {\n    if (C.Kind == LCK_This) {\n      IncludedThis = true;\n      continue;\n    }\n\n    Known.insert(C.Id);\n  }\n\n  // Look for other capturable variables.\n  for (; S && !isNamespaceScope(S); S = S->getParent()) {\n    for (const auto *D : S->decls()) {\n      const auto *Var = dyn_cast<VarDecl>(D);\n      if (!Var || !Var->hasLocalStorage() || Var->hasAttr<BlocksAttr>())\n        continue;\n\n      if (Known.insert(Var->getIdentifier()).second)\n        Results.AddResult(CodeCompletionResult(Var, CCP_LocalDeclaration),\n                          CurContext, nullptr, false);\n    }\n  }\n\n  // Add 'this', if it would be valid.\n  if (!IncludedThis && !AfterAmpersand && Intro.Default != LCD_ByCopy)\n    addThisCompletion(*this, Results);\n\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteAfterFunctionEquals(Declarator &D) {\n  if (!LangOpts.CPlusPlus11)\n    return;\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  auto ShouldAddDefault = [&D, this]() {\n    if (!D.isFunctionDeclarator())\n      return false;\n    auto &Id = D.getName();\n    if (Id.getKind() == UnqualifiedIdKind::IK_DestructorName)\n      return true;\n    // FIXME(liuhui): Ideally, we should check the constructor parameter list to\n    // verify that it is the default, copy or move constructor?\n    if (Id.getKind() == UnqualifiedIdKind::IK_ConstructorName &&\n        D.getFunctionTypeInfo().NumParams <= 1)\n      return true;\n    if (Id.getKind() == UnqualifiedIdKind::IK_OperatorFunctionId) {\n      auto Op = Id.OperatorFunctionId.Operator;\n      // FIXME(liuhui): Ideally, we should check the function parameter list to\n      // verify that it is the copy or move assignment?\n      if (Op == OverloadedOperatorKind::OO_Equal)\n        return true;\n      if (LangOpts.CPlusPlus20 &&\n          (Op == OverloadedOperatorKind::OO_EqualEqual ||\n           Op == OverloadedOperatorKind::OO_ExclaimEqual ||\n           Op == OverloadedOperatorKind::OO_Less ||\n           Op == OverloadedOperatorKind::OO_LessEqual ||\n           Op == OverloadedOperatorKind::OO_Greater ||\n           Op == OverloadedOperatorKind::OO_GreaterEqual ||\n           Op == OverloadedOperatorKind::OO_Spaceship))\n        return true;\n    }\n    return false;\n  };\n\n  Results.EnterNewScope();\n  if (ShouldAddDefault())\n    Results.AddResult(\"default\");\n  // FIXME(liuhui): Ideally, we should only provide `delete` completion for the\n  // first function declaration.\n  Results.AddResult(\"delete\");\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\n/// Macro that optionally prepends an \"@\" to the string literal passed in via\n/// Keyword, depending on whether NeedAt is true or false.\n#define OBJC_AT_KEYWORD_NAME(NeedAt, Keyword) ((NeedAt) ? \"@\" Keyword : Keyword)\n\nstatic void AddObjCImplementationResults(const LangOptions &LangOpts,\n                                         ResultBuilder &Results, bool NeedAt) {\n  typedef CodeCompletionResult Result;\n  // Since we have an implementation, we can end it.\n  Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"end\")));\n\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n  if (LangOpts.ObjC) {\n    // @dynamic\n    Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"dynamic\"));\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"property\");\n    Results.AddResult(Result(Builder.TakeString()));\n\n    // @synthesize\n    Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"synthesize\"));\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"property\");\n    Results.AddResult(Result(Builder.TakeString()));\n  }\n}\n\nstatic void AddObjCInterfaceResults(const LangOptions &LangOpts,\n                                    ResultBuilder &Results, bool NeedAt) {\n  typedef CodeCompletionResult Result;\n\n  // Since we have an interface or protocol, we can end it.\n  Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"end\")));\n\n  if (LangOpts.ObjC) {\n    // @property\n    Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"property\")));\n\n    // @required\n    Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"required\")));\n\n    // @optional\n    Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"optional\")));\n  }\n}\n\nstatic void AddObjCTopLevelResults(ResultBuilder &Results, bool NeedAt) {\n  typedef CodeCompletionResult Result;\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n\n  // @class name ;\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"class\"));\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"name\");\n  Results.AddResult(Result(Builder.TakeString()));\n\n  if (Results.includeCodePatterns()) {\n    // @interface name\n    // FIXME: Could introduce the whole pattern, including superclasses and\n    // such.\n    Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"interface\"));\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"class\");\n    Results.AddResult(Result(Builder.TakeString()));\n\n    // @protocol name\n    Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"protocol\"));\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"protocol\");\n    Results.AddResult(Result(Builder.TakeString()));\n\n    // @implementation name\n    Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"implementation\"));\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"class\");\n    Results.AddResult(Result(Builder.TakeString()));\n  }\n\n  // @compatibility_alias name\n  Builder.AddTypedTextChunk(\n      OBJC_AT_KEYWORD_NAME(NeedAt, \"compatibility_alias\"));\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"alias\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"class\");\n  Results.AddResult(Result(Builder.TakeString()));\n\n  if (Results.getSema().getLangOpts().Modules) {\n    // @import name\n    Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"import\"));\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"module\");\n    Results.AddResult(Result(Builder.TakeString()));\n  }\n}\n\nvoid Sema::CodeCompleteObjCAtDirective(Scope *S) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n  if (isa<ObjCImplDecl>(CurContext))\n    AddObjCImplementationResults(getLangOpts(), Results, false);\n  else if (CurContext->isObjCContainer())\n    AddObjCInterfaceResults(getLangOpts(), Results, false);\n  else\n    AddObjCTopLevelResults(Results, false);\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nstatic void AddObjCExpressionResults(ResultBuilder &Results, bool NeedAt) {\n  typedef CodeCompletionResult Result;\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n\n  // @encode ( type-name )\n  const char *EncodeType = \"char[]\";\n  if (Results.getSema().getLangOpts().CPlusPlus ||\n      Results.getSema().getLangOpts().ConstStrings)\n    EncodeType = \"const char[]\";\n  Builder.AddResultTypeChunk(EncodeType);\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"encode\"));\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n  Builder.AddPlaceholderChunk(\"type-name\");\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n  Results.AddResult(Result(Builder.TakeString()));\n\n  // @protocol ( protocol-name )\n  Builder.AddResultTypeChunk(\"Protocol *\");\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"protocol\"));\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n  Builder.AddPlaceholderChunk(\"protocol-name\");\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n  Results.AddResult(Result(Builder.TakeString()));\n\n  // @selector ( selector )\n  Builder.AddResultTypeChunk(\"SEL\");\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"selector\"));\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n  Builder.AddPlaceholderChunk(\"selector\");\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n  Results.AddResult(Result(Builder.TakeString()));\n\n  // @\"string\"\n  Builder.AddResultTypeChunk(\"NSString *\");\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"\\\"\"));\n  Builder.AddPlaceholderChunk(\"string\");\n  Builder.AddTextChunk(\"\\\"\");\n  Results.AddResult(Result(Builder.TakeString()));\n\n  // @[objects, ...]\n  Builder.AddResultTypeChunk(\"NSArray *\");\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"[\"));\n  Builder.AddPlaceholderChunk(\"objects, ...\");\n  Builder.AddChunk(CodeCompletionString::CK_RightBracket);\n  Results.AddResult(Result(Builder.TakeString()));\n\n  // @{key : object, ...}\n  Builder.AddResultTypeChunk(\"NSDictionary *\");\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"{\"));\n  Builder.AddPlaceholderChunk(\"key\");\n  Builder.AddChunk(CodeCompletionString::CK_Colon);\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"object, ...\");\n  Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n  Results.AddResult(Result(Builder.TakeString()));\n\n  // @(expression)\n  Builder.AddResultTypeChunk(\"id\");\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"(\"));\n  Builder.AddPlaceholderChunk(\"expression\");\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n  Results.AddResult(Result(Builder.TakeString()));\n}\n\nstatic void AddObjCStatementResults(ResultBuilder &Results, bool NeedAt) {\n  typedef CodeCompletionResult Result;\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n\n  if (Results.includeCodePatterns()) {\n    // @try { statements } @catch ( declaration ) { statements } @finally\n    //   { statements }\n    Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"try\"));\n    Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n    Builder.AddPlaceholderChunk(\"statements\");\n    Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n    Builder.AddTextChunk(\"@catch\");\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    Builder.AddPlaceholderChunk(\"parameter\");\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n    Builder.AddPlaceholderChunk(\"statements\");\n    Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n    Builder.AddTextChunk(\"@finally\");\n    Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n    Builder.AddPlaceholderChunk(\"statements\");\n    Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n    Results.AddResult(Result(Builder.TakeString()));\n  }\n\n  // @throw\n  Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"throw\"));\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"expression\");\n  Results.AddResult(Result(Builder.TakeString()));\n\n  if (Results.includeCodePatterns()) {\n    // @synchronized ( expression ) { statements }\n    Builder.AddTypedTextChunk(OBJC_AT_KEYWORD_NAME(NeedAt, \"synchronized\"));\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    Builder.AddPlaceholderChunk(\"expression\");\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n    Builder.AddPlaceholderChunk(\"statements\");\n    Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n    Results.AddResult(Result(Builder.TakeString()));\n  }\n}\n\nstatic void AddObjCVisibilityResults(const LangOptions &LangOpts,\n                                     ResultBuilder &Results, bool NeedAt) {\n  typedef CodeCompletionResult Result;\n  Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"private\")));\n  Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"protected\")));\n  Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"public\")));\n  if (LangOpts.ObjC)\n    Results.AddResult(Result(OBJC_AT_KEYWORD_NAME(NeedAt, \"package\")));\n}\n\nvoid Sema::CodeCompleteObjCAtVisibility(Scope *S) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n  AddObjCVisibilityResults(getLangOpts(), Results, false);\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCAtStatement(Scope *S) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n  AddObjCStatementResults(Results, false);\n  AddObjCExpressionResults(Results, false);\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCAtExpression(Scope *S) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n  AddObjCExpressionResults(Results, false);\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\n/// Determine whether the addition of the given flag to an Objective-C\n/// property's attributes will cause a conflict.\nstatic bool ObjCPropertyFlagConflicts(unsigned Attributes, unsigned NewFlag) {\n  // Check if we've already added this flag.\n  if (Attributes & NewFlag)\n    return true;\n\n  Attributes |= NewFlag;\n\n  // Check for collisions with \"readonly\".\n  if ((Attributes & ObjCPropertyAttribute::kind_readonly) &&\n      (Attributes & ObjCPropertyAttribute::kind_readwrite))\n    return true;\n\n  // Check for more than one of { assign, copy, retain, strong, weak }.\n  unsigned AssignCopyRetMask =\n      Attributes &\n      (ObjCPropertyAttribute::kind_assign |\n       ObjCPropertyAttribute::kind_unsafe_unretained |\n       ObjCPropertyAttribute::kind_copy | ObjCPropertyAttribute::kind_retain |\n       ObjCPropertyAttribute::kind_strong | ObjCPropertyAttribute::kind_weak);\n  if (AssignCopyRetMask &&\n      AssignCopyRetMask != ObjCPropertyAttribute::kind_assign &&\n      AssignCopyRetMask != ObjCPropertyAttribute::kind_unsafe_unretained &&\n      AssignCopyRetMask != ObjCPropertyAttribute::kind_copy &&\n      AssignCopyRetMask != ObjCPropertyAttribute::kind_retain &&\n      AssignCopyRetMask != ObjCPropertyAttribute::kind_strong &&\n      AssignCopyRetMask != ObjCPropertyAttribute::kind_weak)\n    return true;\n\n  return false;\n}\n\nvoid Sema::CodeCompleteObjCPropertyFlags(Scope *S, ObjCDeclSpec &ODS) {\n  if (!CodeCompleter)\n    return;\n\n  unsigned Attributes = ODS.getPropertyAttributes();\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_readonly))\n    Results.AddResult(CodeCompletionResult(\"readonly\"));\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_assign))\n    Results.AddResult(CodeCompletionResult(\"assign\"));\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_unsafe_unretained))\n    Results.AddResult(CodeCompletionResult(\"unsafe_unretained\"));\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_readwrite))\n    Results.AddResult(CodeCompletionResult(\"readwrite\"));\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_retain))\n    Results.AddResult(CodeCompletionResult(\"retain\"));\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_strong))\n    Results.AddResult(CodeCompletionResult(\"strong\"));\n  if (!ObjCPropertyFlagConflicts(Attributes, ObjCPropertyAttribute::kind_copy))\n    Results.AddResult(CodeCompletionResult(\"copy\"));\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_nonatomic))\n    Results.AddResult(CodeCompletionResult(\"nonatomic\"));\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_atomic))\n    Results.AddResult(CodeCompletionResult(\"atomic\"));\n\n  // Only suggest \"weak\" if we're compiling for ARC-with-weak-references or GC.\n  if (getLangOpts().ObjCWeak || getLangOpts().getGC() != LangOptions::NonGC)\n    if (!ObjCPropertyFlagConflicts(Attributes,\n                                   ObjCPropertyAttribute::kind_weak))\n      Results.AddResult(CodeCompletionResult(\"weak\"));\n\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_setter)) {\n    CodeCompletionBuilder Setter(Results.getAllocator(),\n                                 Results.getCodeCompletionTUInfo());\n    Setter.AddTypedTextChunk(\"setter\");\n    Setter.AddTextChunk(\"=\");\n    Setter.AddPlaceholderChunk(\"method\");\n    Results.AddResult(CodeCompletionResult(Setter.TakeString()));\n  }\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_getter)) {\n    CodeCompletionBuilder Getter(Results.getAllocator(),\n                                 Results.getCodeCompletionTUInfo());\n    Getter.AddTypedTextChunk(\"getter\");\n    Getter.AddTextChunk(\"=\");\n    Getter.AddPlaceholderChunk(\"method\");\n    Results.AddResult(CodeCompletionResult(Getter.TakeString()));\n  }\n  if (!ObjCPropertyFlagConflicts(Attributes,\n                                 ObjCPropertyAttribute::kind_nullability)) {\n    Results.AddResult(CodeCompletionResult(\"nonnull\"));\n    Results.AddResult(CodeCompletionResult(\"nullable\"));\n    Results.AddResult(CodeCompletionResult(\"null_unspecified\"));\n    Results.AddResult(CodeCompletionResult(\"null_resettable\"));\n  }\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\n/// Describes the kind of Objective-C method that we want to find\n/// via code completion.\nenum ObjCMethodKind {\n  MK_Any, ///< Any kind of method, provided it means other specified criteria.\n  MK_ZeroArgSelector, ///< Zero-argument (unary) selector.\n  MK_OneArgSelector   ///< One-argument selector.\n};\n\nstatic bool isAcceptableObjCSelector(Selector Sel, ObjCMethodKind WantKind,\n                                     ArrayRef<IdentifierInfo *> SelIdents,\n                                     bool AllowSameLength = true) {\n  unsigned NumSelIdents = SelIdents.size();\n  if (NumSelIdents > Sel.getNumArgs())\n    return false;\n\n  switch (WantKind) {\n  case MK_Any:\n    break;\n  case MK_ZeroArgSelector:\n    return Sel.isUnarySelector();\n  case MK_OneArgSelector:\n    return Sel.getNumArgs() == 1;\n  }\n\n  if (!AllowSameLength && NumSelIdents && NumSelIdents == Sel.getNumArgs())\n    return false;\n\n  for (unsigned I = 0; I != NumSelIdents; ++I)\n    if (SelIdents[I] != Sel.getIdentifierInfoForSlot(I))\n      return false;\n\n  return true;\n}\n\nstatic bool isAcceptableObjCMethod(ObjCMethodDecl *Method,\n                                   ObjCMethodKind WantKind,\n                                   ArrayRef<IdentifierInfo *> SelIdents,\n                                   bool AllowSameLength = true) {\n  return isAcceptableObjCSelector(Method->getSelector(), WantKind, SelIdents,\n                                  AllowSameLength);\n}\n\n/// A set of selectors, which is used to avoid introducing multiple\n/// completions with the same selector into the result set.\ntypedef llvm::SmallPtrSet<Selector, 16> VisitedSelectorSet;\n\n/// Add all of the Objective-C methods in the given Objective-C\n/// container to the set of results.\n///\n/// The container will be a class, protocol, category, or implementation of\n/// any of the above. This mether will recurse to include methods from\n/// the superclasses of classes along with their categories, protocols, and\n/// implementations.\n///\n/// \\param Container the container in which we'll look to find methods.\n///\n/// \\param WantInstanceMethods Whether to add instance methods (only); if\n/// false, this routine will add factory methods (only).\n///\n/// \\param CurContext the context in which we're performing the lookup that\n/// finds methods.\n///\n/// \\param AllowSameLength Whether we allow a method to be added to the list\n/// when it has the same number of parameters as we have selector identifiers.\n///\n/// \\param Results the structure into which we'll add results.\nstatic void AddObjCMethods(ObjCContainerDecl *Container,\n                           bool WantInstanceMethods, ObjCMethodKind WantKind,\n                           ArrayRef<IdentifierInfo *> SelIdents,\n                           DeclContext *CurContext,\n                           VisitedSelectorSet &Selectors, bool AllowSameLength,\n                           ResultBuilder &Results, bool InOriginalClass = true,\n                           bool IsRootClass = false) {\n  typedef CodeCompletionResult Result;\n  Container = getContainerDef(Container);\n  ObjCInterfaceDecl *IFace = dyn_cast<ObjCInterfaceDecl>(Container);\n  IsRootClass = IsRootClass || (IFace && !IFace->getSuperClass());\n  for (ObjCMethodDecl *M : Container->methods()) {\n    // The instance methods on the root class can be messaged via the\n    // metaclass.\n    if (M->isInstanceMethod() == WantInstanceMethods ||\n        (IsRootClass && !WantInstanceMethods)) {\n      // Check whether the selector identifiers we've been given are a\n      // subset of the identifiers for this particular method.\n      if (!isAcceptableObjCMethod(M, WantKind, SelIdents, AllowSameLength))\n        continue;\n\n      if (!Selectors.insert(M->getSelector()).second)\n        continue;\n\n      Result R = Result(M, Results.getBasePriority(M), nullptr);\n      R.StartParameter = SelIdents.size();\n      R.AllParametersAreInformative = (WantKind != MK_Any);\n      if (!InOriginalClass)\n        setInBaseClass(R);\n      Results.MaybeAddResult(R, CurContext);\n    }\n  }\n\n  // Visit the protocols of protocols.\n  if (const auto *Protocol = dyn_cast<ObjCProtocolDecl>(Container)) {\n    if (Protocol->hasDefinition()) {\n      const ObjCList<ObjCProtocolDecl> &Protocols =\n          Protocol->getReferencedProtocols();\n      for (ObjCList<ObjCProtocolDecl>::iterator I = Protocols.begin(),\n                                                E = Protocols.end();\n           I != E; ++I)\n        AddObjCMethods(*I, WantInstanceMethods, WantKind, SelIdents, CurContext,\n                       Selectors, AllowSameLength, Results, false, IsRootClass);\n    }\n  }\n\n  if (!IFace || !IFace->hasDefinition())\n    return;\n\n  // Add methods in protocols.\n  for (ObjCProtocolDecl *I : IFace->protocols())\n    AddObjCMethods(I, WantInstanceMethods, WantKind, SelIdents, CurContext,\n                   Selectors, AllowSameLength, Results, false, IsRootClass);\n\n  // Add methods in categories.\n  for (ObjCCategoryDecl *CatDecl : IFace->known_categories()) {\n    AddObjCMethods(CatDecl, WantInstanceMethods, WantKind, SelIdents,\n                   CurContext, Selectors, AllowSameLength, Results,\n                   InOriginalClass, IsRootClass);\n\n    // Add a categories protocol methods.\n    const ObjCList<ObjCProtocolDecl> &Protocols =\n        CatDecl->getReferencedProtocols();\n    for (ObjCList<ObjCProtocolDecl>::iterator I = Protocols.begin(),\n                                              E = Protocols.end();\n         I != E; ++I)\n      AddObjCMethods(*I, WantInstanceMethods, WantKind, SelIdents, CurContext,\n                     Selectors, AllowSameLength, Results, false, IsRootClass);\n\n    // Add methods in category implementations.\n    if (ObjCCategoryImplDecl *Impl = CatDecl->getImplementation())\n      AddObjCMethods(Impl, WantInstanceMethods, WantKind, SelIdents, CurContext,\n                     Selectors, AllowSameLength, Results, InOriginalClass,\n                     IsRootClass);\n  }\n\n  // Add methods in superclass.\n  // Avoid passing in IsRootClass since root classes won't have super classes.\n  if (IFace->getSuperClass())\n    AddObjCMethods(IFace->getSuperClass(), WantInstanceMethods, WantKind,\n                   SelIdents, CurContext, Selectors, AllowSameLength, Results,\n                   /*IsRootClass=*/false);\n\n  // Add methods in our implementation, if any.\n  if (ObjCImplementationDecl *Impl = IFace->getImplementation())\n    AddObjCMethods(Impl, WantInstanceMethods, WantKind, SelIdents, CurContext,\n                   Selectors, AllowSameLength, Results, InOriginalClass,\n                   IsRootClass);\n}\n\nvoid Sema::CodeCompleteObjCPropertyGetter(Scope *S) {\n  // Try to find the interface where getters might live.\n  ObjCInterfaceDecl *Class = dyn_cast_or_null<ObjCInterfaceDecl>(CurContext);\n  if (!Class) {\n    if (ObjCCategoryDecl *Category =\n            dyn_cast_or_null<ObjCCategoryDecl>(CurContext))\n      Class = Category->getClassInterface();\n\n    if (!Class)\n      return;\n  }\n\n  // Find all of the potential getters.\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n\n  VisitedSelectorSet Selectors;\n  AddObjCMethods(Class, true, MK_ZeroArgSelector, None, CurContext, Selectors,\n                 /*AllowSameLength=*/true, Results);\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCPropertySetter(Scope *S) {\n  // Try to find the interface where setters might live.\n  ObjCInterfaceDecl *Class = dyn_cast_or_null<ObjCInterfaceDecl>(CurContext);\n  if (!Class) {\n    if (ObjCCategoryDecl *Category =\n            dyn_cast_or_null<ObjCCategoryDecl>(CurContext))\n      Class = Category->getClassInterface();\n\n    if (!Class)\n      return;\n  }\n\n  // Find all of the potential getters.\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n\n  VisitedSelectorSet Selectors;\n  AddObjCMethods(Class, true, MK_OneArgSelector, None, CurContext, Selectors,\n                 /*AllowSameLength=*/true, Results);\n\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCPassingType(Scope *S, ObjCDeclSpec &DS,\n                                       bool IsParameter) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Type);\n  Results.EnterNewScope();\n\n  // Add context-sensitive, Objective-C parameter-passing keywords.\n  bool AddedInOut = false;\n  if ((DS.getObjCDeclQualifier() &\n       (ObjCDeclSpec::DQ_In | ObjCDeclSpec::DQ_Inout)) == 0) {\n    Results.AddResult(\"in\");\n    Results.AddResult(\"inout\");\n    AddedInOut = true;\n  }\n  if ((DS.getObjCDeclQualifier() &\n       (ObjCDeclSpec::DQ_Out | ObjCDeclSpec::DQ_Inout)) == 0) {\n    Results.AddResult(\"out\");\n    if (!AddedInOut)\n      Results.AddResult(\"inout\");\n  }\n  if ((DS.getObjCDeclQualifier() &\n       (ObjCDeclSpec::DQ_Bycopy | ObjCDeclSpec::DQ_Byref |\n        ObjCDeclSpec::DQ_Oneway)) == 0) {\n    Results.AddResult(\"bycopy\");\n    Results.AddResult(\"byref\");\n    Results.AddResult(\"oneway\");\n  }\n  if ((DS.getObjCDeclQualifier() & ObjCDeclSpec::DQ_CSNullability) == 0) {\n    Results.AddResult(\"nonnull\");\n    Results.AddResult(\"nullable\");\n    Results.AddResult(\"null_unspecified\");\n  }\n\n  // If we're completing the return type of an Objective-C method and the\n  // identifier IBAction refers to a macro, provide a completion item for\n  // an action, e.g.,\n  //   IBAction)<#selector#>:(id)sender\n  if (DS.getObjCDeclQualifier() == 0 && !IsParameter &&\n      PP.isMacroDefined(\"IBAction\")) {\n    CodeCompletionBuilder Builder(Results.getAllocator(),\n                                  Results.getCodeCompletionTUInfo(),\n                                  CCP_CodePattern, CXAvailability_Available);\n    Builder.AddTypedTextChunk(\"IBAction\");\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    Builder.AddPlaceholderChunk(\"selector\");\n    Builder.AddChunk(CodeCompletionString::CK_Colon);\n    Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n    Builder.AddTextChunk(\"id\");\n    Builder.AddChunk(CodeCompletionString::CK_RightParen);\n    Builder.AddTextChunk(\"sender\");\n    Results.AddResult(CodeCompletionResult(Builder.TakeString()));\n  }\n\n  // If we're completing the return type, provide 'instancetype'.\n  if (!IsParameter) {\n    Results.AddResult(CodeCompletionResult(\"instancetype\"));\n  }\n\n  // Add various builtin type names and specifiers.\n  AddOrdinaryNameResults(PCC_Type, S, *this, Results);\n  Results.ExitScope();\n\n  // Add the various type names\n  Results.setFilter(&ResultBuilder::IsOrdinaryNonValueName);\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n\n  if (CodeCompleter->includeMacros())\n    AddMacroResults(PP, Results, CodeCompleter->loadExternal(), false);\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\n/// When we have an expression with type \"id\", we may assume\n/// that it has some more-specific class type based on knowledge of\n/// common uses of Objective-C. This routine returns that class type,\n/// or NULL if no better result could be determined.\nstatic ObjCInterfaceDecl *GetAssumedMessageSendExprType(Expr *E) {\n  auto *Msg = dyn_cast_or_null<ObjCMessageExpr>(E);\n  if (!Msg)\n    return nullptr;\n\n  Selector Sel = Msg->getSelector();\n  if (Sel.isNull())\n    return nullptr;\n\n  IdentifierInfo *Id = Sel.getIdentifierInfoForSlot(0);\n  if (!Id)\n    return nullptr;\n\n  ObjCMethodDecl *Method = Msg->getMethodDecl();\n  if (!Method)\n    return nullptr;\n\n  // Determine the class that we're sending the message to.\n  ObjCInterfaceDecl *IFace = nullptr;\n  switch (Msg->getReceiverKind()) {\n  case ObjCMessageExpr::Class:\n    if (const ObjCObjectType *ObjType =\n            Msg->getClassReceiver()->getAs<ObjCObjectType>())\n      IFace = ObjType->getInterface();\n    break;\n\n  case ObjCMessageExpr::Instance: {\n    QualType T = Msg->getInstanceReceiver()->getType();\n    if (const ObjCObjectPointerType *Ptr = T->getAs<ObjCObjectPointerType>())\n      IFace = Ptr->getInterfaceDecl();\n    break;\n  }\n\n  case ObjCMessageExpr::SuperInstance:\n  case ObjCMessageExpr::SuperClass:\n    break;\n  }\n\n  if (!IFace)\n    return nullptr;\n\n  ObjCInterfaceDecl *Super = IFace->getSuperClass();\n  if (Method->isInstanceMethod())\n    return llvm::StringSwitch<ObjCInterfaceDecl *>(Id->getName())\n        .Case(\"retain\", IFace)\n        .Case(\"strong\", IFace)\n        .Case(\"autorelease\", IFace)\n        .Case(\"copy\", IFace)\n        .Case(\"copyWithZone\", IFace)\n        .Case(\"mutableCopy\", IFace)\n        .Case(\"mutableCopyWithZone\", IFace)\n        .Case(\"awakeFromCoder\", IFace)\n        .Case(\"replacementObjectFromCoder\", IFace)\n        .Case(\"class\", IFace)\n        .Case(\"classForCoder\", IFace)\n        .Case(\"superclass\", Super)\n        .Default(nullptr);\n\n  return llvm::StringSwitch<ObjCInterfaceDecl *>(Id->getName())\n      .Case(\"new\", IFace)\n      .Case(\"alloc\", IFace)\n      .Case(\"allocWithZone\", IFace)\n      .Case(\"class\", IFace)\n      .Case(\"superclass\", Super)\n      .Default(nullptr);\n}\n\n// Add a special completion for a message send to \"super\", which fills in the\n// most likely case of forwarding all of our arguments to the superclass\n// function.\n///\n/// \\param S The semantic analysis object.\n///\n/// \\param NeedSuperKeyword Whether we need to prefix this completion with\n/// the \"super\" keyword. Otherwise, we just need to provide the arguments.\n///\n/// \\param SelIdents The identifiers in the selector that have already been\n/// provided as arguments for a send to \"super\".\n///\n/// \\param Results The set of results to augment.\n///\n/// \\returns the Objective-C method declaration that would be invoked by\n/// this \"super\" completion. If NULL, no completion was added.\nstatic ObjCMethodDecl *\nAddSuperSendCompletion(Sema &S, bool NeedSuperKeyword,\n                       ArrayRef<IdentifierInfo *> SelIdents,\n                       ResultBuilder &Results) {\n  ObjCMethodDecl *CurMethod = S.getCurMethodDecl();\n  if (!CurMethod)\n    return nullptr;\n\n  ObjCInterfaceDecl *Class = CurMethod->getClassInterface();\n  if (!Class)\n    return nullptr;\n\n  // Try to find a superclass method with the same selector.\n  ObjCMethodDecl *SuperMethod = nullptr;\n  while ((Class = Class->getSuperClass()) && !SuperMethod) {\n    // Check in the class\n    SuperMethod = Class->getMethod(CurMethod->getSelector(),\n                                   CurMethod->isInstanceMethod());\n\n    // Check in categories or class extensions.\n    if (!SuperMethod) {\n      for (const auto *Cat : Class->known_categories()) {\n        if ((SuperMethod = Cat->getMethod(CurMethod->getSelector(),\n                                          CurMethod->isInstanceMethod())))\n          break;\n      }\n    }\n  }\n\n  if (!SuperMethod)\n    return nullptr;\n\n  // Check whether the superclass method has the same signature.\n  if (CurMethod->param_size() != SuperMethod->param_size() ||\n      CurMethod->isVariadic() != SuperMethod->isVariadic())\n    return nullptr;\n\n  for (ObjCMethodDecl::param_iterator CurP = CurMethod->param_begin(),\n                                      CurPEnd = CurMethod->param_end(),\n                                      SuperP = SuperMethod->param_begin();\n       CurP != CurPEnd; ++CurP, ++SuperP) {\n    // Make sure the parameter types are compatible.\n    if (!S.Context.hasSameUnqualifiedType((*CurP)->getType(),\n                                          (*SuperP)->getType()))\n      return nullptr;\n\n    // Make sure we have a parameter name to forward!\n    if (!(*CurP)->getIdentifier())\n      return nullptr;\n  }\n\n  // We have a superclass method. Now, form the send-to-super completion.\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n\n  // Give this completion a return type.\n  AddResultTypeChunk(S.Context, getCompletionPrintingPolicy(S), SuperMethod,\n                     Results.getCompletionContext().getBaseType(), Builder);\n\n  // If we need the \"super\" keyword, add it (plus some spacing).\n  if (NeedSuperKeyword) {\n    Builder.AddTypedTextChunk(\"super\");\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  }\n\n  Selector Sel = CurMethod->getSelector();\n  if (Sel.isUnarySelector()) {\n    if (NeedSuperKeyword)\n      Builder.AddTextChunk(\n          Builder.getAllocator().CopyString(Sel.getNameForSlot(0)));\n    else\n      Builder.AddTypedTextChunk(\n          Builder.getAllocator().CopyString(Sel.getNameForSlot(0)));\n  } else {\n    ObjCMethodDecl::param_iterator CurP = CurMethod->param_begin();\n    for (unsigned I = 0, N = Sel.getNumArgs(); I != N; ++I, ++CurP) {\n      if (I > SelIdents.size())\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n\n      if (I < SelIdents.size())\n        Builder.AddInformativeChunk(\n            Builder.getAllocator().CopyString(Sel.getNameForSlot(I) + \":\"));\n      else if (NeedSuperKeyword || I > SelIdents.size()) {\n        Builder.AddTextChunk(\n            Builder.getAllocator().CopyString(Sel.getNameForSlot(I) + \":\"));\n        Builder.AddPlaceholderChunk(Builder.getAllocator().CopyString(\n            (*CurP)->getIdentifier()->getName()));\n      } else {\n        Builder.AddTypedTextChunk(\n            Builder.getAllocator().CopyString(Sel.getNameForSlot(I) + \":\"));\n        Builder.AddPlaceholderChunk(Builder.getAllocator().CopyString(\n            (*CurP)->getIdentifier()->getName()));\n      }\n    }\n  }\n\n  Results.AddResult(CodeCompletionResult(Builder.TakeString(), SuperMethod,\n                                         CCP_SuperCompletion));\n  return SuperMethod;\n}\n\nvoid Sema::CodeCompleteObjCMessageReceiver(Scope *S) {\n  typedef CodeCompletionResult Result;\n  ResultBuilder Results(\n      *this, CodeCompleter->getAllocator(),\n      CodeCompleter->getCodeCompletionTUInfo(),\n      CodeCompletionContext::CCC_ObjCMessageReceiver,\n      getLangOpts().CPlusPlus11\n          ? &ResultBuilder::IsObjCMessageReceiverOrLambdaCapture\n          : &ResultBuilder::IsObjCMessageReceiver);\n\n  CodeCompletionDeclConsumer Consumer(Results, CurContext);\n  Results.EnterNewScope();\n  LookupVisibleDecls(S, LookupOrdinaryName, Consumer,\n                     CodeCompleter->includeGlobals(),\n                     CodeCompleter->loadExternal());\n\n  // If we are in an Objective-C method inside a class that has a superclass,\n  // add \"super\" as an option.\n  if (ObjCMethodDecl *Method = getCurMethodDecl())\n    if (ObjCInterfaceDecl *Iface = Method->getClassInterface())\n      if (Iface->getSuperClass()) {\n        Results.AddResult(Result(\"super\"));\n\n        AddSuperSendCompletion(*this, /*NeedSuperKeyword=*/true, None, Results);\n      }\n\n  if (getLangOpts().CPlusPlus11)\n    addThisCompletion(*this, Results);\n\n  Results.ExitScope();\n\n  if (CodeCompleter->includeMacros())\n    AddMacroResults(PP, Results, CodeCompleter->loadExternal(), false);\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCSuperMessage(Scope *S, SourceLocation SuperLoc,\n                                        ArrayRef<IdentifierInfo *> SelIdents,\n                                        bool AtArgumentExpression) {\n  ObjCInterfaceDecl *CDecl = nullptr;\n  if (ObjCMethodDecl *CurMethod = getCurMethodDecl()) {\n    // Figure out which interface we're in.\n    CDecl = CurMethod->getClassInterface();\n    if (!CDecl)\n      return;\n\n    // Find the superclass of this class.\n    CDecl = CDecl->getSuperClass();\n    if (!CDecl)\n      return;\n\n    if (CurMethod->isInstanceMethod()) {\n      // We are inside an instance method, which means that the message\n      // send [super ...] is actually calling an instance method on the\n      // current object.\n      return CodeCompleteObjCInstanceMessage(S, nullptr, SelIdents,\n                                             AtArgumentExpression, CDecl);\n    }\n\n    // Fall through to send to the superclass in CDecl.\n  } else {\n    // \"super\" may be the name of a type or variable. Figure out which\n    // it is.\n    IdentifierInfo *Super = getSuperIdentifier();\n    NamedDecl *ND = LookupSingleName(S, Super, SuperLoc, LookupOrdinaryName);\n    if ((CDecl = dyn_cast_or_null<ObjCInterfaceDecl>(ND))) {\n      // \"super\" names an interface. Use it.\n    } else if (TypeDecl *TD = dyn_cast_or_null<TypeDecl>(ND)) {\n      if (const ObjCObjectType *Iface =\n              Context.getTypeDeclType(TD)->getAs<ObjCObjectType>())\n        CDecl = Iface->getInterface();\n    } else if (ND && isa<UnresolvedUsingTypenameDecl>(ND)) {\n      // \"super\" names an unresolved type; we can't be more specific.\n    } else {\n      // Assume that \"super\" names some kind of value and parse that way.\n      CXXScopeSpec SS;\n      SourceLocation TemplateKWLoc;\n      UnqualifiedId id;\n      id.setIdentifier(Super, SuperLoc);\n      ExprResult SuperExpr = ActOnIdExpression(S, SS, TemplateKWLoc, id,\n                                               /*HasTrailingLParen=*/false,\n                                               /*IsAddressOfOperand=*/false);\n      return CodeCompleteObjCInstanceMessage(S, (Expr *)SuperExpr.get(),\n                                             SelIdents, AtArgumentExpression);\n    }\n\n    // Fall through\n  }\n\n  ParsedType Receiver;\n  if (CDecl)\n    Receiver = ParsedType::make(Context.getObjCInterfaceType(CDecl));\n  return CodeCompleteObjCClassMessage(S, Receiver, SelIdents,\n                                      AtArgumentExpression,\n                                      /*IsSuper=*/true);\n}\n\n/// Given a set of code-completion results for the argument of a message\n/// send, determine the preferred type (if any) for that argument expression.\nstatic QualType getPreferredArgumentTypeForMessageSend(ResultBuilder &Results,\n                                                       unsigned NumSelIdents) {\n  typedef CodeCompletionResult Result;\n  ASTContext &Context = Results.getSema().Context;\n\n  QualType PreferredType;\n  unsigned BestPriority = CCP_Unlikely * 2;\n  Result *ResultsData = Results.data();\n  for (unsigned I = 0, N = Results.size(); I != N; ++I) {\n    Result &R = ResultsData[I];\n    if (R.Kind == Result::RK_Declaration &&\n        isa<ObjCMethodDecl>(R.Declaration)) {\n      if (R.Priority <= BestPriority) {\n        const ObjCMethodDecl *Method = cast<ObjCMethodDecl>(R.Declaration);\n        if (NumSelIdents <= Method->param_size()) {\n          QualType MyPreferredType =\n              Method->parameters()[NumSelIdents - 1]->getType();\n          if (R.Priority < BestPriority || PreferredType.isNull()) {\n            BestPriority = R.Priority;\n            PreferredType = MyPreferredType;\n          } else if (!Context.hasSameUnqualifiedType(PreferredType,\n                                                     MyPreferredType)) {\n            PreferredType = QualType();\n          }\n        }\n      }\n    }\n  }\n\n  return PreferredType;\n}\n\nstatic void AddClassMessageCompletions(Sema &SemaRef, Scope *S,\n                                       ParsedType Receiver,\n                                       ArrayRef<IdentifierInfo *> SelIdents,\n                                       bool AtArgumentExpression, bool IsSuper,\n                                       ResultBuilder &Results) {\n  typedef CodeCompletionResult Result;\n  ObjCInterfaceDecl *CDecl = nullptr;\n\n  // If the given name refers to an interface type, retrieve the\n  // corresponding declaration.\n  if (Receiver) {\n    QualType T = SemaRef.GetTypeFromParser(Receiver, nullptr);\n    if (!T.isNull())\n      if (const ObjCObjectType *Interface = T->getAs<ObjCObjectType>())\n        CDecl = Interface->getInterface();\n  }\n\n  // Add all of the factory methods in this Objective-C class, its protocols,\n  // superclasses, categories, implementation, etc.\n  Results.EnterNewScope();\n\n  // If this is a send-to-super, try to add the special \"super\" send\n  // completion.\n  if (IsSuper) {\n    if (ObjCMethodDecl *SuperMethod =\n            AddSuperSendCompletion(SemaRef, false, SelIdents, Results))\n      Results.Ignore(SuperMethod);\n  }\n\n  // If we're inside an Objective-C method definition, prefer its selector to\n  // others.\n  if (ObjCMethodDecl *CurMethod = SemaRef.getCurMethodDecl())\n    Results.setPreferredSelector(CurMethod->getSelector());\n\n  VisitedSelectorSet Selectors;\n  if (CDecl)\n    AddObjCMethods(CDecl, false, MK_Any, SelIdents, SemaRef.CurContext,\n                   Selectors, AtArgumentExpression, Results);\n  else {\n    // We're messaging \"id\" as a type; provide all class/factory methods.\n\n    // If we have an external source, load the entire class method\n    // pool from the AST file.\n    if (SemaRef.getExternalSource()) {\n      for (uint32_t I = 0,\n                    N = SemaRef.getExternalSource()->GetNumExternalSelectors();\n           I != N; ++I) {\n        Selector Sel = SemaRef.getExternalSource()->GetExternalSelector(I);\n        if (Sel.isNull() || SemaRef.MethodPool.count(Sel))\n          continue;\n\n        SemaRef.ReadMethodPool(Sel);\n      }\n    }\n\n    for (Sema::GlobalMethodPool::iterator M = SemaRef.MethodPool.begin(),\n                                          MEnd = SemaRef.MethodPool.end();\n         M != MEnd; ++M) {\n      for (ObjCMethodList *MethList = &M->second.second;\n           MethList && MethList->getMethod(); MethList = MethList->getNext()) {\n        if (!isAcceptableObjCMethod(MethList->getMethod(), MK_Any, SelIdents))\n          continue;\n\n        Result R(MethList->getMethod(),\n                 Results.getBasePriority(MethList->getMethod()), nullptr);\n        R.StartParameter = SelIdents.size();\n        R.AllParametersAreInformative = false;\n        Results.MaybeAddResult(R, SemaRef.CurContext);\n      }\n    }\n  }\n\n  Results.ExitScope();\n}\n\nvoid Sema::CodeCompleteObjCClassMessage(Scope *S, ParsedType Receiver,\n                                        ArrayRef<IdentifierInfo *> SelIdents,\n                                        bool AtArgumentExpression,\n                                        bool IsSuper) {\n\n  QualType T = this->GetTypeFromParser(Receiver);\n\n  ResultBuilder Results(\n      *this, CodeCompleter->getAllocator(),\n      CodeCompleter->getCodeCompletionTUInfo(),\n      CodeCompletionContext(CodeCompletionContext::CCC_ObjCClassMessage, T,\n                            SelIdents));\n\n  AddClassMessageCompletions(*this, S, Receiver, SelIdents,\n                             AtArgumentExpression, IsSuper, Results);\n\n  // If we're actually at the argument expression (rather than prior to the\n  // selector), we're actually performing code completion for an expression.\n  // Determine whether we have a single, best method. If so, we can\n  // code-complete the expression using the corresponding parameter type as\n  // our preferred type, improving completion results.\n  if (AtArgumentExpression) {\n    QualType PreferredType =\n        getPreferredArgumentTypeForMessageSend(Results, SelIdents.size());\n    if (PreferredType.isNull())\n      CodeCompleteOrdinaryName(S, PCC_Expression);\n    else\n      CodeCompleteExpression(S, PreferredType);\n    return;\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCInstanceMessage(Scope *S, Expr *Receiver,\n                                           ArrayRef<IdentifierInfo *> SelIdents,\n                                           bool AtArgumentExpression,\n                                           ObjCInterfaceDecl *Super) {\n  typedef CodeCompletionResult Result;\n\n  Expr *RecExpr = static_cast<Expr *>(Receiver);\n\n  // If necessary, apply function/array conversion to the receiver.\n  // C99 6.7.5.3p[7,8].\n  if (RecExpr) {\n    ExprResult Conv = DefaultFunctionArrayLvalueConversion(RecExpr);\n    if (Conv.isInvalid()) // conversion failed. bail.\n      return;\n    RecExpr = Conv.get();\n  }\n  QualType ReceiverType = RecExpr\n                              ? RecExpr->getType()\n                              : Super ? Context.getObjCObjectPointerType(\n                                            Context.getObjCInterfaceType(Super))\n                                      : Context.getObjCIdType();\n\n  // If we're messaging an expression with type \"id\" or \"Class\", check\n  // whether we know something special about the receiver that allows\n  // us to assume a more-specific receiver type.\n  if (ReceiverType->isObjCIdType() || ReceiverType->isObjCClassType()) {\n    if (ObjCInterfaceDecl *IFace = GetAssumedMessageSendExprType(RecExpr)) {\n      if (ReceiverType->isObjCClassType())\n        return CodeCompleteObjCClassMessage(\n            S, ParsedType::make(Context.getObjCInterfaceType(IFace)), SelIdents,\n            AtArgumentExpression, Super);\n\n      ReceiverType =\n          Context.getObjCObjectPointerType(Context.getObjCInterfaceType(IFace));\n    }\n  } else if (RecExpr && getLangOpts().CPlusPlus) {\n    ExprResult Conv = PerformContextuallyConvertToObjCPointer(RecExpr);\n    if (Conv.isUsable()) {\n      RecExpr = Conv.get();\n      ReceiverType = RecExpr->getType();\n    }\n  }\n\n  // Build the set of methods we can see.\n  ResultBuilder Results(\n      *this, CodeCompleter->getAllocator(),\n      CodeCompleter->getCodeCompletionTUInfo(),\n      CodeCompletionContext(CodeCompletionContext::CCC_ObjCInstanceMessage,\n                            ReceiverType, SelIdents));\n\n  Results.EnterNewScope();\n\n  // If this is a send-to-super, try to add the special \"super\" send\n  // completion.\n  if (Super) {\n    if (ObjCMethodDecl *SuperMethod =\n            AddSuperSendCompletion(*this, false, SelIdents, Results))\n      Results.Ignore(SuperMethod);\n  }\n\n  // If we're inside an Objective-C method definition, prefer its selector to\n  // others.\n  if (ObjCMethodDecl *CurMethod = getCurMethodDecl())\n    Results.setPreferredSelector(CurMethod->getSelector());\n\n  // Keep track of the selectors we've already added.\n  VisitedSelectorSet Selectors;\n\n  // Handle messages to Class. This really isn't a message to an instance\n  // method, so we treat it the same way we would treat a message send to a\n  // class method.\n  if (ReceiverType->isObjCClassType() ||\n      ReceiverType->isObjCQualifiedClassType()) {\n    if (ObjCMethodDecl *CurMethod = getCurMethodDecl()) {\n      if (ObjCInterfaceDecl *ClassDecl = CurMethod->getClassInterface())\n        AddObjCMethods(ClassDecl, false, MK_Any, SelIdents, CurContext,\n                       Selectors, AtArgumentExpression, Results);\n    }\n  }\n  // Handle messages to a qualified ID (\"id<foo>\").\n  else if (const ObjCObjectPointerType *QualID =\n               ReceiverType->getAsObjCQualifiedIdType()) {\n    // Search protocols for instance methods.\n    for (auto *I : QualID->quals())\n      AddObjCMethods(I, true, MK_Any, SelIdents, CurContext, Selectors,\n                     AtArgumentExpression, Results);\n  }\n  // Handle messages to a pointer to interface type.\n  else if (const ObjCObjectPointerType *IFacePtr =\n               ReceiverType->getAsObjCInterfacePointerType()) {\n    // Search the class, its superclasses, etc., for instance methods.\n    AddObjCMethods(IFacePtr->getInterfaceDecl(), true, MK_Any, SelIdents,\n                   CurContext, Selectors, AtArgumentExpression, Results);\n\n    // Search protocols for instance methods.\n    for (auto *I : IFacePtr->quals())\n      AddObjCMethods(I, true, MK_Any, SelIdents, CurContext, Selectors,\n                     AtArgumentExpression, Results);\n  }\n  // Handle messages to \"id\".\n  else if (ReceiverType->isObjCIdType()) {\n    // We're messaging \"id\", so provide all instance methods we know\n    // about as code-completion results.\n\n    // If we have an external source, load the entire class method\n    // pool from the AST file.\n    if (ExternalSource) {\n      for (uint32_t I = 0, N = ExternalSource->GetNumExternalSelectors();\n           I != N; ++I) {\n        Selector Sel = ExternalSource->GetExternalSelector(I);\n        if (Sel.isNull() || MethodPool.count(Sel))\n          continue;\n\n        ReadMethodPool(Sel);\n      }\n    }\n\n    for (GlobalMethodPool::iterator M = MethodPool.begin(),\n                                    MEnd = MethodPool.end();\n         M != MEnd; ++M) {\n      for (ObjCMethodList *MethList = &M->second.first;\n           MethList && MethList->getMethod(); MethList = MethList->getNext()) {\n        if (!isAcceptableObjCMethod(MethList->getMethod(), MK_Any, SelIdents))\n          continue;\n\n        if (!Selectors.insert(MethList->getMethod()->getSelector()).second)\n          continue;\n\n        Result R(MethList->getMethod(),\n                 Results.getBasePriority(MethList->getMethod()), nullptr);\n        R.StartParameter = SelIdents.size();\n        R.AllParametersAreInformative = false;\n        Results.MaybeAddResult(R, CurContext);\n      }\n    }\n  }\n  Results.ExitScope();\n\n  // If we're actually at the argument expression (rather than prior to the\n  // selector), we're actually performing code completion for an expression.\n  // Determine whether we have a single, best method. If so, we can\n  // code-complete the expression using the corresponding parameter type as\n  // our preferred type, improving completion results.\n  if (AtArgumentExpression) {\n    QualType PreferredType =\n        getPreferredArgumentTypeForMessageSend(Results, SelIdents.size());\n    if (PreferredType.isNull())\n      CodeCompleteOrdinaryName(S, PCC_Expression);\n    else\n      CodeCompleteExpression(S, PreferredType);\n    return;\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCForCollection(Scope *S,\n                                         DeclGroupPtrTy IterationVar) {\n  CodeCompleteExpressionData Data;\n  Data.ObjCCollection = true;\n\n  if (IterationVar.getAsOpaquePtr()) {\n    DeclGroupRef DG = IterationVar.get();\n    for (DeclGroupRef::iterator I = DG.begin(), End = DG.end(); I != End; ++I) {\n      if (*I)\n        Data.IgnoreDecls.push_back(*I);\n    }\n  }\n\n  CodeCompleteExpression(S, Data);\n}\n\nvoid Sema::CodeCompleteObjCSelector(Scope *S,\n                                    ArrayRef<IdentifierInfo *> SelIdents) {\n  // If we have an external source, load the entire class method\n  // pool from the AST file.\n  if (ExternalSource) {\n    for (uint32_t I = 0, N = ExternalSource->GetNumExternalSelectors(); I != N;\n         ++I) {\n      Selector Sel = ExternalSource->GetExternalSelector(I);\n      if (Sel.isNull() || MethodPool.count(Sel))\n        continue;\n\n      ReadMethodPool(Sel);\n    }\n  }\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_SelectorName);\n  Results.EnterNewScope();\n  for (GlobalMethodPool::iterator M = MethodPool.begin(),\n                                  MEnd = MethodPool.end();\n       M != MEnd; ++M) {\n\n    Selector Sel = M->first;\n    if (!isAcceptableObjCSelector(Sel, MK_Any, SelIdents))\n      continue;\n\n    CodeCompletionBuilder Builder(Results.getAllocator(),\n                                  Results.getCodeCompletionTUInfo());\n    if (Sel.isUnarySelector()) {\n      Builder.AddTypedTextChunk(\n          Builder.getAllocator().CopyString(Sel.getNameForSlot(0)));\n      Results.AddResult(Builder.TakeString());\n      continue;\n    }\n\n    std::string Accumulator;\n    for (unsigned I = 0, N = Sel.getNumArgs(); I != N; ++I) {\n      if (I == SelIdents.size()) {\n        if (!Accumulator.empty()) {\n          Builder.AddInformativeChunk(\n              Builder.getAllocator().CopyString(Accumulator));\n          Accumulator.clear();\n        }\n      }\n\n      Accumulator += Sel.getNameForSlot(I);\n      Accumulator += ':';\n    }\n    Builder.AddTypedTextChunk(Builder.getAllocator().CopyString(Accumulator));\n    Results.AddResult(Builder.TakeString());\n  }\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\n/// Add all of the protocol declarations that we find in the given\n/// (translation unit) context.\nstatic void AddProtocolResults(DeclContext *Ctx, DeclContext *CurContext,\n                               bool OnlyForwardDeclarations,\n                               ResultBuilder &Results) {\n  typedef CodeCompletionResult Result;\n\n  for (const auto *D : Ctx->decls()) {\n    // Record any protocols we find.\n    if (const auto *Proto = dyn_cast<ObjCProtocolDecl>(D))\n      if (!OnlyForwardDeclarations || !Proto->hasDefinition())\n        Results.AddResult(\n            Result(Proto, Results.getBasePriority(Proto), nullptr), CurContext,\n            nullptr, false);\n  }\n}\n\nvoid Sema::CodeCompleteObjCProtocolReferences(\n    ArrayRef<IdentifierLocPair> Protocols) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_ObjCProtocolName);\n\n  if (CodeCompleter->includeGlobals()) {\n    Results.EnterNewScope();\n\n    // Tell the result set to ignore all of the protocols we have\n    // already seen.\n    // FIXME: This doesn't work when caching code-completion results.\n    for (const IdentifierLocPair &Pair : Protocols)\n      if (ObjCProtocolDecl *Protocol = LookupProtocol(Pair.first, Pair.second))\n        Results.Ignore(Protocol);\n\n    // Add all protocols.\n    AddProtocolResults(Context.getTranslationUnitDecl(), CurContext, false,\n                       Results);\n\n    Results.ExitScope();\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCProtocolDecl(Scope *) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_ObjCProtocolName);\n\n  if (CodeCompleter->includeGlobals()) {\n    Results.EnterNewScope();\n\n    // Add all protocols.\n    AddProtocolResults(Context.getTranslationUnitDecl(), CurContext, true,\n                       Results);\n\n    Results.ExitScope();\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\n/// Add all of the Objective-C interface declarations that we find in\n/// the given (translation unit) context.\nstatic void AddInterfaceResults(DeclContext *Ctx, DeclContext *CurContext,\n                                bool OnlyForwardDeclarations,\n                                bool OnlyUnimplemented,\n                                ResultBuilder &Results) {\n  typedef CodeCompletionResult Result;\n\n  for (const auto *D : Ctx->decls()) {\n    // Record any interfaces we find.\n    if (const auto *Class = dyn_cast<ObjCInterfaceDecl>(D))\n      if ((!OnlyForwardDeclarations || !Class->hasDefinition()) &&\n          (!OnlyUnimplemented || !Class->getImplementation()))\n        Results.AddResult(\n            Result(Class, Results.getBasePriority(Class), nullptr), CurContext,\n            nullptr, false);\n  }\n}\n\nvoid Sema::CodeCompleteObjCInterfaceDecl(Scope *S) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_ObjCInterfaceName);\n  Results.EnterNewScope();\n\n  if (CodeCompleter->includeGlobals()) {\n    // Add all classes.\n    AddInterfaceResults(Context.getTranslationUnitDecl(), CurContext, false,\n                        false, Results);\n  }\n\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCSuperclass(Scope *S, IdentifierInfo *ClassName,\n                                      SourceLocation ClassNameLoc) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_ObjCInterfaceName);\n  Results.EnterNewScope();\n\n  // Make sure that we ignore the class we're currently defining.\n  NamedDecl *CurClass =\n      LookupSingleName(TUScope, ClassName, ClassNameLoc, LookupOrdinaryName);\n  if (CurClass && isa<ObjCInterfaceDecl>(CurClass))\n    Results.Ignore(CurClass);\n\n  if (CodeCompleter->includeGlobals()) {\n    // Add all classes.\n    AddInterfaceResults(Context.getTranslationUnitDecl(), CurContext, false,\n                        false, Results);\n  }\n\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCImplementationDecl(Scope *S) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_ObjCImplementation);\n  Results.EnterNewScope();\n\n  if (CodeCompleter->includeGlobals()) {\n    // Add all unimplemented classes.\n    AddInterfaceResults(Context.getTranslationUnitDecl(), CurContext, false,\n                        true, Results);\n  }\n\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCInterfaceCategory(Scope *S,\n                                             IdentifierInfo *ClassName,\n                                             SourceLocation ClassNameLoc) {\n  typedef CodeCompletionResult Result;\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_ObjCCategoryName);\n\n  // Ignore any categories we find that have already been implemented by this\n  // interface.\n  llvm::SmallPtrSet<IdentifierInfo *, 16> CategoryNames;\n  NamedDecl *CurClass =\n      LookupSingleName(TUScope, ClassName, ClassNameLoc, LookupOrdinaryName);\n  if (ObjCInterfaceDecl *Class =\n          dyn_cast_or_null<ObjCInterfaceDecl>(CurClass)) {\n    for (const auto *Cat : Class->visible_categories())\n      CategoryNames.insert(Cat->getIdentifier());\n  }\n\n  // Add all of the categories we know about.\n  Results.EnterNewScope();\n  TranslationUnitDecl *TU = Context.getTranslationUnitDecl();\n  for (const auto *D : TU->decls())\n    if (const auto *Category = dyn_cast<ObjCCategoryDecl>(D))\n      if (CategoryNames.insert(Category->getIdentifier()).second)\n        Results.AddResult(\n            Result(Category, Results.getBasePriority(Category), nullptr),\n            CurContext, nullptr, false);\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCImplementationCategory(Scope *S,\n                                                  IdentifierInfo *ClassName,\n                                                  SourceLocation ClassNameLoc) {\n  typedef CodeCompletionResult Result;\n\n  // Find the corresponding interface. If we couldn't find the interface, the\n  // program itself is ill-formed. However, we'll try to be helpful still by\n  // providing the list of all of the categories we know about.\n  NamedDecl *CurClass =\n      LookupSingleName(TUScope, ClassName, ClassNameLoc, LookupOrdinaryName);\n  ObjCInterfaceDecl *Class = dyn_cast_or_null<ObjCInterfaceDecl>(CurClass);\n  if (!Class)\n    return CodeCompleteObjCInterfaceCategory(S, ClassName, ClassNameLoc);\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_ObjCCategoryName);\n\n  // Add all of the categories that have have corresponding interface\n  // declarations in this class and any of its superclasses, except for\n  // already-implemented categories in the class itself.\n  llvm::SmallPtrSet<IdentifierInfo *, 16> CategoryNames;\n  Results.EnterNewScope();\n  bool IgnoreImplemented = true;\n  while (Class) {\n    for (const auto *Cat : Class->visible_categories()) {\n      if ((!IgnoreImplemented || !Cat->getImplementation()) &&\n          CategoryNames.insert(Cat->getIdentifier()).second)\n        Results.AddResult(Result(Cat, Results.getBasePriority(Cat), nullptr),\n                          CurContext, nullptr, false);\n    }\n\n    Class = Class->getSuperClass();\n    IgnoreImplemented = false;\n  }\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCPropertyDefinition(Scope *S) {\n  CodeCompletionContext CCContext(CodeCompletionContext::CCC_Other);\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(), CCContext);\n\n  // Figure out where this @synthesize lives.\n  ObjCContainerDecl *Container =\n      dyn_cast_or_null<ObjCContainerDecl>(CurContext);\n  if (!Container || (!isa<ObjCImplementationDecl>(Container) &&\n                     !isa<ObjCCategoryImplDecl>(Container)))\n    return;\n\n  // Ignore any properties that have already been implemented.\n  Container = getContainerDef(Container);\n  for (const auto *D : Container->decls())\n    if (const auto *PropertyImpl = dyn_cast<ObjCPropertyImplDecl>(D))\n      Results.Ignore(PropertyImpl->getPropertyDecl());\n\n  // Add any properties that we find.\n  AddedPropertiesSet AddedProperties;\n  Results.EnterNewScope();\n  if (ObjCImplementationDecl *ClassImpl =\n          dyn_cast<ObjCImplementationDecl>(Container))\n    AddObjCProperties(CCContext, ClassImpl->getClassInterface(), false,\n                      /*AllowNullaryMethods=*/false, CurContext,\n                      AddedProperties, Results);\n  else\n    AddObjCProperties(CCContext,\n                      cast<ObjCCategoryImplDecl>(Container)->getCategoryDecl(),\n                      false, /*AllowNullaryMethods=*/false, CurContext,\n                      AddedProperties, Results);\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCPropertySynthesizeIvar(\n    Scope *S, IdentifierInfo *PropertyName) {\n  typedef CodeCompletionResult Result;\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n\n  // Figure out where this @synthesize lives.\n  ObjCContainerDecl *Container =\n      dyn_cast_or_null<ObjCContainerDecl>(CurContext);\n  if (!Container || (!isa<ObjCImplementationDecl>(Container) &&\n                     !isa<ObjCCategoryImplDecl>(Container)))\n    return;\n\n  // Figure out which interface we're looking into.\n  ObjCInterfaceDecl *Class = nullptr;\n  if (ObjCImplementationDecl *ClassImpl =\n          dyn_cast<ObjCImplementationDecl>(Container))\n    Class = ClassImpl->getClassInterface();\n  else\n    Class = cast<ObjCCategoryImplDecl>(Container)\n                ->getCategoryDecl()\n                ->getClassInterface();\n\n  // Determine the type of the property we're synthesizing.\n  QualType PropertyType = Context.getObjCIdType();\n  if (Class) {\n    if (ObjCPropertyDecl *Property = Class->FindPropertyDeclaration(\n            PropertyName, ObjCPropertyQueryKind::OBJC_PR_query_instance)) {\n      PropertyType =\n          Property->getType().getNonReferenceType().getUnqualifiedType();\n\n      // Give preference to ivars\n      Results.setPreferredType(PropertyType);\n    }\n  }\n\n  // Add all of the instance variables in this class and its superclasses.\n  Results.EnterNewScope();\n  bool SawSimilarlyNamedIvar = false;\n  std::string NameWithPrefix;\n  NameWithPrefix += '_';\n  NameWithPrefix += PropertyName->getName();\n  std::string NameWithSuffix = PropertyName->getName().str();\n  NameWithSuffix += '_';\n  for (; Class; Class = Class->getSuperClass()) {\n    for (ObjCIvarDecl *Ivar = Class->all_declared_ivar_begin(); Ivar;\n         Ivar = Ivar->getNextIvar()) {\n      Results.AddResult(Result(Ivar, Results.getBasePriority(Ivar), nullptr),\n                        CurContext, nullptr, false);\n\n      // Determine whether we've seen an ivar with a name similar to the\n      // property.\n      if ((PropertyName == Ivar->getIdentifier() ||\n           NameWithPrefix == Ivar->getName() ||\n           NameWithSuffix == Ivar->getName())) {\n        SawSimilarlyNamedIvar = true;\n\n        // Reduce the priority of this result by one, to give it a slight\n        // advantage over other results whose names don't match so closely.\n        if (Results.size() &&\n            Results.data()[Results.size() - 1].Kind ==\n                CodeCompletionResult::RK_Declaration &&\n            Results.data()[Results.size() - 1].Declaration == Ivar)\n          Results.data()[Results.size() - 1].Priority--;\n      }\n    }\n  }\n\n  if (!SawSimilarlyNamedIvar) {\n    // Create ivar result _propName, that the user can use to synthesize\n    // an ivar of the appropriate type.\n    unsigned Priority = CCP_MemberDeclaration + 1;\n    typedef CodeCompletionResult Result;\n    CodeCompletionAllocator &Allocator = Results.getAllocator();\n    CodeCompletionBuilder Builder(Allocator, Results.getCodeCompletionTUInfo(),\n                                  Priority, CXAvailability_Available);\n\n    PrintingPolicy Policy = getCompletionPrintingPolicy(*this);\n    Builder.AddResultTypeChunk(\n        GetCompletionTypeString(PropertyType, Context, Policy, Allocator));\n    Builder.AddTypedTextChunk(Allocator.CopyString(NameWithPrefix));\n    Results.AddResult(\n        Result(Builder.TakeString(), Priority, CXCursor_ObjCIvarDecl));\n  }\n\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\n// Mapping from selectors to the methods that implement that selector, along\n// with the \"in original class\" flag.\ntypedef llvm::DenseMap<Selector,\n                       llvm::PointerIntPair<ObjCMethodDecl *, 1, bool>>\n    KnownMethodsMap;\n\n/// Find all of the methods that reside in the given container\n/// (and its superclasses, protocols, etc.) that meet the given\n/// criteria. Insert those methods into the map of known methods,\n/// indexed by selector so they can be easily found.\nstatic void FindImplementableMethods(ASTContext &Context,\n                                     ObjCContainerDecl *Container,\n                                     Optional<bool> WantInstanceMethods,\n                                     QualType ReturnType,\n                                     KnownMethodsMap &KnownMethods,\n                                     bool InOriginalClass = true) {\n  if (ObjCInterfaceDecl *IFace = dyn_cast<ObjCInterfaceDecl>(Container)) {\n    // Make sure we have a definition; that's what we'll walk.\n    if (!IFace->hasDefinition())\n      return;\n\n    IFace = IFace->getDefinition();\n    Container = IFace;\n\n    const ObjCList<ObjCProtocolDecl> &Protocols =\n        IFace->getReferencedProtocols();\n    for (ObjCList<ObjCProtocolDecl>::iterator I = Protocols.begin(),\n                                              E = Protocols.end();\n         I != E; ++I)\n      FindImplementableMethods(Context, *I, WantInstanceMethods, ReturnType,\n                               KnownMethods, InOriginalClass);\n\n    // Add methods from any class extensions and categories.\n    for (auto *Cat : IFace->visible_categories()) {\n      FindImplementableMethods(Context, Cat, WantInstanceMethods, ReturnType,\n                               KnownMethods, false);\n    }\n\n    // Visit the superclass.\n    if (IFace->getSuperClass())\n      FindImplementableMethods(Context, IFace->getSuperClass(),\n                               WantInstanceMethods, ReturnType, KnownMethods,\n                               false);\n  }\n\n  if (ObjCCategoryDecl *Category = dyn_cast<ObjCCategoryDecl>(Container)) {\n    // Recurse into protocols.\n    const ObjCList<ObjCProtocolDecl> &Protocols =\n        Category->getReferencedProtocols();\n    for (ObjCList<ObjCProtocolDecl>::iterator I = Protocols.begin(),\n                                              E = Protocols.end();\n         I != E; ++I)\n      FindImplementableMethods(Context, *I, WantInstanceMethods, ReturnType,\n                               KnownMethods, InOriginalClass);\n\n    // If this category is the original class, jump to the interface.\n    if (InOriginalClass && Category->getClassInterface())\n      FindImplementableMethods(Context, Category->getClassInterface(),\n                               WantInstanceMethods, ReturnType, KnownMethods,\n                               false);\n  }\n\n  if (ObjCProtocolDecl *Protocol = dyn_cast<ObjCProtocolDecl>(Container)) {\n    // Make sure we have a definition; that's what we'll walk.\n    if (!Protocol->hasDefinition())\n      return;\n    Protocol = Protocol->getDefinition();\n    Container = Protocol;\n\n    // Recurse into protocols.\n    const ObjCList<ObjCProtocolDecl> &Protocols =\n        Protocol->getReferencedProtocols();\n    for (ObjCList<ObjCProtocolDecl>::iterator I = Protocols.begin(),\n                                              E = Protocols.end();\n         I != E; ++I)\n      FindImplementableMethods(Context, *I, WantInstanceMethods, ReturnType,\n                               KnownMethods, false);\n  }\n\n  // Add methods in this container. This operation occurs last because\n  // we want the methods from this container to override any methods\n  // we've previously seen with the same selector.\n  for (auto *M : Container->methods()) {\n    if (!WantInstanceMethods || M->isInstanceMethod() == *WantInstanceMethods) {\n      if (!ReturnType.isNull() &&\n          !Context.hasSameUnqualifiedType(ReturnType, M->getReturnType()))\n        continue;\n\n      KnownMethods[M->getSelector()] =\n          KnownMethodsMap::mapped_type(M, InOriginalClass);\n    }\n  }\n}\n\n/// Add the parenthesized return or parameter type chunk to a code\n/// completion string.\nstatic void AddObjCPassingTypeChunk(QualType Type, unsigned ObjCDeclQuals,\n                                    ASTContext &Context,\n                                    const PrintingPolicy &Policy,\n                                    CodeCompletionBuilder &Builder) {\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n  std::string Quals = formatObjCParamQualifiers(ObjCDeclQuals, Type);\n  if (!Quals.empty())\n    Builder.AddTextChunk(Builder.getAllocator().CopyString(Quals));\n  Builder.AddTextChunk(\n      GetCompletionTypeString(Type, Context, Policy, Builder.getAllocator()));\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n}\n\n/// Determine whether the given class is or inherits from a class by\n/// the given name.\nstatic bool InheritsFromClassNamed(ObjCInterfaceDecl *Class, StringRef Name) {\n  if (!Class)\n    return false;\n\n  if (Class->getIdentifier() && Class->getIdentifier()->getName() == Name)\n    return true;\n\n  return InheritsFromClassNamed(Class->getSuperClass(), Name);\n}\n\n/// Add code completions for Objective-C Key-Value Coding (KVC) and\n/// Key-Value Observing (KVO).\nstatic void AddObjCKeyValueCompletions(ObjCPropertyDecl *Property,\n                                       bool IsInstanceMethod,\n                                       QualType ReturnType, ASTContext &Context,\n                                       VisitedSelectorSet &KnownSelectors,\n                                       ResultBuilder &Results) {\n  IdentifierInfo *PropName = Property->getIdentifier();\n  if (!PropName || PropName->getLength() == 0)\n    return;\n\n  PrintingPolicy Policy = getCompletionPrintingPolicy(Results.getSema());\n\n  // Builder that will create each code completion.\n  typedef CodeCompletionResult Result;\n  CodeCompletionAllocator &Allocator = Results.getAllocator();\n  CodeCompletionBuilder Builder(Allocator, Results.getCodeCompletionTUInfo());\n\n  // The selector table.\n  SelectorTable &Selectors = Context.Selectors;\n\n  // The property name, copied into the code completion allocation region\n  // on demand.\n  struct KeyHolder {\n    CodeCompletionAllocator &Allocator;\n    StringRef Key;\n    const char *CopiedKey;\n\n    KeyHolder(CodeCompletionAllocator &Allocator, StringRef Key)\n        : Allocator(Allocator), Key(Key), CopiedKey(nullptr) {}\n\n    operator const char *() {\n      if (CopiedKey)\n        return CopiedKey;\n\n      return CopiedKey = Allocator.CopyString(Key);\n    }\n  } Key(Allocator, PropName->getName());\n\n  // The uppercased name of the property name.\n  std::string UpperKey = std::string(PropName->getName());\n  if (!UpperKey.empty())\n    UpperKey[0] = toUppercase(UpperKey[0]);\n\n  bool ReturnTypeMatchesProperty =\n      ReturnType.isNull() ||\n      Context.hasSameUnqualifiedType(ReturnType.getNonReferenceType(),\n                                     Property->getType());\n  bool ReturnTypeMatchesVoid = ReturnType.isNull() || ReturnType->isVoidType();\n\n  // Add the normal accessor -(type)key.\n  if (IsInstanceMethod &&\n      KnownSelectors.insert(Selectors.getNullarySelector(PropName)).second &&\n      ReturnTypeMatchesProperty && !Property->getGetterMethodDecl()) {\n    if (ReturnType.isNull())\n      AddObjCPassingTypeChunk(Property->getType(), /*Quals=*/0, Context, Policy,\n                              Builder);\n\n    Builder.AddTypedTextChunk(Key);\n    Results.AddResult(Result(Builder.TakeString(), CCP_CodePattern,\n                             CXCursor_ObjCInstanceMethodDecl));\n  }\n\n  // If we have an integral or boolean property (or the user has provided\n  // an integral or boolean return type), add the accessor -(type)isKey.\n  if (IsInstanceMethod &&\n      ((!ReturnType.isNull() &&\n        (ReturnType->isIntegerType() || ReturnType->isBooleanType())) ||\n       (ReturnType.isNull() && (Property->getType()->isIntegerType() ||\n                                Property->getType()->isBooleanType())))) {\n    std::string SelectorName = (Twine(\"is\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getNullarySelector(SelectorId))\n            .second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"BOOL\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorId->getName()));\n      Results.AddResult(Result(Builder.TakeString(), CCP_CodePattern,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Add the normal mutator.\n  if (IsInstanceMethod && ReturnTypeMatchesVoid &&\n      !Property->getSetterMethodDecl()) {\n    std::string SelectorName = (Twine(\"set\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(\n          Allocator.CopyString(SelectorId->getName() + \":\"));\n      AddObjCPassingTypeChunk(Property->getType(), /*Quals=*/0, Context, Policy,\n                              Builder);\n      Builder.AddTextChunk(Key);\n      Results.AddResult(Result(Builder.TakeString(), CCP_CodePattern,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Indexed and unordered accessors\n  unsigned IndexedGetterPriority = CCP_CodePattern;\n  unsigned IndexedSetterPriority = CCP_CodePattern;\n  unsigned UnorderedGetterPriority = CCP_CodePattern;\n  unsigned UnorderedSetterPriority = CCP_CodePattern;\n  if (const auto *ObjCPointer =\n          Property->getType()->getAs<ObjCObjectPointerType>()) {\n    if (ObjCInterfaceDecl *IFace = ObjCPointer->getInterfaceDecl()) {\n      // If this interface type is not provably derived from a known\n      // collection, penalize the corresponding completions.\n      if (!InheritsFromClassNamed(IFace, \"NSMutableArray\")) {\n        IndexedSetterPriority += CCD_ProbablyNotObjCCollection;\n        if (!InheritsFromClassNamed(IFace, \"NSArray\"))\n          IndexedGetterPriority += CCD_ProbablyNotObjCCollection;\n      }\n\n      if (!InheritsFromClassNamed(IFace, \"NSMutableSet\")) {\n        UnorderedSetterPriority += CCD_ProbablyNotObjCCollection;\n        if (!InheritsFromClassNamed(IFace, \"NSSet\"))\n          UnorderedGetterPriority += CCD_ProbablyNotObjCCollection;\n      }\n    }\n  } else {\n    IndexedGetterPriority += CCD_ProbablyNotObjCCollection;\n    IndexedSetterPriority += CCD_ProbablyNotObjCCollection;\n    UnorderedGetterPriority += CCD_ProbablyNotObjCCollection;\n    UnorderedSetterPriority += CCD_ProbablyNotObjCCollection;\n  }\n\n  // Add -(NSUInteger)countOf<key>\n  if (IsInstanceMethod &&\n      (ReturnType.isNull() || ReturnType->isIntegerType())) {\n    std::string SelectorName = (Twine(\"countOf\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getNullarySelector(SelectorId))\n            .second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"NSUInteger\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorId->getName()));\n      Results.AddResult(\n          Result(Builder.TakeString(),\n                 std::min(IndexedGetterPriority, UnorderedGetterPriority),\n                 CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Indexed getters\n  // Add -(id)objectInKeyAtIndex:(NSUInteger)index\n  if (IsInstanceMethod &&\n      (ReturnType.isNull() || ReturnType->isObjCObjectPointerType())) {\n    std::string SelectorName = (Twine(\"objectIn\") + UpperKey + \"AtIndex\").str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"id\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSUInteger\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"index\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedGetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Add -(NSArray *)keyAtIndexes:(NSIndexSet *)indexes\n  if (IsInstanceMethod &&\n      (ReturnType.isNull() ||\n       (ReturnType->isObjCObjectPointerType() &&\n        ReturnType->castAs<ObjCObjectPointerType>()->getInterfaceDecl() &&\n        ReturnType->castAs<ObjCObjectPointerType>()\n                ->getInterfaceDecl()\n                ->getName() == \"NSArray\"))) {\n    std::string SelectorName = (Twine(Property->getName()) + \"AtIndexes\").str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"NSArray *\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSIndexSet *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"indexes\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedGetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Add -(void)getKey:(type **)buffer range:(NSRange)inRange\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName = (Twine(\"get\") + UpperKey).str();\n    IdentifierInfo *SelectorIds[2] = {&Context.Idents.get(SelectorName),\n                                      &Context.Idents.get(\"range\")};\n\n    if (KnownSelectors.insert(Selectors.getSelector(2, SelectorIds)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"object-type\");\n      Builder.AddTextChunk(\" **\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"buffer\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddTypedTextChunk(\"range:\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSRange\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"inRange\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedGetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Mutable indexed accessors\n\n  // - (void)insertObject:(type *)object inKeyAtIndex:(NSUInteger)index\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName = (Twine(\"in\") + UpperKey + \"AtIndex\").str();\n    IdentifierInfo *SelectorIds[2] = {&Context.Idents.get(\"insertObject\"),\n                                      &Context.Idents.get(SelectorName)};\n\n    if (KnownSelectors.insert(Selectors.getSelector(2, SelectorIds)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(\"insertObject:\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"object-type\");\n      Builder.AddTextChunk(\" *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"object\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"NSUInteger\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"index\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // - (void)insertKey:(NSArray *)array atIndexes:(NSIndexSet *)indexes\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName = (Twine(\"insert\") + UpperKey).str();\n    IdentifierInfo *SelectorIds[2] = {&Context.Idents.get(SelectorName),\n                                      &Context.Idents.get(\"atIndexes\")};\n\n    if (KnownSelectors.insert(Selectors.getSelector(2, SelectorIds)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSArray *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"array\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddTypedTextChunk(\"atIndexes:\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"NSIndexSet *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"indexes\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // -(void)removeObjectFromKeyAtIndex:(NSUInteger)index\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName =\n        (Twine(\"removeObjectFrom\") + UpperKey + \"AtIndex\").str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSUInteger\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"index\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // -(void)removeKeyAtIndexes:(NSIndexSet *)indexes\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName = (Twine(\"remove\") + UpperKey + \"AtIndexes\").str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSIndexSet *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"indexes\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // - (void)replaceObjectInKeyAtIndex:(NSUInteger)index withObject:(id)object\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName =\n        (Twine(\"replaceObjectIn\") + UpperKey + \"AtIndex\").str();\n    IdentifierInfo *SelectorIds[2] = {&Context.Idents.get(SelectorName),\n                                      &Context.Idents.get(\"withObject\")};\n\n    if (KnownSelectors.insert(Selectors.getSelector(2, SelectorIds)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"NSUInteger\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"index\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddTypedTextChunk(\"withObject:\");\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"id\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"object\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // - (void)replaceKeyAtIndexes:(NSIndexSet *)indexes withKey:(NSArray *)array\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName1 =\n        (Twine(\"replace\") + UpperKey + \"AtIndexes\").str();\n    std::string SelectorName2 = (Twine(\"with\") + UpperKey).str();\n    IdentifierInfo *SelectorIds[2] = {&Context.Idents.get(SelectorName1),\n                                      &Context.Idents.get(SelectorName2)};\n\n    if (KnownSelectors.insert(Selectors.getSelector(2, SelectorIds)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName1 + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"NSIndexSet *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"indexes\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName2 + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSArray *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"array\");\n      Results.AddResult(Result(Builder.TakeString(), IndexedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Unordered getters\n  // - (NSEnumerator *)enumeratorOfKey\n  if (IsInstanceMethod &&\n      (ReturnType.isNull() ||\n       (ReturnType->isObjCObjectPointerType() &&\n        ReturnType->getAs<ObjCObjectPointerType>()->getInterfaceDecl() &&\n        ReturnType->getAs<ObjCObjectPointerType>()\n                ->getInterfaceDecl()\n                ->getName() == \"NSEnumerator\"))) {\n    std::string SelectorName = (Twine(\"enumeratorOf\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getNullarySelector(SelectorId))\n            .second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"NSEnumerator *\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName));\n      Results.AddResult(Result(Builder.TakeString(), UnorderedGetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // - (type *)memberOfKey:(type *)object\n  if (IsInstanceMethod &&\n      (ReturnType.isNull() || ReturnType->isObjCObjectPointerType())) {\n    std::string SelectorName = (Twine(\"memberOf\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddPlaceholderChunk(\"object-type\");\n        Builder.AddTextChunk(\" *\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      if (ReturnType.isNull()) {\n        Builder.AddPlaceholderChunk(\"object-type\");\n        Builder.AddTextChunk(\" *\");\n      } else {\n        Builder.AddTextChunk(GetCompletionTypeString(\n            ReturnType, Context, Policy, Builder.getAllocator()));\n      }\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"object\");\n      Results.AddResult(Result(Builder.TakeString(), UnorderedGetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Mutable unordered accessors\n  // - (void)addKeyObject:(type *)object\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName =\n        (Twine(\"add\") + UpperKey + Twine(\"Object\")).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"object-type\");\n      Builder.AddTextChunk(\" *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"object\");\n      Results.AddResult(Result(Builder.TakeString(), UnorderedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // - (void)addKey:(NSSet *)objects\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName = (Twine(\"add\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSSet *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"objects\");\n      Results.AddResult(Result(Builder.TakeString(), UnorderedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // - (void)removeKeyObject:(type *)object\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName =\n        (Twine(\"remove\") + UpperKey + Twine(\"Object\")).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddPlaceholderChunk(\"object-type\");\n      Builder.AddTextChunk(\" *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"object\");\n      Results.AddResult(Result(Builder.TakeString(), UnorderedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // - (void)removeKey:(NSSet *)objects\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName = (Twine(\"remove\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSSet *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"objects\");\n      Results.AddResult(Result(Builder.TakeString(), UnorderedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // - (void)intersectKey:(NSSet *)objects\n  if (IsInstanceMethod && ReturnTypeMatchesVoid) {\n    std::string SelectorName = (Twine(\"intersect\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getUnarySelector(SelectorId)).second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"void\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName + \":\"));\n      Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n      Builder.AddTextChunk(\"NSSet *\");\n      Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      Builder.AddTextChunk(\"objects\");\n      Results.AddResult(Result(Builder.TakeString(), UnorderedSetterPriority,\n                               CXCursor_ObjCInstanceMethodDecl));\n    }\n  }\n\n  // Key-Value Observing\n  // + (NSSet *)keyPathsForValuesAffectingKey\n  if (!IsInstanceMethod &&\n      (ReturnType.isNull() ||\n       (ReturnType->isObjCObjectPointerType() &&\n        ReturnType->castAs<ObjCObjectPointerType>()->getInterfaceDecl() &&\n        ReturnType->castAs<ObjCObjectPointerType>()\n                ->getInterfaceDecl()\n                ->getName() == \"NSSet\"))) {\n    std::string SelectorName =\n        (Twine(\"keyPathsForValuesAffecting\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getNullarySelector(SelectorId))\n            .second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"NSSet<NSString *> *\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName));\n      Results.AddResult(Result(Builder.TakeString(), CCP_CodePattern,\n                               CXCursor_ObjCClassMethodDecl));\n    }\n  }\n\n  // + (BOOL)automaticallyNotifiesObserversForKey\n  if (!IsInstanceMethod &&\n      (ReturnType.isNull() || ReturnType->isIntegerType() ||\n       ReturnType->isBooleanType())) {\n    std::string SelectorName =\n        (Twine(\"automaticallyNotifiesObserversOf\") + UpperKey).str();\n    IdentifierInfo *SelectorId = &Context.Idents.get(SelectorName);\n    if (KnownSelectors.insert(Selectors.getNullarySelector(SelectorId))\n            .second) {\n      if (ReturnType.isNull()) {\n        Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n        Builder.AddTextChunk(\"BOOL\");\n        Builder.AddChunk(CodeCompletionString::CK_RightParen);\n      }\n\n      Builder.AddTypedTextChunk(Allocator.CopyString(SelectorName));\n      Results.AddResult(Result(Builder.TakeString(), CCP_CodePattern,\n                               CXCursor_ObjCClassMethodDecl));\n    }\n  }\n}\n\nvoid Sema::CodeCompleteObjCMethodDecl(Scope *S, Optional<bool> IsInstanceMethod,\n                                      ParsedType ReturnTy) {\n  // Determine the return type of the method we're declaring, if\n  // provided.\n  QualType ReturnType = GetTypeFromParser(ReturnTy);\n  Decl *IDecl = nullptr;\n  if (CurContext->isObjCContainer()) {\n    ObjCContainerDecl *OCD = dyn_cast<ObjCContainerDecl>(CurContext);\n    IDecl = OCD;\n  }\n  // Determine where we should start searching for methods.\n  ObjCContainerDecl *SearchDecl = nullptr;\n  bool IsInImplementation = false;\n  if (Decl *D = IDecl) {\n    if (ObjCImplementationDecl *Impl = dyn_cast<ObjCImplementationDecl>(D)) {\n      SearchDecl = Impl->getClassInterface();\n      IsInImplementation = true;\n    } else if (ObjCCategoryImplDecl *CatImpl =\n                   dyn_cast<ObjCCategoryImplDecl>(D)) {\n      SearchDecl = CatImpl->getCategoryDecl();\n      IsInImplementation = true;\n    } else\n      SearchDecl = dyn_cast<ObjCContainerDecl>(D);\n  }\n\n  if (!SearchDecl && S) {\n    if (DeclContext *DC = S->getEntity())\n      SearchDecl = dyn_cast<ObjCContainerDecl>(DC);\n  }\n\n  if (!SearchDecl) {\n    HandleCodeCompleteResults(this, CodeCompleter,\n                              CodeCompletionContext::CCC_Other, nullptr, 0);\n    return;\n  }\n\n  // Find all of the methods that we could declare/implement here.\n  KnownMethodsMap KnownMethods;\n  FindImplementableMethods(Context, SearchDecl, IsInstanceMethod, ReturnType,\n                           KnownMethods);\n\n  // Add declarations or definitions for each of the known methods.\n  typedef CodeCompletionResult Result;\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n  PrintingPolicy Policy = getCompletionPrintingPolicy(*this);\n  for (KnownMethodsMap::iterator M = KnownMethods.begin(),\n                                 MEnd = KnownMethods.end();\n       M != MEnd; ++M) {\n    ObjCMethodDecl *Method = M->second.getPointer();\n    CodeCompletionBuilder Builder(Results.getAllocator(),\n                                  Results.getCodeCompletionTUInfo());\n\n    // Add the '-'/'+' prefix if it wasn't provided yet.\n    if (!IsInstanceMethod) {\n      Builder.AddTextChunk(Method->isInstanceMethod() ? \"-\" : \"+\");\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    }\n\n    // If the result type was not already provided, add it to the\n    // pattern as (type).\n    if (ReturnType.isNull()) {\n      QualType ResTy = Method->getSendResultType().stripObjCKindOfType(Context);\n      AttributedType::stripOuterNullability(ResTy);\n      AddObjCPassingTypeChunk(ResTy, Method->getObjCDeclQualifier(), Context,\n                              Policy, Builder);\n    }\n\n    Selector Sel = Method->getSelector();\n\n    if (Sel.isUnarySelector()) {\n      // Unary selectors have no arguments.\n      Builder.AddTypedTextChunk(\n          Builder.getAllocator().CopyString(Sel.getNameForSlot(0)));\n    } else {\n      // Add all parameters to the pattern.\n      unsigned I = 0;\n      for (ObjCMethodDecl::param_iterator P = Method->param_begin(),\n                                          PEnd = Method->param_end();\n           P != PEnd; (void)++P, ++I) {\n        // Add the part of the selector name.\n        if (I == 0)\n          Builder.AddTypedTextChunk(\n              Builder.getAllocator().CopyString(Sel.getNameForSlot(I) + \":\"));\n        else if (I < Sel.getNumArgs()) {\n          Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n          Builder.AddTypedTextChunk(\n              Builder.getAllocator().CopyString(Sel.getNameForSlot(I) + \":\"));\n        } else\n          break;\n\n        // Add the parameter type.\n        QualType ParamType;\n        if ((*P)->getObjCDeclQualifier() & Decl::OBJC_TQ_CSNullability)\n          ParamType = (*P)->getType();\n        else\n          ParamType = (*P)->getOriginalType();\n        ParamType = ParamType.substObjCTypeArgs(\n            Context, {}, ObjCSubstitutionContext::Parameter);\n        AttributedType::stripOuterNullability(ParamType);\n        AddObjCPassingTypeChunk(ParamType, (*P)->getObjCDeclQualifier(),\n                                Context, Policy, Builder);\n\n        if (IdentifierInfo *Id = (*P)->getIdentifier())\n          Builder.AddTextChunk(\n              Builder.getAllocator().CopyString(Id->getName()));\n      }\n    }\n\n    if (Method->isVariadic()) {\n      if (Method->param_size() > 0)\n        Builder.AddChunk(CodeCompletionString::CK_Comma);\n      Builder.AddTextChunk(\"...\");\n    }\n\n    if (IsInImplementation && Results.includeCodePatterns()) {\n      // We will be defining the method here, so add a compound statement.\n      Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_LeftBrace);\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      if (!Method->getReturnType()->isVoidType()) {\n        // If the result type is not void, add a return clause.\n        Builder.AddTextChunk(\"return\");\n        Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n        Builder.AddPlaceholderChunk(\"expression\");\n        Builder.AddChunk(CodeCompletionString::CK_SemiColon);\n      } else\n        Builder.AddPlaceholderChunk(\"statements\");\n\n      Builder.AddChunk(CodeCompletionString::CK_VerticalSpace);\n      Builder.AddChunk(CodeCompletionString::CK_RightBrace);\n    }\n\n    unsigned Priority = CCP_CodePattern;\n    auto R = Result(Builder.TakeString(), Method, Priority);\n    if (!M->second.getInt())\n      setInBaseClass(R);\n    Results.AddResult(std::move(R));\n  }\n\n  // Add Key-Value-Coding and Key-Value-Observing accessor methods for all of\n  // the properties in this class and its categories.\n  if (Context.getLangOpts().ObjC) {\n    SmallVector<ObjCContainerDecl *, 4> Containers;\n    Containers.push_back(SearchDecl);\n\n    VisitedSelectorSet KnownSelectors;\n    for (KnownMethodsMap::iterator M = KnownMethods.begin(),\n                                   MEnd = KnownMethods.end();\n         M != MEnd; ++M)\n      KnownSelectors.insert(M->first);\n\n    ObjCInterfaceDecl *IFace = dyn_cast<ObjCInterfaceDecl>(SearchDecl);\n    if (!IFace)\n      if (ObjCCategoryDecl *Category = dyn_cast<ObjCCategoryDecl>(SearchDecl))\n        IFace = Category->getClassInterface();\n\n    if (IFace)\n      for (auto *Cat : IFace->visible_categories())\n        Containers.push_back(Cat);\n\n    if (IsInstanceMethod) {\n      for (unsigned I = 0, N = Containers.size(); I != N; ++I)\n        for (auto *P : Containers[I]->instance_properties())\n          AddObjCKeyValueCompletions(P, *IsInstanceMethod, ReturnType, Context,\n                                     KnownSelectors, Results);\n    }\n  }\n\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteObjCMethodDeclSelector(\n    Scope *S, bool IsInstanceMethod, bool AtParameterName, ParsedType ReturnTy,\n    ArrayRef<IdentifierInfo *> SelIdents) {\n  // If we have an external source, load the entire class method\n  // pool from the AST file.\n  if (ExternalSource) {\n    for (uint32_t I = 0, N = ExternalSource->GetNumExternalSelectors(); I != N;\n         ++I) {\n      Selector Sel = ExternalSource->GetExternalSelector(I);\n      if (Sel.isNull() || MethodPool.count(Sel))\n        continue;\n\n      ReadMethodPool(Sel);\n    }\n  }\n\n  // Build the set of methods we can see.\n  typedef CodeCompletionResult Result;\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n\n  if (ReturnTy)\n    Results.setPreferredType(GetTypeFromParser(ReturnTy).getNonReferenceType());\n\n  Results.EnterNewScope();\n  for (GlobalMethodPool::iterator M = MethodPool.begin(),\n                                  MEnd = MethodPool.end();\n       M != MEnd; ++M) {\n    for (ObjCMethodList *MethList = IsInstanceMethod ? &M->second.first\n                                                     : &M->second.second;\n         MethList && MethList->getMethod(); MethList = MethList->getNext()) {\n      if (!isAcceptableObjCMethod(MethList->getMethod(), MK_Any, SelIdents))\n        continue;\n\n      if (AtParameterName) {\n        // Suggest parameter names we've seen before.\n        unsigned NumSelIdents = SelIdents.size();\n        if (NumSelIdents &&\n            NumSelIdents <= MethList->getMethod()->param_size()) {\n          ParmVarDecl *Param =\n              MethList->getMethod()->parameters()[NumSelIdents - 1];\n          if (Param->getIdentifier()) {\n            CodeCompletionBuilder Builder(Results.getAllocator(),\n                                          Results.getCodeCompletionTUInfo());\n            Builder.AddTypedTextChunk(Builder.getAllocator().CopyString(\n                Param->getIdentifier()->getName()));\n            Results.AddResult(Builder.TakeString());\n          }\n        }\n\n        continue;\n      }\n\n      Result R(MethList->getMethod(),\n               Results.getBasePriority(MethList->getMethod()), nullptr);\n      R.StartParameter = SelIdents.size();\n      R.AllParametersAreInformative = false;\n      R.DeclaringEntity = true;\n      Results.MaybeAddResult(R, CurContext);\n    }\n  }\n\n  Results.ExitScope();\n\n  if (!AtParameterName && !SelIdents.empty() &&\n      SelIdents.front()->getName().startswith(\"init\")) {\n    for (const auto &M : PP.macros()) {\n      if (M.first->getName() != \"NS_DESIGNATED_INITIALIZER\")\n        continue;\n      Results.EnterNewScope();\n      CodeCompletionBuilder Builder(Results.getAllocator(),\n                                    Results.getCodeCompletionTUInfo());\n      Builder.AddTypedTextChunk(\n          Builder.getAllocator().CopyString(M.first->getName()));\n      Results.AddResult(CodeCompletionResult(Builder.TakeString(), CCP_Macro,\n                                             CXCursor_MacroDefinition));\n      Results.ExitScope();\n    }\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompletePreprocessorDirective(bool InConditional) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_PreprocessorDirective);\n  Results.EnterNewScope();\n\n  // #if <condition>\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n  Builder.AddTypedTextChunk(\"if\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"condition\");\n  Results.AddResult(Builder.TakeString());\n\n  // #ifdef <macro>\n  Builder.AddTypedTextChunk(\"ifdef\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"macro\");\n  Results.AddResult(Builder.TakeString());\n\n  // #ifndef <macro>\n  Builder.AddTypedTextChunk(\"ifndef\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"macro\");\n  Results.AddResult(Builder.TakeString());\n\n  if (InConditional) {\n    // #elif <condition>\n    Builder.AddTypedTextChunk(\"elif\");\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddPlaceholderChunk(\"condition\");\n    Results.AddResult(Builder.TakeString());\n\n    // #else\n    Builder.AddTypedTextChunk(\"else\");\n    Results.AddResult(Builder.TakeString());\n\n    // #endif\n    Builder.AddTypedTextChunk(\"endif\");\n    Results.AddResult(Builder.TakeString());\n  }\n\n  // #include \"header\"\n  Builder.AddTypedTextChunk(\"include\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddTextChunk(\"\\\"\");\n  Builder.AddPlaceholderChunk(\"header\");\n  Builder.AddTextChunk(\"\\\"\");\n  Results.AddResult(Builder.TakeString());\n\n  // #include <header>\n  Builder.AddTypedTextChunk(\"include\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddTextChunk(\"<\");\n  Builder.AddPlaceholderChunk(\"header\");\n  Builder.AddTextChunk(\">\");\n  Results.AddResult(Builder.TakeString());\n\n  // #define <macro>\n  Builder.AddTypedTextChunk(\"define\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"macro\");\n  Results.AddResult(Builder.TakeString());\n\n  // #define <macro>(<args>)\n  Builder.AddTypedTextChunk(\"define\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"macro\");\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n  Builder.AddPlaceholderChunk(\"args\");\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n  Results.AddResult(Builder.TakeString());\n\n  // #undef <macro>\n  Builder.AddTypedTextChunk(\"undef\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"macro\");\n  Results.AddResult(Builder.TakeString());\n\n  // #line <number>\n  Builder.AddTypedTextChunk(\"line\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"number\");\n  Results.AddResult(Builder.TakeString());\n\n  // #line <number> \"filename\"\n  Builder.AddTypedTextChunk(\"line\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"number\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddTextChunk(\"\\\"\");\n  Builder.AddPlaceholderChunk(\"filename\");\n  Builder.AddTextChunk(\"\\\"\");\n  Results.AddResult(Builder.TakeString());\n\n  // #error <message>\n  Builder.AddTypedTextChunk(\"error\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"message\");\n  Results.AddResult(Builder.TakeString());\n\n  // #pragma <arguments>\n  Builder.AddTypedTextChunk(\"pragma\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"arguments\");\n  Results.AddResult(Builder.TakeString());\n\n  if (getLangOpts().ObjC) {\n    // #import \"header\"\n    Builder.AddTypedTextChunk(\"import\");\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddTextChunk(\"\\\"\");\n    Builder.AddPlaceholderChunk(\"header\");\n    Builder.AddTextChunk(\"\\\"\");\n    Results.AddResult(Builder.TakeString());\n\n    // #import <header>\n    Builder.AddTypedTextChunk(\"import\");\n    Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n    Builder.AddTextChunk(\"<\");\n    Builder.AddPlaceholderChunk(\"header\");\n    Builder.AddTextChunk(\">\");\n    Results.AddResult(Builder.TakeString());\n  }\n\n  // #include_next \"header\"\n  Builder.AddTypedTextChunk(\"include_next\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddTextChunk(\"\\\"\");\n  Builder.AddPlaceholderChunk(\"header\");\n  Builder.AddTextChunk(\"\\\"\");\n  Results.AddResult(Builder.TakeString());\n\n  // #include_next <header>\n  Builder.AddTypedTextChunk(\"include_next\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddTextChunk(\"<\");\n  Builder.AddPlaceholderChunk(\"header\");\n  Builder.AddTextChunk(\">\");\n  Results.AddResult(Builder.TakeString());\n\n  // #warning <message>\n  Builder.AddTypedTextChunk(\"warning\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddPlaceholderChunk(\"message\");\n  Results.AddResult(Builder.TakeString());\n\n  // Note: #ident and #sccs are such crazy anachronisms that we don't provide\n  // completions for them. And __include_macros is a Clang-internal extension\n  // that we don't want to encourage anyone to use.\n\n  // FIXME: we don't support #assert or #unassert, so don't suggest them.\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteInPreprocessorConditionalExclusion(Scope *S) {\n  CodeCompleteOrdinaryName(S, S->getFnParent() ? Sema::PCC_RecoveryInFunction\n                                               : Sema::PCC_Namespace);\n}\n\nvoid Sema::CodeCompletePreprocessorMacroName(bool IsDefinition) {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        IsDefinition ? CodeCompletionContext::CCC_MacroName\n                                     : CodeCompletionContext::CCC_MacroNameUse);\n  if (!IsDefinition && (!CodeCompleter || CodeCompleter->includeMacros())) {\n    // Add just the names of macros, not their arguments.\n    CodeCompletionBuilder Builder(Results.getAllocator(),\n                                  Results.getCodeCompletionTUInfo());\n    Results.EnterNewScope();\n    for (Preprocessor::macro_iterator M = PP.macro_begin(),\n                                      MEnd = PP.macro_end();\n         M != MEnd; ++M) {\n      Builder.AddTypedTextChunk(\n          Builder.getAllocator().CopyString(M->first->getName()));\n      Results.AddResult(CodeCompletionResult(\n          Builder.TakeString(), CCP_CodePattern, CXCursor_MacroDefinition));\n    }\n    Results.ExitScope();\n  } else if (IsDefinition) {\n    // FIXME: Can we detect when the user just wrote an include guard above?\n  }\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompletePreprocessorExpression() {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_PreprocessorExpression);\n\n  if (!CodeCompleter || CodeCompleter->includeMacros())\n    AddMacroResults(PP, Results,\n                    !CodeCompleter || CodeCompleter->loadExternal(), true);\n\n  // defined (<macro>)\n  Results.EnterNewScope();\n  CodeCompletionBuilder Builder(Results.getAllocator(),\n                                Results.getCodeCompletionTUInfo());\n  Builder.AddTypedTextChunk(\"defined\");\n  Builder.AddChunk(CodeCompletionString::CK_HorizontalSpace);\n  Builder.AddChunk(CodeCompletionString::CK_LeftParen);\n  Builder.AddPlaceholderChunk(\"macro\");\n  Builder.AddChunk(CodeCompletionString::CK_RightParen);\n  Results.AddResult(Builder.TakeString());\n  Results.ExitScope();\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompletePreprocessorMacroArgument(Scope *S,\n                                                 IdentifierInfo *Macro,\n                                                 MacroInfo *MacroInfo,\n                                                 unsigned Argument) {\n  // FIXME: In the future, we could provide \"overload\" results, much like we\n  // do for function calls.\n\n  // Now just ignore this. There will be another code-completion callback\n  // for the expanded tokens.\n}\n\n// This handles completion inside an #include filename, e.g. #include <foo/ba\n// We look for the directory \"foo\" under each directory on the include path,\n// list its files, and reassemble the appropriate #include.\nvoid Sema::CodeCompleteIncludedFile(llvm::StringRef Dir, bool Angled) {\n  // RelDir should use /, but unescaped \\ is possible on windows!\n  // Our completions will normalize to / for simplicity, this case is rare.\n  std::string RelDir = llvm::sys::path::convert_to_slash(Dir);\n  // We need the native slashes for the actual file system interactions.\n  SmallString<128> NativeRelDir = StringRef(RelDir);\n  llvm::sys::path::native(NativeRelDir);\n  llvm::vfs::FileSystem &FS =\n      getSourceManager().getFileManager().getVirtualFileSystem();\n\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_IncludedFile);\n  llvm::DenseSet<StringRef> SeenResults; // To deduplicate results.\n\n  // Helper: adds one file or directory completion result.\n  auto AddCompletion = [&](StringRef Filename, bool IsDirectory) {\n    SmallString<64> TypedChunk = Filename;\n    // Directory completion is up to the slash, e.g. <sys/\n    TypedChunk.push_back(IsDirectory ? '/' : Angled ? '>' : '\"');\n    auto R = SeenResults.insert(TypedChunk);\n    if (R.second) { // New completion\n      const char *InternedTyped = Results.getAllocator().CopyString(TypedChunk);\n      *R.first = InternedTyped; // Avoid dangling StringRef.\n      CodeCompletionBuilder Builder(CodeCompleter->getAllocator(),\n                                    CodeCompleter->getCodeCompletionTUInfo());\n      Builder.AddTypedTextChunk(InternedTyped);\n      // The result is a \"Pattern\", which is pretty opaque.\n      // We may want to include the real filename to allow smart ranking.\n      Results.AddResult(CodeCompletionResult(Builder.TakeString()));\n    }\n  };\n\n  // Helper: scans IncludeDir for nice files, and adds results for each.\n  auto AddFilesFromIncludeDir = [&](StringRef IncludeDir,\n                                    bool IsSystem,\n                                    DirectoryLookup::LookupType_t LookupType) {\n    llvm::SmallString<128> Dir = IncludeDir;\n    if (!NativeRelDir.empty()) {\n      if (LookupType == DirectoryLookup::LT_Framework) {\n        // For a framework dir, #include <Foo/Bar/> actually maps to\n        // a path of Foo.framework/Headers/Bar/.\n        auto Begin = llvm::sys::path::begin(NativeRelDir);\n        auto End = llvm::sys::path::end(NativeRelDir);\n\n        llvm::sys::path::append(Dir, *Begin + \".framework\", \"Headers\");\n        llvm::sys::path::append(Dir, ++Begin, End);\n      } else {\n        llvm::sys::path::append(Dir, NativeRelDir);\n      }\n    }\n\n    std::error_code EC;\n    unsigned Count = 0;\n    for (auto It = FS.dir_begin(Dir, EC);\n         !EC && It != llvm::vfs::directory_iterator(); It.increment(EC)) {\n      if (++Count == 2500) // If we happen to hit a huge directory,\n        break;             // bail out early so we're not too slow.\n      StringRef Filename = llvm::sys::path::filename(It->path());\n\n      // To know whether a symlink should be treated as file or a directory, we\n      // have to stat it. This should be cheap enough as there shouldn't be many\n      // symlinks.\n      llvm::sys::fs::file_type Type = It->type();\n      if (Type == llvm::sys::fs::file_type::symlink_file) {\n        if (auto FileStatus = FS.status(It->path()))\n          Type = FileStatus->getType();\n      }\n      switch (Type) {\n      case llvm::sys::fs::file_type::directory_file:\n        // All entries in a framework directory must have a \".framework\" suffix,\n        // but the suffix does not appear in the source code's include/import.\n        if (LookupType == DirectoryLookup::LT_Framework &&\n            NativeRelDir.empty() && !Filename.consume_back(\".framework\"))\n          break;\n\n        AddCompletion(Filename, /*IsDirectory=*/true);\n        break;\n      case llvm::sys::fs::file_type::regular_file:\n        // Only files that really look like headers. (Except in system dirs).\n        if (!IsSystem) {\n          // Header extensions from Types.def, which we can't depend on here.\n          if (!(Filename.endswith_lower(\".h\") ||\n                Filename.endswith_lower(\".hh\") ||\n                Filename.endswith_lower(\".hpp\") ||\n                Filename.endswith_lower(\".inc\")))\n            break;\n        }\n        AddCompletion(Filename, /*IsDirectory=*/false);\n        break;\n      default:\n        break;\n      }\n    }\n  };\n\n  // Helper: adds results relative to IncludeDir, if possible.\n  auto AddFilesFromDirLookup = [&](const DirectoryLookup &IncludeDir,\n                                   bool IsSystem) {\n    switch (IncludeDir.getLookupType()) {\n    case DirectoryLookup::LT_HeaderMap:\n      // header maps are not (currently) enumerable.\n      break;\n    case DirectoryLookup::LT_NormalDir:\n      AddFilesFromIncludeDir(IncludeDir.getDir()->getName(), IsSystem,\n                             DirectoryLookup::LT_NormalDir);\n      break;\n    case DirectoryLookup::LT_Framework:\n      AddFilesFromIncludeDir(IncludeDir.getFrameworkDir()->getName(), IsSystem,\n                             DirectoryLookup::LT_Framework);\n      break;\n    }\n  };\n\n  // Finally with all our helpers, we can scan the include path.\n  // Do this in standard order so deduplication keeps the right file.\n  // (In case we decide to add more details to the results later).\n  const auto &S = PP.getHeaderSearchInfo();\n  using llvm::make_range;\n  if (!Angled) {\n    // The current directory is on the include path for \"quoted\" includes.\n    auto *CurFile = PP.getCurrentFileLexer()->getFileEntry();\n    if (CurFile && CurFile->getDir())\n      AddFilesFromIncludeDir(CurFile->getDir()->getName(), false,\n                             DirectoryLookup::LT_NormalDir);\n    for (const auto &D : make_range(S.quoted_dir_begin(), S.quoted_dir_end()))\n      AddFilesFromDirLookup(D, false);\n  }\n  for (const auto &D : make_range(S.angled_dir_begin(), S.angled_dir_end()))\n    AddFilesFromDirLookup(D, false);\n  for (const auto &D : make_range(S.system_dir_begin(), S.system_dir_end()))\n    AddFilesFromDirLookup(D, true);\n\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::CodeCompleteNaturalLanguage() {\n  HandleCodeCompleteResults(this, CodeCompleter,\n                            CodeCompletionContext::CCC_NaturalLanguage, nullptr,\n                            0);\n}\n\nvoid Sema::CodeCompleteAvailabilityPlatformName() {\n  ResultBuilder Results(*this, CodeCompleter->getAllocator(),\n                        CodeCompleter->getCodeCompletionTUInfo(),\n                        CodeCompletionContext::CCC_Other);\n  Results.EnterNewScope();\n  static const char *Platforms[] = {\"macOS\", \"iOS\", \"watchOS\", \"tvOS\"};\n  for (const char *Platform : llvm::makeArrayRef(Platforms)) {\n    Results.AddResult(CodeCompletionResult(Platform));\n    Results.AddResult(CodeCompletionResult(Results.getAllocator().CopyString(\n        Twine(Platform) + \"ApplicationExtension\")));\n  }\n  Results.ExitScope();\n  HandleCodeCompleteResults(this, CodeCompleter, Results.getCompletionContext(),\n                            Results.data(), Results.size());\n}\n\nvoid Sema::GatherGlobalCodeCompletions(\n    CodeCompletionAllocator &Allocator, CodeCompletionTUInfo &CCTUInfo,\n    SmallVectorImpl<CodeCompletionResult> &Results) {\n  ResultBuilder Builder(*this, Allocator, CCTUInfo,\n                        CodeCompletionContext::CCC_Recovery);\n  if (!CodeCompleter || CodeCompleter->includeGlobals()) {\n    CodeCompletionDeclConsumer Consumer(Builder,\n                                        Context.getTranslationUnitDecl());\n    LookupVisibleDecls(Context.getTranslationUnitDecl(), LookupAnyName,\n                       Consumer,\n                       !CodeCompleter || CodeCompleter->loadExternal());\n  }\n\n  if (!CodeCompleter || CodeCompleter->includeMacros())\n    AddMacroResults(PP, Builder,\n                    !CodeCompleter || CodeCompleter->loadExternal(), true);\n\n  Results.clear();\n  Results.insert(Results.end(), Builder.data(),\n                 Builder.data() + Builder.size());\n}\n"}}, "reports": [{"events": [{"location": {"col": 5, "file": 31, "line": 99}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 31, "line": 99}, "message": "default constructor 'ShadowMapEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp", "reportHash": "b79953af9684100564ec77df3403753d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 31, "line": 101}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 31, "line": 101}, "message": "move constructor 'ShadowMapEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp", "reportHash": "52c4e6e97d6aff2689dd46f0d9c33bd7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 31, "line": 103}, "message": "mark 'noexcept'"}, {"location": {"col": 21, "file": 31, "line": 103}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp", "reportHash": "5955299ee618363db8f1b2f55dc9b579", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 608}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 608}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp", "reportHash": "f51524e9fd8118904a6b5125cee0321d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
