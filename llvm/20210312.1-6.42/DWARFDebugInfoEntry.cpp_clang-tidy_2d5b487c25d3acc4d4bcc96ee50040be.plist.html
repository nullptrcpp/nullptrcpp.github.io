<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h", "content": "//===- llvm/ADT/PointerIntPair.h - Pair for pointer and int -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PointerIntPair class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERINTPAIR_H\n#define LLVM_ADT_POINTERINTPAIR_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n\nnamespace llvm {\n\ntemplate <typename T> struct DenseMapInfo;\ntemplate <typename PointerT, unsigned IntBits, typename PtrTraits>\nstruct PointerIntPairInfo;\n\n/// PointerIntPair - This class implements a pair of a pointer and small\n/// integer.  It is designed to represent this in the space required by one\n/// pointer by bitmangling the integer into the low part of the pointer.  This\n/// can only be done for small integers: typically up to 3 bits, but it depends\n/// on the number of bits available according to PointerLikeTypeTraits for the\n/// type.\n///\n/// Note that PointerIntPair always puts the IntVal part in the highest bits\n/// possible.  For example, PointerIntPair<void*, 1, bool> will put the bit for\n/// the bool into bit #2, not bit #0, which allows the low two bits to be used\n/// for something else.  For example, this allows:\n///   PointerIntPair<PointerIntPair<void*, 1, bool>, 1, bool>\n/// ... and the two bools will land in different bits.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType = unsigned,\n          typename PtrTraits = PointerLikeTypeTraits<PointerTy>,\n          typename Info = PointerIntPairInfo<PointerTy, IntBits, PtrTraits>>\nclass PointerIntPair {\n  // Used by MSVC visualizer and generally helpful for debugging/visualizing.\n  using InfoTy = Info;\n  intptr_t Value = 0;\n\npublic:\n  constexpr PointerIntPair() = default;\n\n  PointerIntPair(PointerTy PtrVal, IntType IntVal) {\n    setPointerAndInt(PtrVal, IntVal);\n  }\n\n  explicit PointerIntPair(PointerTy PtrVal) { initWithPointer(PtrVal); }\n\n  PointerTy getPointer() const { return Info::getPointer(Value); }\n\n  IntType getInt() const { return (IntType)Info::getInt(Value); }\n\n  void setPointer(PointerTy PtrVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updatePointer(Value, PtrVal);\n  }\n\n  void setInt(IntType IntVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updateInt(Value, static_cast<intptr_t>(IntVal));\n  }\n\n  void initWithPointer(PointerTy PtrVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updatePointer(0, PtrVal);\n  }\n\n  void setPointerAndInt(PointerTy PtrVal, IntType IntVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updateInt(Info::updatePointer(0, PtrVal),\n                            static_cast<intptr_t>(IntVal));\n  }\n\n  PointerTy const *getAddrOfPointer() const {\n    return const_cast<PointerIntPair *>(this)->getAddrOfPointer();\n  }\n\n  PointerTy *getAddrOfPointer() {\n    assert(Value == reinterpret_cast<intptr_t>(getPointer()) &&\n           \"Can only return the address if IntBits is cleared and \"\n           \"PtrTraits doesn't change the pointer\");\n    return reinterpret_cast<PointerTy *>(&Value);\n  }\n\n  void *getOpaqueValue() const { return reinterpret_cast<void *>(Value); }\n\n  void setFromOpaqueValue(void *Val) LLVM_LVALUE_FUNCTION {\n    Value = reinterpret_cast<intptr_t>(Val);\n  }\n\n  static PointerIntPair getFromOpaqueValue(void *V) {\n    PointerIntPair P;\n    P.setFromOpaqueValue(V);\n    return P;\n  }\n\n  // Allow PointerIntPairs to be created from const void * if and only if the\n  // pointer type could be created from a const void *.\n  static PointerIntPair getFromOpaqueValue(const void *V) {\n    (void)PtrTraits::getFromVoidPointer(V);\n    return getFromOpaqueValue(const_cast<void *>(V));\n  }\n\n  bool operator==(const PointerIntPair &RHS) const {\n    return Value == RHS.Value;\n  }\n\n  bool operator!=(const PointerIntPair &RHS) const {\n    return Value != RHS.Value;\n  }\n\n  bool operator<(const PointerIntPair &RHS) const { return Value < RHS.Value; }\n  bool operator>(const PointerIntPair &RHS) const { return Value > RHS.Value; }\n\n  bool operator<=(const PointerIntPair &RHS) const {\n    return Value <= RHS.Value;\n  }\n\n  bool operator>=(const PointerIntPair &RHS) const {\n    return Value >= RHS.Value;\n  }\n};\n\n// Specialize is_trivially_copyable to avoid limitation of llvm::is_trivially_copyable\n// when compiled with gcc 4.9.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType,\n          typename PtrTraits,\n          typename Info>\nstruct is_trivially_copyable<PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>> : std::true_type {\n#ifdef HAVE_STD_IS_TRIVIALLY_COPYABLE\n  static_assert(std::is_trivially_copyable<PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>>::value,\n                \"inconsistent behavior between llvm:: and std:: implementation of is_trivially_copyable\");\n#endif\n};\n\n\ntemplate <typename PointerT, unsigned IntBits, typename PtrTraits>\nstruct PointerIntPairInfo {\n  static_assert(PtrTraits::NumLowBitsAvailable <\n                    std::numeric_limits<uintptr_t>::digits,\n                \"cannot use a pointer type that has all bits free\");\n  static_assert(IntBits <= PtrTraits::NumLowBitsAvailable,\n                \"PointerIntPair with integer size too large for pointer\");\n  enum MaskAndShiftConstants : uintptr_t {\n    /// PointerBitMask - The bits that come from the pointer.\n    PointerBitMask =\n        ~(uintptr_t)(((intptr_t)1 << PtrTraits::NumLowBitsAvailable) - 1),\n\n    /// IntShift - The number of low bits that we reserve for other uses, and\n    /// keep zero.\n    IntShift = (uintptr_t)PtrTraits::NumLowBitsAvailable - IntBits,\n\n    /// IntMask - This is the unshifted mask for valid bits of the int type.\n    IntMask = (uintptr_t)(((intptr_t)1 << IntBits) - 1),\n\n    // ShiftedIntMask - This is the bits for the integer shifted in place.\n    ShiftedIntMask = (uintptr_t)(IntMask << IntShift)\n  };\n\n  static PointerT getPointer(intptr_t Value) {\n    return PtrTraits::getFromVoidPointer(\n        reinterpret_cast<void *>(Value & PointerBitMask));\n  }\n\n  static intptr_t getInt(intptr_t Value) {\n    return (Value >> IntShift) & IntMask;\n  }\n\n  static intptr_t updatePointer(intptr_t OrigValue, PointerT Ptr) {\n    intptr_t PtrWord =\n        reinterpret_cast<intptr_t>(PtrTraits::getAsVoidPointer(Ptr));\n    assert((PtrWord & ~PointerBitMask) == 0 &&\n           \"Pointer is not sufficiently aligned\");\n    // Preserve all low bits, just update the pointer.\n    return PtrWord | (OrigValue & ~PointerBitMask);\n  }\n\n  static intptr_t updateInt(intptr_t OrigValue, intptr_t Int) {\n    intptr_t IntWord = static_cast<intptr_t>(Int);\n    assert((IntWord & ~IntMask) == 0 && \"Integer too large for field\");\n\n    // Preserve all bits other than the ones we are updating.\n    return (OrigValue & ~ShiftedIntMask) | IntWord << IntShift;\n  }\n};\n\n// Provide specialization of DenseMapInfo for PointerIntPair.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType>\nstruct DenseMapInfo<PointerIntPair<PointerTy, IntBits, IntType>> {\n  using Ty = PointerIntPair<PointerTy, IntBits, IntType>;\n\n  static Ty getEmptyKey() {\n    uintptr_t Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<Ty>::NumLowBitsAvailable;\n    return Ty::getFromOpaqueValue(reinterpret_cast<void *>(Val));\n  }\n\n  static Ty getTombstoneKey() {\n    uintptr_t Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<PointerTy>::NumLowBitsAvailable;\n    return Ty::getFromOpaqueValue(reinterpret_cast<void *>(Val));\n  }\n\n  static unsigned getHashValue(Ty V) {\n    uintptr_t IV = reinterpret_cast<uintptr_t>(V.getOpaqueValue());\n    return unsigned(IV) ^ unsigned(IV >> 9);\n  }\n\n  static bool isEqual(const Ty &LHS, const Ty &RHS) { return LHS == RHS; }\n};\n\n// Teach SmallPtrSet that PointerIntPair is \"basically a pointer\".\ntemplate <typename PointerTy, unsigned IntBits, typename IntType,\n          typename PtrTraits>\nstruct PointerLikeTypeTraits<\n    PointerIntPair<PointerTy, IntBits, IntType, PtrTraits>> {\n  static inline void *\n  getAsVoidPointer(const PointerIntPair<PointerTy, IntBits, IntType> &P) {\n    return P.getOpaqueValue();\n  }\n\n  static inline PointerIntPair<PointerTy, IntBits, IntType>\n  getFromVoidPointer(void *P) {\n    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);\n  }\n\n  static inline PointerIntPair<PointerTy, IntBits, IntType>\n  getFromVoidPointer(const void *P) {\n    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);\n  }\n\n  static constexpr int NumLowBitsAvailable =\n      PtrTraits::NumLowBitsAvailable - IntBits;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERINTPAIR_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Triple.h", "content": "//===-- llvm/ADT/Triple.h - Target triple helper class ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_TRIPLE_H\n#define LLVM_ADT_TRIPLE_H\n\n#include \"llvm/ADT/Twine.h\"\n\n// Some system headers or GCC predefined macros conflict with identifiers in\n// this file.  Undefine them here.\n#undef NetBSD\n#undef mips\n#undef sparc\n\nnamespace llvm {\n\nclass VersionTuple;\n\n/// Triple - Helper class for working with autoconf configuration names. For\n/// historical reasons, we also call these 'triples' (they used to contain\n/// exactly three fields).\n///\n/// Configuration names are strings in the canonical form:\n///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM\n/// or\n///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT\n///\n/// This class is used for clients which want to support arbitrary\n/// configuration names, but also want to implement certain special\n/// behavior for particular configurations. This class isolates the mapping\n/// from the components of the configuration name to well known IDs.\n///\n/// At its core the Triple class is designed to be a wrapper for a triple\n/// string; the constructor does not change or normalize the triple string.\n/// Clients that need to handle the non-canonical triples that users often\n/// specify should use the normalize method.\n///\n/// See autoconf/config.guess for a glimpse into what configuration names\n/// look like in practice.\nclass Triple {\npublic:\n  enum ArchType {\n    UnknownArch,\n\n    arm,            // ARM (little endian): arm, armv.*, xscale\n    armeb,          // ARM (big endian): armeb\n    aarch64,        // AArch64 (little endian): aarch64\n    aarch64_be,     // AArch64 (big endian): aarch64_be\n    aarch64_32,     // AArch64 (little endian) ILP32: aarch64_32\n    arc,            // ARC: Synopsys ARC\n    avr,            // AVR: Atmel AVR microcontroller\n    bpfel,          // eBPF or extended BPF or 64-bit BPF (little endian)\n    bpfeb,          // eBPF or extended BPF or 64-bit BPF (big endian)\n    csky,           // CSKY: csky\n    hexagon,        // Hexagon: hexagon\n    m68k,           // M68k: Motorola 680x0 family\n    mips,           // MIPS: mips, mipsallegrex, mipsr6\n    mipsel,         // MIPSEL: mipsel, mipsallegrexe, mipsr6el\n    mips64,         // MIPS64: mips64, mips64r6, mipsn32, mipsn32r6\n    mips64el,       // MIPS64EL: mips64el, mips64r6el, mipsn32el, mipsn32r6el\n    msp430,         // MSP430: msp430\n    ppc,            // PPC: powerpc\n    ppcle,          // PPCLE: powerpc (little endian)\n    ppc64,          // PPC64: powerpc64, ppu\n    ppc64le,        // PPC64LE: powerpc64le\n    r600,           // R600: AMD GPUs HD2XXX - HD6XXX\n    amdgcn,         // AMDGCN: AMD GCN GPUs\n    riscv32,        // RISC-V (32-bit): riscv32\n    riscv64,        // RISC-V (64-bit): riscv64\n    sparc,          // Sparc: sparc\n    sparcv9,        // Sparcv9: Sparcv9\n    sparcel,        // Sparc: (endianness = little). NB: 'Sparcle' is a CPU variant\n    systemz,        // SystemZ: s390x\n    tce,            // TCE (http://tce.cs.tut.fi/): tce\n    tcele,          // TCE little endian (http://tce.cs.tut.fi/): tcele\n    thumb,          // Thumb (little endian): thumb, thumbv.*\n    thumbeb,        // Thumb (big endian): thumbeb\n    x86,            // X86: i[3-9]86\n    x86_64,         // X86-64: amd64, x86_64\n    xcore,          // XCore: xcore\n    nvptx,          // NVPTX: 32-bit\n    nvptx64,        // NVPTX: 64-bit\n    le32,           // le32: generic little-endian 32-bit CPU (PNaCl)\n    le64,           // le64: generic little-endian 64-bit CPU (PNaCl)\n    amdil,          // AMDIL\n    amdil64,        // AMDIL with 64-bit pointers\n    hsail,          // AMD HSAIL\n    hsail64,        // AMD HSAIL with 64-bit pointers\n    spir,           // SPIR: standard portable IR for OpenCL 32-bit version\n    spir64,         // SPIR: standard portable IR for OpenCL 64-bit version\n    kalimba,        // Kalimba: generic kalimba\n    shave,          // SHAVE: Movidius vector VLIW processors\n    lanai,          // Lanai: Lanai 32-bit\n    wasm32,         // WebAssembly with 32-bit pointers\n    wasm64,         // WebAssembly with 64-bit pointers\n    renderscript32, // 32-bit RenderScript\n    renderscript64, // 64-bit RenderScript\n    ve,             // NEC SX-Aurora Vector Engine\n    LastArchType = ve\n  };\n  enum SubArchType {\n    NoSubArch,\n\n    ARMSubArch_v8_7a,\n    ARMSubArch_v8_6a,\n    ARMSubArch_v8_5a,\n    ARMSubArch_v8_4a,\n    ARMSubArch_v8_3a,\n    ARMSubArch_v8_2a,\n    ARMSubArch_v8_1a,\n    ARMSubArch_v8,\n    ARMSubArch_v8r,\n    ARMSubArch_v8m_baseline,\n    ARMSubArch_v8m_mainline,\n    ARMSubArch_v8_1m_mainline,\n    ARMSubArch_v7,\n    ARMSubArch_v7em,\n    ARMSubArch_v7m,\n    ARMSubArch_v7s,\n    ARMSubArch_v7k,\n    ARMSubArch_v7ve,\n    ARMSubArch_v6,\n    ARMSubArch_v6m,\n    ARMSubArch_v6k,\n    ARMSubArch_v6t2,\n    ARMSubArch_v5,\n    ARMSubArch_v5te,\n    ARMSubArch_v4t,\n\n    AArch64SubArch_arm64e,\n\n    KalimbaSubArch_v3,\n    KalimbaSubArch_v4,\n    KalimbaSubArch_v5,\n\n    MipsSubArch_r6,\n\n    PPCSubArch_spe\n  };\n  enum VendorType {\n    UnknownVendor,\n\n    Apple,\n    PC,\n    SCEI,\n    Freescale,\n    IBM,\n    ImaginationTechnologies,\n    MipsTechnologies,\n    NVIDIA,\n    CSR,\n    Myriad,\n    AMD,\n    Mesa,\n    SUSE,\n    OpenEmbedded,\n    LastVendorType = OpenEmbedded\n  };\n  enum OSType {\n    UnknownOS,\n\n    Ananas,\n    CloudABI,\n    Darwin,\n    DragonFly,\n    FreeBSD,\n    Fuchsia,\n    IOS,\n    KFreeBSD,\n    Linux,\n    Lv2,        // PS3\n    MacOSX,\n    NetBSD,\n    OpenBSD,\n    Solaris,\n    Win32,\n    ZOS,\n    Haiku,\n    Minix,\n    RTEMS,\n    NaCl,       // Native Client\n    AIX,\n    CUDA,       // NVIDIA CUDA\n    NVCL,       // NVIDIA OpenCL\n    AMDHSA,     // AMD HSA Runtime\n    PS4,\n    ELFIAMCU,\n    TvOS,       // Apple tvOS\n    WatchOS,    // Apple watchOS\n    Mesa3D,\n    Contiki,\n    AMDPAL,     // AMD PAL Runtime\n    HermitCore, // HermitCore Unikernel/Multikernel\n    Hurd,       // GNU/Hurd\n    WASI,       // Experimental WebAssembly OS\n    Emscripten,\n    LastOSType = Emscripten\n  };\n  enum EnvironmentType {\n    UnknownEnvironment,\n\n    GNU,\n    GNUABIN32,\n    GNUABI64,\n    GNUEABI,\n    GNUEABIHF,\n    GNUX32,\n    GNUILP32,\n    CODE16,\n    EABI,\n    EABIHF,\n    Android,\n    Musl,\n    MuslEABI,\n    MuslEABIHF,\n\n    MSVC,\n    Itanium,\n    Cygnus,\n    CoreCLR,\n    Simulator, // Simulator variants of other systems, e.g., Apple's iOS\n    MacABI, // Mac Catalyst variant of Apple's iOS deployment target.\n    LastEnvironmentType = MacABI\n  };\n  enum ObjectFormatType {\n    UnknownObjectFormat,\n\n    COFF,\n    ELF,\n    GOFF,\n    MachO,\n    Wasm,\n    XCOFF,\n  };\n\nprivate:\n  std::string Data;\n\n  /// The parsed arch type.\n  ArchType Arch;\n\n  /// The parsed subarchitecture type.\n  SubArchType SubArch;\n\n  /// The parsed vendor type.\n  VendorType Vendor;\n\n  /// The parsed OS type.\n  OSType OS;\n\n  /// The parsed Environment type.\n  EnvironmentType Environment;\n\n  /// The object format type.\n  ObjectFormatType ObjectFormat;\n\npublic:\n  /// @name Constructors\n  /// @{\n\n  /// Default constructor is the same as an empty string and leaves all\n  /// triple fields unknown.\n  Triple()\n      : Data(), Arch(), SubArch(), Vendor(), OS(), Environment(),\n        ObjectFormat() {}\n\n  explicit Triple(const Twine &Str);\n  Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr);\n  Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr,\n         const Twine &EnvironmentStr);\n\n  bool operator==(const Triple &Other) const {\n    return Arch == Other.Arch && SubArch == Other.SubArch &&\n           Vendor == Other.Vendor && OS == Other.OS &&\n           Environment == Other.Environment &&\n           ObjectFormat == Other.ObjectFormat;\n  }\n\n  bool operator!=(const Triple &Other) const {\n    return !(*this == Other);\n  }\n\n  /// @}\n  /// @name Normalization\n  /// @{\n\n  /// normalize - Turn an arbitrary machine specification into the canonical\n  /// triple form (or something sensible that the Triple class understands if\n  /// nothing better can reasonably be done).  In particular, it handles the\n  /// common case in which otherwise valid components are in the wrong order.\n  static std::string normalize(StringRef Str);\n\n  /// Return the normalized form of this triple's string.\n  std::string normalize() const { return normalize(Data); }\n\n  /// @}\n  /// @name Typed Component Access\n  /// @{\n\n  /// getArch - Get the parsed architecture type of this triple.\n  ArchType getArch() const { return Arch; }\n\n  /// getSubArch - get the parsed subarchitecture type for this triple.\n  SubArchType getSubArch() const { return SubArch; }\n\n  /// getVendor - Get the parsed vendor type of this triple.\n  VendorType getVendor() const { return Vendor; }\n\n  /// getOS - Get the parsed operating system type of this triple.\n  OSType getOS() const { return OS; }\n\n  /// hasEnvironment - Does this triple have the optional environment\n  /// (fourth) component?\n  bool hasEnvironment() const {\n    return getEnvironmentName() != \"\";\n  }\n\n  /// getEnvironment - Get the parsed environment type of this triple.\n  EnvironmentType getEnvironment() const { return Environment; }\n\n  /// Parse the version number from the OS name component of the\n  /// triple, if present.\n  ///\n  /// For example, \"fooos1.2.3\" would return (1, 2, 3).\n  ///\n  /// If an entry is not defined, it will be returned as 0.\n  void getEnvironmentVersion(unsigned &Major, unsigned &Minor,\n                             unsigned &Micro) const;\n\n  /// getFormat - Get the object format for this triple.\n  ObjectFormatType getObjectFormat() const { return ObjectFormat; }\n\n  /// getOSVersion - Parse the version number from the OS name component of the\n  /// triple, if present.\n  ///\n  /// For example, \"fooos1.2.3\" would return (1, 2, 3).\n  ///\n  /// If an entry is not defined, it will be returned as 0.\n  void getOSVersion(unsigned &Major, unsigned &Minor, unsigned &Micro) const;\n\n  /// getOSMajorVersion - Return just the major version number, this is\n  /// specialized because it is a common query.\n  unsigned getOSMajorVersion() const {\n    unsigned Maj, Min, Micro;\n    getOSVersion(Maj, Min, Micro);\n    return Maj;\n  }\n\n  /// getMacOSXVersion - Parse the version number as with getOSVersion and then\n  /// translate generic \"darwin\" versions to the corresponding OS X versions.\n  /// This may also be called with IOS triples but the OS X version number is\n  /// just set to a constant 10.4.0 in that case.  Returns true if successful.\n  bool getMacOSXVersion(unsigned &Major, unsigned &Minor,\n                        unsigned &Micro) const;\n\n  /// getiOSVersion - Parse the version number as with getOSVersion.  This should\n  /// only be called with IOS or generic triples.\n  void getiOSVersion(unsigned &Major, unsigned &Minor,\n                     unsigned &Micro) const;\n\n  /// getWatchOSVersion - Parse the version number as with getOSVersion.  This\n  /// should only be called with WatchOS or generic triples.\n  void getWatchOSVersion(unsigned &Major, unsigned &Minor,\n                         unsigned &Micro) const;\n\n  /// @}\n  /// @name Direct Component Access\n  /// @{\n\n  const std::string &str() const { return Data; }\n\n  const std::string &getTriple() const { return Data; }\n\n  /// getArchName - Get the architecture (first) component of the\n  /// triple.\n  StringRef getArchName() const;\n\n  /// getVendorName - Get the vendor (second) component of the triple.\n  StringRef getVendorName() const;\n\n  /// getOSName - Get the operating system (third) component of the\n  /// triple.\n  StringRef getOSName() const;\n\n  /// getEnvironmentName - Get the optional environment (fourth)\n  /// component of the triple, or \"\" if empty.\n  StringRef getEnvironmentName() const;\n\n  /// getOSAndEnvironmentName - Get the operating system and optional\n  /// environment components as a single string (separated by a '-'\n  /// if the environment component is present).\n  StringRef getOSAndEnvironmentName() const;\n\n  /// @}\n  /// @name Convenience Predicates\n  /// @{\n\n  /// Test whether the architecture is 64-bit\n  ///\n  /// Note that this tests for 64-bit pointer width, and nothing else. Note\n  /// that we intentionally expose only three predicates, 64-bit, 32-bit, and\n  /// 16-bit. The inner details of pointer width for particular architectures\n  /// is not summed up in the triple, and so only a coarse grained predicate\n  /// system is provided.\n  bool isArch64Bit() const;\n\n  /// Test whether the architecture is 32-bit\n  ///\n  /// Note that this tests for 32-bit pointer width, and nothing else.\n  bool isArch32Bit() const;\n\n  /// Test whether the architecture is 16-bit\n  ///\n  /// Note that this tests for 16-bit pointer width, and nothing else.\n  bool isArch16Bit() const;\n\n  /// isOSVersionLT - Helper function for doing comparisons against version\n  /// numbers included in the target triple.\n  bool isOSVersionLT(unsigned Major, unsigned Minor = 0,\n                     unsigned Micro = 0) const {\n    unsigned LHS[3];\n    getOSVersion(LHS[0], LHS[1], LHS[2]);\n\n    if (LHS[0] != Major)\n      return LHS[0] < Major;\n    if (LHS[1] != Minor)\n      return LHS[1] < Minor;\n    if (LHS[2] != Micro)\n      return LHS[2] < Micro;\n\n    return false;\n  }\n\n  bool isOSVersionLT(const Triple &Other) const {\n    unsigned RHS[3];\n    Other.getOSVersion(RHS[0], RHS[1], RHS[2]);\n    return isOSVersionLT(RHS[0], RHS[1], RHS[2]);\n  }\n\n  /// isMacOSXVersionLT - Comparison function for checking OS X version\n  /// compatibility, which handles supporting skewed version numbering schemes\n  /// used by the \"darwin\" triples.\n  bool isMacOSXVersionLT(unsigned Major, unsigned Minor = 0,\n                         unsigned Micro = 0) const;\n\n  /// isMacOSX - Is this a Mac OS X triple. For legacy reasons, we support both\n  /// \"darwin\" and \"osx\" as OS X triples.\n  bool isMacOSX() const {\n    return getOS() == Triple::Darwin || getOS() == Triple::MacOSX;\n  }\n\n  /// Is this an iOS triple.\n  /// Note: This identifies tvOS as a variant of iOS. If that ever\n  /// changes, i.e., if the two operating systems diverge or their version\n  /// numbers get out of sync, that will need to be changed.\n  /// watchOS has completely different version numbers so it is not included.\n  bool isiOS() const {\n    return getOS() == Triple::IOS || isTvOS();\n  }\n\n  /// Is this an Apple tvOS triple.\n  bool isTvOS() const {\n    return getOS() == Triple::TvOS;\n  }\n\n  /// Is this an Apple watchOS triple.\n  bool isWatchOS() const {\n    return getOS() == Triple::WatchOS;\n  }\n\n  bool isWatchABI() const {\n    return getSubArch() == Triple::ARMSubArch_v7k;\n  }\n\n  bool isOSzOS() const { return getOS() == Triple::ZOS; }\n\n  /// isOSDarwin - Is this a \"Darwin\" OS (macOS, iOS, tvOS or watchOS).\n  bool isOSDarwin() const {\n    return isMacOSX() || isiOS() || isWatchOS();\n  }\n\n  bool isSimulatorEnvironment() const {\n    return getEnvironment() == Triple::Simulator;\n  }\n\n  bool isMacCatalystEnvironment() const {\n    return getEnvironment() == Triple::MacABI;\n  }\n\n  /// Returns true for targets that run on a macOS machine.\n  bool isTargetMachineMac() const {\n    return isMacOSX() || (isOSDarwin() && (isSimulatorEnvironment() ||\n                                           isMacCatalystEnvironment()));\n  }\n\n  bool isOSNetBSD() const {\n    return getOS() == Triple::NetBSD;\n  }\n\n  bool isOSOpenBSD() const {\n    return getOS() == Triple::OpenBSD;\n  }\n\n  bool isOSFreeBSD() const {\n    return getOS() == Triple::FreeBSD;\n  }\n\n  bool isOSFuchsia() const {\n    return getOS() == Triple::Fuchsia;\n  }\n\n  bool isOSDragonFly() const { return getOS() == Triple::DragonFly; }\n\n  bool isOSSolaris() const {\n    return getOS() == Triple::Solaris;\n  }\n\n  bool isOSIAMCU() const {\n    return getOS() == Triple::ELFIAMCU;\n  }\n\n  bool isOSUnknown() const { return getOS() == Triple::UnknownOS; }\n\n  bool isGNUEnvironment() const {\n    EnvironmentType Env = getEnvironment();\n    return Env == Triple::GNU || Env == Triple::GNUABIN32 ||\n           Env == Triple::GNUABI64 || Env == Triple::GNUEABI ||\n           Env == Triple::GNUEABIHF || Env == Triple::GNUX32;\n  }\n\n  bool isOSContiki() const {\n    return getOS() == Triple::Contiki;\n  }\n\n  /// Tests whether the OS is Haiku.\n  bool isOSHaiku() const {\n    return getOS() == Triple::Haiku;\n  }\n\n  /// Tests whether the OS is Windows.\n  bool isOSWindows() const {\n    return getOS() == Triple::Win32;\n  }\n\n  /// Checks if the environment is MSVC.\n  bool isKnownWindowsMSVCEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::MSVC;\n  }\n\n  /// Checks if the environment could be MSVC.\n  bool isWindowsMSVCEnvironment() const {\n    return isKnownWindowsMSVCEnvironment() ||\n           (isOSWindows() && getEnvironment() == Triple::UnknownEnvironment);\n  }\n\n  bool isWindowsCoreCLREnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::CoreCLR;\n  }\n\n  bool isWindowsItaniumEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::Itanium;\n  }\n\n  bool isWindowsCygwinEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::Cygnus;\n  }\n\n  bool isWindowsGNUEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::GNU;\n  }\n\n  /// Tests for either Cygwin or MinGW OS\n  bool isOSCygMing() const {\n    return isWindowsCygwinEnvironment() || isWindowsGNUEnvironment();\n  }\n\n  /// Is this a \"Windows\" OS targeting a \"MSVCRT.dll\" environment.\n  bool isOSMSVCRT() const {\n    return isWindowsMSVCEnvironment() || isWindowsGNUEnvironment() ||\n           isWindowsItaniumEnvironment();\n  }\n\n  /// Tests whether the OS is NaCl (Native Client)\n  bool isOSNaCl() const {\n    return getOS() == Triple::NaCl;\n  }\n\n  /// Tests whether the OS is Linux.\n  bool isOSLinux() const {\n    return getOS() == Triple::Linux;\n  }\n\n  /// Tests whether the OS is kFreeBSD.\n  bool isOSKFreeBSD() const {\n    return getOS() == Triple::KFreeBSD;\n  }\n\n  /// Tests whether the OS is Hurd.\n  bool isOSHurd() const {\n    return getOS() == Triple::Hurd;\n  }\n\n  /// Tests whether the OS is WASI.\n  bool isOSWASI() const {\n    return getOS() == Triple::WASI;\n  }\n\n  /// Tests whether the OS is Emscripten.\n  bool isOSEmscripten() const {\n    return getOS() == Triple::Emscripten;\n  }\n\n  /// Tests whether the OS uses glibc.\n  bool isOSGlibc() const {\n    return (getOS() == Triple::Linux || getOS() == Triple::KFreeBSD ||\n            getOS() == Triple::Hurd) &&\n           !isAndroid();\n  }\n\n  /// Tests whether the OS is AIX.\n  bool isOSAIX() const {\n    return getOS() == Triple::AIX;\n  }\n\n  /// Tests whether the OS uses the ELF binary format.\n  bool isOSBinFormatELF() const {\n    return getObjectFormat() == Triple::ELF;\n  }\n\n  /// Tests whether the OS uses the COFF binary format.\n  bool isOSBinFormatCOFF() const {\n    return getObjectFormat() == Triple::COFF;\n  }\n\n  /// Tests whether the OS uses the GOFF binary format.\n  bool isOSBinFormatGOFF() const { return getObjectFormat() == Triple::GOFF; }\n\n  /// Tests whether the environment is MachO.\n  bool isOSBinFormatMachO() const {\n    return getObjectFormat() == Triple::MachO;\n  }\n\n  /// Tests whether the OS uses the Wasm binary format.\n  bool isOSBinFormatWasm() const {\n    return getObjectFormat() == Triple::Wasm;\n  }\n\n  /// Tests whether the OS uses the XCOFF binary format.\n  bool isOSBinFormatXCOFF() const {\n    return getObjectFormat() == Triple::XCOFF;\n  }\n\n  /// Tests whether the target is the PS4 CPU\n  bool isPS4CPU() const {\n    return getArch() == Triple::x86_64 &&\n           getVendor() == Triple::SCEI &&\n           getOS() == Triple::PS4;\n  }\n\n  /// Tests whether the target is the PS4 platform\n  bool isPS4() const {\n    return getVendor() == Triple::SCEI &&\n           getOS() == Triple::PS4;\n  }\n\n  /// Tests whether the target is Android\n  bool isAndroid() const { return getEnvironment() == Triple::Android; }\n\n  bool isAndroidVersionLT(unsigned Major) const {\n    assert(isAndroid() && \"Not an Android triple!\");\n\n    unsigned Env[3];\n    getEnvironmentVersion(Env[0], Env[1], Env[2]);\n\n    // 64-bit targets did not exist before API level 21 (Lollipop).\n    if (isArch64Bit() && Env[0] < 21)\n      Env[0] = 21;\n\n    return Env[0] < Major;\n  }\n\n  /// Tests whether the environment is musl-libc\n  bool isMusl() const {\n    return getEnvironment() == Triple::Musl ||\n           getEnvironment() == Triple::MuslEABI ||\n           getEnvironment() == Triple::MuslEABIHF;\n  }\n\n  /// Tests whether the target is SPIR (32- or 64-bit).\n  bool isSPIR() const {\n    return getArch() == Triple::spir || getArch() == Triple::spir64;\n  }\n\n  /// Tests whether the target is NVPTX (32- or 64-bit).\n  bool isNVPTX() const {\n    return getArch() == Triple::nvptx || getArch() == Triple::nvptx64;\n  }\n\n  /// Tests whether the target is AMDGCN\n  bool isAMDGCN() const { return getArch() == Triple::amdgcn; }\n\n  bool isAMDGPU() const {\n    return getArch() == Triple::r600 || getArch() == Triple::amdgcn;\n  }\n\n  /// Tests whether the target is Thumb (little and big endian).\n  bool isThumb() const {\n    return getArch() == Triple::thumb || getArch() == Triple::thumbeb;\n  }\n\n  /// Tests whether the target is ARM (little and big endian).\n  bool isARM() const {\n    return getArch() == Triple::arm || getArch() == Triple::armeb;\n  }\n\n  /// Tests whether the target is AArch64 (little and big endian).\n  bool isAArch64() const {\n    return getArch() == Triple::aarch64 || getArch() == Triple::aarch64_be ||\n           getArch() == Triple::aarch64_32;\n  }\n\n  /// Tests whether the target is AArch64 and pointers are the size specified by\n  /// \\p PointerWidth.\n  bool isAArch64(int PointerWidth) const {\n    assert(PointerWidth == 64 || PointerWidth == 32);\n    if (!isAArch64())\n      return false;\n    return getArch() == Triple::aarch64_32 ||\n                   getEnvironment() == Triple::GNUILP32\n               ? PointerWidth == 32\n               : PointerWidth == 64;\n  }\n\n  /// Tests whether the target is MIPS 32-bit (little and big endian).\n  bool isMIPS32() const {\n    return getArch() == Triple::mips || getArch() == Triple::mipsel;\n  }\n\n  /// Tests whether the target is MIPS 64-bit (little and big endian).\n  bool isMIPS64() const {\n    return getArch() == Triple::mips64 || getArch() == Triple::mips64el;\n  }\n\n  /// Tests whether the target is MIPS (little and big endian, 32- or 64-bit).\n  bool isMIPS() const {\n    return isMIPS32() || isMIPS64();\n  }\n\n  /// Tests whether the target is PowerPC (32- or 64-bit LE or BE).\n  bool isPPC() const {\n    return getArch() == Triple::ppc || getArch() == Triple::ppc64 ||\n           getArch() == Triple::ppcle || getArch() == Triple::ppc64le;\n  }\n\n  /// Tests whether the target is 32-bit PowerPC (little and big endian).\n  bool isPPC32() const {\n    return getArch() == Triple::ppc || getArch() == Triple::ppcle;\n  }\n\n  /// Tests whether the target is 64-bit PowerPC (little and big endian).\n  bool isPPC64() const {\n    return getArch() == Triple::ppc64 || getArch() == Triple::ppc64le;\n  }\n\n  /// Tests whether the target is RISC-V (32- and 64-bit).\n  bool isRISCV() const {\n    return getArch() == Triple::riscv32 || getArch() == Triple::riscv64;\n  }\n\n  /// Tests whether the target is SystemZ.\n  bool isSystemZ() const {\n    return getArch() == Triple::systemz;\n  }\n\n  /// Tests whether the target is x86 (32- or 64-bit).\n  bool isX86() const {\n    return getArch() == Triple::x86 || getArch() == Triple::x86_64;\n  }\n\n  /// Tests whether the target is VE\n  bool isVE() const {\n    return getArch() == Triple::ve;\n  }\n\n  /// Tests whether the target is wasm (32- and 64-bit).\n  bool isWasm() const {\n    return getArch() == Triple::wasm32 || getArch() == Triple::wasm64;\n  }\n\n  // Tests whether the target is CSKY\n  bool isCSKY() const {\n    return getArch() == Triple::csky;\n  }\n\n  /// Tests whether the target is the Apple \"arm64e\" AArch64 subarch.\n  bool isArm64e() const {\n    return getArch() == Triple::aarch64 &&\n           getSubArch() == Triple::AArch64SubArch_arm64e;\n  }\n\n  /// Tests whether the target supports comdat\n  bool supportsCOMDAT() const {\n    return !(isOSBinFormatMachO() || isOSBinFormatXCOFF());\n  }\n\n  /// Tests whether the target uses emulated TLS as default.\n  bool hasDefaultEmulatedTLS() const {\n    return isAndroid() || isOSOpenBSD() || isWindowsCygwinEnvironment();\n  }\n\n  /// Tests whether the target uses -data-sections as default.\n  bool hasDefaultDataSections() const {\n    return isOSBinFormatXCOFF() || isWasm();\n  }\n\n  /// Tests if the environment supports dllimport/export annotations.\n  bool hasDLLImportExport() const { return isOSWindows() || isPS4CPU(); }\n\n  /// @}\n  /// @name Mutators\n  /// @{\n\n  /// setArch - Set the architecture (first) component of the triple\n  /// to a known type.\n  void setArch(ArchType Kind);\n\n  /// setVendor - Set the vendor (second) component of the triple to a\n  /// known type.\n  void setVendor(VendorType Kind);\n\n  /// setOS - Set the operating system (third) component of the triple\n  /// to a known type.\n  void setOS(OSType Kind);\n\n  /// setEnvironment - Set the environment (fourth) component of the triple\n  /// to a known type.\n  void setEnvironment(EnvironmentType Kind);\n\n  /// setObjectFormat - Set the object file format\n  void setObjectFormat(ObjectFormatType Kind);\n\n  /// setTriple - Set all components to the new triple \\p Str.\n  void setTriple(const Twine &Str);\n\n  /// setArchName - Set the architecture (first) component of the\n  /// triple by name.\n  void setArchName(StringRef Str);\n\n  /// setVendorName - Set the vendor (second) component of the triple\n  /// by name.\n  void setVendorName(StringRef Str);\n\n  /// setOSName - Set the operating system (third) component of the\n  /// triple by name.\n  void setOSName(StringRef Str);\n\n  /// setEnvironmentName - Set the optional environment (fourth)\n  /// component of the triple by name.\n  void setEnvironmentName(StringRef Str);\n\n  /// setOSAndEnvironmentName - Set the operating system and optional\n  /// environment components with a single string.\n  void setOSAndEnvironmentName(StringRef Str);\n\n  /// @}\n  /// @name Helpers to build variants of a particular triple.\n  /// @{\n\n  /// Form a triple with a 32-bit variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a 32-bit architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple get32BitArchVariant() const;\n\n  /// Form a triple with a 64-bit variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a 64-bit architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple get64BitArchVariant() const;\n\n  /// Form a triple with a big endian variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a big endian architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple getBigEndianArchVariant() const;\n\n  /// Form a triple with a little endian variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a little endian architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple getLittleEndianArchVariant() const;\n\n  /// Get the (LLVM) name of the minimum ARM CPU for the arch we are targeting.\n  ///\n  /// \\param Arch the architecture name (e.g., \"armv7s\"). If it is an empty\n  /// string then the triple's arch name is used.\n  StringRef getARMCPUForArch(StringRef Arch = StringRef()) const;\n\n  /// Tests whether the target triple is little endian.\n  ///\n  /// \\returns true if the triple is little endian, false otherwise.\n  bool isLittleEndian() const;\n\n  /// Test whether target triples are compatible.\n  bool isCompatibleWith(const Triple &Other) const;\n\n  /// Merge target triples.\n  std::string merge(const Triple &Other) const;\n\n  /// Some platforms have different minimum supported OS versions that\n  /// varies by the architecture specified in the triple. This function\n  /// returns the minimum supported OS version for this triple if one an exists,\n  /// or an invalid version tuple if this triple doesn't have one.\n  VersionTuple getMinimumSupportedOSVersion() const;\n\n  /// @}\n  /// @name Static helpers for IDs.\n  /// @{\n\n  /// getArchTypeName - Get the canonical name for the \\p Kind architecture.\n  static StringRef getArchTypeName(ArchType Kind);\n\n  /// getArchTypePrefix - Get the \"prefix\" canonical name for the \\p Kind\n  /// architecture. This is the prefix used by the architecture specific\n  /// builtins, and is suitable for passing to \\see\n  /// Intrinsic::getIntrinsicForGCCBuiltin().\n  ///\n  /// \\return - The architecture prefix, or 0 if none is defined.\n  static StringRef getArchTypePrefix(ArchType Kind);\n\n  /// getVendorTypeName - Get the canonical name for the \\p Kind vendor.\n  static StringRef getVendorTypeName(VendorType Kind);\n\n  /// getOSTypeName - Get the canonical name for the \\p Kind operating system.\n  static StringRef getOSTypeName(OSType Kind);\n\n  /// getEnvironmentTypeName - Get the canonical name for the \\p Kind\n  /// environment.\n  static StringRef getEnvironmentTypeName(EnvironmentType Kind);\n\n  /// @}\n  /// @name Static helpers for converting alternate architecture names.\n  /// @{\n\n  /// getArchTypeForLLVMName - The canonical type for the given LLVM\n  /// architecture name (e.g., \"x86\").\n  static ArchType getArchTypeForLLVMName(StringRef Str);\n\n  /// @}\n\n  /// Returns a canonicalized OS version number for the specified OS.\n  static VersionTuple getCanonicalVersionForOS(OSType OSKind,\n                                               const VersionTuple &Version);\n};\n\n} // End llvm namespace\n\n\n#endif\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "content": "//===- llvm/ADT/ilist_node.h - Intrusive Linked List Helper -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ilist_node class template, which is a convenient\n// base class for creating classes that can be used with ilists.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_NODE_H\n#define LLVM_ADT_ILIST_NODE_H\n\n#include \"llvm/ADT/ilist_node_base.h\"\n#include \"llvm/ADT/ilist_node_options.h\"\n\nnamespace llvm {\n\nnamespace ilist_detail {\n\nstruct NodeAccess;\n\n} // end namespace ilist_detail\n\ntemplate <class OptionsT, bool IsReverse, bool IsConst> class ilist_iterator;\ntemplate <class OptionsT> class ilist_sentinel;\n\n/// Implementation for an ilist node.\n///\n/// Templated on an appropriate \\a ilist_detail::node_options, usually computed\n/// by \\a ilist_detail::compute_node_options.\n///\n/// This is a wrapper around \\a ilist_node_base whose main purpose is to\n/// provide type safety: you can't insert nodes of \\a ilist_node_impl into the\n/// wrong \\a simple_ilist or \\a iplist.\ntemplate <class OptionsT> class ilist_node_impl : OptionsT::node_base_type {\n  using value_type = typename OptionsT::value_type;\n  using node_base_type = typename OptionsT::node_base_type;\n  using list_base_type = typename OptionsT::list_base_type;\n\n  friend typename OptionsT::list_base_type;\n  friend struct ilist_detail::NodeAccess;\n  friend class ilist_sentinel<OptionsT>;\n  friend class ilist_iterator<OptionsT, false, false>;\n  friend class ilist_iterator<OptionsT, false, true>;\n  friend class ilist_iterator<OptionsT, true, false>;\n  friend class ilist_iterator<OptionsT, true, true>;\n\nprotected:\n  using self_iterator = ilist_iterator<OptionsT, false, false>;\n  using const_self_iterator = ilist_iterator<OptionsT, false, true>;\n  using reverse_self_iterator = ilist_iterator<OptionsT, true, false>;\n  using const_reverse_self_iterator = ilist_iterator<OptionsT, true, true>;\n\n  ilist_node_impl() = default;\n\nprivate:\n  ilist_node_impl *getPrev() {\n    return static_cast<ilist_node_impl *>(node_base_type::getPrev());\n  }\n\n  ilist_node_impl *getNext() {\n    return static_cast<ilist_node_impl *>(node_base_type::getNext());\n  }\n\n  const ilist_node_impl *getPrev() const {\n    return static_cast<ilist_node_impl *>(node_base_type::getPrev());\n  }\n\n  const ilist_node_impl *getNext() const {\n    return static_cast<ilist_node_impl *>(node_base_type::getNext());\n  }\n\n  void setPrev(ilist_node_impl *N) { node_base_type::setPrev(N); }\n  void setNext(ilist_node_impl *N) { node_base_type::setNext(N); }\n\npublic:\n  self_iterator getIterator() { return self_iterator(*this); }\n  const_self_iterator getIterator() const { return const_self_iterator(*this); }\n\n  reverse_self_iterator getReverseIterator() {\n    return reverse_self_iterator(*this);\n  }\n\n  const_reverse_self_iterator getReverseIterator() const {\n    return const_reverse_self_iterator(*this);\n  }\n\n  // Under-approximation, but always available for assertions.\n  using node_base_type::isKnownSentinel;\n\n  /// Check whether this is the sentinel node.\n  ///\n  /// This requires sentinel tracking to be explicitly enabled.  Use the\n  /// ilist_sentinel_tracking<true> option to get this API.\n  bool isSentinel() const {\n    static_assert(OptionsT::is_sentinel_tracking_explicit,\n                  \"Use ilist_sentinel_tracking<true> to enable isSentinel()\");\n    return node_base_type::isSentinel();\n  }\n};\n\n/// An intrusive list node.\n///\n/// A base class to enable membership in intrusive lists, including \\a\n/// simple_ilist, \\a iplist, and \\a ilist.  The first template parameter is the\n/// \\a value_type for the list.\n///\n/// An ilist node can be configured with compile-time options to change\n/// behaviour and/or add API.\n///\n/// By default, an \\a ilist_node knows whether it is the list sentinel (an\n/// instance of \\a ilist_sentinel) if and only if\n/// LLVM_ENABLE_ABI_BREAKING_CHECKS.  The function \\a isKnownSentinel() always\n/// returns \\c false tracking is off.  Sentinel tracking steals a bit from the\n/// \"prev\" link, which adds a mask operation when decrementing an iterator, but\n/// enables bug-finding assertions in \\a ilist_iterator.\n///\n/// To turn sentinel tracking on all the time, pass in the\n/// ilist_sentinel_tracking<true> template parameter.  This also enables the \\a\n/// isSentinel() function.  The same option must be passed to the intrusive\n/// list.  (ilist_sentinel_tracking<false> turns sentinel tracking off all the\n/// time.)\n///\n/// A type can inherit from ilist_node multiple times by passing in different\n/// \\a ilist_tag options.  This allows a single instance to be inserted into\n/// multiple lists simultaneously, where each list is given the same tag.\n///\n/// \\example\n/// struct A {};\n/// struct B {};\n/// struct N : ilist_node<N, ilist_tag<A>>, ilist_node<N, ilist_tag<B>> {};\n///\n/// void foo() {\n///   simple_ilist<N, ilist_tag<A>> ListA;\n///   simple_ilist<N, ilist_tag<B>> ListB;\n///   N N1;\n///   ListA.push_back(N1);\n///   ListB.push_back(N1);\n/// }\n/// \\endexample\n///\n/// See \\a is_valid_option for steps on adding a new option.\ntemplate <class T, class... Options>\nclass ilist_node\n    : public ilist_node_impl<\n          typename ilist_detail::compute_node_options<T, Options...>::type> {\n  static_assert(ilist_detail::check_options<Options...>::value,\n                \"Unrecognized node option!\");\n};\n\nnamespace ilist_detail {\n\n/// An access class for ilist_node private API.\n///\n/// This gives access to the private parts of ilist nodes.  Nodes for an ilist\n/// should friend this class if they inherit privately from ilist_node.\n///\n/// Using this class outside of the ilist implementation is unsupported.\nstruct NodeAccess {\nprotected:\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getNodePtr(typename OptionsT::pointer N) {\n    return N;\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getNodePtr(typename OptionsT::const_pointer N) {\n    return N;\n  }\n\n  template <class OptionsT>\n  static typename OptionsT::pointer getValuePtr(ilist_node_impl<OptionsT> *N) {\n    return static_cast<typename OptionsT::pointer>(N);\n  }\n\n  template <class OptionsT>\n  static typename OptionsT::const_pointer\n  getValuePtr(const ilist_node_impl<OptionsT> *N) {\n    return static_cast<typename OptionsT::const_pointer>(N);\n  }\n\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getPrev(ilist_node_impl<OptionsT> &N) {\n    return N.getPrev();\n  }\n\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getNext(ilist_node_impl<OptionsT> &N) {\n    return N.getNext();\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getPrev(const ilist_node_impl<OptionsT> &N) {\n    return N.getPrev();\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getNext(const ilist_node_impl<OptionsT> &N) {\n    return N.getNext();\n  }\n};\n\ntemplate <class OptionsT> struct SpecificNodeAccess : NodeAccess {\nprotected:\n  using pointer = typename OptionsT::pointer;\n  using const_pointer = typename OptionsT::const_pointer;\n  using node_type = ilist_node_impl<OptionsT>;\n\n  static node_type *getNodePtr(pointer N) {\n    return NodeAccess::getNodePtr<OptionsT>(N);\n  }\n\n  static const node_type *getNodePtr(const_pointer N) {\n    return NodeAccess::getNodePtr<OptionsT>(N);\n  }\n\n  static pointer getValuePtr(node_type *N) {\n    return NodeAccess::getValuePtr<OptionsT>(N);\n  }\n\n  static const_pointer getValuePtr(const node_type *N) {\n    return NodeAccess::getValuePtr<OptionsT>(N);\n  }\n};\n\n} // end namespace ilist_detail\n\ntemplate <class OptionsT>\nclass ilist_sentinel : public ilist_node_impl<OptionsT> {\npublic:\n  ilist_sentinel() {\n    this->initializeSentinel();\n    reset();\n  }\n\n  void reset() {\n    this->setPrev(this);\n    this->setNext(this);\n  }\n\n  bool empty() const { return this == this->getPrev(); }\n};\n\n/// An ilist node that can access its parent list.\n///\n/// Requires \\c NodeTy to have \\a getParent() to find the parent node, and the\n/// \\c ParentTy to have \\a getSublistAccess() to get a reference to the list.\ntemplate <typename NodeTy, typename ParentTy, class... Options>\nclass ilist_node_with_parent : public ilist_node<NodeTy, Options...> {\nprotected:\n  ilist_node_with_parent() = default;\n\nprivate:\n  /// Forward to NodeTy::getParent().\n  ///\n  /// Note: do not use the name \"getParent()\".  We want a compile error\n  /// (instead of recursion) when the subclass fails to implement \\a\n  /// getParent().\n  const ParentTy *getNodeParent() const {\n    return static_cast<const NodeTy *>(this)->getParent();\n  }\n\npublic:\n  /// @name Adjacent Node Accessors\n  /// @{\n  /// Get the previous node, or \\c nullptr for the list head.\n  NodeTy *getPrevNode() {\n    // Should be separated to a reused function, but then we couldn't use auto\n    // (and would need the type of the list).\n    const auto &List =\n        getNodeParent()->*(ParentTy::getSublistAccess((NodeTy *)nullptr));\n    return List.getPrevNode(*static_cast<NodeTy *>(this));\n  }\n\n  /// Get the previous node, or \\c nullptr for the list head.\n  const NodeTy *getPrevNode() const {\n    return const_cast<ilist_node_with_parent *>(this)->getPrevNode();\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  NodeTy *getNextNode() {\n    // Should be separated to a reused function, but then we couldn't use auto\n    // (and would need the type of the list).\n    const auto &List =\n        getNodeParent()->*(ParentTy::getSublistAccess((NodeTy *)nullptr));\n    return List.getNextNode(*static_cast<NodeTy *>(this));\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  const NodeTy *getNextNode() const {\n    return const_cast<ilist_node_with_parent *>(this)->getNextNode();\n  }\n  /// @}\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ILIST_NODE_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "content": "//===- DIContext.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines DIContext, an abstract data structure that holds\n// debug information data.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DICONTEXT_H\n#define LLVM_DEBUGINFO_DICONTEXT_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/WithColor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// A format-neutral container for source line information.\nstruct DILineInfo {\n  // DILineInfo contains \"<invalid>\" for function/filename it cannot fetch.\n  static constexpr const char *const BadString = \"<invalid>\";\n  // Use \"??\" instead of \"<invalid>\" to make our output closer to addr2line.\n  static constexpr const char *const Addr2LineBadString = \"??\";\n  std::string FileName;\n  std::string FunctionName;\n  std::string StartFileName;\n  Optional<StringRef> Source;\n  uint32_t Line = 0;\n  uint32_t Column = 0;\n  uint32_t StartLine = 0;\n\n  // DWARF-specific.\n  uint32_t Discriminator = 0;\n\n  DILineInfo()\n      : FileName(BadString), FunctionName(BadString), StartFileName(BadString) {\n  }\n\n  bool operator==(const DILineInfo &RHS) const {\n    return Line == RHS.Line && Column == RHS.Column &&\n           FileName == RHS.FileName && FunctionName == RHS.FunctionName &&\n           StartFileName == RHS.StartFileName && StartLine == RHS.StartLine &&\n           Discriminator == RHS.Discriminator;\n  }\n\n  bool operator!=(const DILineInfo &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator<(const DILineInfo &RHS) const {\n    return std::tie(FileName, FunctionName, StartFileName, Line, Column,\n                    StartLine, Discriminator) <\n           std::tie(RHS.FileName, RHS.FunctionName, RHS.StartFileName, RHS.Line,\n                    RHS.Column, RHS.StartLine, RHS.Discriminator);\n  }\n\n  explicit operator bool() const { return *this != DILineInfo(); }\n\n  void dump(raw_ostream &OS) {\n    OS << \"Line info: \";\n    if (FileName != BadString)\n      OS << \"file '\" << FileName << \"', \";\n    if (FunctionName != BadString)\n      OS << \"function '\" << FunctionName << \"', \";\n    OS << \"line \" << Line << \", \";\n    OS << \"column \" << Column << \", \";\n    if (StartFileName != BadString)\n      OS << \"start file '\" << StartFileName << \"', \";\n    OS << \"start line \" << StartLine << '\\n';\n  }\n};\n\nusing DILineInfoTable = SmallVector<std::pair<uint64_t, DILineInfo>, 16>;\n\n/// A format-neutral container for inlined code description.\nclass DIInliningInfo {\n  SmallVector<DILineInfo, 4> Frames;\n\npublic:\n  DIInliningInfo() = default;\n\n  const DILineInfo & getFrame(unsigned Index) const {\n    assert(Index < Frames.size());\n    return Frames[Index];\n  }\n\n  DILineInfo *getMutableFrame(unsigned Index) {\n    assert(Index < Frames.size());\n    return &Frames[Index];\n  }\n\n  uint32_t getNumberOfFrames() const {\n    return Frames.size();\n  }\n\n  void addFrame(const DILineInfo &Frame) {\n    Frames.push_back(Frame);\n  }\n\n  void resize(unsigned i) {\n    Frames.resize(i);\n  }\n};\n\n/// Container for description of a global variable.\nstruct DIGlobal {\n  std::string Name;\n  uint64_t Start = 0;\n  uint64_t Size = 0;\n\n  DIGlobal() : Name(DILineInfo::BadString) {}\n};\n\nstruct DILocal {\n  std::string FunctionName;\n  std::string Name;\n  std::string DeclFile;\n  uint64_t DeclLine = 0;\n  Optional<int64_t> FrameOffset;\n  Optional<uint64_t> Size;\n  Optional<uint64_t> TagOffset;\n};\n\n/// A DINameKind is passed to name search methods to specify a\n/// preference regarding the type of name resolution the caller wants.\nenum class DINameKind { None, ShortName, LinkageName };\n\n/// Controls which fields of DILineInfo container should be filled\n/// with data.\nstruct DILineInfoSpecifier {\n  enum class FileLineInfoKind {\n    None,\n    // RawValue is whatever the compiler stored in the filename table.  Could be\n    // a full path, could be something else.\n    RawValue,\n    BaseNameOnly,\n    // Relative to the compilation directory.\n    RelativeFilePath,\n    AbsoluteFilePath\n  };\n  using FunctionNameKind = DINameKind;\n\n  FileLineInfoKind FLIKind;\n  FunctionNameKind FNKind;\n\n  DILineInfoSpecifier(FileLineInfoKind FLIKind = FileLineInfoKind::RawValue,\n                      FunctionNameKind FNKind = FunctionNameKind::None)\n      : FLIKind(FLIKind), FNKind(FNKind) {}\n};\n\n/// This is just a helper to programmatically construct DIDumpType.\nenum DIDumpTypeCounter {\n#define HANDLE_DWARF_SECTION(ENUM_NAME, ELF_NAME, CMDLINE_NAME, OPTION)        \\\n  DIDT_ID_##ENUM_NAME,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n#undef HANDLE_DWARF_SECTION\n  DIDT_ID_UUID,\n  DIDT_ID_Count\n};\nstatic_assert(DIDT_ID_Count <= 32, \"section types overflow storage\");\n\n/// Selects which debug sections get dumped.\nenum DIDumpType : unsigned {\n  DIDT_Null,\n  DIDT_All             = ~0U,\n#define HANDLE_DWARF_SECTION(ENUM_NAME, ELF_NAME, CMDLINE_NAME, OPTION)        \\\n  DIDT_##ENUM_NAME = 1U << DIDT_ID_##ENUM_NAME,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n#undef HANDLE_DWARF_SECTION\n  DIDT_UUID = 1 << DIDT_ID_UUID,\n};\n\n/// Container for dump options that control which debug information will be\n/// dumped.\nstruct DIDumpOptions {\n  unsigned DumpType = DIDT_All;\n  unsigned ChildRecurseDepth = -1U;\n  unsigned ParentRecurseDepth = -1U;\n  uint16_t Version = 0; // DWARF version to assume when extracting.\n  uint8_t AddrSize = 4; // Address byte size to assume when extracting.\n  bool ShowAddresses = true;\n  bool ShowChildren = false;\n  bool ShowParents = false;\n  bool ShowForm = false;\n  bool SummarizeTypes = false;\n  bool Verbose = false;\n  bool DisplayRawContents = false;\n\n  /// Return default option set for printing a single DIE without children.\n  static DIDumpOptions getForSingleDIE() {\n    DIDumpOptions Opts;\n    Opts.ChildRecurseDepth = 0;\n    Opts.ParentRecurseDepth = 0;\n    return Opts;\n  }\n\n  /// Return the options with RecurseDepth set to 0 unless explicitly required.\n  DIDumpOptions noImplicitRecursion() const {\n    DIDumpOptions Opts = *this;\n    if (ChildRecurseDepth == -1U && !ShowChildren)\n      Opts.ChildRecurseDepth = 0;\n    if (ParentRecurseDepth == -1U && !ShowParents)\n      Opts.ParentRecurseDepth = 0;\n    return Opts;\n  }\n\n  std::function<void(Error)> RecoverableErrorHandler =\n      WithColor::defaultErrorHandler;\n  std::function<void(Error)> WarningHandler = WithColor::defaultWarningHandler;\n};\n\nclass DIContext {\npublic:\n  enum DIContextKind {\n    CK_DWARF,\n    CK_PDB\n  };\n\n  DIContext(DIContextKind K) : Kind(K) {}\n  virtual ~DIContext() = default;\n\n  DIContextKind getKind() const { return Kind; }\n\n  virtual void dump(raw_ostream &OS, DIDumpOptions DumpOpts) = 0;\n\n  virtual bool verify(raw_ostream &OS, DIDumpOptions DumpOpts = {}) {\n    // No verifier? Just say things went well.\n    return true;\n  }\n\n  virtual DILineInfo getLineInfoForAddress(\n      object::SectionedAddress Address,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n  virtual DILineInfoTable getLineInfoForAddressRange(\n      object::SectionedAddress Address, uint64_t Size,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n  virtual DIInliningInfo getInliningInfoForAddress(\n      object::SectionedAddress Address,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n\n  virtual std::vector<DILocal>\n  getLocalsForAddress(object::SectionedAddress Address) = 0;\n\nprivate:\n  const DIContextKind Kind;\n};\n\n/// An inferface for inquiring the load address of a loaded object file\n/// to be used by the DIContext implementations when applying relocations\n/// on the fly.\nclass LoadedObjectInfo {\nprotected:\n  LoadedObjectInfo() = default;\n  LoadedObjectInfo(const LoadedObjectInfo &) = default;\n\npublic:\n  virtual ~LoadedObjectInfo() = default;\n\n  /// Obtain the Load Address of a section by SectionRef.\n  ///\n  /// Calculate the address of the given section.\n  /// The section need not be present in the local address space. The addresses\n  /// need to be consistent with the addresses used to query the DIContext and\n  /// the output of this function should be deterministic, i.e. repeated calls\n  /// with the same Sec should give the same address.\n  virtual uint64_t getSectionLoadAddress(const object::SectionRef &Sec) const {\n    return 0;\n  }\n\n  /// If conveniently available, return the content of the given Section.\n  ///\n  /// When the section is available in the local address space, in relocated\n  /// (loaded) form, e.g. because it was relocated by a JIT for execution, this\n  /// function should provide the contents of said section in `Data`. If the\n  /// loaded section is not available, or the cost of retrieving it would be\n  /// prohibitive, this function should return false. In that case, relocations\n  /// will be read from the local (unrelocated) object file and applied on the\n  /// fly. Note that this method is used purely for optimzation purposes in the\n  /// common case of JITting in the local address space, so returning false\n  /// should always be correct.\n  virtual bool getLoadedSectionContents(const object::SectionRef &Sec,\n                                        StringRef &Data) const {\n    return false;\n  }\n\n  // FIXME: This is untested and unused anywhere in the LLVM project, it's\n  // used/needed by Julia (an external project). It should have some coverage\n  // (at least tests, but ideally example functionality).\n  /// Obtain a copy of this LoadedObjectInfo.\n  virtual std::unique_ptr<LoadedObjectInfo> clone() const = 0;\n};\n\ntemplate <typename Derived, typename Base = LoadedObjectInfo>\nstruct LoadedObjectInfoHelper : Base {\nprotected:\n  LoadedObjectInfoHelper(const LoadedObjectInfoHelper &) = default;\n  LoadedObjectInfoHelper() = default;\n\npublic:\n  template <typename... Ts>\n  LoadedObjectInfoHelper(Ts &&... Args) : Base(std::forward<Ts>(Args)...) {}\n\n  std::unique_ptr<llvm::LoadedObjectInfo> clone() const override {\n    return std::make_unique<Derived>(static_cast<const Derived &>(*this));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DICONTEXT_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "content": "//===- DWARFAbbreviationDeclaration.h ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n#define LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass DWARFFormValue;\nclass DWARFUnit;\nclass raw_ostream;\n\nclass DWARFAbbreviationDeclaration {\npublic:\n  struct AttributeSpec {\n    AttributeSpec(dwarf::Attribute A, dwarf::Form F, int64_t Value)\n        : Attr(A), Form(F), Value(Value) {\n      assert(isImplicitConst());\n    }\n    AttributeSpec(dwarf::Attribute A, dwarf::Form F, Optional<uint8_t> ByteSize)\n        : Attr(A), Form(F) {\n      assert(!isImplicitConst());\n      this->ByteSize.HasByteSize = ByteSize.hasValue();\n      if (this->ByteSize.HasByteSize)\n        this->ByteSize.ByteSize = *ByteSize;\n    }\n\n    dwarf::Attribute Attr;\n    dwarf::Form Form;\n\n  private:\n    /// The following field is used for ByteSize for non-implicit_const\n    /// attributes and as value for implicit_const ones, indicated by\n    /// Form == DW_FORM_implicit_const.\n    /// The following cases are distinguished:\n    /// * Form != DW_FORM_implicit_const and HasByteSize is true:\n    ///     ByteSize contains the fixed size in bytes for the Form in this\n    ///     object.\n    /// * Form != DW_FORM_implicit_const and HasByteSize is false:\n    ///     byte size of Form either varies according to the DWARFUnit\n    ///     that it is contained in or the value size varies and must be\n    ///     decoded from the debug information in order to determine its size.\n    /// * Form == DW_FORM_implicit_const:\n    ///     Value contains value for the implicit_const attribute.\n    struct ByteSizeStorage {\n      bool HasByteSize;\n      uint8_t ByteSize;\n    };\n    union {\n      ByteSizeStorage ByteSize;\n      int64_t Value;\n    };\n\n  public:\n    bool isImplicitConst() const {\n      return Form == dwarf::DW_FORM_implicit_const;\n    }\n\n    int64_t getImplicitConstValue() const {\n      assert(isImplicitConst());\n      return Value;\n    }\n\n    /// Get the fixed byte size of this Form if possible. This function might\n    /// use the DWARFUnit to calculate the size of the Form, like for\n    /// DW_AT_address and DW_AT_ref_addr, so this isn't just an accessor for\n    /// the ByteSize member.\n    Optional<int64_t> getByteSize(const DWARFUnit &U) const;\n  };\n  using AttributeSpecVector = SmallVector<AttributeSpec, 8>;\n\n  DWARFAbbreviationDeclaration();\n\n  uint32_t getCode() const { return Code; }\n  uint8_t getCodeByteSize() const { return CodeByteSize; }\n  dwarf::Tag getTag() const { return Tag; }\n  bool hasChildren() const { return HasChildren; }\n\n  using attr_iterator_range =\n      iterator_range<AttributeSpecVector::const_iterator>;\n\n  attr_iterator_range attributes() const {\n    return attr_iterator_range(AttributeSpecs.begin(), AttributeSpecs.end());\n  }\n\n  dwarf::Form getFormByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].Form;\n  }\n\n  size_t getNumAttributes() const {\n    return AttributeSpecs.size();\n  }\n\n  dwarf::Attribute getAttrByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].Attr;\n  }\n\n  bool getAttrIsImplicitConstByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].isImplicitConst();\n  }\n\n  int64_t getAttrImplicitConstValueByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].getImplicitConstValue();\n  }\n\n  /// Get the index of the specified attribute.\n  ///\n  /// Searches the this abbreviation declaration for the index of the specified\n  /// attribute.\n  ///\n  /// \\param attr DWARF attribute to search for.\n  /// \\returns Optional index of the attribute if found, None otherwise.\n  Optional<uint32_t> findAttributeIndex(dwarf::Attribute attr) const;\n\n  /// Extract a DWARF form value from a DIE specified by DIE offset.\n  ///\n  /// Extract an attribute value for a DWARFUnit given the DIE offset and the\n  /// attribute.\n  ///\n  /// \\param DIEOffset the DIE offset that points to the ULEB128 abbreviation\n  /// code in the .debug_info data.\n  /// \\param Attr DWARF attribute to search for.\n  /// \\param U the DWARFUnit the contains the DIE.\n  /// \\returns Optional DWARF form value if the attribute was extracted.\n  Optional<DWARFFormValue> getAttributeValue(const uint64_t DIEOffset,\n                                             const dwarf::Attribute Attr,\n                                             const DWARFUnit &U) const;\n\n  bool extract(DataExtractor Data, uint64_t* OffsetPtr);\n  void dump(raw_ostream &OS) const;\n\n  // Return an optional byte size of all attribute data in this abbreviation\n  // if a constant byte size can be calculated given a DWARFUnit. This allows\n  // DWARF parsing to be faster as many DWARF DIEs have a fixed byte size.\n  Optional<size_t> getFixedAttributesByteSize(const DWARFUnit &U) const;\n\nprivate:\n  void clear();\n\n  /// A helper structure that can quickly determine the size in bytes of an\n  /// abbreviation declaration.\n  struct FixedSizeInfo {\n    /// The fixed byte size for fixed size forms.\n    uint16_t NumBytes = 0;\n    /// Number of DW_FORM_address forms in this abbrevation declaration.\n    uint8_t NumAddrs = 0;\n    /// Number of DW_FORM_ref_addr forms in this abbrevation declaration.\n    uint8_t NumRefAddrs = 0;\n    /// Number of 4 byte in DWARF32 and 8 byte in DWARF64 forms.\n    uint8_t NumDwarfOffsets = 0;\n\n    FixedSizeInfo() = default;\n\n    /// Calculate the fixed size in bytes given a DWARFUnit.\n    ///\n    /// \\param U the DWARFUnit to use when determing the byte size.\n    /// \\returns the size in bytes for all attribute data in this abbreviation.\n    /// The returned size does not include bytes for the  ULEB128 abbreviation\n    /// code\n    size_t getByteSize(const DWARFUnit &U) const;\n  };\n\n  uint32_t Code;\n  dwarf::Tag Tag;\n  uint8_t CodeByteSize;\n  bool HasChildren;\n  AttributeSpecVector AttributeSpecs;\n  /// If this abbreviation has a fixed byte size then FixedAttributeSize member\n  /// variable below will have a value.\n  Optional<FixedSizeInfo> FixedAttributeSize;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAbbrev.h", "content": "//===- DWARFDebugAbbrev.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGABBREV_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGABBREV_H\n\n#include \"llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cstdint>\n#include <map>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass DWARFAbbreviationDeclarationSet {\n  uint64_t Offset;\n  /// Code of the first abbreviation, if all abbreviations in the set have\n  /// consecutive codes. UINT32_MAX otherwise.\n  uint32_t FirstAbbrCode;\n  std::vector<DWARFAbbreviationDeclaration> Decls;\n\n  using const_iterator =\n      std::vector<DWARFAbbreviationDeclaration>::const_iterator;\n\npublic:\n  DWARFAbbreviationDeclarationSet();\n\n  uint64_t getOffset() const { return Offset; }\n  void dump(raw_ostream &OS) const;\n  bool extract(DataExtractor Data, uint64_t *OffsetPtr);\n\n  const DWARFAbbreviationDeclaration *\n  getAbbreviationDeclaration(uint32_t AbbrCode) const;\n\n  const_iterator begin() const {\n    return Decls.begin();\n  }\n\n  const_iterator end() const {\n    return Decls.end();\n  }\n\nprivate:\n  void clear();\n};\n\nclass DWARFDebugAbbrev {\n  using DWARFAbbreviationDeclarationSetMap =\n      std::map<uint64_t, DWARFAbbreviationDeclarationSet>;\n\n  mutable DWARFAbbreviationDeclarationSetMap AbbrDeclSets;\n  mutable DWARFAbbreviationDeclarationSetMap::const_iterator PrevAbbrOffsetPos;\n  mutable Optional<DataExtractor> Data;\n\npublic:\n  DWARFDebugAbbrev();\n\n  const DWARFAbbreviationDeclarationSet *\n  getAbbreviationDeclarationSet(uint64_t CUAbbrOffset) const;\n\n  void dump(raw_ostream &OS) const;\n  void parse() const;\n  void extract(DataExtractor Data);\n\n  DWARFAbbreviationDeclarationSetMap::const_iterator begin() const {\n    parse();\n    return AbbrDeclSets.begin();\n  }\n\n  DWARFAbbreviationDeclarationSetMap::const_iterator end() const {\n    return AbbrDeclSets.end();\n  }\n\nprivate:\n  void clear();\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGABBREV_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRangeList.h", "content": "//===- DWARFDebugRangeList.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n\n#include \"llvm/DebugInfo/DWARF/DWARFAddressRange.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include <cassert>\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass DWARFDebugRangeList {\npublic:\n  struct RangeListEntry {\n    /// A beginning address offset. This address offset has the size of an\n    /// address and is relative to the applicable base address of the\n    /// compilation unit referencing this range list. It marks the beginning\n    /// of an address range.\n    uint64_t StartAddress;\n    /// An ending address offset. This address offset again has the size of\n    /// an address and is relative to the applicable base address of the\n    /// compilation unit referencing this range list. It marks the first\n    /// address past the end of the address range. The ending address must\n    /// be greater than or equal to the beginning address.\n    uint64_t EndAddress;\n    /// A section index this range belongs to.\n    uint64_t SectionIndex;\n\n    /// The end of any given range list is marked by an end of list entry,\n    /// which consists of a 0 for the beginning address offset\n    /// and a 0 for the ending address offset.\n    bool isEndOfListEntry() const {\n      return (StartAddress == 0) && (EndAddress == 0);\n    }\n\n    /// A base address selection entry consists of:\n    /// 1. The value of the largest representable address offset\n    /// (for example, 0xffffffff when the size of an address is 32 bits).\n    /// 2. An address, which defines the appropriate base address for\n    /// use in interpreting the beginning and ending address offsets of\n    /// subsequent entries of the location list.\n    bool isBaseAddressSelectionEntry(uint8_t AddressSize) const {\n      assert(AddressSize == 4 || AddressSize == 8);\n      if (AddressSize == 4)\n        return StartAddress == -1U;\n      return StartAddress == -1ULL;\n    }\n  };\n\nprivate:\n  /// Offset in .debug_ranges section.\n  uint64_t Offset;\n  uint8_t AddressSize;\n  std::vector<RangeListEntry> Entries;\n\npublic:\n  DWARFDebugRangeList() { clear(); }\n\n  void clear();\n  void dump(raw_ostream &OS) const;\n  Error extract(const DWARFDataExtractor &data, uint64_t *offset_ptr);\n  const std::vector<RangeListEntry> &getEntries() { return Entries; }\n\n  /// getAbsoluteRanges - Returns absolute address ranges defined by this range\n  /// list. Has to be passed base address of the compile unit referencing this\n  /// range list.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(llvm::Optional<object::SectionedAddress> BaseAddr) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRnglists.h", "content": "//===- DWARFDebugRnglists.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRangeList.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFListTable.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass Error;\nclass raw_ostream;\nclass DWARFUnit;\n\n/// A class representing a single range list entry.\nstruct RangeListEntry : public DWARFListEntryBase {\n  /// The values making up the range list entry. Most represent a range with\n  /// a start and end address or a start address and a length. Others are\n  /// single value base addresses or end-of-list with no values. The unneeded\n  /// values are semantically undefined, but initialized to 0.\n  uint64_t Value0;\n  uint64_t Value1;\n\n  Error extract(DWARFDataExtractor Data, uint64_t *OffsetPtr);\n  void dump(raw_ostream &OS, uint8_t AddrSize, uint8_t MaxEncodingStringLength,\n            uint64_t &CurrentBase, DIDumpOptions DumpOpts,\n            llvm::function_ref<Optional<object::SectionedAddress>(uint32_t)>\n                LookupPooledAddress) const;\n  bool isSentinel() const { return EntryKind == dwarf::DW_RLE_end_of_list; }\n};\n\n/// A class representing a single rangelist.\nclass DWARFDebugRnglist : public DWARFListType<RangeListEntry> {\npublic:\n  /// Build a DWARFAddressRangesVector from a rangelist.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(Optional<object::SectionedAddress> BaseAddr,\n                    uint8_t AddressByteSize,\n                    function_ref<Optional<object::SectionedAddress>(uint32_t)>\n                        LookupPooledAddress) const;\n\n  /// Build a DWARFAddressRangesVector from a rangelist.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(llvm::Optional<object::SectionedAddress> BaseAddr,\n                    DWARFUnit &U) const;\n};\n\nclass DWARFDebugRnglistTable : public DWARFListTableBase<DWARFDebugRnglist> {\npublic:\n  DWARFDebugRnglistTable()\n      : DWARFListTableBase(/* SectionName    = */ \".debug_rnglists\",\n                           /* HeaderString   = */ \"ranges:\",\n                           /* ListTypeString = */ \"range\") {}\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "content": "//===- DWARFDie.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAddressRange.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAttribute.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLoc.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n\nnamespace llvm {\n\nclass DWARFUnit;\nclass raw_ostream;\n\n//===----------------------------------------------------------------------===//\n/// Utility class that carries the DWARF compile/type unit and the debug info\n/// entry in an object.\n///\n/// When accessing information from a debug info entry we always need to DWARF\n/// compile/type unit in order to extract the info correctly as some information\n/// is relative to the compile/type unit. Prior to this class the DWARFUnit and\n/// the DWARFDebugInfoEntry was passed around separately and there was the\n/// possibility for error if the wrong DWARFUnit was used to extract a unit\n/// relative offset. This class helps to ensure that this doesn't happen and\n/// also simplifies the attribute extraction calls by not having to specify the\n/// DWARFUnit for each call.\nclass DWARFDie {\n  DWARFUnit *U = nullptr;\n  const DWARFDebugInfoEntry *Die = nullptr;\n\npublic:\n  DWARFDie() = default;\n  DWARFDie(DWARFUnit *Unit, const DWARFDebugInfoEntry *D) : U(Unit), Die(D) {}\n\n  bool isValid() const { return U && Die; }\n  explicit operator bool() const { return isValid(); }\n  const DWARFDebugInfoEntry *getDebugInfoEntry() const { return Die; }\n  DWARFUnit *getDwarfUnit() const { return U; }\n\n  /// Get the abbreviation declaration for this DIE.\n  ///\n  /// \\returns the abbreviation declaration or NULL for null tags.\n  const DWARFAbbreviationDeclaration *getAbbreviationDeclarationPtr() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->getAbbreviationDeclarationPtr();\n  }\n\n  /// Get the absolute offset into the debug info or types section.\n  ///\n  /// \\returns the DIE offset or -1U if invalid.\n  uint64_t getOffset() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->getOffset();\n  }\n\n  dwarf::Tag getTag() const {\n    auto AbbrevDecl = getAbbreviationDeclarationPtr();\n    if (AbbrevDecl)\n      return AbbrevDecl->getTag();\n    return dwarf::DW_TAG_null;\n  }\n\n  bool hasChildren() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->hasChildren();\n  }\n\n  /// Returns true for a valid DIE that terminates a sibling chain.\n  bool isNULL() const { return getAbbreviationDeclarationPtr() == nullptr; }\n\n  /// Returns true if DIE represents a subprogram (not inlined).\n  bool isSubprogramDIE() const;\n\n  /// Returns true if DIE represents a subprogram or an inlined subroutine.\n  bool isSubroutineDIE() const;\n\n  /// Get the parent of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a parent or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getParent() const;\n\n  /// Get the sibling of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a sibling or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getSibling() const;\n\n  /// Get the previous sibling of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a sibling or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getPreviousSibling() const;\n\n  /// Get the first child of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has children or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getFirstChild() const;\n\n  /// Get the last child of this DIE object.\n  ///\n  /// \\returns a valid null DWARFDie instance if this object has children or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getLastChild() const;\n\n  /// Dump the DIE and all of its attributes to the supplied stream.\n  ///\n  /// \\param OS the stream to use for output.\n  /// \\param indent the number of characters to indent each line that is output.\n  void dump(raw_ostream &OS, unsigned indent = 0,\n            DIDumpOptions DumpOpts = DIDumpOptions()) const;\n\n  /// Convenience zero-argument overload for debugging.\n  LLVM_DUMP_METHOD void dump() const;\n\n  /// Extract the specified attribute from this DIE.\n  ///\n  /// Extract an attribute value from this DIE only. This call doesn't look\n  /// for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs.\n  ///\n  /// \\param Attr the attribute to extract.\n  /// \\returns an optional DWARFFormValue that will have the form value if the\n  /// attribute was successfully extracted.\n  Optional<DWARFFormValue> find(dwarf::Attribute Attr) const;\n\n  /// Extract the first value of any attribute in Attrs from this DIE.\n  ///\n  /// Extract the first attribute that matches from this DIE only. This call\n  /// doesn't look for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs. The attributes will be searched\n  /// linearly in the order they are specified within Attrs.\n  ///\n  /// \\param Attrs an array of DWARF attribute to look for.\n  /// \\returns an optional that has a valid DWARFFormValue for the first\n  /// matching attribute in Attrs, or None if none of the attributes in Attrs\n  /// exist in this DIE.\n  Optional<DWARFFormValue> find(ArrayRef<dwarf::Attribute> Attrs) const;\n\n  /// Extract the first value of any attribute in Attrs from this DIE and\n  /// recurse into any DW_AT_specification or DW_AT_abstract_origin referenced\n  /// DIEs.\n  ///\n  /// \\param Attrs an array of DWARF attribute to look for.\n  /// \\returns an optional that has a valid DWARFFormValue for the first\n  /// matching attribute in Attrs, or None if none of the attributes in Attrs\n  /// exist in this DIE or in any DW_AT_specification or DW_AT_abstract_origin\n  /// DIEs.\n  Optional<DWARFFormValue>\n  findRecursively(ArrayRef<dwarf::Attribute> Attrs) const;\n\n  /// Extract the specified attribute from this DIE as the referenced DIE.\n  ///\n  /// Regardless of the reference type, return the correct DWARFDie instance if\n  /// the attribute exists. The returned DWARFDie object might be from another\n  /// DWARFUnit, but that is all encapsulated in the new DWARFDie object.\n  ///\n  /// Extract an attribute value from this DIE only. This call doesn't look\n  /// for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs.\n  ///\n  /// \\param Attr the attribute to extract.\n  /// \\returns a valid DWARFDie instance if the attribute exists, or an invalid\n  /// DWARFDie object if it doesn't.\n  DWARFDie getAttributeValueAsReferencedDie(dwarf::Attribute Attr) const;\n  DWARFDie getAttributeValueAsReferencedDie(const DWARFFormValue &V) const;\n\n  /// Extract the range base attribute from this DIE as absolute section offset.\n  ///\n  /// This is a utility function that checks for either the DW_AT_rnglists_base\n  /// or DW_AT_GNU_ranges_base attribute.\n  ///\n  /// \\returns anm optional absolute section offset value for the attribute.\n  Optional<uint64_t> getRangesBaseAttribute() const;\n  Optional<uint64_t> getLocBaseAttribute() const;\n\n  /// Get the DW_AT_high_pc attribute value as an address.\n  ///\n  /// In DWARF version 4 and later the high PC can be encoded as an offset from\n  /// the DW_AT_low_pc. This function takes care of extracting the value as an\n  /// address or offset and adds it to the low PC if needed and returns the\n  /// value as an optional in case the DIE doesn't have a DW_AT_high_pc\n  /// attribute.\n  ///\n  /// \\param LowPC the low PC that might be needed to calculate the high PC.\n  /// \\returns an optional address value for the attribute.\n  Optional<uint64_t> getHighPC(uint64_t LowPC) const;\n\n  /// Retrieves DW_AT_low_pc and DW_AT_high_pc from CU.\n  /// Returns true if both attributes are present.\n  bool getLowAndHighPC(uint64_t &LowPC, uint64_t &HighPC,\n                       uint64_t &SectionIndex) const;\n\n  /// Get the address ranges for this DIE.\n  ///\n  /// Get the hi/low PC range if both attributes are available or exrtracts the\n  /// non-contiguous address ranges from the DW_AT_ranges attribute.\n  ///\n  /// Extracts the range information from this DIE only. This call doesn't look\n  /// for the range in any DW_AT_specification or DW_AT_abstract_origin DIEs.\n  ///\n  /// \\returns a address range vector that might be empty if no address range\n  /// information is available.\n  Expected<DWARFAddressRangesVector> getAddressRanges() const;\n\n  /// Get all address ranges for any DW_TAG_subprogram DIEs in this DIE or any\n  /// of its children.\n  ///\n  /// Get the hi/low PC range if both attributes are available or exrtracts the\n  /// non-contiguous address ranges from the DW_AT_ranges attribute for this DIE\n  /// and all children.\n  ///\n  /// \\param Ranges the addres range vector to fill in.\n  void collectChildrenAddressRanges(DWARFAddressRangesVector &Ranges) const;\n\n  bool addressRangeContainsAddress(const uint64_t Address) const;\n\n  Expected<DWARFLocationExpressionsVector>\n  getLocations(dwarf::Attribute Attr) const;\n\n  /// If a DIE represents a subprogram (or inlined subroutine), returns its\n  /// mangled name (or short name, if mangled is missing). This name may be\n  /// fetched from specification or abstract origin for this subprogram.\n  /// Returns null if no name is found.\n  const char *getSubroutineName(DINameKind Kind) const;\n\n  /// Return the DIE name resolving DW_AT_specification or DW_AT_abstract_origin\n  /// references if necessary. For the LinkageName case it additionaly searches\n  /// for ShortName if LinkageName is not found.\n  /// Returns null if no name is found.\n  const char *getName(DINameKind Kind) const;\n\n  /// Return the DIE short name resolving DW_AT_specification or\n  /// DW_AT_abstract_origin references if necessary. Returns null if no name\n  /// is found.\n  const char *getShortName() const;\n\n  /// Return the DIE linkage name resolving DW_AT_specification or\n  /// DW_AT_abstract_origin references if necessary. Returns null if no name\n  /// is found.\n  const char *getLinkageName() const;\n\n  /// Returns the declaration line (start line) for a DIE, assuming it specifies\n  /// a subprogram. This may be fetched from specification or abstract origin\n  /// for this subprogram by resolving DW_AT_sepcification or\n  /// DW_AT_abstract_origin references if necessary.\n  uint64_t getDeclLine() const;\n  std::string getDeclFile(DILineInfoSpecifier::FileLineInfoKind Kind) const;\n\n  /// Retrieves values of DW_AT_call_file, DW_AT_call_line and DW_AT_call_column\n  /// from DIE (or zeroes if they are missing). This function looks for\n  /// DW_AT_call attributes in this DIE only, it will not resolve the attribute\n  /// values in any DW_AT_specification or DW_AT_abstract_origin DIEs.\n  /// \\param CallFile filled in with non-zero if successful, zero if there is no\n  /// DW_AT_call_file attribute in this DIE.\n  /// \\param CallLine filled in with non-zero if successful, zero if there is no\n  /// DW_AT_call_line attribute in this DIE.\n  /// \\param CallColumn filled in with non-zero if successful, zero if there is\n  /// no DW_AT_call_column attribute in this DIE.\n  /// \\param CallDiscriminator filled in with non-zero if successful, zero if\n  /// there is no DW_AT_GNU_discriminator attribute in this DIE.\n  void getCallerFrame(uint32_t &CallFile, uint32_t &CallLine,\n                      uint32_t &CallColumn, uint32_t &CallDiscriminator) const;\n\n  class attribute_iterator;\n\n  /// Get an iterator range to all attributes in the current DIE only.\n  ///\n  /// \\returns an iterator range for the attributes of the current DIE.\n  iterator_range<attribute_iterator> attributes() const;\n\n  class iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\n  std::reverse_iterator<iterator> rbegin() const;\n  std::reverse_iterator<iterator> rend() const;\n\n  iterator_range<iterator> children() const;\n};\n\nclass DWARFDie::attribute_iterator\n    : public iterator_facade_base<attribute_iterator, std::forward_iterator_tag,\n                                  const DWARFAttribute> {\n  /// The DWARF DIE we are extracting attributes from.\n  DWARFDie Die;\n  /// The value vended to clients via the operator*() or operator->().\n  DWARFAttribute AttrValue;\n  /// The attribute index within the abbreviation declaration in Die.\n  uint32_t Index;\n\n  friend bool operator==(const attribute_iterator &LHS,\n                         const attribute_iterator &RHS);\n\n  /// Update the attribute index and attempt to read the attribute value. If the\n  /// attribute is able to be read, update AttrValue and the Index member\n  /// variable. If the attribute value is not able to be read, an appropriate\n  /// error will be set if the Err member variable is non-NULL and the iterator\n  /// will be set to the end value so iteration stops.\n  void updateForIndex(const DWARFAbbreviationDeclaration &AbbrDecl, uint32_t I);\n\npublic:\n  attribute_iterator() = delete;\n  explicit attribute_iterator(DWARFDie D, bool End);\n\n  attribute_iterator &operator++();\n  attribute_iterator &operator--();\n  explicit operator bool() const { return AttrValue.isValid(); }\n  const DWARFAttribute &operator*() const { return AttrValue; }\n};\n\ninline bool operator==(const DWARFDie::attribute_iterator &LHS,\n                       const DWARFDie::attribute_iterator &RHS) {\n  return LHS.Index == RHS.Index;\n}\n\ninline bool operator!=(const DWARFDie::attribute_iterator &LHS,\n                       const DWARFDie::attribute_iterator &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator==(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return LHS.getDebugInfoEntry() == RHS.getDebugInfoEntry() &&\n         LHS.getDwarfUnit() == RHS.getDwarfUnit();\n}\n\ninline bool operator!=(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator<(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return LHS.getOffset() < RHS.getOffset();\n}\n\nclass DWARFDie::iterator\n    : public iterator_facade_base<iterator, std::bidirectional_iterator_tag,\n                                  const DWARFDie> {\n  DWARFDie Die;\n\n  friend std::reverse_iterator<llvm::DWARFDie::iterator>;\n  friend bool operator==(const DWARFDie::iterator &LHS,\n                         const DWARFDie::iterator &RHS);\n\npublic:\n  iterator() = default;\n\n  explicit iterator(DWARFDie D) : Die(D) {}\n\n  iterator &operator++() {\n    Die = Die.getSibling();\n    return *this;\n  }\n\n  iterator &operator--() {\n    Die = Die.getPreviousSibling();\n    return *this;\n  }\n\n  const DWARFDie &operator*() const { return Die; }\n};\n\ninline bool operator==(const DWARFDie::iterator &LHS,\n                       const DWARFDie::iterator &RHS) {\n  return LHS.Die == RHS.Die;\n}\n\n// These inline functions must follow the DWARFDie::iterator definition above\n// as they use functions from that class.\ninline DWARFDie::iterator DWARFDie::begin() const {\n  return iterator(getFirstChild());\n}\n\ninline DWARFDie::iterator DWARFDie::end() const {\n  return iterator(getLastChild());\n}\n\ninline iterator_range<DWARFDie::iterator> DWARFDie::children() const {\n  return make_range(begin(), end());\n}\n\n} // end namespace llvm\n\nnamespace std {\n\ntemplate <>\nclass reverse_iterator<llvm::DWARFDie::iterator>\n    : public llvm::iterator_facade_base<\n          reverse_iterator<llvm::DWARFDie::iterator>,\n          bidirectional_iterator_tag, const llvm::DWARFDie> {\n\nprivate:\n  llvm::DWARFDie Die;\n  bool AtEnd;\n\npublic:\n  reverse_iterator(llvm::DWARFDie::iterator It)\n      : Die(It.Die), AtEnd(!It.Die.getPreviousSibling()) {\n    if (!AtEnd)\n      Die = Die.getPreviousSibling();\n  }\n\n  llvm::DWARFDie::iterator base() const {\n    return llvm::DWARFDie::iterator(AtEnd ? Die : Die.getSibling());\n  }\n\n  reverse_iterator<llvm::DWARFDie::iterator> &operator++() {\n    assert(!AtEnd && \"Incrementing rend\");\n    llvm::DWARFDie D = Die.getPreviousSibling();\n    if (D)\n      Die = D;\n    else\n      AtEnd = true;\n    return *this;\n  }\n\n  reverse_iterator<llvm::DWARFDie::iterator> &operator--() {\n    if (AtEnd) {\n      AtEnd = false;\n      return *this;\n    }\n    Die = Die.getSibling();\n    assert(!Die.isNULL() && \"Decrementing rbegin\");\n    return *this;\n  }\n\n  const llvm::DWARFDie &operator*() const {\n    assert(Die.isValid());\n    return Die;\n  }\n\n  // FIXME: We should be able to specify the equals operator as a friend, but\n  //        that causes the compiler to think the operator overload is ambiguous\n  //        with the friend declaration and the actual definition as candidates.\n  bool equals(const reverse_iterator<llvm::DWARFDie::iterator> &RHS) const {\n    return Die == RHS.Die && AtEnd == RHS.AtEnd;\n  }\n};\n\n} // namespace std\n\nnamespace llvm {\n\ninline bool operator==(const std::reverse_iterator<DWARFDie::iterator> &LHS,\n                       const std::reverse_iterator<DWARFDie::iterator> &RHS) {\n  return LHS.equals(RHS);\n}\n\ninline bool operator!=(const std::reverse_iterator<DWARFDie::iterator> &LHS,\n                       const std::reverse_iterator<DWARFDie::iterator> &RHS) {\n  return !(LHS == RHS);\n}\n\ninline std::reverse_iterator<DWARFDie::iterator> DWARFDie::rbegin() const {\n  return llvm::make_reverse_iterator(end());\n}\n\ninline std::reverse_iterator<DWARFDie::iterator> DWARFDie::rend() const {\n  return llvm::make_reverse_iterator(begin());\n}\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "content": "//===- DWARFFormValue.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFFORMVALUE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFFORMVALUE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass DWARFContext;\nclass DWARFUnit;\nclass raw_ostream;\n\nclass DWARFFormValue {\npublic:\n  enum FormClass {\n    FC_Unknown,\n    FC_Address,\n    FC_Block,\n    FC_Constant,\n    FC_String,\n    FC_Flag,\n    FC_Reference,\n    FC_Indirect,\n    FC_SectionOffset,\n    FC_Exprloc\n  };\n\nprivate:\n  struct ValueType {\n    ValueType() { uval = 0; }\n    ValueType(int64_t V) : sval(V) {}\n    ValueType(uint64_t V) : uval(V) {}\n    ValueType(const char *V) : cstr(V) {}\n\n    union {\n      uint64_t uval;\n      int64_t sval;\n      const char *cstr;\n    };\n    const uint8_t *data = nullptr;\n    uint64_t SectionIndex;      /// Section index for reference forms.\n  };\n\n  dwarf::Form Form;             /// Form for this value.\n  dwarf::DwarfFormat Format =\n      dwarf::DWARF32;           /// Remember the DWARF format at extract time.\n  ValueType Value;              /// Contains all data for the form.\n  const DWARFUnit *U = nullptr; /// Remember the DWARFUnit at extract time.\n  const DWARFContext *C = nullptr; /// Context for extract time.\n\n  DWARFFormValue(dwarf::Form F, ValueType V) : Form(F), Value(V) {}\n\npublic:\n  DWARFFormValue(dwarf::Form F = dwarf::Form(0)) : Form(F) {}\n\n  static DWARFFormValue createFromSValue(dwarf::Form F, int64_t V);\n  static DWARFFormValue createFromUValue(dwarf::Form F, uint64_t V);\n  static DWARFFormValue createFromPValue(dwarf::Form F, const char *V);\n  static DWARFFormValue createFromBlockValue(dwarf::Form F,\n                                             ArrayRef<uint8_t> D);\n  static DWARFFormValue createFromUnit(dwarf::Form F, const DWARFUnit *Unit,\n                                       uint64_t *OffsetPtr);\n\n  dwarf::Form getForm() const { return Form; }\n  uint64_t getRawUValue() const { return Value.uval; }\n\n  bool isFormClass(FormClass FC) const;\n  const DWARFUnit *getUnit() const { return U; }\n  void dump(raw_ostream &OS, DIDumpOptions DumpOpts = DIDumpOptions()) const;\n  void dumpSectionedAddress(raw_ostream &OS, DIDumpOptions DumpOpts,\n                            object::SectionedAddress SA) const;\n  void dumpAddress(raw_ostream &OS, uint64_t Address) const;\n  static void dumpAddress(raw_ostream &OS, uint8_t AddressSize,\n                          uint64_t Address);\n  static void dumpAddressSection(const DWARFObject &Obj, raw_ostream &OS,\n                                 DIDumpOptions DumpOpts, uint64_t SectionIndex);\n\n  /// Extracts a value in \\p Data at offset \\p *OffsetPtr. The information\n  /// in \\p FormParams is needed to interpret some forms. The optional\n  /// \\p Context and \\p Unit allows extracting information if the form refers\n  /// to other sections (e.g., .debug_str).\n  bool extractValue(const DWARFDataExtractor &Data, uint64_t *OffsetPtr,\n                    dwarf::FormParams FormParams,\n                    const DWARFContext *Context = nullptr,\n                    const DWARFUnit *Unit = nullptr);\n\n  bool extractValue(const DWARFDataExtractor &Data, uint64_t *OffsetPtr,\n                    dwarf::FormParams FormParams, const DWARFUnit *U) {\n    return extractValue(Data, OffsetPtr, FormParams, nullptr, U);\n  }\n\n  bool isInlinedCStr() const {\n    return Value.data != nullptr && Value.data == (const uint8_t *)Value.cstr;\n  }\n\n  /// getAsFoo functions below return the extracted value as Foo if only\n  /// DWARFFormValue has form class is suitable for representing Foo.\n  Optional<uint64_t> getAsReference() const;\n  struct UnitOffset {\n    DWARFUnit *Unit;\n    uint64_t Offset;\n  };\n  Optional<UnitOffset> getAsRelativeReference() const;\n  Optional<uint64_t> getAsUnsignedConstant() const;\n  Optional<int64_t> getAsSignedConstant() const;\n  Optional<const char *> getAsCString() const;\n  Optional<uint64_t> getAsAddress() const;\n  Optional<object::SectionedAddress> getAsSectionedAddress() const;\n  Optional<uint64_t> getAsSectionOffset() const;\n  Optional<ArrayRef<uint8_t>> getAsBlock() const;\n  Optional<uint64_t> getAsCStringOffset() const;\n  Optional<uint64_t> getAsReferenceUVal() const;\n\n  /// Skip a form's value in \\p DebugInfoData at the offset specified by\n  /// \\p OffsetPtr.\n  ///\n  /// Skips the bytes for the current form and updates the offset.\n  ///\n  /// \\param DebugInfoData The data where we want to skip the value.\n  /// \\param OffsetPtr A reference to the offset that will be updated.\n  /// \\param Params DWARF parameters to help interpret forms.\n  /// \\returns true on success, false if the form was not skipped.\n  bool skipValue(DataExtractor DebugInfoData, uint64_t *OffsetPtr,\n                 const dwarf::FormParams Params) const {\n    return DWARFFormValue::skipValue(Form, DebugInfoData, OffsetPtr, Params);\n  }\n\n  /// Skip a form's value in \\p DebugInfoData at the offset specified by\n  /// \\p OffsetPtr.\n  ///\n  /// Skips the bytes for the specified form and updates the offset.\n  ///\n  /// \\param Form The DW_FORM enumeration that indicates the form to skip.\n  /// \\param DebugInfoData The data where we want to skip the value.\n  /// \\param OffsetPtr A reference to the offset that will be updated.\n  /// \\param FormParams DWARF parameters to help interpret forms.\n  /// \\returns true on success, false if the form was not skipped.\n  static bool skipValue(dwarf::Form Form, DataExtractor DebugInfoData,\n                        uint64_t *OffsetPtr,\n                        const dwarf::FormParams FormParams);\n\nprivate:\n  void dumpString(raw_ostream &OS) const;\n};\n\nnamespace dwarf {\n\n/// Take an optional DWARFFormValue and try to extract a string value from it.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and was a string.\ninline Optional<const char *> toString(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsCString();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and try to extract a string value from it.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and was a string.\ninline StringRef toStringRef(const Optional<DWARFFormValue> &V,\n                             StringRef Default = {}) {\n  if (V)\n    if (auto S = V->getAsCString())\n      return *S;\n  return Default;\n}\n\n/// Take an optional DWARFFormValue and extract a string value from it.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the string value or Default if the V doesn't have a value or the\n/// form value's encoding wasn't a string.\ninline const char *toString(const Optional<DWARFFormValue> &V,\n                            const char *Default) {\n  return toString(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an unsigned constant.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a unsigned constant form.\ninline Optional<uint64_t> toUnsigned(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsUnsignedConstant();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a unsigned constant.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted unsigned value or Default if the V doesn't have a\n/// value or the form value's encoding wasn't an unsigned constant form.\ninline uint64_t toUnsigned(const Optional<DWARFFormValue> &V,\n                           uint64_t Default) {\n  return toUnsigned(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an reference.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a reference form.\ninline Optional<uint64_t> toReference(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsReference();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a reference.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted reference value or Default if the V doesn't have a\n/// value or the form value's encoding wasn't a reference form.\ninline uint64_t toReference(const Optional<DWARFFormValue> &V,\n                            uint64_t Default) {\n  return toReference(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an signed constant.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a signed constant form.\ninline Optional<int64_t> toSigned(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsSignedConstant();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a signed integer.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted signed integer value or Default if the V doesn't\n/// have a value or the form value's encoding wasn't a signed integer form.\ninline int64_t toSigned(const Optional<DWARFFormValue> &V, int64_t Default) {\n  return toSigned(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an address.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a address form.\ninline Optional<uint64_t> toAddress(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsAddress();\n  return None;\n}\n\ninline Optional<object::SectionedAddress>\ntoSectionedAddress(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsSectionedAddress();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a address.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted address value or Default if the V doesn't have a\n/// value or the form value's encoding wasn't an address form.\ninline uint64_t toAddress(const Optional<DWARFFormValue> &V, uint64_t Default) {\n  return toAddress(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract an section offset.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a section offset form.\ninline Optional<uint64_t> toSectionOffset(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsSectionOffset();\n  return None;\n}\n\n/// Take an optional DWARFFormValue and extract a section offset.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\param Default the default value to return in case of failure.\n/// \\returns the extracted section offset value or Default if the V doesn't\n/// have a value or the form value's encoding wasn't a section offset form.\ninline uint64_t toSectionOffset(const Optional<DWARFFormValue> &V,\n                                uint64_t Default) {\n  return toSectionOffset(V).getValueOr(Default);\n}\n\n/// Take an optional DWARFFormValue and try to extract block data.\n///\n/// \\param V and optional DWARFFormValue to attempt to extract the value from.\n/// \\returns an optional value that contains a value if the form value\n/// was valid and has a block form.\ninline Optional<ArrayRef<uint8_t>> toBlock(const Optional<DWARFFormValue> &V) {\n  if (V)\n    return V->getAsBlock();\n  return None;\n}\n\n} // end namespace dwarf\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFFORMVALUE_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "content": "//===- MCExpr.h - Assembly Level Expressions --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCEXPR_H\n#define LLVM_MC_MCEXPR_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass MCAsmInfo;\nclass MCAsmLayout;\nclass MCAssembler;\nclass MCContext;\nclass MCFixup;\nclass MCFragment;\nclass MCSection;\nclass MCStreamer;\nclass MCSymbol;\nclass MCValue;\nclass raw_ostream;\nclass StringRef;\n\nusing SectionAddrMap = DenseMap<const MCSection *, uint64_t>;\n\n/// Base class for the full range of assembler expressions which are\n/// needed for parsing.\nclass MCExpr {\npublic:\n  enum ExprKind : uint8_t {\n    Binary,    ///< Binary expressions.\n    Constant,  ///< Constant expressions.\n    SymbolRef, ///< References to labels and assigned expressions.\n    Unary,     ///< Unary expressions.\n    Target     ///< Target specific expression.\n  };\n\nprivate:\n  static const unsigned NumSubclassDataBits = 24;\n  static_assert(\n      NumSubclassDataBits == CHAR_BIT * (sizeof(unsigned) - sizeof(ExprKind)),\n      \"ExprKind and SubclassData together should take up one word\");\n\n  ExprKind Kind;\n  /// Field reserved for use by MCExpr subclasses.\n  unsigned SubclassData : NumSubclassDataBits;\n  SMLoc Loc;\n\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler *Asm,\n                          const MCAsmLayout *Layout,\n                          const SectionAddrMap *Addrs, bool InSet) const;\n\nprotected:\n  explicit MCExpr(ExprKind Kind, SMLoc Loc, unsigned SubclassData = 0)\n      : Kind(Kind), SubclassData(SubclassData), Loc(Loc) {\n    assert(SubclassData < (1 << NumSubclassDataBits) &&\n           \"Subclass data too large\");\n  }\n\n  bool evaluateAsRelocatableImpl(MCValue &Res, const MCAssembler *Asm,\n                                 const MCAsmLayout *Layout,\n                                 const MCFixup *Fixup,\n                                 const SectionAddrMap *Addrs, bool InSet) const;\n\n  unsigned getSubclassData() const { return SubclassData; }\n\npublic:\n  MCExpr(const MCExpr &) = delete;\n  MCExpr &operator=(const MCExpr &) = delete;\n\n  /// \\name Accessors\n  /// @{\n\n  ExprKind getKind() const { return Kind; }\n  SMLoc getLoc() const { return Loc; }\n\n  /// @}\n  /// \\name Utility Methods\n  /// @{\n\n  void print(raw_ostream &OS, const MCAsmInfo *MAI,\n             bool InParens = false) const;\n  void dump() const;\n\n  /// @}\n  /// \\name Expression Evaluation\n  /// @{\n\n  /// Try to evaluate the expression to an absolute value.\n  ///\n  /// \\param Res - The absolute value, if evaluation succeeds.\n  /// \\param Layout - The assembler layout object to use for evaluating symbol\n  /// values. If not given, then only non-symbolic expressions will be\n  /// evaluated.\n  /// \\return - True on success.\n  bool evaluateAsAbsolute(int64_t &Res, const MCAsmLayout &Layout,\n                          const SectionAddrMap &Addrs) const;\n  bool evaluateAsAbsolute(int64_t &Res) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler &Asm) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler *Asm) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAsmLayout &Layout) const;\n\n  bool evaluateKnownAbsolute(int64_t &Res, const MCAsmLayout &Layout) const;\n\n  /// Try to evaluate the expression to a relocatable value, i.e. an\n  /// expression of the fixed form (a - b + constant).\n  ///\n  /// \\param Res - The relocatable value, if evaluation succeeds.\n  /// \\param Layout - The assembler layout object to use for evaluating values.\n  /// \\param Fixup - The Fixup object if available.\n  /// \\return - True on success.\n  bool evaluateAsRelocatable(MCValue &Res, const MCAsmLayout *Layout,\n                             const MCFixup *Fixup) const;\n\n  /// Try to evaluate the expression to the form (a - b + constant) where\n  /// neither a nor b are variables.\n  ///\n  /// This is a more aggressive variant of evaluateAsRelocatable. The intended\n  /// use is for when relocations are not available, like the .size directive.\n  bool evaluateAsValue(MCValue &Res, const MCAsmLayout &Layout) const;\n\n  /// Find the \"associated section\" for this expression, which is\n  /// currently defined as the absolute section for constants, or\n  /// otherwise the section associated with the first defined symbol in the\n  /// expression.\n  MCFragment *findAssociatedFragment() const;\n\n  /// @}\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const MCExpr &E) {\n  E.print(OS, nullptr);\n  return OS;\n}\n\n////  Represent a constant integer expression.\nclass MCConstantExpr : public MCExpr {\n  int64_t Value;\n\n  // Subclass data stores SizeInBytes in bits 0..7 and PrintInHex in bit 8.\n  static const unsigned SizeInBytesBits = 8;\n  static const unsigned SizeInBytesMask = (1 << SizeInBytesBits) - 1;\n  static const unsigned PrintInHexBit = 1 << SizeInBytesBits;\n\n  static unsigned encodeSubclassData(bool PrintInHex, unsigned SizeInBytes) {\n    assert(SizeInBytes <= sizeof(int64_t) && \"Excessive size\");\n    return SizeInBytes | (PrintInHex ? PrintInHexBit : 0);\n  }\n\n  MCConstantExpr(int64_t Value, bool PrintInHex, unsigned SizeInBytes)\n      : MCExpr(MCExpr::Constant, SMLoc(),\n               encodeSubclassData(PrintInHex, SizeInBytes)), Value(Value) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCConstantExpr *create(int64_t Value, MCContext &Ctx,\n                                      bool PrintInHex = false,\n                                      unsigned SizeInBytes = 0);\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  int64_t getValue() const { return Value; }\n  unsigned getSizeInBytes() const {\n    return getSubclassData() & SizeInBytesMask;\n  }\n\n  bool useHexFormat() const { return (getSubclassData() & PrintInHexBit) != 0; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Constant;\n  }\n};\n\n///  Represent a reference to a symbol from inside an expression.\n///\n/// A symbol reference in an expression may be a use of a label, a use of an\n/// assembler variable (defined constant), or constitute an implicit definition\n/// of the symbol as external.\nclass MCSymbolRefExpr : public MCExpr {\npublic:\n  enum VariantKind : uint16_t {\n    VK_None,\n    VK_Invalid,\n\n    VK_GOT,\n    VK_GOTOFF,\n    VK_GOTREL,\n    VK_PCREL,\n    VK_GOTPCREL,\n    VK_GOTTPOFF,\n    VK_INDNTPOFF,\n    VK_NTPOFF,\n    VK_GOTNTPOFF,\n    VK_PLT,\n    VK_TLSGD,\n    VK_TLSLD,\n    VK_TLSLDM,\n    VK_TPOFF,\n    VK_DTPOFF,\n    VK_TLSCALL, // symbol(tlscall)\n    VK_TLSDESC, // symbol(tlsdesc)\n    VK_TLVP,    // Mach-O thread local variable relocations\n    VK_TLVPPAGE,\n    VK_TLVPPAGEOFF,\n    VK_PAGE,\n    VK_PAGEOFF,\n    VK_GOTPAGE,\n    VK_GOTPAGEOFF,\n    VK_SECREL,\n    VK_SIZE,    // symbol@SIZE\n    VK_WEAKREF, // The link between the symbols in .weakref foo, bar\n\n    VK_X86_ABS8,\n    VK_X86_PLTOFF,\n\n    VK_ARM_NONE,\n    VK_ARM_GOT_PREL,\n    VK_ARM_TARGET1,\n    VK_ARM_TARGET2,\n    VK_ARM_PREL31,\n    VK_ARM_SBREL,  // symbol(sbrel)\n    VK_ARM_TLSLDO, // symbol(tlsldo)\n    VK_ARM_TLSDESCSEQ,\n\n    VK_AVR_NONE,\n    VK_AVR_LO8,\n    VK_AVR_HI8,\n    VK_AVR_HLO8,\n    VK_AVR_DIFF8,\n    VK_AVR_DIFF16,\n    VK_AVR_DIFF32,\n    VK_AVR_PM,\n\n    VK_PPC_LO,              // symbol@l\n    VK_PPC_HI,              // symbol@h\n    VK_PPC_HA,              // symbol@ha\n    VK_PPC_HIGH,            // symbol@high\n    VK_PPC_HIGHA,           // symbol@higha\n    VK_PPC_HIGHER,          // symbol@higher\n    VK_PPC_HIGHERA,         // symbol@highera\n    VK_PPC_HIGHEST,         // symbol@highest\n    VK_PPC_HIGHESTA,        // symbol@highesta\n    VK_PPC_GOT_LO,          // symbol@got@l\n    VK_PPC_GOT_HI,          // symbol@got@h\n    VK_PPC_GOT_HA,          // symbol@got@ha\n    VK_PPC_TOCBASE,         // symbol@tocbase\n    VK_PPC_TOC,             // symbol@toc\n    VK_PPC_TOC_LO,          // symbol@toc@l\n    VK_PPC_TOC_HI,          // symbol@toc@h\n    VK_PPC_TOC_HA,          // symbol@toc@ha\n    VK_PPC_U,               // symbol@u\n    VK_PPC_L,               // symbol@l\n    VK_PPC_DTPMOD,          // symbol@dtpmod\n    VK_PPC_TPREL_LO,        // symbol@tprel@l\n    VK_PPC_TPREL_HI,        // symbol@tprel@h\n    VK_PPC_TPREL_HA,        // symbol@tprel@ha\n    VK_PPC_TPREL_HIGH,      // symbol@tprel@high\n    VK_PPC_TPREL_HIGHA,     // symbol@tprel@higha\n    VK_PPC_TPREL_HIGHER,    // symbol@tprel@higher\n    VK_PPC_TPREL_HIGHERA,   // symbol@tprel@highera\n    VK_PPC_TPREL_HIGHEST,   // symbol@tprel@highest\n    VK_PPC_TPREL_HIGHESTA,  // symbol@tprel@highesta\n    VK_PPC_DTPREL_LO,       // symbol@dtprel@l\n    VK_PPC_DTPREL_HI,       // symbol@dtprel@h\n    VK_PPC_DTPREL_HA,       // symbol@dtprel@ha\n    VK_PPC_DTPREL_HIGH,     // symbol@dtprel@high\n    VK_PPC_DTPREL_HIGHA,    // symbol@dtprel@higha\n    VK_PPC_DTPREL_HIGHER,   // symbol@dtprel@higher\n    VK_PPC_DTPREL_HIGHERA,  // symbol@dtprel@highera\n    VK_PPC_DTPREL_HIGHEST,  // symbol@dtprel@highest\n    VK_PPC_DTPREL_HIGHESTA, // symbol@dtprel@highesta\n    VK_PPC_GOT_TPREL,       // symbol@got@tprel\n    VK_PPC_GOT_TPREL_LO,    // symbol@got@tprel@l\n    VK_PPC_GOT_TPREL_HI,    // symbol@got@tprel@h\n    VK_PPC_GOT_TPREL_HA,    // symbol@got@tprel@ha\n    VK_PPC_GOT_DTPREL,      // symbol@got@dtprel\n    VK_PPC_GOT_DTPREL_LO,   // symbol@got@dtprel@l\n    VK_PPC_GOT_DTPREL_HI,   // symbol@got@dtprel@h\n    VK_PPC_GOT_DTPREL_HA,   // symbol@got@dtprel@ha\n    VK_PPC_TLS,             // symbol@tls\n    VK_PPC_GOT_TLSGD,       // symbol@got@tlsgd\n    VK_PPC_GOT_TLSGD_LO,    // symbol@got@tlsgd@l\n    VK_PPC_GOT_TLSGD_HI,    // symbol@got@tlsgd@h\n    VK_PPC_GOT_TLSGD_HA,    // symbol@got@tlsgd@ha\n    VK_PPC_TLSGD,           // symbol@tlsgd\n    VK_PPC_GOT_TLSLD,       // symbol@got@tlsld\n    VK_PPC_GOT_TLSLD_LO,    // symbol@got@tlsld@l\n    VK_PPC_GOT_TLSLD_HI,    // symbol@got@tlsld@h\n    VK_PPC_GOT_TLSLD_HA,    // symbol@got@tlsld@ha\n    VK_PPC_GOT_PCREL,       // symbol@got@pcrel\n    VK_PPC_GOT_TLSGD_PCREL, // symbol@got@tlsgd@pcrel\n    VK_PPC_GOT_TLSLD_PCREL, // symbol@got@tlsld@pcrel\n    VK_PPC_GOT_TPREL_PCREL, // symbol@got@tprel@pcrel\n    VK_PPC_TLS_PCREL,       // symbol@tls@pcrel\n    VK_PPC_TLSLD,           // symbol@tlsld\n    VK_PPC_LOCAL,           // symbol@local\n    VK_PPC_NOTOC,           // symbol@notoc\n    VK_PPC_PCREL_OPT,       // .reloc expr, R_PPC64_PCREL_OPT, expr\n\n    VK_COFF_IMGREL32, // symbol@imgrel (image-relative)\n\n    VK_Hexagon_LO16,\n    VK_Hexagon_HI16,\n    VK_Hexagon_GPREL,\n    VK_Hexagon_GD_GOT,\n    VK_Hexagon_LD_GOT,\n    VK_Hexagon_GD_PLT,\n    VK_Hexagon_LD_PLT,\n    VK_Hexagon_IE,\n    VK_Hexagon_IE_GOT,\n\n    VK_WASM_TYPEINDEX, // Reference to a symbol's type (signature)\n    VK_WASM_TLSREL,    // Memory address relative to __tls_base\n    VK_WASM_MBREL,     // Memory address relative to __memory_base\n    VK_WASM_TBREL,     // Table index relative to __table_base\n\n    VK_AMDGPU_GOTPCREL32_LO, // symbol@gotpcrel32@lo\n    VK_AMDGPU_GOTPCREL32_HI, // symbol@gotpcrel32@hi\n    VK_AMDGPU_REL32_LO,      // symbol@rel32@lo\n    VK_AMDGPU_REL32_HI,      // symbol@rel32@hi\n    VK_AMDGPU_REL64,         // symbol@rel64\n    VK_AMDGPU_ABS32_LO,      // symbol@abs32@lo\n    VK_AMDGPU_ABS32_HI,      // symbol@abs32@hi\n\n    VK_VE_HI32,        // symbol@hi\n    VK_VE_LO32,        // symbol@lo\n    VK_VE_PC_HI32,     // symbol@pc_hi\n    VK_VE_PC_LO32,     // symbol@pc_lo\n    VK_VE_GOT_HI32,    // symbol@got_hi\n    VK_VE_GOT_LO32,    // symbol@got_lo\n    VK_VE_GOTOFF_HI32, // symbol@gotoff_hi\n    VK_VE_GOTOFF_LO32, // symbol@gotoff_lo\n    VK_VE_PLT_HI32,    // symbol@plt_hi\n    VK_VE_PLT_LO32,    // symbol@plt_lo\n    VK_VE_TLS_GD_HI32, // symbol@tls_gd_hi\n    VK_VE_TLS_GD_LO32, // symbol@tls_gd_lo\n    VK_VE_TPOFF_HI32,  // symbol@tpoff_hi\n    VK_VE_TPOFF_LO32,  // symbol@tpoff_lo\n\n    VK_TPREL,\n    VK_DTPREL\n  };\n\nprivate:\n  /// The symbol being referenced.\n  const MCSymbol *Symbol;\n\n  // Subclass data stores VariantKind in bits 0..15 and HasSubsectionsViaSymbols\n  // in bit 16.\n  static const unsigned VariantKindBits = 16;\n  static const unsigned VariantKindMask = (1 << VariantKindBits) - 1;\n\n  // FIXME: Remove this bit.\n  static const unsigned HasSubsectionsViaSymbolsBit = 1 << VariantKindBits;\n\n  static unsigned encodeSubclassData(VariantKind Kind,\n                                     bool HasSubsectionsViaSymbols) {\n    return (unsigned)Kind |\n           (HasSubsectionsViaSymbols ? HasSubsectionsViaSymbolsBit : 0);\n  }\n\n  explicit MCSymbolRefExpr(const MCSymbol *Symbol, VariantKind Kind,\n                           const MCAsmInfo *MAI, SMLoc Loc = SMLoc());\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCSymbolRefExpr *create(const MCSymbol *Symbol, MCContext &Ctx) {\n    return MCSymbolRefExpr::create(Symbol, VK_None, Ctx);\n  }\n\n  static const MCSymbolRefExpr *create(const MCSymbol *Symbol, VariantKind Kind,\n                                       MCContext &Ctx, SMLoc Loc = SMLoc());\n  static const MCSymbolRefExpr *create(StringRef Name, VariantKind Kind,\n                                       MCContext &Ctx);\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  const MCSymbol &getSymbol() const { return *Symbol; }\n\n  VariantKind getKind() const {\n    return (VariantKind)(getSubclassData() & VariantKindMask);\n  }\n\n  bool hasSubsectionsViaSymbols() const {\n    return (getSubclassData() & HasSubsectionsViaSymbolsBit) != 0;\n  }\n\n  /// @}\n  /// \\name Static Utility Functions\n  /// @{\n\n  static StringRef getVariantKindName(VariantKind Kind);\n\n  static VariantKind getVariantKindForName(StringRef Name);\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::SymbolRef;\n  }\n};\n\n/// Unary assembler expressions.\nclass MCUnaryExpr : public MCExpr {\npublic:\n  enum Opcode {\n    LNot,  ///< Logical negation.\n    Minus, ///< Unary minus.\n    Not,   ///< Bitwise negation.\n    Plus   ///< Unary plus.\n  };\n\nprivate:\n  const MCExpr *Expr;\n\n  MCUnaryExpr(Opcode Op, const MCExpr *Expr, SMLoc Loc)\n      : MCExpr(MCExpr::Unary, Loc, Op), Expr(Expr) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCUnaryExpr *create(Opcode Op, const MCExpr *Expr,\n                                   MCContext &Ctx, SMLoc Loc = SMLoc());\n\n  static const MCUnaryExpr *createLNot(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(LNot, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createMinus(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Minus, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createNot(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Not, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createPlus(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Plus, Expr, Ctx, Loc);\n  }\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  /// Get the kind of this unary expression.\n  Opcode getOpcode() const { return (Opcode)getSubclassData(); }\n\n  /// Get the child of this unary expression.\n  const MCExpr *getSubExpr() const { return Expr; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Unary;\n  }\n};\n\n/// Binary assembler expressions.\nclass MCBinaryExpr : public MCExpr {\npublic:\n  enum Opcode {\n    Add,  ///< Addition.\n    And,  ///< Bitwise and.\n    Div,  ///< Signed division.\n    EQ,   ///< Equality comparison.\n    GT,   ///< Signed greater than comparison (result is either 0 or some\n          ///< target-specific non-zero value)\n    GTE,  ///< Signed greater than or equal comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    LAnd, ///< Logical and.\n    LOr,  ///< Logical or.\n    LT,   ///< Signed less than comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    LTE,  ///< Signed less than or equal comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    Mod,  ///< Signed remainder.\n    Mul,  ///< Multiplication.\n    NE,   ///< Inequality comparison.\n    Or,   ///< Bitwise or.\n    OrNot, ///< Bitwise or not.\n    Shl,  ///< Shift left.\n    AShr, ///< Arithmetic shift right.\n    LShr, ///< Logical shift right.\n    Sub,  ///< Subtraction.\n    Xor   ///< Bitwise exclusive or.\n  };\n\nprivate:\n  const MCExpr *LHS, *RHS;\n\n  MCBinaryExpr(Opcode Op, const MCExpr *LHS, const MCExpr *RHS,\n               SMLoc Loc = SMLoc())\n      : MCExpr(MCExpr::Binary, Loc, Op), LHS(LHS), RHS(RHS) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCBinaryExpr *create(Opcode Op, const MCExpr *LHS,\n                                    const MCExpr *RHS, MCContext &Ctx,\n                                    SMLoc Loc = SMLoc());\n\n  static const MCBinaryExpr *createAdd(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Add, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createAnd(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(And, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createDiv(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Div, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createEQ(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(EQ, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createGT(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(GT, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createGTE(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(GTE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLAnd(const MCExpr *LHS, const MCExpr *RHS,\n                                        MCContext &Ctx) {\n    return create(LAnd, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLOr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LOr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLT(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(LT, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLTE(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LTE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createMod(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Mod, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createMul(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Mul, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createNE(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(NE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createOr(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(Or, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createShl(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Shl, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createAShr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(AShr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLShr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LShr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createSub(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Sub, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createXor(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Xor, LHS, RHS, Ctx);\n  }\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  /// Get the kind of this binary expression.\n  Opcode getOpcode() const { return (Opcode)getSubclassData(); }\n\n  /// Get the left-hand side expression of the binary operator.\n  const MCExpr *getLHS() const { return LHS; }\n\n  /// Get the right-hand side expression of the binary operator.\n  const MCExpr *getRHS() const { return RHS; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Binary;\n  }\n};\n\n/// This is an extension point for target-specific MCExpr subclasses to\n/// implement.\n///\n/// NOTE: All subclasses are required to have trivial destructors because\n/// MCExprs are bump pointer allocated and not destructed.\nclass MCTargetExpr : public MCExpr {\n  virtual void anchor();\n\nprotected:\n  MCTargetExpr() : MCExpr(Target, SMLoc()) {}\n  virtual ~MCTargetExpr() = default;\n\npublic:\n  virtual void printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const = 0;\n  virtual bool evaluateAsRelocatableImpl(MCValue &Res,\n                                         const MCAsmLayout *Layout,\n                                         const MCFixup *Fixup) const = 0;\n  // allow Target Expressions to be checked for equality\n  virtual bool isEqualTo(const MCExpr *x) const { return false; }\n  // This should be set when assigned expressions are not valid \".set\"\n  // expressions, e.g. registers, and must be inlined.\n  virtual bool inlineAssignedExpr() const { return false; }\n  virtual void visitUsedExpr(MCStreamer& Streamer) const = 0;\n  virtual MCFragment *findAssociatedFragment() const = 0;\n\n  virtual void fixELFSymbolsInTLSFixups(MCAssembler &) const = 0;\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Target;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCEXPR_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "content": "//===- MCFragment.h - Fragment type hierarchy -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCFRAGMENT_H\n#define LLVM_MC_MCFRAGMENT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/MC/MCFixup.h\"\n#include \"llvm/MC/MCInst.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\nclass MCSection;\nclass MCSubtargetInfo;\nclass MCSymbol;\n\nclass MCFragment : public ilist_node_with_parent<MCFragment, MCSection> {\n  friend class MCAsmLayout;\n\npublic:\n  enum FragmentType : uint8_t {\n    FT_Align,\n    FT_Data,\n    FT_CompactEncodedInst,\n    FT_Fill,\n    FT_Nops,\n    FT_Relaxable,\n    FT_Org,\n    FT_Dwarf,\n    FT_DwarfFrame,\n    FT_LEB,\n    FT_BoundaryAlign,\n    FT_SymbolId,\n    FT_CVInlineLines,\n    FT_CVDefRange,\n    FT_PseudoProbe,\n    FT_Dummy\n  };\n\nprivate:\n  /// The data for the section this fragment is in.\n  MCSection *Parent;\n\n  /// The atom this fragment is in, as represented by its defining symbol.\n  const MCSymbol *Atom;\n\n  /// The offset of this fragment in its section. This is ~0 until\n  /// initialized.\n  uint64_t Offset;\n\n  /// The layout order of this fragment.\n  unsigned LayoutOrder;\n\n  /// The subsection this fragment belongs to. This is 0 if the fragment is not\n  // in any subsection.\n  unsigned SubsectionNumber = 0;\n\n  FragmentType Kind;\n\n  /// Whether fragment is being laid out.\n  bool IsBeingLaidOut;\n\nprotected:\n  bool HasInstructions;\n\n  MCFragment(FragmentType Kind, bool HasInstructions,\n             MCSection *Parent = nullptr);\n\npublic:\n  MCFragment() = delete;\n  MCFragment(const MCFragment &) = delete;\n  MCFragment &operator=(const MCFragment &) = delete;\n\n  /// Destroys the current fragment.\n  ///\n  /// This must be used instead of delete as MCFragment is non-virtual.\n  /// This method will dispatch to the appropriate subclass.\n  void destroy();\n\n  FragmentType getKind() const { return Kind; }\n\n  MCSection *getParent() const { return Parent; }\n  void setParent(MCSection *Value) { Parent = Value; }\n\n  const MCSymbol *getAtom() const { return Atom; }\n  void setAtom(const MCSymbol *Value) { Atom = Value; }\n\n  unsigned getLayoutOrder() const { return LayoutOrder; }\n  void setLayoutOrder(unsigned Value) { LayoutOrder = Value; }\n\n  /// Does this fragment have instructions emitted into it? By default\n  /// this is false, but specific fragment types may set it to true.\n  bool hasInstructions() const { return HasInstructions; }\n\n  void dump() const;\n\n  void setSubsectionNumber(unsigned Value) { SubsectionNumber = Value; }\n  unsigned getSubsectionNumber() const { return SubsectionNumber; }\n};\n\nclass MCDummyFragment : public MCFragment {\npublic:\n  explicit MCDummyFragment(MCSection *Sec) : MCFragment(FT_Dummy, false, Sec) {}\n\n  static bool classof(const MCFragment *F) { return F->getKind() == FT_Dummy; }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data.\n///\nclass MCEncodedFragment : public MCFragment {\n  /// Should this fragment be aligned to the end of a bundle?\n  bool AlignToBundleEnd = false;\n\n  uint8_t BundlePadding = 0;\n\nprotected:\n  MCEncodedFragment(MCFragment::FragmentType FType, bool HasInstructions,\n                    MCSection *Sec)\n      : MCFragment(FType, HasInstructions, Sec) {}\n\n  /// The MCSubtargetInfo in effect when the instruction was encoded.\n  /// It must be non-null for instructions.\n  const MCSubtargetInfo *STI = nullptr;\n\npublic:\n  static bool classof(const MCFragment *F) {\n    MCFragment::FragmentType Kind = F->getKind();\n    switch (Kind) {\n    default:\n      return false;\n    case MCFragment::FT_Relaxable:\n    case MCFragment::FT_CompactEncodedInst:\n    case MCFragment::FT_Data:\n    case MCFragment::FT_Dwarf:\n    case MCFragment::FT_DwarfFrame:\n    case MCFragment::FT_PseudoProbe:\n      return true;\n    }\n  }\n\n  /// Should this fragment be placed at the end of an aligned bundle?\n  bool alignToBundleEnd() const { return AlignToBundleEnd; }\n  void setAlignToBundleEnd(bool V) { AlignToBundleEnd = V; }\n\n  /// Get the padding size that must be inserted before this fragment.\n  /// Used for bundling. By default, no padding is inserted.\n  /// Note that padding size is restricted to 8 bits. This is an optimization\n  /// to reduce the amount of space used for each fragment. In practice, larger\n  /// padding should never be required.\n  uint8_t getBundlePadding() const { return BundlePadding; }\n\n  /// Set the padding size for this fragment. By default it's a no-op,\n  /// and only some fragments have a meaningful implementation.\n  void setBundlePadding(uint8_t N) { BundlePadding = N; }\n\n  /// Retrieve the MCSubTargetInfo in effect when the instruction was encoded.\n  /// Guaranteed to be non-null if hasInstructions() == true\n  const MCSubtargetInfo *getSubtargetInfo() const { return STI; }\n\n  /// Record that the fragment contains instructions with the MCSubtargetInfo in\n  /// effect when the instruction was encoded.\n  void setHasInstructions(const MCSubtargetInfo &STI) {\n    HasInstructions = true;\n    this->STI = &STI;\n  }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data.\n///\ntemplate<unsigned ContentsSize>\nclass MCEncodedFragmentWithContents : public MCEncodedFragment {\n  SmallVector<char, ContentsSize> Contents;\n\nprotected:\n  MCEncodedFragmentWithContents(MCFragment::FragmentType FType,\n                                bool HasInstructions,\n                                MCSection *Sec)\n      : MCEncodedFragment(FType, HasInstructions, Sec) {}\n\npublic:\n  SmallVectorImpl<char> &getContents() { return Contents; }\n  const SmallVectorImpl<char> &getContents() const { return Contents; }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data and also have fixups registered.\n///\ntemplate<unsigned ContentsSize, unsigned FixupsSize>\nclass MCEncodedFragmentWithFixups :\n  public MCEncodedFragmentWithContents<ContentsSize> {\n\n  /// The list of fixups in this fragment.\n  SmallVector<MCFixup, FixupsSize> Fixups;\n\nprotected:\n  MCEncodedFragmentWithFixups(MCFragment::FragmentType FType,\n                              bool HasInstructions,\n                              MCSection *Sec)\n      : MCEncodedFragmentWithContents<ContentsSize>(FType, HasInstructions,\n                                                    Sec) {}\n\npublic:\n\n  using const_fixup_iterator = SmallVectorImpl<MCFixup>::const_iterator;\n  using fixup_iterator = SmallVectorImpl<MCFixup>::iterator;\n\n  SmallVectorImpl<MCFixup> &getFixups() { return Fixups; }\n  const SmallVectorImpl<MCFixup> &getFixups() const { return Fixups; }\n\n  fixup_iterator fixup_begin() { return Fixups.begin(); }\n  const_fixup_iterator fixup_begin() const { return Fixups.begin(); }\n\n  fixup_iterator fixup_end() { return Fixups.end(); }\n  const_fixup_iterator fixup_end() const { return Fixups.end(); }\n\n  static bool classof(const MCFragment *F) {\n    MCFragment::FragmentType Kind = F->getKind();\n    return Kind == MCFragment::FT_Relaxable || Kind == MCFragment::FT_Data ||\n           Kind == MCFragment::FT_CVDefRange || Kind == MCFragment::FT_Dwarf ||\n           Kind == MCFragment::FT_DwarfFrame;\n  }\n};\n\n/// Fragment for data and encoded instructions.\n///\nclass MCDataFragment : public MCEncodedFragmentWithFixups<32, 4> {\npublic:\n  MCDataFragment(MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<32, 4>(FT_Data, false, Sec) {}\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Data;\n  }\n};\n\n/// This is a compact (memory-size-wise) fragment for holding an encoded\n/// instruction (non-relaxable) that has no fixups registered. When applicable,\n/// it can be used instead of MCDataFragment and lead to lower memory\n/// consumption.\n///\nclass MCCompactEncodedInstFragment : public MCEncodedFragmentWithContents<4> {\npublic:\n  MCCompactEncodedInstFragment(MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithContents(FT_CompactEncodedInst, true, Sec) {\n  }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CompactEncodedInst;\n  }\n};\n\n/// A relaxable fragment holds on to its MCInst, since it may need to be\n/// relaxed during the assembler layout and relaxation stage.\n///\nclass MCRelaxableFragment : public MCEncodedFragmentWithFixups<8, 1> {\n\n  /// The instruction this is a fragment for.\n  MCInst Inst;\n  /// Can we auto pad the instruction?\n  bool AllowAutoPadding = false;\n\npublic:\n  MCRelaxableFragment(const MCInst &Inst, const MCSubtargetInfo &STI,\n                      MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups(FT_Relaxable, true, Sec),\n        Inst(Inst) { this->STI = &STI; }\n\n  const MCInst &getInst() const { return Inst; }\n  void setInst(const MCInst &Value) { Inst = Value; }\n\n  bool getAllowAutoPadding() const { return AllowAutoPadding; }\n  void setAllowAutoPadding(bool V) { AllowAutoPadding = V; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Relaxable;\n  }\n};\n\nclass MCAlignFragment : public MCFragment {\n  /// The alignment to ensure, in bytes.\n  unsigned Alignment;\n\n  /// Flag to indicate that (optimal) NOPs should be emitted instead\n  /// of using the provided value. The exact interpretation of this flag is\n  /// target dependent.\n  bool EmitNops : 1;\n\n  /// Value to use for filling padding bytes.\n  int64_t Value;\n\n  /// The size of the integer (in bytes) of \\p Value.\n  unsigned ValueSize;\n\n  /// The maximum number of bytes to emit; if the alignment\n  /// cannot be satisfied in this width then this fragment is ignored.\n  unsigned MaxBytesToEmit;\n\npublic:\n  MCAlignFragment(unsigned Alignment, int64_t Value, unsigned ValueSize,\n                  unsigned MaxBytesToEmit, MCSection *Sec = nullptr)\n      : MCFragment(FT_Align, false, Sec), Alignment(Alignment), EmitNops(false),\n        Value(Value), ValueSize(ValueSize), MaxBytesToEmit(MaxBytesToEmit) {}\n\n  unsigned getAlignment() const { return Alignment; }\n\n  int64_t getValue() const { return Value; }\n\n  unsigned getValueSize() const { return ValueSize; }\n\n  unsigned getMaxBytesToEmit() const { return MaxBytesToEmit; }\n\n  bool hasEmitNops() const { return EmitNops; }\n  void setEmitNops(bool Value) { EmitNops = Value; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Align;\n  }\n};\n\nclass MCFillFragment : public MCFragment {\n  uint8_t ValueSize;\n  /// Value to use for filling bytes.\n  uint64_t Value;\n  /// The number of bytes to insert.\n  const MCExpr &NumValues;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCFillFragment(uint64_t Value, uint8_t VSize, const MCExpr &NumValues,\n                 SMLoc Loc, MCSection *Sec = nullptr)\n      : MCFragment(FT_Fill, false, Sec), ValueSize(VSize), Value(Value),\n        NumValues(NumValues), Loc(Loc) {}\n\n  uint64_t getValue() const { return Value; }\n  uint8_t getValueSize() const { return ValueSize; }\n  const MCExpr &getNumValues() const { return NumValues; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Fill;\n  }\n};\n\nclass MCNopsFragment : public MCFragment {\n  /// The number of bytes to insert.\n  int64_t Size;\n  /// Maximum number of bytes allowed in each NOP instruction.\n  int64_t ControlledNopLength;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCNopsFragment(int64_t NumBytes, int64_t ControlledNopLength, SMLoc L,\n                 MCSection *Sec = nullptr)\n      : MCFragment(FT_Nops, false, Sec), Size(NumBytes),\n        ControlledNopLength(ControlledNopLength), Loc(L) {}\n\n  int64_t getNumBytes() const { return Size; }\n  int64_t getControlledNopLength() const { return ControlledNopLength; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Nops;\n  }\n};\n\nclass MCOrgFragment : public MCFragment {\n  /// Value to use for filling bytes.\n  int8_t Value;\n\n  /// The offset this fragment should start at.\n  const MCExpr *Offset;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCOrgFragment(const MCExpr &Offset, int8_t Value, SMLoc Loc,\n                MCSection *Sec = nullptr)\n      : MCFragment(FT_Org, false, Sec), Value(Value), Offset(&Offset),\n        Loc(Loc) {}\n\n  const MCExpr &getOffset() const { return *Offset; }\n\n  uint8_t getValue() const { return Value; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Org;\n  }\n};\n\nclass MCLEBFragment : public MCFragment {\n  /// True if this is a sleb128, false if uleb128.\n  bool IsSigned;\n\n  /// The value this fragment should contain.\n  const MCExpr *Value;\n\n  SmallString<8> Contents;\n\npublic:\n  MCLEBFragment(const MCExpr &Value_, bool IsSigned_, MCSection *Sec = nullptr)\n      : MCFragment(FT_LEB, false, Sec), IsSigned(IsSigned_), Value(&Value_) {\n    Contents.push_back(0);\n  }\n\n  const MCExpr &getValue() const { return *Value; }\n\n  bool isSigned() const { return IsSigned; }\n\n  SmallString<8> &getContents() { return Contents; }\n  const SmallString<8> &getContents() const { return Contents; }\n\n  /// @}\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_LEB;\n  }\n};\n\nclass MCDwarfLineAddrFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The value of the difference between the two line numbers\n  /// between two .loc dwarf directives.\n  int64_t LineDelta;\n\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .loc dwarf directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCDwarfLineAddrFragment(int64_t LineDelta, const MCExpr &AddrDelta,\n                          MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_Dwarf, false, Sec),\n        LineDelta(LineDelta), AddrDelta(&AddrDelta) {}\n\n  int64_t getLineDelta() const { return LineDelta; }\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Dwarf;\n  }\n};\n\nclass MCDwarfCallFrameFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .cfi_* dwarf directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCDwarfCallFrameFragment(const MCExpr &AddrDelta, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_DwarfFrame, false, Sec),\n        AddrDelta(&AddrDelta) {}\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_DwarfFrame;\n  }\n};\n\n/// Represents a symbol table index fragment.\nclass MCSymbolIdFragment : public MCFragment {\n  const MCSymbol *Sym;\n\npublic:\n  MCSymbolIdFragment(const MCSymbol *Sym, MCSection *Sec = nullptr)\n      : MCFragment(FT_SymbolId, false, Sec), Sym(Sym) {}\n\n  const MCSymbol *getSymbol() { return Sym; }\n  const MCSymbol *getSymbol() const { return Sym; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_SymbolId;\n  }\n};\n\n/// Fragment representing the binary annotations produced by the\n/// .cv_inline_linetable directive.\nclass MCCVInlineLineTableFragment : public MCFragment {\n  unsigned SiteFuncId;\n  unsigned StartFileId;\n  unsigned StartLineNum;\n  const MCSymbol *FnStartSym;\n  const MCSymbol *FnEndSym;\n  SmallString<8> Contents;\n\n  /// CodeViewContext has the real knowledge about this format, so let it access\n  /// our members.\n  friend class CodeViewContext;\n\npublic:\n  MCCVInlineLineTableFragment(unsigned SiteFuncId, unsigned StartFileId,\n                              unsigned StartLineNum, const MCSymbol *FnStartSym,\n                              const MCSymbol *FnEndSym,\n                              MCSection *Sec = nullptr)\n      : MCFragment(FT_CVInlineLines, false, Sec), SiteFuncId(SiteFuncId),\n        StartFileId(StartFileId), StartLineNum(StartLineNum),\n        FnStartSym(FnStartSym), FnEndSym(FnEndSym) {}\n\n  const MCSymbol *getFnStartSym() const { return FnStartSym; }\n  const MCSymbol *getFnEndSym() const { return FnEndSym; }\n\n  SmallString<8> &getContents() { return Contents; }\n  const SmallString<8> &getContents() const { return Contents; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CVInlineLines;\n  }\n};\n\n/// Fragment representing the .cv_def_range directive.\nclass MCCVDefRangeFragment : public MCEncodedFragmentWithFixups<32, 4> {\n  SmallVector<std::pair<const MCSymbol *, const MCSymbol *>, 2> Ranges;\n  SmallString<32> FixedSizePortion;\n\n  /// CodeViewContext has the real knowledge about this format, so let it access\n  /// our members.\n  friend class CodeViewContext;\n\npublic:\n  MCCVDefRangeFragment(\n      ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,\n      StringRef FixedSizePortion, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<32, 4>(FT_CVDefRange, false, Sec),\n        Ranges(Ranges.begin(), Ranges.end()),\n        FixedSizePortion(FixedSizePortion) {}\n\n  ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> getRanges() const {\n    return Ranges;\n  }\n\n  StringRef getFixedSizePortion() const { return FixedSizePortion; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CVDefRange;\n  }\n};\n\n/// Represents required padding such that a particular other set of fragments\n/// does not cross a particular power-of-two boundary. The other fragments must\n/// follow this one within the same section.\nclass MCBoundaryAlignFragment : public MCFragment {\n  /// The alignment requirement of the branch to be aligned.\n  Align AlignBoundary;\n  /// The last fragment in the set of fragments to be aligned.\n  const MCFragment *LastFragment = nullptr;\n  /// The size of the fragment.  The size is lazily set during relaxation, and\n  /// is not meaningful before that.\n  uint64_t Size = 0;\n\npublic:\n  MCBoundaryAlignFragment(Align AlignBoundary, MCSection *Sec = nullptr)\n      : MCFragment(FT_BoundaryAlign, false, Sec), AlignBoundary(AlignBoundary) {\n  }\n\n  uint64_t getSize() const { return Size; }\n  void setSize(uint64_t Value) { Size = Value; }\n\n  Align getAlignment() const { return AlignBoundary; }\n  void setAlignment(Align Value) { AlignBoundary = Value; }\n\n  const MCFragment *getLastFragment() const { return LastFragment; }\n  void setLastFragment(const MCFragment *F) {\n    assert(!F || getParent() == F->getParent());\n    LastFragment = F;\n  }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_BoundaryAlign;\n  }\n};\n\nclass MCPseudoProbeAddrFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .pseudoprobe directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCPseudoProbeAddrFragment(const MCExpr *AddrDelta, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_PseudoProbe, false, Sec),\n        AddrDelta(AddrDelta) {}\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_PseudoProbe;\n  }\n};\n} // end namespace llvm\n\n#endif // LLVM_MC_MCFRAGMENT_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "content": "//===- llvm/MC/MCInst.h - MCInst class --------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MCInst and MCOperand classes, which\n// is the basic representation used to represent low-level machine code\n// instructions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCINST_H\n#define LLVM_MC_MCINST_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/bit.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass MCExpr;\nclass MCInst;\nclass MCInstPrinter;\nclass raw_ostream;\n\n/// Instances of this class represent operands of the MCInst class.\n/// This is a simple discriminated union.\nclass MCOperand {\n  enum MachineOperandType : unsigned char {\n    kInvalid,      ///< Uninitialized.\n    kRegister,     ///< Register operand.\n    kImmediate,    ///< Immediate operand.\n    kSFPImmediate, ///< Single-floating-point immediate operand.\n    kDFPImmediate, ///< Double-Floating-point immediate operand.\n    kExpr,         ///< Relocatable immediate operand.\n    kInst          ///< Sub-instruction operand.\n  };\n  MachineOperandType Kind = kInvalid;\n\n  union {\n    unsigned RegVal;\n    int64_t ImmVal;\n    uint32_t SFPImmVal;\n    uint64_t FPImmVal;\n    const MCExpr *ExprVal;\n    const MCInst *InstVal;\n  };\n\npublic:\n  MCOperand() : FPImmVal(0) {}\n\n  bool isValid() const { return Kind != kInvalid; }\n  bool isReg() const { return Kind == kRegister; }\n  bool isImm() const { return Kind == kImmediate; }\n  bool isSFPImm() const { return Kind == kSFPImmediate; }\n  bool isDFPImm() const { return Kind == kDFPImmediate; }\n  bool isFPImm() const { return Kind == kDFPImmediate; }\n  bool isExpr() const { return Kind == kExpr; }\n  bool isInst() const { return Kind == kInst; }\n\n  /// Returns the register number.\n  unsigned getReg() const {\n    assert(isReg() && \"This is not a register operand!\");\n    return RegVal;\n  }\n\n  /// Set the register number.\n  void setReg(unsigned Reg) {\n    assert(isReg() && \"This is not a register operand!\");\n    RegVal = Reg;\n  }\n\n  int64_t getImm() const {\n    assert(isImm() && \"This is not an immediate\");\n    return ImmVal;\n  }\n\n  void setImm(int64_t Val) {\n    assert(isImm() && \"This is not an immediate\");\n    ImmVal = Val;\n  }\n\n  uint32_t getSFPImm() const {\n    assert(isSFPImm() && \"This is not an SFP immediate\");\n    return SFPImmVal;\n  }\n\n  void setSFPImm(uint32_t Val) {\n    assert(isSFPImm() && \"This is not an SFP immediate\");\n    SFPImmVal = Val;\n  }\n\n  uint64_t getDFPImm() const {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    return FPImmVal;\n  }\n  double getFPImm() const {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    return bit_cast<double>(FPImmVal);\n  }\n\n  void setDFPImm(uint64_t Val) {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    FPImmVal = Val;\n  }\n  void setFPImm(double Val) {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    FPImmVal = bit_cast<uint64_t>(Val);\n  }\n\n  const MCExpr *getExpr() const {\n    assert(isExpr() && \"This is not an expression\");\n    return ExprVal;\n  }\n\n  void setExpr(const MCExpr *Val) {\n    assert(isExpr() && \"This is not an expression\");\n    ExprVal = Val;\n  }\n\n  const MCInst *getInst() const {\n    assert(isInst() && \"This is not a sub-instruction\");\n    return InstVal;\n  }\n\n  void setInst(const MCInst *Val) {\n    assert(isInst() && \"This is not a sub-instruction\");\n    InstVal = Val;\n  }\n\n  static MCOperand createReg(unsigned Reg) {\n    MCOperand Op;\n    Op.Kind = kRegister;\n    Op.RegVal = Reg;\n    return Op;\n  }\n\n  static MCOperand createImm(int64_t Val) {\n    MCOperand Op;\n    Op.Kind = kImmediate;\n    Op.ImmVal = Val;\n    return Op;\n  }\n\n  static MCOperand createSFPImm(uint32_t Val) {\n    MCOperand Op;\n    Op.Kind = kSFPImmediate;\n    Op.SFPImmVal = Val;\n    return Op;\n  }\n\n  static MCOperand createDFPImm(uint64_t Val) {\n    MCOperand Op;\n    Op.Kind = kDFPImmediate;\n    Op.FPImmVal = Val;\n    return Op;\n  }\n  static MCOperand createFPImm(double Val) {\n    MCOperand Op;\n    Op.Kind = kDFPImmediate;\n    Op.FPImmVal = bit_cast<uint64_t>(Val);\n    return Op;\n  }\n\n  static MCOperand createExpr(const MCExpr *Val) {\n    MCOperand Op;\n    Op.Kind = kExpr;\n    Op.ExprVal = Val;\n    return Op;\n  }\n\n  static MCOperand createInst(const MCInst *Val) {\n    MCOperand Op;\n    Op.Kind = kInst;\n    Op.InstVal = Val;\n    return Op;\n  }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n  bool isBareSymbolRef() const;\n  bool evaluateAsConstantImm(int64_t &Imm) const;\n};\n\n/// Instances of this class represent a single low-level machine\n/// instruction.\nclass MCInst {\n  unsigned Opcode = 0;\n  // These flags could be used to pass some info from one target subcomponent\n  // to another, for example, from disassembler to asm printer. The values of\n  // the flags have any sense on target level only (e.g. prefixes on x86).\n  unsigned Flags = 0;\n\n  SMLoc Loc;\n  SmallVector<MCOperand, 8> Operands;\n\npublic:\n  MCInst() = default;\n\n  void setOpcode(unsigned Op) { Opcode = Op; }\n  unsigned getOpcode() const { return Opcode; }\n\n  void setFlags(unsigned F) { Flags = F; }\n  unsigned getFlags() const { return Flags; }\n\n  void setLoc(SMLoc loc) { Loc = loc; }\n  SMLoc getLoc() const { return Loc; }\n\n  const MCOperand &getOperand(unsigned i) const { return Operands[i]; }\n  MCOperand &getOperand(unsigned i) { return Operands[i]; }\n  unsigned getNumOperands() const { return Operands.size(); }\n\n  void addOperand(const MCOperand Op) { Operands.push_back(Op); }\n\n  using iterator = SmallVectorImpl<MCOperand>::iterator;\n  using const_iterator = SmallVectorImpl<MCOperand>::const_iterator;\n\n  void clear() { Operands.clear(); }\n  void erase(iterator I) { Operands.erase(I); }\n  void erase(iterator First, iterator Last) { Operands.erase(First, Last); }\n  size_t size() const { return Operands.size(); }\n  iterator begin() { return Operands.begin(); }\n  const_iterator begin() const { return Operands.begin(); }\n  iterator end() { return Operands.end(); }\n  const_iterator end() const { return Operands.end(); }\n\n  iterator insert(iterator I, const MCOperand &Op) {\n    return Operands.insert(I, Op);\n  }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\n  /// Dump the MCInst as prettily as possible using the additional MC\n  /// structures, if given. Operators are separated by the \\p Separator\n  /// string.\n  void dump_pretty(raw_ostream &OS, const MCInstPrinter *Printer = nullptr,\n                   StringRef Separator = \" \") const;\n  void dump_pretty(raw_ostream &OS, StringRef Name,\n                   StringRef Separator = \" \") const;\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const MCOperand &MO) {\n  MO.print(OS);\n  return OS;\n}\n\ninline raw_ostream& operator<<(raw_ostream &OS, const MCInst &MI) {\n  MI.print(OS);\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCINST_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SubtargetFeature.h", "content": "//===- llvm/MC/SubtargetFeature.h - CPU characteristics ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file Defines and manages user or tool specified CPU characteristics.\n/// The intent is to be able to package specific features that should or should\n/// not be used on a specific target processor.  A tool, such as llc, could, as\n/// as example, gather chip info from the command line, a long with features\n/// that should be used on that chip.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_SUBTARGETFEATURE_H\n#define LLVM_MC_SUBTARGETFEATURE_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <array>\n#include <bitset>\n#include <initializer_list>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\nclass Triple;\n\nconst unsigned MAX_SUBTARGET_WORDS = 4;\nconst unsigned MAX_SUBTARGET_FEATURES = MAX_SUBTARGET_WORDS * 64;\n\n/// Container class for subtarget features.\n/// This is a constexpr reimplementation of a subset of std::bitset. It would be\n/// nice to use std::bitset directly, but it doesn't support constant\n/// initialization.\nclass FeatureBitset {\n  static_assert((MAX_SUBTARGET_FEATURES % 64) == 0,\n                \"Should be a multiple of 64!\");\n  // This cannot be a std::array, operator[] is not constexpr until C++17.\n  uint64_t Bits[MAX_SUBTARGET_WORDS] = {};\n\nprotected:\n  constexpr FeatureBitset(const std::array<uint64_t, MAX_SUBTARGET_WORDS> &B) {\n    for (unsigned I = 0; I != B.size(); ++I)\n      Bits[I] = B[I];\n  }\n\npublic:\n  constexpr FeatureBitset() = default;\n  constexpr FeatureBitset(std::initializer_list<unsigned> Init) {\n    for (auto I : Init)\n      set(I);\n  }\n\n  FeatureBitset &set() {\n    std::fill(std::begin(Bits), std::end(Bits), -1ULL);\n    return *this;\n  }\n\n  constexpr FeatureBitset &set(unsigned I) {\n    // GCC <6.2 crashes if this is written in a single statement.\n    uint64_t NewBits = Bits[I / 64] | (uint64_t(1) << (I % 64));\n    Bits[I / 64] = NewBits;\n    return *this;\n  }\n\n  constexpr FeatureBitset &reset(unsigned I) {\n    // GCC <6.2 crashes if this is written in a single statement.\n    uint64_t NewBits = Bits[I / 64] & ~(uint64_t(1) << (I % 64));\n    Bits[I / 64] = NewBits;\n    return *this;\n  }\n\n  constexpr FeatureBitset &flip(unsigned I) {\n    // GCC <6.2 crashes if this is written in a single statement.\n    uint64_t NewBits = Bits[I / 64] ^ (uint64_t(1) << (I % 64));\n    Bits[I / 64] = NewBits;\n    return *this;\n  }\n\n  constexpr bool operator[](unsigned I) const {\n    uint64_t Mask = uint64_t(1) << (I % 64);\n    return (Bits[I / 64] & Mask) != 0;\n  }\n\n  constexpr bool test(unsigned I) const { return (*this)[I]; }\n\n  constexpr size_t size() const { return MAX_SUBTARGET_FEATURES; }\n\n  bool any() const {\n    return llvm::any_of(Bits, [](uint64_t I) { return I != 0; });\n  }\n  bool none() const { return !any(); }\n  size_t count() const {\n    size_t Count = 0;\n    for (auto B : Bits)\n      Count += countPopulation(B);\n    return Count;\n  }\n\n  constexpr FeatureBitset &operator^=(const FeatureBitset &RHS) {\n    for (unsigned I = 0, E = array_lengthof(Bits); I != E; ++I) {\n      Bits[I] ^= RHS.Bits[I];\n    }\n    return *this;\n  }\n  constexpr FeatureBitset operator^(const FeatureBitset &RHS) const {\n    FeatureBitset Result = *this;\n    Result ^= RHS;\n    return Result;\n  }\n\n  constexpr FeatureBitset &operator&=(const FeatureBitset &RHS) {\n    for (unsigned I = 0, E = array_lengthof(Bits); I != E; ++I) {\n      Bits[I] &= RHS.Bits[I];\n    }\n    return *this;\n  }\n  constexpr FeatureBitset operator&(const FeatureBitset &RHS) const {\n    FeatureBitset Result = *this;\n    Result &= RHS;\n    return Result;\n  }\n\n  constexpr FeatureBitset &operator|=(const FeatureBitset &RHS) {\n    for (unsigned I = 0, E = array_lengthof(Bits); I != E; ++I) {\n      Bits[I] |= RHS.Bits[I];\n    }\n    return *this;\n  }\n  constexpr FeatureBitset operator|(const FeatureBitset &RHS) const {\n    FeatureBitset Result = *this;\n    Result |= RHS;\n    return Result;\n  }\n\n  constexpr FeatureBitset operator~() const {\n    FeatureBitset Result = *this;\n    for (auto &B : Result.Bits)\n      B = ~B;\n    return Result;\n  }\n\n  bool operator==(const FeatureBitset &RHS) const {\n    return std::equal(std::begin(Bits), std::end(Bits), std::begin(RHS.Bits));\n  }\n\n  bool operator!=(const FeatureBitset &RHS) const { return !(*this == RHS); }\n\n  bool operator < (const FeatureBitset &Other) const {\n    for (unsigned I = 0, E = size(); I != E; ++I) {\n      bool LHS = test(I), RHS = Other.test(I);\n      if (LHS != RHS)\n        return LHS < RHS;\n    }\n    return false;\n  }\n};\n\n/// Class used to store the subtarget bits in the tables created by tablegen.\nclass FeatureBitArray : public FeatureBitset {\npublic:\n  constexpr FeatureBitArray(const std::array<uint64_t, MAX_SUBTARGET_WORDS> &B)\n      : FeatureBitset(B) {}\n\n  const FeatureBitset &getAsBitset() const { return *this; }\n};\n\n//===----------------------------------------------------------------------===//\n\n/// Manages the enabling and disabling of subtarget specific features.\n///\n/// Features are encoded as a string of the form\n///   \"+attr1,+attr2,-attr3,...,+attrN\"\n/// A comma separates each feature from the next (all lowercase.)\n/// Each of the remaining features is prefixed with + or - indicating whether\n/// that feature should be enabled or disabled contrary to the cpu\n/// specification.\nclass SubtargetFeatures {\n  std::vector<std::string> Features;    ///< Subtarget features as a vector\n\npublic:\n  explicit SubtargetFeatures(StringRef Initial = \"\");\n\n  /// Returns features as a string.\n  std::string getString() const;\n\n  /// Adds Features.\n  void AddFeature(StringRef String, bool Enable = true);\n\n  /// Returns the vector of individual subtarget features.\n  const std::vector<std::string> &getFeatures() const { return Features; }\n\n  /// Prints feature string.\n  void print(raw_ostream &OS) const;\n\n  // Dumps feature info.\n  void dump() const;\n\n  /// Adds the default features for the specified target triple.\n  void getDefaultSubtargetFeatures(const Triple& Triple);\n\n  /// Determine if a feature has a flag; '+' or '-'\n  static bool hasFlag(StringRef Feature) {\n    assert(!Feature.empty() && \"Empty string\");\n    // Get first character\n    char Ch = Feature[0];\n    // Check if first character is '+' or '-' flag\n    return Ch == '+' || Ch =='-';\n  }\n\n  /// Return string stripped of flag.\n  static StringRef StripFlag(StringRef Feature) {\n    return hasFlag(Feature) ? Feature.substr(1) : Feature;\n  }\n\n  /// Return true if enable flag; '+'.\n  static inline bool isEnabled(StringRef Feature) {\n    assert(!Feature.empty() && \"Empty string\");\n    // Get first character\n    char Ch = Feature[0];\n    // Check if first character is '+' for enabled\n    return Ch == '+';\n  }\n\n  /// Splits a string of comma separated items in to a vector of strings.\n  static void Split(std::vector<std::string> &V, StringRef S);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_SUBTARGETFEATURE_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "content": "//===- Binary.h - A generic binary file -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Binary class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_BINARY_H\n#define LLVM_OBJECT_BINARY_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <algorithm>\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\nclass LLVMContext;\nclass StringRef;\n\nnamespace object {\n\nclass Binary {\nprivate:\n  unsigned int TypeID;\n\nprotected:\n  MemoryBufferRef Data;\n\n  Binary(unsigned int Type, MemoryBufferRef Source);\n\n  enum {\n    ID_Archive,\n    ID_MachOUniversalBinary,\n    ID_COFFImportFile,\n    ID_IR,            // LLVM IR\n    ID_TapiUniversal, // Text-based Dynamic Library Stub file.\n    ID_TapiFile,      // Text-based Dynamic Library Stub file.\n\n    ID_Minidump,\n\n    ID_WinRes, // Windows resource (.res) file.\n\n    // Object and children.\n    ID_StartObjects,\n    ID_COFF,\n\n    ID_XCOFF32, // AIX XCOFF 32-bit\n    ID_XCOFF64, // AIX XCOFF 64-bit\n\n    ID_ELF32L, // ELF 32-bit, little endian\n    ID_ELF32B, // ELF 32-bit, big endian\n    ID_ELF64L, // ELF 64-bit, little endian\n    ID_ELF64B, // ELF 64-bit, big endian\n\n    ID_MachO32L, // MachO 32-bit, little endian\n    ID_MachO32B, // MachO 32-bit, big endian\n    ID_MachO64L, // MachO 64-bit, little endian\n    ID_MachO64B, // MachO 64-bit, big endian\n\n    ID_Wasm,\n\n    ID_EndObjects\n  };\n\n  static inline unsigned int getELFType(bool isLE, bool is64Bits) {\n    if (isLE)\n      return is64Bits ? ID_ELF64L : ID_ELF32L;\n    else\n      return is64Bits ? ID_ELF64B : ID_ELF32B;\n  }\n\n  static unsigned int getMachOType(bool isLE, bool is64Bits) {\n    if (isLE)\n      return is64Bits ? ID_MachO64L : ID_MachO32L;\n    else\n      return is64Bits ? ID_MachO64B : ID_MachO32B;\n  }\n\npublic:\n  Binary() = delete;\n  Binary(const Binary &other) = delete;\n  virtual ~Binary();\n\n  virtual Error initContent() { return Error::success(); };\n\n  StringRef getData() const;\n  StringRef getFileName() const;\n  MemoryBufferRef getMemoryBufferRef() const;\n\n  // Cast methods.\n  unsigned int getType() const { return TypeID; }\n\n  // Convenience methods\n  bool isObject() const {\n    return TypeID > ID_StartObjects && TypeID < ID_EndObjects;\n  }\n\n  bool isSymbolic() const {\n    return isIR() || isObject() || isCOFFImportFile() || isTapiFile();\n  }\n\n  bool isArchive() const { return TypeID == ID_Archive; }\n\n  bool isMachOUniversalBinary() const {\n    return TypeID == ID_MachOUniversalBinary;\n  }\n\n  bool isTapiUniversal() const { return TypeID == ID_TapiUniversal; }\n\n  bool isELF() const {\n    return TypeID >= ID_ELF32L && TypeID <= ID_ELF64B;\n  }\n\n  bool isMachO() const {\n    return TypeID >= ID_MachO32L && TypeID <= ID_MachO64B;\n  }\n\n  bool isCOFF() const {\n    return TypeID == ID_COFF;\n  }\n\n  bool isXCOFF() const { return TypeID == ID_XCOFF32 || TypeID == ID_XCOFF64; }\n\n  bool isWasm() const { return TypeID == ID_Wasm; }\n\n  bool isCOFFImportFile() const {\n    return TypeID == ID_COFFImportFile;\n  }\n\n  bool isIR() const {\n    return TypeID == ID_IR;\n  }\n\n  bool isMinidump() const { return TypeID == ID_Minidump; }\n\n  bool isTapiFile() const { return TypeID == ID_TapiFile; }\n\n  bool isLittleEndian() const {\n    return !(TypeID == ID_ELF32B || TypeID == ID_ELF64B ||\n             TypeID == ID_MachO32B || TypeID == ID_MachO64B);\n  }\n\n  bool isWinRes() const { return TypeID == ID_WinRes; }\n\n  Triple::ObjectFormatType getTripleObjectFormat() const {\n    if (isCOFF())\n      return Triple::COFF;\n    if (isMachO())\n      return Triple::MachO;\n    if (isELF())\n      return Triple::ELF;\n    return Triple::UnknownObjectFormat;\n  }\n\n  static Error checkOffset(MemoryBufferRef M, uintptr_t Addr,\n                           const uint64_t Size) {\n    if (Addr + Size < Addr || Addr + Size < Size ||\n        Addr + Size > reinterpret_cast<uintptr_t>(M.getBufferEnd()) ||\n        Addr < reinterpret_cast<uintptr_t>(M.getBufferStart())) {\n      return errorCodeToError(object_error::unexpected_eof);\n    }\n    return Error::success();\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Binary, LLVMBinaryRef)\n\n/// Create a Binary from Source, autodetecting the file type.\n///\n/// @param Source The data to create the Binary from.\nExpected<std::unique_ptr<Binary>> createBinary(MemoryBufferRef Source,\n                                               LLVMContext *Context = nullptr,\n                                               bool InitContent = true);\n\ntemplate <typename T> class OwningBinary {\n  std::unique_ptr<T> Bin;\n  std::unique_ptr<MemoryBuffer> Buf;\n\npublic:\n  OwningBinary();\n  OwningBinary(std::unique_ptr<T> Bin, std::unique_ptr<MemoryBuffer> Buf);\n  OwningBinary(OwningBinary<T>&& Other);\n  OwningBinary<T> &operator=(OwningBinary<T> &&Other);\n\n  std::pair<std::unique_ptr<T>, std::unique_ptr<MemoryBuffer>> takeBinary();\n\n  T* getBinary();\n  const T* getBinary() const;\n};\n\ntemplate <typename T>\nOwningBinary<T>::OwningBinary(std::unique_ptr<T> Bin,\n                              std::unique_ptr<MemoryBuffer> Buf)\n    : Bin(std::move(Bin)), Buf(std::move(Buf)) {}\n\ntemplate <typename T> OwningBinary<T>::OwningBinary() = default;\n\ntemplate <typename T>\nOwningBinary<T>::OwningBinary(OwningBinary &&Other)\n    : Bin(std::move(Other.Bin)), Buf(std::move(Other.Buf)) {}\n\ntemplate <typename T>\nOwningBinary<T> &OwningBinary<T>::operator=(OwningBinary &&Other) {\n  Bin = std::move(Other.Bin);\n  Buf = std::move(Other.Buf);\n  return *this;\n}\n\ntemplate <typename T>\nstd::pair<std::unique_ptr<T>, std::unique_ptr<MemoryBuffer>>\nOwningBinary<T>::takeBinary() {\n  return std::make_pair(std::move(Bin), std::move(Buf));\n}\n\ntemplate <typename T> T* OwningBinary<T>::getBinary() {\n  return Bin.get();\n}\n\ntemplate <typename T> const T* OwningBinary<T>::getBinary() const {\n  return Bin.get();\n}\n\nExpected<OwningBinary<Binary>> createBinary(StringRef Path,\n                                            LLVMContext *Context = nullptr,\n                                            bool InitContent = true);\n\n} // end namespace object\n\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_BINARY_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "content": "//===- ELFObjectFile.h - ELF object file implementation ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the ELFObjectFile template class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ELFOBJECTFILE_H\n#define LLVM_OBJECT_ELFOBJECTFILE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/ELF.h\"\n#include \"llvm/Object/ELFTypes.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/ARMAttributeParser.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ELFAttributes.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cassert>\n#include <cstdint>\n#include <system_error>\n\nnamespace llvm {\nnamespace object {\n\nconstexpr int NumElfSymbolTypes = 16;\nextern const llvm::EnumEntry<unsigned> ElfSymbolTypes[NumElfSymbolTypes];\n\nclass elf_symbol_iterator;\n\nclass ELFObjectFileBase : public ObjectFile {\n  friend class ELFRelocationRef;\n  friend class ELFSectionRef;\n  friend class ELFSymbolRef;\n\n  SubtargetFeatures getMIPSFeatures() const;\n  SubtargetFeatures getARMFeatures() const;\n  SubtargetFeatures getRISCVFeatures() const;\n\n  StringRef getAMDGPUCPUName() const;\n\nprotected:\n  ELFObjectFileBase(unsigned int Type, MemoryBufferRef Source);\n\n  virtual uint64_t getSymbolSize(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolBinding(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolOther(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolELFType(DataRefImpl Symb) const = 0;\n\n  virtual uint32_t getSectionType(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionFlags(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionOffset(DataRefImpl Sec) const = 0;\n\n  virtual Expected<int64_t> getRelocationAddend(DataRefImpl Rel) const = 0;\n  virtual Error getBuildAttributes(ELFAttributeParser &Attributes) const = 0;\n\npublic:\n  using elf_symbol_iterator_range = iterator_range<elf_symbol_iterator>;\n\n  virtual elf_symbol_iterator_range getDynamicSymbolIterators() const = 0;\n\n  /// Returns platform-specific object flags, if any.\n  virtual unsigned getPlatformFlags() const = 0;\n\n  elf_symbol_iterator_range symbols() const;\n\n  static bool classof(const Binary *v) { return v->isELF(); }\n\n  SubtargetFeatures getFeatures() const override;\n\n  Optional<StringRef> tryGetCPUName() const override;\n\n  void setARMSubArch(Triple &TheTriple) const override;\n\n  virtual uint16_t getEType() const = 0;\n\n  virtual uint16_t getEMachine() const = 0;\n\n  std::vector<std::pair<Optional<DataRefImpl>, uint64_t>>\n  getPltAddresses() const;\n};\n\nclass ELFSectionRef : public SectionRef {\npublic:\n  ELFSectionRef(const SectionRef &B) : SectionRef(B) {\n    assert(isa<ELFObjectFileBase>(SectionRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(SectionRef::getObject());\n  }\n\n  uint32_t getType() const {\n    return getObject()->getSectionType(getRawDataRefImpl());\n  }\n\n  uint64_t getFlags() const {\n    return getObject()->getSectionFlags(getRawDataRefImpl());\n  }\n\n  uint64_t getOffset() const {\n    return getObject()->getSectionOffset(getRawDataRefImpl());\n  }\n};\n\nclass elf_section_iterator : public section_iterator {\npublic:\n  elf_section_iterator(const section_iterator &B) : section_iterator(B) {\n    assert(isa<ELFObjectFileBase>(B->getObject()));\n  }\n\n  const ELFSectionRef *operator->() const {\n    return static_cast<const ELFSectionRef *>(section_iterator::operator->());\n  }\n\n  const ELFSectionRef &operator*() const {\n    return static_cast<const ELFSectionRef &>(section_iterator::operator*());\n  }\n};\n\nclass ELFSymbolRef : public SymbolRef {\npublic:\n  ELFSymbolRef(const SymbolRef &B) : SymbolRef(B) {\n    assert(isa<ELFObjectFileBase>(SymbolRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(BasicSymbolRef::getObject());\n  }\n\n  uint64_t getSize() const {\n    return getObject()->getSymbolSize(getRawDataRefImpl());\n  }\n\n  uint8_t getBinding() const {\n    return getObject()->getSymbolBinding(getRawDataRefImpl());\n  }\n\n  uint8_t getOther() const {\n    return getObject()->getSymbolOther(getRawDataRefImpl());\n  }\n\n  uint8_t getELFType() const {\n    return getObject()->getSymbolELFType(getRawDataRefImpl());\n  }\n\n  StringRef getELFTypeName() const {\n    uint8_t Type = getELFType();\n    for (auto &EE : ElfSymbolTypes) {\n      if (EE.Value == Type) {\n        return EE.AltName;\n      }\n    }\n    return \"\";\n  }\n};\n\nclass elf_symbol_iterator : public symbol_iterator {\npublic:\n  elf_symbol_iterator(const basic_symbol_iterator &B)\n      : symbol_iterator(SymbolRef(B->getRawDataRefImpl(),\n                                  cast<ELFObjectFileBase>(B->getObject()))) {}\n\n  const ELFSymbolRef *operator->() const {\n    return static_cast<const ELFSymbolRef *>(symbol_iterator::operator->());\n  }\n\n  const ELFSymbolRef &operator*() const {\n    return static_cast<const ELFSymbolRef &>(symbol_iterator::operator*());\n  }\n};\n\nclass ELFRelocationRef : public RelocationRef {\npublic:\n  ELFRelocationRef(const RelocationRef &B) : RelocationRef(B) {\n    assert(isa<ELFObjectFileBase>(RelocationRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(RelocationRef::getObject());\n  }\n\n  Expected<int64_t> getAddend() const {\n    return getObject()->getRelocationAddend(getRawDataRefImpl());\n  }\n};\n\nclass elf_relocation_iterator : public relocation_iterator {\npublic:\n  elf_relocation_iterator(const relocation_iterator &B)\n      : relocation_iterator(RelocationRef(\n            B->getRawDataRefImpl(), cast<ELFObjectFileBase>(B->getObject()))) {}\n\n  const ELFRelocationRef *operator->() const {\n    return static_cast<const ELFRelocationRef *>(\n        relocation_iterator::operator->());\n  }\n\n  const ELFRelocationRef &operator*() const {\n    return static_cast<const ELFRelocationRef &>(\n        relocation_iterator::operator*());\n  }\n};\n\ninline ELFObjectFileBase::elf_symbol_iterator_range\nELFObjectFileBase::symbols() const {\n  return elf_symbol_iterator_range(symbol_begin(), symbol_end());\n}\n\ntemplate <class ELFT> class ELFObjectFile : public ELFObjectFileBase {\n  uint16_t getEMachine() const override;\n  uint16_t getEType() const override;\n  uint64_t getSymbolSize(DataRefImpl Sym) const override;\n\npublic:\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  SectionRef toSectionRef(const Elf_Shdr *Sec) const {\n    return SectionRef(toDRI(Sec), this);\n  }\n\n  ELFSymbolRef toSymbolRef(const Elf_Shdr *SymTable, unsigned SymbolNum) const {\n    return ELFSymbolRef({toDRI(SymTable, SymbolNum), this});\n  }\n\n  bool IsContentValid() const { return ContentValid; }\n\nprivate:\n  ELFObjectFile(MemoryBufferRef Object, ELFFile<ELFT> EF,\n                const Elf_Shdr *DotDynSymSec, const Elf_Shdr *DotSymtabSec,\n                const Elf_Shdr *DotSymtabShndxSec);\n\n  bool ContentValid = false;\n\nprotected:\n  ELFFile<ELFT> EF;\n\n  const Elf_Shdr *DotDynSymSec = nullptr; // Dynamic symbol table section.\n  const Elf_Shdr *DotSymtabSec = nullptr; // Symbol table section.\n  const Elf_Shdr *DotSymtabShndxSec = nullptr; // SHT_SYMTAB_SHNDX section.\n\n  Error initContent() override;\n\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n  uint8_t getSymbolBinding(DataRefImpl Symb) const override;\n  uint8_t getSymbolOther(DataRefImpl Symb) const override;\n  uint8_t getSymbolELFType(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(const Elf_Sym *Symb,\n                                              const Elf_Shdr *SymTab) const;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  bool isBerkeleyText(DataRefImpl Sec) const override;\n  bool isBerkeleyData(DataRefImpl Sec) const override;\n  bool isDebugSection(StringRef SectionName) const override;\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n  std::vector<SectionRef> dynamic_relocation_sections() const override;\n  Expected<section_iterator>\n  getRelocatedSection(DataRefImpl Sec) const override;\n\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n\n  uint32_t getSectionType(DataRefImpl Sec) const override;\n  uint64_t getSectionFlags(DataRefImpl Sec) const override;\n  uint64_t getSectionOffset(DataRefImpl Sec) const override;\n  StringRef getRelocationTypeName(uint32_t Type) const;\n\n  DataRefImpl toDRI(const Elf_Shdr *SymTable, unsigned SymbolNum) const {\n    DataRefImpl DRI;\n    if (!SymTable) {\n      DRI.d.a = 0;\n      DRI.d.b = 0;\n      return DRI;\n    }\n    assert(SymTable->sh_type == ELF::SHT_SYMTAB ||\n           SymTable->sh_type == ELF::SHT_DYNSYM);\n\n    auto SectionsOrErr = EF.sections();\n    if (!SectionsOrErr) {\n      DRI.d.a = 0;\n      DRI.d.b = 0;\n      return DRI;\n    }\n    uintptr_t SHT = reinterpret_cast<uintptr_t>((*SectionsOrErr).begin());\n    unsigned SymTableIndex =\n        (reinterpret_cast<uintptr_t>(SymTable) - SHT) / sizeof(Elf_Shdr);\n\n    DRI.d.a = SymTableIndex;\n    DRI.d.b = SymbolNum;\n    return DRI;\n  }\n\n  const Elf_Shdr *toELFShdrIter(DataRefImpl Sec) const {\n    return reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  }\n\n  DataRefImpl toDRI(const Elf_Shdr *Sec) const {\n    DataRefImpl DRI;\n    DRI.p = reinterpret_cast<uintptr_t>(Sec);\n    return DRI;\n  }\n\n  DataRefImpl toDRI(const Elf_Dyn *Dyn) const {\n    DataRefImpl DRI;\n    DRI.p = reinterpret_cast<uintptr_t>(Dyn);\n    return DRI;\n  }\n\n  bool isExportedToOtherDSO(const Elf_Sym *ESym) const {\n    unsigned char Binding = ESym->getBinding();\n    unsigned char Visibility = ESym->getVisibility();\n\n    // A symbol is exported if its binding is either GLOBAL or WEAK, and its\n    // visibility is either DEFAULT or PROTECTED. All other symbols are not\n    // exported.\n    return (\n        (Binding == ELF::STB_GLOBAL || Binding == ELF::STB_WEAK ||\n         Binding == ELF::STB_GNU_UNIQUE) &&\n        (Visibility == ELF::STV_DEFAULT || Visibility == ELF::STV_PROTECTED));\n  }\n\n  Error getBuildAttributes(ELFAttributeParser &Attributes) const override {\n    auto SectionsOrErr = EF.sections();\n    if (!SectionsOrErr)\n      return SectionsOrErr.takeError();\n\n    for (const Elf_Shdr &Sec : *SectionsOrErr) {\n      if (Sec.sh_type == ELF::SHT_ARM_ATTRIBUTES ||\n          Sec.sh_type == ELF::SHT_RISCV_ATTRIBUTES) {\n        auto ErrorOrContents = EF.getSectionContents(Sec);\n        if (!ErrorOrContents)\n          return ErrorOrContents.takeError();\n\n        auto Contents = ErrorOrContents.get();\n        if (Contents[0] != ELFAttrs::Format_Version || Contents.size() == 1)\n          return Error::success();\n\n        if (Error E = Attributes.parse(Contents, ELFT::TargetEndianness))\n          return E;\n        break;\n      }\n    }\n    return Error::success();\n  }\n\n  // This flag is used for classof, to distinguish ELFObjectFile from\n  // its subclass. If more subclasses will be created, this flag will\n  // have to become an enum.\n  bool isDyldELFObject;\n\npublic:\n  ELFObjectFile(ELFObjectFile<ELFT> &&Other);\n  static Expected<ELFObjectFile<ELFT>> create(MemoryBufferRef Object,\n                                              bool InitContent = true);\n\n  const Elf_Rel *getRel(DataRefImpl Rel) const;\n  const Elf_Rela *getRela(DataRefImpl Rela) const;\n\n  Expected<const Elf_Sym *> getSymbol(DataRefImpl Sym) const {\n    return EF.template getEntry<Elf_Sym>(Sym.d.a, Sym.d.b);\n  }\n\n  /// Get the relocation section that contains \\a Rel.\n  const Elf_Shdr *getRelSection(DataRefImpl Rel) const {\n    auto RelSecOrErr = EF.getSection(Rel.d.a);\n    if (!RelSecOrErr)\n      report_fatal_error(errorToErrorCode(RelSecOrErr.takeError()).message());\n    return *RelSecOrErr;\n  }\n\n  const Elf_Shdr *getSection(DataRefImpl Sec) const {\n    return reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  }\n\n  basic_symbol_iterator symbol_begin() const override;\n  basic_symbol_iterator symbol_end() const override;\n\n  elf_symbol_iterator dynamic_symbol_begin() const;\n  elf_symbol_iterator dynamic_symbol_end() const;\n\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n\n  Expected<int64_t> getRelocationAddend(DataRefImpl Rel) const override;\n\n  uint8_t getBytesInAddress() const override;\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  Expected<uint64_t> getStartAddress() const override;\n\n  unsigned getPlatformFlags() const override { return EF.getHeader().e_flags; }\n\n  const ELFFile<ELFT> &getELFFile() const { return EF; }\n\n  bool isDyldType() const { return isDyldELFObject; }\n  static bool classof(const Binary *v) {\n    return v->getType() == getELFType(ELFT::TargetEndianness == support::little,\n                                      ELFT::Is64Bits);\n  }\n\n  elf_symbol_iterator_range getDynamicSymbolIterators() const override;\n\n  bool isRelocatableObject() const override;\n};\n\nusing ELF32LEObjectFile = ELFObjectFile<ELF32LE>;\nusing ELF64LEObjectFile = ELFObjectFile<ELF64LE>;\nusing ELF32BEObjectFile = ELFObjectFile<ELF32BE>;\nusing ELF64BEObjectFile = ELFObjectFile<ELF64BE>;\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveSymbolNext(DataRefImpl &Sym) const {\n  ++Sym.d.b;\n}\n\ntemplate <class ELFT> Error ELFObjectFile<ELFT>::initContent() {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    switch (Sec.sh_type) {\n    case ELF::SHT_DYNSYM: {\n      if (!DotDynSymSec)\n        DotDynSymSec = &Sec;\n      break;\n    }\n    case ELF::SHT_SYMTAB: {\n      if (!DotSymtabSec)\n        DotSymtabSec = &Sec;\n      break;\n    }\n    case ELF::SHT_SYMTAB_SHNDX: {\n      if (!DotSymtabShndxSec)\n        DotSymtabShndxSec = &Sec;\n      break;\n    }\n    }\n  }\n\n  ContentValid = true;\n  return Error::success();\n}\n\ntemplate <class ELFT>\nExpected<StringRef> ELFObjectFile<ELFT>::getSymbolName(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n  auto SymTabOrErr = EF.getSection(Sym.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n  const Elf_Shdr *SymTableSec = *SymTabOrErr;\n  auto StrTabOrErr = EF.getSection(SymTableSec->sh_link);\n  if (!StrTabOrErr)\n    return StrTabOrErr.takeError();\n  const Elf_Shdr *StringTableSec = *StrTabOrErr;\n  auto SymStrTabOrErr = EF.getStringTable(*StringTableSec);\n  if (!SymStrTabOrErr)\n    return SymStrTabOrErr.takeError();\n  Expected<StringRef> Name = (*SymOrErr)->getName(*SymStrTabOrErr);\n  if (Name && !Name->empty())\n    return Name;\n\n  // If the symbol name is empty use the section name.\n  if ((*SymOrErr)->getType() == ELF::STT_SECTION) {\n    if (Expected<section_iterator> SecOrErr = getSymbolSection(Sym)) {\n      consumeError(Name.takeError());\n      return (*SecOrErr)->getName();\n    }\n  }\n  return Name;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionFlags(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags;\n}\n\ntemplate <class ELFT>\nuint32_t ELFObjectFile<ELFT>::getSectionType(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_type;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionOffset(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_offset;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSymbolValueImpl(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n\n  uint64_t Ret = (*SymOrErr)->st_value;\n  if ((*SymOrErr)->st_shndx == ELF::SHN_ABS)\n    return Ret;\n\n  const Elf_Ehdr &Header = EF.getHeader();\n  // Clear the ARM/Thumb or microMIPS indicator flag.\n  if ((Header.e_machine == ELF::EM_ARM || Header.e_machine == ELF::EM_MIPS) &&\n      (*SymOrErr)->getType() == ELF::STT_FUNC)\n    Ret &= ~1;\n\n  return Ret;\n}\n\ntemplate <class ELFT>\nExpected<uint64_t>\nELFObjectFile<ELFT>::getSymbolAddress(DataRefImpl Symb) const {\n  Expected<uint64_t> SymbolValueOrErr = getSymbolValue(Symb);\n  if (!SymbolValueOrErr)\n    // TODO: Test this error.\n    return SymbolValueOrErr.takeError();\n\n  uint64_t Result = *SymbolValueOrErr;\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  switch ((*SymOrErr)->st_shndx) {\n  case ELF::SHN_COMMON:\n  case ELF::SHN_UNDEF:\n  case ELF::SHN_ABS:\n    return Result;\n  }\n\n  auto SymTabOrErr = EF.getSection(Symb.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n\n  if (EF.getHeader().e_type == ELF::ET_REL) {\n    ArrayRef<Elf_Word> ShndxTable;\n    if (DotSymtabShndxSec) {\n      // TODO: Test this error.\n      if (Expected<ArrayRef<Elf_Word>> ShndxTableOrErr =\n              EF.getSHNDXTable(*DotSymtabShndxSec))\n        ShndxTable = *ShndxTableOrErr;\n      else\n        return ShndxTableOrErr.takeError();\n    }\n\n    Expected<const Elf_Shdr *> SectionOrErr =\n        EF.getSection(**SymOrErr, *SymTabOrErr, ShndxTable);\n    if (!SectionOrErr)\n      return SectionOrErr.takeError();\n    const Elf_Shdr *Section = *SectionOrErr;\n    if (Section)\n      Result += Section->sh_addr;\n  }\n\n  return Result;\n}\n\ntemplate <class ELFT>\nuint32_t ELFObjectFile<ELFT>::getSymbolAlignment(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  if ((*SymOrErr)->st_shndx == ELF::SHN_COMMON)\n    return (*SymOrErr)->st_value;\n  return 0;\n}\n\ntemplate <class ELFT>\nuint16_t ELFObjectFile<ELFT>::getEMachine() const {\n  return EF.getHeader().e_machine;\n}\n\ntemplate <class ELFT> uint16_t ELFObjectFile<ELFT>::getEType() const {\n  return EF.getHeader().e_type;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSymbolSize(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->st_size;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getCommonSymbolSizeImpl(DataRefImpl Symb) const {\n  return getSymbolSize(Symb);\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolBinding(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->getBinding();\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolOther(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->st_other;\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolELFType(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->getType();\n}\n\ntemplate <class ELFT>\nExpected<SymbolRef::Type>\nELFObjectFile<ELFT>::getSymbolType(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  switch ((*SymOrErr)->getType()) {\n  case ELF::STT_NOTYPE:\n    return SymbolRef::ST_Unknown;\n  case ELF::STT_SECTION:\n    return SymbolRef::ST_Debug;\n  case ELF::STT_FILE:\n    return SymbolRef::ST_File;\n  case ELF::STT_FUNC:\n    return SymbolRef::ST_Function;\n  case ELF::STT_OBJECT:\n  case ELF::STT_COMMON:\n    return SymbolRef::ST_Data;\n  case ELF::STT_TLS:\n  default:\n    return SymbolRef::ST_Other;\n  }\n}\n\ntemplate <class ELFT>\nExpected<uint32_t> ELFObjectFile<ELFT>::getSymbolFlags(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  const Elf_Sym *ESym = *SymOrErr;\n  uint32_t Result = SymbolRef::SF_None;\n\n  if (ESym->getBinding() != ELF::STB_LOCAL)\n    Result |= SymbolRef::SF_Global;\n\n  if (ESym->getBinding() == ELF::STB_WEAK)\n    Result |= SymbolRef::SF_Weak;\n\n  if (ESym->st_shndx == ELF::SHN_ABS)\n    Result |= SymbolRef::SF_Absolute;\n\n  if (ESym->getType() == ELF::STT_FILE || ESym->getType() == ELF::STT_SECTION)\n    Result |= SymbolRef::SF_FormatSpecific;\n\n  if (Expected<typename ELFT::SymRange> SymbolsOrErr =\n          EF.symbols(DotSymtabSec)) {\n    // Set the SF_FormatSpecific flag for the 0-index null symbol.\n    if (ESym == SymbolsOrErr->begin())\n      Result |= SymbolRef::SF_FormatSpecific;\n  } else\n    // TODO: Test this error.\n    return SymbolsOrErr.takeError();\n\n  if (Expected<typename ELFT::SymRange> SymbolsOrErr =\n          EF.symbols(DotDynSymSec)) {\n    // Set the SF_FormatSpecific flag for the 0-index null symbol.\n    if (ESym == SymbolsOrErr->begin())\n      Result |= SymbolRef::SF_FormatSpecific;\n  } else\n    // TODO: Test this error.\n    return SymbolsOrErr.takeError();\n\n  if (EF.getHeader().e_machine == ELF::EM_ARM) {\n    if (Expected<StringRef> NameOrErr = getSymbolName(Sym)) {\n      StringRef Name = *NameOrErr;\n      if (Name.startswith(\"$d\") || Name.startswith(\"$t\") ||\n          Name.startswith(\"$a\"))\n        Result |= SymbolRef::SF_FormatSpecific;\n    } else {\n      // TODO: Actually report errors helpfully.\n      consumeError(NameOrErr.takeError());\n    }\n    if (ESym->getType() == ELF::STT_FUNC && (ESym->st_value & 1) == 1)\n      Result |= SymbolRef::SF_Thumb;\n  }\n\n  if (ESym->st_shndx == ELF::SHN_UNDEF)\n    Result |= SymbolRef::SF_Undefined;\n\n  if (ESym->getType() == ELF::STT_COMMON || ESym->st_shndx == ELF::SHN_COMMON)\n    Result |= SymbolRef::SF_Common;\n\n  if (isExportedToOtherDSO(ESym))\n    Result |= SymbolRef::SF_Exported;\n\n  if (ESym->getVisibility() == ELF::STV_HIDDEN)\n    Result |= SymbolRef::SF_Hidden;\n\n  return Result;\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getSymbolSection(const Elf_Sym *ESym,\n                                      const Elf_Shdr *SymTab) const {\n  ArrayRef<Elf_Word> ShndxTable;\n  if (DotSymtabShndxSec) {\n    // TODO: Test this error.\n    Expected<ArrayRef<Elf_Word>> ShndxTableOrErr =\n        EF.getSHNDXTable(*DotSymtabShndxSec);\n    if (!ShndxTableOrErr)\n      return ShndxTableOrErr.takeError();\n    ShndxTable = *ShndxTableOrErr;\n  }\n\n  auto ESecOrErr = EF.getSection(*ESym, SymTab, ShndxTable);\n  if (!ESecOrErr)\n    return ESecOrErr.takeError();\n\n  const Elf_Shdr *ESec = *ESecOrErr;\n  if (!ESec)\n    return section_end();\n\n  DataRefImpl Sec;\n  Sec.p = reinterpret_cast<intptr_t>(ESec);\n  return section_iterator(SectionRef(Sec, this));\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getSymbolSection(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  auto SymTabOrErr = EF.getSection(Symb.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n  return getSymbolSection(*SymOrErr, *SymTabOrErr);\n}\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveSectionNext(DataRefImpl &Sec) const {\n  const Elf_Shdr *ESec = getSection(Sec);\n  Sec = toDRI(++ESec);\n}\n\ntemplate <class ELFT>\nExpected<StringRef> ELFObjectFile<ELFT>::getSectionName(DataRefImpl Sec) const {\n  return EF.getSectionName(*getSection(Sec));\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionAddress(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_addr;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionIndex(DataRefImpl Sec) const {\n  auto SectionsOrErr = EF.sections();\n  handleAllErrors(std::move(SectionsOrErr.takeError()),\n                  [](const ErrorInfoBase &) {\n                    llvm_unreachable(\"unable to get section index\");\n                  });\n  const Elf_Shdr *First = SectionsOrErr->begin();\n  return getSection(Sec) - First;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionSize(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_size;\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<uint8_t>>\nELFObjectFile<ELFT>::getSectionContents(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  if (EShdr->sh_type == ELF::SHT_NOBITS)\n    return makeArrayRef((const uint8_t *)base(), 0);\n  if (Error E =\n          checkOffset(getMemoryBufferRef(),\n                      (uintptr_t)base() + EShdr->sh_offset, EShdr->sh_size))\n    return std::move(E);\n  return makeArrayRef((const uint8_t *)base() + EShdr->sh_offset,\n                      EShdr->sh_size);\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionAlignment(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_addralign;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionCompressed(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_COMPRESSED;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionText(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_EXECINSTR;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionData(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return EShdr->sh_type == ELF::SHT_PROGBITS &&\n         EShdr->sh_flags & ELF::SHF_ALLOC &&\n         !(EShdr->sh_flags & ELF::SHF_EXECINSTR);\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionBSS(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return EShdr->sh_flags & (ELF::SHF_ALLOC | ELF::SHF_WRITE) &&\n         EShdr->sh_type == ELF::SHT_NOBITS;\n}\n\ntemplate <class ELFT>\nstd::vector<SectionRef>\nELFObjectFile<ELFT>::dynamic_relocation_sections() const {\n  std::vector<SectionRef> Res;\n  std::vector<uintptr_t> Offsets;\n\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return Res;\n\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    if (Sec.sh_type != ELF::SHT_DYNAMIC)\n      continue;\n    Elf_Dyn *Dynamic =\n        reinterpret_cast<Elf_Dyn *>((uintptr_t)base() + Sec.sh_offset);\n    for (; Dynamic->d_tag != ELF::DT_NULL; Dynamic++) {\n      if (Dynamic->d_tag == ELF::DT_REL || Dynamic->d_tag == ELF::DT_RELA ||\n          Dynamic->d_tag == ELF::DT_JMPREL) {\n        Offsets.push_back(Dynamic->d_un.d_val);\n      }\n    }\n  }\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    if (is_contained(Offsets, Sec.sh_addr))\n      Res.emplace_back(toDRI(&Sec), this);\n  }\n  return Res;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionVirtual(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_type == ELF::SHT_NOBITS;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isBerkeleyText(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_ALLOC &&\n         (getSection(Sec)->sh_flags & ELF::SHF_EXECINSTR ||\n          !(getSection(Sec)->sh_flags & ELF::SHF_WRITE));\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isBerkeleyData(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return !isBerkeleyText(Sec) && EShdr->sh_type != ELF::SHT_NOBITS &&\n         EShdr->sh_flags & ELF::SHF_ALLOC;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isDebugSection(StringRef SectionName) const {\n  return SectionName.startswith(\".debug\") ||\n         SectionName.startswith(\".zdebug\") || SectionName == \".gdb_index\";\n}\n\ntemplate <class ELFT>\nrelocation_iterator\nELFObjectFile<ELFT>::section_rel_begin(DataRefImpl Sec) const {\n  DataRefImpl RelData;\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return relocation_iterator(RelocationRef());\n  uintptr_t SHT = reinterpret_cast<uintptr_t>((*SectionsOrErr).begin());\n  RelData.d.a = (Sec.p - SHT) / EF.getHeader().e_shentsize;\n  RelData.d.b = 0;\n  return relocation_iterator(RelocationRef(RelData, this));\n}\n\ntemplate <class ELFT>\nrelocation_iterator\nELFObjectFile<ELFT>::section_rel_end(DataRefImpl Sec) const {\n  const Elf_Shdr *S = reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  relocation_iterator Begin = section_rel_begin(Sec);\n  if (S->sh_type != ELF::SHT_RELA && S->sh_type != ELF::SHT_REL)\n    return Begin;\n  DataRefImpl RelData = Begin->getRawDataRefImpl();\n  const Elf_Shdr *RelSec = getRelSection(RelData);\n\n  // Error check sh_link here so that getRelocationSymbol can just use it.\n  auto SymSecOrErr = EF.getSection(RelSec->sh_link);\n  if (!SymSecOrErr)\n    report_fatal_error(errorToErrorCode(SymSecOrErr.takeError()).message());\n\n  RelData.d.b += S->sh_size / S->sh_entsize;\n  return relocation_iterator(RelocationRef(RelData, this));\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getRelocatedSection(DataRefImpl Sec) const {\n  if (EF.getHeader().e_type != ELF::ET_REL)\n    return section_end();\n\n  const Elf_Shdr *EShdr = getSection(Sec);\n  uintX_t Type = EShdr->sh_type;\n  if (Type != ELF::SHT_REL && Type != ELF::SHT_RELA)\n    return section_end();\n\n  Expected<const Elf_Shdr *> SecOrErr = EF.getSection(EShdr->sh_info);\n  if (!SecOrErr)\n    return SecOrErr.takeError();\n  return section_iterator(SectionRef(toDRI(*SecOrErr), this));\n}\n\n// Relocations\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveRelocationNext(DataRefImpl &Rel) const {\n  ++Rel.d.b;\n}\n\ntemplate <class ELFT>\nsymbol_iterator\nELFObjectFile<ELFT>::getRelocationSymbol(DataRefImpl Rel) const {\n  uint32_t symbolIdx;\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    symbolIdx = getRel(Rel)->getSymbol(EF.isMips64EL());\n  else\n    symbolIdx = getRela(Rel)->getSymbol(EF.isMips64EL());\n  if (!symbolIdx)\n    return symbol_end();\n\n  // FIXME: error check symbolIdx\n  DataRefImpl SymbolData;\n  SymbolData.d.a = sec->sh_link;\n  SymbolData.d.b = symbolIdx;\n  return symbol_iterator(SymbolRef(SymbolData, this));\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getRelocationOffset(DataRefImpl Rel) const {\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    return getRel(Rel)->r_offset;\n\n  return getRela(Rel)->r_offset;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getRelocationType(DataRefImpl Rel) const {\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    return getRel(Rel)->getType(EF.isMips64EL());\n  else\n    return getRela(Rel)->getType(EF.isMips64EL());\n}\n\ntemplate <class ELFT>\nStringRef ELFObjectFile<ELFT>::getRelocationTypeName(uint32_t Type) const {\n  return getELFRelocationTypeName(EF.getHeader().e_machine, Type);\n}\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::getRelocationTypeName(\n    DataRefImpl Rel, SmallVectorImpl<char> &Result) const {\n  uint32_t type = getRelocationType(Rel);\n  EF.getRelocationTypeName(type, Result);\n}\n\ntemplate <class ELFT>\nExpected<int64_t>\nELFObjectFile<ELFT>::getRelocationAddend(DataRefImpl Rel) const {\n  if (getRelSection(Rel)->sh_type != ELF::SHT_RELA)\n    return createError(\"Section is not SHT_RELA\");\n  return (int64_t)getRela(Rel)->r_addend;\n}\n\ntemplate <class ELFT>\nconst typename ELFObjectFile<ELFT>::Elf_Rel *\nELFObjectFile<ELFT>::getRel(DataRefImpl Rel) const {\n  assert(getRelSection(Rel)->sh_type == ELF::SHT_REL);\n  auto Ret = EF.template getEntry<Elf_Rel>(Rel.d.a, Rel.d.b);\n  if (!Ret)\n    report_fatal_error(errorToErrorCode(Ret.takeError()).message());\n  return *Ret;\n}\n\ntemplate <class ELFT>\nconst typename ELFObjectFile<ELFT>::Elf_Rela *\nELFObjectFile<ELFT>::getRela(DataRefImpl Rela) const {\n  assert(getRelSection(Rela)->sh_type == ELF::SHT_RELA);\n  auto Ret = EF.template getEntry<Elf_Rela>(Rela.d.a, Rela.d.b);\n  if (!Ret)\n    report_fatal_error(errorToErrorCode(Ret.takeError()).message());\n  return *Ret;\n}\n\ntemplate <class ELFT>\nExpected<ELFObjectFile<ELFT>>\nELFObjectFile<ELFT>::create(MemoryBufferRef Object, bool InitContent) {\n  auto EFOrErr = ELFFile<ELFT>::create(Object.getBuffer());\n  if (Error E = EFOrErr.takeError())\n    return std::move(E);\n\n  ELFObjectFile<ELFT> Obj = {Object, std::move(*EFOrErr), nullptr, nullptr,\n                             nullptr};\n  if (InitContent)\n    if (Error E = Obj.initContent())\n      return std::move(E);\n  return std::move(Obj);\n}\n\ntemplate <class ELFT>\nELFObjectFile<ELFT>::ELFObjectFile(MemoryBufferRef Object, ELFFile<ELFT> EF,\n                                   const Elf_Shdr *DotDynSymSec,\n                                   const Elf_Shdr *DotSymtabSec,\n                                   const Elf_Shdr *DotSymtabShndx)\n    : ELFObjectFileBase(\n          getELFType(ELFT::TargetEndianness == support::little, ELFT::Is64Bits),\n          Object),\n      EF(EF), DotDynSymSec(DotDynSymSec), DotSymtabSec(DotSymtabSec),\n      DotSymtabShndxSec(DotSymtabShndx) {}\n\ntemplate <class ELFT>\nELFObjectFile<ELFT>::ELFObjectFile(ELFObjectFile<ELFT> &&Other)\n    : ELFObjectFile(Other.Data, Other.EF, Other.DotDynSymSec,\n                    Other.DotSymtabSec, Other.DotSymtabShndxSec) {}\n\ntemplate <class ELFT>\nbasic_symbol_iterator ELFObjectFile<ELFT>::symbol_begin() const {\n  DataRefImpl Sym =\n      toDRI(DotSymtabSec,\n            DotSymtabSec && DotSymtabSec->sh_size >= sizeof(Elf_Sym) ? 1 : 0);\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nbasic_symbol_iterator ELFObjectFile<ELFT>::symbol_end() const {\n  const Elf_Shdr *SymTab = DotSymtabSec;\n  if (!SymTab)\n    return symbol_begin();\n  DataRefImpl Sym = toDRI(SymTab, SymTab->sh_size / sizeof(Elf_Sym));\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nelf_symbol_iterator ELFObjectFile<ELFT>::dynamic_symbol_begin() const {\n  if (!DotDynSymSec || DotDynSymSec->sh_size < sizeof(Elf_Sym))\n    // Ignore errors here where the dynsym is empty or sh_size less than the\n    // size of one symbol. These should be handled elsewhere.\n    return symbol_iterator(SymbolRef(toDRI(DotDynSymSec, 0), this));\n  // Skip 0-index NULL symbol.\n  return symbol_iterator(SymbolRef(toDRI(DotDynSymSec, 1), this));\n}\n\ntemplate <class ELFT>\nelf_symbol_iterator ELFObjectFile<ELFT>::dynamic_symbol_end() const {\n  const Elf_Shdr *SymTab = DotDynSymSec;\n  if (!SymTab)\n    return dynamic_symbol_begin();\n  DataRefImpl Sym = toDRI(SymTab, SymTab->sh_size / sizeof(Elf_Sym));\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nsection_iterator ELFObjectFile<ELFT>::section_begin() const {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return section_iterator(SectionRef());\n  return section_iterator(SectionRef(toDRI((*SectionsOrErr).begin()), this));\n}\n\ntemplate <class ELFT>\nsection_iterator ELFObjectFile<ELFT>::section_end() const {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return section_iterator(SectionRef());\n  return section_iterator(SectionRef(toDRI((*SectionsOrErr).end()), this));\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getBytesInAddress() const {\n  return ELFT::Is64Bits ? 8 : 4;\n}\n\ntemplate <class ELFT>\nStringRef ELFObjectFile<ELFT>::getFileFormatName() const {\n  bool IsLittleEndian = ELFT::TargetEndianness == support::little;\n  switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n  case ELF::ELFCLASS32:\n    switch (EF.getHeader().e_machine) {\n    case ELF::EM_68K:\n      return \"elf32-m68k\";\n    case ELF::EM_386:\n      return \"elf32-i386\";\n    case ELF::EM_IAMCU:\n      return \"elf32-iamcu\";\n    case ELF::EM_X86_64:\n      return \"elf32-x86-64\";\n    case ELF::EM_ARM:\n      return (IsLittleEndian ? \"elf32-littlearm\" : \"elf32-bigarm\");\n    case ELF::EM_AVR:\n      return \"elf32-avr\";\n    case ELF::EM_HEXAGON:\n      return \"elf32-hexagon\";\n    case ELF::EM_LANAI:\n      return \"elf32-lanai\";\n    case ELF::EM_MIPS:\n      return \"elf32-mips\";\n    case ELF::EM_MSP430:\n      return \"elf32-msp430\";\n    case ELF::EM_PPC:\n      return (IsLittleEndian ? \"elf32-powerpcle\" : \"elf32-powerpc\");\n    case ELF::EM_RISCV:\n      return \"elf32-littleriscv\";\n    case ELF::EM_CSKY:\n      return \"elf32-csky\";\n    case ELF::EM_SPARC:\n    case ELF::EM_SPARC32PLUS:\n      return \"elf32-sparc\";\n    case ELF::EM_AMDGPU:\n      return \"elf32-amdgpu\";\n    default:\n      return \"elf32-unknown\";\n    }\n  case ELF::ELFCLASS64:\n    switch (EF.getHeader().e_machine) {\n    case ELF::EM_386:\n      return \"elf64-i386\";\n    case ELF::EM_X86_64:\n      return \"elf64-x86-64\";\n    case ELF::EM_AARCH64:\n      return (IsLittleEndian ? \"elf64-littleaarch64\" : \"elf64-bigaarch64\");\n    case ELF::EM_PPC64:\n      return (IsLittleEndian ? \"elf64-powerpcle\" : \"elf64-powerpc\");\n    case ELF::EM_RISCV:\n      return \"elf64-littleriscv\";\n    case ELF::EM_S390:\n      return \"elf64-s390\";\n    case ELF::EM_SPARCV9:\n      return \"elf64-sparc\";\n    case ELF::EM_MIPS:\n      return \"elf64-mips\";\n    case ELF::EM_AMDGPU:\n      return \"elf64-amdgpu\";\n    case ELF::EM_BPF:\n      return \"elf64-bpf\";\n    case ELF::EM_VE:\n      return \"elf64-ve\";\n    default:\n      return \"elf64-unknown\";\n    }\n  default:\n    // FIXME: Proper error handling.\n    report_fatal_error(\"Invalid ELFCLASS!\");\n  }\n}\n\ntemplate <class ELFT> Triple::ArchType ELFObjectFile<ELFT>::getArch() const {\n  bool IsLittleEndian = ELFT::TargetEndianness == support::little;\n  switch (EF.getHeader().e_machine) {\n  case ELF::EM_68K:\n    return Triple::m68k;\n  case ELF::EM_386:\n  case ELF::EM_IAMCU:\n    return Triple::x86;\n  case ELF::EM_X86_64:\n    return Triple::x86_64;\n  case ELF::EM_AARCH64:\n    return IsLittleEndian ? Triple::aarch64 : Triple::aarch64_be;\n  case ELF::EM_ARM:\n    return Triple::arm;\n  case ELF::EM_AVR:\n    return Triple::avr;\n  case ELF::EM_HEXAGON:\n    return Triple::hexagon;\n  case ELF::EM_LANAI:\n    return Triple::lanai;\n  case ELF::EM_MIPS:\n    switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n    case ELF::ELFCLASS32:\n      return IsLittleEndian ? Triple::mipsel : Triple::mips;\n    case ELF::ELFCLASS64:\n      return IsLittleEndian ? Triple::mips64el : Triple::mips64;\n    default:\n      report_fatal_error(\"Invalid ELFCLASS!\");\n    }\n  case ELF::EM_MSP430:\n    return Triple::msp430;\n  case ELF::EM_PPC:\n    return IsLittleEndian ? Triple::ppcle : Triple::ppc;\n  case ELF::EM_PPC64:\n    return IsLittleEndian ? Triple::ppc64le : Triple::ppc64;\n  case ELF::EM_RISCV:\n    switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n    case ELF::ELFCLASS32:\n      return Triple::riscv32;\n    case ELF::ELFCLASS64:\n      return Triple::riscv64;\n    default:\n      report_fatal_error(\"Invalid ELFCLASS!\");\n    }\n  case ELF::EM_S390:\n    return Triple::systemz;\n\n  case ELF::EM_SPARC:\n  case ELF::EM_SPARC32PLUS:\n    return IsLittleEndian ? Triple::sparcel : Triple::sparc;\n  case ELF::EM_SPARCV9:\n    return Triple::sparcv9;\n\n  case ELF::EM_AMDGPU: {\n    if (!IsLittleEndian)\n      return Triple::UnknownArch;\n\n    unsigned MACH = EF.getHeader().e_flags & ELF::EF_AMDGPU_MACH;\n    if (MACH >= ELF::EF_AMDGPU_MACH_R600_FIRST &&\n        MACH <= ELF::EF_AMDGPU_MACH_R600_LAST)\n      return Triple::r600;\n    if (MACH >= ELF::EF_AMDGPU_MACH_AMDGCN_FIRST &&\n        MACH <= ELF::EF_AMDGPU_MACH_AMDGCN_LAST)\n      return Triple::amdgcn;\n\n    return Triple::UnknownArch;\n  }\n\n  case ELF::EM_BPF:\n    return IsLittleEndian ? Triple::bpfel : Triple::bpfeb;\n\n  case ELF::EM_VE:\n    return Triple::ve;\n  case ELF::EM_CSKY:\n    return Triple::csky;\n  default:\n    return Triple::UnknownArch;\n  }\n}\n\ntemplate <class ELFT>\nExpected<uint64_t> ELFObjectFile<ELFT>::getStartAddress() const {\n  return EF.getHeader().e_entry;\n}\n\ntemplate <class ELFT>\nELFObjectFileBase::elf_symbol_iterator_range\nELFObjectFile<ELFT>::getDynamicSymbolIterators() const {\n  return make_range(dynamic_symbol_begin(), dynamic_symbol_end());\n}\n\ntemplate <class ELFT> bool ELFObjectFile<ELFT>::isRelocatableObject() const {\n  return EF.getHeader().e_type == ELF::ET_REL;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_ELFOBJECTFILE_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFTypes.h", "content": "//===- ELFTypes.h - Endian specific types for ELF ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ELFTYPES_H\n#define LLVM_OBJECT_ELFTYPES_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <type_traits>\n\nnamespace llvm {\nnamespace object {\n\nusing support::endianness;\n\ntemplate <class ELFT> struct Elf_Ehdr_Impl;\ntemplate <class ELFT> struct Elf_Shdr_Impl;\ntemplate <class ELFT> struct Elf_Sym_Impl;\ntemplate <class ELFT> struct Elf_Dyn_Impl;\ntemplate <class ELFT> struct Elf_Phdr_Impl;\ntemplate <class ELFT, bool isRela> struct Elf_Rel_Impl;\ntemplate <class ELFT> struct Elf_Verdef_Impl;\ntemplate <class ELFT> struct Elf_Verdaux_Impl;\ntemplate <class ELFT> struct Elf_Verneed_Impl;\ntemplate <class ELFT> struct Elf_Vernaux_Impl;\ntemplate <class ELFT> struct Elf_Versym_Impl;\ntemplate <class ELFT> struct Elf_Hash_Impl;\ntemplate <class ELFT> struct Elf_GnuHash_Impl;\ntemplate <class ELFT> struct Elf_Chdr_Impl;\ntemplate <class ELFT> struct Elf_Nhdr_Impl;\ntemplate <class ELFT> class Elf_Note_Impl;\ntemplate <class ELFT> class Elf_Note_Iterator_Impl;\ntemplate <class ELFT> struct Elf_CGProfile_Impl;\ntemplate <class ELFT> struct Elf_BBAddrMap_Impl;\n\ntemplate <endianness E, bool Is64> struct ELFType {\nprivate:\n  template <typename Ty>\n  using packed = support::detail::packed_endian_specific_integral<Ty, E, 1>;\n\npublic:\n  static const endianness TargetEndianness = E;\n  static const bool Is64Bits = Is64;\n\n  using uint = std::conditional_t<Is64, uint64_t, uint32_t>;\n  using Ehdr = Elf_Ehdr_Impl<ELFType<E, Is64>>;\n  using Shdr = Elf_Shdr_Impl<ELFType<E, Is64>>;\n  using Sym = Elf_Sym_Impl<ELFType<E, Is64>>;\n  using Dyn = Elf_Dyn_Impl<ELFType<E, Is64>>;\n  using Phdr = Elf_Phdr_Impl<ELFType<E, Is64>>;\n  using Rel = Elf_Rel_Impl<ELFType<E, Is64>, false>;\n  using Rela = Elf_Rel_Impl<ELFType<E, Is64>, true>;\n  using Relr = packed<uint>;\n  using Verdef = Elf_Verdef_Impl<ELFType<E, Is64>>;\n  using Verdaux = Elf_Verdaux_Impl<ELFType<E, Is64>>;\n  using Verneed = Elf_Verneed_Impl<ELFType<E, Is64>>;\n  using Vernaux = Elf_Vernaux_Impl<ELFType<E, Is64>>;\n  using Versym = Elf_Versym_Impl<ELFType<E, Is64>>;\n  using Hash = Elf_Hash_Impl<ELFType<E, Is64>>;\n  using GnuHash = Elf_GnuHash_Impl<ELFType<E, Is64>>;\n  using Chdr = Elf_Chdr_Impl<ELFType<E, Is64>>;\n  using Nhdr = Elf_Nhdr_Impl<ELFType<E, Is64>>;\n  using Note = Elf_Note_Impl<ELFType<E, Is64>>;\n  using NoteIterator = Elf_Note_Iterator_Impl<ELFType<E, Is64>>;\n  using CGProfile = Elf_CGProfile_Impl<ELFType<E, Is64>>;\n  using BBAddrMap = Elf_BBAddrMap_Impl<ELFType<E, Is64>>;\n  using DynRange = ArrayRef<Dyn>;\n  using ShdrRange = ArrayRef<Shdr>;\n  using SymRange = ArrayRef<Sym>;\n  using RelRange = ArrayRef<Rel>;\n  using RelaRange = ArrayRef<Rela>;\n  using RelrRange = ArrayRef<Relr>;\n  using PhdrRange = ArrayRef<Phdr>;\n\n  using Half = packed<uint16_t>;\n  using Word = packed<uint32_t>;\n  using Sword = packed<int32_t>;\n  using Xword = packed<uint64_t>;\n  using Sxword = packed<int64_t>;\n  using Addr = packed<uint>;\n  using Off = packed<uint>;\n};\n\nusing ELF32LE = ELFType<support::little, false>;\nusing ELF32BE = ELFType<support::big, false>;\nusing ELF64LE = ELFType<support::little, true>;\nusing ELF64BE = ELFType<support::big, true>;\n\n// Use an alignment of 2 for the typedefs since that is the worst case for\n// ELF files in archives.\n\n// I really don't like doing this, but the alternative is copypasta.\n#define LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)                                       \\\n  using Elf_Addr = typename ELFT::Addr;                                        \\\n  using Elf_Off = typename ELFT::Off;                                          \\\n  using Elf_Half = typename ELFT::Half;                                        \\\n  using Elf_Word = typename ELFT::Word;                                        \\\n  using Elf_Sword = typename ELFT::Sword;                                      \\\n  using Elf_Xword = typename ELFT::Xword;                                      \\\n  using Elf_Sxword = typename ELFT::Sxword;                                    \\\n  using uintX_t = typename ELFT::uint;                                         \\\n  using Elf_Ehdr = typename ELFT::Ehdr;                                        \\\n  using Elf_Shdr = typename ELFT::Shdr;                                        \\\n  using Elf_Sym = typename ELFT::Sym;                                          \\\n  using Elf_Dyn = typename ELFT::Dyn;                                          \\\n  using Elf_Phdr = typename ELFT::Phdr;                                        \\\n  using Elf_Rel = typename ELFT::Rel;                                          \\\n  using Elf_Rela = typename ELFT::Rela;                                        \\\n  using Elf_Relr = typename ELFT::Relr;                                        \\\n  using Elf_Verdef = typename ELFT::Verdef;                                    \\\n  using Elf_Verdaux = typename ELFT::Verdaux;                                  \\\n  using Elf_Verneed = typename ELFT::Verneed;                                  \\\n  using Elf_Vernaux = typename ELFT::Vernaux;                                  \\\n  using Elf_Versym = typename ELFT::Versym;                                    \\\n  using Elf_Hash = typename ELFT::Hash;                                        \\\n  using Elf_GnuHash = typename ELFT::GnuHash;                                  \\\n  using Elf_Nhdr = typename ELFT::Nhdr;                                        \\\n  using Elf_Note = typename ELFT::Note;                                        \\\n  using Elf_Note_Iterator = typename ELFT::NoteIterator;                       \\\n  using Elf_CGProfile = typename ELFT::CGProfile;                              \\\n  using Elf_BBAddrMap = typename ELFT::BBAddrMap;                              \\\n  using Elf_Dyn_Range = typename ELFT::DynRange;                               \\\n  using Elf_Shdr_Range = typename ELFT::ShdrRange;                             \\\n  using Elf_Sym_Range = typename ELFT::SymRange;                               \\\n  using Elf_Rel_Range = typename ELFT::RelRange;                               \\\n  using Elf_Rela_Range = typename ELFT::RelaRange;                             \\\n  using Elf_Relr_Range = typename ELFT::RelrRange;                             \\\n  using Elf_Phdr_Range = typename ELFT::PhdrRange;\n\n#define LLVM_ELF_COMMA ,\n#define LLVM_ELF_IMPORT_TYPES(E, W)                                            \\\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFType<E LLVM_ELF_COMMA W>)\n\n// Section header.\ntemplate <class ELFT> struct Elf_Shdr_Base;\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Shdr_Base<ELFType<TargetEndianness, false>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, false)\n  Elf_Word sh_name;      // Section name (index into string table)\n  Elf_Word sh_type;      // Section type (SHT_*)\n  Elf_Word sh_flags;     // Section flags (SHF_*)\n  Elf_Addr sh_addr;      // Address where section is to be loaded\n  Elf_Off sh_offset;     // File offset of section data, in bytes\n  Elf_Word sh_size;      // Size of section, in bytes\n  Elf_Word sh_link;      // Section type-specific header table index link\n  Elf_Word sh_info;      // Section type-specific extra information\n  Elf_Word sh_addralign; // Section address alignment\n  Elf_Word sh_entsize;   // Size of records contained within the section\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Shdr_Base<ELFType<TargetEndianness, true>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, true)\n  Elf_Word sh_name;       // Section name (index into string table)\n  Elf_Word sh_type;       // Section type (SHT_*)\n  Elf_Xword sh_flags;     // Section flags (SHF_*)\n  Elf_Addr sh_addr;       // Address where section is to be loaded\n  Elf_Off sh_offset;      // File offset of section data, in bytes\n  Elf_Xword sh_size;      // Size of section, in bytes\n  Elf_Word sh_link;       // Section type-specific header table index link\n  Elf_Word sh_info;       // Section type-specific extra information\n  Elf_Xword sh_addralign; // Section address alignment\n  Elf_Xword sh_entsize;   // Size of records contained within the section\n};\n\ntemplate <class ELFT>\nstruct Elf_Shdr_Impl : Elf_Shdr_Base<ELFT> {\n  using Elf_Shdr_Base<ELFT>::sh_entsize;\n  using Elf_Shdr_Base<ELFT>::sh_size;\n\n  /// Get the number of entities this section contains if it has any.\n  unsigned getEntityCount() const {\n    if (sh_entsize == 0)\n      return 0;\n    return sh_size / sh_entsize;\n  }\n};\n\ntemplate <class ELFT> struct Elf_Sym_Base;\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Sym_Base<ELFType<TargetEndianness, false>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, false)\n  Elf_Word st_name;       // Symbol name (index into string table)\n  Elf_Addr st_value;      // Value or address associated with the symbol\n  Elf_Word st_size;       // Size of the symbol\n  unsigned char st_info;  // Symbol's type and binding attributes\n  unsigned char st_other; // Must be zero; reserved\n  Elf_Half st_shndx;      // Which section (header table index) it's defined in\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Sym_Base<ELFType<TargetEndianness, true>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, true)\n  Elf_Word st_name;       // Symbol name (index into string table)\n  unsigned char st_info;  // Symbol's type and binding attributes\n  unsigned char st_other; // Must be zero; reserved\n  Elf_Half st_shndx;      // Which section (header table index) it's defined in\n  Elf_Addr st_value;      // Value or address associated with the symbol\n  Elf_Xword st_size;      // Size of the symbol\n};\n\ntemplate <class ELFT>\nstruct Elf_Sym_Impl : Elf_Sym_Base<ELFT> {\n  using Elf_Sym_Base<ELFT>::st_info;\n  using Elf_Sym_Base<ELFT>::st_shndx;\n  using Elf_Sym_Base<ELFT>::st_other;\n  using Elf_Sym_Base<ELFT>::st_value;\n\n  // These accessors and mutators correspond to the ELF32_ST_BIND,\n  // ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:\n  unsigned char getBinding() const { return st_info >> 4; }\n  unsigned char getType() const { return st_info & 0x0f; }\n  uint64_t getValue() const { return st_value; }\n  void setBinding(unsigned char b) { setBindingAndType(b, getType()); }\n  void setType(unsigned char t) { setBindingAndType(getBinding(), t); }\n\n  void setBindingAndType(unsigned char b, unsigned char t) {\n    st_info = (b << 4) + (t & 0x0f);\n  }\n\n  /// Access to the STV_xxx flag stored in the first two bits of st_other.\n  /// STV_DEFAULT: 0\n  /// STV_INTERNAL: 1\n  /// STV_HIDDEN: 2\n  /// STV_PROTECTED: 3\n  unsigned char getVisibility() const { return st_other & 0x3; }\n  void setVisibility(unsigned char v) {\n    assert(v < 4 && \"Invalid value for visibility\");\n    st_other = (st_other & ~0x3) | v;\n  }\n\n  bool isAbsolute() const { return st_shndx == ELF::SHN_ABS; }\n\n  bool isCommon() const {\n    return getType() == ELF::STT_COMMON || st_shndx == ELF::SHN_COMMON;\n  }\n\n  bool isDefined() const { return !isUndefined(); }\n\n  bool isProcessorSpecific() const {\n    return st_shndx >= ELF::SHN_LOPROC && st_shndx <= ELF::SHN_HIPROC;\n  }\n\n  bool isOSSpecific() const {\n    return st_shndx >= ELF::SHN_LOOS && st_shndx <= ELF::SHN_HIOS;\n  }\n\n  bool isReserved() const {\n    // ELF::SHN_HIRESERVE is 0xffff so st_shndx <= ELF::SHN_HIRESERVE is always\n    // true and some compilers warn about it.\n    return st_shndx >= ELF::SHN_LORESERVE;\n  }\n\n  bool isUndefined() const { return st_shndx == ELF::SHN_UNDEF; }\n\n  bool isExternal() const {\n    return getBinding() != ELF::STB_LOCAL;\n  }\n\n  Expected<StringRef> getName(StringRef StrTab) const;\n};\n\ntemplate <class ELFT>\nExpected<StringRef> Elf_Sym_Impl<ELFT>::getName(StringRef StrTab) const {\n  uint32_t Offset = this->st_name;\n  if (Offset >= StrTab.size())\n    return createStringError(object_error::parse_failed,\n                             \"st_name (0x%\" PRIx32\n                             \") is past the end of the string table\"\n                             \" of size 0x%zx\",\n                             Offset, StrTab.size());\n  return StringRef(StrTab.data() + Offset);\n}\n\n/// Elf_Versym: This is the structure of entries in the SHT_GNU_versym section\n/// (.gnu.version). This structure is identical for ELF32 and ELF64.\ntemplate <class ELFT>\nstruct Elf_Versym_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Half vs_index; // Version index with flags (e.g. VERSYM_HIDDEN)\n};\n\n/// Elf_Verdef: This is the structure of entries in the SHT_GNU_verdef section\n/// (.gnu.version_d). This structure is identical for ELF32 and ELF64.\ntemplate <class ELFT>\nstruct Elf_Verdef_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Half vd_version; // Version of this structure (e.g. VER_DEF_CURRENT)\n  Elf_Half vd_flags;   // Bitwise flags (VER_DEF_*)\n  Elf_Half vd_ndx;     // Version index, used in .gnu.version entries\n  Elf_Half vd_cnt;     // Number of Verdaux entries\n  Elf_Word vd_hash;    // Hash of name\n  Elf_Word vd_aux;     // Offset to the first Verdaux entry (in bytes)\n  Elf_Word vd_next;    // Offset to the next Verdef entry (in bytes)\n\n  /// Get the first Verdaux entry for this Verdef.\n  const Elf_Verdaux *getAux() const {\n    return reinterpret_cast<const Elf_Verdaux *>((const char *)this + vd_aux);\n  }\n};\n\n/// Elf_Verdaux: This is the structure of auxiliary data in the SHT_GNU_verdef\n/// section (.gnu.version_d). This structure is identical for ELF32 and ELF64.\ntemplate <class ELFT>\nstruct Elf_Verdaux_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Word vda_name; // Version name (offset in string table)\n  Elf_Word vda_next; // Offset to next Verdaux entry (in bytes)\n};\n\n/// Elf_Verneed: This is the structure of entries in the SHT_GNU_verneed\n/// section (.gnu.version_r). This structure is identical for ELF32 and ELF64.\ntemplate <class ELFT>\nstruct Elf_Verneed_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Half vn_version; // Version of this structure (e.g. VER_NEED_CURRENT)\n  Elf_Half vn_cnt;     // Number of associated Vernaux entries\n  Elf_Word vn_file;    // Library name (string table offset)\n  Elf_Word vn_aux;     // Offset to first Vernaux entry (in bytes)\n  Elf_Word vn_next;    // Offset to next Verneed entry (in bytes)\n};\n\n/// Elf_Vernaux: This is the structure of auxiliary data in SHT_GNU_verneed\n/// section (.gnu.version_r). This structure is identical for ELF32 and ELF64.\ntemplate <class ELFT>\nstruct Elf_Vernaux_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Word vna_hash;  // Hash of dependency name\n  Elf_Half vna_flags; // Bitwise Flags (VER_FLAG_*)\n  Elf_Half vna_other; // Version index, used in .gnu.version entries\n  Elf_Word vna_name;  // Dependency name\n  Elf_Word vna_next;  // Offset to next Vernaux entry (in bytes)\n};\n\n/// Elf_Dyn_Base: This structure matches the form of entries in the dynamic\n///               table section (.dynamic) look like.\ntemplate <class ELFT> struct Elf_Dyn_Base;\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Dyn_Base<ELFType<TargetEndianness, false>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, false)\n  Elf_Sword d_tag;\n  union {\n    Elf_Word d_val;\n    Elf_Addr d_ptr;\n  } d_un;\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Dyn_Base<ELFType<TargetEndianness, true>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, true)\n  Elf_Sxword d_tag;\n  union {\n    Elf_Xword d_val;\n    Elf_Addr d_ptr;\n  } d_un;\n};\n\n/// Elf_Dyn_Impl: This inherits from Elf_Dyn_Base, adding getters.\ntemplate <class ELFT>\nstruct Elf_Dyn_Impl : Elf_Dyn_Base<ELFT> {\n  using Elf_Dyn_Base<ELFT>::d_tag;\n  using Elf_Dyn_Base<ELFT>::d_un;\n  using intX_t = std::conditional_t<ELFT::Is64Bits, int64_t, int32_t>;\n  using uintX_t = std::conditional_t<ELFT::Is64Bits, uint64_t, uint32_t>;\n  intX_t getTag() const { return d_tag; }\n  uintX_t getVal() const { return d_un.d_val; }\n  uintX_t getPtr() const { return d_un.d_ptr; }\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Rel_Impl<ELFType<TargetEndianness, false>, false> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, false)\n  static const bool IsRela = false;\n  Elf_Addr r_offset; // Location (file byte offset, or program virtual addr)\n  Elf_Word r_info;   // Symbol table index and type of relocation to apply\n\n  uint32_t getRInfo(bool isMips64EL) const {\n    assert(!isMips64EL);\n    return r_info;\n  }\n  void setRInfo(uint32_t R, bool IsMips64EL) {\n    assert(!IsMips64EL);\n    r_info = R;\n  }\n\n  // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,\n  // and ELF32_R_INFO macros defined in the ELF specification:\n  uint32_t getSymbol(bool isMips64EL) const {\n    return this->getRInfo(isMips64EL) >> 8;\n  }\n  unsigned char getType(bool isMips64EL) const {\n    return (unsigned char)(this->getRInfo(isMips64EL) & 0x0ff);\n  }\n  void setSymbol(uint32_t s, bool IsMips64EL) {\n    setSymbolAndType(s, getType(IsMips64EL), IsMips64EL);\n  }\n  void setType(unsigned char t, bool IsMips64EL) {\n    setSymbolAndType(getSymbol(IsMips64EL), t, IsMips64EL);\n  }\n  void setSymbolAndType(uint32_t s, unsigned char t, bool IsMips64EL) {\n    this->setRInfo((s << 8) + t, IsMips64EL);\n  }\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Rel_Impl<ELFType<TargetEndianness, false>, true>\n    : public Elf_Rel_Impl<ELFType<TargetEndianness, false>, false> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, false)\n  static const bool IsRela = true;\n  Elf_Sword r_addend; // Compute value for relocatable field by adding this\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Rel_Impl<ELFType<TargetEndianness, true>, false> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, true)\n  static const bool IsRela = false;\n  Elf_Addr r_offset; // Location (file byte offset, or program virtual addr)\n  Elf_Xword r_info;  // Symbol table index and type of relocation to apply\n\n  uint64_t getRInfo(bool isMips64EL) const {\n    uint64_t t = r_info;\n    if (!isMips64EL)\n      return t;\n    // Mips64 little endian has a \"special\" encoding of r_info. Instead of one\n    // 64 bit little endian number, it is a little endian 32 bit number followed\n    // by a 32 bit big endian number.\n    return (t << 32) | ((t >> 8) & 0xff000000) | ((t >> 24) & 0x00ff0000) |\n           ((t >> 40) & 0x0000ff00) | ((t >> 56) & 0x000000ff);\n  }\n\n  void setRInfo(uint64_t R, bool IsMips64EL) {\n    if (IsMips64EL)\n      r_info = (R >> 32) | ((R & 0xff000000) << 8) | ((R & 0x00ff0000) << 24) |\n               ((R & 0x0000ff00) << 40) | ((R & 0x000000ff) << 56);\n    else\n      r_info = R;\n  }\n\n  // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,\n  // and ELF64_R_INFO macros defined in the ELF specification:\n  uint32_t getSymbol(bool isMips64EL) const {\n    return (uint32_t)(this->getRInfo(isMips64EL) >> 32);\n  }\n  uint32_t getType(bool isMips64EL) const {\n    return (uint32_t)(this->getRInfo(isMips64EL) & 0xffffffffL);\n  }\n  void setSymbol(uint32_t s, bool IsMips64EL) {\n    setSymbolAndType(s, getType(IsMips64EL), IsMips64EL);\n  }\n  void setType(uint32_t t, bool IsMips64EL) {\n    setSymbolAndType(getSymbol(IsMips64EL), t, IsMips64EL);\n  }\n  void setSymbolAndType(uint32_t s, uint32_t t, bool IsMips64EL) {\n    this->setRInfo(((uint64_t)s << 32) + (t & 0xffffffffL), IsMips64EL);\n  }\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Rel_Impl<ELFType<TargetEndianness, true>, true>\n    : public Elf_Rel_Impl<ELFType<TargetEndianness, true>, false> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, true)\n  static const bool IsRela = true;\n  Elf_Sxword r_addend; // Compute value for relocatable field by adding this.\n};\n\ntemplate <class ELFT>\nstruct Elf_Ehdr_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  unsigned char e_ident[ELF::EI_NIDENT]; // ELF Identification bytes\n  Elf_Half e_type;                       // Type of file (see ET_*)\n  Elf_Half e_machine;   // Required architecture for this file (see EM_*)\n  Elf_Word e_version;   // Must be equal to 1\n  Elf_Addr e_entry;     // Address to jump to in order to start program\n  Elf_Off e_phoff;      // Program header table's file offset, in bytes\n  Elf_Off e_shoff;      // Section header table's file offset, in bytes\n  Elf_Word e_flags;     // Processor-specific flags\n  Elf_Half e_ehsize;    // Size of ELF header, in bytes\n  Elf_Half e_phentsize; // Size of an entry in the program header table\n  Elf_Half e_phnum;     // Number of entries in the program header table\n  Elf_Half e_shentsize; // Size of an entry in the section header table\n  Elf_Half e_shnum;     // Number of entries in the section header table\n  Elf_Half e_shstrndx;  // Section header table index of section name\n                        // string table\n\n  bool checkMagic() const {\n    return (memcmp(e_ident, ELF::ElfMagic, strlen(ELF::ElfMagic))) == 0;\n  }\n\n  unsigned char getFileClass() const { return e_ident[ELF::EI_CLASS]; }\n  unsigned char getDataEncoding() const { return e_ident[ELF::EI_DATA]; }\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Phdr_Impl<ELFType<TargetEndianness, false>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, false)\n  Elf_Word p_type;   // Type of segment\n  Elf_Off p_offset;  // FileOffset where segment is located, in bytes\n  Elf_Addr p_vaddr;  // Virtual Address of beginning of segment\n  Elf_Addr p_paddr;  // Physical address of beginning of segment (OS-specific)\n  Elf_Word p_filesz; // Num. of bytes in file image of segment (may be zero)\n  Elf_Word p_memsz;  // Num. of bytes in mem image of segment (may be zero)\n  Elf_Word p_flags;  // Segment flags\n  Elf_Word p_align;  // Segment alignment constraint\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Phdr_Impl<ELFType<TargetEndianness, true>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, true)\n  Elf_Word p_type;    // Type of segment\n  Elf_Word p_flags;   // Segment flags\n  Elf_Off p_offset;   // FileOffset where segment is located, in bytes\n  Elf_Addr p_vaddr;   // Virtual Address of beginning of segment\n  Elf_Addr p_paddr;   // Physical address of beginning of segment (OS-specific)\n  Elf_Xword p_filesz; // Num. of bytes in file image of segment (may be zero)\n  Elf_Xword p_memsz;  // Num. of bytes in mem image of segment (may be zero)\n  Elf_Xword p_align;  // Segment alignment constraint\n};\n\n// ELFT needed for endianness.\ntemplate <class ELFT>\nstruct Elf_Hash_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Word nbucket;\n  Elf_Word nchain;\n\n  ArrayRef<Elf_Word> buckets() const {\n    return ArrayRef<Elf_Word>(&nbucket + 2, &nbucket + 2 + nbucket);\n  }\n\n  ArrayRef<Elf_Word> chains() const {\n    return ArrayRef<Elf_Word>(&nbucket + 2 + nbucket,\n                              &nbucket + 2 + nbucket + nchain);\n  }\n};\n\n// .gnu.hash section\ntemplate <class ELFT>\nstruct Elf_GnuHash_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Word nbuckets;\n  Elf_Word symndx;\n  Elf_Word maskwords;\n  Elf_Word shift2;\n\n  ArrayRef<Elf_Off> filter() const {\n    return ArrayRef<Elf_Off>(reinterpret_cast<const Elf_Off *>(&shift2 + 1),\n                             maskwords);\n  }\n\n  ArrayRef<Elf_Word> buckets() const {\n    return ArrayRef<Elf_Word>(\n        reinterpret_cast<const Elf_Word *>(filter().end()), nbuckets);\n  }\n\n  ArrayRef<Elf_Word> values(unsigned DynamicSymCount) const {\n    assert(DynamicSymCount >= symndx);\n    return ArrayRef<Elf_Word>(buckets().end(), DynamicSymCount - symndx);\n  }\n};\n\n// Compressed section headers.\n// http://www.sco.com/developers/gabi/latest/ch4.sheader.html#compression_header\ntemplate <endianness TargetEndianness>\nstruct Elf_Chdr_Impl<ELFType<TargetEndianness, false>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, false)\n  Elf_Word ch_type;\n  Elf_Word ch_size;\n  Elf_Word ch_addralign;\n};\n\ntemplate <endianness TargetEndianness>\nstruct Elf_Chdr_Impl<ELFType<TargetEndianness, true>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, true)\n  Elf_Word ch_type;\n  Elf_Word ch_reserved;\n  Elf_Xword ch_size;\n  Elf_Xword ch_addralign;\n};\n\n/// Note header\ntemplate <class ELFT>\nstruct Elf_Nhdr_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Word n_namesz;\n  Elf_Word n_descsz;\n  Elf_Word n_type;\n\n  /// The alignment of the name and descriptor.\n  ///\n  /// Implementations differ from the specification here: in practice all\n  /// variants align both the name and descriptor to 4-bytes.\n  static const unsigned int Align = 4;\n\n  /// Get the size of the note, including name, descriptor, and padding.\n  size_t getSize() const {\n    return sizeof(*this) + alignTo<Align>(n_namesz) + alignTo<Align>(n_descsz);\n  }\n};\n\n/// An ELF note.\n///\n/// Wraps a note header, providing methods for accessing the name and\n/// descriptor safely.\ntemplate <class ELFT>\nclass Elf_Note_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  const Elf_Nhdr_Impl<ELFT> &Nhdr;\n\n  template <class NoteIteratorELFT> friend class Elf_Note_Iterator_Impl;\n\npublic:\n  Elf_Note_Impl(const Elf_Nhdr_Impl<ELFT> &Nhdr) : Nhdr(Nhdr) {}\n\n  /// Get the note's name, excluding the terminating null byte.\n  StringRef getName() const {\n    if (!Nhdr.n_namesz)\n      return StringRef();\n    return StringRef(reinterpret_cast<const char *>(&Nhdr) + sizeof(Nhdr),\n                     Nhdr.n_namesz - 1);\n  }\n\n  /// Get the note's descriptor.\n  ArrayRef<uint8_t> getDesc() const {\n    if (!Nhdr.n_descsz)\n      return ArrayRef<uint8_t>();\n    return ArrayRef<uint8_t>(\n        reinterpret_cast<const uint8_t *>(&Nhdr) + sizeof(Nhdr) +\n          alignTo<Elf_Nhdr_Impl<ELFT>::Align>(Nhdr.n_namesz),\n        Nhdr.n_descsz);\n  }\n\n  /// Get the note's descriptor as StringRef\n  StringRef getDescAsStringRef() const {\n    ArrayRef<uint8_t> Desc = getDesc();\n    return StringRef(reinterpret_cast<const char *>(Desc.data()), Desc.size());\n  }\n\n  /// Get the note's type.\n  Elf_Word getType() const { return Nhdr.n_type; }\n};\n\ntemplate <class ELFT>\nclass Elf_Note_Iterator_Impl\n    : std::iterator<std::forward_iterator_tag, Elf_Note_Impl<ELFT>> {\n  // Nhdr being a nullptr marks the end of iteration.\n  const Elf_Nhdr_Impl<ELFT> *Nhdr = nullptr;\n  size_t RemainingSize = 0u;\n  Error *Err = nullptr;\n\n  template <class ELFFileELFT> friend class ELFFile;\n\n  // Stop iteration and indicate an overflow.\n  void stopWithOverflowError() {\n    Nhdr = nullptr;\n    *Err = make_error<StringError>(\"ELF note overflows container\",\n                                   object_error::parse_failed);\n  }\n\n  // Advance Nhdr by NoteSize bytes, starting from NhdrPos.\n  //\n  // Assumes NoteSize <= RemainingSize. Ensures Nhdr->getSize() <= RemainingSize\n  // upon returning. Handles stopping iteration when reaching the end of the\n  // container, either cleanly or with an overflow error.\n  void advanceNhdr(const uint8_t *NhdrPos, size_t NoteSize) {\n    RemainingSize -= NoteSize;\n    if (RemainingSize == 0u) {\n      // Ensure that if the iterator walks to the end, the error is checked\n      // afterwards.\n      *Err = Error::success();\n      Nhdr = nullptr;\n    } else if (sizeof(*Nhdr) > RemainingSize)\n      stopWithOverflowError();\n    else {\n      Nhdr = reinterpret_cast<const Elf_Nhdr_Impl<ELFT> *>(NhdrPos + NoteSize);\n      if (Nhdr->getSize() > RemainingSize)\n        stopWithOverflowError();\n      else\n        *Err = Error::success();\n    }\n  }\n\n  Elf_Note_Iterator_Impl() {}\n  explicit Elf_Note_Iterator_Impl(Error &Err) : Err(&Err) {}\n  Elf_Note_Iterator_Impl(const uint8_t *Start, size_t Size, Error &Err)\n      : RemainingSize(Size), Err(&Err) {\n    consumeError(std::move(Err));\n    assert(Start && \"ELF note iterator starting at NULL\");\n    advanceNhdr(Start, 0u);\n  }\n\npublic:\n  Elf_Note_Iterator_Impl &operator++() {\n    assert(Nhdr && \"incremented ELF note end iterator\");\n    const uint8_t *NhdrPos = reinterpret_cast<const uint8_t *>(Nhdr);\n    size_t NoteSize = Nhdr->getSize();\n    advanceNhdr(NhdrPos, NoteSize);\n    return *this;\n  }\n  bool operator==(Elf_Note_Iterator_Impl Other) const {\n    if (!Nhdr && Other.Err)\n      (void)(bool)(*Other.Err);\n    if (!Other.Nhdr && Err)\n      (void)(bool)(*Err);\n    return Nhdr == Other.Nhdr;\n  }\n  bool operator!=(Elf_Note_Iterator_Impl Other) const {\n    return !(*this == Other);\n  }\n  Elf_Note_Impl<ELFT> operator*() const {\n    assert(Nhdr && \"dereferenced ELF note end iterator\");\n    return Elf_Note_Impl<ELFT>(*Nhdr);\n  }\n};\n\ntemplate <class ELFT> struct Elf_CGProfile_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Word cgp_from;\n  Elf_Word cgp_to;\n  Elf_Xword cgp_weight;\n};\n\n// MIPS .reginfo section\ntemplate <class ELFT>\nstruct Elf_Mips_RegInfo;\n\ntemplate <support::endianness TargetEndianness>\nstruct Elf_Mips_RegInfo<ELFType<TargetEndianness, false>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, false)\n  Elf_Word ri_gprmask;     // bit-mask of used general registers\n  Elf_Word ri_cprmask[4];  // bit-mask of used co-processor registers\n  Elf_Addr ri_gp_value;    // gp register value\n};\n\ntemplate <support::endianness TargetEndianness>\nstruct Elf_Mips_RegInfo<ELFType<TargetEndianness, true>> {\n  LLVM_ELF_IMPORT_TYPES(TargetEndianness, true)\n  Elf_Word ri_gprmask;     // bit-mask of used general registers\n  Elf_Word ri_pad;         // unused padding field\n  Elf_Word ri_cprmask[4];  // bit-mask of used co-processor registers\n  Elf_Addr ri_gp_value;    // gp register value\n};\n\n// .MIPS.options section\ntemplate <class ELFT> struct Elf_Mips_Options {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  uint8_t kind;     // Determines interpretation of variable part of descriptor\n  uint8_t size;     // Byte size of descriptor, including this header\n  Elf_Half section; // Section header index of section affected,\n                    // or 0 for global options\n  Elf_Word info;    // Kind-specific information\n\n  Elf_Mips_RegInfo<ELFT> &getRegInfo() {\n    assert(kind == ELF::ODK_REGINFO);\n    return *reinterpret_cast<Elf_Mips_RegInfo<ELFT> *>(\n        (uint8_t *)this + sizeof(Elf_Mips_Options));\n  }\n  const Elf_Mips_RegInfo<ELFT> &getRegInfo() const {\n    return const_cast<Elf_Mips_Options *>(this)->getRegInfo();\n  }\n};\n\n// .MIPS.abiflags section content\ntemplate <class ELFT> struct Elf_Mips_ABIFlags {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  Elf_Half version;  // Version of the structure\n  uint8_t isa_level; // ISA level: 1-5, 32, and 64\n  uint8_t isa_rev;   // ISA revision (0 for MIPS I - MIPS V)\n  uint8_t gpr_size;  // General purpose registers size\n  uint8_t cpr1_size; // Co-processor 1 registers size\n  uint8_t cpr2_size; // Co-processor 2 registers size\n  uint8_t fp_abi;    // Floating-point ABI flag\n  Elf_Word isa_ext;  // Processor-specific extension\n  Elf_Word ases;     // ASEs flags\n  Elf_Word flags1;   // General flags\n  Elf_Word flags2;   // General flags\n};\n\n// Struct representing the BBAddrMap for one function.\ntemplate <class ELFT> struct Elf_BBAddrMap_Impl {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  uintX_t Addr; // Function address\n  // Struct representing the BBAddrMap information for one basic block.\n  struct BBEntry {\n    uint32_t Offset; // Offset of basic block relative to function start.\n    uint32_t Size;   // Size of the basic block.\n\n    // The following fields are decoded from the Metadata field. The encoding\n    // happens in AsmPrinter.cpp:getBBAddrMapMetadata.\n    bool HasReturn;   // If this block ends with a return (or tail call).\n    bool HasTailCall; // If this block ends with a tail call.\n    bool IsEHPad;     // If this is an exception handling block.\n\n    BBEntry(uint32_t Offset, uint32_t Size, uint32_t Metadata)\n        : Offset(Offset), Size(Size), HasReturn(Metadata & 1),\n          HasTailCall(Metadata & (1 << 1)), IsEHPad(Metadata & (1 << 2)){};\n  };\n  std::vector<BBEntry> BBEntries; // Basic block entries for this function.\n};\n\n} // end namespace object.\n} // end namespace llvm.\n\n#endif // LLVM_OBJECT_ELFTYPES_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Error.h", "content": "//===- Error.h - system_error extensions for Object -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This declares a new error_category for the Object library.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ERROR_H\n#define LLVM_OBJECT_ERROR_H\n\n#include \"llvm/Support/Error.h\"\n#include <system_error>\n\nnamespace llvm {\n\nclass Twine;\n\nnamespace object {\n\nclass Binary;\n\nconst std::error_category &object_category();\n\nenum class object_error {\n  // Error code 0 is absent. Use std::error_code() instead.\n  arch_not_found = 1,\n  invalid_file_type,\n  parse_failed,\n  unexpected_eof,\n  string_table_non_null_end,\n  invalid_section_index,\n  bitcode_section_not_found,\n  invalid_symbol_index,\n};\n\ninline std::error_code make_error_code(object_error e) {\n  return std::error_code(static_cast<int>(e), object_category());\n}\n\n/// Base class for all errors indicating malformed binary files.\n///\n/// Having a subclass for all malformed binary files allows archive-walking\n/// code to skip malformed files without having to understand every possible\n/// way that a binary file might be malformed.\n///\n/// Currently inherits from ECError for easy interoperability with\n/// std::error_code, but this will be removed in the future.\nclass BinaryError : public ErrorInfo<BinaryError, ECError> {\n  void anchor() override;\npublic:\n  static char ID;\n  BinaryError() {\n    // Default to parse_failed, can be overridden with setErrorCode.\n    setErrorCode(make_error_code(object_error::parse_failed));\n  }\n};\n\n/// Generic binary error.\n///\n/// For errors that don't require their own specific sub-error (most errors)\n/// this class can be used to describe the error via a string message.\nclass GenericBinaryError : public ErrorInfo<GenericBinaryError, BinaryError> {\npublic:\n  static char ID;\n  GenericBinaryError(const Twine &Msg);\n  GenericBinaryError(const Twine &Msg, object_error ECOverride);\n  const std::string &getMessage() const { return Msg; }\n  void log(raw_ostream &OS) const override;\nprivate:\n  std::string Msg;\n};\n\n/// isNotObjectErrorInvalidFileType() is used when looping through the children\n/// of an archive after calling getAsBinary() on the child and it returns an\n/// llvm::Error.  In the cases we want to loop through the children and ignore the\n/// non-objects in the archive this is used to test the error to see if an\n/// error() function needs to called on the llvm::Error.\nError isNotObjectErrorInvalidFileType(llvm::Error Err);\n\n} // end namespace object.\n\n} // end namespace llvm.\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<llvm::object::object_error> : std::true_type {};\n}\n\n#endif\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "content": "//===- ObjectFile.h - File format independent object file -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares a file format independent ObjectFile class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_OBJECTFILE_H\n#define LLVM_OBJECT_OBJECTFILE_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Magic.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <system_error>\n\nnamespace llvm {\n\nclass ARMAttributeParser;\nclass SubtargetFeatures;\n\nnamespace object {\n\nclass COFFObjectFile;\nclass MachOObjectFile;\nclass ObjectFile;\nclass SectionRef;\nclass SymbolRef;\nclass symbol_iterator;\nclass WasmObjectFile;\n\nusing section_iterator = content_iterator<SectionRef>;\n\n/// This is a value type class that represents a single relocation in the list\n/// of relocations in the object file.\nclass RelocationRef {\n  DataRefImpl RelocationPimpl;\n  const ObjectFile *OwningObject = nullptr;\n\npublic:\n  RelocationRef() = default;\n  RelocationRef(DataRefImpl RelocationP, const ObjectFile *Owner);\n\n  bool operator==(const RelocationRef &Other) const;\n\n  void moveNext();\n\n  uint64_t getOffset() const;\n  symbol_iterator getSymbol() const;\n  uint64_t getType() const;\n\n  /// Get a string that represents the type of this relocation.\n  ///\n  /// This is for display purposes only.\n  void getTypeName(SmallVectorImpl<char> &Result) const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const ObjectFile *getObject() const;\n};\n\nusing relocation_iterator = content_iterator<RelocationRef>;\n\n/// This is a value type class that represents a single section in the list of\n/// sections in the object file.\nclass SectionRef {\n  friend class SymbolRef;\n\n  DataRefImpl SectionPimpl;\n  const ObjectFile *OwningObject = nullptr;\n\npublic:\n  SectionRef() = default;\n  SectionRef(DataRefImpl SectionP, const ObjectFile *Owner);\n\n  bool operator==(const SectionRef &Other) const;\n  bool operator!=(const SectionRef &Other) const;\n  bool operator<(const SectionRef &Other) const;\n\n  void moveNext();\n\n  Expected<StringRef> getName() const;\n  uint64_t getAddress() const;\n  uint64_t getIndex() const;\n  uint64_t getSize() const;\n  Expected<StringRef> getContents() const;\n\n  /// Get the alignment of this section as the actual value (not log 2).\n  uint64_t getAlignment() const;\n\n  bool isCompressed() const;\n  /// Whether this section contains instructions.\n  bool isText() const;\n  /// Whether this section contains data, not instructions.\n  bool isData() const;\n  /// Whether this section contains BSS uninitialized data.\n  bool isBSS() const;\n  bool isVirtual() const;\n  bool isBitcode() const;\n  bool isStripped() const;\n\n  /// Whether this section will be placed in the text segment, according to the\n  /// Berkeley size format. This is true if the section is allocatable, and\n  /// contains either code or readonly data.\n  bool isBerkeleyText() const;\n  /// Whether this section will be placed in the data segment, according to the\n  /// Berkeley size format. This is true if the section is allocatable and\n  /// contains data (e.g. PROGBITS), but is not text.\n  bool isBerkeleyData() const;\n\n  /// Whether this section is a debug section.\n  bool isDebugSection(StringRef SectionName) const;\n\n  bool containsSymbol(SymbolRef S) const;\n\n  relocation_iterator relocation_begin() const;\n  relocation_iterator relocation_end() const;\n  iterator_range<relocation_iterator> relocations() const {\n    return make_range(relocation_begin(), relocation_end());\n  }\n  Expected<section_iterator> getRelocatedSection() const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const ObjectFile *getObject() const;\n};\n\nstruct SectionedAddress {\n  const static uint64_t UndefSection = UINT64_MAX;\n\n  uint64_t Address = 0;\n  uint64_t SectionIndex = UndefSection;\n};\n\ninline bool operator<(const SectionedAddress &LHS,\n                      const SectionedAddress &RHS) {\n  return std::tie(LHS.SectionIndex, LHS.Address) <\n         std::tie(RHS.SectionIndex, RHS.Address);\n}\n\ninline bool operator==(const SectionedAddress &LHS,\n                       const SectionedAddress &RHS) {\n  return std::tie(LHS.SectionIndex, LHS.Address) ==\n         std::tie(RHS.SectionIndex, RHS.Address);\n}\n\nraw_ostream &operator<<(raw_ostream &OS, const SectionedAddress &Addr);\n\n/// This is a value type class that represents a single symbol in the list of\n/// symbols in the object file.\nclass SymbolRef : public BasicSymbolRef {\n  friend class SectionRef;\n\npublic:\n  enum Type {\n    ST_Unknown, // Type not specified\n    ST_Data,\n    ST_Debug,\n    ST_File,\n    ST_Function,\n    ST_Other\n  };\n\n  SymbolRef() = default;\n  SymbolRef(DataRefImpl SymbolP, const ObjectFile *Owner);\n  SymbolRef(const BasicSymbolRef &B) : BasicSymbolRef(B) {\n    assert(isa<ObjectFile>(BasicSymbolRef::getObject()));\n  }\n\n  Expected<StringRef> getName() const;\n  /// Returns the symbol virtual address (i.e. address at which it will be\n  /// mapped).\n  Expected<uint64_t> getAddress() const;\n\n  /// Return the value of the symbol depending on the object this can be an\n  /// offset or a virtual address.\n  Expected<uint64_t> getValue() const;\n\n  /// Get the alignment of this symbol as the actual value (not log 2).\n  uint32_t getAlignment() const;\n  uint64_t getCommonSize() const;\n  Expected<SymbolRef::Type> getType() const;\n\n  /// Get section this symbol is defined in reference to. Result is\n  /// end_sections() if it is undefined or is an absolute symbol.\n  Expected<section_iterator> getSection() const;\n\n  const ObjectFile *getObject() const;\n};\n\nclass symbol_iterator : public basic_symbol_iterator {\npublic:\n  symbol_iterator(SymbolRef Sym) : basic_symbol_iterator(Sym) {}\n  symbol_iterator(const basic_symbol_iterator &B)\n      : basic_symbol_iterator(SymbolRef(B->getRawDataRefImpl(),\n                                        cast<ObjectFile>(B->getObject()))) {}\n\n  const SymbolRef *operator->() const {\n    const BasicSymbolRef &P = basic_symbol_iterator::operator *();\n    return static_cast<const SymbolRef*>(&P);\n  }\n\n  const SymbolRef &operator*() const {\n    const BasicSymbolRef &P = basic_symbol_iterator::operator *();\n    return static_cast<const SymbolRef&>(P);\n  }\n};\n\n/// This class is the base class for all object file types. Concrete instances\n/// of this object are created by createObjectFile, which figures out which type\n/// to create.\nclass ObjectFile : public SymbolicFile {\n  virtual void anchor();\n\nprotected:\n  ObjectFile(unsigned int Type, MemoryBufferRef Source);\n\n  const uint8_t *base() const {\n    return reinterpret_cast<const uint8_t *>(Data.getBufferStart());\n  }\n\n  // These functions are for SymbolRef to call internally. The main goal of\n  // this is to allow SymbolRef::SymbolPimpl to point directly to the symbol\n  // entry in the memory mapped object file. SymbolPimpl cannot contain any\n  // virtual functions because then it could not point into the memory mapped\n  // file.\n  //\n  // Implementations assume that the DataRefImpl is valid and has not been\n  // modified externally. It's UB otherwise.\n  friend class SymbolRef;\n\n  virtual Expected<StringRef> getSymbolName(DataRefImpl Symb) const = 0;\n  Error printSymbolName(raw_ostream &OS,\n                                  DataRefImpl Symb) const override;\n  virtual Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const = 0;\n  virtual uint64_t getSymbolValueImpl(DataRefImpl Symb) const = 0;\n  virtual uint32_t getSymbolAlignment(DataRefImpl Symb) const;\n  virtual uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const = 0;\n  virtual Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const = 0;\n  virtual Expected<section_iterator>\n  getSymbolSection(DataRefImpl Symb) const = 0;\n\n  // Same as above for SectionRef.\n  friend class SectionRef;\n\n  virtual void moveSectionNext(DataRefImpl &Sec) const = 0;\n  virtual Expected<StringRef> getSectionName(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionAddress(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionIndex(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionSize(DataRefImpl Sec) const = 0;\n  virtual Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionAlignment(DataRefImpl Sec) const = 0;\n  virtual bool isSectionCompressed(DataRefImpl Sec) const = 0;\n  virtual bool isSectionText(DataRefImpl Sec) const = 0;\n  virtual bool isSectionData(DataRefImpl Sec) const = 0;\n  virtual bool isSectionBSS(DataRefImpl Sec) const = 0;\n  // A section is 'virtual' if its contents aren't present in the object image.\n  virtual bool isSectionVirtual(DataRefImpl Sec) const = 0;\n  virtual bool isSectionBitcode(DataRefImpl Sec) const;\n  virtual bool isSectionStripped(DataRefImpl Sec) const;\n  virtual bool isBerkeleyText(DataRefImpl Sec) const;\n  virtual bool isBerkeleyData(DataRefImpl Sec) const;\n  virtual bool isDebugSection(StringRef SectionName) const;\n  virtual relocation_iterator section_rel_begin(DataRefImpl Sec) const = 0;\n  virtual relocation_iterator section_rel_end(DataRefImpl Sec) const = 0;\n  virtual Expected<section_iterator> getRelocatedSection(DataRefImpl Sec) const;\n\n  // Same as above for RelocationRef.\n  friend class RelocationRef;\n  virtual void moveRelocationNext(DataRefImpl &Rel) const = 0;\n  virtual uint64_t getRelocationOffset(DataRefImpl Rel) const = 0;\n  virtual symbol_iterator getRelocationSymbol(DataRefImpl Rel) const = 0;\n  virtual uint64_t getRelocationType(DataRefImpl Rel) const = 0;\n  virtual void getRelocationTypeName(DataRefImpl Rel,\n                                     SmallVectorImpl<char> &Result) const = 0;\n\n  Expected<uint64_t> getSymbolValue(DataRefImpl Symb) const;\n\npublic:\n  ObjectFile() = delete;\n  ObjectFile(const ObjectFile &other) = delete;\n\n  uint64_t getCommonSymbolSize(DataRefImpl Symb) const {\n    Expected<uint32_t> SymbolFlagsOrErr = getSymbolFlags(Symb);\n    if (!SymbolFlagsOrErr)\n      // TODO: Actually report errors helpfully.\n      report_fatal_error(SymbolFlagsOrErr.takeError());\n    assert(*SymbolFlagsOrErr & SymbolRef::SF_Common);\n    return getCommonSymbolSizeImpl(Symb);\n  }\n\n  virtual std::vector<SectionRef> dynamic_relocation_sections() const {\n    return std::vector<SectionRef>();\n  }\n\n  using symbol_iterator_range = iterator_range<symbol_iterator>;\n  symbol_iterator_range symbols() const {\n    return symbol_iterator_range(symbol_begin(), symbol_end());\n  }\n\n  virtual section_iterator section_begin() const = 0;\n  virtual section_iterator section_end() const = 0;\n\n  using section_iterator_range = iterator_range<section_iterator>;\n  section_iterator_range sections() const {\n    return section_iterator_range(section_begin(), section_end());\n  }\n\n  /// The number of bytes used to represent an address in this object\n  ///        file format.\n  virtual uint8_t getBytesInAddress() const = 0;\n\n  virtual StringRef getFileFormatName() const = 0;\n  virtual Triple::ArchType getArch() const = 0;\n  virtual SubtargetFeatures getFeatures() const = 0;\n  virtual Optional<StringRef> tryGetCPUName() const { return None; };\n  virtual void setARMSubArch(Triple &TheTriple) const { }\n  virtual Expected<uint64_t> getStartAddress() const {\n    return errorCodeToError(object_error::parse_failed);\n  };\n\n  /// Create a triple from the data in this object file.\n  Triple makeTriple() const;\n\n  /// Maps a debug section name to a standard DWARF section name.\n  virtual StringRef mapDebugSectionName(StringRef Name) const { return Name; }\n\n  /// True if this is a relocatable object (.o/.obj).\n  virtual bool isRelocatableObject() const = 0;\n\n  /// @returns Pointer to ObjectFile subclass to handle this type of object.\n  /// @param ObjectPath The path to the object file. ObjectPath.isObject must\n  ///        return true.\n  /// Create ObjectFile from path.\n  static Expected<OwningBinary<ObjectFile>>\n  createObjectFile(StringRef ObjectPath);\n\n  static Expected<std::unique_ptr<ObjectFile>>\n  createObjectFile(MemoryBufferRef Object, llvm::file_magic Type,\n                   bool InitContent = true);\n  static Expected<std::unique_ptr<ObjectFile>>\n  createObjectFile(MemoryBufferRef Object) {\n    return createObjectFile(Object, llvm::file_magic::unknown);\n  }\n\n  static bool classof(const Binary *v) {\n    return v->isObject();\n  }\n\n  static Expected<std::unique_ptr<COFFObjectFile>>\n  createCOFFObjectFile(MemoryBufferRef Object);\n\n  static Expected<std::unique_ptr<ObjectFile>>\n  createXCOFFObjectFile(MemoryBufferRef Object, unsigned FileType);\n\n  static Expected<std::unique_ptr<ObjectFile>>\n  createELFObjectFile(MemoryBufferRef Object, bool InitContent = true);\n\n  static Expected<std::unique_ptr<MachOObjectFile>>\n  createMachOObjectFile(MemoryBufferRef Object,\n                        uint32_t UniversalCputype = 0,\n                        uint32_t UniversalIndex = 0);\n\n  static Expected<std::unique_ptr<WasmObjectFile>>\n  createWasmObjectFile(MemoryBufferRef Object);\n};\n\n// Inline function definitions.\ninline SymbolRef::SymbolRef(DataRefImpl SymbolP, const ObjectFile *Owner)\n    : BasicSymbolRef(SymbolP, Owner) {}\n\ninline Expected<StringRef> SymbolRef::getName() const {\n  return getObject()->getSymbolName(getRawDataRefImpl());\n}\n\ninline Expected<uint64_t> SymbolRef::getAddress() const {\n  return getObject()->getSymbolAddress(getRawDataRefImpl());\n}\n\ninline Expected<uint64_t> SymbolRef::getValue() const {\n  return getObject()->getSymbolValue(getRawDataRefImpl());\n}\n\ninline uint32_t SymbolRef::getAlignment() const {\n  return getObject()->getSymbolAlignment(getRawDataRefImpl());\n}\n\ninline uint64_t SymbolRef::getCommonSize() const {\n  return getObject()->getCommonSymbolSize(getRawDataRefImpl());\n}\n\ninline Expected<section_iterator> SymbolRef::getSection() const {\n  return getObject()->getSymbolSection(getRawDataRefImpl());\n}\n\ninline Expected<SymbolRef::Type> SymbolRef::getType() const {\n  return getObject()->getSymbolType(getRawDataRefImpl());\n}\n\ninline const ObjectFile *SymbolRef::getObject() const {\n  const SymbolicFile *O = BasicSymbolRef::getObject();\n  return cast<ObjectFile>(O);\n}\n\n/// SectionRef\ninline SectionRef::SectionRef(DataRefImpl SectionP,\n                              const ObjectFile *Owner)\n  : SectionPimpl(SectionP)\n  , OwningObject(Owner) {}\n\ninline bool SectionRef::operator==(const SectionRef &Other) const {\n  return OwningObject == Other.OwningObject &&\n         SectionPimpl == Other.SectionPimpl;\n}\n\ninline bool SectionRef::operator!=(const SectionRef &Other) const {\n  return !(*this == Other);\n}\n\ninline bool SectionRef::operator<(const SectionRef &Other) const {\n  assert(OwningObject == Other.OwningObject);\n  return SectionPimpl < Other.SectionPimpl;\n}\n\ninline void SectionRef::moveNext() {\n  return OwningObject->moveSectionNext(SectionPimpl);\n}\n\ninline Expected<StringRef> SectionRef::getName() const {\n  return OwningObject->getSectionName(SectionPimpl);\n}\n\ninline uint64_t SectionRef::getAddress() const {\n  return OwningObject->getSectionAddress(SectionPimpl);\n}\n\ninline uint64_t SectionRef::getIndex() const {\n  return OwningObject->getSectionIndex(SectionPimpl);\n}\n\ninline uint64_t SectionRef::getSize() const {\n  return OwningObject->getSectionSize(SectionPimpl);\n}\n\ninline Expected<StringRef> SectionRef::getContents() const {\n  Expected<ArrayRef<uint8_t>> Res =\n      OwningObject->getSectionContents(SectionPimpl);\n  if (!Res)\n    return Res.takeError();\n  return StringRef(reinterpret_cast<const char *>(Res->data()), Res->size());\n}\n\ninline uint64_t SectionRef::getAlignment() const {\n  return OwningObject->getSectionAlignment(SectionPimpl);\n}\n\ninline bool SectionRef::isCompressed() const {\n  return OwningObject->isSectionCompressed(SectionPimpl);\n}\n\ninline bool SectionRef::isText() const {\n  return OwningObject->isSectionText(SectionPimpl);\n}\n\ninline bool SectionRef::isData() const {\n  return OwningObject->isSectionData(SectionPimpl);\n}\n\ninline bool SectionRef::isBSS() const {\n  return OwningObject->isSectionBSS(SectionPimpl);\n}\n\ninline bool SectionRef::isVirtual() const {\n  return OwningObject->isSectionVirtual(SectionPimpl);\n}\n\ninline bool SectionRef::isBitcode() const {\n  return OwningObject->isSectionBitcode(SectionPimpl);\n}\n\ninline bool SectionRef::isStripped() const {\n  return OwningObject->isSectionStripped(SectionPimpl);\n}\n\ninline bool SectionRef::isBerkeleyText() const {\n  return OwningObject->isBerkeleyText(SectionPimpl);\n}\n\ninline bool SectionRef::isBerkeleyData() const {\n  return OwningObject->isBerkeleyData(SectionPimpl);\n}\n\ninline bool SectionRef::isDebugSection(StringRef SectionName) const {\n  return OwningObject->isDebugSection(SectionName);\n}\n\ninline relocation_iterator SectionRef::relocation_begin() const {\n  return OwningObject->section_rel_begin(SectionPimpl);\n}\n\ninline relocation_iterator SectionRef::relocation_end() const {\n  return OwningObject->section_rel_end(SectionPimpl);\n}\n\ninline Expected<section_iterator> SectionRef::getRelocatedSection() const {\n  return OwningObject->getRelocatedSection(SectionPimpl);\n}\n\ninline DataRefImpl SectionRef::getRawDataRefImpl() const {\n  return SectionPimpl;\n}\n\ninline const ObjectFile *SectionRef::getObject() const {\n  return OwningObject;\n}\n\n/// RelocationRef\ninline RelocationRef::RelocationRef(DataRefImpl RelocationP,\n                              const ObjectFile *Owner)\n  : RelocationPimpl(RelocationP)\n  , OwningObject(Owner) {}\n\ninline bool RelocationRef::operator==(const RelocationRef &Other) const {\n  return RelocationPimpl == Other.RelocationPimpl;\n}\n\ninline void RelocationRef::moveNext() {\n  return OwningObject->moveRelocationNext(RelocationPimpl);\n}\n\ninline uint64_t RelocationRef::getOffset() const {\n  return OwningObject->getRelocationOffset(RelocationPimpl);\n}\n\ninline symbol_iterator RelocationRef::getSymbol() const {\n  return OwningObject->getRelocationSymbol(RelocationPimpl);\n}\n\ninline uint64_t RelocationRef::getType() const {\n  return OwningObject->getRelocationType(RelocationPimpl);\n}\n\ninline void RelocationRef::getTypeName(SmallVectorImpl<char> &Result) const {\n  return OwningObject->getRelocationTypeName(RelocationPimpl, Result);\n}\n\ninline DataRefImpl RelocationRef::getRawDataRefImpl() const {\n  return RelocationPimpl;\n}\n\ninline const ObjectFile *RelocationRef::getObject() const {\n  return OwningObject;\n}\n\n} // end namespace object\n\ntemplate <> struct DenseMapInfo<object::SectionRef> {\n  static bool isEqual(const object::SectionRef &A,\n                      const object::SectionRef &B) {\n    return A == B;\n  }\n  static object::SectionRef getEmptyKey() {\n    return object::SectionRef({}, nullptr);\n  }\n  static object::SectionRef getTombstoneKey() {\n    object::DataRefImpl TS;\n    TS.p = (uintptr_t)-1;\n    return object::SectionRef(TS, nullptr);\n  }\n  static unsigned getHashValue(const object::SectionRef &Sec) {\n    object::DataRefImpl Raw = Sec.getRawDataRefImpl();\n    return hash_combine(Raw.p, Raw.d.a, Raw.d.b);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_OBJECTFILE_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "content": "//===- SymbolicFile.h - Interface that only provides symbols ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SymbolicFile interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_SYMBOLICFILE_H\n#define LLVM_OBJECT_SYMBOLICFILE_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Magic.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cinttypes>\n#include <cstdint>\n#include <cstring>\n#include <iterator>\n#include <memory>\n#include <system_error>\n\nnamespace llvm {\nnamespace object {\n\nunion DataRefImpl {\n  // This entire union should probably be a\n  // char[max(8, sizeof(uintptr_t))] and require the impl to cast.\n  struct {\n    uint32_t a, b;\n  } d;\n  uintptr_t p;\n\n  DataRefImpl() { std::memset(this, 0, sizeof(DataRefImpl)); }\n};\n\ntemplate <typename OStream>\nOStream& operator<<(OStream &OS, const DataRefImpl &D) {\n  OS << \"(\" << format(\"0x%08\" PRIxPTR, D.p) << \" (\" << format(\"0x%08x\", D.d.a)\n     << \", \" << format(\"0x%08x\", D.d.b) << \"))\";\n  return OS;\n}\n\ninline bool operator==(const DataRefImpl &a, const DataRefImpl &b) {\n  // Check bitwise identical. This is the only legal way to compare a union w/o\n  // knowing which member is in use.\n  return std::memcmp(&a, &b, sizeof(DataRefImpl)) == 0;\n}\n\ninline bool operator!=(const DataRefImpl &a, const DataRefImpl &b) {\n  return !operator==(a, b);\n}\n\ninline bool operator<(const DataRefImpl &a, const DataRefImpl &b) {\n  // Check bitwise identical. This is the only legal way to compare a union w/o\n  // knowing which member is in use.\n  return std::memcmp(&a, &b, sizeof(DataRefImpl)) < 0;\n}\n\ntemplate <class content_type>\nclass content_iterator\n    : public std::iterator<std::forward_iterator_tag, content_type> {\n  content_type Current;\n\npublic:\n  content_iterator(content_type symb) : Current(std::move(symb)) {}\n\n  const content_type *operator->() const { return &Current; }\n\n  const content_type &operator*() const { return Current; }\n\n  bool operator==(const content_iterator &other) const {\n    return Current == other.Current;\n  }\n\n  bool operator!=(const content_iterator &other) const {\n    return !(*this == other);\n  }\n\n  content_iterator &operator++() { // preincrement\n    Current.moveNext();\n    return *this;\n  }\n};\n\nclass SymbolicFile;\n\n/// This is a value type class that represents a single symbol in the list of\n/// symbols in the object file.\nclass BasicSymbolRef {\n  DataRefImpl SymbolPimpl;\n  const SymbolicFile *OwningObject = nullptr;\n\npublic:\n  enum Flags : unsigned {\n    SF_None = 0,\n    SF_Undefined = 1U << 0,      // Symbol is defined in another object file\n    SF_Global = 1U << 1,         // Global symbol\n    SF_Weak = 1U << 2,           // Weak symbol\n    SF_Absolute = 1U << 3,       // Absolute symbol\n    SF_Common = 1U << 4,         // Symbol has common linkage\n    SF_Indirect = 1U << 5,       // Symbol is an alias to another symbol\n    SF_Exported = 1U << 6,       // Symbol is visible to other DSOs\n    SF_FormatSpecific = 1U << 7, // Specific to the object file format\n                                 // (e.g. section symbols)\n    SF_Thumb = 1U << 8,          // Thumb symbol in a 32-bit ARM binary\n    SF_Hidden = 1U << 9,         // Symbol has hidden visibility\n    SF_Const = 1U << 10,         // Symbol value is constant\n    SF_Executable = 1U << 11,    // Symbol points to an executable section\n                                 // (IR only)\n  };\n\n  BasicSymbolRef() = default;\n  BasicSymbolRef(DataRefImpl SymbolP, const SymbolicFile *Owner);\n\n  bool operator==(const BasicSymbolRef &Other) const;\n  bool operator<(const BasicSymbolRef &Other) const;\n\n  void moveNext();\n\n  Error printName(raw_ostream &OS) const;\n\n  /// Get symbol flags (bitwise OR of SymbolRef::Flags)\n  Expected<uint32_t> getFlags() const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const SymbolicFile *getObject() const;\n};\n\nusing basic_symbol_iterator = content_iterator<BasicSymbolRef>;\n\nclass SymbolicFile : public Binary {\npublic:\n  SymbolicFile(unsigned int Type, MemoryBufferRef Source);\n  ~SymbolicFile() override;\n\n  // virtual interface.\n  virtual void moveSymbolNext(DataRefImpl &Symb) const = 0;\n\n  virtual Error printSymbolName(raw_ostream &OS, DataRefImpl Symb) const = 0;\n\n  virtual Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const = 0;\n\n  virtual basic_symbol_iterator symbol_begin() const = 0;\n\n  virtual basic_symbol_iterator symbol_end() const = 0;\n\n  // convenience wrappers.\n  using basic_symbol_iterator_range = iterator_range<basic_symbol_iterator>;\n  basic_symbol_iterator_range symbols() const {\n    return basic_symbol_iterator_range(symbol_begin(), symbol_end());\n  }\n\n  // construction aux.\n  static Expected<std::unique_ptr<SymbolicFile>>\n  createSymbolicFile(MemoryBufferRef Object, llvm::file_magic Type,\n                     LLVMContext *Context, bool InitContent = true);\n\n  static Expected<std::unique_ptr<SymbolicFile>>\n  createSymbolicFile(MemoryBufferRef Object) {\n    return createSymbolicFile(Object, llvm::file_magic::unknown, nullptr);\n  }\n\n  static bool classof(const Binary *v) {\n    return v->isSymbolic();\n  }\n\n  static bool isSymbolicFile(file_magic Type, const LLVMContext *Context);\n};\n\ninline BasicSymbolRef::BasicSymbolRef(DataRefImpl SymbolP,\n                                      const SymbolicFile *Owner)\n    : SymbolPimpl(SymbolP), OwningObject(Owner) {}\n\ninline bool BasicSymbolRef::operator==(const BasicSymbolRef &Other) const {\n  return SymbolPimpl == Other.SymbolPimpl;\n}\n\ninline bool BasicSymbolRef::operator<(const BasicSymbolRef &Other) const {\n  return SymbolPimpl < Other.SymbolPimpl;\n}\n\ninline void BasicSymbolRef::moveNext() {\n  return OwningObject->moveSymbolNext(SymbolPimpl);\n}\n\ninline Error BasicSymbolRef::printName(raw_ostream &OS) const {\n  return OwningObject->printSymbolName(OS, SymbolPimpl);\n}\n\ninline Expected<uint32_t> BasicSymbolRef::getFlags() const {\n  return OwningObject->getSymbolFlags(SymbolPimpl);\n}\n\ninline DataRefImpl BasicSymbolRef::getRawDataRefImpl() const {\n  return SymbolPimpl;\n}\n\ninline const SymbolicFile *BasicSymbolRef::getObject() const {\n  return OwningObject;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_SYMBOLICFILE_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMAttributeParser.h", "content": "//===- ARMAttributeParser.h - ARM Attribute Information Printer -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ARMATTRIBUTEPARSER_H\n#define LLVM_SUPPORT_ARMATTRIBUTEPARSER_H\n\n#include \"ARMBuildAttributes.h\"\n#include \"ELFAttributeParser.h\"\n#include \"ScopedPrinter.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\nclass StringRef;\n\nclass ARMAttributeParser : public ELFAttributeParser {\n  struct DisplayHandler {\n    ARMBuildAttrs::AttrType attribute;\n    Error (ARMAttributeParser::*routine)(ARMBuildAttrs::AttrType);\n  };\n  static const DisplayHandler displayRoutines[];\n\n  Error handler(uint64_t tag, bool &handled) override;\n\n  Error stringAttribute(ARMBuildAttrs::AttrType tag);\n\n  Error CPU_arch(ARMBuildAttrs::AttrType tag);\n  Error CPU_arch_profile(ARMBuildAttrs::AttrType tag);\n  Error ARM_ISA_use(ARMBuildAttrs::AttrType tag);\n  Error THUMB_ISA_use(ARMBuildAttrs::AttrType tag);\n  Error FP_arch(ARMBuildAttrs::AttrType tag);\n  Error WMMX_arch(ARMBuildAttrs::AttrType tag);\n  Error Advanced_SIMD_arch(ARMBuildAttrs::AttrType tag);\n  Error MVE_arch(ARMBuildAttrs::AttrType tag);\n  Error PCS_config(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_R9_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_RW_data(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_RO_data(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_GOT_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_wchar_t(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_rounding(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_denormal(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_exceptions(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_user_exceptions(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_number_model(ARMBuildAttrs::AttrType tag);\n  Error ABI_align_needed(ARMBuildAttrs::AttrType tag);\n  Error ABI_align_preserved(ARMBuildAttrs::AttrType tag);\n  Error ABI_enum_size(ARMBuildAttrs::AttrType tag);\n  Error ABI_HardFP_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_VFP_args(ARMBuildAttrs::AttrType tag);\n  Error ABI_WMMX_args(ARMBuildAttrs::AttrType tag);\n  Error ABI_optimization_goals(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_optimization_goals(ARMBuildAttrs::AttrType tag);\n  Error compatibility(ARMBuildAttrs::AttrType tag);\n  Error CPU_unaligned_access(ARMBuildAttrs::AttrType tag);\n  Error FP_HP_extension(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_16bit_format(ARMBuildAttrs::AttrType tag);\n  Error MPextension_use(ARMBuildAttrs::AttrType tag);\n  Error DIV_use(ARMBuildAttrs::AttrType tag);\n  Error DSP_extension(ARMBuildAttrs::AttrType tag);\n  Error T2EE_use(ARMBuildAttrs::AttrType tag);\n  Error Virtualization_use(ARMBuildAttrs::AttrType tag);\n  Error nodefaults(ARMBuildAttrs::AttrType tag);\n\npublic:\n  ARMAttributeParser(ScopedPrinter *sw)\n      : ELFAttributeParser(sw, ARMBuildAttrs::ARMAttributeTags, \"aeabi\") {}\n  ARMAttributeParser()\n      : ELFAttributeParser(ARMBuildAttrs::ARMAttributeTags, \"aeabi\") {}\n};\n}\n\n#endif\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ScopedPrinter.h", "content": "//===-- ScopedPrinter.h ----------------------------------------*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SCOPEDPRINTER_H\n#define LLVM_SUPPORT_SCOPEDPRINTER_H\n\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n\nnamespace llvm {\n\ntemplate <typename T> struct EnumEntry {\n  StringRef Name;\n  // While Name suffices in most of the cases, in certain cases\n  // GNU style and LLVM style of ELFDumper do not\n  // display same string for same enum. The AltName if initialized appropriately\n  // will hold the string that GNU style emits.\n  // Example:\n  // \"EM_X86_64\" string on LLVM style for Elf_Ehdr->e_machine corresponds to\n  // \"Advanced Micro Devices X86-64\" on GNU style\n  StringRef AltName;\n  T Value;\n  EnumEntry(StringRef N, StringRef A, T V) : Name(N), AltName(A), Value(V) {}\n  EnumEntry(StringRef N, T V) : Name(N), AltName(N), Value(V) {}\n};\n\nstruct HexNumber {\n  // To avoid sign-extension we have to explicitly cast to the appropriate\n  // unsigned type. The overloads are here so that every type that is implicitly\n  // convertible to an integer (including enums and endian helpers) can be used\n  // without requiring type traits or call-site changes.\n  HexNumber(char Value) : Value(static_cast<unsigned char>(Value)) {}\n  HexNumber(signed char Value) : Value(static_cast<unsigned char>(Value)) {}\n  HexNumber(signed short Value) : Value(static_cast<unsigned short>(Value)) {}\n  HexNumber(signed int Value) : Value(static_cast<unsigned int>(Value)) {}\n  HexNumber(signed long Value) : Value(static_cast<unsigned long>(Value)) {}\n  HexNumber(signed long long Value)\n      : Value(static_cast<unsigned long long>(Value)) {}\n  HexNumber(unsigned char Value) : Value(Value) {}\n  HexNumber(unsigned short Value) : Value(Value) {}\n  HexNumber(unsigned int Value) : Value(Value) {}\n  HexNumber(unsigned long Value) : Value(Value) {}\n  HexNumber(unsigned long long Value) : Value(Value) {}\n  uint64_t Value;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const HexNumber &Value);\nstd::string to_hexString(uint64_t Value, bool UpperCase = true);\n\ntemplate <class T> std::string to_string(const T &Value) {\n  std::string number;\n  llvm::raw_string_ostream stream(number);\n  stream << Value;\n  return stream.str();\n}\n\nclass ScopedPrinter {\npublic:\n  ScopedPrinter(raw_ostream &OS) : OS(OS), IndentLevel(0) {}\n\n  void flush() { OS.flush(); }\n\n  void indent(int Levels = 1) { IndentLevel += Levels; }\n\n  void unindent(int Levels = 1) {\n    IndentLevel = std::max(0, IndentLevel - Levels);\n  }\n\n  void resetIndent() { IndentLevel = 0; }\n\n  int getIndentLevel() { return IndentLevel; }\n\n  void setPrefix(StringRef P) { Prefix = P; }\n\n  void printIndent() {\n    OS << Prefix;\n    for (int i = 0; i < IndentLevel; ++i)\n      OS << \"  \";\n  }\n\n  template <typename T> HexNumber hex(T Value) { return HexNumber(Value); }\n\n  template <typename T, typename TEnum>\n  void printEnum(StringRef Label, T Value,\n                 ArrayRef<EnumEntry<TEnum>> EnumValues) {\n    StringRef Name;\n    bool Found = false;\n    for (const auto &EnumItem : EnumValues) {\n      if (EnumItem.Value == Value) {\n        Name = EnumItem.Name;\n        Found = true;\n        break;\n      }\n    }\n\n    if (Found) {\n      startLine() << Label << \": \" << Name << \" (\" << hex(Value) << \")\\n\";\n    } else {\n      startLine() << Label << \": \" << hex(Value) << \"\\n\";\n    }\n  }\n\n  template <typename T, typename TFlag>\n  void printFlags(StringRef Label, T Value, ArrayRef<EnumEntry<TFlag>> Flags,\n                  TFlag EnumMask1 = {}, TFlag EnumMask2 = {},\n                  TFlag EnumMask3 = {}) {\n    typedef EnumEntry<TFlag> FlagEntry;\n    typedef SmallVector<FlagEntry, 10> FlagVector;\n    FlagVector SetFlags;\n\n    for (const auto &Flag : Flags) {\n      if (Flag.Value == 0)\n        continue;\n\n      TFlag EnumMask{};\n      if (Flag.Value & EnumMask1)\n        EnumMask = EnumMask1;\n      else if (Flag.Value & EnumMask2)\n        EnumMask = EnumMask2;\n      else if (Flag.Value & EnumMask3)\n        EnumMask = EnumMask3;\n      bool IsEnum = (Flag.Value & EnumMask) != 0;\n      if ((!IsEnum && (Value & Flag.Value) == Flag.Value) ||\n          (IsEnum && (Value & EnumMask) == Flag.Value)) {\n        SetFlags.push_back(Flag);\n      }\n    }\n\n    llvm::sort(SetFlags, &flagName<TFlag>);\n\n    startLine() << Label << \" [ (\" << hex(Value) << \")\\n\";\n    for (const auto &Flag : SetFlags) {\n      startLine() << \"  \" << Flag.Name << \" (\" << hex(Flag.Value) << \")\\n\";\n    }\n    startLine() << \"]\\n\";\n  }\n\n  template <typename T> void printFlags(StringRef Label, T Value) {\n    startLine() << Label << \" [ (\" << hex(Value) << \")\\n\";\n    uint64_t Flag = 1;\n    uint64_t Curr = Value;\n    while (Curr > 0) {\n      if (Curr & 1)\n        startLine() << \"  \" << hex(Flag) << \"\\n\";\n      Curr >>= 1;\n      Flag <<= 1;\n    }\n    startLine() << \"]\\n\";\n  }\n\n  void printNumber(StringRef Label, uint64_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, uint32_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, uint16_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, uint8_t Value) {\n    startLine() << Label << \": \" << unsigned(Value) << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, int64_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, int32_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, int16_t Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, int8_t Value) {\n    startLine() << Label << \": \" << int(Value) << \"\\n\";\n  }\n\n  void printNumber(StringRef Label, const APSInt &Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printBoolean(StringRef Label, bool Value) {\n    startLine() << Label << \": \" << (Value ? \"Yes\" : \"No\") << '\\n';\n  }\n\n  template <typename... T> void printVersion(StringRef Label, T... Version) {\n    startLine() << Label << \": \";\n    printVersionInternal(Version...);\n    getOStream() << \"\\n\";\n  }\n\n  template <typename T> void printList(StringRef Label, const T &List) {\n    startLine() << Label << \": [\";\n    ListSeparator LS;\n    for (const auto &Item : List)\n      OS << LS << Item;\n    OS << \"]\\n\";\n  }\n\n  template <typename T, typename U>\n  void printList(StringRef Label, const T &List, const U &Printer) {\n    startLine() << Label << \": [\";\n    ListSeparator LS;\n    for (const auto &Item : List) {\n      OS << LS;\n      Printer(OS, Item);\n    }\n    OS << \"]\\n\";\n  }\n\n  template <typename T> void printHexList(StringRef Label, const T &List) {\n    startLine() << Label << \": [\";\n    ListSeparator LS;\n    for (const auto &Item : List)\n      OS << LS << hex(Item);\n    OS << \"]\\n\";\n  }\n\n  template <typename T> void printHex(StringRef Label, T Value) {\n    startLine() << Label << \": \" << hex(Value) << \"\\n\";\n  }\n\n  template <typename T> void printHex(StringRef Label, StringRef Str, T Value) {\n    startLine() << Label << \": \" << Str << \" (\" << hex(Value) << \")\\n\";\n  }\n\n  template <typename T>\n  void printSymbolOffset(StringRef Label, StringRef Symbol, T Value) {\n    startLine() << Label << \": \" << Symbol << '+' << hex(Value) << '\\n';\n  }\n\n  void printString(StringRef Value) { startLine() << Value << \"\\n\"; }\n\n  void printString(StringRef Label, StringRef Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  void printString(StringRef Label, const std::string &Value) {\n    printString(Label, StringRef(Value));\n  }\n\n  void printString(StringRef Label, const char* Value) {\n    printString(Label, StringRef(Value));\n  }\n\n  template <typename T>\n  void printNumber(StringRef Label, StringRef Str, T Value) {\n    startLine() << Label << \": \" << Str << \" (\" << Value << \")\\n\";\n  }\n\n  void printBinary(StringRef Label, StringRef Str, ArrayRef<uint8_t> Value) {\n    printBinaryImpl(Label, Str, Value, false);\n  }\n\n  void printBinary(StringRef Label, StringRef Str, ArrayRef<char> Value) {\n    auto V = makeArrayRef(reinterpret_cast<const uint8_t *>(Value.data()),\n                          Value.size());\n    printBinaryImpl(Label, Str, V, false);\n  }\n\n  void printBinary(StringRef Label, ArrayRef<uint8_t> Value) {\n    printBinaryImpl(Label, StringRef(), Value, false);\n  }\n\n  void printBinary(StringRef Label, ArrayRef<char> Value) {\n    auto V = makeArrayRef(reinterpret_cast<const uint8_t *>(Value.data()),\n                          Value.size());\n    printBinaryImpl(Label, StringRef(), V, false);\n  }\n\n  void printBinary(StringRef Label, StringRef Value) {\n    auto V = makeArrayRef(reinterpret_cast<const uint8_t *>(Value.data()),\n                          Value.size());\n    printBinaryImpl(Label, StringRef(), V, false);\n  }\n\n  void printBinaryBlock(StringRef Label, ArrayRef<uint8_t> Value,\n                        uint32_t StartOffset) {\n    printBinaryImpl(Label, StringRef(), Value, true, StartOffset);\n  }\n\n  void printBinaryBlock(StringRef Label, ArrayRef<uint8_t> Value) {\n    printBinaryImpl(Label, StringRef(), Value, true);\n  }\n\n  void printBinaryBlock(StringRef Label, StringRef Value) {\n    auto V = makeArrayRef(reinterpret_cast<const uint8_t *>(Value.data()),\n                          Value.size());\n    printBinaryImpl(Label, StringRef(), V, true);\n  }\n\n  template <typename T> void printObject(StringRef Label, const T &Value) {\n    startLine() << Label << \": \" << Value << \"\\n\";\n  }\n\n  raw_ostream &startLine() {\n    printIndent();\n    return OS;\n  }\n\n  raw_ostream &getOStream() { return OS; }\n\nprivate:\n  template <typename T> void printVersionInternal(T Value) {\n    getOStream() << Value;\n  }\n\n  template <typename S, typename T, typename... TArgs>\n  void printVersionInternal(S Value, T Value2, TArgs... Args) {\n    getOStream() << Value << \".\";\n    printVersionInternal(Value2, Args...);\n  }\n\n  template <typename T>\n  static bool flagName(const EnumEntry<T> &lhs, const EnumEntry<T> &rhs) {\n    return lhs.Name < rhs.Name;\n  }\n\n  void printBinaryImpl(StringRef Label, StringRef Str, ArrayRef<uint8_t> Value,\n                       bool Block, uint32_t StartOffset = 0);\n\n  raw_ostream &OS;\n  int IndentLevel;\n  StringRef Prefix;\n};\n\ntemplate <>\ninline void\nScopedPrinter::printHex<support::ulittle16_t>(StringRef Label,\n                                              support::ulittle16_t Value) {\n  startLine() << Label << \": \" << hex(Value) << \"\\n\";\n}\n\ntemplate<char Open, char Close>\nstruct DelimitedScope {\n  explicit DelimitedScope(ScopedPrinter &W) : W(W) {\n    W.startLine() << Open << '\\n';\n    W.indent();\n  }\n\n  DelimitedScope(ScopedPrinter &W, StringRef N) : W(W) {\n    W.startLine() << N;\n    if (!N.empty())\n      W.getOStream() << ' ';\n    W.getOStream() << Open << '\\n';\n    W.indent();\n  }\n\n  ~DelimitedScope() {\n    W.unindent();\n    W.startLine() << Close << '\\n';\n  }\n\n  ScopedPrinter &W;\n};\n\nusing DictScope = DelimitedScope<'{', '}'>;\nusing ListScope = DelimitedScope<'[', ']'>;\n\n} // namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 3, "line": 358}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 358}, "message": "default constructor 'DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "9314d99df9e627ec6be9633552a7ed60", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 3, "line": 730}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 3, "line": 730}, "message": "default constructor 'DenseMap<KeyT, ValueT, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "7479231c070a640d35c4e840b7463387", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 737}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 737}, "message": "move constructor 'DenseMap<KeyT, ValueT, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "4fdfbe30c39c43f5c5b3e54270c9819c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 753}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 753}, "message": "destructor '~DenseMap<KeyT, ValueT, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "a6ff4d948fef9c7318a1e5eff533ce32", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 758}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 3, "line": 758}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "03650cc8c215b611c291b20d08aebdb7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 3, "line": 773}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 3, "line": 773}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "8df5d98c2df08e030d01759a4928e4d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 3, "line": 907}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 3, "line": 907}, "message": "default constructor 'SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "5b641399bf7656cdadac9066d5e501f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 916}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 916}, "message": "move constructor 'SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "05221992f39bf1d76c15cf41c723ed55", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 927}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 927}, "message": "destructor '~SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "324a9d7e195ab34cd53793b6f2115305", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 932}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 3, "line": 932}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "51a530db05681b1fbd9ce60f5b5df3e3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 3, "line": 1010}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 3, "line": 1010}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "fa6bbd2d6f26d7136f628c3a43d818e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 1206}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 1206}, "message": "default constructor 'DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConst>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "9b89250ac249ebf29849ec4c99c82319", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 6, "line": 51}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 6, "line": 51}, "message": "default constructor 'PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h", "reportHash": "3d8cd141257d1dda34e5d3e794e89f04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 12, "line": 268}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 12, "line": 268}, "message": "default constructor 'Triple' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Triple.h", "reportHash": "5342d26fe9c8d4fae2e8e84e049c0ea7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 14, "line": 58}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 14, "line": 58}, "message": "default constructor 'ilist_node_impl<OptionsT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "c34ce7c5bca5a52973078ed5ebf0cf6a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 14, "line": 238}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 14, "line": 238}, "message": "default constructor 'ilist_sentinel<OptionsT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "ed5619572f9e32452ba91edfd155468c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 14, "line": 258}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 14, "line": 258}, "message": "default constructor 'ilist_node_with_parent<NodeTy, ParentTy, Options...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "8a639a41b9ddf2591388ce69d51d9fa1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 47}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 47}, "message": "default constructor 'DILineInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "e829d97f02ee3368921ae6ba2284a93f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 123}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 123}, "message": "default constructor 'DIGlobal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "5aa0613643d46075bc66d717ee6f9020", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 158}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 158}, "message": "default constructor 'DILineInfoSpecifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "4f50f00d242011c6b4c694e3bff34f4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 187}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 16, "line": 187}, "message": "default constructor 'DIDumpOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "46ddfdf1f819f1d46d740f291da754f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 309}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 309}, "message": "default constructor 'LoadedObjectInfoHelper<Derived, Base>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "8e1ed75e38f8ff4d94a5533238abbb21", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 313}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 313}, "message": "default constructor 'LoadedObjectInfoHelper<Derived, Base>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "5541f5041fecb13a8728249c46bd927d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 17, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 17, "line": 86}, "message": "default constructor 'DWARFAbbreviationDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "0fed9592235595820e1cf83f2a86f6ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 18, "line": 33}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 18, "line": 33}, "message": "default constructor 'DWARFAbbreviationDeclarationSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAbbrev.h", "reportHash": "19d27e5c01fb04fe46d7113c699c7ec3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 18, "line": 63}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 18, "line": 63}, "message": "default constructor 'DWARFDebugAbbrev' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAbbrev.h", "reportHash": "143488caca17b1a73857b474d039e55a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 67}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 67}, "message": "default constructor 'DWARFDebugRangeList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRangeList.h", "reportHash": "d0e8059fe09f29ffe552ab7b5a45d2cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 20, "line": 62}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 20, "line": 62}, "message": "default constructor 'DWARFDebugRnglistTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRnglists.h", "reportHash": "dad0f9a8c59b246d9757ec20dca06417", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 21, "line": 321}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 21, "line": 321}, "message": "default constructor 'attribute_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "10070ab79871545c557303f90c96994f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 22, "line": 43}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 22, "line": 43}, "message": "default constructor 'ValueType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "88c1c2c38bef32c0f86dffa36c874544", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 67}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 67}, "message": "default constructor 'DWARFFormValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h", "reportHash": "565bde8c585e386be61fc9826842350c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 23, "line": 645}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 23, "line": 645}, "message": "default constructor 'MCTargetExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "reportHash": "433f630c08f5b69a7252c9fe52f0208d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 84}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 84}, "message": "default constructor 'MCFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "c23078bef389e30c431774f00350552b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 244}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 244}, "message": "default constructor 'MCDataFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "c8734abebb63a41615b7d5a1a79e863a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 24, "line": 259}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 24, "line": 259}, "message": "default constructor 'MCCompactEncodedInstFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "9b6b757882c4e5ad6d15c05e0dc898fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 25, "line": 57}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 25, "line": 57}, "message": "default constructor 'MCOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "93c7c8d7cb963437bbaad199cf16260e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 26, "line": 187}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 26, "line": 187}, "message": "default constructor 'SubtargetFeatures' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/SubtargetFeature.h", "reportHash": "1e71c75baf9986c9fd40a5c1569d4014", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 90}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 27, "line": 90}, "message": "default constructor 'Binary' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "8af261789de9a74c57108ce17f4f5ec4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 191}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 27, "line": 191}, "message": "default constructor 'OwningBinary<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "21efdb3947ca1c5f59153b4459a813f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 193}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 27, "line": 193}, "message": "move constructor 'OwningBinary<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "85c4397b277834ce7e445401c7cab014", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 27, "line": 194}, "message": "mark 'noexcept'"}, {"location": {"col": 20, "file": 27, "line": 194}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "2ffd326078b8951738d062c055245ea9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 27, "line": 207}, "message": "mark 'noexcept'"}, {"location": {"col": 40, "file": 27, "line": 207}, "message": "default constructor 'OwningBinary<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "92fd56fc44e223b0bb516028a791ac53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 27, "line": 210}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 27, "line": 210}, "message": "move constructor 'OwningBinary<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "ce045407ce1ed3286328e40cba08d11d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 27, "line": 214}, "message": "mark 'noexcept'"}, {"location": {"col": 35, "file": 27, "line": 214}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "dfd73af316f1a5ab3c195320139f3ff1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 28, "line": 395}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 28, "line": 395}, "message": "move constructor 'ELFObjectFile<ELFT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "reportHash": "77e2ec6c54626b77c29772c2de0df928", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 28, "line": 1077}, "message": "mark 'noexcept'"}, {"location": {"col": 22, "file": 28, "line": 1077}, "message": "move constructor 'ELFObjectFile<ELFT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "reportHash": "ca6be472a75d14d01d3830ec9950667a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 698}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 698}, "message": "default constructor 'Elf_Note_Iterator_Impl<ELFT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFTypes.h", "reportHash": "d49d92dd281a1792551f7a2a4d29bf87", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 57}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 30, "line": 57}, "message": "default constructor 'BinaryError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Error.h", "reportHash": "01fe204c09d96456489a90923cfded28", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 56}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 56}, "message": "default constructor 'RelocationRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "e5f95a6134e745207c3514d40d1b1c5d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 87}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 87}, "message": "default constructor 'SectionRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "3483498d5381533ef5af9a8652aa0f64", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 294}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 294}, "message": "default constructor 'ObjectFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ObjectFile.h", "reportHash": "271076a2a7cd926903a8e825bdd16cbd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 32, "line": 41}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 32, "line": 41}, "message": "default constructor 'DataRefImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/SymbolicFile.h", "reportHash": "f7eb9dc0c2efccbc36c03b32ec0c0965", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 75}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 75}, "message": "default constructor 'ARMAttributeParser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMAttributeParser.h", "reportHash": "801b539ed7b045b7472eba59f8821903", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 39, "line": 366}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 39, "line": 366}, "message": "destructor '~DelimitedScope<Open, Close>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ScopedPrinter.h", "reportHash": "1198a97214d72cca9cce60046626a6c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
