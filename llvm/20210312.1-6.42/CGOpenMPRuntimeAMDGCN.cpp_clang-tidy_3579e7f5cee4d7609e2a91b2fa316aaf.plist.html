<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTFwd.h", "content": "//===--- ASTFwd.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===--------------------------------------------------------------===//\n///\n/// \\file\n/// Forward declaration of all AST node types.\n///\n//===-------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTFWD_H\n#define LLVM_CLANG_AST_ASTFWD_H\n\nnamespace clang {\n\nclass Decl;\n#define DECL(DERIVED, BASE) class DERIVED##Decl;\n#include \"clang/AST/DeclNodes.inc\"\nclass Stmt;\n#define STMT(DERIVED, BASE) class DERIVED;\n#include \"clang/AST/StmtNodes.inc\"\nclass Type;\n#define TYPE(DERIVED, BASE) class DERIVED##Type;\n#include \"clang/AST/TypeNodes.inc\"\nclass CXXCtorInitializer;\nclass OMPClause;\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) class Class;\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n\n} // end namespace clang\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CXXInheritance.h", "content": "//===- CXXInheritance.h - C++ Inheritance -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides routines that help analyzing C++ inheritance hierarchies.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_CXXINHERITANCE_H\n#define LLVM_CLANG_AST_CXXINHERITANCE_H\n\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <list>\n#include <memory>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass NamedDecl;\n\n/// Represents an element in a path from a derived class to a\n/// base class.\n///\n/// Each step in the path references the link from a\n/// derived class to one of its direct base classes, along with a\n/// base \"number\" that identifies which base subobject of the\n/// original derived class we are referencing.\nstruct CXXBasePathElement {\n  /// The base specifier that states the link from a derived\n  /// class to a base class, which will be followed by this base\n  /// path element.\n  const CXXBaseSpecifier *Base;\n\n  /// The record decl of the class that the base is a base of.\n  const CXXRecordDecl *Class;\n\n  /// Identifies which base class subobject (of type\n  /// \\c Base->getType()) this base path element refers to.\n  ///\n  /// This value is only valid if \\c !Base->isVirtual(), because there\n  /// is no base numbering for the zero or one virtual bases of a\n  /// given type.\n  int SubobjectNumber;\n};\n\n/// Represents a path from a specific derived class\n/// (which is not represented as part of the path) to a particular\n/// (direct or indirect) base class subobject.\n///\n/// Individual elements in the path are described by the \\c CXXBasePathElement\n/// structure, which captures both the link from a derived class to one of its\n/// direct bases and identification describing which base class\n/// subobject is being used.\nclass CXXBasePath : public SmallVector<CXXBasePathElement, 4> {\npublic:\n  /// The access along this inheritance path.  This is only\n  /// calculated when recording paths.  AS_none is a special value\n  /// used to indicate a path which permits no legal access.\n  AccessSpecifier Access = AS_public;\n\n  CXXBasePath() = default;\n\n  /// The set of declarations found inside this base class\n  /// subobject.\n  DeclContext::lookup_result Decls;\n\n  void clear() {\n    SmallVectorImpl<CXXBasePathElement>::clear();\n    Access = AS_public;\n  }\n};\n\n/// BasePaths - Represents the set of paths from a derived class to\n/// one of its (direct or indirect) bases. For example, given the\n/// following class hierarchy:\n///\n/// @code\n/// class A { };\n/// class B : public A { };\n/// class C : public A { };\n/// class D : public B, public C{ };\n/// @endcode\n///\n/// There are two potential BasePaths to represent paths from D to a\n/// base subobject of type A. One path is (D,0) -> (B,0) -> (A,0)\n/// and another is (D,0)->(C,0)->(A,1). These two paths actually\n/// refer to two different base class subobjects of the same type,\n/// so the BasePaths object refers to an ambiguous path. On the\n/// other hand, consider the following class hierarchy:\n///\n/// @code\n/// class A { };\n/// class B : public virtual A { };\n/// class C : public virtual A { };\n/// class D : public B, public C{ };\n/// @endcode\n///\n/// Here, there are two potential BasePaths again, (D, 0) -> (B, 0)\n/// -> (A,v) and (D, 0) -> (C, 0) -> (A, v), but since both of them\n/// refer to the same base class subobject of type A (the virtual\n/// one), there is no ambiguity.\nclass CXXBasePaths {\n  friend class CXXRecordDecl;\n\n  /// The type from which this search originated.\n  const CXXRecordDecl *Origin = nullptr;\n\n  /// Paths - The actual set of paths that can be taken from the\n  /// derived class to the same base class.\n  std::list<CXXBasePath> Paths;\n\n  /// ClassSubobjects - Records the class subobjects for each class\n  /// type that we've seen. The first element IsVirtBase says\n  /// whether we found a path to a virtual base for that class type,\n  /// while NumberOfNonVirtBases contains the number of non-virtual base\n  /// class subobjects for that class type. The key of the map is\n  /// the cv-unqualified canonical type of the base class subobject.\n  struct IsVirtBaseAndNumberNonVirtBases {\n    unsigned IsVirtBase : 1;\n    unsigned NumberOfNonVirtBases : 31;\n  };\n  llvm::SmallDenseMap<QualType, IsVirtBaseAndNumberNonVirtBases, 8>\n      ClassSubobjects;\n\n  /// VisitedDependentRecords - Records the dependent records that have been\n  /// already visited.\n  llvm::SmallPtrSet<const CXXRecordDecl *, 4> VisitedDependentRecords;\n\n  /// DetectedVirtual - The base class that is virtual.\n  const RecordType *DetectedVirtual = nullptr;\n\n  /// ScratchPath - A BasePath that is used by Sema::lookupInBases\n  /// to help build the set of paths.\n  CXXBasePath ScratchPath;\n\n  /// FindAmbiguities - Whether Sema::IsDerivedFrom should try find\n  /// ambiguous paths while it is looking for a path from a derived\n  /// type to a base type.\n  bool FindAmbiguities;\n\n  /// RecordPaths - Whether Sema::IsDerivedFrom should record paths\n  /// while it is determining whether there are paths from a derived\n  /// type to a base type.\n  bool RecordPaths;\n\n  /// DetectVirtual - Whether Sema::IsDerivedFrom should abort the search\n  /// if it finds a path that goes across a virtual base. The virtual class\n  /// is also recorded.\n  bool DetectVirtual;\n\n  bool lookupInBases(ASTContext &Context, const CXXRecordDecl *Record,\n                     CXXRecordDecl::BaseMatchesCallback BaseMatches,\n                     bool LookupInDependent = false);\n\npublic:\n  using paths_iterator = std::list<CXXBasePath>::iterator;\n  using const_paths_iterator = std::list<CXXBasePath>::const_iterator;\n  using decl_iterator = NamedDecl **;\n\n  /// BasePaths - Construct a new BasePaths structure to record the\n  /// paths for a derived-to-base search.\n  explicit CXXBasePaths(bool FindAmbiguities = true, bool RecordPaths = true,\n                        bool DetectVirtual = true)\n      : FindAmbiguities(FindAmbiguities), RecordPaths(RecordPaths),\n        DetectVirtual(DetectVirtual) {}\n\n  paths_iterator begin() { return Paths.begin(); }\n  paths_iterator end()   { return Paths.end(); }\n  const_paths_iterator begin() const { return Paths.begin(); }\n  const_paths_iterator end()   const { return Paths.end(); }\n\n  CXXBasePath&       front()       { return Paths.front(); }\n  const CXXBasePath& front() const { return Paths.front(); }\n\n  using decl_range = llvm::iterator_range<decl_iterator>;\n\n  /// Determine whether the path from the most-derived type to the\n  /// given base type is ambiguous (i.e., it refers to multiple subobjects of\n  /// the same base type).\n  bool isAmbiguous(CanQualType BaseType);\n\n  /// Whether we are finding multiple paths to detect ambiguities.\n  bool isFindingAmbiguities() const { return FindAmbiguities; }\n\n  /// Whether we are recording paths.\n  bool isRecordingPaths() const { return RecordPaths; }\n\n  /// Specify whether we should be recording paths or not.\n  void setRecordingPaths(bool RP) { RecordPaths = RP; }\n\n  /// Whether we are detecting virtual bases.\n  bool isDetectingVirtual() const { return DetectVirtual; }\n\n  /// The virtual base discovered on the path (if we are merely\n  /// detecting virtuals).\n  const RecordType* getDetectedVirtual() const {\n    return DetectedVirtual;\n  }\n\n  /// Retrieve the type from which this base-paths search\n  /// began\n  const CXXRecordDecl *getOrigin() const { return Origin; }\n  void setOrigin(const CXXRecordDecl *Rec) { Origin = Rec; }\n\n  /// Clear the base-paths results.\n  void clear();\n\n  /// Swap this data structure's contents with another CXXBasePaths\n  /// object.\n  void swap(CXXBasePaths &Other);\n};\n\n/// Uniquely identifies a virtual method within a class\n/// hierarchy by the method itself and a class subobject number.\nstruct UniqueVirtualMethod {\n  /// The overriding virtual method.\n  CXXMethodDecl *Method = nullptr;\n\n  /// The subobject in which the overriding virtual method\n  /// resides.\n  unsigned Subobject = 0;\n\n  /// The virtual base class subobject of which this overridden\n  /// virtual method is a part. Note that this records the closest\n  /// derived virtual base class subobject.\n  const CXXRecordDecl *InVirtualSubobject = nullptr;\n\n  UniqueVirtualMethod() = default;\n\n  UniqueVirtualMethod(CXXMethodDecl *Method, unsigned Subobject,\n                      const CXXRecordDecl *InVirtualSubobject)\n      : Method(Method), Subobject(Subobject),\n        InVirtualSubobject(InVirtualSubobject) {}\n\n  friend bool operator==(const UniqueVirtualMethod &X,\n                         const UniqueVirtualMethod &Y) {\n    return X.Method == Y.Method && X.Subobject == Y.Subobject &&\n      X.InVirtualSubobject == Y.InVirtualSubobject;\n  }\n\n  friend bool operator!=(const UniqueVirtualMethod &X,\n                         const UniqueVirtualMethod &Y) {\n    return !(X == Y);\n  }\n};\n\n/// The set of methods that override a given virtual method in\n/// each subobject where it occurs.\n///\n/// The first part of the pair is the subobject in which the\n/// overridden virtual function occurs, while the second part of the\n/// pair is the virtual method that overrides it (including the\n/// subobject in which that virtual function occurs).\nclass OverridingMethods {\n  using ValuesT = SmallVector<UniqueVirtualMethod, 4>;\n  using MapType = llvm::MapVector<unsigned, ValuesT>;\n\n  MapType Overrides;\n\npublic:\n  // Iterate over the set of subobjects that have overriding methods.\n  using iterator = MapType::iterator;\n  using const_iterator = MapType::const_iterator;\n\n  iterator begin() { return Overrides.begin(); }\n  const_iterator begin() const { return Overrides.begin(); }\n  iterator end() { return Overrides.end(); }\n  const_iterator end() const { return Overrides.end(); }\n  unsigned size() const { return Overrides.size(); }\n\n  // Iterate over the set of overriding virtual methods in a given\n  // subobject.\n  using overriding_iterator =\n      SmallVectorImpl<UniqueVirtualMethod>::iterator;\n  using overriding_const_iterator =\n      SmallVectorImpl<UniqueVirtualMethod>::const_iterator;\n\n  // Add a new overriding method for a particular subobject.\n  void add(unsigned OverriddenSubobject, UniqueVirtualMethod Overriding);\n\n  // Add all of the overriding methods from \"other\" into overrides for\n  // this method. Used when merging the overrides from multiple base\n  // class subobjects.\n  void add(const OverridingMethods &Other);\n\n  // Replace all overriding virtual methods in all subobjects with the\n  // given virtual method.\n  void replaceAll(UniqueVirtualMethod Overriding);\n};\n\n/// A mapping from each virtual member function to its set of\n/// final overriders.\n///\n/// Within a class hierarchy for a given derived class, each virtual\n/// member function in that hierarchy has one or more \"final\n/// overriders\" (C++ [class.virtual]p2). A final overrider for a\n/// virtual function \"f\" is the virtual function that will actually be\n/// invoked when dispatching a call to \"f\" through the\n/// vtable. Well-formed classes have a single final overrider for each\n/// virtual function; in abstract classes, the final overrider for at\n/// least one virtual function is a pure virtual function. Due to\n/// multiple, virtual inheritance, it is possible for a class to have\n/// more than one final overrider. Athough this is an error (per C++\n/// [class.virtual]p2), it is not considered an error here: the final\n/// overrider map can represent multiple final overriders for a\n/// method, and it is up to the client to determine whether they are\n/// problem. For example, the following class \\c D has two final\n/// overriders for the virtual function \\c A::f(), one in \\c C and one\n/// in \\c D:\n///\n/// \\code\n///   struct A { virtual void f(); };\n///   struct B : virtual A { virtual void f(); };\n///   struct C : virtual A { virtual void f(); };\n///   struct D : B, C { };\n/// \\endcode\n///\n/// This data structure contains a mapping from every virtual\n/// function *that does not override an existing virtual function* and\n/// in every subobject where that virtual function occurs to the set\n/// of virtual functions that override it. Thus, the same virtual\n/// function \\c A::f can actually occur in multiple subobjects of type\n/// \\c A due to multiple inheritance, and may be overridden by\n/// different virtual functions in each, as in the following example:\n///\n/// \\code\n///   struct A { virtual void f(); };\n///   struct B : A { virtual void f(); };\n///   struct C : A { virtual void f(); };\n///   struct D : B, C { };\n/// \\endcode\n///\n/// Unlike in the previous example, where the virtual functions \\c\n/// B::f and \\c C::f both overrode \\c A::f in the same subobject of\n/// type \\c A, in this example the two virtual functions both override\n/// \\c A::f but in *different* subobjects of type A. This is\n/// represented by numbering the subobjects in which the overridden\n/// and the overriding virtual member functions are located. Subobject\n/// 0 represents the virtual base class subobject of that type, while\n/// subobject numbers greater than 0 refer to non-virtual base class\n/// subobjects of that type.\nclass CXXFinalOverriderMap\n  : public llvm::MapVector<const CXXMethodDecl *, OverridingMethods> {};\n\n/// A set of all the primary bases for a class.\nclass CXXIndirectPrimaryBaseSet\n  : public llvm::SmallSet<const CXXRecordDecl*, 32> {};\n\ninline bool\ninheritanceModelHasVBPtrOffsetField(MSInheritanceModel Inheritance) {\n  return Inheritance == MSInheritanceModel::Unspecified;\n}\n\n// Only member pointers to functions need a this adjustment, since it can be\n// combined with the field offset for data pointers.\ninline bool inheritanceModelHasNVOffsetField(bool IsMemberFunction,\n                                             MSInheritanceModel Inheritance) {\n  return IsMemberFunction && Inheritance >= MSInheritanceModel::Multiple;\n}\n\ninline bool\ninheritanceModelHasVBTableOffsetField(MSInheritanceModel Inheritance) {\n  return Inheritance >= MSInheritanceModel::Virtual;\n}\n\ninline bool inheritanceModelHasOnlyOneField(bool IsMemberFunction,\n                                            MSInheritanceModel Inheritance) {\n  if (IsMemberFunction)\n    return Inheritance <= MSInheritanceModel::Single;\n  return Inheritance <= MSInheritanceModel::Multiple;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_CXXINHERITANCE_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/VTableBuilder.h", "content": "//===--- VTableBuilder.h - C++ vtable layout builder --------------*- C++ -*-=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This contains code dealing with generation of the layout of virtual tables.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_VTABLEBUILDER_H\n#define LLVM_CLANG_AST_VTABLEBUILDER_H\n\n#include \"clang/AST/BaseSubobject.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Basic/ABI.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include <memory>\n#include <utility>\n\nnamespace clang {\n  class CXXRecordDecl;\n\n/// Represents a single component in a vtable.\nclass VTableComponent {\npublic:\n  enum Kind {\n    CK_VCallOffset,\n    CK_VBaseOffset,\n    CK_OffsetToTop,\n    CK_RTTI,\n    CK_FunctionPointer,\n\n    /// A pointer to the complete destructor.\n    CK_CompleteDtorPointer,\n\n    /// A pointer to the deleting destructor.\n    CK_DeletingDtorPointer,\n\n    /// An entry that is never used.\n    ///\n    /// In some cases, a vtable function pointer will end up never being\n    /// called. Such vtable function pointers are represented as a\n    /// CK_UnusedFunctionPointer.\n    CK_UnusedFunctionPointer\n  };\n\n  VTableComponent() = default;\n\n  static VTableComponent MakeVCallOffset(CharUnits Offset) {\n    return VTableComponent(CK_VCallOffset, Offset);\n  }\n\n  static VTableComponent MakeVBaseOffset(CharUnits Offset) {\n    return VTableComponent(CK_VBaseOffset, Offset);\n  }\n\n  static VTableComponent MakeOffsetToTop(CharUnits Offset) {\n    return VTableComponent(CK_OffsetToTop, Offset);\n  }\n\n  static VTableComponent MakeRTTI(const CXXRecordDecl *RD) {\n    return VTableComponent(CK_RTTI, reinterpret_cast<uintptr_t>(RD));\n  }\n\n  static VTableComponent MakeFunction(const CXXMethodDecl *MD) {\n    assert(!isa<CXXDestructorDecl>(MD) &&\n           \"Don't use MakeFunction with destructors!\");\n\n    return VTableComponent(CK_FunctionPointer,\n                           reinterpret_cast<uintptr_t>(MD));\n  }\n\n  static VTableComponent MakeCompleteDtor(const CXXDestructorDecl *DD) {\n    return VTableComponent(CK_CompleteDtorPointer,\n                           reinterpret_cast<uintptr_t>(DD));\n  }\n\n  static VTableComponent MakeDeletingDtor(const CXXDestructorDecl *DD) {\n    return VTableComponent(CK_DeletingDtorPointer,\n                           reinterpret_cast<uintptr_t>(DD));\n  }\n\n  static VTableComponent MakeUnusedFunction(const CXXMethodDecl *MD) {\n    assert(!isa<CXXDestructorDecl>(MD) &&\n           \"Don't use MakeUnusedFunction with destructors!\");\n    return VTableComponent(CK_UnusedFunctionPointer,\n                           reinterpret_cast<uintptr_t>(MD));\n  }\n\n  /// Get the kind of this vtable component.\n  Kind getKind() const {\n    return (Kind)(Value & 0x7);\n  }\n\n  CharUnits getVCallOffset() const {\n    assert(getKind() == CK_VCallOffset && \"Invalid component kind!\");\n\n    return getOffset();\n  }\n\n  CharUnits getVBaseOffset() const {\n    assert(getKind() == CK_VBaseOffset && \"Invalid component kind!\");\n\n    return getOffset();\n  }\n\n  CharUnits getOffsetToTop() const {\n    assert(getKind() == CK_OffsetToTop && \"Invalid component kind!\");\n\n    return getOffset();\n  }\n\n  const CXXRecordDecl *getRTTIDecl() const {\n    assert(isRTTIKind() && \"Invalid component kind!\");\n    return reinterpret_cast<CXXRecordDecl *>(getPointer());\n  }\n\n  const CXXMethodDecl *getFunctionDecl() const {\n    assert(isFunctionPointerKind() && \"Invalid component kind!\");\n    if (isDestructorKind())\n      return getDestructorDecl();\n    return reinterpret_cast<CXXMethodDecl *>(getPointer());\n  }\n\n  const CXXDestructorDecl *getDestructorDecl() const {\n    assert(isDestructorKind() && \"Invalid component kind!\");\n    return reinterpret_cast<CXXDestructorDecl *>(getPointer());\n  }\n\n  const CXXMethodDecl *getUnusedFunctionDecl() const {\n    assert(getKind() == CK_UnusedFunctionPointer && \"Invalid component kind!\");\n    return reinterpret_cast<CXXMethodDecl *>(getPointer());\n  }\n\n  bool isDestructorKind() const { return isDestructorKind(getKind()); }\n\n  bool isUsedFunctionPointerKind() const {\n    return isUsedFunctionPointerKind(getKind());\n  }\n\n  bool isFunctionPointerKind() const {\n    return isFunctionPointerKind(getKind());\n  }\n\n  bool isRTTIKind() const { return isRTTIKind(getKind()); }\n\n  GlobalDecl getGlobalDecl() const {\n    assert(isUsedFunctionPointerKind() &&\n           \"GlobalDecl can be created only from virtual function\");\n\n    auto *DtorDecl = dyn_cast<CXXDestructorDecl>(getFunctionDecl());\n    switch (getKind()) {\n    case CK_FunctionPointer:\n      return GlobalDecl(getFunctionDecl());\n    case CK_CompleteDtorPointer:\n      return GlobalDecl(DtorDecl, CXXDtorType::Dtor_Complete);\n    case CK_DeletingDtorPointer:\n      return GlobalDecl(DtorDecl, CXXDtorType::Dtor_Deleting);\n    case CK_VCallOffset:\n    case CK_VBaseOffset:\n    case CK_OffsetToTop:\n    case CK_RTTI:\n    case CK_UnusedFunctionPointer:\n      llvm_unreachable(\"Only function pointers kinds\");\n    }\n    llvm_unreachable(\"Should already return\");\n  }\n\nprivate:\n  static bool isFunctionPointerKind(Kind ComponentKind) {\n    return isUsedFunctionPointerKind(ComponentKind) ||\n           ComponentKind == CK_UnusedFunctionPointer;\n  }\n  static bool isUsedFunctionPointerKind(Kind ComponentKind) {\n    return ComponentKind == CK_FunctionPointer ||\n           isDestructorKind(ComponentKind);\n  }\n  static bool isDestructorKind(Kind ComponentKind) {\n    return ComponentKind == CK_CompleteDtorPointer ||\n           ComponentKind == CK_DeletingDtorPointer;\n  }\n  static bool isRTTIKind(Kind ComponentKind) {\n    return ComponentKind == CK_RTTI;\n  }\n\n  VTableComponent(Kind ComponentKind, CharUnits Offset) {\n    assert((ComponentKind == CK_VCallOffset ||\n            ComponentKind == CK_VBaseOffset ||\n            ComponentKind == CK_OffsetToTop) && \"Invalid component kind!\");\n    assert(Offset.getQuantity() < (1LL << 56) && \"Offset is too big!\");\n    assert(Offset.getQuantity() >= -(1LL << 56) && \"Offset is too small!\");\n\n    Value = (uint64_t(Offset.getQuantity()) << 3) | ComponentKind;\n  }\n\n  VTableComponent(Kind ComponentKind, uintptr_t Ptr) {\n    assert((isRTTIKind(ComponentKind) || isFunctionPointerKind(ComponentKind)) &&\n           \"Invalid component kind!\");\n\n    assert((Ptr & 7) == 0 && \"Pointer not sufficiently aligned!\");\n\n    Value = Ptr | ComponentKind;\n  }\n\n  CharUnits getOffset() const {\n    assert((getKind() == CK_VCallOffset || getKind() == CK_VBaseOffset ||\n            getKind() == CK_OffsetToTop) && \"Invalid component kind!\");\n\n    return CharUnits::fromQuantity(Value >> 3);\n  }\n\n  uintptr_t getPointer() const {\n    assert((getKind() == CK_RTTI || isFunctionPointerKind()) &&\n           \"Invalid component kind!\");\n\n    return static_cast<uintptr_t>(Value & ~7ULL);\n  }\n\n  /// The kind is stored in the lower 3 bits of the value. For offsets, we\n  /// make use of the facts that classes can't be larger than 2^55 bytes,\n  /// so we store the offset in the lower part of the 61 bits that remain.\n  /// (The reason that we're not simply using a PointerIntPair here is that we\n  /// need the offsets to be 64-bit, even when on a 32-bit machine).\n  int64_t Value;\n};\n\nclass VTableLayout {\npublic:\n  typedef std::pair<uint64_t, ThunkInfo> VTableThunkTy;\n  struct AddressPointLocation {\n    unsigned VTableIndex, AddressPointIndex;\n  };\n  typedef llvm::DenseMap<BaseSubobject, AddressPointLocation>\n      AddressPointsMapTy;\n\n  // Mapping between the VTable index and address point index. This is useful\n  // when you don't care about the base subobjects and only want the address\n  // point for a given vtable index.\n  typedef llvm::SmallVector<unsigned, 4> AddressPointsIndexMapTy;\n\nprivate:\n  // Stores the component indices of the first component of each virtual table in\n  // the virtual table group. To save a little memory in the common case where\n  // the vtable group contains a single vtable, an empty vector here represents\n  // the vector {0}.\n  OwningArrayRef<size_t> VTableIndices;\n\n  OwningArrayRef<VTableComponent> VTableComponents;\n\n  /// Contains thunks needed by vtables, sorted by indices.\n  OwningArrayRef<VTableThunkTy> VTableThunks;\n\n  /// Address points for all vtables.\n  AddressPointsMapTy AddressPoints;\n\n  /// Address points for all vtable indices.\n  AddressPointsIndexMapTy AddressPointIndices;\n\npublic:\n  VTableLayout(ArrayRef<size_t> VTableIndices,\n               ArrayRef<VTableComponent> VTableComponents,\n               ArrayRef<VTableThunkTy> VTableThunks,\n               const AddressPointsMapTy &AddressPoints);\n  ~VTableLayout();\n\n  ArrayRef<VTableComponent> vtable_components() const {\n    return VTableComponents;\n  }\n\n  ArrayRef<VTableThunkTy> vtable_thunks() const {\n    return VTableThunks;\n  }\n\n  AddressPointLocation getAddressPoint(BaseSubobject Base) const {\n    assert(AddressPoints.count(Base) && \"Did not find address point!\");\n    return AddressPoints.find(Base)->second;\n  }\n\n  const AddressPointsMapTy &getAddressPoints() const {\n    return AddressPoints;\n  }\n\n  const AddressPointsIndexMapTy &getAddressPointIndices() const {\n    return AddressPointIndices;\n  }\n\n  size_t getNumVTables() const {\n    if (VTableIndices.empty())\n      return 1;\n    return VTableIndices.size();\n  }\n\n  size_t getVTableOffset(size_t i) const {\n    if (VTableIndices.empty()) {\n      assert(i == 0);\n      return 0;\n    }\n    return VTableIndices[i];\n  }\n\n  size_t getVTableSize(size_t i) const {\n    if (VTableIndices.empty()) {\n      assert(i == 0);\n      return vtable_components().size();\n    }\n\n    size_t thisIndex = VTableIndices[i];\n    size_t nextIndex = (i + 1 == VTableIndices.size())\n                           ? vtable_components().size()\n                           : VTableIndices[i + 1];\n    return nextIndex - thisIndex;\n  }\n};\n\nclass VTableContextBase {\npublic:\n  typedef SmallVector<ThunkInfo, 1> ThunkInfoVectorTy;\n\n  bool isMicrosoft() const { return IsMicrosoftABI; }\n\n  virtual ~VTableContextBase() {}\n\nprotected:\n  typedef llvm::DenseMap<const CXXMethodDecl *, ThunkInfoVectorTy> ThunksMapTy;\n\n  /// Contains all thunks that a given method decl will need.\n  ThunksMapTy Thunks;\n\n  /// Compute and store all vtable related information (vtable layout, vbase\n  /// offset offsets, thunks etc) for the given record decl.\n  virtual void computeVTableRelatedInformation(const CXXRecordDecl *RD) = 0;\n\n  VTableContextBase(bool MS) : IsMicrosoftABI(MS) {}\n\npublic:\n  virtual const ThunkInfoVectorTy *getThunkInfo(GlobalDecl GD) {\n    const CXXMethodDecl *MD = cast<CXXMethodDecl>(GD.getDecl()->getCanonicalDecl());\n    computeVTableRelatedInformation(MD->getParent());\n\n    // This assumes that all the destructors present in the vtable\n    // use exactly the same set of thunks.\n    ThunksMapTy::const_iterator I = Thunks.find(MD);\n    if (I == Thunks.end()) {\n      // We did not find a thunk for this method.\n      return nullptr;\n    }\n\n    return &I->second;\n  }\n\n  bool IsMicrosoftABI;\n\n  /// Determine whether this function should be assigned a vtable slot.\n  static bool hasVtableSlot(const CXXMethodDecl *MD);\n};\n\nclass ItaniumVTableContext : public VTableContextBase {\nprivate:\n\n  /// Contains the index (relative to the vtable address point)\n  /// where the function pointer for a virtual function is stored.\n  typedef llvm::DenseMap<GlobalDecl, int64_t> MethodVTableIndicesTy;\n  MethodVTableIndicesTy MethodVTableIndices;\n\n  typedef llvm::DenseMap<const CXXRecordDecl *,\n                         std::unique_ptr<const VTableLayout>>\n      VTableLayoutMapTy;\n  VTableLayoutMapTy VTableLayouts;\n\n  typedef std::pair<const CXXRecordDecl *,\n                    const CXXRecordDecl *> ClassPairTy;\n\n  /// vtable offsets for offsets of virtual bases of a class.\n  ///\n  /// Contains the vtable offset (relative to the address point) in chars\n  /// where the offsets for virtual bases of a class are stored.\n  typedef llvm::DenseMap<ClassPairTy, CharUnits>\n    VirtualBaseClassOffsetOffsetsMapTy;\n  VirtualBaseClassOffsetOffsetsMapTy VirtualBaseClassOffsetOffsets;\n\n  void computeVTableRelatedInformation(const CXXRecordDecl *RD) override;\n\npublic:\n  enum VTableComponentLayout {\n    /// Components in the vtable are pointers to other structs/functions.\n    Pointer,\n\n    /// Components in the vtable are relative offsets between the vtable and the\n    /// other structs/functions.\n    Relative,\n  };\n\n  ItaniumVTableContext(ASTContext &Context,\n                       VTableComponentLayout ComponentLayout = Pointer);\n  ~ItaniumVTableContext() override;\n\n  const VTableLayout &getVTableLayout(const CXXRecordDecl *RD) {\n    computeVTableRelatedInformation(RD);\n    assert(VTableLayouts.count(RD) && \"No layout for this record decl!\");\n\n    return *VTableLayouts[RD];\n  }\n\n  std::unique_ptr<VTableLayout> createConstructionVTableLayout(\n      const CXXRecordDecl *MostDerivedClass, CharUnits MostDerivedClassOffset,\n      bool MostDerivedClassIsVirtual, const CXXRecordDecl *LayoutClass);\n\n  /// Locate a virtual function in the vtable.\n  ///\n  /// Return the index (relative to the vtable address point) where the\n  /// function pointer for the given virtual function is stored.\n  uint64_t getMethodVTableIndex(GlobalDecl GD);\n\n  /// Return the offset in chars (relative to the vtable address point) where\n  /// the offset of the virtual base that contains the given base is stored,\n  /// otherwise, if no virtual base contains the given class, return 0.\n  ///\n  /// Base must be a virtual base class or an unambiguous base.\n  CharUnits getVirtualBaseOffsetOffset(const CXXRecordDecl *RD,\n                                       const CXXRecordDecl *VBase);\n\n  static bool classof(const VTableContextBase *VT) {\n    return !VT->isMicrosoft();\n  }\n\n  VTableComponentLayout getVTableComponentLayout() const {\n    return ComponentLayout;\n  }\n\n  bool isPointerLayout() const { return ComponentLayout == Pointer; }\n  bool isRelativeLayout() const { return ComponentLayout == Relative; }\n\nprivate:\n  VTableComponentLayout ComponentLayout;\n};\n\n/// Holds information about the inheritance path to a virtual base or function\n/// table pointer.  A record may contain as many vfptrs or vbptrs as there are\n/// base subobjects.\nstruct VPtrInfo {\n  typedef SmallVector<const CXXRecordDecl *, 1> BasePath;\n\n  VPtrInfo(const CXXRecordDecl *RD)\n      : ObjectWithVPtr(RD), IntroducingObject(RD), NextBaseToMangle(RD) {}\n\n  /// This is the most derived class that has this vptr at offset zero. When\n  /// single inheritance is used, this is always the most derived class. If\n  /// multiple inheritance is used, it may be any direct or indirect base.\n  const CXXRecordDecl *ObjectWithVPtr;\n\n  /// This is the class that introduced the vptr by declaring new virtual\n  /// methods or virtual bases.\n  const CXXRecordDecl *IntroducingObject;\n\n  /// IntroducingObject is at this offset from its containing complete object or\n  /// virtual base.\n  CharUnits NonVirtualOffset;\n\n  /// The bases from the inheritance path that got used to mangle the vbtable\n  /// name.  This is not really a full path like a CXXBasePath.  It holds the\n  /// subset of records that need to be mangled into the vbtable symbol name in\n  /// order to get a unique name.\n  BasePath MangledPath;\n\n  /// The next base to push onto the mangled path if this path is ambiguous in a\n  /// derived class.  If it's null, then it's already been pushed onto the path.\n  const CXXRecordDecl *NextBaseToMangle;\n\n  /// The set of possibly indirect vbases that contain this vbtable.  When a\n  /// derived class indirectly inherits from the same vbase twice, we only keep\n  /// vtables and their paths from the first instance.\n  BasePath ContainingVBases;\n\n  /// This holds the base classes path from the complete type to the first base\n  /// with the given vfptr offset, in the base-to-derived order.  Only used for\n  /// vftables.\n  BasePath PathToIntroducingObject;\n\n  /// Static offset from the top of the most derived class to this vfptr,\n  /// including any virtual base offset.  Only used for vftables.\n  CharUnits FullOffsetInMDC;\n\n  /// The vptr is stored inside the non-virtual component of this virtual base.\n  const CXXRecordDecl *getVBaseWithVPtr() const {\n    return ContainingVBases.empty() ? nullptr : ContainingVBases.front();\n  }\n};\n\ntypedef SmallVector<std::unique_ptr<VPtrInfo>, 2> VPtrInfoVector;\n\n/// All virtual base related information about a given record decl.  Includes\n/// information on all virtual base tables and the path components that are used\n/// to mangle them.\nstruct VirtualBaseInfo {\n  /// A map from virtual base to vbtable index for doing a conversion from the\n  /// the derived class to the a base.\n  llvm::DenseMap<const CXXRecordDecl *, unsigned> VBTableIndices;\n\n  /// Information on all virtual base tables used when this record is the most\n  /// derived class.\n  VPtrInfoVector VBPtrPaths;\n};\n\nstruct MethodVFTableLocation {\n  /// If nonzero, holds the vbtable index of the virtual base with the vfptr.\n  uint64_t VBTableIndex;\n\n  /// If nonnull, holds the last vbase which contains the vfptr that the\n  /// method definition is adjusted to.\n  const CXXRecordDecl *VBase;\n\n  /// This is the offset of the vfptr from the start of the last vbase, or the\n  /// complete type if there are no virtual bases.\n  CharUnits VFPtrOffset;\n\n  /// Method's index in the vftable.\n  uint64_t Index;\n\n  MethodVFTableLocation()\n      : VBTableIndex(0), VBase(nullptr), VFPtrOffset(CharUnits::Zero()),\n        Index(0) {}\n\n  MethodVFTableLocation(uint64_t VBTableIndex, const CXXRecordDecl *VBase,\n                        CharUnits VFPtrOffset, uint64_t Index)\n      : VBTableIndex(VBTableIndex), VBase(VBase), VFPtrOffset(VFPtrOffset),\n        Index(Index) {}\n\n  bool operator<(const MethodVFTableLocation &other) const {\n    if (VBTableIndex != other.VBTableIndex) {\n      assert(VBase != other.VBase);\n      return VBTableIndex < other.VBTableIndex;\n    }\n    return std::tie(VFPtrOffset, Index) <\n           std::tie(other.VFPtrOffset, other.Index);\n  }\n};\n\nclass MicrosoftVTableContext : public VTableContextBase {\npublic:\n\nprivate:\n  ASTContext &Context;\n\n  typedef llvm::DenseMap<GlobalDecl, MethodVFTableLocation>\n    MethodVFTableLocationsTy;\n  MethodVFTableLocationsTy MethodVFTableLocations;\n\n  typedef llvm::DenseMap<const CXXRecordDecl *, std::unique_ptr<VPtrInfoVector>>\n      VFPtrLocationsMapTy;\n  VFPtrLocationsMapTy VFPtrLocations;\n\n  typedef std::pair<const CXXRecordDecl *, CharUnits> VFTableIdTy;\n  typedef llvm::DenseMap<VFTableIdTy, std::unique_ptr<const VTableLayout>>\n      VFTableLayoutMapTy;\n  VFTableLayoutMapTy VFTableLayouts;\n\n  llvm::DenseMap<const CXXRecordDecl *, std::unique_ptr<VirtualBaseInfo>>\n      VBaseInfo;\n\n  void enumerateVFPtrs(const CXXRecordDecl *ForClass, VPtrInfoVector &Result);\n\n  void computeVTableRelatedInformation(const CXXRecordDecl *RD) override;\n\n  void dumpMethodLocations(const CXXRecordDecl *RD,\n                           const MethodVFTableLocationsTy &NewMethods,\n                           raw_ostream &);\n\n  const VirtualBaseInfo &\n  computeVBTableRelatedInformation(const CXXRecordDecl *RD);\n\n  void computeVTablePaths(bool ForVBTables, const CXXRecordDecl *RD,\n                          VPtrInfoVector &Paths);\n\npublic:\n  MicrosoftVTableContext(ASTContext &Context)\n      : VTableContextBase(/*MS=*/true), Context(Context) {}\n\n  ~MicrosoftVTableContext() override;\n\n  const VPtrInfoVector &getVFPtrOffsets(const CXXRecordDecl *RD);\n\n  const VTableLayout &getVFTableLayout(const CXXRecordDecl *RD,\n                                       CharUnits VFPtrOffset);\n\n  MethodVFTableLocation getMethodVFTableLocation(GlobalDecl GD);\n\n  const ThunkInfoVectorTy *getThunkInfo(GlobalDecl GD) override {\n    // Complete destructors don't have a slot in a vftable, so no thunks needed.\n    if (isa<CXXDestructorDecl>(GD.getDecl()) &&\n        GD.getDtorType() == Dtor_Complete)\n      return nullptr;\n    return VTableContextBase::getThunkInfo(GD);\n  }\n\n  /// Returns the index of VBase in the vbtable of Derived.\n  /// VBase must be a morally virtual base of Derived.\n  /// The vbtable is an array of i32 offsets.  The first entry is a self entry,\n  /// and the rest are offsets from the vbptr to virtual bases.\n  unsigned getVBTableIndex(const CXXRecordDecl *Derived,\n                           const CXXRecordDecl *VBase);\n\n  const VPtrInfoVector &enumerateVBTables(const CXXRecordDecl *RD);\n\n  static bool classof(const VTableContextBase *VT) { return VT->isMicrosoft(); }\n};\n\n} // namespace clang\n\n#endif\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/OpenCLOptions.h", "content": "//===--- OpenCLOptions.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the clang::OpenCLOptions class.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_OPENCLOPTIONS_H\n#define LLVM_CLANG_BASIC_OPENCLOPTIONS_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"llvm/ADT/StringMap.h\"\n\nnamespace clang {\n\nnamespace {\n// This enum maps OpenCL version(s) into value. These values are used as\n// a mask to indicate in which OpenCL version(s) extension is a core or\n// optional core feature.\nenum OpenCLVersionID : unsigned int {\n  OCL_C_10 = 0x1,\n  OCL_C_11 = 0x2,\n  OCL_C_12 = 0x4,\n  OCL_C_20 = 0x8,\n  OCL_C_30 = 0x10,\n  OCL_C_ALL = 0x1f,\n  OCL_C_11P = OCL_C_ALL ^ OCL_C_10,              // OpenCL C 1.1+\n  OCL_C_12P = OCL_C_ALL ^ (OCL_C_10 | OCL_C_11), // OpenCL C 1.2+\n};\n\nstatic inline OpenCLVersionID encodeOpenCLVersion(unsigned OpenCLVersion) {\n  switch (OpenCLVersion) {\n  default:\n    llvm_unreachable(\"Unknown OpenCL version code\");\n  case 100:\n    return OCL_C_10;\n  case 110:\n    return OCL_C_11;\n  case 120:\n    return OCL_C_12;\n  case 200:\n    return OCL_C_20;\n  case 300:\n    return OCL_C_30;\n  }\n}\n\n// Simple helper to check if OpenCL C version is contained in a given encoded\n// OpenCL C version mask\nstatic inline bool isOpenCLVersionIsContainedInMask(const LangOptions &LO,\n                                                    unsigned Mask) {\n  auto CLVer = LO.OpenCLCPlusPlus ? 200 : LO.OpenCLVersion;\n  OpenCLVersionID Code = encodeOpenCLVersion(CLVer);\n  return Mask & Code;\n}\n} // end anonymous namespace\n\n/// OpenCL supported extensions and optional core features\nclass OpenCLOptions {\npublic:\n  struct OpenCLOptionInfo {\n    // Does this option have pragma.\n    bool WithPragma = false;\n\n    // Option starts to be available in this OpenCL version\n    unsigned Avail = 100U;\n\n    // Option becomes core feature in this OpenCL versions\n    unsigned Core = 0U;\n\n    // Option becomes optional core feature in this OpenCL versions\n    unsigned Opt = 0U;\n\n    // Is this option supported\n    bool Supported = false;\n\n    // Is this option enabled\n    bool Enabled = false;\n\n    OpenCLOptionInfo() = default;\n    OpenCLOptionInfo(bool Pragma, unsigned AvailV, unsigned CoreV,\n                     unsigned OptV)\n        : WithPragma(Pragma), Avail(AvailV), Core(CoreV), Opt(OptV) {}\n\n    bool isCore() const { return Core != 0U; }\n\n    bool isOptionalCore() const { return Opt != 0U; }\n\n    // Is option available in OpenCL version \\p LO.\n    bool isAvailableIn(const LangOptions &LO) const {\n      // In C++ mode all extensions should work at least as in v2.0.\n      auto CLVer = LO.OpenCLCPlusPlus ? 200 : LO.OpenCLVersion;\n      return CLVer >= Avail;\n    }\n\n    // Is core option in OpenCL version \\p LO.\n    bool isCoreIn(const LangOptions &LO) const {\n      return isAvailableIn(LO) && isOpenCLVersionIsContainedInMask(LO, Core);\n    }\n\n    // Is optional core option in OpenCL version \\p LO.\n    bool isOptionalCoreIn(const LangOptions &LO) const {\n      return isAvailableIn(LO) && isOpenCLVersionIsContainedInMask(LO, Opt);\n    }\n  };\n\n  bool isKnown(llvm::StringRef Ext) const;\n\n  bool isEnabled(llvm::StringRef Ext) const;\n\n  bool isWithPragma(llvm::StringRef Ext) const;\n\n  // Is supported as either an extension or an (optional) core feature for\n  // OpenCL version \\p LO.\n  bool isSupported(llvm::StringRef Ext, const LangOptions &LO) const;\n\n  // Is supported OpenCL core feature for OpenCL version \\p LO.\n  // For supported extension, return false.\n  bool isSupportedCore(llvm::StringRef Ext, const LangOptions &LO) const;\n\n  // Is supported optional core OpenCL feature for OpenCL version \\p LO.\n  // For supported extension, return false.\n  bool isSupportedOptionalCore(llvm::StringRef Ext,\n                               const LangOptions &LO) const;\n\n  // Is supported optional core or core OpenCL feature for OpenCL version \\p\n  // LO. For supported extension, return false.\n  bool isSupportedCoreOrOptionalCore(llvm::StringRef Ext,\n                                     const LangOptions &LO) const;\n\n  // Is supported OpenCL extension for OpenCL version \\p LO.\n  // For supported core or optional core feature, return false.\n  bool isSupportedExtension(llvm::StringRef Ext, const LangOptions &LO) const;\n\n  // FIXME: Whether extension should accept pragma should not\n  // be reset dynamically. But it currently required when\n  // registering new extensions via pragmas.\n  void acceptsPragma(llvm::StringRef Ext, bool V = true);\n\n  void enable(llvm::StringRef Ext, bool V = true);\n\n  /// Enable or disable support for OpenCL extensions\n  /// \\param Ext name of the extension (not prefixed with '+' or '-')\n  /// \\param V value to set for a extension\n  void support(llvm::StringRef Ext, bool V = true);\n\n  OpenCLOptions();\n  OpenCLOptions(const OpenCLOptions &) = default;\n\n  // Set supported options based on target settings and language version\n  void addSupport(const llvm::StringMap<bool> &FeaturesMap,\n                  const LangOptions &Opts);\n\n  // Disable all extensions\n  void disableAll();\n\n  // Enable supported core and optional core features\n  void enableSupportedCore(const LangOptions &LO);\n\n  friend class ASTWriter;\n  friend class ASTReader;\n\n  using OpenCLOptionInfoMap = llvm::StringMap<OpenCLOptionInfo>;\n\nprivate:\n  OpenCLOptionInfoMap OptMap;\n};\n\n} // end namespace clang\n\n#endif\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/TargetCXXABI.h", "content": "//===--- TargetCXXABI.h - C++ ABI Target Configuration ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the TargetCXXABI class, which abstracts details of the\n/// C++ ABI that we're targeting.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_TARGETCXXABI_H\n#define LLVM_CLANG_BASIC_TARGETCXXABI_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n\nnamespace clang {\n\n/// The basic abstraction for the target C++ ABI.\nclass TargetCXXABI {\npublic:\n  /// The basic C++ ABI kind.\n  enum Kind {\n    /// The generic Itanium ABI is the standard ABI of most open-source\n    /// and Unix-like platforms.  It is the primary ABI targeted by\n    /// many compilers, including Clang and GCC.\n    ///\n    /// It is documented here:\n    ///   http://www.codesourcery.com/public/cxx-abi/\n    GenericItanium,\n\n    /// The generic ARM ABI is a modified version of the Itanium ABI\n    /// proposed by ARM for use on ARM-based platforms.\n    ///\n    /// These changes include:\n    ///   - the representation of member function pointers is adjusted\n    ///     to not conflict with the 'thumb' bit of ARM function pointers;\n    ///   - constructors and destructors return 'this';\n    ///   - guard variables are smaller;\n    ///   - inline functions are never key functions;\n    ///   - array cookies have a slightly different layout;\n    ///   - additional convenience functions are specified;\n    ///   - and more!\n    ///\n    /// It is documented here:\n    ///    http://infocenter.arm.com\n    ///                    /help/topic/com.arm.doc.ihi0041c/IHI0041C_cppabi.pdf\n    GenericARM,\n\n    /// The iOS ABI is a partial implementation of the ARM ABI.\n    /// Several of the features of the ARM ABI were not fully implemented\n    /// in the compilers that iOS was launched with.\n    ///\n    /// Essentially, the iOS ABI includes the ARM changes to:\n    ///   - member function pointers,\n    ///   - guard variables,\n    ///   - array cookies, and\n    ///   - constructor/destructor signatures.\n    iOS,\n\n    /// The iOS 64-bit and macOS 64-bit ARM ABI follows ARM's published 64-bit\n    /// ABI more closely, but we don't guarantee to follow it perfectly.\n    ///\n    /// It is documented here:\n    ///    http://infocenter.arm.com\n    ///                  /help/topic/com.arm.doc.ihi0059a/IHI0059A_cppabi64.pdf\n    AppleARM64,\n\n    /// WatchOS is a modernisation of the iOS ABI, which roughly means it's\n    /// the AppleARM64 ABI ported to 32-bits. The primary difference from\n    /// AppleARM64 is that RTTI objects must still be unique at the moment.\n    WatchOS,\n\n    /// The generic AArch64 ABI is also a modified version of the Itanium ABI,\n    /// but it has fewer divergences than the 32-bit ARM ABI.\n    ///\n    /// The relevant changes from the generic ABI in this case are:\n    ///   - representation of member function pointers adjusted as in ARM.\n    ///   - guard variables  are smaller.\n    GenericAArch64,\n\n    /// The generic Mips ABI is a modified version of the Itanium ABI.\n    ///\n    /// At the moment, only change from the generic ABI in this case is:\n    ///   - representation of member function pointers adjusted as in ARM.\n    GenericMIPS,\n\n    /// The WebAssembly ABI is a modified version of the Itanium ABI.\n    ///\n    /// The changes from the Itanium ABI are:\n    ///   - representation of member function pointers is adjusted, as in ARM;\n    ///   - member functions are not specially aligned;\n    ///   - constructors and destructors return 'this', as in ARM;\n    ///   - guard variables are 32-bit on wasm32, as in ARM;\n    ///   - unused bits of guard variables are reserved, as in ARM;\n    ///   - inline functions are never key functions, as in ARM;\n    ///   - C++11 POD rules are used for tail padding, as in AppleARM64.\n    ///\n    /// TODO: At present the WebAssembly ABI is not considered stable, so none\n    /// of these details is necessarily final yet.\n    WebAssembly,\n\n    /// The Fuchsia ABI is a modified version of the Itanium ABI.\n    ///\n    /// The relevant changes from the Itanium ABI are:\n    ///   - constructors and destructors return 'this', as in ARM.\n    Fuchsia,\n\n    /// The XL ABI is the ABI used by IBM xlclang compiler and is a modified\n    /// version of the Itanium ABI.\n    ///\n    /// The relevant changes from the Itanium ABI are:\n    ///   - static initialization is adjusted to use sinit and sterm functions;\n    XL,\n\n    /// The Microsoft ABI is the ABI used by Microsoft Visual Studio (and\n    /// compatible compilers).\n    ///\n    /// FIXME: should this be split into Win32 and Win64 variants?\n    ///\n    /// Only scattered and incomplete official documentation exists.\n    Microsoft\n  };\n\nprivate:\n  // Right now, this class is passed around as a cheap value type.\n  // If you add more members, especially non-POD members, please\n  // audit the users to pass it by reference instead.\n  Kind TheKind;\n\npublic:\n  /// A bogus initialization of the platform ABI.\n  TargetCXXABI() : TheKind(GenericItanium) {}\n\n  TargetCXXABI(Kind kind) : TheKind(kind) {}\n\n  void set(Kind kind) {\n    TheKind = kind;\n  }\n\n  Kind getKind() const { return TheKind; }\n\n  /// Does this ABI generally fall into the Itanium family of ABIs?\n  bool isItaniumFamily() const {\n    switch (getKind()) {\n    case AppleARM64:\n    case Fuchsia:\n    case GenericAArch64:\n    case GenericItanium:\n    case GenericARM:\n    case iOS:\n    case WatchOS:\n    case GenericMIPS:\n    case WebAssembly:\n    case XL:\n      return true;\n\n    case Microsoft:\n      return false;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  /// Is this ABI an MSVC-compatible ABI?\n  bool isMicrosoft() const {\n    switch (getKind()) {\n    case AppleARM64:\n    case Fuchsia:\n    case GenericAArch64:\n    case GenericItanium:\n    case GenericARM:\n    case iOS:\n    case WatchOS:\n    case GenericMIPS:\n    case WebAssembly:\n    case XL:\n      return false;\n\n    case Microsoft:\n      return true;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  /// Are member functions differently aligned?\n  ///\n  /// Many Itanium-style C++ ABIs require member functions to be aligned, so\n  /// that a pointer to such a function is guaranteed to have a zero in the\n  /// least significant bit, so that pointers to member functions can use that\n  /// bit to distinguish between virtual and non-virtual functions. However,\n  /// some Itanium-style C++ ABIs differentiate between virtual and non-virtual\n  /// functions via other means, and consequently don't require that member\n  /// functions be aligned.\n  bool areMemberFunctionsAligned() const {\n    switch (getKind()) {\n    case WebAssembly:\n      // WebAssembly doesn't require any special alignment for member functions.\n      return false;\n    case AppleARM64:\n    case Fuchsia:\n    case GenericARM:\n    case GenericAArch64:\n    case GenericMIPS:\n      // TODO: ARM-style pointers to member functions put the discriminator in\n      //       the this adjustment, so they don't require functions to have any\n      //       special alignment and could therefore also return false.\n    case GenericItanium:\n    case iOS:\n    case WatchOS:\n    case Microsoft:\n    case XL:\n      return true;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  /// Are arguments to a call destroyed left to right in the callee?\n  /// This is a fundamental language change, since it implies that objects\n  /// passed by value do *not* live to the end of the full expression.\n  /// Temporaries passed to a function taking a const reference live to the end\n  /// of the full expression as usual.  Both the caller and the callee must\n  /// have access to the destructor, while only the caller needs the\n  /// destructor if this is false.\n  bool areArgsDestroyedLeftToRightInCallee() const {\n    return isMicrosoft();\n  }\n\n  /// Does this ABI have different entrypoints for complete-object\n  /// and base-subobject constructors?\n  bool hasConstructorVariants() const {\n    return isItaniumFamily();\n  }\n\n  /// Does this ABI allow virtual bases to be primary base classes?\n  bool hasPrimaryVBases() const {\n    return isItaniumFamily();\n  }\n\n  /// Does this ABI use key functions?  If so, class data such as the\n  /// vtable is emitted with strong linkage by the TU containing the key\n  /// function.\n  bool hasKeyFunctions() const {\n    return isItaniumFamily();\n  }\n\n  /// Can an out-of-line inline function serve as a key function?\n  ///\n  /// This flag is only useful in ABIs where type data (for example,\n  /// vtables and type_info objects) are emitted only after processing\n  /// the definition of a special \"key\" virtual function.  (This is safe\n  /// because the ODR requires that every virtual function be defined\n  /// somewhere in a program.)  This usually permits such data to be\n  /// emitted in only a single object file, as opposed to redundantly\n  /// in every object file that requires it.\n  ///\n  /// One simple and common definition of \"key function\" is the first\n  /// virtual function in the class definition which is not defined there.\n  /// This rule works very well when that function has a non-inline\n  /// definition in some non-header file.  Unfortunately, when that\n  /// function is defined inline, this rule requires the type data\n  /// to be emitted weakly, as if there were no key function.\n  ///\n  /// The ARM ABI observes that the ODR provides an additional guarantee:\n  /// a virtual function is always ODR-used, so if it is defined inline,\n  /// that definition must appear in every translation unit that defines\n  /// the class.  Therefore, there is no reason to allow such functions\n  /// to serve as key functions.\n  ///\n  /// Because this changes the rules for emitting type data,\n  /// it can cause type data to be emitted with both weak and strong\n  /// linkage, which is not allowed on all platforms.  Therefore,\n  /// exploiting this observation requires an ABI break and cannot be\n  /// done on a generic Itanium platform.\n  bool canKeyFunctionBeInline() const {\n    switch (getKind()) {\n    case AppleARM64:\n    case Fuchsia:\n    case GenericARM:\n    case WebAssembly:\n    case WatchOS:\n      return false;\n\n    case GenericAArch64:\n    case GenericItanium:\n    case iOS:   // old iOS compilers did not follow this rule\n    case Microsoft:\n    case GenericMIPS:\n    case XL:\n      return true;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  /// When is record layout allowed to allocate objects in the tail\n  /// padding of a base class?\n  ///\n  /// This decision cannot be changed without breaking platform ABI\n  /// compatibility. In ISO C++98, tail padding reuse was only permitted for\n  /// non-POD base classes, but that restriction was removed retroactively by\n  /// DR 43, and tail padding reuse is always permitted in all de facto C++\n  /// language modes. However, many platforms use a variant of the old C++98\n  /// rule for compatibility.\n  enum TailPaddingUseRules {\n    /// The tail-padding of a base class is always theoretically\n    /// available, even if it's POD.\n    AlwaysUseTailPadding,\n\n    /// Only allocate objects in the tail padding of a base class if\n    /// the base class is not POD according to the rules of C++ TR1.\n    UseTailPaddingUnlessPOD03,\n\n    /// Only allocate objects in the tail padding of a base class if\n    /// the base class is not POD according to the rules of C++11.\n    UseTailPaddingUnlessPOD11\n  };\n  TailPaddingUseRules getTailPaddingUseRules() const {\n    switch (getKind()) {\n    // To preserve binary compatibility, the generic Itanium ABI has\n    // permanently locked the definition of POD to the rules of C++ TR1,\n    // and that trickles down to derived ABIs.\n    case GenericItanium:\n    case GenericAArch64:\n    case GenericARM:\n    case iOS:\n    case GenericMIPS:\n    case XL:\n      return UseTailPaddingUnlessPOD03;\n\n    // AppleARM64 and WebAssembly use the C++11 POD rules.  They do not honor\n    // the Itanium exception about classes with over-large bitfields.\n    case AppleARM64:\n    case Fuchsia:\n    case WebAssembly:\n    case WatchOS:\n      return UseTailPaddingUnlessPOD11;\n\n    // MSVC always allocates fields in the tail-padding of a base class\n    // subobject, even if they're POD.\n    case Microsoft:\n      return AlwaysUseTailPadding;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  friend bool operator==(const TargetCXXABI &left, const TargetCXXABI &right) {\n    return left.getKind() == right.getKind();\n  }\n\n  friend bool operator!=(const TargetCXXABI &left, const TargetCXXABI &right) {\n    return !(left == right);\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h", "content": "//==-- CGFunctionInfo.h - Representation of function argument/return types -==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Defines CGFunctionInfo and associated types used in representing the\n// LLVM source types and ABI-coerced types for function arguments and\n// return values.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_CODEGEN_CGFUNCTIONINFO_H\n#define LLVM_CLANG_CODEGEN_CGFUNCTIONINFO_H\n\n#include \"clang/AST/CanonicalType.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n\nnamespace clang {\nnamespace CodeGen {\n\n/// ABIArgInfo - Helper class to encapsulate information about how a\n/// specific C type should be passed to or returned from a function.\nclass ABIArgInfo {\npublic:\n  enum Kind : uint8_t {\n    /// Direct - Pass the argument directly using the normal converted LLVM\n    /// type, or by coercing to another specified type stored in\n    /// 'CoerceToType').  If an offset is specified (in UIntData), then the\n    /// argument passed is offset by some number of bytes in the memory\n    /// representation. A dummy argument is emitted before the real argument\n    /// if the specified type stored in \"PaddingType\" is not zero.\n    Direct,\n\n    /// Extend - Valid only for integer argument types. Same as 'direct'\n    /// but also emit a zero/sign extension attribute.\n    Extend,\n\n    /// Indirect - Pass the argument indirectly via a hidden pointer with the\n    /// specified alignment (0 indicates default alignment) and address space.\n    Indirect,\n\n    /// IndirectAliased - Similar to Indirect, but the pointer may be to an\n    /// object that is otherwise referenced.  The object is known to not be\n    /// modified through any other references for the duration of the call, and\n    /// the callee must not itself modify the object.  Because C allows\n    /// parameter variables to be modified and guarantees that they have unique\n    /// addresses, the callee must defensively copy the object into a local\n    /// variable if it might be modified or its address might be compared.\n    /// Since those are uncommon, in principle this convention allows programs\n    /// to avoid copies in more situations.  However, it may introduce *extra*\n    /// copies if the callee fails to prove that a copy is unnecessary and the\n    /// caller naturally produces an unaliased object for the argument.\n    IndirectAliased,\n\n    /// Ignore - Ignore the argument (treat as void). Useful for void and\n    /// empty structs.\n    Ignore,\n\n    /// Expand - Only valid for aggregate argument types. The structure should\n    /// be expanded into consecutive arguments for its constituent fields.\n    /// Currently expand is only allowed on structures whose fields\n    /// are all scalar types or are themselves expandable types.\n    Expand,\n\n    /// CoerceAndExpand - Only valid for aggregate argument types. The\n    /// structure should be expanded into consecutive arguments corresponding\n    /// to the non-array elements of the type stored in CoerceToType.\n    /// Array elements in the type are assumed to be padding and skipped.\n    CoerceAndExpand,\n\n    /// InAlloca - Pass the argument directly using the LLVM inalloca attribute.\n    /// This is similar to indirect with byval, except it only applies to\n    /// arguments stored in memory and forbids any implicit copies.  When\n    /// applied to a return type, it means the value is returned indirectly via\n    /// an implicit sret parameter stored in the argument struct.\n    InAlloca,\n    KindFirst = Direct,\n    KindLast = InAlloca\n  };\n\nprivate:\n  llvm::Type *TypeData; // canHaveCoerceToType()\n  union {\n    llvm::Type *PaddingType; // canHavePaddingType()\n    llvm::Type *UnpaddedCoerceAndExpandType; // isCoerceAndExpand()\n  };\n  union {\n    unsigned DirectOffset;     // isDirect() || isExtend()\n    unsigned IndirectAlign;    // isIndirect()\n    unsigned AllocaFieldIndex; // isInAlloca()\n  };\n  Kind TheKind;\n  unsigned IndirectAddrSpace : 24; // isIndirect()\n  bool PaddingInReg : 1;\n  bool InAllocaSRet : 1;    // isInAlloca()\n  bool InAllocaIndirect : 1;// isInAlloca()\n  bool IndirectByVal : 1;   // isIndirect()\n  bool IndirectRealign : 1; // isIndirect()\n  bool SRetAfterThis : 1;   // isIndirect()\n  bool InReg : 1;           // isDirect() || isExtend() || isIndirect()\n  bool CanBeFlattened: 1;   // isDirect()\n  bool SignExt : 1;         // isExtend()\n\n  bool canHavePaddingType() const {\n    return isDirect() || isExtend() || isIndirect() || isIndirectAliased() ||\n           isExpand();\n  }\n  void setPaddingType(llvm::Type *T) {\n    assert(canHavePaddingType());\n    PaddingType = T;\n  }\n\n  void setUnpaddedCoerceToType(llvm::Type *T) {\n    assert(isCoerceAndExpand());\n    UnpaddedCoerceAndExpandType = T;\n  }\n\npublic:\n  ABIArgInfo(Kind K = Direct)\n      : TypeData(nullptr), PaddingType(nullptr), DirectOffset(0), TheKind(K),\n        IndirectAddrSpace(0), PaddingInReg(false), InAllocaSRet(false),\n        InAllocaIndirect(false), IndirectByVal(false), IndirectRealign(false),\n        SRetAfterThis(false), InReg(false), CanBeFlattened(false),\n        SignExt(false) {}\n\n  static ABIArgInfo getDirect(llvm::Type *T = nullptr, unsigned Offset = 0,\n                              llvm::Type *Padding = nullptr,\n                              bool CanBeFlattened = true) {\n    auto AI = ABIArgInfo(Direct);\n    AI.setCoerceToType(T);\n    AI.setPaddingType(Padding);\n    AI.setDirectOffset(Offset);\n    AI.setCanBeFlattened(CanBeFlattened);\n    return AI;\n  }\n  static ABIArgInfo getDirectInReg(llvm::Type *T = nullptr) {\n    auto AI = getDirect(T);\n    AI.setInReg(true);\n    return AI;\n  }\n\n  static ABIArgInfo getSignExtend(QualType Ty, llvm::Type *T = nullptr) {\n    assert(Ty->isIntegralOrEnumerationType() && \"Unexpected QualType\");\n    auto AI = ABIArgInfo(Extend);\n    AI.setCoerceToType(T);\n    AI.setPaddingType(nullptr);\n    AI.setDirectOffset(0);\n    AI.setSignExt(true);\n    return AI;\n  }\n\n  static ABIArgInfo getZeroExtend(QualType Ty, llvm::Type *T = nullptr) {\n    assert(Ty->isIntegralOrEnumerationType() && \"Unexpected QualType\");\n    auto AI = ABIArgInfo(Extend);\n    AI.setCoerceToType(T);\n    AI.setPaddingType(nullptr);\n    AI.setDirectOffset(0);\n    AI.setSignExt(false);\n    return AI;\n  }\n\n  // ABIArgInfo will record the argument as being extended based on the sign\n  // of its type.\n  static ABIArgInfo getExtend(QualType Ty, llvm::Type *T = nullptr) {\n    assert(Ty->isIntegralOrEnumerationType() && \"Unexpected QualType\");\n    if (Ty->hasSignedIntegerRepresentation())\n      return getSignExtend(Ty, T);\n    return getZeroExtend(Ty, T);\n  }\n\n  static ABIArgInfo getExtendInReg(QualType Ty, llvm::Type *T = nullptr) {\n    auto AI = getExtend(Ty, T);\n    AI.setInReg(true);\n    return AI;\n  }\n  static ABIArgInfo getIgnore() {\n    return ABIArgInfo(Ignore);\n  }\n  static ABIArgInfo getIndirect(CharUnits Alignment, bool ByVal = true,\n                                bool Realign = false,\n                                llvm::Type *Padding = nullptr) {\n    auto AI = ABIArgInfo(Indirect);\n    AI.setIndirectAlign(Alignment);\n    AI.setIndirectByVal(ByVal);\n    AI.setIndirectRealign(Realign);\n    AI.setSRetAfterThis(false);\n    AI.setPaddingType(Padding);\n    return AI;\n  }\n\n  /// Pass this in memory using the IR byref attribute.\n  static ABIArgInfo getIndirectAliased(CharUnits Alignment, unsigned AddrSpace,\n                                       bool Realign = false,\n                                       llvm::Type *Padding = nullptr) {\n    auto AI = ABIArgInfo(IndirectAliased);\n    AI.setIndirectAlign(Alignment);\n    AI.setIndirectRealign(Realign);\n    AI.setPaddingType(Padding);\n    AI.setIndirectAddrSpace(AddrSpace);\n    return AI;\n  }\n\n  static ABIArgInfo getIndirectInReg(CharUnits Alignment, bool ByVal = true,\n                                     bool Realign = false) {\n    auto AI = getIndirect(Alignment, ByVal, Realign);\n    AI.setInReg(true);\n    return AI;\n  }\n  static ABIArgInfo getInAlloca(unsigned FieldIndex, bool Indirect = false) {\n    auto AI = ABIArgInfo(InAlloca);\n    AI.setInAllocaFieldIndex(FieldIndex);\n    AI.setInAllocaIndirect(Indirect);\n    return AI;\n  }\n  static ABIArgInfo getExpand() {\n    auto AI = ABIArgInfo(Expand);\n    AI.setPaddingType(nullptr);\n    return AI;\n  }\n  static ABIArgInfo getExpandWithPadding(bool PaddingInReg,\n                                         llvm::Type *Padding) {\n    auto AI = getExpand();\n    AI.setPaddingInReg(PaddingInReg);\n    AI.setPaddingType(Padding);\n    return AI;\n  }\n\n  /// \\param unpaddedCoerceToType The coerce-to type with padding elements\n  ///   removed, canonicalized to a single element if it would otherwise\n  ///   have exactly one element.\n  static ABIArgInfo getCoerceAndExpand(llvm::StructType *coerceToType,\n                                       llvm::Type *unpaddedCoerceToType) {\n#ifndef NDEBUG\n    // Sanity checks on unpaddedCoerceToType.\n\n    // Assert that we only have a struct type if there are multiple elements.\n    auto unpaddedStruct = dyn_cast<llvm::StructType>(unpaddedCoerceToType);\n    assert(!unpaddedStruct || unpaddedStruct->getNumElements() != 1);\n\n    // Assert that all the non-padding elements have a corresponding element\n    // in the unpadded type.\n    unsigned unpaddedIndex = 0;\n    for (auto eltType : coerceToType->elements()) {\n      if (isPaddingForCoerceAndExpand(eltType)) continue;\n      if (unpaddedStruct) {\n        assert(unpaddedStruct->getElementType(unpaddedIndex) == eltType);\n      } else {\n        assert(unpaddedIndex == 0 && unpaddedCoerceToType == eltType);\n      }\n      unpaddedIndex++;\n    }\n\n    // Assert that there aren't extra elements in the unpadded type.\n    if (unpaddedStruct) {\n      assert(unpaddedStruct->getNumElements() == unpaddedIndex);\n    } else {\n      assert(unpaddedIndex == 1);\n    }\n#endif\n\n    auto AI = ABIArgInfo(CoerceAndExpand);\n    AI.setCoerceToType(coerceToType);\n    AI.setUnpaddedCoerceToType(unpaddedCoerceToType);\n    return AI;\n  }\n\n  static bool isPaddingForCoerceAndExpand(llvm::Type *eltType) {\n    if (eltType->isArrayTy()) {\n      assert(eltType->getArrayElementType()->isIntegerTy(8));\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  Kind getKind() const { return TheKind; }\n  bool isDirect() const { return TheKind == Direct; }\n  bool isInAlloca() const { return TheKind == InAlloca; }\n  bool isExtend() const { return TheKind == Extend; }\n  bool isIgnore() const { return TheKind == Ignore; }\n  bool isIndirect() const { return TheKind == Indirect; }\n  bool isIndirectAliased() const { return TheKind == IndirectAliased; }\n  bool isExpand() const { return TheKind == Expand; }\n  bool isCoerceAndExpand() const { return TheKind == CoerceAndExpand; }\n\n  bool canHaveCoerceToType() const {\n    return isDirect() || isExtend() || isCoerceAndExpand();\n  }\n\n  // Direct/Extend accessors\n  unsigned getDirectOffset() const {\n    assert((isDirect() || isExtend()) && \"Not a direct or extend kind\");\n    return DirectOffset;\n  }\n  void setDirectOffset(unsigned Offset) {\n    assert((isDirect() || isExtend()) && \"Not a direct or extend kind\");\n    DirectOffset = Offset;\n  }\n\n  bool isSignExt() const {\n    assert(isExtend() && \"Invalid kind!\");\n    return SignExt;\n  }\n  void setSignExt(bool SExt) {\n    assert(isExtend() && \"Invalid kind!\");\n    SignExt = SExt;\n  }\n\n  llvm::Type *getPaddingType() const {\n    return (canHavePaddingType() ? PaddingType : nullptr);\n  }\n\n  bool getPaddingInReg() const {\n    return PaddingInReg;\n  }\n  void setPaddingInReg(bool PIR) {\n    PaddingInReg = PIR;\n  }\n\n  llvm::Type *getCoerceToType() const {\n    assert(canHaveCoerceToType() && \"Invalid kind!\");\n    return TypeData;\n  }\n\n  void setCoerceToType(llvm::Type *T) {\n    assert(canHaveCoerceToType() && \"Invalid kind!\");\n    TypeData = T;\n  }\n\n  llvm::StructType *getCoerceAndExpandType() const {\n    assert(isCoerceAndExpand());\n    return cast<llvm::StructType>(TypeData);\n  }\n\n  llvm::Type *getUnpaddedCoerceAndExpandType() const {\n    assert(isCoerceAndExpand());\n    return UnpaddedCoerceAndExpandType;\n  }\n\n  ArrayRef<llvm::Type *>getCoerceAndExpandTypeSequence() const {\n    assert(isCoerceAndExpand());\n    if (auto structTy =\n          dyn_cast<llvm::StructType>(UnpaddedCoerceAndExpandType)) {\n      return structTy->elements();\n    } else {\n      return llvm::makeArrayRef(&UnpaddedCoerceAndExpandType, 1);\n    }\n  }\n\n  bool getInReg() const {\n    assert((isDirect() || isExtend() || isIndirect()) && \"Invalid kind!\");\n    return InReg;\n  }\n\n  void setInReg(bool IR) {\n    assert((isDirect() || isExtend() || isIndirect()) && \"Invalid kind!\");\n    InReg = IR;\n  }\n\n  // Indirect accessors\n  CharUnits getIndirectAlign() const {\n    assert((isIndirect() || isIndirectAliased()) && \"Invalid kind!\");\n    return CharUnits::fromQuantity(IndirectAlign);\n  }\n  void setIndirectAlign(CharUnits IA) {\n    assert((isIndirect() || isIndirectAliased()) && \"Invalid kind!\");\n    IndirectAlign = IA.getQuantity();\n  }\n\n  bool getIndirectByVal() const {\n    assert(isIndirect() && \"Invalid kind!\");\n    return IndirectByVal;\n  }\n  void setIndirectByVal(bool IBV) {\n    assert(isIndirect() && \"Invalid kind!\");\n    IndirectByVal = IBV;\n  }\n\n  unsigned getIndirectAddrSpace() const {\n    assert(isIndirectAliased() && \"Invalid kind!\");\n    return IndirectAddrSpace;\n  }\n\n  void setIndirectAddrSpace(unsigned AddrSpace) {\n    assert(isIndirectAliased() && \"Invalid kind!\");\n    IndirectAddrSpace = AddrSpace;\n  }\n\n  bool getIndirectRealign() const {\n    assert((isIndirect() || isIndirectAliased()) && \"Invalid kind!\");\n    return IndirectRealign;\n  }\n  void setIndirectRealign(bool IR) {\n    assert((isIndirect() || isIndirectAliased()) && \"Invalid kind!\");\n    IndirectRealign = IR;\n  }\n\n  bool isSRetAfterThis() const {\n    assert(isIndirect() && \"Invalid kind!\");\n    return SRetAfterThis;\n  }\n  void setSRetAfterThis(bool AfterThis) {\n    assert(isIndirect() && \"Invalid kind!\");\n    SRetAfterThis = AfterThis;\n  }\n\n  unsigned getInAllocaFieldIndex() const {\n    assert(isInAlloca() && \"Invalid kind!\");\n    return AllocaFieldIndex;\n  }\n  void setInAllocaFieldIndex(unsigned FieldIndex) {\n    assert(isInAlloca() && \"Invalid kind!\");\n    AllocaFieldIndex = FieldIndex;\n  }\n\n  unsigned getInAllocaIndirect() const {\n    assert(isInAlloca() && \"Invalid kind!\");\n    return InAllocaIndirect;\n  }\n  void setInAllocaIndirect(bool Indirect) {\n    assert(isInAlloca() && \"Invalid kind!\");\n    InAllocaIndirect = Indirect;\n  }\n\n  /// Return true if this field of an inalloca struct should be returned\n  /// to implement a struct return calling convention.\n  bool getInAllocaSRet() const {\n    assert(isInAlloca() && \"Invalid kind!\");\n    return InAllocaSRet;\n  }\n\n  void setInAllocaSRet(bool SRet) {\n    assert(isInAlloca() && \"Invalid kind!\");\n    InAllocaSRet = SRet;\n  }\n\n  bool getCanBeFlattened() const {\n    assert(isDirect() && \"Invalid kind!\");\n    return CanBeFlattened;\n  }\n\n  void setCanBeFlattened(bool Flatten) {\n    assert(isDirect() && \"Invalid kind!\");\n    CanBeFlattened = Flatten;\n  }\n\n  void dump() const;\n};\n\n/// A class for recording the number of arguments that a function\n/// signature requires.\nclass RequiredArgs {\n  /// The number of required arguments, or ~0 if the signature does\n  /// not permit optional arguments.\n  unsigned NumRequired;\npublic:\n  enum All_t { All };\n\n  RequiredArgs(All_t _) : NumRequired(~0U) {}\n  explicit RequiredArgs(unsigned n) : NumRequired(n) {\n    assert(n != ~0U);\n  }\n\n  /// Compute the arguments required by the given formal prototype,\n  /// given that there may be some additional, non-formal arguments\n  /// in play.\n  ///\n  /// If FD is not null, this will consider pass_object_size params in FD.\n  static RequiredArgs forPrototypePlus(const FunctionProtoType *prototype,\n                                       unsigned additional) {\n    if (!prototype->isVariadic()) return All;\n\n    if (prototype->hasExtParameterInfos())\n      additional += llvm::count_if(\n          prototype->getExtParameterInfos(),\n          [](const FunctionProtoType::ExtParameterInfo &ExtInfo) {\n            return ExtInfo.hasPassObjectSize();\n          });\n\n    return RequiredArgs(prototype->getNumParams() + additional);\n  }\n\n  static RequiredArgs forPrototypePlus(CanQual<FunctionProtoType> prototype,\n                                       unsigned additional) {\n    return forPrototypePlus(prototype.getTypePtr(), additional);\n  }\n\n  static RequiredArgs forPrototype(const FunctionProtoType *prototype) {\n    return forPrototypePlus(prototype, 0);\n  }\n\n  static RequiredArgs forPrototype(CanQual<FunctionProtoType> prototype) {\n    return forPrototypePlus(prototype.getTypePtr(), 0);\n  }\n\n  bool allowsOptionalArgs() const { return NumRequired != ~0U; }\n  unsigned getNumRequiredArgs() const {\n    assert(allowsOptionalArgs());\n    return NumRequired;\n  }\n\n  unsigned getOpaqueData() const { return NumRequired; }\n  static RequiredArgs getFromOpaqueData(unsigned value) {\n    if (value == ~0U) return All;\n    return RequiredArgs(value);\n  }\n};\n\n// Implementation detail of CGFunctionInfo, factored out so it can be named\n// in the TrailingObjects base class of CGFunctionInfo.\nstruct CGFunctionInfoArgInfo {\n  CanQualType type;\n  ABIArgInfo info;\n};\n\n/// CGFunctionInfo - Class to encapsulate the information about a\n/// function definition.\nclass CGFunctionInfo final\n    : public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<CGFunctionInfo, CGFunctionInfoArgInfo,\n                                    FunctionProtoType::ExtParameterInfo> {\n  typedef CGFunctionInfoArgInfo ArgInfo;\n  typedef FunctionProtoType::ExtParameterInfo ExtParameterInfo;\n\n  /// The LLVM::CallingConv to use for this function (as specified by the\n  /// user).\n  unsigned CallingConvention : 8;\n\n  /// The LLVM::CallingConv to actually use for this function, which may\n  /// depend on the ABI.\n  unsigned EffectiveCallingConvention : 8;\n\n  /// The clang::CallingConv that this was originally created with.\n  unsigned ASTCallingConvention : 6;\n\n  /// Whether this is an instance method.\n  unsigned InstanceMethod : 1;\n\n  /// Whether this is a chain call.\n  unsigned ChainCall : 1;\n\n  /// Whether this function is a CMSE nonsecure call\n  unsigned CmseNSCall : 1;\n\n  /// Whether this function is noreturn.\n  unsigned NoReturn : 1;\n\n  /// Whether this function is returns-retained.\n  unsigned ReturnsRetained : 1;\n\n  /// Whether this function saved caller registers.\n  unsigned NoCallerSavedRegs : 1;\n\n  /// How many arguments to pass inreg.\n  unsigned HasRegParm : 1;\n  unsigned RegParm : 3;\n\n  /// Whether this function has nocf_check attribute.\n  unsigned NoCfCheck : 1;\n\n  RequiredArgs Required;\n\n  /// The struct representing all arguments passed in memory.  Only used when\n  /// passing non-trivial types with inalloca.  Not part of the profile.\n  llvm::StructType *ArgStruct;\n  unsigned ArgStructAlign : 31;\n  unsigned HasExtParameterInfos : 1;\n\n  unsigned NumArgs;\n\n  ArgInfo *getArgsBuffer() {\n    return getTrailingObjects<ArgInfo>();\n  }\n  const ArgInfo *getArgsBuffer() const {\n    return getTrailingObjects<ArgInfo>();\n  }\n\n  ExtParameterInfo *getExtParameterInfosBuffer() {\n    return getTrailingObjects<ExtParameterInfo>();\n  }\n  const ExtParameterInfo *getExtParameterInfosBuffer() const{\n    return getTrailingObjects<ExtParameterInfo>();\n  }\n\n  CGFunctionInfo() : Required(RequiredArgs::All) {}\n\npublic:\n  static CGFunctionInfo *create(unsigned llvmCC,\n                                bool instanceMethod,\n                                bool chainCall,\n                                const FunctionType::ExtInfo &extInfo,\n                                ArrayRef<ExtParameterInfo> paramInfos,\n                                CanQualType resultType,\n                                ArrayRef<CanQualType> argTypes,\n                                RequiredArgs required);\n  void operator delete(void *p) { ::operator delete(p); }\n\n  // Friending class TrailingObjects is apparently not good enough for MSVC,\n  // so these have to be public.\n  friend class TrailingObjects;\n  size_t numTrailingObjects(OverloadToken<ArgInfo>) const {\n    return NumArgs + 1;\n  }\n  size_t numTrailingObjects(OverloadToken<ExtParameterInfo>) const {\n    return (HasExtParameterInfos ? NumArgs : 0);\n  }\n\n  typedef const ArgInfo *const_arg_iterator;\n  typedef ArgInfo *arg_iterator;\n\n  MutableArrayRef<ArgInfo> arguments() {\n    return MutableArrayRef<ArgInfo>(arg_begin(), NumArgs);\n  }\n  ArrayRef<ArgInfo> arguments() const {\n    return ArrayRef<ArgInfo>(arg_begin(), NumArgs);\n  }\n\n  const_arg_iterator arg_begin() const { return getArgsBuffer() + 1; }\n  const_arg_iterator arg_end() const { return getArgsBuffer() + 1 + NumArgs; }\n  arg_iterator arg_begin() { return getArgsBuffer() + 1; }\n  arg_iterator arg_end() { return getArgsBuffer() + 1 + NumArgs; }\n\n  unsigned  arg_size() const { return NumArgs; }\n\n  bool isVariadic() const { return Required.allowsOptionalArgs(); }\n  RequiredArgs getRequiredArgs() const { return Required; }\n  unsigned getNumRequiredArgs() const {\n    return isVariadic() ? getRequiredArgs().getNumRequiredArgs() : arg_size();\n  }\n\n  bool isInstanceMethod() const { return InstanceMethod; }\n\n  bool isChainCall() const { return ChainCall; }\n\n  bool isCmseNSCall() const { return CmseNSCall; }\n\n  bool isNoReturn() const { return NoReturn; }\n\n  /// In ARC, whether this function retains its return value.  This\n  /// is not always reliable for call sites.\n  bool isReturnsRetained() const { return ReturnsRetained; }\n\n  /// Whether this function no longer saves caller registers.\n  bool isNoCallerSavedRegs() const { return NoCallerSavedRegs; }\n\n  /// Whether this function has nocf_check attribute.\n  bool isNoCfCheck() const { return NoCfCheck; }\n\n  /// getASTCallingConvention() - Return the AST-specified calling\n  /// convention.\n  CallingConv getASTCallingConvention() const {\n    return CallingConv(ASTCallingConvention);\n  }\n\n  /// getCallingConvention - Return the user specified calling\n  /// convention, which has been translated into an LLVM CC.\n  unsigned getCallingConvention() const { return CallingConvention; }\n\n  /// getEffectiveCallingConvention - Return the actual calling convention to\n  /// use, which may depend on the ABI.\n  unsigned getEffectiveCallingConvention() const {\n    return EffectiveCallingConvention;\n  }\n  void setEffectiveCallingConvention(unsigned Value) {\n    EffectiveCallingConvention = Value;\n  }\n\n  bool getHasRegParm() const { return HasRegParm; }\n  unsigned getRegParm() const { return RegParm; }\n\n  FunctionType::ExtInfo getExtInfo() const {\n    return FunctionType::ExtInfo(isNoReturn(), getHasRegParm(), getRegParm(),\n                                 getASTCallingConvention(), isReturnsRetained(),\n                                 isNoCallerSavedRegs(), isNoCfCheck(),\n                                 isCmseNSCall());\n  }\n\n  CanQualType getReturnType() const { return getArgsBuffer()[0].type; }\n\n  ABIArgInfo &getReturnInfo() { return getArgsBuffer()[0].info; }\n  const ABIArgInfo &getReturnInfo() const { return getArgsBuffer()[0].info; }\n\n  ArrayRef<ExtParameterInfo> getExtParameterInfos() const {\n    if (!HasExtParameterInfos) return {};\n    return llvm::makeArrayRef(getExtParameterInfosBuffer(), NumArgs);\n  }\n  ExtParameterInfo getExtParameterInfo(unsigned argIndex) const {\n    assert(argIndex <= NumArgs);\n    if (!HasExtParameterInfos) return ExtParameterInfo();\n    return getExtParameterInfos()[argIndex];\n  }\n\n  /// Return true if this function uses inalloca arguments.\n  bool usesInAlloca() const { return ArgStruct; }\n\n  /// Get the struct type used to represent all the arguments in memory.\n  llvm::StructType *getArgStruct() const { return ArgStruct; }\n  CharUnits getArgStructAlignment() const {\n    return CharUnits::fromQuantity(ArgStructAlign);\n  }\n  void setArgStruct(llvm::StructType *Ty, CharUnits Align) {\n    ArgStruct = Ty;\n    ArgStructAlign = Align.getQuantity();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    ID.AddInteger(getASTCallingConvention());\n    ID.AddBoolean(InstanceMethod);\n    ID.AddBoolean(ChainCall);\n    ID.AddBoolean(NoReturn);\n    ID.AddBoolean(ReturnsRetained);\n    ID.AddBoolean(NoCallerSavedRegs);\n    ID.AddBoolean(HasRegParm);\n    ID.AddInteger(RegParm);\n    ID.AddBoolean(NoCfCheck);\n    ID.AddBoolean(CmseNSCall);\n    ID.AddInteger(Required.getOpaqueData());\n    ID.AddBoolean(HasExtParameterInfos);\n    if (HasExtParameterInfos) {\n      for (auto paramInfo : getExtParameterInfos())\n        ID.AddInteger(paramInfo.getOpaqueValue());\n    }\n    getReturnType().Profile(ID);\n    for (const auto &I : arguments())\n      I.type.Profile(ID);\n  }\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      bool InstanceMethod,\n                      bool ChainCall,\n                      const FunctionType::ExtInfo &info,\n                      ArrayRef<ExtParameterInfo> paramInfos,\n                      RequiredArgs required,\n                      CanQualType resultType,\n                      ArrayRef<CanQualType> argTypes) {\n    ID.AddInteger(info.getCC());\n    ID.AddBoolean(InstanceMethod);\n    ID.AddBoolean(ChainCall);\n    ID.AddBoolean(info.getNoReturn());\n    ID.AddBoolean(info.getProducesResult());\n    ID.AddBoolean(info.getNoCallerSavedRegs());\n    ID.AddBoolean(info.getHasRegParm());\n    ID.AddInteger(info.getRegParm());\n    ID.AddBoolean(info.getNoCfCheck());\n    ID.AddBoolean(info.getCmseNSCall());\n    ID.AddInteger(required.getOpaqueData());\n    ID.AddBoolean(!paramInfos.empty());\n    if (!paramInfos.empty()) {\n      for (auto paramInfo : paramInfos)\n        ID.AddInteger(paramInfo.getOpaqueValue());\n    }\n    resultType.Profile(ID);\n    for (ArrayRef<CanQualType>::iterator\n           i = argTypes.begin(), e = argTypes.end(); i != e; ++i) {\n      i->Profile(ID);\n    }\n  }\n};\n\n}  // end namespace CodeGen\n}  // end namespace clang\n\n#endif\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h", "content": "//===- PreprocessorOptions.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSOROPTIONS_H_\n#define LLVM_CLANG_LEX_PREPROCESSOROPTIONS_H_\n\n#include \"clang/Basic/BitmaskEnum.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include <functional>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\n} // namespace llvm\n\nnamespace clang {\n\n/// Enumerate the kinds of standard library that\nenum ObjCXXARCStandardLibraryKind {\n  ARCXX_nolib,\n\n  /// libc++\n  ARCXX_libcxx,\n\n  /// libstdc++\n  ARCXX_libstdcxx\n};\n\n/// Whether to disable the normal validation performed on precompiled\n/// headers and module files when they are loaded.\nenum class DisableValidationForModuleKind {\n  /// Perform validation, don't disable it.\n  None = 0,\n\n  /// Disable validation for a precompiled header and the modules it depends on.\n  PCH = 0x1,\n\n  /// Disable validation for module files.\n  Module = 0x2,\n\n  /// Disable validation for all kinds.\n  All = PCH | Module,\n\n  LLVM_MARK_AS_BITMASK_ENUM(Module)\n};\n\n/// PreprocessorOptions - This class is used for passing the various options\n/// used in preprocessor initialization to InitializePreprocessor().\nclass PreprocessorOptions {\npublic:\n  std::vector<std::pair<std::string, bool/*isUndef*/>> Macros;\n  std::vector<std::string> Includes;\n  std::vector<std::string> MacroIncludes;\n\n  /// Initialize the preprocessor with the compiler and target specific\n  /// predefines.\n  bool UsePredefines = true;\n\n  /// Whether we should maintain a detailed record of all macro\n  /// definitions and expansions.\n  bool DetailedRecord = false;\n\n  /// When true, we are creating or using a PCH where a #pragma hdrstop is\n  /// expected to indicate the beginning or end of the PCH.\n  bool PCHWithHdrStop = false;\n\n  /// When true, we are creating a PCH or creating the PCH object while\n  /// expecting a #pragma hdrstop to separate the two.  Allow for a\n  /// missing #pragma hdrstop, which generates a PCH for the whole file,\n  /// and creates an empty PCH object.\n  bool PCHWithHdrStopCreate = false;\n\n  /// If non-empty, the filename used in an #include directive in the primary\n  /// source file (or command-line preinclude) that is used to implement\n  /// MSVC-style precompiled headers. When creating a PCH, after the #include\n  /// of this header, the PCH generation stops. When using a PCH, tokens are\n  /// skipped until after an #include of this header is seen.\n  std::string PCHThroughHeader;\n\n  /// The implicit PCH included at the start of the translation unit, or empty.\n  std::string ImplicitPCHInclude;\n\n  /// Headers that will be converted to chained PCHs in memory.\n  std::vector<std::string> ChainedIncludes;\n\n  /// Whether to disable most of the normal validation performed on\n  /// precompiled headers and module files.\n  DisableValidationForModuleKind DisablePCHOrModuleValidation =\n      DisableValidationForModuleKind::None;\n\n  /// When true, a PCH with compiler errors will not be rejected.\n  bool AllowPCHWithCompilerErrors = false;\n\n  /// Dump declarations that are deserialized from PCH, for testing.\n  bool DumpDeserializedPCHDecls = false;\n\n  /// This is a set of names for decls that we do not want to be\n  /// deserialized, and we emit an error if they are; for testing purposes.\n  std::set<std::string> DeserializedPCHDeclsToErrorOn;\n\n  /// If non-zero, the implicit PCH include is actually a precompiled\n  /// preamble that covers this number of bytes in the main source file.\n  ///\n  /// The boolean indicates whether the preamble ends at the start of a new\n  /// line.\n  std::pair<unsigned, bool> PrecompiledPreambleBytes;\n\n  /// True indicates that a preamble is being generated.\n  ///\n  /// When the lexer is done, one of the things that need to be preserved is the\n  /// conditional #if stack, so the ASTWriter/ASTReader can save/restore it when\n  /// processing the rest of the file.\n  bool GeneratePreamble = false;\n\n  /// Whether to write comment locations into the PCH when building it.\n  /// Reading the comments from the PCH can be a performance hit even if the\n  /// clients don't use them.\n  bool WriteCommentListToPCH = true;\n\n  /// When enabled, preprocessor is in a mode for parsing a single file only.\n  ///\n  /// Disables #includes of other files and if there are unresolved identifiers\n  /// in preprocessor directive conditions it causes all blocks to be parsed so\n  /// that the client can get the maximum amount of information from the parser.\n  bool SingleFileParseMode = false;\n\n  /// When enabled, the preprocessor will construct editor placeholder tokens.\n  bool LexEditorPlaceholders = true;\n\n  /// True if the SourceManager should report the original file name for\n  /// contents of files that were remapped to other files. Defaults to true.\n  bool RemappedFilesKeepOriginalName = true;\n\n  /// The set of file remappings, which take existing files on\n  /// the system (the first part of each pair) and gives them the\n  /// contents of other files on the system (the second part of each\n  /// pair).\n  std::vector<std::pair<std::string, std::string>> RemappedFiles;\n\n  /// The set of file-to-buffer remappings, which take existing files\n  /// on the system (the first part of each pair) and gives them the contents\n  /// of the specified memory buffer (the second part of each pair).\n  std::vector<std::pair<std::string, llvm::MemoryBuffer *>> RemappedFileBuffers;\n\n  /// Whether the compiler instance should retain (i.e., not free)\n  /// the buffers associated with remapped files.\n  ///\n  /// This flag defaults to false; it can be set true only through direct\n  /// manipulation of the compiler invocation object, in cases where the\n  /// compiler invocation and its buffers will be reused.\n  bool RetainRemappedFileBuffers = false;\n\n  /// When enabled, excluded conditional blocks retain in the main file.\n  bool RetainExcludedConditionalBlocks = false;\n\n  /// The Objective-C++ ARC standard library that we should support,\n  /// by providing appropriate definitions to retrofit the standard library\n  /// with support for lifetime-qualified pointers.\n  ObjCXXARCStandardLibraryKind ObjCXXARCStandardLibrary = ARCXX_nolib;\n\n  /// Records the set of modules\n  class FailedModulesSet {\n    llvm::StringSet<> Failed;\n\n  public:\n    bool hasAlreadyFailed(StringRef module) {\n      return Failed.count(module) > 0;\n    }\n\n    void addFailed(StringRef module) {\n      Failed.insert(module);\n    }\n  };\n\n  /// The set of modules that failed to build.\n  ///\n  /// This pointer will be shared among all of the compiler instances created\n  /// to (re)build modules, so that once a module fails to build anywhere,\n  /// other instances will see that the module has failed and won't try to\n  /// build it again.\n  std::shared_ptr<FailedModulesSet> FailedModules;\n\n  /// A prefix map for __FILE__ and __BASE_FILE__.\n  std::map<std::string, std::string, std::greater<std::string>> MacroPrefixMap;\n\n  /// Contains the currently active skipped range mappings for skipping excluded\n  /// conditional directives.\n  ///\n  /// The pointer is passed to the Preprocessor when it's constructed. The\n  /// pointer is unowned, the client is responsible for its lifetime.\n  ExcludedPreprocessorDirectiveSkipMapping\n      *ExcludedConditionalDirectiveSkipMappings = nullptr;\n\n  /// Set up preprocessor for RunAnalysis action.\n  bool SetUpStaticAnalyzer = false;\n\n  /// Prevents intended crashes when using #pragma clang __debug. For testing.\n  bool DisablePragmaDebugCrash = false;\n\npublic:\n  PreprocessorOptions() : PrecompiledPreambleBytes(0, false) {}\n\n  void addMacroDef(StringRef Name) {\n    Macros.emplace_back(std::string(Name), false);\n  }\n  void addMacroUndef(StringRef Name) {\n    Macros.emplace_back(std::string(Name), true);\n  }\n\n  void addRemappedFile(StringRef From, StringRef To) {\n    RemappedFiles.emplace_back(std::string(From), std::string(To));\n  }\n\n  void addRemappedFile(StringRef From, llvm::MemoryBuffer *To) {\n    RemappedFileBuffers.emplace_back(std::string(From), To);\n  }\n\n  void clearRemappedFiles() {\n    RemappedFiles.clear();\n    RemappedFileBuffers.clear();\n  }\n\n  /// Reset any options that are not considered when building a\n  /// module.\n  void resetNonModularOptions() {\n    Includes.clear();\n    MacroIncludes.clear();\n    ChainedIncludes.clear();\n    DumpDeserializedPCHDecls = false;\n    ImplicitPCHInclude.clear();\n    SingleFileParseMode = false;\n    LexEditorPlaceholders = true;\n    RetainRemappedFileBuffers = true;\n    PrecompiledPreambleBytes.first = 0;\n    PrecompiledPreambleBytes.second = false;\n    RetainExcludedConditionalBlocks = false;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PREPROCESSOROPTIONS_H_\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGCall.h", "content": "//===----- CGCall.h - Encapsulate calling convention details ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// These classes wrap the information about a call or function\n// definition used to handle ABI compliancy.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CGCALL_H\n#define LLVM_CLANG_LIB_CODEGEN_CGCALL_H\n\n#include \"CGValue.h\"\n#include \"EHScopeStack.h\"\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/CanonicalType.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/Type.h\"\n#include \"llvm/IR/Value.h\"\n\n// FIXME: Restructure so we don't have to expose so much stuff.\n#include \"ABIInfo.h\"\n\nnamespace llvm {\nclass AttributeList;\nclass Function;\nclass Type;\nclass Value;\n} // namespace llvm\n\nnamespace clang {\nclass ASTContext;\nclass Decl;\nclass FunctionDecl;\nclass ObjCMethodDecl;\nclass VarDecl;\n\nnamespace CodeGen {\n\n/// Abstract information about a function or function prototype.\nclass CGCalleeInfo {\n  /// The function prototype of the callee.\n  const FunctionProtoType *CalleeProtoTy;\n  /// The function declaration of the callee.\n  GlobalDecl CalleeDecl;\n\npublic:\n  explicit CGCalleeInfo() : CalleeProtoTy(nullptr), CalleeDecl() {}\n  CGCalleeInfo(const FunctionProtoType *calleeProtoTy, GlobalDecl calleeDecl)\n      : CalleeProtoTy(calleeProtoTy), CalleeDecl(calleeDecl) {}\n  CGCalleeInfo(const FunctionProtoType *calleeProtoTy)\n      : CalleeProtoTy(calleeProtoTy), CalleeDecl() {}\n  CGCalleeInfo(GlobalDecl calleeDecl)\n      : CalleeProtoTy(nullptr), CalleeDecl(calleeDecl) {}\n\n  const FunctionProtoType *getCalleeFunctionProtoType() const {\n    return CalleeProtoTy;\n  }\n  const GlobalDecl getCalleeDecl() const { return CalleeDecl; }\n};\n\n/// All available information about a concrete callee.\nclass CGCallee {\n  enum class SpecialKind : uintptr_t {\n    Invalid,\n    Builtin,\n    PseudoDestructor,\n    Virtual,\n\n    Last = Virtual\n  };\n\n  struct BuiltinInfoStorage {\n    const FunctionDecl *Decl;\n    unsigned ID;\n  };\n  struct PseudoDestructorInfoStorage {\n    const CXXPseudoDestructorExpr *Expr;\n  };\n  struct VirtualInfoStorage {\n    const CallExpr *CE;\n    GlobalDecl MD;\n    Address Addr;\n    llvm::FunctionType *FTy;\n  };\n\n  SpecialKind KindOrFunctionPointer;\n  union {\n    CGCalleeInfo AbstractInfo;\n    BuiltinInfoStorage BuiltinInfo;\n    PseudoDestructorInfoStorage PseudoDestructorInfo;\n    VirtualInfoStorage VirtualInfo;\n  };\n\n  explicit CGCallee(SpecialKind kind) : KindOrFunctionPointer(kind) {}\n\n  CGCallee(const FunctionDecl *builtinDecl, unsigned builtinID)\n      : KindOrFunctionPointer(SpecialKind::Builtin) {\n    BuiltinInfo.Decl = builtinDecl;\n    BuiltinInfo.ID = builtinID;\n  }\n\npublic:\n  CGCallee() : KindOrFunctionPointer(SpecialKind::Invalid) {}\n\n  /// Construct a callee.  Call this constructor directly when this\n  /// isn't a direct call.\n  CGCallee(const CGCalleeInfo &abstractInfo, llvm::Value *functionPtr)\n      : KindOrFunctionPointer(\n            SpecialKind(reinterpret_cast<uintptr_t>(functionPtr))) {\n    AbstractInfo = abstractInfo;\n    assert(functionPtr && \"configuring callee without function pointer\");\n    assert(functionPtr->getType()->isPointerTy());\n    assert(functionPtr->getType()->getPointerElementType()->isFunctionTy());\n  }\n\n  static CGCallee forBuiltin(unsigned builtinID,\n                             const FunctionDecl *builtinDecl) {\n    CGCallee result(SpecialKind::Builtin);\n    result.BuiltinInfo.Decl = builtinDecl;\n    result.BuiltinInfo.ID = builtinID;\n    return result;\n  }\n\n  static CGCallee forPseudoDestructor(const CXXPseudoDestructorExpr *E) {\n    CGCallee result(SpecialKind::PseudoDestructor);\n    result.PseudoDestructorInfo.Expr = E;\n    return result;\n  }\n\n  static CGCallee forDirect(llvm::Constant *functionPtr,\n                            const CGCalleeInfo &abstractInfo = CGCalleeInfo()) {\n    return CGCallee(abstractInfo, functionPtr);\n  }\n\n  static CGCallee forDirect(llvm::FunctionCallee functionPtr,\n                            const CGCalleeInfo &abstractInfo = CGCalleeInfo()) {\n    return CGCallee(abstractInfo, functionPtr.getCallee());\n  }\n\n  static CGCallee forVirtual(const CallExpr *CE, GlobalDecl MD, Address Addr,\n                             llvm::FunctionType *FTy) {\n    CGCallee result(SpecialKind::Virtual);\n    result.VirtualInfo.CE = CE;\n    result.VirtualInfo.MD = MD;\n    result.VirtualInfo.Addr = Addr;\n    result.VirtualInfo.FTy = FTy;\n    return result;\n  }\n\n  bool isBuiltin() const {\n    return KindOrFunctionPointer == SpecialKind::Builtin;\n  }\n  const FunctionDecl *getBuiltinDecl() const {\n    assert(isBuiltin());\n    return BuiltinInfo.Decl;\n  }\n  unsigned getBuiltinID() const {\n    assert(isBuiltin());\n    return BuiltinInfo.ID;\n  }\n\n  bool isPseudoDestructor() const {\n    return KindOrFunctionPointer == SpecialKind::PseudoDestructor;\n  }\n  const CXXPseudoDestructorExpr *getPseudoDestructorExpr() const {\n    assert(isPseudoDestructor());\n    return PseudoDestructorInfo.Expr;\n  }\n\n  bool isOrdinary() const {\n    return uintptr_t(KindOrFunctionPointer) > uintptr_t(SpecialKind::Last);\n  }\n  CGCalleeInfo getAbstractInfo() const {\n    if (isVirtual())\n      return VirtualInfo.MD;\n    assert(isOrdinary());\n    return AbstractInfo;\n  }\n  llvm::Value *getFunctionPointer() const {\n    assert(isOrdinary());\n    return reinterpret_cast<llvm::Value *>(uintptr_t(KindOrFunctionPointer));\n  }\n  void setFunctionPointer(llvm::Value *functionPtr) {\n    assert(isOrdinary());\n    KindOrFunctionPointer =\n        SpecialKind(reinterpret_cast<uintptr_t>(functionPtr));\n  }\n\n  bool isVirtual() const {\n    return KindOrFunctionPointer == SpecialKind::Virtual;\n  }\n  const CallExpr *getVirtualCallExpr() const {\n    assert(isVirtual());\n    return VirtualInfo.CE;\n  }\n  GlobalDecl getVirtualMethodDecl() const {\n    assert(isVirtual());\n    return VirtualInfo.MD;\n  }\n  Address getThisAddress() const {\n    assert(isVirtual());\n    return VirtualInfo.Addr;\n  }\n  llvm::FunctionType *getVirtualFunctionType() const {\n    assert(isVirtual());\n    return VirtualInfo.FTy;\n  }\n\n  /// If this is a delayed callee computation of some sort, prepare\n  /// a concrete callee.\n  CGCallee prepareConcreteCallee(CodeGenFunction &CGF) const;\n};\n\nstruct CallArg {\nprivate:\n  union {\n    RValue RV;\n    LValue LV; /// The argument is semantically a load from this l-value.\n  };\n  bool HasLV;\n\n  /// A data-flow flag to make sure getRValue and/or copyInto are not\n  /// called twice for duplicated IR emission.\n  mutable bool IsUsed;\n\npublic:\n  QualType Ty;\n  CallArg(RValue rv, QualType ty)\n      : RV(rv), HasLV(false), IsUsed(false), Ty(ty) {}\n  CallArg(LValue lv, QualType ty)\n      : LV(lv), HasLV(true), IsUsed(false), Ty(ty) {}\n  bool hasLValue() const { return HasLV; }\n  QualType getType() const { return Ty; }\n\n  /// \\returns an independent RValue. If the CallArg contains an LValue,\n  /// a temporary copy is returned.\n  RValue getRValue(CodeGenFunction &CGF) const;\n\n  LValue getKnownLValue() const {\n    assert(HasLV && !IsUsed);\n    return LV;\n  }\n  RValue getKnownRValue() const {\n    assert(!HasLV && !IsUsed);\n    return RV;\n  }\n  void setRValue(RValue _RV) {\n    assert(!HasLV);\n    RV = _RV;\n  }\n\n  bool isAggregate() const { return HasLV || RV.isAggregate(); }\n\n  void copyInto(CodeGenFunction &CGF, Address A) const;\n};\n\n/// CallArgList - Type for representing both the value and type of\n/// arguments in a call.\nclass CallArgList : public SmallVector<CallArg, 8> {\npublic:\n  CallArgList() : StackBase(nullptr) {}\n\n  struct Writeback {\n    /// The original argument.  Note that the argument l-value\n    /// is potentially null.\n    LValue Source;\n\n    /// The temporary alloca.\n    Address Temporary;\n\n    /// A value to \"use\" after the writeback, or null.\n    llvm::Value *ToUse;\n  };\n\n  struct CallArgCleanup {\n    EHScopeStack::stable_iterator Cleanup;\n\n    /// The \"is active\" insertion point.  This instruction is temporary and\n    /// will be removed after insertion.\n    llvm::Instruction *IsActiveIP;\n  };\n\n  void add(RValue rvalue, QualType type) { push_back(CallArg(rvalue, type)); }\n\n  void addUncopiedAggregate(LValue LV, QualType type) {\n    push_back(CallArg(LV, type));\n  }\n\n  /// Add all the arguments from another CallArgList to this one. After doing\n  /// this, the old CallArgList retains its list of arguments, but must not\n  /// be used to emit a call.\n  void addFrom(const CallArgList &other) {\n    insert(end(), other.begin(), other.end());\n    Writebacks.insert(Writebacks.end(), other.Writebacks.begin(),\n                      other.Writebacks.end());\n    CleanupsToDeactivate.insert(CleanupsToDeactivate.end(),\n                                other.CleanupsToDeactivate.begin(),\n                                other.CleanupsToDeactivate.end());\n    assert(!(StackBase && other.StackBase) && \"can't merge stackbases\");\n    if (!StackBase)\n      StackBase = other.StackBase;\n  }\n\n  void addWriteback(LValue srcLV, Address temporary, llvm::Value *toUse) {\n    Writeback writeback = {srcLV, temporary, toUse};\n    Writebacks.push_back(writeback);\n  }\n\n  bool hasWritebacks() const { return !Writebacks.empty(); }\n\n  typedef llvm::iterator_range<SmallVectorImpl<Writeback>::const_iterator>\n      writeback_const_range;\n\n  writeback_const_range writebacks() const {\n    return writeback_const_range(Writebacks.begin(), Writebacks.end());\n  }\n\n  void addArgCleanupDeactivation(EHScopeStack::stable_iterator Cleanup,\n                                 llvm::Instruction *IsActiveIP) {\n    CallArgCleanup ArgCleanup;\n    ArgCleanup.Cleanup = Cleanup;\n    ArgCleanup.IsActiveIP = IsActiveIP;\n    CleanupsToDeactivate.push_back(ArgCleanup);\n  }\n\n  ArrayRef<CallArgCleanup> getCleanupsToDeactivate() const {\n    return CleanupsToDeactivate;\n  }\n\n  void allocateArgumentMemory(CodeGenFunction &CGF);\n  llvm::Instruction *getStackBase() const { return StackBase; }\n  void freeArgumentMemory(CodeGenFunction &CGF) const;\n\n  /// Returns if we're using an inalloca struct to pass arguments in\n  /// memory.\n  bool isUsingInAlloca() const { return StackBase; }\n\nprivate:\n  SmallVector<Writeback, 1> Writebacks;\n\n  /// Deactivate these cleanups immediately before making the call.  This\n  /// is used to cleanup objects that are owned by the callee once the call\n  /// occurs.\n  SmallVector<CallArgCleanup, 1> CleanupsToDeactivate;\n\n  /// The stacksave call.  It dominates all of the argument evaluation.\n  llvm::CallInst *StackBase;\n};\n\n/// FunctionArgList - Type for representing both the decl and type\n/// of parameters to a function. The decl must be either a\n/// ParmVarDecl or ImplicitParamDecl.\nclass FunctionArgList : public SmallVector<const VarDecl *, 16> {};\n\n/// ReturnValueSlot - Contains the address where the return value of a\n/// function can be stored, and whether the address is volatile or not.\nclass ReturnValueSlot {\n  Address Addr = Address::invalid();\n\n  // Return value slot flags\n  unsigned IsVolatile : 1;\n  unsigned IsUnused : 1;\n  unsigned IsExternallyDestructed : 1;\n\npublic:\n  ReturnValueSlot()\n      : IsVolatile(false), IsUnused(false), IsExternallyDestructed(false) {}\n  ReturnValueSlot(Address Addr, bool IsVolatile, bool IsUnused = false,\n                  bool IsExternallyDestructed = false)\n      : Addr(Addr), IsVolatile(IsVolatile), IsUnused(IsUnused),\n        IsExternallyDestructed(IsExternallyDestructed) {}\n\n  bool isNull() const { return !Addr.isValid(); }\n  bool isVolatile() const { return IsVolatile; }\n  Address getValue() const { return Addr; }\n  bool isUnused() const { return IsUnused; }\n  bool isExternallyDestructed() const { return IsExternallyDestructed; }\n};\n\n} // end namespace CodeGen\n} // end namespace clang\n\n#endif\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGDebugInfo.h", "content": "//===--- CGDebugInfo.h - DebugInfo for LLVM CodeGen -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This is the source-level debug info generator for llvm translation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CGDEBUGINFO_H\n#define LLVM_CLANG_LIB_CODEGEN_CGDEBUGINFO_H\n\n#include \"CGBuilder.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/IR/DIBuilder.h\"\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Allocator.h\"\n\nnamespace llvm {\nclass MDNode;\n}\n\nnamespace clang {\nclass ClassTemplateSpecializationDecl;\nclass GlobalDecl;\nclass ModuleMap;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass UsingDecl;\nclass VarDecl;\nenum class DynamicInitKind : unsigned;\n\nnamespace CodeGen {\nclass CodeGenModule;\nclass CodeGenFunction;\nclass CGBlockInfo;\n\n/// This class gathers all debug information during compilation and is\n/// responsible for emitting to llvm globals or pass directly to the\n/// backend.\nclass CGDebugInfo {\n  friend class ApplyDebugLocation;\n  friend class SaveAndRestoreLocation;\n  CodeGenModule &CGM;\n  const codegenoptions::DebugInfoKind DebugKind;\n  bool DebugTypeExtRefs;\n  llvm::DIBuilder DBuilder;\n  llvm::DICompileUnit *TheCU = nullptr;\n  ModuleMap *ClangModuleMap = nullptr;\n  ASTSourceDescriptor PCHDescriptor;\n  SourceLocation CurLoc;\n  llvm::MDNode *CurInlinedAt = nullptr;\n  llvm::DIType *VTablePtrType = nullptr;\n  llvm::DIType *ClassTy = nullptr;\n  llvm::DICompositeType *ObjTy = nullptr;\n  llvm::DIType *SelTy = nullptr;\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \\\n  llvm::DIType *SingletonId = nullptr;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  llvm::DIType *OCLSamplerDITy = nullptr;\n  llvm::DIType *OCLEventDITy = nullptr;\n  llvm::DIType *OCLClkEventDITy = nullptr;\n  llvm::DIType *OCLQueueDITy = nullptr;\n  llvm::DIType *OCLNDRangeDITy = nullptr;\n  llvm::DIType *OCLReserveIDDITy = nullptr;\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  llvm::DIType *Id##Ty = nullptr;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n\n  /// Cache of previously constructed Types.\n  llvm::DenseMap<const void *, llvm::TrackingMDRef> TypeCache;\n\n  std::map<llvm::StringRef, llvm::StringRef, std::greater<llvm::StringRef>>\n      DebugPrefixMap;\n\n  /// Cache that maps VLA types to size expressions for that type,\n  /// represented by instantiated Metadata nodes.\n  llvm::SmallDenseMap<QualType, llvm::Metadata *> SizeExprCache;\n\n  /// Callbacks to use when printing names and types.\n  class PrintingCallbacks final : public clang::PrintingCallbacks {\n    const CGDebugInfo &Self;\n\n  public:\n    PrintingCallbacks(const CGDebugInfo &Self) : Self(Self) {}\n    std::string remapPath(StringRef Path) const override {\n      return Self.remapDIPath(Path);\n    }\n  };\n  PrintingCallbacks PrintCB = {*this};\n\n  struct ObjCInterfaceCacheEntry {\n    const ObjCInterfaceType *Type;\n    llvm::DIType *Decl;\n    llvm::DIFile *Unit;\n    ObjCInterfaceCacheEntry(const ObjCInterfaceType *Type, llvm::DIType *Decl,\n                            llvm::DIFile *Unit)\n        : Type(Type), Decl(Decl), Unit(Unit) {}\n  };\n\n  /// Cache of previously constructed interfaces which may change.\n  llvm::SmallVector<ObjCInterfaceCacheEntry, 32> ObjCInterfaceCache;\n\n  /// Cache of forward declarations for methods belonging to the interface.\n  /// The extra bit on the DISubprogram specifies whether a method is\n  /// \"objc_direct\".\n  llvm::DenseMap<const ObjCInterfaceDecl *,\n                 std::vector<llvm::PointerIntPair<llvm::DISubprogram *, 1>>>\n      ObjCMethodCache;\n\n  /// Cache of references to clang modules and precompiled headers.\n  llvm::DenseMap<const Module *, llvm::TrackingMDRef> ModuleCache;\n\n  /// List of interfaces we want to keep even if orphaned.\n  std::vector<void *> RetainedTypes;\n\n  /// Cache of forward declared types to RAUW at the end of compilation.\n  std::vector<std::pair<const TagType *, llvm::TrackingMDRef>> ReplaceMap;\n\n  /// Cache of replaceable forward declarations (functions and\n  /// variables) to RAUW at the end of compilation.\n  std::vector<std::pair<const DeclaratorDecl *, llvm::TrackingMDRef>>\n      FwdDeclReplaceMap;\n\n  /// Keep track of our current nested lexical block.\n  std::vector<llvm::TypedTrackingMDRef<llvm::DIScope>> LexicalBlockStack;\n  llvm::DenseMap<const Decl *, llvm::TrackingMDRef> RegionMap;\n  /// Keep track of LexicalBlockStack counter at the beginning of a\n  /// function. This is used to pop unbalanced regions at the end of a\n  /// function.\n  std::vector<unsigned> FnBeginRegionCount;\n\n  /// This is a storage for names that are constructed on demand. For\n  /// example, C++ destructors, C++ operators etc..\n  llvm::BumpPtrAllocator DebugInfoNames;\n  StringRef CWDName;\n\n  llvm::DenseMap<const char *, llvm::TrackingMDRef> DIFileCache;\n  llvm::DenseMap<const FunctionDecl *, llvm::TrackingMDRef> SPCache;\n  /// Cache declarations relevant to DW_TAG_imported_declarations (C++\n  /// using declarations) that aren't covered by other more specific caches.\n  llvm::DenseMap<const Decl *, llvm::TrackingMDRef> DeclCache;\n  llvm::DenseMap<const NamespaceDecl *, llvm::TrackingMDRef> NamespaceCache;\n  llvm::DenseMap<const NamespaceAliasDecl *, llvm::TrackingMDRef>\n      NamespaceAliasCache;\n  llvm::DenseMap<const Decl *, llvm::TypedTrackingMDRef<llvm::DIDerivedType>>\n      StaticDataMemberCache;\n\n  /// Helper functions for getOrCreateType.\n  /// @{\n  /// Currently the checksum of an interface includes the number of\n  /// ivars and property accessors.\n  llvm::DIType *CreateType(const BuiltinType *Ty);\n  llvm::DIType *CreateType(const ComplexType *Ty);\n  llvm::DIType *CreateType(const AutoType *Ty);\n  llvm::DIType *CreateType(const ExtIntType *Ty);\n  llvm::DIType *CreateQualifiedType(QualType Ty, llvm::DIFile *Fg);\n  llvm::DIType *CreateType(const TypedefType *Ty, llvm::DIFile *Fg);\n  llvm::DIType *CreateType(const TemplateSpecializationType *Ty,\n                           llvm::DIFile *Fg);\n  llvm::DIType *CreateType(const ObjCObjectPointerType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const PointerType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const BlockPointerType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const FunctionType *Ty, llvm::DIFile *F);\n  /// Get structure or union type.\n  llvm::DIType *CreateType(const RecordType *Tyg);\n  llvm::DIType *CreateTypeDefinition(const RecordType *Ty);\n  llvm::DICompositeType *CreateLimitedType(const RecordType *Ty);\n  void CollectContainingType(const CXXRecordDecl *RD,\n                             llvm::DICompositeType *CT);\n  /// Get Objective-C interface type.\n  llvm::DIType *CreateType(const ObjCInterfaceType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateTypeDefinition(const ObjCInterfaceType *Ty,\n                                     llvm::DIFile *F);\n  /// Get Objective-C object type.\n  llvm::DIType *CreateType(const ObjCObjectType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const ObjCTypeParamType *Ty, llvm::DIFile *Unit);\n\n  llvm::DIType *CreateType(const VectorType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const ConstantMatrixType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const ArrayType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const LValueReferenceType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const RValueReferenceType *Ty, llvm::DIFile *Unit);\n  llvm::DIType *CreateType(const MemberPointerType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const AtomicType *Ty, llvm::DIFile *F);\n  llvm::DIType *CreateType(const PipeType *Ty, llvm::DIFile *F);\n  /// Get enumeration type.\n  llvm::DIType *CreateEnumType(const EnumType *Ty);\n  llvm::DIType *CreateTypeDefinition(const EnumType *Ty);\n  /// Look up the completed type for a self pointer in the TypeCache and\n  /// create a copy of it with the ObjectPointer and Artificial flags\n  /// set. If the type is not cached, a new one is created. This should\n  /// never happen though, since creating a type for the implicit self\n  /// argument implies that we already parsed the interface definition\n  /// and the ivar declarations in the implementation.\n  llvm::DIType *CreateSelfType(const QualType &QualTy, llvm::DIType *Ty);\n  /// @}\n\n  /// Get the type from the cache or return null type if it doesn't\n  /// exist.\n  llvm::DIType *getTypeOrNull(const QualType);\n  /// Return the debug type for a C++ method.\n  /// \\arg CXXMethodDecl is of FunctionType. This function type is\n  /// not updated to include implicit \\c this pointer. Use this routine\n  /// to get a method type which includes \\c this pointer.\n  llvm::DISubroutineType *getOrCreateMethodType(const CXXMethodDecl *Method,\n                                                llvm::DIFile *F, bool decl);\n  llvm::DISubroutineType *\n  getOrCreateInstanceMethodType(QualType ThisPtr, const FunctionProtoType *Func,\n                                llvm::DIFile *Unit, bool decl);\n  llvm::DISubroutineType *\n  getOrCreateFunctionType(const Decl *D, QualType FnType, llvm::DIFile *F);\n  /// \\return debug info descriptor for vtable.\n  llvm::DIType *getOrCreateVTablePtrType(llvm::DIFile *F);\n\n  /// \\return namespace descriptor for the given namespace decl.\n  llvm::DINamespace *getOrCreateNamespace(const NamespaceDecl *N);\n  llvm::DIType *CreatePointerLikeType(llvm::dwarf::Tag Tag, const Type *Ty,\n                                      QualType PointeeTy, llvm::DIFile *F);\n  llvm::DIType *getOrCreateStructPtrType(StringRef Name, llvm::DIType *&Cache);\n\n  /// A helper function to create a subprogram for a single member\n  /// function GlobalDecl.\n  llvm::DISubprogram *CreateCXXMemberFunction(const CXXMethodDecl *Method,\n                                              llvm::DIFile *F,\n                                              llvm::DIType *RecordTy);\n\n  /// A helper function to collect debug info for C++ member\n  /// functions. This is used while creating debug info entry for a\n  /// Record.\n  void CollectCXXMemberFunctions(const CXXRecordDecl *Decl, llvm::DIFile *F,\n                                 SmallVectorImpl<llvm::Metadata *> &E,\n                                 llvm::DIType *T);\n\n  /// A helper function to collect debug info for C++ base\n  /// classes. This is used while creating debug info entry for a\n  /// Record.\n  void CollectCXXBases(const CXXRecordDecl *Decl, llvm::DIFile *F,\n                       SmallVectorImpl<llvm::Metadata *> &EltTys,\n                       llvm::DIType *RecordTy);\n\n  /// Helper function for CollectCXXBases.\n  /// Adds debug info entries for types in Bases that are not in SeenTypes.\n  void CollectCXXBasesAux(\n      const CXXRecordDecl *RD, llvm::DIFile *Unit,\n      SmallVectorImpl<llvm::Metadata *> &EltTys, llvm::DIType *RecordTy,\n      const CXXRecordDecl::base_class_const_range &Bases,\n      llvm::DenseSet<CanonicalDeclPtr<const CXXRecordDecl>> &SeenTypes,\n      llvm::DINode::DIFlags StartingFlags);\n\n  /// A helper function to collect template parameters.\n  llvm::DINodeArray CollectTemplateParams(const TemplateParameterList *TPList,\n                                          ArrayRef<TemplateArgument> TAList,\n                                          llvm::DIFile *Unit);\n  /// A helper function to collect debug info for function template\n  /// parameters.\n  llvm::DINodeArray CollectFunctionTemplateParams(const FunctionDecl *FD,\n                                                  llvm::DIFile *Unit);\n\n  /// A helper function to collect debug info for function template\n  /// parameters.\n  llvm::DINodeArray CollectVarTemplateParams(const VarDecl *VD,\n                                             llvm::DIFile *Unit);\n\n  /// A helper function to collect debug info for template\n  /// parameters.\n  llvm::DINodeArray\n  CollectCXXTemplateParams(const ClassTemplateSpecializationDecl *TS,\n                           llvm::DIFile *F);\n\n  llvm::DIType *createFieldType(StringRef name, QualType type,\n                                SourceLocation loc, AccessSpecifier AS,\n                                uint64_t offsetInBits, uint32_t AlignInBits,\n                                llvm::DIFile *tunit, llvm::DIScope *scope,\n                                const RecordDecl *RD = nullptr);\n\n  llvm::DIType *createFieldType(StringRef name, QualType type,\n                                SourceLocation loc, AccessSpecifier AS,\n                                uint64_t offsetInBits, llvm::DIFile *tunit,\n                                llvm::DIScope *scope,\n                                const RecordDecl *RD = nullptr) {\n    return createFieldType(name, type, loc, AS, offsetInBits, 0, tunit, scope,\n                           RD);\n  }\n\n  /// Create new bit field member.\n  llvm::DIType *createBitFieldType(const FieldDecl *BitFieldDecl,\n                                   llvm::DIScope *RecordTy,\n                                   const RecordDecl *RD);\n\n  /// Helpers for collecting fields of a record.\n  /// @{\n  void CollectRecordLambdaFields(const CXXRecordDecl *CXXDecl,\n                                 SmallVectorImpl<llvm::Metadata *> &E,\n                                 llvm::DIType *RecordTy);\n  llvm::DIDerivedType *CreateRecordStaticField(const VarDecl *Var,\n                                               llvm::DIType *RecordTy,\n                                               const RecordDecl *RD);\n  void CollectRecordNormalField(const FieldDecl *Field, uint64_t OffsetInBits,\n                                llvm::DIFile *F,\n                                SmallVectorImpl<llvm::Metadata *> &E,\n                                llvm::DIType *RecordTy, const RecordDecl *RD);\n  void CollectRecordNestedType(const TypeDecl *RD,\n                               SmallVectorImpl<llvm::Metadata *> &E);\n  void CollectRecordFields(const RecordDecl *Decl, llvm::DIFile *F,\n                           SmallVectorImpl<llvm::Metadata *> &E,\n                           llvm::DICompositeType *RecordTy);\n\n  /// If the C++ class has vtable info then insert appropriate debug\n  /// info entry in EltTys vector.\n  void CollectVTableInfo(const CXXRecordDecl *Decl, llvm::DIFile *F,\n                         SmallVectorImpl<llvm::Metadata *> &EltTys);\n  /// @}\n\n  /// Create a new lexical block node and push it on the stack.\n  void CreateLexicalBlock(SourceLocation Loc);\n\n  /// If target-specific LLVM \\p AddressSpace directly maps to target-specific\n  /// DWARF address space, appends extended dereferencing mechanism to complex\n  /// expression \\p Expr. Otherwise, does nothing.\n  ///\n  /// Extended dereferencing mechanism is has the following format:\n  ///     DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef\n  void AppendAddressSpaceXDeref(unsigned AddressSpace,\n                                SmallVectorImpl<int64_t> &Expr) const;\n\n  /// A helper function to collect debug info for the default elements of a\n  /// block.\n  ///\n  /// \\returns The next available field offset after the default elements.\n  uint64_t collectDefaultElementTypesForBlockPointer(\n      const BlockPointerType *Ty, llvm::DIFile *Unit,\n      llvm::DIDerivedType *DescTy, unsigned LineNo,\n      SmallVectorImpl<llvm::Metadata *> &EltTys);\n\n  /// A helper function to collect debug info for the default fields of a\n  /// block.\n  void collectDefaultFieldsForBlockLiteralDeclare(\n      const CGBlockInfo &Block, const ASTContext &Context, SourceLocation Loc,\n      const llvm::StructLayout &BlockLayout, llvm::DIFile *Unit,\n      SmallVectorImpl<llvm::Metadata *> &Fields);\n\npublic:\n  CGDebugInfo(CodeGenModule &CGM);\n  ~CGDebugInfo();\n\n  void finalize();\n\n  /// Remap a given path with the current debug prefix map\n  std::string remapDIPath(StringRef) const;\n\n  /// Register VLA size expression debug node with the qualified type.\n  void registerVLASizeExpression(QualType Ty, llvm::Metadata *SizeExpr) {\n    SizeExprCache[Ty] = SizeExpr;\n  }\n\n  /// Module debugging: Support for building PCMs.\n  /// @{\n  /// Set the main CU's DwoId field to \\p Signature.\n  void setDwoId(uint64_t Signature);\n\n  /// When generating debug information for a clang module or\n  /// precompiled header, this module map will be used to determine\n  /// the module of origin of each Decl.\n  void setModuleMap(ModuleMap &MMap) { ClangModuleMap = &MMap; }\n\n  /// When generating debug information for a clang module or\n  /// precompiled header, this module map will be used to determine\n  /// the module of origin of each Decl.\n  void setPCHDescriptor(ASTSourceDescriptor PCH) { PCHDescriptor = PCH; }\n  /// @}\n\n  /// Update the current source location. If \\arg loc is invalid it is\n  /// ignored.\n  void setLocation(SourceLocation Loc);\n\n  /// Return the current source location. This does not necessarily correspond\n  /// to the IRBuilder's current DebugLoc.\n  SourceLocation getLocation() const { return CurLoc; }\n\n  /// Update the current inline scope. All subsequent calls to \\p EmitLocation\n  /// will create a location with this inlinedAt field.\n  void setInlinedAt(llvm::MDNode *InlinedAt) { CurInlinedAt = InlinedAt; }\n\n  /// \\return the current inline scope.\n  llvm::MDNode *getInlinedAt() const { return CurInlinedAt; }\n\n  // Converts a SourceLocation to a DebugLoc\n  llvm::DebugLoc SourceLocToDebugLoc(SourceLocation Loc);\n\n  /// Emit metadata to indicate a change in line/column information in\n  /// the source file. If the location is invalid, the previous\n  /// location will be reused.\n  void EmitLocation(CGBuilderTy &Builder, SourceLocation Loc);\n\n  /// Emit a call to llvm.dbg.function.start to indicate\n  /// start of a new function.\n  /// \\param Loc       The location of the function header.\n  /// \\param ScopeLoc  The location of the function body.\n  void emitFunctionStart(GlobalDecl GD, SourceLocation Loc,\n                         SourceLocation ScopeLoc, QualType FnType,\n                         llvm::Function *Fn, bool CurFnIsThunk);\n\n  /// Start a new scope for an inlined function.\n  void EmitInlineFunctionStart(CGBuilderTy &Builder, GlobalDecl GD);\n  /// End an inlined function scope.\n  void EmitInlineFunctionEnd(CGBuilderTy &Builder);\n\n  /// Emit debug info for a function declaration.\n  /// \\p Fn is set only when a declaration for a debug call site gets created.\n  void EmitFunctionDecl(GlobalDecl GD, SourceLocation Loc,\n                        QualType FnType, llvm::Function *Fn = nullptr);\n\n  /// Emit debug info for an extern function being called.\n  /// This is needed for call site debug info.\n  void EmitFuncDeclForCallSite(llvm::CallBase *CallOrInvoke,\n                               QualType CalleeType,\n                               const FunctionDecl *CalleeDecl);\n\n  /// Constructs the debug code for exiting a function.\n  void EmitFunctionEnd(CGBuilderTy &Builder, llvm::Function *Fn);\n\n  /// Emit metadata to indicate the beginning of a new lexical block\n  /// and push the block onto the stack.\n  void EmitLexicalBlockStart(CGBuilderTy &Builder, SourceLocation Loc);\n\n  /// Emit metadata to indicate the end of a new lexical block and pop\n  /// the current block.\n  void EmitLexicalBlockEnd(CGBuilderTy &Builder, SourceLocation Loc);\n\n  /// Emit call to \\c llvm.dbg.declare for an automatic variable\n  /// declaration.\n  /// Returns a pointer to the DILocalVariable associated with the\n  /// llvm.dbg.declare, or nullptr otherwise.\n  llvm::DILocalVariable *\n  EmitDeclareOfAutoVariable(const VarDecl *Decl, llvm::Value *AI,\n                            CGBuilderTy &Builder,\n                            const bool UsePointerValue = false);\n\n  /// Emit call to \\c llvm.dbg.label for an label.\n  void EmitLabel(const LabelDecl *D, CGBuilderTy &Builder);\n\n  /// Emit call to \\c llvm.dbg.declare for an imported variable\n  /// declaration in a block.\n  void EmitDeclareOfBlockDeclRefVariable(\n      const VarDecl *variable, llvm::Value *storage, CGBuilderTy &Builder,\n      const CGBlockInfo &blockInfo, llvm::Instruction *InsertPoint = nullptr);\n\n  /// Emit call to \\c llvm.dbg.declare for an argument variable\n  /// declaration.\n  void EmitDeclareOfArgVariable(const VarDecl *Decl, llvm::Value *AI,\n                                unsigned ArgNo, CGBuilderTy &Builder);\n\n  /// Emit call to \\c llvm.dbg.declare for the block-literal argument\n  /// to a block invocation function.\n  void EmitDeclareOfBlockLiteralArgVariable(const CGBlockInfo &block,\n                                            StringRef Name, unsigned ArgNo,\n                                            llvm::AllocaInst *LocalAddr,\n                                            CGBuilderTy &Builder);\n\n  /// Emit information about a global variable.\n  void EmitGlobalVariable(llvm::GlobalVariable *GV, const VarDecl *Decl);\n\n  /// Emit a constant global variable's debug info.\n  void EmitGlobalVariable(const ValueDecl *VD, const APValue &Init);\n\n  /// Emit information about an external variable.\n  void EmitExternalVariable(llvm::GlobalVariable *GV, const VarDecl *Decl);\n\n  /// Emit C++ using directive.\n  void EmitUsingDirective(const UsingDirectiveDecl &UD);\n\n  /// Emit the type explicitly casted to.\n  void EmitExplicitCastType(QualType Ty);\n\n  /// Emit the type even if it might not be used.\n  void EmitAndRetainType(QualType Ty);\n\n  /// Emit C++ using declaration.\n  void EmitUsingDecl(const UsingDecl &UD);\n\n  /// Emit an @import declaration.\n  void EmitImportDecl(const ImportDecl &ID);\n\n  /// Emit C++ namespace alias.\n  llvm::DIImportedEntity *EmitNamespaceAlias(const NamespaceAliasDecl &NA);\n\n  /// Emit record type's standalone debug info.\n  llvm::DIType *getOrCreateRecordType(QualType Ty, SourceLocation L);\n\n  /// Emit an Objective-C interface type standalone debug info.\n  llvm::DIType *getOrCreateInterfaceType(QualType Ty, SourceLocation Loc);\n\n  /// Emit standalone debug info for a type.\n  llvm::DIType *getOrCreateStandaloneType(QualType Ty, SourceLocation Loc);\n\n  /// Add heapallocsite metadata for MSAllocator calls.\n  void addHeapAllocSiteMetadata(llvm::CallBase *CallSite, QualType AllocatedTy,\n                                SourceLocation Loc);\n\n  void completeType(const EnumDecl *ED);\n  void completeType(const RecordDecl *RD);\n  void completeRequiredType(const RecordDecl *RD);\n  void completeClassData(const RecordDecl *RD);\n  void completeClass(const RecordDecl *RD);\n\n  void completeTemplateDefinition(const ClassTemplateSpecializationDecl &SD);\n  void completeUnusedClass(const CXXRecordDecl &D);\n\n  /// Create debug info for a macro defined by a #define directive or a macro\n  /// undefined by a #undef directive.\n  llvm::DIMacro *CreateMacro(llvm::DIMacroFile *Parent, unsigned MType,\n                             SourceLocation LineLoc, StringRef Name,\n                             StringRef Value);\n\n  /// Create debug info for a file referenced by an #include directive.\n  llvm::DIMacroFile *CreateTempMacroFile(llvm::DIMacroFile *Parent,\n                                         SourceLocation LineLoc,\n                                         SourceLocation FileLoc);\n\nprivate:\n  /// Emit call to llvm.dbg.declare for a variable declaration.\n  /// Returns a pointer to the DILocalVariable associated with the\n  /// llvm.dbg.declare, or nullptr otherwise.\n  llvm::DILocalVariable *EmitDeclare(const VarDecl *decl, llvm::Value *AI,\n                                     llvm::Optional<unsigned> ArgNo,\n                                     CGBuilderTy &Builder,\n                                     const bool UsePointerValue = false);\n\n  struct BlockByRefType {\n    /// The wrapper struct used inside the __block_literal struct.\n    llvm::DIType *BlockByRefWrapper;\n    /// The type as it appears in the source code.\n    llvm::DIType *WrappedType;\n  };\n\n  /// Build up structure info for the byref.  See \\a BuildByRefType.\n  BlockByRefType EmitTypeForVarWithBlocksAttr(const VarDecl *VD,\n                                              uint64_t *OffSet);\n\n  /// Get context info for the DeclContext of \\p Decl.\n  llvm::DIScope *getDeclContextDescriptor(const Decl *D);\n  /// Get context info for a given DeclContext \\p Decl.\n  llvm::DIScope *getContextDescriptor(const Decl *Context,\n                                      llvm::DIScope *Default);\n\n  llvm::DIScope *getCurrentContextDescriptor(const Decl *Decl);\n\n  /// Create a forward decl for a RecordType in a given context.\n  llvm::DICompositeType *getOrCreateRecordFwdDecl(const RecordType *,\n                                                  llvm::DIScope *);\n\n  /// Return current directory name.\n  StringRef getCurrentDirname();\n\n  /// Create new compile unit.\n  void CreateCompileUnit();\n\n  /// Compute the file checksum debug info for input file ID.\n  Optional<llvm::DIFile::ChecksumKind>\n  computeChecksum(FileID FID, SmallString<32> &Checksum) const;\n\n  /// Get the source of the given file ID.\n  Optional<StringRef> getSource(const SourceManager &SM, FileID FID);\n\n  /// Convenience function to get the file debug info descriptor for the input\n  /// location.\n  llvm::DIFile *getOrCreateFile(SourceLocation Loc);\n\n  /// Create a file debug info descriptor for a source file.\n  llvm::DIFile *\n  createFile(StringRef FileName,\n             Optional<llvm::DIFile::ChecksumInfo<StringRef>> CSInfo,\n             Optional<StringRef> Source);\n\n  /// Get the type from the cache or create a new type if necessary.\n  llvm::DIType *getOrCreateType(QualType Ty, llvm::DIFile *Fg);\n\n  /// Get a reference to a clang module.  If \\p CreateSkeletonCU is true,\n  /// this also creates a split dwarf skeleton compile unit.\n  llvm::DIModule *getOrCreateModuleRef(ASTSourceDescriptor Mod,\n                                       bool CreateSkeletonCU);\n\n  /// DebugTypeExtRefs: If \\p D originated in a clang module, return it.\n  llvm::DIModule *getParentModuleOrNull(const Decl *D);\n\n  /// Get the type from the cache or create a new partial type if\n  /// necessary.\n  llvm::DICompositeType *getOrCreateLimitedType(const RecordType *Ty);\n\n  /// Create type metadata for a source language type.\n  llvm::DIType *CreateTypeNode(QualType Ty, llvm::DIFile *Fg);\n\n  /// Create new member and increase Offset by FType's size.\n  llvm::DIType *CreateMemberType(llvm::DIFile *Unit, QualType FType,\n                                 StringRef Name, uint64_t *Offset);\n\n  /// Retrieve the DIDescriptor, if any, for the canonical form of this\n  /// declaration.\n  llvm::DINode *getDeclarationOrDefinition(const Decl *D);\n\n  /// \\return debug info descriptor to describe method\n  /// declaration for the given method definition.\n  llvm::DISubprogram *getFunctionDeclaration(const Decl *D);\n\n  /// \\return          debug info descriptor to the describe method declaration\n  ///                  for the given method definition.\n  /// \\param FnType    For Objective-C methods, their type.\n  /// \\param LineNo    The declaration's line number.\n  /// \\param Flags     The DIFlags for the method declaration.\n  /// \\param SPFlags   The subprogram-spcific flags for the method declaration.\n  llvm::DISubprogram *\n  getObjCMethodDeclaration(const Decl *D, llvm::DISubroutineType *FnType,\n                           unsigned LineNo, llvm::DINode::DIFlags Flags,\n                           llvm::DISubprogram::DISPFlags SPFlags);\n\n  /// \\return debug info descriptor to describe in-class static data\n  /// member declaration for the given out-of-class definition.  If D\n  /// is an out-of-class definition of a static data member of a\n  /// class, find its corresponding in-class declaration.\n  llvm::DIDerivedType *\n  getOrCreateStaticDataMemberDeclarationOrNull(const VarDecl *D);\n\n  /// Helper that either creates a forward declaration or a stub.\n  llvm::DISubprogram *getFunctionFwdDeclOrStub(GlobalDecl GD, bool Stub);\n\n  /// Create a subprogram describing the forward declaration\n  /// represented in the given FunctionDecl wrapped in a GlobalDecl.\n  llvm::DISubprogram *getFunctionForwardDeclaration(GlobalDecl GD);\n\n  /// Create a DISubprogram describing the function\n  /// represented in the given FunctionDecl wrapped in a GlobalDecl.\n  llvm::DISubprogram *getFunctionStub(GlobalDecl GD);\n\n  /// Create a global variable describing the forward declaration\n  /// represented in the given VarDecl.\n  llvm::DIGlobalVariable *\n  getGlobalVariableForwardDeclaration(const VarDecl *VD);\n\n  /// Return a global variable that represents one of the collection of global\n  /// variables created for an anonmyous union.\n  ///\n  /// Recursively collect all of the member fields of a global\n  /// anonymous decl and create static variables for them. The first\n  /// time this is called it needs to be on a union and then from\n  /// there we can have additional unnamed fields.\n  llvm::DIGlobalVariableExpression *\n  CollectAnonRecordDecls(const RecordDecl *RD, llvm::DIFile *Unit,\n                         unsigned LineNo, StringRef LinkageName,\n                         llvm::GlobalVariable *Var, llvm::DIScope *DContext);\n\n\n  /// Return flags which enable debug info emission for call sites, provided\n  /// that it is supported and enabled.\n  llvm::DINode::DIFlags getCallSiteRelatedAttrs() const;\n\n  /// Get the printing policy for producing names for debug info.\n  PrintingPolicy getPrintingPolicy() const;\n\n  /// Get function name for the given FunctionDecl. If the name is\n  /// constructed on demand (e.g., C++ destructor) then the name is\n  /// stored on the side.\n  StringRef getFunctionName(const FunctionDecl *FD);\n\n  /// Returns the unmangled name of an Objective-C method.\n  /// This is the display name for the debugging info.\n  StringRef getObjCMethodName(const ObjCMethodDecl *FD);\n\n  /// Return selector name. This is used for debugging\n  /// info.\n  StringRef getSelectorName(Selector S);\n\n  /// Get class name including template argument list.\n  StringRef getClassName(const RecordDecl *RD);\n\n  /// Get the vtable name for the given class.\n  StringRef getVTableName(const CXXRecordDecl *Decl);\n\n  /// Get the name to use in the debug info for a dynamic initializer or atexit\n  /// stub function.\n  StringRef getDynamicInitializerName(const VarDecl *VD,\n                                      DynamicInitKind StubKind,\n                                      llvm::Function *InitFn);\n\n  /// Get line number for the location. If location is invalid\n  /// then use current location.\n  unsigned getLineNumber(SourceLocation Loc);\n\n  /// Get column number for the location. If location is\n  /// invalid then use current location.\n  /// \\param Force  Assume DebugColumnInfo option is true.\n  unsigned getColumnNumber(SourceLocation Loc, bool Force = false);\n\n  /// Collect various properties of a FunctionDecl.\n  /// \\param GD  A GlobalDecl whose getDecl() must return a FunctionDecl.\n  void collectFunctionDeclProps(GlobalDecl GD, llvm::DIFile *Unit,\n                                StringRef &Name, StringRef &LinkageName,\n                                llvm::DIScope *&FDContext,\n                                llvm::DINodeArray &TParamsArray,\n                                llvm::DINode::DIFlags &Flags);\n\n  /// Collect various properties of a VarDecl.\n  void collectVarDeclProps(const VarDecl *VD, llvm::DIFile *&Unit,\n                           unsigned &LineNo, QualType &T, StringRef &Name,\n                           StringRef &LinkageName,\n                           llvm::MDTuple *&TemplateParameters,\n                           llvm::DIScope *&VDContext);\n\n  /// Allocate a copy of \\p A using the DebugInfoNames allocator\n  /// and return a reference to it. If multiple arguments are given the strings\n  /// are concatenated.\n  StringRef internString(StringRef A, StringRef B = StringRef()) {\n    char *Data = DebugInfoNames.Allocate<char>(A.size() + B.size());\n    if (!A.empty())\n      std::memcpy(Data, A.data(), A.size());\n    if (!B.empty())\n      std::memcpy(Data + A.size(), B.data(), B.size());\n    return StringRef(Data, A.size() + B.size());\n  }\n};\n\n/// A scoped helper to set the current debug location to the specified\n/// location or preferred location of the specified Expr.\nclass ApplyDebugLocation {\nprivate:\n  void init(SourceLocation TemporaryLocation, bool DefaultToEmpty = false);\n  ApplyDebugLocation(CodeGenFunction &CGF, bool DefaultToEmpty,\n                     SourceLocation TemporaryLocation);\n\n  llvm::DebugLoc OriginalLocation;\n  CodeGenFunction *CGF;\n\npublic:\n  /// Set the location to the (valid) TemporaryLocation.\n  ApplyDebugLocation(CodeGenFunction &CGF, SourceLocation TemporaryLocation);\n  ApplyDebugLocation(CodeGenFunction &CGF, const Expr *E);\n  ApplyDebugLocation(CodeGenFunction &CGF, llvm::DebugLoc Loc);\n  ApplyDebugLocation(ApplyDebugLocation &&Other) : CGF(Other.CGF) {\n    Other.CGF = nullptr;\n  }\n  ApplyDebugLocation &operator=(ApplyDebugLocation &&) = default;\n\n  ~ApplyDebugLocation();\n\n  /// Apply TemporaryLocation if it is valid. Otherwise switch\n  /// to an artificial debug location that has a valid scope, but no\n  /// line information.\n  ///\n  /// Artificial locations are useful when emitting compiler-generated\n  /// helper functions that have no source location associated with\n  /// them. The DWARF specification allows the compiler to use the\n  /// special line number 0 to indicate code that can not be\n  /// attributed to any source location. Note that passing an empty\n  /// SourceLocation to CGDebugInfo::setLocation() will result in the\n  /// last valid location being reused.\n  static ApplyDebugLocation CreateArtificial(CodeGenFunction &CGF) {\n    return ApplyDebugLocation(CGF, false, SourceLocation());\n  }\n  /// Apply TemporaryLocation if it is valid. Otherwise switch\n  /// to an artificial debug location that has a valid scope, but no\n  /// line information.\n  static ApplyDebugLocation\n  CreateDefaultArtificial(CodeGenFunction &CGF,\n                          SourceLocation TemporaryLocation) {\n    return ApplyDebugLocation(CGF, false, TemporaryLocation);\n  }\n\n  /// Set the IRBuilder to not attach debug locations.  Note that\n  /// passing an empty SourceLocation to \\a CGDebugInfo::setLocation()\n  /// will result in the last valid location being reused.  Note that\n  /// all instructions that do not have a location at the beginning of\n  /// a function are counted towards to function prologue.\n  static ApplyDebugLocation CreateEmpty(CodeGenFunction &CGF) {\n    return ApplyDebugLocation(CGF, true, SourceLocation());\n  }\n};\n\n/// A scoped helper to set the current debug location to an inlined location.\nclass ApplyInlineDebugLocation {\n  SourceLocation SavedLocation;\n  CodeGenFunction *CGF;\n\npublic:\n  /// Set up the CodeGenFunction's DebugInfo to produce inline locations for the\n  /// function \\p InlinedFn. The current debug location becomes the inlined call\n  /// site of the inlined function.\n  ApplyInlineDebugLocation(CodeGenFunction &CGF, GlobalDecl InlinedFn);\n  /// Restore everything back to the original state.\n  ~ApplyInlineDebugLocation();\n};\n\n} // namespace CodeGen\n} // namespace clang\n\n#endif // LLVM_CLANG_LIB_CODEGEN_CGDEBUGINFO_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGLoopInfo.h", "content": "//===---- CGLoopInfo.h - LLVM CodeGen for loop metadata -*- C++ -*---------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This is the internal state used for llvm translation for loop statement\n// metadata.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CGLOOPINFO_H\n#define LLVM_CLANG_LIB_CODEGEN_CGLOOPINFO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Compiler.h\"\n\nnamespace llvm {\nclass BasicBlock;\nclass Instruction;\nclass MDNode;\n} // end namespace llvm\n\nnamespace clang {\nclass Attr;\nclass ASTContext;\nclass CodeGenOptions;\nnamespace CodeGen {\n\n/// Attributes that may be specified on loops.\nstruct LoopAttributes {\n  explicit LoopAttributes(bool IsParallel = false);\n  void clear();\n\n  /// Generate llvm.loop.parallel metadata for loads and stores.\n  bool IsParallel;\n\n  /// State of loop vectorization or unrolling.\n  enum LVEnableState { Unspecified, Enable, Disable, Full };\n\n  /// Value for llvm.loop.vectorize.enable metadata.\n  LVEnableState VectorizeEnable;\n\n  /// Value for llvm.loop.unroll.* metadata (enable, disable, or full).\n  LVEnableState UnrollEnable;\n\n  /// Value for llvm.loop.unroll_and_jam.* metadata (enable, disable, or full).\n  LVEnableState UnrollAndJamEnable;\n\n  /// Value for llvm.loop.vectorize.predicate metadata\n  LVEnableState VectorizePredicateEnable;\n\n  /// Value for llvm.loop.vectorize.width metadata.\n  unsigned VectorizeWidth;\n\n  // Value for llvm.loop.vectorize.scalable.enable\n  LVEnableState VectorizeScalable;\n\n  /// Value for llvm.loop.interleave.count metadata.\n  unsigned InterleaveCount;\n\n  /// llvm.unroll.\n  unsigned UnrollCount;\n\n  /// llvm.unroll.\n  unsigned UnrollAndJamCount;\n\n  /// Value for llvm.loop.distribute.enable metadata.\n  LVEnableState DistributeEnable;\n\n  /// Value for llvm.loop.pipeline.disable metadata.\n  bool PipelineDisabled;\n\n  /// Value for llvm.loop.pipeline.iicount metadata.\n  unsigned PipelineInitiationInterval;\n\n  /// Value for whether the loop is required to make progress.\n  bool MustProgress;\n};\n\n/// Information used when generating a structured loop.\nclass LoopInfo {\npublic:\n  /// Construct a new LoopInfo for the loop with entry Header.\n  LoopInfo(llvm::BasicBlock *Header, const LoopAttributes &Attrs,\n           const llvm::DebugLoc &StartLoc, const llvm::DebugLoc &EndLoc,\n           LoopInfo *Parent);\n\n  /// Get the loop id metadata for this loop.\n  llvm::MDNode *getLoopID() const { return TempLoopID.get(); }\n\n  /// Get the header block of this loop.\n  llvm::BasicBlock *getHeader() const { return Header; }\n\n  /// Get the set of attributes active for this loop.\n  const LoopAttributes &getAttributes() const { return Attrs; }\n\n  /// Return this loop's access group or nullptr if it does not have one.\n  llvm::MDNode *getAccessGroup() const { return AccGroup; }\n\n  /// Create the loop's metadata. Must be called after its nested loops have\n  /// been processed.\n  void finish();\n\nprivate:\n  /// Loop ID metadata.\n  llvm::TempMDTuple TempLoopID;\n  /// Header block of this loop.\n  llvm::BasicBlock *Header;\n  /// The attributes for this loop.\n  LoopAttributes Attrs;\n  /// The access group for memory accesses parallel to this loop.\n  llvm::MDNode *AccGroup = nullptr;\n  /// Start location of this loop.\n  llvm::DebugLoc StartLoc;\n  /// End location of this loop.\n  llvm::DebugLoc EndLoc;\n  /// The next outer loop, or nullptr if this is the outermost loop.\n  LoopInfo *Parent;\n  /// If this loop has unroll-and-jam metadata, this can be set by the inner\n  /// loop's LoopInfo to set the llvm.loop.unroll_and_jam.followup_inner\n  /// metadata.\n  llvm::MDNode *UnrollAndJamInnerFollowup = nullptr;\n\n  /// Create a LoopID without any transformations.\n  llvm::MDNode *\n  createLoopPropertiesMetadata(llvm::ArrayRef<llvm::Metadata *> LoopProperties);\n\n  /// Create a LoopID for transformations.\n  ///\n  /// The methods call each other in case multiple transformations are applied\n  /// to a loop. The transformation first to be applied will use LoopID of the\n  /// next transformation in its followup attribute.\n  ///\n  /// @param Attrs             The loop's transformations.\n  /// @param LoopProperties    Non-transformation properties such as debug\n  ///                          location, parallel accesses and disabled\n  ///                          transformations. These are added to the returned\n  ///                          LoopID.\n  /// @param HasUserTransforms [out] Set to true if the returned MDNode encodes\n  ///                          at least one transformation.\n  ///\n  /// @return A LoopID (metadata node) that can be used for the llvm.loop\n  ///         annotation or followup-attribute.\n  /// @{\n  llvm::MDNode *\n  createPipeliningMetadata(const LoopAttributes &Attrs,\n                           llvm::ArrayRef<llvm::Metadata *> LoopProperties,\n                           bool &HasUserTransforms);\n  llvm::MDNode *\n  createPartialUnrollMetadata(const LoopAttributes &Attrs,\n                              llvm::ArrayRef<llvm::Metadata *> LoopProperties,\n                              bool &HasUserTransforms);\n  llvm::MDNode *\n  createUnrollAndJamMetadata(const LoopAttributes &Attrs,\n                             llvm::ArrayRef<llvm::Metadata *> LoopProperties,\n                             bool &HasUserTransforms);\n  llvm::MDNode *\n  createLoopVectorizeMetadata(const LoopAttributes &Attrs,\n                              llvm::ArrayRef<llvm::Metadata *> LoopProperties,\n                              bool &HasUserTransforms);\n  llvm::MDNode *\n  createLoopDistributeMetadata(const LoopAttributes &Attrs,\n                               llvm::ArrayRef<llvm::Metadata *> LoopProperties,\n                               bool &HasUserTransforms);\n  llvm::MDNode *\n  createFullUnrollMetadata(const LoopAttributes &Attrs,\n                           llvm::ArrayRef<llvm::Metadata *> LoopProperties,\n                           bool &HasUserTransforms);\n  /// @}\n\n  /// Create a LoopID for this loop, including transformation-unspecific\n  /// metadata such as debug location.\n  ///\n  /// @param Attrs             This loop's attributes and transformations.\n  /// @param LoopProperties    Additional non-transformation properties to add\n  ///                          to the LoopID, such as transformation-specific\n  ///                          metadata that are not covered by @p Attrs.\n  /// @param HasUserTransforms [out] Set to true if the returned MDNode encodes\n  ///                          at least one transformation.\n  ///\n  /// @return A LoopID (metadata node) that can be used for the llvm.loop\n  ///         annotation.\n  llvm::MDNode *createMetadata(const LoopAttributes &Attrs,\n                               llvm::ArrayRef<llvm::Metadata *> LoopProperties,\n                               bool &HasUserTransforms);\n};\n\n/// A stack of loop information corresponding to loop nesting levels.\n/// This stack can be used to prepare attributes which are applied when a loop\n/// is emitted.\nclass LoopInfoStack {\n  LoopInfoStack(const LoopInfoStack &) = delete;\n  void operator=(const LoopInfoStack &) = delete;\n\npublic:\n  LoopInfoStack() {}\n\n  /// Begin a new structured loop. The set of staged attributes will be\n  /// applied to the loop and then cleared.\n  void push(llvm::BasicBlock *Header, const llvm::DebugLoc &StartLoc,\n            const llvm::DebugLoc &EndLoc);\n\n  /// Begin a new structured loop. Stage attributes from the Attrs list.\n  /// The staged attributes are applied to the loop and then cleared.\n  void push(llvm::BasicBlock *Header, clang::ASTContext &Ctx,\n            const clang::CodeGenOptions &CGOpts,\n            llvm::ArrayRef<const Attr *> Attrs, const llvm::DebugLoc &StartLoc,\n            const llvm::DebugLoc &EndLoc, bool MustProgress = false);\n\n  /// End the current loop.\n  void pop();\n\n  /// Return the top loop id metadata.\n  llvm::MDNode *getCurLoopID() const { return getInfo().getLoopID(); }\n\n  /// Return true if the top loop is parallel.\n  bool getCurLoopParallel() const {\n    return hasInfo() ? getInfo().getAttributes().IsParallel : false;\n  }\n\n  /// Function called by the CodeGenFunction when an instruction is\n  /// created.\n  void InsertHelper(llvm::Instruction *I) const;\n\n  /// Set the next pushed loop as parallel.\n  void setParallel(bool Enable = true) { StagedAttrs.IsParallel = Enable; }\n\n  /// Set the next pushed loop 'vectorize.enable'\n  void setVectorizeEnable(bool Enable = true) {\n    StagedAttrs.VectorizeEnable =\n        Enable ? LoopAttributes::Enable : LoopAttributes::Disable;\n  }\n\n  /// Set the next pushed loop as a distribution candidate.\n  void setDistributeState(bool Enable = true) {\n    StagedAttrs.DistributeEnable =\n        Enable ? LoopAttributes::Enable : LoopAttributes::Disable;\n  }\n\n  /// Set the next pushed loop unroll state.\n  void setUnrollState(const LoopAttributes::LVEnableState &State) {\n    StagedAttrs.UnrollEnable = State;\n  }\n\n  /// Set the next pushed vectorize predicate state.\n  void setVectorizePredicateState(const LoopAttributes::LVEnableState &State) {\n    StagedAttrs.VectorizePredicateEnable = State;\n  }\n\n  /// Set the next pushed loop unroll_and_jam state.\n  void setUnrollAndJamState(const LoopAttributes::LVEnableState &State) {\n    StagedAttrs.UnrollAndJamEnable = State;\n  }\n\n  /// Set the vectorize width for the next loop pushed.\n  void setVectorizeWidth(unsigned W) { StagedAttrs.VectorizeWidth = W; }\n\n  void setVectorizeScalable(const LoopAttributes::LVEnableState &State) {\n    StagedAttrs.VectorizeScalable = State;\n  }\n\n  /// Set the interleave count for the next loop pushed.\n  void setInterleaveCount(unsigned C) { StagedAttrs.InterleaveCount = C; }\n\n  /// Set the unroll count for the next loop pushed.\n  void setUnrollCount(unsigned C) { StagedAttrs.UnrollCount = C; }\n\n  /// \\brief Set the unroll count for the next loop pushed.\n  void setUnrollAndJamCount(unsigned C) { StagedAttrs.UnrollAndJamCount = C; }\n\n  /// Set the pipeline disabled state.\n  void setPipelineDisabled(bool S) { StagedAttrs.PipelineDisabled = S; }\n\n  /// Set the pipeline initiation interval.\n  void setPipelineInitiationInterval(unsigned C) {\n    StagedAttrs.PipelineInitiationInterval = C;\n  }\n\n  /// Set no progress for the next loop pushed.\n  void setMustProgress(bool P) { StagedAttrs.MustProgress = P; }\n\nprivate:\n  /// Returns true if there is LoopInfo on the stack.\n  bool hasInfo() const { return !Active.empty(); }\n  /// Return the LoopInfo for the current loop. HasInfo should be called\n  /// first to ensure LoopInfo is present.\n  const LoopInfo &getInfo() const { return *Active.back(); }\n  /// The set of attributes that will be applied to the next pushed loop.\n  LoopAttributes StagedAttrs;\n  /// Stack of active loops.\n  llvm::SmallVector<std::unique_ptr<LoopInfo>, 4> Active;\n};\n\n} // end namespace CodeGen\n} // end namespace clang\n\n#endif\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "content": "//===----- CGOpenMPRuntime.h - Interface to OpenMP Runtimes -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This provides a class for OpenMP runtime code generation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIME_H\n#define LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIME_H\n\n#include \"CGValue.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include \"llvm/Frontend/OpenMP/OMPIRBuilder.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n\nnamespace llvm {\nclass ArrayType;\nclass Constant;\nclass FunctionType;\nclass GlobalVariable;\nclass StructType;\nclass Type;\nclass Value;\nclass OpenMPIRBuilder;\n} // namespace llvm\n\nnamespace clang {\nclass Expr;\nclass OMPDependClause;\nclass OMPExecutableDirective;\nclass OMPLoopDirective;\nclass VarDecl;\nclass OMPDeclareReductionDecl;\nclass IdentifierInfo;\n\nnamespace CodeGen {\nclass Address;\nclass CodeGenFunction;\nclass CodeGenModule;\n\n/// A basic class for pre|post-action for advanced codegen sequence for OpenMP\n/// region.\nclass PrePostActionTy {\npublic:\n  explicit PrePostActionTy() {}\n  virtual void Enter(CodeGenFunction &CGF) {}\n  virtual void Exit(CodeGenFunction &CGF) {}\n  virtual ~PrePostActionTy() {}\n};\n\n/// Class provides a way to call simple version of codegen for OpenMP region, or\n/// an advanced with possible pre|post-actions in codegen.\nclass RegionCodeGenTy final {\n  intptr_t CodeGen;\n  typedef void (*CodeGenTy)(intptr_t, CodeGenFunction &, PrePostActionTy &);\n  CodeGenTy Callback;\n  mutable PrePostActionTy *PrePostAction;\n  RegionCodeGenTy() = delete;\n  RegionCodeGenTy &operator=(const RegionCodeGenTy &) = delete;\n  template <typename Callable>\n  static void CallbackFn(intptr_t CodeGen, CodeGenFunction &CGF,\n                         PrePostActionTy &Action) {\n    return (*reinterpret_cast<Callable *>(CodeGen))(CGF, Action);\n  }\n\npublic:\n  template <typename Callable>\n  RegionCodeGenTy(\n      Callable &&CodeGen,\n      std::enable_if_t<!std::is_same<std::remove_reference_t<Callable>,\n                                     RegionCodeGenTy>::value> * = nullptr)\n      : CodeGen(reinterpret_cast<intptr_t>(&CodeGen)),\n        Callback(CallbackFn<std::remove_reference_t<Callable>>),\n        PrePostAction(nullptr) {}\n  void setAction(PrePostActionTy &Action) const { PrePostAction = &Action; }\n  void operator()(CodeGenFunction &CGF) const;\n};\n\nstruct OMPTaskDataTy final {\n  SmallVector<const Expr *, 4> PrivateVars;\n  SmallVector<const Expr *, 4> PrivateCopies;\n  SmallVector<const Expr *, 4> FirstprivateVars;\n  SmallVector<const Expr *, 4> FirstprivateCopies;\n  SmallVector<const Expr *, 4> FirstprivateInits;\n  SmallVector<const Expr *, 4> LastprivateVars;\n  SmallVector<const Expr *, 4> LastprivateCopies;\n  SmallVector<const Expr *, 4> ReductionVars;\n  SmallVector<const Expr *, 4> ReductionOrigs;\n  SmallVector<const Expr *, 4> ReductionCopies;\n  SmallVector<const Expr *, 4> ReductionOps;\n  SmallVector<CanonicalDeclPtr<const VarDecl>, 4> PrivateLocals;\n  struct DependData {\n    OpenMPDependClauseKind DepKind = OMPC_DEPEND_unknown;\n    const Expr *IteratorExpr = nullptr;\n    SmallVector<const Expr *, 4> DepExprs;\n    explicit DependData() = default;\n    DependData(OpenMPDependClauseKind DepKind, const Expr *IteratorExpr)\n        : DepKind(DepKind), IteratorExpr(IteratorExpr) {}\n  };\n  SmallVector<DependData, 4> Dependences;\n  llvm::PointerIntPair<llvm::Value *, 1, bool> Final;\n  llvm::PointerIntPair<llvm::Value *, 1, bool> Schedule;\n  llvm::PointerIntPair<llvm::Value *, 1, bool> Priority;\n  llvm::Value *Reductions = nullptr;\n  unsigned NumberOfParts = 0;\n  bool Tied = true;\n  bool Nogroup = false;\n  bool IsReductionWithTaskMod = false;\n  bool IsWorksharingReduction = false;\n};\n\n/// Class intended to support codegen of all kind of the reduction clauses.\nclass ReductionCodeGen {\nprivate:\n  /// Data required for codegen of reduction clauses.\n  struct ReductionData {\n    /// Reference to the item shared between tasks to reduce into.\n    const Expr *Shared = nullptr;\n    /// Reference to the original item.\n    const Expr *Ref = nullptr;\n    /// Helper expression for generation of private copy.\n    const Expr *Private = nullptr;\n    /// Helper expression for generation reduction operation.\n    const Expr *ReductionOp = nullptr;\n    ReductionData(const Expr *Shared, const Expr *Ref, const Expr *Private,\n                  const Expr *ReductionOp)\n        : Shared(Shared), Ref(Ref), Private(Private), ReductionOp(ReductionOp) {\n    }\n  };\n  /// List of reduction-based clauses.\n  SmallVector<ReductionData, 4> ClausesData;\n\n  /// List of addresses of shared variables/expressions.\n  SmallVector<std::pair<LValue, LValue>, 4> SharedAddresses;\n  /// List of addresses of original variables/expressions.\n  SmallVector<std::pair<LValue, LValue>, 4> OrigAddresses;\n  /// Sizes of the reduction items in chars.\n  SmallVector<std::pair<llvm::Value *, llvm::Value *>, 4> Sizes;\n  /// Base declarations for the reduction items.\n  SmallVector<const VarDecl *, 4> BaseDecls;\n\n  /// Emits lvalue for shared expression.\n  LValue emitSharedLValue(CodeGenFunction &CGF, const Expr *E);\n  /// Emits upper bound for shared expression (if array section).\n  LValue emitSharedLValueUB(CodeGenFunction &CGF, const Expr *E);\n  /// Performs aggregate initialization.\n  /// \\param N Number of reduction item in the common list.\n  /// \\param PrivateAddr Address of the corresponding private item.\n  /// \\param SharedLVal Address of the original shared variable.\n  /// \\param DRD Declare reduction construct used for reduction item.\n  void emitAggregateInitialization(CodeGenFunction &CGF, unsigned N,\n                                   Address PrivateAddr, LValue SharedLVal,\n                                   const OMPDeclareReductionDecl *DRD);\n\npublic:\n  ReductionCodeGen(ArrayRef<const Expr *> Shareds, ArrayRef<const Expr *> Origs,\n                   ArrayRef<const Expr *> Privates,\n                   ArrayRef<const Expr *> ReductionOps);\n  /// Emits lvalue for the shared and original reduction item.\n  /// \\param N Number of the reduction item.\n  void emitSharedOrigLValue(CodeGenFunction &CGF, unsigned N);\n  /// Emits the code for the variable-modified type, if required.\n  /// \\param N Number of the reduction item.\n  void emitAggregateType(CodeGenFunction &CGF, unsigned N);\n  /// Emits the code for the variable-modified type, if required.\n  /// \\param N Number of the reduction item.\n  /// \\param Size Size of the type in chars.\n  void emitAggregateType(CodeGenFunction &CGF, unsigned N, llvm::Value *Size);\n  /// Performs initialization of the private copy for the reduction item.\n  /// \\param N Number of the reduction item.\n  /// \\param PrivateAddr Address of the corresponding private item.\n  /// \\param DefaultInit Default initialization sequence that should be\n  /// performed if no reduction specific initialization is found.\n  /// \\param SharedLVal Address of the original shared variable.\n  void\n  emitInitialization(CodeGenFunction &CGF, unsigned N, Address PrivateAddr,\n                     LValue SharedLVal,\n                     llvm::function_ref<bool(CodeGenFunction &)> DefaultInit);\n  /// Returns true if the private copy requires cleanups.\n  bool needCleanups(unsigned N);\n  /// Emits cleanup code for the reduction item.\n  /// \\param N Number of the reduction item.\n  /// \\param PrivateAddr Address of the corresponding private item.\n  void emitCleanups(CodeGenFunction &CGF, unsigned N, Address PrivateAddr);\n  /// Adjusts \\p PrivatedAddr for using instead of the original variable\n  /// address in normal operations.\n  /// \\param N Number of the reduction item.\n  /// \\param PrivateAddr Address of the corresponding private item.\n  Address adjustPrivateAddress(CodeGenFunction &CGF, unsigned N,\n                               Address PrivateAddr);\n  /// Returns LValue for the reduction item.\n  LValue getSharedLValue(unsigned N) const { return SharedAddresses[N].first; }\n  /// Returns LValue for the original reduction item.\n  LValue getOrigLValue(unsigned N) const { return OrigAddresses[N].first; }\n  /// Returns the size of the reduction item (in chars and total number of\n  /// elements in the item), or nullptr, if the size is a constant.\n  std::pair<llvm::Value *, llvm::Value *> getSizes(unsigned N) const {\n    return Sizes[N];\n  }\n  /// Returns the base declaration of the reduction item.\n  const VarDecl *getBaseDecl(unsigned N) const { return BaseDecls[N]; }\n  /// Returns the base declaration of the reduction item.\n  const Expr *getRefExpr(unsigned N) const { return ClausesData[N].Ref; }\n  /// Returns true if the initialization of the reduction item uses initializer\n  /// from declare reduction construct.\n  bool usesReductionInitializer(unsigned N) const;\n};\n\nclass CGOpenMPRuntime {\npublic:\n  /// Allows to disable automatic handling of functions used in target regions\n  /// as those marked as `omp declare target`.\n  class DisableAutoDeclareTargetRAII {\n    CodeGenModule &CGM;\n    bool SavedShouldMarkAsGlobal;\n\n  public:\n    DisableAutoDeclareTargetRAII(CodeGenModule &CGM);\n    ~DisableAutoDeclareTargetRAII();\n  };\n\n  /// Manages list of nontemporal decls for the specified directive.\n  class NontemporalDeclsRAII {\n    CodeGenModule &CGM;\n    const bool NeedToPush;\n\n  public:\n    NontemporalDeclsRAII(CodeGenModule &CGM, const OMPLoopDirective &S);\n    ~NontemporalDeclsRAII();\n  };\n\n  /// Manages list of nontemporal decls for the specified directive.\n  class UntiedTaskLocalDeclsRAII {\n    CodeGenModule &CGM;\n    const bool NeedToPush;\n\n  public:\n    UntiedTaskLocalDeclsRAII(\n        CodeGenFunction &CGF,\n        const llvm::DenseMap<CanonicalDeclPtr<const VarDecl>,\n                             std::pair<Address, Address>> &LocalVars);\n    ~UntiedTaskLocalDeclsRAII();\n  };\n\n  /// Maps the expression for the lastprivate variable to the global copy used\n  /// to store new value because original variables are not mapped in inner\n  /// parallel regions. Only private copies are captured but we need also to\n  /// store private copy in shared address.\n  /// Also, stores the expression for the private loop counter and it\n  /// threaprivate name.\n  struct LastprivateConditionalData {\n    llvm::MapVector<CanonicalDeclPtr<const Decl>, SmallString<16>>\n        DeclToUniqueName;\n    LValue IVLVal;\n    llvm::Function *Fn = nullptr;\n    bool Disabled = false;\n  };\n  /// Manages list of lastprivate conditional decls for the specified directive.\n  class LastprivateConditionalRAII {\n    enum class ActionToDo {\n      DoNotPush,\n      PushAsLastprivateConditional,\n      DisableLastprivateConditional,\n    };\n    CodeGenModule &CGM;\n    ActionToDo Action = ActionToDo::DoNotPush;\n\n    /// Check and try to disable analysis of inner regions for changes in\n    /// lastprivate conditional.\n    void tryToDisableInnerAnalysis(const OMPExecutableDirective &S,\n                                   llvm::DenseSet<CanonicalDeclPtr<const Decl>>\n                                       &NeedToAddForLPCsAsDisabled) const;\n\n    LastprivateConditionalRAII(CodeGenFunction &CGF,\n                               const OMPExecutableDirective &S);\n\n  public:\n    explicit LastprivateConditionalRAII(CodeGenFunction &CGF,\n                                        const OMPExecutableDirective &S,\n                                        LValue IVLVal);\n    static LastprivateConditionalRAII disable(CodeGenFunction &CGF,\n                                              const OMPExecutableDirective &S);\n    ~LastprivateConditionalRAII();\n  };\n\n  llvm::OpenMPIRBuilder &getOMPBuilder() { return OMPBuilder; }\n\nprotected:\n  CodeGenModule &CGM;\n  StringRef FirstSeparator, Separator;\n\n  /// An OpenMP-IR-Builder instance.\n  llvm::OpenMPIRBuilder OMPBuilder;\n\n  /// Constructor allowing to redefine the name separator for the variables.\n  explicit CGOpenMPRuntime(CodeGenModule &CGM, StringRef FirstSeparator,\n                           StringRef Separator);\n\n  /// Creates offloading entry for the provided entry ID \\a ID,\n  /// address \\a Addr, size \\a Size, and flags \\a Flags.\n  virtual void createOffloadEntry(llvm::Constant *ID, llvm::Constant *Addr,\n                                  uint64_t Size, int32_t Flags,\n                                  llvm::GlobalValue::LinkageTypes Linkage);\n\n  /// Helper to emit outlined function for 'target' directive.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// \\param CodeGen Lambda codegen specific to an accelerator device.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  virtual void emitTargetOutlinedFunctionHelper(const OMPExecutableDirective &D,\n                                                StringRef ParentName,\n                                                llvm::Function *&OutlinedFn,\n                                                llvm::Constant *&OutlinedFnID,\n                                                bool IsOffloadEntry,\n                                                const RegionCodeGenTy &CodeGen);\n\n  /// Emits object of ident_t type with info for source location.\n  /// \\param Flags Flags for OpenMP location.\n  ///\n  llvm::Value *emitUpdateLocation(CodeGenFunction &CGF, SourceLocation Loc,\n                                  unsigned Flags = 0);\n\n  /// Returns pointer to ident_t type.\n  llvm::Type *getIdentTyPointerTy();\n\n  /// Gets thread id value for the current thread.\n  ///\n  llvm::Value *getThreadID(CodeGenFunction &CGF, SourceLocation Loc);\n\n  /// Get the function name of an outlined region.\n  //  The name can be customized depending on the target.\n  //\n  virtual StringRef getOutlinedHelperName() const { return \".omp_outlined.\"; }\n\n  /// Emits \\p Callee function call with arguments \\p Args with location \\p Loc.\n  void emitCall(CodeGenFunction &CGF, SourceLocation Loc,\n                llvm::FunctionCallee Callee,\n                ArrayRef<llvm::Value *> Args = llvm::None) const;\n\n  /// Emits address of the word in a memory where current thread id is\n  /// stored.\n  virtual Address emitThreadIDAddress(CodeGenFunction &CGF, SourceLocation Loc);\n\n  void setLocThreadIdInsertPt(CodeGenFunction &CGF,\n                              bool AtCurrentPoint = false);\n  void clearLocThreadIdInsertPt(CodeGenFunction &CGF);\n\n  /// Check if the default location must be constant.\n  /// Default is false to support OMPT/OMPD.\n  virtual bool isDefaultLocationConstant() const { return false; }\n\n  /// Returns additional flags that can be stored in reserved_2 field of the\n  /// default location.\n  virtual unsigned getDefaultLocationReserved2Flags() const { return 0; }\n\n  /// Returns default flags for the barriers depending on the directive, for\n  /// which this barier is going to be emitted.\n  static unsigned getDefaultFlagsForBarriers(OpenMPDirectiveKind Kind);\n\n  /// Get the LLVM type for the critical name.\n  llvm::ArrayType *getKmpCriticalNameTy() const {return KmpCriticalNameTy;}\n\n  /// Returns corresponding lock object for the specified critical region\n  /// name. If the lock object does not exist it is created, otherwise the\n  /// reference to the existing copy is returned.\n  /// \\param CriticalName Name of the critical region.\n  ///\n  llvm::Value *getCriticalRegionLock(StringRef CriticalName);\n\nprivate:\n\n  /// Map for SourceLocation and OpenMP runtime library debug locations.\n  typedef llvm::DenseMap<SourceLocation, llvm::Value *> OpenMPDebugLocMapTy;\n  OpenMPDebugLocMapTy OpenMPDebugLocMap;\n  /// The type for a microtask which gets passed to __kmpc_fork_call().\n  /// Original representation is:\n  /// typedef void (kmpc_micro)(kmp_int32 global_tid, kmp_int32 bound_tid,...);\n  llvm::FunctionType *Kmpc_MicroTy = nullptr;\n  /// Stores debug location and ThreadID for the function.\n  struct DebugLocThreadIdTy {\n    llvm::Value *DebugLoc;\n    llvm::Value *ThreadID;\n    /// Insert point for the service instructions.\n    llvm::AssertingVH<llvm::Instruction> ServiceInsertPt = nullptr;\n  };\n  /// Map of local debug location, ThreadId and functions.\n  typedef llvm::DenseMap<llvm::Function *, DebugLocThreadIdTy>\n      OpenMPLocThreadIDMapTy;\n  OpenMPLocThreadIDMapTy OpenMPLocThreadIDMap;\n  /// Map of UDRs and corresponding combiner/initializer.\n  typedef llvm::DenseMap<const OMPDeclareReductionDecl *,\n                         std::pair<llvm::Function *, llvm::Function *>>\n      UDRMapTy;\n  UDRMapTy UDRMap;\n  /// Map of functions and locally defined UDRs.\n  typedef llvm::DenseMap<llvm::Function *,\n                         SmallVector<const OMPDeclareReductionDecl *, 4>>\n      FunctionUDRMapTy;\n  FunctionUDRMapTy FunctionUDRMap;\n  /// Map from the user-defined mapper declaration to its corresponding\n  /// functions.\n  llvm::DenseMap<const OMPDeclareMapperDecl *, llvm::Function *> UDMMap;\n  /// Map of functions and their local user-defined mappers.\n  using FunctionUDMMapTy =\n      llvm::DenseMap<llvm::Function *,\n                     SmallVector<const OMPDeclareMapperDecl *, 4>>;\n  FunctionUDMMapTy FunctionUDMMap;\n  /// Maps local variables marked as lastprivate conditional to their internal\n  /// types.\n  llvm::DenseMap<llvm::Function *,\n                 llvm::DenseMap<CanonicalDeclPtr<const Decl>,\n                                std::tuple<QualType, const FieldDecl *,\n                                           const FieldDecl *, LValue>>>\n      LastprivateConditionalToTypes;\n  /// Maps function to the position of the untied task locals stack.\n  llvm::DenseMap<llvm::Function *, unsigned> FunctionToUntiedTaskStackMap;\n  /// Type kmp_critical_name, originally defined as typedef kmp_int32\n  /// kmp_critical_name[8];\n  llvm::ArrayType *KmpCriticalNameTy;\n  /// An ordered map of auto-generated variables to their unique names.\n  /// It stores variables with the following names: 1) \".gomp_critical_user_\" +\n  /// <critical_section_name> + \".var\" for \"omp critical\" directives; 2)\n  /// <mangled_name_for_global_var> + \".cache.\" for cache for threadprivate\n  /// variables.\n  llvm::StringMap<llvm::AssertingVH<llvm::Constant>, llvm::BumpPtrAllocator>\n      InternalVars;\n  /// Type typedef kmp_int32 (* kmp_routine_entry_t)(kmp_int32, void *);\n  llvm::Type *KmpRoutineEntryPtrTy = nullptr;\n  QualType KmpRoutineEntryPtrQTy;\n  /// Type typedef struct kmp_task {\n  ///    void *              shareds; /**< pointer to block of pointers to\n  ///    shared vars   */\n  ///    kmp_routine_entry_t routine; /**< pointer to routine to call for\n  ///    executing task */\n  ///    kmp_int32           part_id; /**< part id for the task */\n  ///    kmp_routine_entry_t destructors; /* pointer to function to invoke\n  ///    deconstructors of firstprivate C++ objects */\n  /// } kmp_task_t;\n  QualType KmpTaskTQTy;\n  /// Saved kmp_task_t for task directive.\n  QualType SavedKmpTaskTQTy;\n  /// Saved kmp_task_t for taskloop-based directive.\n  QualType SavedKmpTaskloopTQTy;\n  /// Type typedef struct kmp_depend_info {\n  ///    kmp_intptr_t               base_addr;\n  ///    size_t                     len;\n  ///    struct {\n  ///             bool                   in:1;\n  ///             bool                   out:1;\n  ///    } flags;\n  /// } kmp_depend_info_t;\n  QualType KmpDependInfoTy;\n  /// Type typedef struct kmp_task_affinity_info {\n  ///    kmp_intptr_t base_addr;\n  ///    size_t len;\n  ///    struct {\n  ///      bool flag1 : 1;\n  ///      bool flag2 : 1;\n  ///      kmp_int32 reserved : 30;\n  ///   } flags;\n  /// } kmp_task_affinity_info_t;\n  QualType KmpTaskAffinityInfoTy;\n  /// struct kmp_dim {  // loop bounds info casted to kmp_int64\n  ///  kmp_int64 lo; // lower\n  ///  kmp_int64 up; // upper\n  ///  kmp_int64 st; // stride\n  /// };\n  QualType KmpDimTy;\n  /// Type struct __tgt_offload_entry{\n  ///   void      *addr;       // Pointer to the offload entry info.\n  ///                          // (function or global)\n  ///   char      *name;       // Name of the function or global.\n  ///   size_t     size;       // Size of the entry info (0 if it a function).\n  ///   int32_t flags;\n  ///   int32_t reserved;\n  /// };\n  QualType TgtOffloadEntryQTy;\n  /// Entity that registers the offloading constants that were emitted so\n  /// far.\n  class OffloadEntriesInfoManagerTy {\n    CodeGenModule &CGM;\n\n    /// Number of entries registered so far.\n    unsigned OffloadingEntriesNum = 0;\n\n  public:\n    /// Base class of the entries info.\n    class OffloadEntryInfo {\n    public:\n      /// Kind of a given entry.\n      enum OffloadingEntryInfoKinds : unsigned {\n        /// Entry is a target region.\n        OffloadingEntryInfoTargetRegion = 0,\n        /// Entry is a declare target variable.\n        OffloadingEntryInfoDeviceGlobalVar = 1,\n        /// Invalid entry info.\n        OffloadingEntryInfoInvalid = ~0u\n      };\n\n    protected:\n      OffloadEntryInfo() = delete;\n      explicit OffloadEntryInfo(OffloadingEntryInfoKinds Kind) : Kind(Kind) {}\n      explicit OffloadEntryInfo(OffloadingEntryInfoKinds Kind, unsigned Order,\n                                uint32_t Flags)\n          : Flags(Flags), Order(Order), Kind(Kind) {}\n      ~OffloadEntryInfo() = default;\n\n    public:\n      bool isValid() const { return Order != ~0u; }\n      unsigned getOrder() const { return Order; }\n      OffloadingEntryInfoKinds getKind() const { return Kind; }\n      uint32_t getFlags() const { return Flags; }\n      void setFlags(uint32_t NewFlags) { Flags = NewFlags; }\n      llvm::Constant *getAddress() const {\n        return cast_or_null<llvm::Constant>(Addr);\n      }\n      void setAddress(llvm::Constant *V) {\n        assert(!Addr.pointsToAliveValue() && \"Address has been set before!\");\n        Addr = V;\n      }\n      static bool classof(const OffloadEntryInfo *Info) { return true; }\n\n    private:\n      /// Address of the entity that has to be mapped for offloading.\n      llvm::WeakTrackingVH Addr;\n\n      /// Flags associated with the device global.\n      uint32_t Flags = 0u;\n\n      /// Order this entry was emitted.\n      unsigned Order = ~0u;\n\n      OffloadingEntryInfoKinds Kind = OffloadingEntryInfoInvalid;\n    };\n\n    /// Return true if a there are no entries defined.\n    bool empty() const;\n    /// Return number of entries defined so far.\n    unsigned size() const { return OffloadingEntriesNum; }\n    OffloadEntriesInfoManagerTy(CodeGenModule &CGM) : CGM(CGM) {}\n\n    //\n    // Target region entries related.\n    //\n\n    /// Kind of the target registry entry.\n    enum OMPTargetRegionEntryKind : uint32_t {\n      /// Mark the entry as target region.\n      OMPTargetRegionEntryTargetRegion = 0x0,\n      /// Mark the entry as a global constructor.\n      OMPTargetRegionEntryCtor = 0x02,\n      /// Mark the entry as a global destructor.\n      OMPTargetRegionEntryDtor = 0x04,\n    };\n\n    /// Target region entries info.\n    class OffloadEntryInfoTargetRegion final : public OffloadEntryInfo {\n      /// Address that can be used as the ID of the entry.\n      llvm::Constant *ID = nullptr;\n\n    public:\n      OffloadEntryInfoTargetRegion()\n          : OffloadEntryInfo(OffloadingEntryInfoTargetRegion) {}\n      explicit OffloadEntryInfoTargetRegion(unsigned Order,\n                                            llvm::Constant *Addr,\n                                            llvm::Constant *ID,\n                                            OMPTargetRegionEntryKind Flags)\n          : OffloadEntryInfo(OffloadingEntryInfoTargetRegion, Order, Flags),\n            ID(ID) {\n        setAddress(Addr);\n      }\n\n      llvm::Constant *getID() const { return ID; }\n      void setID(llvm::Constant *V) {\n        assert(!ID && \"ID has been set before!\");\n        ID = V;\n      }\n      static bool classof(const OffloadEntryInfo *Info) {\n        return Info->getKind() == OffloadingEntryInfoTargetRegion;\n      }\n    };\n\n    /// Initialize target region entry.\n    void initializeTargetRegionEntryInfo(unsigned DeviceID, unsigned FileID,\n                                         StringRef ParentName, unsigned LineNum,\n                                         unsigned Order);\n    /// Register target region entry.\n    void registerTargetRegionEntryInfo(unsigned DeviceID, unsigned FileID,\n                                       StringRef ParentName, unsigned LineNum,\n                                       llvm::Constant *Addr, llvm::Constant *ID,\n                                       OMPTargetRegionEntryKind Flags);\n    /// Return true if a target region entry with the provided information\n    /// exists.\n    bool hasTargetRegionEntryInfo(unsigned DeviceID, unsigned FileID,\n                                  StringRef ParentName, unsigned LineNum,\n                                  bool IgnoreAddressId = false) const;\n    /// brief Applies action \\a Action on all registered entries.\n    typedef llvm::function_ref<void(unsigned, unsigned, StringRef, unsigned,\n                                    const OffloadEntryInfoTargetRegion &)>\n        OffloadTargetRegionEntryInfoActTy;\n    void actOnTargetRegionEntriesInfo(\n        const OffloadTargetRegionEntryInfoActTy &Action);\n\n    //\n    // Device global variable entries related.\n    //\n\n    /// Kind of the global variable entry..\n    enum OMPTargetGlobalVarEntryKind : uint32_t {\n      /// Mark the entry as a to declare target.\n      OMPTargetGlobalVarEntryTo = 0x0,\n      /// Mark the entry as a to declare target link.\n      OMPTargetGlobalVarEntryLink = 0x1,\n    };\n\n    /// Device global variable entries info.\n    class OffloadEntryInfoDeviceGlobalVar final : public OffloadEntryInfo {\n      /// Type of the global variable.\n     CharUnits VarSize;\n     llvm::GlobalValue::LinkageTypes Linkage;\n\n   public:\n     OffloadEntryInfoDeviceGlobalVar()\n         : OffloadEntryInfo(OffloadingEntryInfoDeviceGlobalVar) {}\n     explicit OffloadEntryInfoDeviceGlobalVar(unsigned Order,\n                                              OMPTargetGlobalVarEntryKind Flags)\n         : OffloadEntryInfo(OffloadingEntryInfoDeviceGlobalVar, Order, Flags) {}\n     explicit OffloadEntryInfoDeviceGlobalVar(\n         unsigned Order, llvm::Constant *Addr, CharUnits VarSize,\n         OMPTargetGlobalVarEntryKind Flags,\n         llvm::GlobalValue::LinkageTypes Linkage)\n         : OffloadEntryInfo(OffloadingEntryInfoDeviceGlobalVar, Order, Flags),\n           VarSize(VarSize), Linkage(Linkage) {\n       setAddress(Addr);\n      }\n\n      CharUnits getVarSize() const { return VarSize; }\n      void setVarSize(CharUnits Size) { VarSize = Size; }\n      llvm::GlobalValue::LinkageTypes getLinkage() const { return Linkage; }\n      void setLinkage(llvm::GlobalValue::LinkageTypes LT) { Linkage = LT; }\n      static bool classof(const OffloadEntryInfo *Info) {\n        return Info->getKind() == OffloadingEntryInfoDeviceGlobalVar;\n      }\n    };\n\n    /// Initialize device global variable entry.\n    void initializeDeviceGlobalVarEntryInfo(StringRef Name,\n                                            OMPTargetGlobalVarEntryKind Flags,\n                                            unsigned Order);\n\n    /// Register device global variable entry.\n    void\n    registerDeviceGlobalVarEntryInfo(StringRef VarName, llvm::Constant *Addr,\n                                     CharUnits VarSize,\n                                     OMPTargetGlobalVarEntryKind Flags,\n                                     llvm::GlobalValue::LinkageTypes Linkage);\n    /// Checks if the variable with the given name has been registered already.\n    bool hasDeviceGlobalVarEntryInfo(StringRef VarName) const {\n      return OffloadEntriesDeviceGlobalVar.count(VarName) > 0;\n    }\n    /// Applies action \\a Action on all registered entries.\n    typedef llvm::function_ref<void(StringRef,\n                                    const OffloadEntryInfoDeviceGlobalVar &)>\n        OffloadDeviceGlobalVarEntryInfoActTy;\n    void actOnDeviceGlobalVarEntriesInfo(\n        const OffloadDeviceGlobalVarEntryInfoActTy &Action);\n\n  private:\n    // Storage for target region entries kind. The storage is to be indexed by\n    // file ID, device ID, parent function name and line number.\n    typedef llvm::DenseMap<unsigned, OffloadEntryInfoTargetRegion>\n        OffloadEntriesTargetRegionPerLine;\n    typedef llvm::StringMap<OffloadEntriesTargetRegionPerLine>\n        OffloadEntriesTargetRegionPerParentName;\n    typedef llvm::DenseMap<unsigned, OffloadEntriesTargetRegionPerParentName>\n        OffloadEntriesTargetRegionPerFile;\n    typedef llvm::DenseMap<unsigned, OffloadEntriesTargetRegionPerFile>\n        OffloadEntriesTargetRegionPerDevice;\n    typedef OffloadEntriesTargetRegionPerDevice OffloadEntriesTargetRegionTy;\n    OffloadEntriesTargetRegionTy OffloadEntriesTargetRegion;\n    /// Storage for device global variable entries kind. The storage is to be\n    /// indexed by mangled name.\n    typedef llvm::StringMap<OffloadEntryInfoDeviceGlobalVar>\n        OffloadEntriesDeviceGlobalVarTy;\n    OffloadEntriesDeviceGlobalVarTy OffloadEntriesDeviceGlobalVar;\n  };\n  OffloadEntriesInfoManagerTy OffloadEntriesInfoManager;\n\n  bool ShouldMarkAsGlobal = true;\n  /// List of the emitted declarations.\n  llvm::DenseSet<CanonicalDeclPtr<const Decl>> AlreadyEmittedTargetDecls;\n  /// List of the global variables with their addresses that should not be\n  /// emitted for the target.\n  llvm::StringMap<llvm::WeakTrackingVH> EmittedNonTargetVariables;\n\n  /// List of variables that can become declare target implicitly and, thus,\n  /// must be emitted.\n  llvm::SmallDenseSet<const VarDecl *> DeferredGlobalVariables;\n\n  using NontemporalDeclsSet = llvm::SmallDenseSet<CanonicalDeclPtr<const Decl>>;\n  /// Stack for list of declarations in current context marked as nontemporal.\n  /// The set is the union of all current stack elements.\n  llvm::SmallVector<NontemporalDeclsSet, 4> NontemporalDeclsStack;\n\n  using UntiedLocalVarsAddressesMap =\n      llvm::DenseMap<CanonicalDeclPtr<const VarDecl>,\n                     std::pair<Address, Address>>;\n  llvm::SmallVector<UntiedLocalVarsAddressesMap, 4> UntiedLocalVarsStack;\n\n  /// Stack for list of addresses of declarations in current context marked as\n  /// lastprivate conditional. The set is the union of all current stack\n  /// elements.\n  llvm::SmallVector<LastprivateConditionalData, 4> LastprivateConditionalStack;\n\n  /// Flag for keeping track of weather a requires unified_shared_memory\n  /// directive is present.\n  bool HasRequiresUnifiedSharedMemory = false;\n\n  /// Atomic ordering from the omp requires directive.\n  llvm::AtomicOrdering RequiresAtomicOrdering = llvm::AtomicOrdering::Monotonic;\n\n  /// Flag for keeping track of weather a target region has been emitted.\n  bool HasEmittedTargetRegion = false;\n\n  /// Flag for keeping track of weather a device routine has been emitted.\n  /// Device routines are specific to the\n  bool HasEmittedDeclareTargetRegion = false;\n\n  /// Loads all the offload entries information from the host IR\n  /// metadata.\n  void loadOffloadInfoMetadata();\n\n  /// Returns __tgt_offload_entry type.\n  QualType getTgtOffloadEntryQTy();\n\n  /// Start scanning from statement \\a S and and emit all target regions\n  /// found along the way.\n  /// \\param S Starting statement.\n  /// \\param ParentName Name of the function declaration that is being scanned.\n  void scanForTargetRegionsFunctions(const Stmt *S, StringRef ParentName);\n\n  /// Build type kmp_routine_entry_t (if not built yet).\n  void emitKmpRoutineEntryT(QualType KmpInt32Ty);\n\n  /// Returns pointer to kmpc_micro type.\n  llvm::Type *getKmpc_MicroPointerTy();\n\n  /// Returns __kmpc_for_static_init_* runtime function for the specified\n  /// size \\a IVSize and sign \\a IVSigned.\n  llvm::FunctionCallee createForStaticInitFunction(unsigned IVSize,\n                                                   bool IVSigned);\n\n  /// Returns __kmpc_dispatch_init_* runtime function for the specified\n  /// size \\a IVSize and sign \\a IVSigned.\n  llvm::FunctionCallee createDispatchInitFunction(unsigned IVSize,\n                                                  bool IVSigned);\n\n  /// Returns __kmpc_dispatch_next_* runtime function for the specified\n  /// size \\a IVSize and sign \\a IVSigned.\n  llvm::FunctionCallee createDispatchNextFunction(unsigned IVSize,\n                                                  bool IVSigned);\n\n  /// Returns __kmpc_dispatch_fini_* runtime function for the specified\n  /// size \\a IVSize and sign \\a IVSigned.\n  llvm::FunctionCallee createDispatchFiniFunction(unsigned IVSize,\n                                                  bool IVSigned);\n\n  /// If the specified mangled name is not in the module, create and\n  /// return threadprivate cache object. This object is a pointer's worth of\n  /// storage that's reserved for use by the OpenMP runtime.\n  /// \\param VD Threadprivate variable.\n  /// \\return Cache variable for the specified threadprivate.\n  llvm::Constant *getOrCreateThreadPrivateCache(const VarDecl *VD);\n\n  /// Gets (if variable with the given name already exist) or creates\n  /// internal global variable with the specified Name. The created variable has\n  /// linkage CommonLinkage by default and is initialized by null value.\n  /// \\param Ty Type of the global variable. If it is exist already the type\n  /// must be the same.\n  /// \\param Name Name of the variable.\n  llvm::Constant *getOrCreateInternalVariable(llvm::Type *Ty,\n                                              const llvm::Twine &Name,\n                                              unsigned AddressSpace = 0);\n\n  /// Set of threadprivate variables with the generated initializer.\n  llvm::StringSet<> ThreadPrivateWithDefinition;\n\n  /// Set of declare target variables with the generated initializer.\n  llvm::StringSet<> DeclareTargetWithDefinition;\n\n  /// Emits initialization code for the threadprivate variables.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Ctor Pointer to a global init function for \\a VD.\n  /// \\param CopyCtor Pointer to a global copy function for \\a VD.\n  /// \\param Dtor Pointer to a global destructor function for \\a VD.\n  /// \\param Loc Location of threadprivate declaration.\n  void emitThreadPrivateVarInit(CodeGenFunction &CGF, Address VDAddr,\n                                llvm::Value *Ctor, llvm::Value *CopyCtor,\n                                llvm::Value *Dtor, SourceLocation Loc);\n\n  /// Emit the array initialization or deletion portion for user-defined mapper\n  /// code generation.\n  void emitUDMapperArrayInitOrDel(CodeGenFunction &MapperCGF,\n                                  llvm::Value *Handle, llvm::Value *BasePtr,\n                                  llvm::Value *Ptr, llvm::Value *Size,\n                                  llvm::Value *MapType, CharUnits ElementSize,\n                                  llvm::BasicBlock *ExitBB, bool IsInit);\n\n  struct TaskResultTy {\n    llvm::Value *NewTask = nullptr;\n    llvm::Function *TaskEntry = nullptr;\n    llvm::Value *NewTaskNewTaskTTy = nullptr;\n    LValue TDBase;\n    const RecordDecl *KmpTaskTQTyRD = nullptr;\n    llvm::Value *TaskDupFn = nullptr;\n  };\n  /// Emit task region for the task directive. The task region is emitted in\n  /// several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  TaskResultTy emitTaskInit(CodeGenFunction &CGF, SourceLocation Loc,\n                            const OMPExecutableDirective &D,\n                            llvm::Function *TaskFunction, QualType SharedsTy,\n                            Address Shareds, const OMPTaskDataTy &Data);\n\n  /// Returns default address space for the constant firstprivates, 0 by\n  /// default.\n  virtual unsigned getDefaultFirstprivateAddressSpace() const { return 0; }\n\n  /// Emit code that pushes the trip count of loops associated with constructs\n  /// 'target teams distribute' and 'teams distribute parallel for'.\n  /// \\param SizeEmitter Emits the int64 value for the number of iterations of\n  /// the associated loop.\n  void emitTargetNumIterationsCall(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D,\n      llvm::Value *DeviceID,\n      llvm::function_ref<llvm::Value *(CodeGenFunction &CGF,\n                                       const OMPLoopDirective &D)>\n          SizeEmitter);\n\n  /// Emit update for lastprivate conditional data.\n  void emitLastprivateConditionalUpdate(CodeGenFunction &CGF, LValue IVLVal,\n                                        StringRef UniqueDeclName, LValue LVal,\n                                        SourceLocation Loc);\n\n  /// Returns the number of the elements and the address of the depobj\n  /// dependency array.\n  /// \\return Number of elements in depobj array and the pointer to the array of\n  /// dependencies.\n  std::pair<llvm::Value *, LValue> getDepobjElements(CodeGenFunction &CGF,\n                                                     LValue DepobjLVal,\n                                                     SourceLocation Loc);\n\npublic:\n  explicit CGOpenMPRuntime(CodeGenModule &CGM)\n      : CGOpenMPRuntime(CGM, \".\", \".\") {}\n  virtual ~CGOpenMPRuntime() {}\n  virtual void clear();\n\n  /// Emits code for OpenMP 'if' clause using specified \\a CodeGen\n  /// function. Here is the logic:\n  /// if (Cond) {\n  ///   ThenGen();\n  /// } else {\n  ///   ElseGen();\n  /// }\n  void emitIfClause(CodeGenFunction &CGF, const Expr *Cond,\n                    const RegionCodeGenTy &ThenGen,\n                    const RegionCodeGenTy &ElseGen);\n\n  /// Checks if the \\p Body is the \\a CompoundStmt and returns its child\n  /// statement iff there is only one that is not evaluatable at the compile\n  /// time.\n  static const Stmt *getSingleCompoundChild(ASTContext &Ctx, const Stmt *Body);\n\n  /// Get the platform-specific name separator.\n  std::string getName(ArrayRef<StringRef> Parts) const;\n\n  /// Emit code for the specified user defined reduction construct.\n  virtual void emitUserDefinedReduction(CodeGenFunction *CGF,\n                                        const OMPDeclareReductionDecl *D);\n  /// Get combiner/initializer for the specified user-defined reduction, if any.\n  virtual std::pair<llvm::Function *, llvm::Function *>\n  getUserDefinedReduction(const OMPDeclareReductionDecl *D);\n\n  /// Emit the function for the user defined mapper construct.\n  void emitUserDefinedMapper(const OMPDeclareMapperDecl *D,\n                             CodeGenFunction *CGF = nullptr);\n  /// Get the function for the specified user-defined mapper. If it does not\n  /// exist, create one.\n  llvm::Function *\n  getOrCreateUserDefinedMapperFunc(const OMPDeclareMapperDecl *D);\n\n  /// Emits outlined function for the specified OpenMP parallel directive\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  virtual llvm::Function *emitParallelOutlinedFunction(\n      const OMPExecutableDirective &D, const VarDecl *ThreadIDVar,\n      OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen);\n\n  /// Emits outlined function for the specified OpenMP teams directive\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  virtual llvm::Function *emitTeamsOutlinedFunction(\n      const OMPExecutableDirective &D, const VarDecl *ThreadIDVar,\n      OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen);\n\n  /// Emits outlined function for the OpenMP task directive \\a D. This\n  /// outlined function has type void(*)(kmp_int32 ThreadID, struct task_t*\n  /// TaskT).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param PartIDVar Variable for partition id in the current OpenMP untied\n  /// task region.\n  /// \\param TaskTVar Variable for task_t argument.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// \\param Tied true if task is generated for tied task, false otherwise.\n  /// \\param NumberOfParts Number of parts in untied task. Ignored for tied\n  /// tasks.\n  ///\n  virtual llvm::Function *emitTaskOutlinedFunction(\n      const OMPExecutableDirective &D, const VarDecl *ThreadIDVar,\n      const VarDecl *PartIDVar, const VarDecl *TaskTVar,\n      OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen,\n      bool Tied, unsigned &NumberOfParts);\n\n  /// Cleans up references to the objects in finished function.\n  ///\n  virtual void functionFinished(CodeGenFunction &CGF);\n\n  /// Emits code for parallel or serial call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run in parallel threads. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  ///\n  virtual void emitParallelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                                llvm::Function *OutlinedFn,\n                                ArrayRef<llvm::Value *> CapturedVars,\n                                const Expr *IfCond);\n\n  /// Emits a critical region.\n  /// \\param CriticalName Name of the critical region.\n  /// \\param CriticalOpGen Generator for the statement associated with the given\n  /// critical region.\n  /// \\param Hint Value of the 'hint' clause (optional).\n  virtual void emitCriticalRegion(CodeGenFunction &CGF, StringRef CriticalName,\n                                  const RegionCodeGenTy &CriticalOpGen,\n                                  SourceLocation Loc,\n                                  const Expr *Hint = nullptr);\n\n  /// Emits a master region.\n  /// \\param MasterOpGen Generator for the statement associated with the given\n  /// master region.\n  virtual void emitMasterRegion(CodeGenFunction &CGF,\n                                const RegionCodeGenTy &MasterOpGen,\n                                SourceLocation Loc);\n\n  /// Emits code for a taskyield directive.\n  virtual void emitTaskyieldCall(CodeGenFunction &CGF, SourceLocation Loc);\n\n  /// Emit a taskgroup region.\n  /// \\param TaskgroupOpGen Generator for the statement associated with the\n  /// given taskgroup region.\n  virtual void emitTaskgroupRegion(CodeGenFunction &CGF,\n                                   const RegionCodeGenTy &TaskgroupOpGen,\n                                   SourceLocation Loc);\n\n  /// Emits a single region.\n  /// \\param SingleOpGen Generator for the statement associated with the given\n  /// single region.\n  virtual void emitSingleRegion(CodeGenFunction &CGF,\n                                const RegionCodeGenTy &SingleOpGen,\n                                SourceLocation Loc,\n                                ArrayRef<const Expr *> CopyprivateVars,\n                                ArrayRef<const Expr *> DestExprs,\n                                ArrayRef<const Expr *> SrcExprs,\n                                ArrayRef<const Expr *> AssignmentOps);\n\n  /// Emit an ordered region.\n  /// \\param OrderedOpGen Generator for the statement associated with the given\n  /// ordered region.\n  virtual void emitOrderedRegion(CodeGenFunction &CGF,\n                                 const RegionCodeGenTy &OrderedOpGen,\n                                 SourceLocation Loc, bool IsThreads);\n\n  /// Emit an implicit/explicit barrier for OpenMP threads.\n  /// \\param Kind Directive for which this implicit barrier call must be\n  /// generated. Must be OMPD_barrier for explicit barrier generation.\n  /// \\param EmitChecks true if need to emit checks for cancellation barriers.\n  /// \\param ForceSimpleCall true simple barrier call must be emitted, false if\n  /// runtime class decides which one to emit (simple or with cancellation\n  /// checks).\n  ///\n  virtual void emitBarrierCall(CodeGenFunction &CGF, SourceLocation Loc,\n                               OpenMPDirectiveKind Kind,\n                               bool EmitChecks = true,\n                               bool ForceSimpleCall = false);\n\n  /// Check if the specified \\a ScheduleKind is static non-chunked.\n  /// This kind of worksharing directive is emitted without outer loop.\n  /// \\param ScheduleKind Schedule kind specified in the 'schedule' clause.\n  /// \\param Chunked True if chunk is specified in the clause.\n  ///\n  virtual bool isStaticNonchunked(OpenMPScheduleClauseKind ScheduleKind,\n                                  bool Chunked) const;\n\n  /// Check if the specified \\a ScheduleKind is static non-chunked.\n  /// This kind of distribute directive is emitted without outer loop.\n  /// \\param ScheduleKind Schedule kind specified in the 'dist_schedule' clause.\n  /// \\param Chunked True if chunk is specified in the clause.\n  ///\n  virtual bool isStaticNonchunked(OpenMPDistScheduleClauseKind ScheduleKind,\n                                  bool Chunked) const;\n\n  /// Check if the specified \\a ScheduleKind is static chunked.\n  /// \\param ScheduleKind Schedule kind specified in the 'schedule' clause.\n  /// \\param Chunked True if chunk is specified in the clause.\n  ///\n  virtual bool isStaticChunked(OpenMPScheduleClauseKind ScheduleKind,\n                               bool Chunked) const;\n\n  /// Check if the specified \\a ScheduleKind is static non-chunked.\n  /// \\param ScheduleKind Schedule kind specified in the 'dist_schedule' clause.\n  /// \\param Chunked True if chunk is specified in the clause.\n  ///\n  virtual bool isStaticChunked(OpenMPDistScheduleClauseKind ScheduleKind,\n                               bool Chunked) const;\n\n  /// Check if the specified \\a ScheduleKind is dynamic.\n  /// This kind of worksharing directive is emitted without outer loop.\n  /// \\param ScheduleKind Schedule Kind specified in the 'schedule' clause.\n  ///\n  virtual bool isDynamic(OpenMPScheduleClauseKind ScheduleKind) const;\n\n  /// struct with the values to be passed to the dispatch runtime function\n  struct DispatchRTInput {\n    /// Loop lower bound\n    llvm::Value *LB = nullptr;\n    /// Loop upper bound\n    llvm::Value *UB = nullptr;\n    /// Chunk size specified using 'schedule' clause (nullptr if chunk\n    /// was not specified)\n    llvm::Value *Chunk = nullptr;\n    DispatchRTInput() = default;\n    DispatchRTInput(llvm::Value *LB, llvm::Value *UB, llvm::Value *Chunk)\n        : LB(LB), UB(UB), Chunk(Chunk) {}\n  };\n\n  /// Call the appropriate runtime routine to initialize it before start\n  /// of loop.\n\n  /// This is used for non static scheduled types and when the ordered\n  /// clause is present on the loop construct.\n  /// Depending on the loop schedule, it is necessary to call some runtime\n  /// routine before start of the OpenMP loop to get the loop upper / lower\n  /// bounds \\a LB and \\a UB and stride \\a ST.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param ScheduleKind Schedule kind, specified by the 'schedule' clause.\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  /// \\param Ordered true if loop is ordered, false otherwise.\n  /// \\param DispatchValues struct containing llvm values for lower bound, upper\n  /// bound, and chunk expression.\n  /// For the default (nullptr) value, the chunk 1 will be used.\n  ///\n  virtual void emitForDispatchInit(CodeGenFunction &CGF, SourceLocation Loc,\n                                   const OpenMPScheduleTy &ScheduleKind,\n                                   unsigned IVSize, bool IVSigned, bool Ordered,\n                                   const DispatchRTInput &DispatchValues);\n\n  /// Struct with the values to be passed to the static runtime function\n  struct StaticRTInput {\n    /// Size of the iteration variable in bits.\n    unsigned IVSize = 0;\n    /// Sign of the iteration variable.\n    bool IVSigned = false;\n    /// true if loop is ordered, false otherwise.\n    bool Ordered = false;\n    /// Address of the output variable in which the flag of the last iteration\n    /// is returned.\n    Address IL = Address::invalid();\n    /// Address of the output variable in which the lower iteration number is\n    /// returned.\n    Address LB = Address::invalid();\n    /// Address of the output variable in which the upper iteration number is\n    /// returned.\n    Address UB = Address::invalid();\n    /// Address of the output variable in which the stride value is returned\n    /// necessary to generated the static_chunked scheduled loop.\n    Address ST = Address::invalid();\n    /// Value of the chunk for the static_chunked scheduled loop. For the\n    /// default (nullptr) value, the chunk 1 will be used.\n    llvm::Value *Chunk = nullptr;\n    StaticRTInput(unsigned IVSize, bool IVSigned, bool Ordered, Address IL,\n                  Address LB, Address UB, Address ST,\n                  llvm::Value *Chunk = nullptr)\n        : IVSize(IVSize), IVSigned(IVSigned), Ordered(Ordered), IL(IL), LB(LB),\n          UB(UB), ST(ST), Chunk(Chunk) {}\n  };\n  /// Call the appropriate runtime routine to initialize it before start\n  /// of loop.\n  ///\n  /// This is used only in case of static schedule, when the user did not\n  /// specify a ordered clause on the loop construct.\n  /// Depending on the loop schedule, it is necessary to call some runtime\n  /// routine before start of the OpenMP loop to get the loop upper / lower\n  /// bounds LB and UB and stride ST.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param DKind Kind of the directive.\n  /// \\param ScheduleKind Schedule kind, specified by the 'schedule' clause.\n  /// \\param Values Input arguments for the construct.\n  ///\n  virtual void emitForStaticInit(CodeGenFunction &CGF, SourceLocation Loc,\n                                 OpenMPDirectiveKind DKind,\n                                 const OpenMPScheduleTy &ScheduleKind,\n                                 const StaticRTInput &Values);\n\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param SchedKind Schedule kind, specified by the 'dist_schedule' clause.\n  /// \\param Values Input arguments for the construct.\n  ///\n  virtual void emitDistributeStaticInit(CodeGenFunction &CGF,\n                                        SourceLocation Loc,\n                                        OpenMPDistScheduleClauseKind SchedKind,\n                                        const StaticRTInput &Values);\n\n  /// Call the appropriate runtime routine to notify that we finished\n  /// iteration of the ordered loop with the dynamic scheduling.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  ///\n  virtual void emitForOrderedIterationEnd(CodeGenFunction &CGF,\n                                          SourceLocation Loc, unsigned IVSize,\n                                          bool IVSigned);\n\n  /// Call the appropriate runtime routine to notify that we finished\n  /// all the work with current loop.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param DKind Kind of the directive for which the static finish is emitted.\n  ///\n  virtual void emitForStaticFinish(CodeGenFunction &CGF, SourceLocation Loc,\n                                   OpenMPDirectiveKind DKind);\n\n  /// Call __kmpc_dispatch_next(\n  ///          ident_t *loc, kmp_int32 tid, kmp_int32 *p_lastiter,\n  ///          kmp_int[32|64] *p_lower, kmp_int[32|64] *p_upper,\n  ///          kmp_int[32|64] *p_stride);\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  /// \\param IL Address of the output variable in which the flag of the\n  /// last iteration is returned.\n  /// \\param LB Address of the output variable in which the lower iteration\n  /// number is returned.\n  /// \\param UB Address of the output variable in which the upper iteration\n  /// number is returned.\n  /// \\param ST Address of the output variable in which the stride value is\n  /// returned.\n  virtual llvm::Value *emitForNext(CodeGenFunction &CGF, SourceLocation Loc,\n                                   unsigned IVSize, bool IVSigned,\n                                   Address IL, Address LB,\n                                   Address UB, Address ST);\n\n  /// Emits call to void __kmpc_push_num_threads(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_threads) to generate code for 'num_threads'\n  /// clause.\n  /// \\param NumThreads An integer value of threads.\n  virtual void emitNumThreadsClause(CodeGenFunction &CGF,\n                                    llvm::Value *NumThreads,\n                                    SourceLocation Loc);\n\n  /// Emit call to void __kmpc_push_proc_bind(ident_t *loc, kmp_int32\n  /// global_tid, int proc_bind) to generate code for 'proc_bind' clause.\n  virtual void emitProcBindClause(CodeGenFunction &CGF,\n                                  llvm::omp::ProcBindKind ProcBind,\n                                  SourceLocation Loc);\n\n  /// Returns address of the threadprivate variable for the current\n  /// thread.\n  /// \\param VD Threadprivate variable.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Loc Location of the reference to threadprivate var.\n  /// \\return Address of the threadprivate variable for the current thread.\n  virtual Address getAddrOfThreadPrivate(CodeGenFunction &CGF,\n                                         const VarDecl *VD,\n                                         Address VDAddr,\n                                         SourceLocation Loc);\n\n  /// Returns the address of the variable marked as declare target with link\n  /// clause OR as declare target with to clause and unified memory.\n  virtual Address getAddrOfDeclareTargetVar(const VarDecl *VD);\n\n  /// Emit a code for initialization of threadprivate variable. It emits\n  /// a call to runtime library which adds initial value to the newly created\n  /// threadprivate variable (if it is not constant) and registers destructor\n  /// for the variable (if any).\n  /// \\param VD Threadprivate variable.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Loc Location of threadprivate declaration.\n  /// \\param PerformInit true if initialization expression is not constant.\n  virtual llvm::Function *\n  emitThreadPrivateVarDefinition(const VarDecl *VD, Address VDAddr,\n                                 SourceLocation Loc, bool PerformInit,\n                                 CodeGenFunction *CGF = nullptr);\n\n  /// Emit a code for initialization of declare target variable.\n  /// \\param VD Declare target variable.\n  /// \\param Addr Address of the global variable \\a VD.\n  /// \\param PerformInit true if initialization expression is not constant.\n  virtual bool emitDeclareTargetVarDefinition(const VarDecl *VD,\n                                              llvm::GlobalVariable *Addr,\n                                              bool PerformInit);\n\n  /// Creates artificial threadprivate variable with name \\p Name and type \\p\n  /// VarType.\n  /// \\param VarType Type of the artificial threadprivate variable.\n  /// \\param Name Name of the artificial threadprivate variable.\n  virtual Address getAddrOfArtificialThreadPrivate(CodeGenFunction &CGF,\n                                                   QualType VarType,\n                                                   StringRef Name);\n\n  /// Emit flush of the variables specified in 'omp flush' directive.\n  /// \\param Vars List of variables to flush.\n  virtual void emitFlush(CodeGenFunction &CGF, ArrayRef<const Expr *> Vars,\n                         SourceLocation Loc, llvm::AtomicOrdering AO);\n\n  /// Emit task region for the task directive. The task region is\n  /// emitted in several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// 4. Emit a call to kmp_int32 __kmpc_omp_task(ident_t *, kmp_int32 gtid,\n  /// kmp_task_t *new_task), where new_task is a resulting structure from\n  /// previous items.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param IfCond Not a nullptr if 'if' clause was specified, nullptr\n  /// otherwise.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  virtual void emitTaskCall(CodeGenFunction &CGF, SourceLocation Loc,\n                            const OMPExecutableDirective &D,\n                            llvm::Function *TaskFunction, QualType SharedsTy,\n                            Address Shareds, const Expr *IfCond,\n                            const OMPTaskDataTy &Data);\n\n  /// Emit task region for the taskloop directive. The taskloop region is\n  /// emitted in several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// 4. Emit a call to void __kmpc_taskloop(ident_t *loc, int gtid, kmp_task_t\n  /// *task, int if_val, kmp_uint64 *lb, kmp_uint64 *ub, kmp_int64 st, int\n  /// nogroup, int sched, kmp_uint64 grainsize, void *task_dup ), where new_task\n  /// is a resulting structure from\n  /// previous items.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param IfCond Not a nullptr if 'if' clause was specified, nullptr\n  /// otherwise.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  virtual void emitTaskLoopCall(CodeGenFunction &CGF, SourceLocation Loc,\n                                const OMPLoopDirective &D,\n                                llvm::Function *TaskFunction,\n                                QualType SharedsTy, Address Shareds,\n                                const Expr *IfCond, const OMPTaskDataTy &Data);\n\n  /// Emit code for the directive that does not require outlining.\n  ///\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// \\param HasCancel true if region has inner cancel directive, false\n  /// otherwise.\n  virtual void emitInlinedDirective(CodeGenFunction &CGF,\n                                    OpenMPDirectiveKind InnermostKind,\n                                    const RegionCodeGenTy &CodeGen,\n                                    bool HasCancel = false);\n\n  /// Emits reduction function.\n  /// \\param ArgsType Array type containing pointers to reduction variables.\n  /// \\param Privates List of private copies for original reduction arguments.\n  /// \\param LHSExprs List of LHS in \\a ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a ReductionOps reduction operations.\n  /// \\param ReductionOps List of reduction operations in form 'LHS binop RHS'\n  /// or 'operator binop(LHS, RHS)'.\n  llvm::Function *emitReductionFunction(SourceLocation Loc,\n                                        llvm::Type *ArgsType,\n                                        ArrayRef<const Expr *> Privates,\n                                        ArrayRef<const Expr *> LHSExprs,\n                                        ArrayRef<const Expr *> RHSExprs,\n                                        ArrayRef<const Expr *> ReductionOps);\n\n  /// Emits single reduction combiner\n  void emitSingleReductionCombiner(CodeGenFunction &CGF,\n                                   const Expr *ReductionOp,\n                                   const Expr *PrivateRef,\n                                   const DeclRefExpr *LHS,\n                                   const DeclRefExpr *RHS);\n\n  struct ReductionOptionsTy {\n    bool WithNowait;\n    bool SimpleReduction;\n    OpenMPDirectiveKind ReductionKind;\n  };\n  /// Emit a code for reduction clause. Next code should be emitted for\n  /// reduction:\n  /// \\code\n  ///\n  /// static kmp_critical_name lock = { 0 };\n  ///\n  /// void reduce_func(void *lhs[<n>], void *rhs[<n>]) {\n  ///  ...\n  ///  *(Type<i>*)lhs[i] = RedOp<i>(*(Type<i>*)lhs[i], *(Type<i>*)rhs[i]);\n  ///  ...\n  /// }\n  ///\n  /// ...\n  /// void *RedList[<n>] = {&<RHSExprs>[0], ..., &<RHSExprs>[<n>-1]};\n  /// switch (__kmpc_reduce{_nowait}(<loc>, <gtid>, <n>, sizeof(RedList),\n  /// RedList, reduce_func, &<lock>)) {\n  /// case 1:\n  ///  ...\n  ///  <LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]);\n  ///  ...\n  /// __kmpc_end_reduce{_nowait}(<loc>, <gtid>, &<lock>);\n  /// break;\n  /// case 2:\n  ///  ...\n  ///  Atomic(<LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]));\n  ///  ...\n  /// break;\n  /// default:;\n  /// }\n  /// \\endcode\n  ///\n  /// \\param Privates List of private copies for original reduction arguments.\n  /// \\param LHSExprs List of LHS in \\a ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a ReductionOps reduction operations.\n  /// \\param ReductionOps List of reduction operations in form 'LHS binop RHS'\n  /// or 'operator binop(LHS, RHS)'.\n  /// \\param Options List of options for reduction codegen:\n  ///     WithNowait true if parent directive has also nowait clause, false\n  ///     otherwise.\n  ///     SimpleReduction Emit reduction operation only. Used for omp simd\n  ///     directive on the host.\n  ///     ReductionKind The kind of reduction to perform.\n  virtual void emitReduction(CodeGenFunction &CGF, SourceLocation Loc,\n                             ArrayRef<const Expr *> Privates,\n                             ArrayRef<const Expr *> LHSExprs,\n                             ArrayRef<const Expr *> RHSExprs,\n                             ArrayRef<const Expr *> ReductionOps,\n                             ReductionOptionsTy Options);\n\n  /// Emit a code for initialization of task reduction clause. Next code\n  /// should be emitted for reduction:\n  /// \\code\n  ///\n  /// _taskred_item_t red_data[n];\n  /// ...\n  /// red_data[i].shar = &shareds[i];\n  /// red_data[i].orig = &origs[i];\n  /// red_data[i].size = sizeof(origs[i]);\n  /// red_data[i].f_init = (void*)RedInit<i>;\n  /// red_data[i].f_fini = (void*)RedDest<i>;\n  /// red_data[i].f_comb = (void*)RedOp<i>;\n  /// red_data[i].flags = <Flag_i>;\n  /// ...\n  /// void* tg1 = __kmpc_taskred_init(gtid, n, red_data);\n  /// \\endcode\n  /// For reduction clause with task modifier it emits the next call:\n  /// \\code\n  ///\n  /// _taskred_item_t red_data[n];\n  /// ...\n  /// red_data[i].shar = &shareds[i];\n  /// red_data[i].orig = &origs[i];\n  /// red_data[i].size = sizeof(origs[i]);\n  /// red_data[i].f_init = (void*)RedInit<i>;\n  /// red_data[i].f_fini = (void*)RedDest<i>;\n  /// red_data[i].f_comb = (void*)RedOp<i>;\n  /// red_data[i].flags = <Flag_i>;\n  /// ...\n  /// void* tg1 = __kmpc_taskred_modifier_init(loc, gtid, is_worksharing, n,\n  /// red_data);\n  /// \\endcode\n  /// \\param LHSExprs List of LHS in \\a Data.ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a Data.ReductionOps reduction operations.\n  /// \\param Data Additional data for task generation like tiedness, final\n  /// state, list of privates, reductions etc.\n  virtual llvm::Value *emitTaskReductionInit(CodeGenFunction &CGF,\n                                             SourceLocation Loc,\n                                             ArrayRef<const Expr *> LHSExprs,\n                                             ArrayRef<const Expr *> RHSExprs,\n                                             const OMPTaskDataTy &Data);\n\n  /// Emits the following code for reduction clause with task modifier:\n  /// \\code\n  /// __kmpc_task_reduction_modifier_fini(loc, gtid, is_worksharing);\n  /// \\endcode\n  virtual void emitTaskReductionFini(CodeGenFunction &CGF, SourceLocation Loc,\n                                     bool IsWorksharingReduction);\n\n  /// Required to resolve existing problems in the runtime. Emits threadprivate\n  /// variables to store the size of the VLAs/array sections for\n  /// initializer/combiner/finalizer functions.\n  /// \\param RCG Allows to reuse an existing data for the reductions.\n  /// \\param N Reduction item for which fixups must be emitted.\n  virtual void emitTaskReductionFixups(CodeGenFunction &CGF, SourceLocation Loc,\n                                       ReductionCodeGen &RCG, unsigned N);\n\n  /// Get the address of `void *` type of the privatue copy of the reduction\n  /// item specified by the \\p SharedLVal.\n  /// \\param ReductionsPtr Pointer to the reduction data returned by the\n  /// emitTaskReductionInit function.\n  /// \\param SharedLVal Address of the original reduction item.\n  virtual Address getTaskReductionItem(CodeGenFunction &CGF, SourceLocation Loc,\n                                       llvm::Value *ReductionsPtr,\n                                       LValue SharedLVal);\n\n  /// Emit code for 'taskwait' directive.\n  virtual void emitTaskwaitCall(CodeGenFunction &CGF, SourceLocation Loc);\n\n  /// Emit code for 'cancellation point' construct.\n  /// \\param CancelRegion Region kind for which the cancellation point must be\n  /// emitted.\n  ///\n  virtual void emitCancellationPointCall(CodeGenFunction &CGF,\n                                         SourceLocation Loc,\n                                         OpenMPDirectiveKind CancelRegion);\n\n  /// Emit code for 'cancel' construct.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  /// \\param CancelRegion Region kind for which the cancel must be emitted.\n  ///\n  virtual void emitCancelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                              const Expr *IfCond,\n                              OpenMPDirectiveKind CancelRegion);\n\n  /// Emit outilined function for 'target' directive.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  virtual void emitTargetOutlinedFunction(const OMPExecutableDirective &D,\n                                          StringRef ParentName,\n                                          llvm::Function *&OutlinedFn,\n                                          llvm::Constant *&OutlinedFnID,\n                                          bool IsOffloadEntry,\n                                          const RegionCodeGenTy &CodeGen);\n\n  /// Emit the target offloading code associated with \\a D. The emitted\n  /// code attempts offloading the execution to the device, an the event of\n  /// a failure it executes the host version outlined in \\a OutlinedFn.\n  /// \\param D Directive to emit.\n  /// \\param OutlinedFn Host version of the code to be offloaded.\n  /// \\param OutlinedFnID ID of host version of the code to be offloaded.\n  /// \\param IfCond Expression evaluated in if clause associated with the target\n  /// directive, or null if no if clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used and device modifier.\n  /// \\param SizeEmitter Callback to emit number of iterations for loop-based\n  /// directives.\n  virtual void emitTargetCall(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D,\n      llvm::Function *OutlinedFn, llvm::Value *OutlinedFnID, const Expr *IfCond,\n      llvm::PointerIntPair<const Expr *, 2, OpenMPDeviceClauseModifier> Device,\n      llvm::function_ref<llvm::Value *(CodeGenFunction &CGF,\n                                       const OMPLoopDirective &D)>\n          SizeEmitter);\n\n  /// Emit the target regions enclosed in \\a GD function definition or\n  /// the function itself in case it is a valid device function. Returns true if\n  /// \\a GD was dealt with successfully.\n  /// \\param GD Function to scan.\n  virtual bool emitTargetFunctions(GlobalDecl GD);\n\n  /// Emit the global variable if it is a valid device global variable.\n  /// Returns true if \\a GD was dealt with successfully.\n  /// \\param GD Variable declaration to emit.\n  virtual bool emitTargetGlobalVariable(GlobalDecl GD);\n\n  /// Checks if the provided global decl \\a GD is a declare target variable and\n  /// registers it when emitting code for the host.\n  virtual void registerTargetGlobalVariable(const VarDecl *VD,\n                                            llvm::Constant *Addr);\n\n  /// Registers provided target firstprivate variable as global on the\n  /// target.\n  llvm::Constant *registerTargetFirstprivateCopy(CodeGenFunction &CGF,\n                                                 const VarDecl *VD);\n\n  /// Emit the global \\a GD if it is meaningful for the target. Returns\n  /// if it was emitted successfully.\n  /// \\param GD Global to scan.\n  virtual bool emitTargetGlobal(GlobalDecl GD);\n\n  /// Creates and returns a registration function for when at least one\n  /// requires directives was used in the current module.\n  llvm::Function *emitRequiresDirectiveRegFun();\n\n  /// Creates all the offload entries in the current compilation unit\n  /// along with the associated metadata.\n  void createOffloadEntriesAndInfoMetadata();\n\n  /// Emits code for teams call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run by team masters. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  ///\n  virtual void emitTeamsCall(CodeGenFunction &CGF,\n                             const OMPExecutableDirective &D,\n                             SourceLocation Loc, llvm::Function *OutlinedFn,\n                             ArrayRef<llvm::Value *> CapturedVars);\n\n  /// Emits call to void __kmpc_push_num_teams(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_teams, kmp_int32 thread_limit) to generate code\n  /// for num_teams clause.\n  /// \\param NumTeams An integer expression of teams.\n  /// \\param ThreadLimit An integer expression of threads.\n  virtual void emitNumTeamsClause(CodeGenFunction &CGF, const Expr *NumTeams,\n                                  const Expr *ThreadLimit, SourceLocation Loc);\n\n  /// Struct that keeps all the relevant information that should be kept\n  /// throughout a 'target data' region.\n  class TargetDataInfo {\n    /// Set to true if device pointer information have to be obtained.\n    bool RequiresDevicePointerInfo = false;\n    /// Set to true if Clang emits separate runtime calls for the beginning and\n    /// end of the region.  These calls might have separate map type arrays.\n    bool SeparateBeginEndCalls = false;\n\n  public:\n    /// The array of base pointer passed to the runtime library.\n    llvm::Value *BasePointersArray = nullptr;\n    /// The array of section pointers passed to the runtime library.\n    llvm::Value *PointersArray = nullptr;\n    /// The array of sizes passed to the runtime library.\n    llvm::Value *SizesArray = nullptr;\n    /// The array of map types passed to the runtime library for the beginning\n    /// of the region or for the entire region if there are no separate map\n    /// types for the region end.\n    llvm::Value *MapTypesArray = nullptr;\n    /// The array of map types passed to the runtime library for the end of the\n    /// region, or nullptr if there are no separate map types for the region\n    /// end.\n    llvm::Value *MapTypesArrayEnd = nullptr;\n    /// The array of user-defined mappers passed to the runtime library.\n    llvm::Value *MappersArray = nullptr;\n    /// The array of original declaration names of mapped pointers sent to the\n    /// runtime library for debugging\n    llvm::Value *MapNamesArray = nullptr;\n    /// Indicate whether any user-defined mapper exists.\n    bool HasMapper = false;\n    /// The total number of pointers passed to the runtime library.\n    unsigned NumberOfPtrs = 0u;\n    /// Map between the a declaration of a capture and the corresponding base\n    /// pointer address where the runtime returns the device pointers.\n    llvm::DenseMap<const ValueDecl *, Address> CaptureDeviceAddrMap;\n\n    explicit TargetDataInfo() {}\n    explicit TargetDataInfo(bool RequiresDevicePointerInfo,\n                            bool SeparateBeginEndCalls)\n        : RequiresDevicePointerInfo(RequiresDevicePointerInfo),\n          SeparateBeginEndCalls(SeparateBeginEndCalls) {}\n    /// Clear information about the data arrays.\n    void clearArrayInfo() {\n      BasePointersArray = nullptr;\n      PointersArray = nullptr;\n      SizesArray = nullptr;\n      MapTypesArray = nullptr;\n      MapTypesArrayEnd = nullptr;\n      MapNamesArray = nullptr;\n      MappersArray = nullptr;\n      HasMapper = false;\n      NumberOfPtrs = 0u;\n    }\n    /// Return true if the current target data information has valid arrays.\n    bool isValid() {\n      return BasePointersArray && PointersArray && SizesArray &&\n             MapTypesArray && (!HasMapper || MappersArray) && NumberOfPtrs;\n    }\n    bool requiresDevicePointerInfo() { return RequiresDevicePointerInfo; }\n    bool separateBeginEndCalls() { return SeparateBeginEndCalls; }\n  };\n\n  /// Emit the target data mapping code associated with \\a D.\n  /// \\param D Directive to emit.\n  /// \\param IfCond Expression evaluated in if clause associated with the\n  /// target directive, or null if no device clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used.\n  /// \\param Info A record used to store information that needs to be preserved\n  /// until the region is closed.\n  virtual void emitTargetDataCalls(CodeGenFunction &CGF,\n                                   const OMPExecutableDirective &D,\n                                   const Expr *IfCond, const Expr *Device,\n                                   const RegionCodeGenTy &CodeGen,\n                                   TargetDataInfo &Info);\n\n  /// Emit the data mapping/movement code associated with the directive\n  /// \\a D that should be of the form 'target [{enter|exit} data | update]'.\n  /// \\param D Directive to emit.\n  /// \\param IfCond Expression evaluated in if clause associated with the target\n  /// directive, or null if no if clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used.\n  virtual void emitTargetDataStandAloneCall(CodeGenFunction &CGF,\n                                            const OMPExecutableDirective &D,\n                                            const Expr *IfCond,\n                                            const Expr *Device);\n\n  /// Marks function \\a Fn with properly mangled versions of vector functions.\n  /// \\param FD Function marked as 'declare simd'.\n  /// \\param Fn LLVM function that must be marked with 'declare simd'\n  /// attributes.\n  virtual void emitDeclareSimdFunction(const FunctionDecl *FD,\n                                       llvm::Function *Fn);\n\n  /// Emit initialization for doacross loop nesting support.\n  /// \\param D Loop-based construct used in doacross nesting construct.\n  virtual void emitDoacrossInit(CodeGenFunction &CGF, const OMPLoopDirective &D,\n                                ArrayRef<Expr *> NumIterations);\n\n  /// Emit code for doacross ordered directive with 'depend' clause.\n  /// \\param C 'depend' clause with 'sink|source' dependency kind.\n  virtual void emitDoacrossOrdered(CodeGenFunction &CGF,\n                                   const OMPDependClause *C);\n\n  /// Translates the native parameter of outlined function if this is required\n  /// for target.\n  /// \\param FD Field decl from captured record for the parameter.\n  /// \\param NativeParam Parameter itself.\n  virtual const VarDecl *translateParameter(const FieldDecl *FD,\n                                            const VarDecl *NativeParam) const {\n    return NativeParam;\n  }\n\n  /// Gets the address of the native argument basing on the address of the\n  /// target-specific parameter.\n  /// \\param NativeParam Parameter itself.\n  /// \\param TargetParam Corresponding target-specific parameter.\n  virtual Address getParameterAddress(CodeGenFunction &CGF,\n                                      const VarDecl *NativeParam,\n                                      const VarDecl *TargetParam) const;\n\n  /// Choose default schedule type and chunk value for the\n  /// dist_schedule clause.\n  virtual void getDefaultDistScheduleAndChunk(CodeGenFunction &CGF,\n      const OMPLoopDirective &S, OpenMPDistScheduleClauseKind &ScheduleKind,\n      llvm::Value *&Chunk) const {}\n\n  /// Choose default schedule type and chunk value for the\n  /// schedule clause.\n  virtual void getDefaultScheduleAndChunk(CodeGenFunction &CGF,\n      const OMPLoopDirective &S, OpenMPScheduleClauseKind &ScheduleKind,\n      const Expr *&ChunkExpr) const;\n\n  /// Emits call of the outlined function with the provided arguments,\n  /// translating these arguments to correct target-specific arguments.\n  virtual void\n  emitOutlinedFunctionCall(CodeGenFunction &CGF, SourceLocation Loc,\n                           llvm::FunctionCallee OutlinedFn,\n                           ArrayRef<llvm::Value *> Args = llvm::None) const;\n\n  /// Emits OpenMP-specific function prolog.\n  /// Required for device constructs.\n  virtual void emitFunctionProlog(CodeGenFunction &CGF, const Decl *D);\n\n  /// Gets the OpenMP-specific address of the local variable.\n  virtual Address getAddressOfLocalVariable(CodeGenFunction &CGF,\n                                            const VarDecl *VD);\n\n  /// Marks the declaration as already emitted for the device code and returns\n  /// true, if it was marked already, and false, otherwise.\n  bool markAsGlobalTarget(GlobalDecl GD);\n\n  /// Emit deferred declare target variables marked for deferred emission.\n  void emitDeferredTargetDecls() const;\n\n  /// Adjust some parameters for the target-based directives, like addresses of\n  /// the variables captured by reference in lambdas.\n  virtual void\n  adjustTargetSpecificDataForLambdas(CodeGenFunction &CGF,\n                                     const OMPExecutableDirective &D) const;\n\n  /// Perform check on requires decl to ensure that target architecture\n  /// supports unified addressing\n  virtual void processRequiresDirective(const OMPRequiresDecl *D);\n\n  /// Gets default memory ordering as specified in requires directive.\n  llvm::AtomicOrdering getDefaultMemoryOrdering() const;\n\n  /// Checks if the variable has associated OMPAllocateDeclAttr attribute with\n  /// the predefined allocator and translates it into the corresponding address\n  /// space.\n  virtual bool hasAllocateAttributeForGlobalVar(const VarDecl *VD, LangAS &AS);\n\n  /// Return whether the unified_shared_memory has been specified.\n  bool hasRequiresUnifiedSharedMemory() const;\n\n  /// Checks if the \\p VD variable is marked as nontemporal declaration in\n  /// current context.\n  bool isNontemporalDecl(const ValueDecl *VD) const;\n\n  /// Create specialized alloca to handle lastprivate conditionals.\n  Address emitLastprivateConditionalInit(CodeGenFunction &CGF,\n                                         const VarDecl *VD);\n\n  /// Checks if the provided \\p LVal is lastprivate conditional and emits the\n  /// code to update the value of the original variable.\n  /// \\code\n  /// lastprivate(conditional: a)\n  /// ...\n  /// <type> a;\n  /// lp_a = ...;\n  /// #pragma omp critical(a)\n  /// if (last_iv_a <= iv) {\n  ///   last_iv_a = iv;\n  ///   global_a = lp_a;\n  /// }\n  /// \\endcode\n  virtual void checkAndEmitLastprivateConditional(CodeGenFunction &CGF,\n                                                  const Expr *LHS);\n\n  /// Checks if the lastprivate conditional was updated in inner region and\n  /// writes the value.\n  /// \\code\n  /// lastprivate(conditional: a)\n  /// ...\n  /// <type> a;bool Fired = false;\n  /// #pragma omp ... shared(a)\n  /// {\n  ///   lp_a = ...;\n  ///   Fired = true;\n  /// }\n  /// if (Fired) {\n  ///   #pragma omp critical(a)\n  ///   if (last_iv_a <= iv) {\n  ///     last_iv_a = iv;\n  ///     global_a = lp_a;\n  ///   }\n  ///   Fired = false;\n  /// }\n  /// \\endcode\n  virtual void checkAndEmitSharedLastprivateConditional(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D,\n      const llvm::DenseSet<CanonicalDeclPtr<const VarDecl>> &IgnoredDecls);\n\n  /// Gets the address of the global copy used for lastprivate conditional\n  /// update, if any.\n  /// \\param PrivLVal LValue for the private copy.\n  /// \\param VD Original lastprivate declaration.\n  virtual void emitLastprivateConditionalFinalUpdate(CodeGenFunction &CGF,\n                                                     LValue PrivLVal,\n                                                     const VarDecl *VD,\n                                                     SourceLocation Loc);\n\n  /// Emits list of dependecies based on the provided data (array of\n  /// dependence/expression pairs).\n  /// \\returns Pointer to the first element of the array casted to VoidPtr type.\n  std::pair<llvm::Value *, Address>\n  emitDependClause(CodeGenFunction &CGF,\n                   ArrayRef<OMPTaskDataTy::DependData> Dependencies,\n                   SourceLocation Loc);\n\n  /// Emits list of dependecies based on the provided data (array of\n  /// dependence/expression pairs) for depobj construct. In this case, the\n  /// variable is allocated in dynamically. \\returns Pointer to the first\n  /// element of the array casted to VoidPtr type.\n  Address emitDepobjDependClause(CodeGenFunction &CGF,\n                                 const OMPTaskDataTy::DependData &Dependencies,\n                                 SourceLocation Loc);\n\n  /// Emits the code to destroy the dependency object provided in depobj\n  /// directive.\n  void emitDestroyClause(CodeGenFunction &CGF, LValue DepobjLVal,\n                         SourceLocation Loc);\n\n  /// Updates the dependency kind in the specified depobj object.\n  /// \\param DepobjLVal LValue for the main depobj object.\n  /// \\param NewDepKind New dependency kind.\n  void emitUpdateClause(CodeGenFunction &CGF, LValue DepobjLVal,\n                        OpenMPDependClauseKind NewDepKind, SourceLocation Loc);\n\n  /// Initializes user defined allocators specified in the uses_allocators\n  /// clauses.\n  void emitUsesAllocatorsInit(CodeGenFunction &CGF, const Expr *Allocator,\n                              const Expr *AllocatorTraits);\n\n  /// Destroys user defined allocators specified in the uses_allocators clause.\n  void emitUsesAllocatorsFini(CodeGenFunction &CGF, const Expr *Allocator);\n\n  /// Returns true if the variable is a local variable in untied task.\n  bool isLocalVarInUntiedTask(CodeGenFunction &CGF, const VarDecl *VD) const;\n};\n\n/// Class supports emissionof SIMD-only code.\nclass CGOpenMPSIMDRuntime final : public CGOpenMPRuntime {\npublic:\n  explicit CGOpenMPSIMDRuntime(CodeGenModule &CGM) : CGOpenMPRuntime(CGM) {}\n  ~CGOpenMPSIMDRuntime() override {}\n\n  /// Emits outlined function for the specified OpenMP parallel directive\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  llvm::Function *\n  emitParallelOutlinedFunction(const OMPExecutableDirective &D,\n                               const VarDecl *ThreadIDVar,\n                               OpenMPDirectiveKind InnermostKind,\n                               const RegionCodeGenTy &CodeGen) override;\n\n  /// Emits outlined function for the specified OpenMP teams directive\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  llvm::Function *\n  emitTeamsOutlinedFunction(const OMPExecutableDirective &D,\n                            const VarDecl *ThreadIDVar,\n                            OpenMPDirectiveKind InnermostKind,\n                            const RegionCodeGenTy &CodeGen) override;\n\n  /// Emits outlined function for the OpenMP task directive \\a D. This\n  /// outlined function has type void(*)(kmp_int32 ThreadID, struct task_t*\n  /// TaskT).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param PartIDVar Variable for partition id in the current OpenMP untied\n  /// task region.\n  /// \\param TaskTVar Variable for task_t argument.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// \\param Tied true if task is generated for tied task, false otherwise.\n  /// \\param NumberOfParts Number of parts in untied task. Ignored for tied\n  /// tasks.\n  ///\n  llvm::Function *emitTaskOutlinedFunction(\n      const OMPExecutableDirective &D, const VarDecl *ThreadIDVar,\n      const VarDecl *PartIDVar, const VarDecl *TaskTVar,\n      OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen,\n      bool Tied, unsigned &NumberOfParts) override;\n\n  /// Emits code for parallel or serial call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run in parallel threads. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  ///\n  void emitParallelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                        llvm::Function *OutlinedFn,\n                        ArrayRef<llvm::Value *> CapturedVars,\n                        const Expr *IfCond) override;\n\n  /// Emits a critical region.\n  /// \\param CriticalName Name of the critical region.\n  /// \\param CriticalOpGen Generator for the statement associated with the given\n  /// critical region.\n  /// \\param Hint Value of the 'hint' clause (optional).\n  void emitCriticalRegion(CodeGenFunction &CGF, StringRef CriticalName,\n                          const RegionCodeGenTy &CriticalOpGen,\n                          SourceLocation Loc,\n                          const Expr *Hint = nullptr) override;\n\n  /// Emits a master region.\n  /// \\param MasterOpGen Generator for the statement associated with the given\n  /// master region.\n  void emitMasterRegion(CodeGenFunction &CGF,\n                        const RegionCodeGenTy &MasterOpGen,\n                        SourceLocation Loc) override;\n\n  /// Emits code for a taskyield directive.\n  void emitTaskyieldCall(CodeGenFunction &CGF, SourceLocation Loc) override;\n\n  /// Emit a taskgroup region.\n  /// \\param TaskgroupOpGen Generator for the statement associated with the\n  /// given taskgroup region.\n  void emitTaskgroupRegion(CodeGenFunction &CGF,\n                           const RegionCodeGenTy &TaskgroupOpGen,\n                           SourceLocation Loc) override;\n\n  /// Emits a single region.\n  /// \\param SingleOpGen Generator for the statement associated with the given\n  /// single region.\n  void emitSingleRegion(CodeGenFunction &CGF,\n                        const RegionCodeGenTy &SingleOpGen, SourceLocation Loc,\n                        ArrayRef<const Expr *> CopyprivateVars,\n                        ArrayRef<const Expr *> DestExprs,\n                        ArrayRef<const Expr *> SrcExprs,\n                        ArrayRef<const Expr *> AssignmentOps) override;\n\n  /// Emit an ordered region.\n  /// \\param OrderedOpGen Generator for the statement associated with the given\n  /// ordered region.\n  void emitOrderedRegion(CodeGenFunction &CGF,\n                         const RegionCodeGenTy &OrderedOpGen,\n                         SourceLocation Loc, bool IsThreads) override;\n\n  /// Emit an implicit/explicit barrier for OpenMP threads.\n  /// \\param Kind Directive for which this implicit barrier call must be\n  /// generated. Must be OMPD_barrier for explicit barrier generation.\n  /// \\param EmitChecks true if need to emit checks for cancellation barriers.\n  /// \\param ForceSimpleCall true simple barrier call must be emitted, false if\n  /// runtime class decides which one to emit (simple or with cancellation\n  /// checks).\n  ///\n  void emitBarrierCall(CodeGenFunction &CGF, SourceLocation Loc,\n                       OpenMPDirectiveKind Kind, bool EmitChecks = true,\n                       bool ForceSimpleCall = false) override;\n\n  /// This is used for non static scheduled types and when the ordered\n  /// clause is present on the loop construct.\n  /// Depending on the loop schedule, it is necessary to call some runtime\n  /// routine before start of the OpenMP loop to get the loop upper / lower\n  /// bounds \\a LB and \\a UB and stride \\a ST.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param ScheduleKind Schedule kind, specified by the 'schedule' clause.\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  /// \\param Ordered true if loop is ordered, false otherwise.\n  /// \\param DispatchValues struct containing llvm values for lower bound, upper\n  /// bound, and chunk expression.\n  /// For the default (nullptr) value, the chunk 1 will be used.\n  ///\n  void emitForDispatchInit(CodeGenFunction &CGF, SourceLocation Loc,\n                           const OpenMPScheduleTy &ScheduleKind,\n                           unsigned IVSize, bool IVSigned, bool Ordered,\n                           const DispatchRTInput &DispatchValues) override;\n\n  /// Call the appropriate runtime routine to initialize it before start\n  /// of loop.\n  ///\n  /// This is used only in case of static schedule, when the user did not\n  /// specify a ordered clause on the loop construct.\n  /// Depending on the loop schedule, it is necessary to call some runtime\n  /// routine before start of the OpenMP loop to get the loop upper / lower\n  /// bounds LB and UB and stride ST.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param DKind Kind of the directive.\n  /// \\param ScheduleKind Schedule kind, specified by the 'schedule' clause.\n  /// \\param Values Input arguments for the construct.\n  ///\n  void emitForStaticInit(CodeGenFunction &CGF, SourceLocation Loc,\n                         OpenMPDirectiveKind DKind,\n                         const OpenMPScheduleTy &ScheduleKind,\n                         const StaticRTInput &Values) override;\n\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param SchedKind Schedule kind, specified by the 'dist_schedule' clause.\n  /// \\param Values Input arguments for the construct.\n  ///\n  void emitDistributeStaticInit(CodeGenFunction &CGF, SourceLocation Loc,\n                                OpenMPDistScheduleClauseKind SchedKind,\n                                const StaticRTInput &Values) override;\n\n  /// Call the appropriate runtime routine to notify that we finished\n  /// iteration of the ordered loop with the dynamic scheduling.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  ///\n  void emitForOrderedIterationEnd(CodeGenFunction &CGF, SourceLocation Loc,\n                                  unsigned IVSize, bool IVSigned) override;\n\n  /// Call the appropriate runtime routine to notify that we finished\n  /// all the work with current loop.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param DKind Kind of the directive for which the static finish is emitted.\n  ///\n  void emitForStaticFinish(CodeGenFunction &CGF, SourceLocation Loc,\n                           OpenMPDirectiveKind DKind) override;\n\n  /// Call __kmpc_dispatch_next(\n  ///          ident_t *loc, kmp_int32 tid, kmp_int32 *p_lastiter,\n  ///          kmp_int[32|64] *p_lower, kmp_int[32|64] *p_upper,\n  ///          kmp_int[32|64] *p_stride);\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  /// \\param IL Address of the output variable in which the flag of the\n  /// last iteration is returned.\n  /// \\param LB Address of the output variable in which the lower iteration\n  /// number is returned.\n  /// \\param UB Address of the output variable in which the upper iteration\n  /// number is returned.\n  /// \\param ST Address of the output variable in which the stride value is\n  /// returned.\n  llvm::Value *emitForNext(CodeGenFunction &CGF, SourceLocation Loc,\n                           unsigned IVSize, bool IVSigned, Address IL,\n                           Address LB, Address UB, Address ST) override;\n\n  /// Emits call to void __kmpc_push_num_threads(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_threads) to generate code for 'num_threads'\n  /// clause.\n  /// \\param NumThreads An integer value of threads.\n  void emitNumThreadsClause(CodeGenFunction &CGF, llvm::Value *NumThreads,\n                            SourceLocation Loc) override;\n\n  /// Emit call to void __kmpc_push_proc_bind(ident_t *loc, kmp_int32\n  /// global_tid, int proc_bind) to generate code for 'proc_bind' clause.\n  void emitProcBindClause(CodeGenFunction &CGF,\n                          llvm::omp::ProcBindKind ProcBind,\n                          SourceLocation Loc) override;\n\n  /// Returns address of the threadprivate variable for the current\n  /// thread.\n  /// \\param VD Threadprivate variable.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Loc Location of the reference to threadprivate var.\n  /// \\return Address of the threadprivate variable for the current thread.\n  Address getAddrOfThreadPrivate(CodeGenFunction &CGF, const VarDecl *VD,\n                                 Address VDAddr, SourceLocation Loc) override;\n\n  /// Emit a code for initialization of threadprivate variable. It emits\n  /// a call to runtime library which adds initial value to the newly created\n  /// threadprivate variable (if it is not constant) and registers destructor\n  /// for the variable (if any).\n  /// \\param VD Threadprivate variable.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Loc Location of threadprivate declaration.\n  /// \\param PerformInit true if initialization expression is not constant.\n  llvm::Function *\n  emitThreadPrivateVarDefinition(const VarDecl *VD, Address VDAddr,\n                                 SourceLocation Loc, bool PerformInit,\n                                 CodeGenFunction *CGF = nullptr) override;\n\n  /// Creates artificial threadprivate variable with name \\p Name and type \\p\n  /// VarType.\n  /// \\param VarType Type of the artificial threadprivate variable.\n  /// \\param Name Name of the artificial threadprivate variable.\n  Address getAddrOfArtificialThreadPrivate(CodeGenFunction &CGF,\n                                           QualType VarType,\n                                           StringRef Name) override;\n\n  /// Emit flush of the variables specified in 'omp flush' directive.\n  /// \\param Vars List of variables to flush.\n  void emitFlush(CodeGenFunction &CGF, ArrayRef<const Expr *> Vars,\n                 SourceLocation Loc, llvm::AtomicOrdering AO) override;\n\n  /// Emit task region for the task directive. The task region is\n  /// emitted in several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// 4. Emit a call to kmp_int32 __kmpc_omp_task(ident_t *, kmp_int32 gtid,\n  /// kmp_task_t *new_task), where new_task is a resulting structure from\n  /// previous items.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param IfCond Not a nullptr if 'if' clause was specified, nullptr\n  /// otherwise.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  void emitTaskCall(CodeGenFunction &CGF, SourceLocation Loc,\n                    const OMPExecutableDirective &D,\n                    llvm::Function *TaskFunction, QualType SharedsTy,\n                    Address Shareds, const Expr *IfCond,\n                    const OMPTaskDataTy &Data) override;\n\n  /// Emit task region for the taskloop directive. The taskloop region is\n  /// emitted in several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// 4. Emit a call to void __kmpc_taskloop(ident_t *loc, int gtid, kmp_task_t\n  /// *task, int if_val, kmp_uint64 *lb, kmp_uint64 *ub, kmp_int64 st, int\n  /// nogroup, int sched, kmp_uint64 grainsize, void *task_dup ), where new_task\n  /// is a resulting structure from\n  /// previous items.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param IfCond Not a nullptr if 'if' clause was specified, nullptr\n  /// otherwise.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  void emitTaskLoopCall(CodeGenFunction &CGF, SourceLocation Loc,\n                        const OMPLoopDirective &D, llvm::Function *TaskFunction,\n                        QualType SharedsTy, Address Shareds, const Expr *IfCond,\n                        const OMPTaskDataTy &Data) override;\n\n  /// Emit a code for reduction clause. Next code should be emitted for\n  /// reduction:\n  /// \\code\n  ///\n  /// static kmp_critical_name lock = { 0 };\n  ///\n  /// void reduce_func(void *lhs[<n>], void *rhs[<n>]) {\n  ///  ...\n  ///  *(Type<i>*)lhs[i] = RedOp<i>(*(Type<i>*)lhs[i], *(Type<i>*)rhs[i]);\n  ///  ...\n  /// }\n  ///\n  /// ...\n  /// void *RedList[<n>] = {&<RHSExprs>[0], ..., &<RHSExprs>[<n>-1]};\n  /// switch (__kmpc_reduce{_nowait}(<loc>, <gtid>, <n>, sizeof(RedList),\n  /// RedList, reduce_func, &<lock>)) {\n  /// case 1:\n  ///  ...\n  ///  <LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]);\n  ///  ...\n  /// __kmpc_end_reduce{_nowait}(<loc>, <gtid>, &<lock>);\n  /// break;\n  /// case 2:\n  ///  ...\n  ///  Atomic(<LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]));\n  ///  ...\n  /// break;\n  /// default:;\n  /// }\n  /// \\endcode\n  ///\n  /// \\param Privates List of private copies for original reduction arguments.\n  /// \\param LHSExprs List of LHS in \\a ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a ReductionOps reduction operations.\n  /// \\param ReductionOps List of reduction operations in form 'LHS binop RHS'\n  /// or 'operator binop(LHS, RHS)'.\n  /// \\param Options List of options for reduction codegen:\n  ///     WithNowait true if parent directive has also nowait clause, false\n  ///     otherwise.\n  ///     SimpleReduction Emit reduction operation only. Used for omp simd\n  ///     directive on the host.\n  ///     ReductionKind The kind of reduction to perform.\n  void emitReduction(CodeGenFunction &CGF, SourceLocation Loc,\n                     ArrayRef<const Expr *> Privates,\n                     ArrayRef<const Expr *> LHSExprs,\n                     ArrayRef<const Expr *> RHSExprs,\n                     ArrayRef<const Expr *> ReductionOps,\n                     ReductionOptionsTy Options) override;\n\n  /// Emit a code for initialization of task reduction clause. Next code\n  /// should be emitted for reduction:\n  /// \\code\n  ///\n  /// _taskred_item_t red_data[n];\n  /// ...\n  /// red_data[i].shar = &shareds[i];\n  /// red_data[i].orig = &origs[i];\n  /// red_data[i].size = sizeof(origs[i]);\n  /// red_data[i].f_init = (void*)RedInit<i>;\n  /// red_data[i].f_fini = (void*)RedDest<i>;\n  /// red_data[i].f_comb = (void*)RedOp<i>;\n  /// red_data[i].flags = <Flag_i>;\n  /// ...\n  /// void* tg1 = __kmpc_taskred_init(gtid, n, red_data);\n  /// \\endcode\n  /// For reduction clause with task modifier it emits the next call:\n  /// \\code\n  ///\n  /// _taskred_item_t red_data[n];\n  /// ...\n  /// red_data[i].shar = &shareds[i];\n  /// red_data[i].orig = &origs[i];\n  /// red_data[i].size = sizeof(origs[i]);\n  /// red_data[i].f_init = (void*)RedInit<i>;\n  /// red_data[i].f_fini = (void*)RedDest<i>;\n  /// red_data[i].f_comb = (void*)RedOp<i>;\n  /// red_data[i].flags = <Flag_i>;\n  /// ...\n  /// void* tg1 = __kmpc_taskred_modifier_init(loc, gtid, is_worksharing, n,\n  /// red_data);\n  /// \\endcode\n  /// \\param LHSExprs List of LHS in \\a Data.ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a Data.ReductionOps reduction operations.\n  /// \\param Data Additional data for task generation like tiedness, final\n  /// state, list of privates, reductions etc.\n  llvm::Value *emitTaskReductionInit(CodeGenFunction &CGF, SourceLocation Loc,\n                                     ArrayRef<const Expr *> LHSExprs,\n                                     ArrayRef<const Expr *> RHSExprs,\n                                     const OMPTaskDataTy &Data) override;\n\n  /// Emits the following code for reduction clause with task modifier:\n  /// \\code\n  /// __kmpc_task_reduction_modifier_fini(loc, gtid, is_worksharing);\n  /// \\endcode\n  void emitTaskReductionFini(CodeGenFunction &CGF, SourceLocation Loc,\n                             bool IsWorksharingReduction) override;\n\n  /// Required to resolve existing problems in the runtime. Emits threadprivate\n  /// variables to store the size of the VLAs/array sections for\n  /// initializer/combiner/finalizer functions + emits threadprivate variable to\n  /// store the pointer to the original reduction item for the custom\n  /// initializer defined by declare reduction construct.\n  /// \\param RCG Allows to reuse an existing data for the reductions.\n  /// \\param N Reduction item for which fixups must be emitted.\n  void emitTaskReductionFixups(CodeGenFunction &CGF, SourceLocation Loc,\n                               ReductionCodeGen &RCG, unsigned N) override;\n\n  /// Get the address of `void *` type of the privatue copy of the reduction\n  /// item specified by the \\p SharedLVal.\n  /// \\param ReductionsPtr Pointer to the reduction data returned by the\n  /// emitTaskReductionInit function.\n  /// \\param SharedLVal Address of the original reduction item.\n  Address getTaskReductionItem(CodeGenFunction &CGF, SourceLocation Loc,\n                               llvm::Value *ReductionsPtr,\n                               LValue SharedLVal) override;\n\n  /// Emit code for 'taskwait' directive.\n  void emitTaskwaitCall(CodeGenFunction &CGF, SourceLocation Loc) override;\n\n  /// Emit code for 'cancellation point' construct.\n  /// \\param CancelRegion Region kind for which the cancellation point must be\n  /// emitted.\n  ///\n  void emitCancellationPointCall(CodeGenFunction &CGF, SourceLocation Loc,\n                                 OpenMPDirectiveKind CancelRegion) override;\n\n  /// Emit code for 'cancel' construct.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  /// \\param CancelRegion Region kind for which the cancel must be emitted.\n  ///\n  void emitCancelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                      const Expr *IfCond,\n                      OpenMPDirectiveKind CancelRegion) override;\n\n  /// Emit outilined function for 'target' directive.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  void emitTargetOutlinedFunction(const OMPExecutableDirective &D,\n                                  StringRef ParentName,\n                                  llvm::Function *&OutlinedFn,\n                                  llvm::Constant *&OutlinedFnID,\n                                  bool IsOffloadEntry,\n                                  const RegionCodeGenTy &CodeGen) override;\n\n  /// Emit the target offloading code associated with \\a D. The emitted\n  /// code attempts offloading the execution to the device, an the event of\n  /// a failure it executes the host version outlined in \\a OutlinedFn.\n  /// \\param D Directive to emit.\n  /// \\param OutlinedFn Host version of the code to be offloaded.\n  /// \\param OutlinedFnID ID of host version of the code to be offloaded.\n  /// \\param IfCond Expression evaluated in if clause associated with the target\n  /// directive, or null if no if clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used and device modifier.\n  void emitTargetCall(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D,\n      llvm::Function *OutlinedFn, llvm::Value *OutlinedFnID, const Expr *IfCond,\n      llvm::PointerIntPair<const Expr *, 2, OpenMPDeviceClauseModifier> Device,\n      llvm::function_ref<llvm::Value *(CodeGenFunction &CGF,\n                                       const OMPLoopDirective &D)>\n          SizeEmitter) override;\n\n  /// Emit the target regions enclosed in \\a GD function definition or\n  /// the function itself in case it is a valid device function. Returns true if\n  /// \\a GD was dealt with successfully.\n  /// \\param GD Function to scan.\n  bool emitTargetFunctions(GlobalDecl GD) override;\n\n  /// Emit the global variable if it is a valid device global variable.\n  /// Returns true if \\a GD was dealt with successfully.\n  /// \\param GD Variable declaration to emit.\n  bool emitTargetGlobalVariable(GlobalDecl GD) override;\n\n  /// Emit the global \\a GD if it is meaningful for the target. Returns\n  /// if it was emitted successfully.\n  /// \\param GD Global to scan.\n  bool emitTargetGlobal(GlobalDecl GD) override;\n\n  /// Emits code for teams call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run by team masters. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  ///\n  void emitTeamsCall(CodeGenFunction &CGF, const OMPExecutableDirective &D,\n                     SourceLocation Loc, llvm::Function *OutlinedFn,\n                     ArrayRef<llvm::Value *> CapturedVars) override;\n\n  /// Emits call to void __kmpc_push_num_teams(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_teams, kmp_int32 thread_limit) to generate code\n  /// for num_teams clause.\n  /// \\param NumTeams An integer expression of teams.\n  /// \\param ThreadLimit An integer expression of threads.\n  void emitNumTeamsClause(CodeGenFunction &CGF, const Expr *NumTeams,\n                          const Expr *ThreadLimit, SourceLocation Loc) override;\n\n  /// Emit the target data mapping code associated with \\a D.\n  /// \\param D Directive to emit.\n  /// \\param IfCond Expression evaluated in if clause associated with the\n  /// target directive, or null if no device clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used.\n  /// \\param Info A record used to store information that needs to be preserved\n  /// until the region is closed.\n  void emitTargetDataCalls(CodeGenFunction &CGF,\n                           const OMPExecutableDirective &D, const Expr *IfCond,\n                           const Expr *Device, const RegionCodeGenTy &CodeGen,\n                           TargetDataInfo &Info) override;\n\n  /// Emit the data mapping/movement code associated with the directive\n  /// \\a D that should be of the form 'target [{enter|exit} data | update]'.\n  /// \\param D Directive to emit.\n  /// \\param IfCond Expression evaluated in if clause associated with the target\n  /// directive, or null if no if clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used.\n  void emitTargetDataStandAloneCall(CodeGenFunction &CGF,\n                                    const OMPExecutableDirective &D,\n                                    const Expr *IfCond,\n                                    const Expr *Device) override;\n\n  /// Emit initialization for doacross loop nesting support.\n  /// \\param D Loop-based construct used in doacross nesting construct.\n  void emitDoacrossInit(CodeGenFunction &CGF, const OMPLoopDirective &D,\n                        ArrayRef<Expr *> NumIterations) override;\n\n  /// Emit code for doacross ordered directive with 'depend' clause.\n  /// \\param C 'depend' clause with 'sink|source' dependency kind.\n  void emitDoacrossOrdered(CodeGenFunction &CGF,\n                           const OMPDependClause *C) override;\n\n  /// Translates the native parameter of outlined function if this is required\n  /// for target.\n  /// \\param FD Field decl from captured record for the parameter.\n  /// \\param NativeParam Parameter itself.\n  const VarDecl *translateParameter(const FieldDecl *FD,\n                                    const VarDecl *NativeParam) const override;\n\n  /// Gets the address of the native argument basing on the address of the\n  /// target-specific parameter.\n  /// \\param NativeParam Parameter itself.\n  /// \\param TargetParam Corresponding target-specific parameter.\n  Address getParameterAddress(CodeGenFunction &CGF, const VarDecl *NativeParam,\n                              const VarDecl *TargetParam) const override;\n\n  /// Gets the OpenMP-specific address of the local variable.\n  Address getAddressOfLocalVariable(CodeGenFunction &CGF,\n                                    const VarDecl *VD) override {\n    return Address::invalid();\n  }\n};\n\n} // namespace CodeGen\n} // namespace clang\n\n#endif\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h", "content": "//===------ CGOpenMPRuntimeGPU.h - Interface to OpenMP GPU Runtimes ------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This provides a generalized class for OpenMP runtime code generation\n// specialized by GPU targets NVPTX and AMDGCN.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIMEGPU_H\n#define LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIMEGPU_H\n\n#include \"CGOpenMPRuntime.h\"\n#include \"CodeGenFunction.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"llvm/Frontend/OpenMP/OMPGridValues.h\"\n\nnamespace clang {\nnamespace CodeGen {\n\nclass CGOpenMPRuntimeGPU : public CGOpenMPRuntime {\npublic:\n  /// Defines the execution mode.\n  enum ExecutionMode {\n    /// SPMD execution mode (all threads are worker threads).\n    EM_SPMD,\n    /// Non-SPMD execution mode (1 master thread, others are workers).\n    EM_NonSPMD,\n    /// Unknown execution mode (orphaned directive).\n    EM_Unknown,\n  };\nprivate:\n  /// Parallel outlined function work for workers to execute.\n  llvm::SmallVector<llvm::Function *, 16> Work;\n\n  struct EntryFunctionState {\n    llvm::BasicBlock *ExitBB = nullptr;\n  };\n\n  class WorkerFunctionState {\n  public:\n    llvm::Function *WorkerFn;\n    const CGFunctionInfo &CGFI;\n    SourceLocation Loc;\n\n    WorkerFunctionState(CodeGenModule &CGM, SourceLocation Loc);\n\n  private:\n    void createWorkerFunction(CodeGenModule &CGM);\n  };\n\n  ExecutionMode getExecutionMode() const;\n\n  bool requiresFullRuntime() const { return RequiresFullRuntime; }\n\n  /// Get barrier to synchronize all threads in a block.\n  void syncCTAThreads(CodeGenFunction &CGF);\n\n  /// Emit the worker function for the current target region.\n  void emitWorkerFunction(WorkerFunctionState &WST);\n\n  /// Helper for worker function. Emit body of worker loop.\n  void emitWorkerLoop(CodeGenFunction &CGF, WorkerFunctionState &WST);\n\n  /// Helper for non-SPMD target entry function. Guide the master and\n  /// worker threads to their respective locations.\n  void emitNonSPMDEntryHeader(CodeGenFunction &CGF, EntryFunctionState &EST,\n                              WorkerFunctionState &WST);\n\n  /// Signal termination of OMP execution for non-SPMD target entry\n  /// function.\n  void emitNonSPMDEntryFooter(CodeGenFunction &CGF, EntryFunctionState &EST);\n\n  /// Helper for generic variables globalization prolog.\n  void emitGenericVarsProlog(CodeGenFunction &CGF, SourceLocation Loc,\n                             bool WithSPMDCheck = false);\n\n  /// Helper for generic variables globalization epilog.\n  void emitGenericVarsEpilog(CodeGenFunction &CGF, bool WithSPMDCheck = false);\n\n  /// Helper for SPMD mode target directive's entry function.\n  void emitSPMDEntryHeader(CodeGenFunction &CGF, EntryFunctionState &EST,\n                           const OMPExecutableDirective &D);\n\n  /// Signal termination of SPMD mode execution.\n  void emitSPMDEntryFooter(CodeGenFunction &CGF, EntryFunctionState &EST);\n\n  //\n  // Base class overrides.\n  //\n\n  /// Creates offloading entry for the provided entry ID \\a ID,\n  /// address \\a Addr, size \\a Size, and flags \\a Flags.\n  void createOffloadEntry(llvm::Constant *ID, llvm::Constant *Addr,\n                          uint64_t Size, int32_t Flags,\n                          llvm::GlobalValue::LinkageTypes Linkage) override;\n\n  /// Emit outlined function specialized for the Fork-Join\n  /// programming model for applicable target directives on the NVPTX device.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  void emitNonSPMDKernel(const OMPExecutableDirective &D, StringRef ParentName,\n                         llvm::Function *&OutlinedFn,\n                         llvm::Constant *&OutlinedFnID, bool IsOffloadEntry,\n                         const RegionCodeGenTy &CodeGen);\n\n  /// Emit outlined function specialized for the Single Program\n  /// Multiple Data programming model for applicable target directives on the\n  /// NVPTX device.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// \\param CodeGen Object containing the target statements.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  void emitSPMDKernel(const OMPExecutableDirective &D, StringRef ParentName,\n                      llvm::Function *&OutlinedFn,\n                      llvm::Constant *&OutlinedFnID, bool IsOffloadEntry,\n                      const RegionCodeGenTy &CodeGen);\n\n  /// Emit outlined function for 'target' directive on the NVPTX\n  /// device.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  void emitTargetOutlinedFunction(const OMPExecutableDirective &D,\n                                  StringRef ParentName,\n                                  llvm::Function *&OutlinedFn,\n                                  llvm::Constant *&OutlinedFnID,\n                                  bool IsOffloadEntry,\n                                  const RegionCodeGenTy &CodeGen) override;\n\n  /// Emits code for parallel or serial call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// This call is for the Non-SPMD Execution Mode.\n  /// \\param OutlinedFn Outlined function to be run in parallel threads. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  void emitNonSPMDParallelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                               llvm::Value *OutlinedFn,\n                               ArrayRef<llvm::Value *> CapturedVars,\n                               const Expr *IfCond);\n\n  /// Emits code for parallel or serial call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// This call is for a parallel directive within an SPMD target directive.\n  /// \\param OutlinedFn Outlined function to be run in parallel threads. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  ///\n  void emitSPMDParallelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                            llvm::Function *OutlinedFn,\n                            ArrayRef<llvm::Value *> CapturedVars,\n                            const Expr *IfCond);\n\nprotected:\n  /// Get the function name of an outlined region.\n  //  The name can be customized depending on the target.\n  //\n  StringRef getOutlinedHelperName() const override {\n    return \"__omp_outlined__\";\n  }\n\n  /// Check if the default location must be constant.\n  /// Constant for NVPTX for better optimization.\n  bool isDefaultLocationConstant() const override { return true; }\n\n  /// Returns additional flags that can be stored in reserved_2 field of the\n  /// default location.\n  /// For NVPTX target contains data about SPMD/Non-SPMD execution mode +\n  /// Full/Lightweight runtime mode. Used for better optimization.\n  unsigned getDefaultLocationReserved2Flags() const override;\n\npublic:\n  explicit CGOpenMPRuntimeGPU(CodeGenModule &CGM);\n  void clear() override;\n\n  /// Declare generalized virtual functions which need to be defined\n  /// by all specializations of OpenMPGPURuntime Targets like AMDGCN\n  /// and NVPTX.\n\n  /// Get the GPU warp size.\n  virtual llvm::Value *getGPUWarpSize(CodeGenFunction &CGF) = 0;\n\n  /// Get the id of the current thread on the GPU.\n  virtual llvm::Value *getGPUThreadID(CodeGenFunction &CGF) = 0;\n\n  /// Get the maximum number of threads in a block of the GPU.\n  virtual llvm::Value *getGPUNumThreads(CodeGenFunction &CGF) = 0;\n\n  /// Emit call to void __kmpc_push_proc_bind(ident_t *loc, kmp_int32\n  /// global_tid, int proc_bind) to generate code for 'proc_bind' clause.\n  virtual void emitProcBindClause(CodeGenFunction &CGF,\n                                  llvm::omp::ProcBindKind ProcBind,\n                                  SourceLocation Loc) override;\n\n  /// Emits call to void __kmpc_push_num_threads(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_threads) to generate code for 'num_threads'\n  /// clause.\n  /// \\param NumThreads An integer value of threads.\n  virtual void emitNumThreadsClause(CodeGenFunction &CGF,\n                                    llvm::Value *NumThreads,\n                                    SourceLocation Loc) override;\n\n  /// This function ought to emit, in the general case, a call to\n  // the openmp runtime kmpc_push_num_teams. In NVPTX backend it is not needed\n  // as these numbers are obtained through the PTX grid and block configuration.\n  /// \\param NumTeams An integer expression of teams.\n  /// \\param ThreadLimit An integer expression of threads.\n  void emitNumTeamsClause(CodeGenFunction &CGF, const Expr *NumTeams,\n                          const Expr *ThreadLimit, SourceLocation Loc) override;\n\n  /// Emits inlined function for the specified OpenMP parallel\n  //  directive.\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  llvm::Function *\n  emitParallelOutlinedFunction(const OMPExecutableDirective &D,\n                               const VarDecl *ThreadIDVar,\n                               OpenMPDirectiveKind InnermostKind,\n                               const RegionCodeGenTy &CodeGen) override;\n\n  /// Emits inlined function for the specified OpenMP teams\n  //  directive.\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  llvm::Function *\n  emitTeamsOutlinedFunction(const OMPExecutableDirective &D,\n                            const VarDecl *ThreadIDVar,\n                            OpenMPDirectiveKind InnermostKind,\n                            const RegionCodeGenTy &CodeGen) override;\n\n  /// Emits code for teams call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run by team masters. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  ///\n  void emitTeamsCall(CodeGenFunction &CGF, const OMPExecutableDirective &D,\n                     SourceLocation Loc, llvm::Function *OutlinedFn,\n                     ArrayRef<llvm::Value *> CapturedVars) override;\n\n  /// Emits code for parallel or serial call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run in parallel threads. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  void emitParallelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                        llvm::Function *OutlinedFn,\n                        ArrayRef<llvm::Value *> CapturedVars,\n                        const Expr *IfCond) override;\n\n  /// Emit an implicit/explicit barrier for OpenMP threads.\n  /// \\param Kind Directive for which this implicit barrier call must be\n  /// generated. Must be OMPD_barrier for explicit barrier generation.\n  /// \\param EmitChecks true if need to emit checks for cancellation barriers.\n  /// \\param ForceSimpleCall true simple barrier call must be emitted, false if\n  /// runtime class decides which one to emit (simple or with cancellation\n  /// checks).\n  ///\n  void emitBarrierCall(CodeGenFunction &CGF, SourceLocation Loc,\n                       OpenMPDirectiveKind Kind, bool EmitChecks = true,\n                       bool ForceSimpleCall = false) override;\n\n  /// Emits a critical region.\n  /// \\param CriticalName Name of the critical region.\n  /// \\param CriticalOpGen Generator for the statement associated with the given\n  /// critical region.\n  /// \\param Hint Value of the 'hint' clause (optional).\n  void emitCriticalRegion(CodeGenFunction &CGF, StringRef CriticalName,\n                          const RegionCodeGenTy &CriticalOpGen,\n                          SourceLocation Loc,\n                          const Expr *Hint = nullptr) override;\n\n  /// Emit a code for reduction clause.\n  ///\n  /// \\param Privates List of private copies for original reduction arguments.\n  /// \\param LHSExprs List of LHS in \\a ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a ReductionOps reduction operations.\n  /// \\param ReductionOps List of reduction operations in form 'LHS binop RHS'\n  /// or 'operator binop(LHS, RHS)'.\n  /// \\param Options List of options for reduction codegen:\n  ///     WithNowait true if parent directive has also nowait clause, false\n  ///     otherwise.\n  ///     SimpleReduction Emit reduction operation only. Used for omp simd\n  ///     directive on the host.\n  ///     ReductionKind The kind of reduction to perform.\n  virtual void emitReduction(CodeGenFunction &CGF, SourceLocation Loc,\n                             ArrayRef<const Expr *> Privates,\n                             ArrayRef<const Expr *> LHSExprs,\n                             ArrayRef<const Expr *> RHSExprs,\n                             ArrayRef<const Expr *> ReductionOps,\n                             ReductionOptionsTy Options) override;\n\n  /// Returns specified OpenMP runtime function for the current OpenMP\n  /// implementation.  Specialized for the NVPTX device.\n  /// \\param Function OpenMP runtime function.\n  /// \\return Specified function.\n  llvm::FunctionCallee createNVPTXRuntimeFunction(unsigned Function);\n\n  /// Translates the native parameter of outlined function if this is required\n  /// for target.\n  /// \\param FD Field decl from captured record for the parameter.\n  /// \\param NativeParam Parameter itself.\n  const VarDecl *translateParameter(const FieldDecl *FD,\n                                    const VarDecl *NativeParam) const override;\n\n  /// Gets the address of the native argument basing on the address of the\n  /// target-specific parameter.\n  /// \\param NativeParam Parameter itself.\n  /// \\param TargetParam Corresponding target-specific parameter.\n  Address getParameterAddress(CodeGenFunction &CGF, const VarDecl *NativeParam,\n                              const VarDecl *TargetParam) const override;\n\n  /// Emits call of the outlined function with the provided arguments,\n  /// translating these arguments to correct target-specific arguments.\n  void emitOutlinedFunctionCall(\n      CodeGenFunction &CGF, SourceLocation Loc, llvm::FunctionCallee OutlinedFn,\n      ArrayRef<llvm::Value *> Args = llvm::None) const override;\n\n  /// Emits OpenMP-specific function prolog.\n  /// Required for device constructs.\n  void emitFunctionProlog(CodeGenFunction &CGF, const Decl *D) override;\n\n  /// Gets the OpenMP-specific address of the local variable.\n  Address getAddressOfLocalVariable(CodeGenFunction &CGF,\n                                    const VarDecl *VD) override;\n\n  /// Target codegen is specialized based on two data-sharing modes: CUDA, in\n  /// which the local variables are actually global threadlocal, and Generic, in\n  /// which the local variables are placed in global memory if they may escape\n  /// their declaration context.\n  enum DataSharingMode {\n    /// CUDA data sharing mode.\n    CUDA,\n    /// Generic data-sharing mode.\n    Generic,\n  };\n\n  /// Cleans up references to the objects in finished function.\n  ///\n  void functionFinished(CodeGenFunction &CGF) override;\n\n  /// Choose a default value for the dist_schedule clause.\n  void getDefaultDistScheduleAndChunk(CodeGenFunction &CGF,\n      const OMPLoopDirective &S, OpenMPDistScheduleClauseKind &ScheduleKind,\n      llvm::Value *&Chunk) const override;\n\n  /// Choose a default value for the schedule clause.\n  void getDefaultScheduleAndChunk(CodeGenFunction &CGF,\n      const OMPLoopDirective &S, OpenMPScheduleClauseKind &ScheduleKind,\n      const Expr *&ChunkExpr) const override;\n\n  /// Adjust some parameters for the target-based directives, like addresses of\n  /// the variables captured by reference in lambdas.\n  void adjustTargetSpecificDataForLambdas(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D) const override;\n\n  /// Perform check on requires decl to ensure that target architecture\n  /// supports unified addressing\n  void processRequiresDirective(const OMPRequiresDecl *D) override;\n\n  /// Returns default address space for the constant firstprivates, __constant__\n  /// address space by default.\n  unsigned getDefaultFirstprivateAddressSpace() const override;\n\n  /// Checks if the variable has associated OMPAllocateDeclAttr attribute with\n  /// the predefined allocator and translates it into the corresponding address\n  /// space.\n  bool hasAllocateAttributeForGlobalVar(const VarDecl *VD, LangAS &AS) override;\n\nprivate:\n  /// Track the execution mode when codegening directives within a target\n  /// region. The appropriate mode (SPMD/NON-SPMD) is set on entry to the\n  /// target region and used by containing directives such as 'parallel'\n  /// to emit optimized code.\n  ExecutionMode CurrentExecutionMode = EM_Unknown;\n\n  /// Check if the full runtime is required (default - yes).\n  bool RequiresFullRuntime = true;\n\n  /// true if we're emitting the code for the target region and next parallel\n  /// region is L0 for sure.\n  bool IsInTargetMasterThreadRegion = false;\n  /// true if currently emitting code for target/teams/distribute region, false\n  /// - otherwise.\n  bool IsInTTDRegion = false;\n  /// true if we're definitely in the parallel region.\n  bool IsInParallelRegion = false;\n\n  /// Map between an outlined function and its wrapper.\n  llvm::DenseMap<llvm::Function *, llvm::Function *> WrapperFunctionsMap;\n\n  /// Emit function which wraps the outline parallel region\n  /// and controls the parameters which are passed to this function.\n  /// The wrapper ensures that the outlined function is called\n  /// with the correct arguments when data is shared.\n  llvm::Function *createParallelDataSharingWrapper(\n      llvm::Function *OutlinedParallelFn, const OMPExecutableDirective &D);\n\n  /// The data for the single globalized variable.\n  struct MappedVarData {\n    /// Corresponding field in the global record.\n    const FieldDecl *FD = nullptr;\n    /// Corresponding address.\n    Address PrivateAddr = Address::invalid();\n    /// true, if only one element is required (for latprivates in SPMD mode),\n    /// false, if need to create based on the warp-size.\n    bool IsOnePerTeam = false;\n    MappedVarData() = delete;\n    MappedVarData(const FieldDecl *FD, bool IsOnePerTeam = false)\n        : FD(FD), IsOnePerTeam(IsOnePerTeam) {}\n  };\n  /// The map of local variables to their addresses in the global memory.\n  using DeclToAddrMapTy = llvm::MapVector<const Decl *, MappedVarData>;\n  /// Set of the parameters passed by value escaping OpenMP context.\n  using EscapedParamsTy = llvm::SmallPtrSet<const Decl *, 4>;\n  struct FunctionData {\n    DeclToAddrMapTy LocalVarData;\n    llvm::Optional<DeclToAddrMapTy> SecondaryLocalVarData = llvm::None;\n    EscapedParamsTy EscapedParameters;\n    llvm::SmallVector<const ValueDecl*, 4> EscapedVariableLengthDecls;\n    llvm::SmallVector<llvm::Value *, 4> EscapedVariableLengthDeclsAddrs;\n    const RecordDecl *GlobalRecord = nullptr;\n    llvm::Optional<const RecordDecl *> SecondaryGlobalRecord = llvm::None;\n    llvm::Value *GlobalRecordAddr = nullptr;\n    llvm::Value *IsInSPMDModeFlag = nullptr;\n    std::unique_ptr<CodeGenFunction::OMPMapVars> MappedParams;\n  };\n  /// Maps the function to the list of the globalized variables with their\n  /// addresses.\n  llvm::SmallDenseMap<llvm::Function *, FunctionData> FunctionGlobalizedDecls;\n  /// List of records for the globalized variables in target/teams/distribute\n  /// contexts. Inner records are going to be joined into the single record,\n  /// while those resulting records are going to be joined into the single\n  /// union. This resulting union (one per CU) is the entry point for the static\n  /// memory management runtime functions.\n  struct GlobalPtrSizeRecsTy {\n    llvm::GlobalVariable *UseSharedMemory = nullptr;\n    llvm::GlobalVariable *RecSize = nullptr;\n    llvm::GlobalVariable *Buffer = nullptr;\n    SourceLocation Loc;\n    llvm::SmallVector<const RecordDecl *, 2> Records;\n    unsigned RegionCounter = 0;\n  };\n  llvm::SmallVector<GlobalPtrSizeRecsTy, 8> GlobalizedRecords;\n  llvm::GlobalVariable *KernelTeamsReductionPtr = nullptr;\n  /// List of the records with the list of fields for the reductions across the\n  /// teams. Used to build the intermediate buffer for the fast teams\n  /// reductions.\n  /// All the records are gathered into a union `union.type` is created.\n  llvm::SmallVector<const RecordDecl *, 4> TeamsReductions;\n  /// Shared pointer for the global memory in the global memory buffer used for\n  /// the given kernel.\n  llvm::GlobalVariable *KernelStaticGlobalized = nullptr;\n  /// Pair of the Non-SPMD team and all reductions variables in this team\n  /// region.\n  std::pair<const Decl *, llvm::SmallVector<const ValueDecl *, 4>>\n      TeamAndReductions;\n};\n\n} // CodeGen namespace.\n} // clang namespace.\n\n#endif // LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIMEGPU_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "content": "//===-- CodeGenFunction.h - Per-Function state for LLVM CodeGen -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This is the internal per-function state used for llvm translation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CODEGENFUNCTION_H\n#define LLVM_CLANG_LIB_CODEGEN_CODEGENFUNCTION_H\n\n#include \"CGBuilder.h\"\n#include \"CGDebugInfo.h\"\n#include \"CGLoopInfo.h\"\n#include \"CGValue.h\"\n#include \"CodeGenModule.h\"\n#include \"CodeGenPGO.h\"\n#include \"EHScopeStack.h\"\n#include \"VarBypassDetector.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/CurrentSourceLocExprScope.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/ABI.h\"\n#include \"clang/Basic/CapturedStmt.h\"\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Frontend/OpenMP/OMPIRBuilder.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Transforms/Utils/SanitizerStats.h\"\n\nnamespace llvm {\nclass BasicBlock;\nclass LLVMContext;\nclass MDNode;\nclass Module;\nclass SwitchInst;\nclass Twine;\nclass Value;\nclass CanonicalLoopInfo;\n}\n\nnamespace clang {\nclass ASTContext;\nclass BlockDecl;\nclass CXXDestructorDecl;\nclass CXXForRangeStmt;\nclass CXXTryStmt;\nclass Decl;\nclass LabelDecl;\nclass EnumConstantDecl;\nclass FunctionDecl;\nclass FunctionProtoType;\nclass LabelStmt;\nclass ObjCContainerDecl;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass ObjCMethodDecl;\nclass ObjCImplementationDecl;\nclass ObjCPropertyImplDecl;\nclass TargetInfo;\nclass VarDecl;\nclass ObjCForCollectionStmt;\nclass ObjCAtTryStmt;\nclass ObjCAtThrowStmt;\nclass ObjCAtSynchronizedStmt;\nclass ObjCAutoreleasePoolStmt;\nclass OMPUseDevicePtrClause;\nclass OMPUseDeviceAddrClause;\nclass ReturnsNonNullAttr;\nclass SVETypeFlags;\nclass OMPExecutableDirective;\n\nnamespace analyze_os_log {\nclass OSLogBufferLayout;\n}\n\nnamespace CodeGen {\nclass CodeGenTypes;\nclass CGCallee;\nclass CGFunctionInfo;\nclass CGRecordLayout;\nclass CGBlockInfo;\nclass CGCXXABI;\nclass BlockByrefHelpers;\nclass BlockByrefInfo;\nclass BlockFlags;\nclass BlockFieldFlags;\nclass RegionCodeGenTy;\nclass TargetCodeGenInfo;\nstruct OMPTaskDataTy;\nstruct CGCoroData;\n\n/// The kind of evaluation to perform on values of a particular\n/// type.  Basically, is the code in CGExprScalar, CGExprComplex, or\n/// CGExprAgg?\n///\n/// TODO: should vectors maybe be split out into their own thing?\nenum TypeEvaluationKind {\n  TEK_Scalar,\n  TEK_Complex,\n  TEK_Aggregate\n};\n\n#define LIST_SANITIZER_CHECKS                                                  \\\n  SANITIZER_CHECK(AddOverflow, add_overflow, 0)                                \\\n  SANITIZER_CHECK(BuiltinUnreachable, builtin_unreachable, 0)                  \\\n  SANITIZER_CHECK(CFICheckFail, cfi_check_fail, 0)                             \\\n  SANITIZER_CHECK(DivremOverflow, divrem_overflow, 0)                          \\\n  SANITIZER_CHECK(DynamicTypeCacheMiss, dynamic_type_cache_miss, 0)            \\\n  SANITIZER_CHECK(FloatCastOverflow, float_cast_overflow, 0)                   \\\n  SANITIZER_CHECK(FunctionTypeMismatch, function_type_mismatch, 1)             \\\n  SANITIZER_CHECK(ImplicitConversion, implicit_conversion, 0)                  \\\n  SANITIZER_CHECK(InvalidBuiltin, invalid_builtin, 0)                          \\\n  SANITIZER_CHECK(InvalidObjCCast, invalid_objc_cast, 0)                       \\\n  SANITIZER_CHECK(LoadInvalidValue, load_invalid_value, 0)                     \\\n  SANITIZER_CHECK(MissingReturn, missing_return, 0)                            \\\n  SANITIZER_CHECK(MulOverflow, mul_overflow, 0)                                \\\n  SANITIZER_CHECK(NegateOverflow, negate_overflow, 0)                          \\\n  SANITIZER_CHECK(NullabilityArg, nullability_arg, 0)                          \\\n  SANITIZER_CHECK(NullabilityReturn, nullability_return, 1)                    \\\n  SANITIZER_CHECK(NonnullArg, nonnull_arg, 0)                                  \\\n  SANITIZER_CHECK(NonnullReturn, nonnull_return, 1)                            \\\n  SANITIZER_CHECK(OutOfBounds, out_of_bounds, 0)                               \\\n  SANITIZER_CHECK(PointerOverflow, pointer_overflow, 0)                        \\\n  SANITIZER_CHECK(ShiftOutOfBounds, shift_out_of_bounds, 0)                    \\\n  SANITIZER_CHECK(SubOverflow, sub_overflow, 0)                                \\\n  SANITIZER_CHECK(TypeMismatch, type_mismatch, 1)                              \\\n  SANITIZER_CHECK(AlignmentAssumption, alignment_assumption, 0)                \\\n  SANITIZER_CHECK(VLABoundNotPositive, vla_bound_not_positive, 0)\n\nenum SanitizerHandler {\n#define SANITIZER_CHECK(Enum, Name, Version) Enum,\n  LIST_SANITIZER_CHECKS\n#undef SANITIZER_CHECK\n};\n\n/// Helper class with most of the code for saving a value for a\n/// conditional expression cleanup.\nstruct DominatingLLVMValue {\n  typedef llvm::PointerIntPair<llvm::Value*, 1, bool> saved_type;\n\n  /// Answer whether the given value needs extra work to be saved.\n  static bool needsSaving(llvm::Value *value) {\n    // If it's not an instruction, we don't need to save.\n    if (!isa<llvm::Instruction>(value)) return false;\n\n    // If it's an instruction in the entry block, we don't need to save.\n    llvm::BasicBlock *block = cast<llvm::Instruction>(value)->getParent();\n    return (block != &block->getParent()->getEntryBlock());\n  }\n\n  static saved_type save(CodeGenFunction &CGF, llvm::Value *value);\n  static llvm::Value *restore(CodeGenFunction &CGF, saved_type value);\n};\n\n/// A partial specialization of DominatingValue for llvm::Values that\n/// might be llvm::Instructions.\ntemplate <class T> struct DominatingPointer<T,true> : DominatingLLVMValue {\n  typedef T *type;\n  static type restore(CodeGenFunction &CGF, saved_type value) {\n    return static_cast<T*>(DominatingLLVMValue::restore(CGF, value));\n  }\n};\n\n/// A specialization of DominatingValue for Address.\ntemplate <> struct DominatingValue<Address> {\n  typedef Address type;\n\n  struct saved_type {\n    DominatingLLVMValue::saved_type SavedValue;\n    CharUnits Alignment;\n  };\n\n  static bool needsSaving(type value) {\n    return DominatingLLVMValue::needsSaving(value.getPointer());\n  }\n  static saved_type save(CodeGenFunction &CGF, type value) {\n    return { DominatingLLVMValue::save(CGF, value.getPointer()),\n             value.getAlignment() };\n  }\n  static type restore(CodeGenFunction &CGF, saved_type value) {\n    return Address(DominatingLLVMValue::restore(CGF, value.SavedValue),\n                   value.Alignment);\n  }\n};\n\n/// A specialization of DominatingValue for RValue.\ntemplate <> struct DominatingValue<RValue> {\n  typedef RValue type;\n  class saved_type {\n    enum Kind { ScalarLiteral, ScalarAddress, AggregateLiteral,\n                AggregateAddress, ComplexAddress };\n\n    llvm::Value *Value;\n    unsigned K : 3;\n    unsigned Align : 29;\n    saved_type(llvm::Value *v, Kind k, unsigned a = 0)\n      : Value(v), K(k), Align(a) {}\n\n  public:\n    static bool needsSaving(RValue value);\n    static saved_type save(CodeGenFunction &CGF, RValue value);\n    RValue restore(CodeGenFunction &CGF);\n\n    // implementations in CGCleanup.cpp\n  };\n\n  static bool needsSaving(type value) {\n    return saved_type::needsSaving(value);\n  }\n  static saved_type save(CodeGenFunction &CGF, type value) {\n    return saved_type::save(CGF, value);\n  }\n  static type restore(CodeGenFunction &CGF, saved_type value) {\n    return value.restore(CGF);\n  }\n};\n\n/// CodeGenFunction - This class organizes the per-function state that is used\n/// while generating LLVM code.\nclass CodeGenFunction : public CodeGenTypeCache {\n  CodeGenFunction(const CodeGenFunction &) = delete;\n  void operator=(const CodeGenFunction &) = delete;\n\n  friend class CGCXXABI;\npublic:\n  /// A jump destination is an abstract label, branching to which may\n  /// require a jump out through normal cleanups.\n  struct JumpDest {\n    JumpDest() : Block(nullptr), ScopeDepth(), Index(0) {}\n    JumpDest(llvm::BasicBlock *Block,\n             EHScopeStack::stable_iterator Depth,\n             unsigned Index)\n      : Block(Block), ScopeDepth(Depth), Index(Index) {}\n\n    bool isValid() const { return Block != nullptr; }\n    llvm::BasicBlock *getBlock() const { return Block; }\n    EHScopeStack::stable_iterator getScopeDepth() const { return ScopeDepth; }\n    unsigned getDestIndex() const { return Index; }\n\n    // This should be used cautiously.\n    void setScopeDepth(EHScopeStack::stable_iterator depth) {\n      ScopeDepth = depth;\n    }\n\n  private:\n    llvm::BasicBlock *Block;\n    EHScopeStack::stable_iterator ScopeDepth;\n    unsigned Index;\n  };\n\n  CodeGenModule &CGM;  // Per-module state.\n  const TargetInfo &Target;\n\n  // For EH/SEH outlined funclets, this field points to parent's CGF\n  CodeGenFunction *ParentCGF = nullptr;\n\n  typedef std::pair<llvm::Value *, llvm::Value *> ComplexPairTy;\n  LoopInfoStack LoopStack;\n  CGBuilderTy Builder;\n\n  // Stores variables for which we can't generate correct lifetime markers\n  // because of jumps.\n  VarBypassDetector Bypasses;\n\n  /// List of recently emitted OMPCanonicalLoops.\n  ///\n  /// Since OMPCanonicalLoops are nested inside other statements (in particular\n  /// CapturedStmt generated by OMPExecutableDirective and non-perfectly nested\n  /// loops), we cannot directly call OMPEmitOMPCanonicalLoop and receive its\n  /// llvm::CanonicalLoopInfo. Instead, we call EmitStmt and any\n  /// OMPEmitOMPCanonicalLoop called by it will add its CanonicalLoopInfo to\n  /// this stack when done. Entering a new loop requires clearing this list; it\n  /// either means we start parsing a new loop nest (in which case the previous\n  /// loop nest goes out of scope) or a second loop in the same level in which\n  /// case it would be ambiguous into which of the two (or more) loops the loop\n  /// nest would extend.\n  SmallVector<llvm::CanonicalLoopInfo *, 4> OMPLoopNestStack;\n\n  // CodeGen lambda for loops and support for ordered clause\n  typedef llvm::function_ref<void(CodeGenFunction &, const OMPLoopDirective &,\n                                  JumpDest)>\n      CodeGenLoopTy;\n  typedef llvm::function_ref<void(CodeGenFunction &, SourceLocation,\n                                  const unsigned, const bool)>\n      CodeGenOrderedTy;\n\n  // Codegen lambda for loop bounds in worksharing loop constructs\n  typedef llvm::function_ref<std::pair<LValue, LValue>(\n      CodeGenFunction &, const OMPExecutableDirective &S)>\n      CodeGenLoopBoundsTy;\n\n  // Codegen lambda for loop bounds in dispatch-based loop implementation\n  typedef llvm::function_ref<std::pair<llvm::Value *, llvm::Value *>(\n      CodeGenFunction &, const OMPExecutableDirective &S, Address LB,\n      Address UB)>\n      CodeGenDispatchBoundsTy;\n\n  /// CGBuilder insert helper. This function is called after an\n  /// instruction is created using Builder.\n  void InsertHelper(llvm::Instruction *I, const llvm::Twine &Name,\n                    llvm::BasicBlock *BB,\n                    llvm::BasicBlock::iterator InsertPt) const;\n\n  /// CurFuncDecl - Holds the Decl for the current outermost\n  /// non-closure context.\n  const Decl *CurFuncDecl;\n  /// CurCodeDecl - This is the inner-most code context, which includes blocks.\n  const Decl *CurCodeDecl;\n  const CGFunctionInfo *CurFnInfo;\n  QualType FnRetTy;\n  llvm::Function *CurFn = nullptr;\n\n  // Holds coroutine data if the current function is a coroutine. We use a\n  // wrapper to manage its lifetime, so that we don't have to define CGCoroData\n  // in this header.\n  struct CGCoroInfo {\n    std::unique_ptr<CGCoroData> Data;\n    CGCoroInfo();\n    ~CGCoroInfo();\n  };\n  CGCoroInfo CurCoro;\n\n  bool isCoroutine() const {\n    return CurCoro.Data != nullptr;\n  }\n\n  /// CurGD - The GlobalDecl for the current function being compiled.\n  GlobalDecl CurGD;\n\n  /// PrologueCleanupDepth - The cleanup depth enclosing all the\n  /// cleanups associated with the parameters.\n  EHScopeStack::stable_iterator PrologueCleanupDepth;\n\n  /// ReturnBlock - Unified return block.\n  JumpDest ReturnBlock;\n\n  /// ReturnValue - The temporary alloca to hold the return\n  /// value. This is invalid iff the function has no return value.\n  Address ReturnValue = Address::invalid();\n\n  /// ReturnValuePointer - The temporary alloca to hold a pointer to sret.\n  /// This is invalid if sret is not in use.\n  Address ReturnValuePointer = Address::invalid();\n\n  /// If a return statement is being visited, this holds the return statment's\n  /// result expression.\n  const Expr *RetExpr = nullptr;\n\n  /// Return true if a label was seen in the current scope.\n  bool hasLabelBeenSeenInCurrentScope() const {\n    if (CurLexicalScope)\n      return CurLexicalScope->hasLabels();\n    return !LabelMap.empty();\n  }\n\n  /// AllocaInsertPoint - This is an instruction in the entry block before which\n  /// we prefer to insert allocas.\n  llvm::AssertingVH<llvm::Instruction> AllocaInsertPt;\n\n  /// API for captured statement code generation.\n  class CGCapturedStmtInfo {\n  public:\n    explicit CGCapturedStmtInfo(CapturedRegionKind K = CR_Default)\n        : Kind(K), ThisValue(nullptr), CXXThisFieldDecl(nullptr) {}\n    explicit CGCapturedStmtInfo(const CapturedStmt &S,\n                                CapturedRegionKind K = CR_Default)\n      : Kind(K), ThisValue(nullptr), CXXThisFieldDecl(nullptr) {\n\n      RecordDecl::field_iterator Field =\n        S.getCapturedRecordDecl()->field_begin();\n      for (CapturedStmt::const_capture_iterator I = S.capture_begin(),\n                                                E = S.capture_end();\n           I != E; ++I, ++Field) {\n        if (I->capturesThis())\n          CXXThisFieldDecl = *Field;\n        else if (I->capturesVariable())\n          CaptureFields[I->getCapturedVar()->getCanonicalDecl()] = *Field;\n        else if (I->capturesVariableByCopy())\n          CaptureFields[I->getCapturedVar()->getCanonicalDecl()] = *Field;\n      }\n    }\n\n    virtual ~CGCapturedStmtInfo();\n\n    CapturedRegionKind getKind() const { return Kind; }\n\n    virtual void setContextValue(llvm::Value *V) { ThisValue = V; }\n    // Retrieve the value of the context parameter.\n    virtual llvm::Value *getContextValue() const { return ThisValue; }\n\n    /// Lookup the captured field decl for a variable.\n    virtual const FieldDecl *lookup(const VarDecl *VD) const {\n      return CaptureFields.lookup(VD->getCanonicalDecl());\n    }\n\n    bool isCXXThisExprCaptured() const { return getThisFieldDecl() != nullptr; }\n    virtual FieldDecl *getThisFieldDecl() const { return CXXThisFieldDecl; }\n\n    static bool classof(const CGCapturedStmtInfo *) {\n      return true;\n    }\n\n    /// Emit the captured statement body.\n    virtual void EmitBody(CodeGenFunction &CGF, const Stmt *S) {\n      CGF.incrementProfileCounter(S);\n      CGF.EmitStmt(S);\n    }\n\n    /// Get the name of the capture helper.\n    virtual StringRef getHelperName() const { return \"__captured_stmt\"; }\n\n  private:\n    /// The kind of captured statement being generated.\n    CapturedRegionKind Kind;\n\n    /// Keep the map between VarDecl and FieldDecl.\n    llvm::SmallDenseMap<const VarDecl *, FieldDecl *> CaptureFields;\n\n    /// The base address of the captured record, passed in as the first\n    /// argument of the parallel region function.\n    llvm::Value *ThisValue;\n\n    /// Captured 'this' type.\n    FieldDecl *CXXThisFieldDecl;\n  };\n  CGCapturedStmtInfo *CapturedStmtInfo = nullptr;\n\n  /// RAII for correct setting/restoring of CapturedStmtInfo.\n  class CGCapturedStmtRAII {\n  private:\n    CodeGenFunction &CGF;\n    CGCapturedStmtInfo *PrevCapturedStmtInfo;\n  public:\n    CGCapturedStmtRAII(CodeGenFunction &CGF,\n                       CGCapturedStmtInfo *NewCapturedStmtInfo)\n        : CGF(CGF), PrevCapturedStmtInfo(CGF.CapturedStmtInfo) {\n      CGF.CapturedStmtInfo = NewCapturedStmtInfo;\n    }\n    ~CGCapturedStmtRAII() { CGF.CapturedStmtInfo = PrevCapturedStmtInfo; }\n  };\n\n  /// An abstract representation of regular/ObjC call/message targets.\n  class AbstractCallee {\n    /// The function declaration of the callee.\n    const Decl *CalleeDecl;\n\n  public:\n    AbstractCallee() : CalleeDecl(nullptr) {}\n    AbstractCallee(const FunctionDecl *FD) : CalleeDecl(FD) {}\n    AbstractCallee(const ObjCMethodDecl *OMD) : CalleeDecl(OMD) {}\n    bool hasFunctionDecl() const {\n      return dyn_cast_or_null<FunctionDecl>(CalleeDecl);\n    }\n    const Decl *getDecl() const { return CalleeDecl; }\n    unsigned getNumParams() const {\n      if (const auto *FD = dyn_cast<FunctionDecl>(CalleeDecl))\n        return FD->getNumParams();\n      return cast<ObjCMethodDecl>(CalleeDecl)->param_size();\n    }\n    const ParmVarDecl *getParamDecl(unsigned I) const {\n      if (const auto *FD = dyn_cast<FunctionDecl>(CalleeDecl))\n        return FD->getParamDecl(I);\n      return *(cast<ObjCMethodDecl>(CalleeDecl)->param_begin() + I);\n    }\n  };\n\n  /// Sanitizers enabled for this function.\n  SanitizerSet SanOpts;\n\n  /// True if CodeGen currently emits code implementing sanitizer checks.\n  bool IsSanitizerScope = false;\n\n  /// RAII object to set/unset CodeGenFunction::IsSanitizerScope.\n  class SanitizerScope {\n    CodeGenFunction *CGF;\n  public:\n    SanitizerScope(CodeGenFunction *CGF);\n    ~SanitizerScope();\n  };\n\n  /// In C++, whether we are code generating a thunk.  This controls whether we\n  /// should emit cleanups.\n  bool CurFuncIsThunk = false;\n\n  /// In ARC, whether we should autorelease the return value.\n  bool AutoreleaseResult = false;\n\n  /// Whether we processed a Microsoft-style asm block during CodeGen. These can\n  /// potentially set the return value.\n  bool SawAsmBlock = false;\n\n  const NamedDecl *CurSEHParent = nullptr;\n\n  /// True if the current function is an outlined SEH helper. This can be a\n  /// finally block or filter expression.\n  bool IsOutlinedSEHHelper = false;\n\n  /// True if CodeGen currently emits code inside presereved access index\n  /// region.\n  bool IsInPreservedAIRegion = false;\n\n  /// True if the current statement has nomerge attribute.\n  bool InNoMergeAttributedStmt = false;\n\n  /// True if the current function should be marked mustprogress.\n  bool FnIsMustProgress = false;\n\n  /// True if the C++ Standard Requires Progress.\n  bool CPlusPlusWithProgress() {\n    if (CGM.getCodeGenOpts().getFiniteLoops() ==\n        CodeGenOptions::FiniteLoopsKind::Never)\n      return false;\n\n    return getLangOpts().CPlusPlus11 || getLangOpts().CPlusPlus14 ||\n           getLangOpts().CPlusPlus17 || getLangOpts().CPlusPlus20;\n  }\n\n  /// True if the C Standard Requires Progress.\n  bool CWithProgress() {\n    if (CGM.getCodeGenOpts().getFiniteLoops() ==\n        CodeGenOptions::FiniteLoopsKind::Always)\n      return true;\n    if (CGM.getCodeGenOpts().getFiniteLoops() ==\n        CodeGenOptions::FiniteLoopsKind::Never)\n      return false;\n\n    return getLangOpts().C11 || getLangOpts().C17 || getLangOpts().C2x;\n  }\n\n  /// True if the language standard requires progress in functions or\n  /// in infinite loops with non-constant conditionals.\n  bool LanguageRequiresProgress() {\n    return CWithProgress() || CPlusPlusWithProgress();\n  }\n\n  const CodeGen::CGBlockInfo *BlockInfo = nullptr;\n  llvm::Value *BlockPointer = nullptr;\n\n  llvm::DenseMap<const VarDecl *, FieldDecl *> LambdaCaptureFields;\n  FieldDecl *LambdaThisCaptureField = nullptr;\n\n  /// A mapping from NRVO variables to the flags used to indicate\n  /// when the NRVO has been applied to this variable.\n  llvm::DenseMap<const VarDecl *, llvm::Value *> NRVOFlags;\n\n  EHScopeStack EHStack;\n  llvm::SmallVector<char, 256> LifetimeExtendedCleanupStack;\n  llvm::SmallVector<const JumpDest *, 2> SEHTryEpilogueStack;\n\n  llvm::Instruction *CurrentFuncletPad = nullptr;\n\n  class CallLifetimeEnd final : public EHScopeStack::Cleanup {\n    llvm::Value *Addr;\n    llvm::Value *Size;\n\n  public:\n    CallLifetimeEnd(Address addr, llvm::Value *size)\n        : Addr(addr.getPointer()), Size(size) {}\n\n    void Emit(CodeGenFunction &CGF, Flags flags) override {\n      CGF.EmitLifetimeEnd(Size, Addr);\n    }\n  };\n\n  /// Header for data within LifetimeExtendedCleanupStack.\n  struct LifetimeExtendedCleanupHeader {\n    /// The size of the following cleanup object.\n    unsigned Size;\n    /// The kind of cleanup to push: a value from the CleanupKind enumeration.\n    unsigned Kind : 31;\n    /// Whether this is a conditional cleanup.\n    unsigned IsConditional : 1;\n\n    size_t getSize() const { return Size; }\n    CleanupKind getKind() const { return (CleanupKind)Kind; }\n    bool isConditional() const { return IsConditional; }\n  };\n\n  /// i32s containing the indexes of the cleanup destinations.\n  Address NormalCleanupDest = Address::invalid();\n\n  unsigned NextCleanupDestIndex = 1;\n\n  /// EHResumeBlock - Unified block containing a call to llvm.eh.resume.\n  llvm::BasicBlock *EHResumeBlock = nullptr;\n\n  /// The exception slot.  All landing pads write the current exception pointer\n  /// into this alloca.\n  llvm::Value *ExceptionSlot = nullptr;\n\n  /// The selector slot.  Under the MandatoryCleanup model, all landing pads\n  /// write the current selector value into this alloca.\n  llvm::AllocaInst *EHSelectorSlot = nullptr;\n\n  /// A stack of exception code slots. Entering an __except block pushes a slot\n  /// on the stack and leaving pops one. The __exception_code() intrinsic loads\n  /// a value from the top of the stack.\n  SmallVector<Address, 1> SEHCodeSlotStack;\n\n  /// Value returned by __exception_info intrinsic.\n  llvm::Value *SEHInfo = nullptr;\n\n  /// Emits a landing pad for the current EH stack.\n  llvm::BasicBlock *EmitLandingPad();\n\n  llvm::BasicBlock *getInvokeDestImpl();\n\n  /// Parent loop-based directive for scan directive.\n  const OMPExecutableDirective *OMPParentLoopDirectiveForScan = nullptr;\n  llvm::BasicBlock *OMPBeforeScanBlock = nullptr;\n  llvm::BasicBlock *OMPAfterScanBlock = nullptr;\n  llvm::BasicBlock *OMPScanExitBlock = nullptr;\n  llvm::BasicBlock *OMPScanDispatch = nullptr;\n  bool OMPFirstScanLoop = false;\n\n  /// Manages parent directive for scan directives.\n  class ParentLoopDirectiveForScanRegion {\n    CodeGenFunction &CGF;\n    const OMPExecutableDirective *ParentLoopDirectiveForScan;\n\n  public:\n    ParentLoopDirectiveForScanRegion(\n        CodeGenFunction &CGF,\n        const OMPExecutableDirective &ParentLoopDirectiveForScan)\n        : CGF(CGF),\n          ParentLoopDirectiveForScan(CGF.OMPParentLoopDirectiveForScan) {\n      CGF.OMPParentLoopDirectiveForScan = &ParentLoopDirectiveForScan;\n    }\n    ~ParentLoopDirectiveForScanRegion() {\n      CGF.OMPParentLoopDirectiveForScan = ParentLoopDirectiveForScan;\n    }\n  };\n\n  template <class T>\n  typename DominatingValue<T>::saved_type saveValueInCond(T value) {\n    return DominatingValue<T>::save(*this, value);\n  }\n\n  class CGFPOptionsRAII {\n  public:\n    CGFPOptionsRAII(CodeGenFunction &CGF, FPOptions FPFeatures);\n    CGFPOptionsRAII(CodeGenFunction &CGF, const Expr *E);\n    ~CGFPOptionsRAII();\n\n  private:\n    void ConstructorHelper(FPOptions FPFeatures);\n    CodeGenFunction &CGF;\n    FPOptions OldFPFeatures;\n    llvm::fp::ExceptionBehavior OldExcept;\n    llvm::RoundingMode OldRounding;\n    Optional<CGBuilderTy::FastMathFlagGuard> FMFGuard;\n  };\n  FPOptions CurFPFeatures;\n\npublic:\n  /// ObjCEHValueStack - Stack of Objective-C exception values, used for\n  /// rethrows.\n  SmallVector<llvm::Value*, 8> ObjCEHValueStack;\n\n  /// A class controlling the emission of a finally block.\n  class FinallyInfo {\n    /// Where the catchall's edge through the cleanup should go.\n    JumpDest RethrowDest;\n\n    /// A function to call to enter the catch.\n    llvm::FunctionCallee BeginCatchFn;\n\n    /// An i1 variable indicating whether or not the @finally is\n    /// running for an exception.\n    llvm::AllocaInst *ForEHVar;\n\n    /// An i8* variable into which the exception pointer to rethrow\n    /// has been saved.\n    llvm::AllocaInst *SavedExnVar;\n\n  public:\n    void enter(CodeGenFunction &CGF, const Stmt *Finally,\n               llvm::FunctionCallee beginCatchFn,\n               llvm::FunctionCallee endCatchFn, llvm::FunctionCallee rethrowFn);\n    void exit(CodeGenFunction &CGF);\n  };\n\n  /// Returns true inside SEH __try blocks.\n  bool isSEHTryScope() const { return !SEHTryEpilogueStack.empty(); }\n\n  /// Returns true while emitting a cleanuppad.\n  bool isCleanupPadScope() const {\n    return CurrentFuncletPad && isa<llvm::CleanupPadInst>(CurrentFuncletPad);\n  }\n\n  /// pushFullExprCleanup - Push a cleanup to be run at the end of the\n  /// current full-expression.  Safe against the possibility that\n  /// we're currently inside a conditionally-evaluated expression.\n  template <class T, class... As>\n  void pushFullExprCleanup(CleanupKind kind, As... A) {\n    // If we're not in a conditional branch, or if none of the\n    // arguments requires saving, then use the unconditional cleanup.\n    if (!isInConditionalBranch())\n      return EHStack.pushCleanup<T>(kind, A...);\n\n    // Stash values in a tuple so we can guarantee the order of saves.\n    typedef std::tuple<typename DominatingValue<As>::saved_type...> SavedTuple;\n    SavedTuple Saved{saveValueInCond(A)...};\n\n    typedef EHScopeStack::ConditionalCleanup<T, As...> CleanupType;\n    EHStack.pushCleanupTuple<CleanupType>(kind, Saved);\n    initFullExprCleanup();\n  }\n\n  /// Queue a cleanup to be pushed after finishing the current full-expression,\n  /// potentially with an active flag.\n  template <class T, class... As>\n  void pushCleanupAfterFullExpr(CleanupKind Kind, As... A) {\n    if (!isInConditionalBranch())\n      return pushCleanupAfterFullExprWithActiveFlag<T>(Kind, Address::invalid(),\n                                                       A...);\n\n    Address ActiveFlag = createCleanupActiveFlag();\n    assert(!DominatingValue<Address>::needsSaving(ActiveFlag) &&\n           \"cleanup active flag should never need saving\");\n\n    typedef std::tuple<typename DominatingValue<As>::saved_type...> SavedTuple;\n    SavedTuple Saved{saveValueInCond(A)...};\n\n    typedef EHScopeStack::ConditionalCleanup<T, As...> CleanupType;\n    pushCleanupAfterFullExprWithActiveFlag<CleanupType>(Kind, ActiveFlag, Saved);\n  }\n\n  template <class T, class... As>\n  void pushCleanupAfterFullExprWithActiveFlag(CleanupKind Kind,\n                                              Address ActiveFlag, As... A) {\n    LifetimeExtendedCleanupHeader Header = {sizeof(T), Kind,\n                                            ActiveFlag.isValid()};\n\n    size_t OldSize = LifetimeExtendedCleanupStack.size();\n    LifetimeExtendedCleanupStack.resize(\n        LifetimeExtendedCleanupStack.size() + sizeof(Header) + Header.Size +\n        (Header.IsConditional ? sizeof(ActiveFlag) : 0));\n\n    static_assert(sizeof(Header) % alignof(T) == 0,\n                  \"Cleanup will be allocated on misaligned address\");\n    char *Buffer = &LifetimeExtendedCleanupStack[OldSize];\n    new (Buffer) LifetimeExtendedCleanupHeader(Header);\n    new (Buffer + sizeof(Header)) T(A...);\n    if (Header.IsConditional)\n      new (Buffer + sizeof(Header) + sizeof(T)) Address(ActiveFlag);\n  }\n\n  /// Set up the last cleanup that was pushed as a conditional\n  /// full-expression cleanup.\n  void initFullExprCleanup() {\n    initFullExprCleanupWithFlag(createCleanupActiveFlag());\n  }\n\n  void initFullExprCleanupWithFlag(Address ActiveFlag);\n  Address createCleanupActiveFlag();\n\n  /// PushDestructorCleanup - Push a cleanup to call the\n  /// complete-object destructor of an object of the given type at the\n  /// given address.  Does nothing if T is not a C++ class type with a\n  /// non-trivial destructor.\n  void PushDestructorCleanup(QualType T, Address Addr);\n\n  /// PushDestructorCleanup - Push a cleanup to call the\n  /// complete-object variant of the given destructor on the object at\n  /// the given address.\n  void PushDestructorCleanup(const CXXDestructorDecl *Dtor, QualType T,\n                             Address Addr);\n\n  /// PopCleanupBlock - Will pop the cleanup entry on the stack and\n  /// process all branch fixups.\n  void PopCleanupBlock(bool FallThroughIsBranchThrough = false);\n\n  /// DeactivateCleanupBlock - Deactivates the given cleanup block.\n  /// The block cannot be reactivated.  Pops it if it's the top of the\n  /// stack.\n  ///\n  /// \\param DominatingIP - An instruction which is known to\n  ///   dominate the current IP (if set) and which lies along\n  ///   all paths of execution between the current IP and the\n  ///   the point at which the cleanup comes into scope.\n  void DeactivateCleanupBlock(EHScopeStack::stable_iterator Cleanup,\n                              llvm::Instruction *DominatingIP);\n\n  /// ActivateCleanupBlock - Activates an initially-inactive cleanup.\n  /// Cannot be used to resurrect a deactivated cleanup.\n  ///\n  /// \\param DominatingIP - An instruction which is known to\n  ///   dominate the current IP (if set) and which lies along\n  ///   all paths of execution between the current IP and the\n  ///   the point at which the cleanup comes into scope.\n  void ActivateCleanupBlock(EHScopeStack::stable_iterator Cleanup,\n                            llvm::Instruction *DominatingIP);\n\n  /// Enters a new scope for capturing cleanups, all of which\n  /// will be executed once the scope is exited.\n  class RunCleanupsScope {\n    EHScopeStack::stable_iterator CleanupStackDepth, OldCleanupScopeDepth;\n    size_t LifetimeExtendedCleanupStackSize;\n    bool OldDidCallStackSave;\n  protected:\n    bool PerformCleanup;\n  private:\n\n    RunCleanupsScope(const RunCleanupsScope &) = delete;\n    void operator=(const RunCleanupsScope &) = delete;\n\n  protected:\n    CodeGenFunction& CGF;\n\n  public:\n    /// Enter a new cleanup scope.\n    explicit RunCleanupsScope(CodeGenFunction &CGF)\n      : PerformCleanup(true), CGF(CGF)\n    {\n      CleanupStackDepth = CGF.EHStack.stable_begin();\n      LifetimeExtendedCleanupStackSize =\n          CGF.LifetimeExtendedCleanupStack.size();\n      OldDidCallStackSave = CGF.DidCallStackSave;\n      CGF.DidCallStackSave = false;\n      OldCleanupScopeDepth = CGF.CurrentCleanupScopeDepth;\n      CGF.CurrentCleanupScopeDepth = CleanupStackDepth;\n    }\n\n    /// Exit this cleanup scope, emitting any accumulated cleanups.\n    ~RunCleanupsScope() {\n      if (PerformCleanup)\n        ForceCleanup();\n    }\n\n    /// Determine whether this scope requires any cleanups.\n    bool requiresCleanups() const {\n      return CGF.EHStack.stable_begin() != CleanupStackDepth;\n    }\n\n    /// Force the emission of cleanups now, instead of waiting\n    /// until this object is destroyed.\n    /// \\param ValuesToReload - A list of values that need to be available at\n    /// the insertion point after cleanup emission. If cleanup emission created\n    /// a shared cleanup block, these value pointers will be rewritten.\n    /// Otherwise, they not will be modified.\n    void ForceCleanup(std::initializer_list<llvm::Value**> ValuesToReload = {}) {\n      assert(PerformCleanup && \"Already forced cleanup\");\n      CGF.DidCallStackSave = OldDidCallStackSave;\n      CGF.PopCleanupBlocks(CleanupStackDepth, LifetimeExtendedCleanupStackSize,\n                           ValuesToReload);\n      PerformCleanup = false;\n      CGF.CurrentCleanupScopeDepth = OldCleanupScopeDepth;\n    }\n  };\n\n  // Cleanup stack depth of the RunCleanupsScope that was pushed most recently.\n  EHScopeStack::stable_iterator CurrentCleanupScopeDepth =\n      EHScopeStack::stable_end();\n\n  class LexicalScope : public RunCleanupsScope {\n    SourceRange Range;\n    SmallVector<const LabelDecl*, 4> Labels;\n    LexicalScope *ParentScope;\n\n    LexicalScope(const LexicalScope &) = delete;\n    void operator=(const LexicalScope &) = delete;\n\n  public:\n    /// Enter a new cleanup scope.\n    explicit LexicalScope(CodeGenFunction &CGF, SourceRange Range)\n      : RunCleanupsScope(CGF), Range(Range), ParentScope(CGF.CurLexicalScope) {\n      CGF.CurLexicalScope = this;\n      if (CGDebugInfo *DI = CGF.getDebugInfo())\n        DI->EmitLexicalBlockStart(CGF.Builder, Range.getBegin());\n    }\n\n    void addLabel(const LabelDecl *label) {\n      assert(PerformCleanup && \"adding label to dead scope?\");\n      Labels.push_back(label);\n    }\n\n    /// Exit this cleanup scope, emitting any accumulated\n    /// cleanups.\n    ~LexicalScope() {\n      if (CGDebugInfo *DI = CGF.getDebugInfo())\n        DI->EmitLexicalBlockEnd(CGF.Builder, Range.getEnd());\n\n      // If we should perform a cleanup, force them now.  Note that\n      // this ends the cleanup scope before rescoping any labels.\n      if (PerformCleanup) {\n        ApplyDebugLocation DL(CGF, Range.getEnd());\n        ForceCleanup();\n      }\n    }\n\n    /// Force the emission of cleanups now, instead of waiting\n    /// until this object is destroyed.\n    void ForceCleanup() {\n      CGF.CurLexicalScope = ParentScope;\n      RunCleanupsScope::ForceCleanup();\n\n      if (!Labels.empty())\n        rescopeLabels();\n    }\n\n    bool hasLabels() const {\n      return !Labels.empty();\n    }\n\n    void rescopeLabels();\n  };\n\n  typedef llvm::DenseMap<const Decl *, Address> DeclMapTy;\n\n  /// The class used to assign some variables some temporarily addresses.\n  class OMPMapVars {\n    DeclMapTy SavedLocals;\n    DeclMapTy SavedTempAddresses;\n    OMPMapVars(const OMPMapVars &) = delete;\n    void operator=(const OMPMapVars &) = delete;\n\n  public:\n    explicit OMPMapVars() = default;\n    ~OMPMapVars() {\n      assert(SavedLocals.empty() && \"Did not restored original addresses.\");\n    };\n\n    /// Sets the address of the variable \\p LocalVD to be \\p TempAddr in\n    /// function \\p CGF.\n    /// \\return true if at least one variable was set already, false otherwise.\n    bool setVarAddr(CodeGenFunction &CGF, const VarDecl *LocalVD,\n                    Address TempAddr) {\n      LocalVD = LocalVD->getCanonicalDecl();\n      // Only save it once.\n      if (SavedLocals.count(LocalVD)) return false;\n\n      // Copy the existing local entry to SavedLocals.\n      auto it = CGF.LocalDeclMap.find(LocalVD);\n      if (it != CGF.LocalDeclMap.end())\n        SavedLocals.try_emplace(LocalVD, it->second);\n      else\n        SavedLocals.try_emplace(LocalVD, Address::invalid());\n\n      // Generate the private entry.\n      QualType VarTy = LocalVD->getType();\n      if (VarTy->isReferenceType()) {\n        Address Temp = CGF.CreateMemTemp(VarTy);\n        CGF.Builder.CreateStore(TempAddr.getPointer(), Temp);\n        TempAddr = Temp;\n      }\n      SavedTempAddresses.try_emplace(LocalVD, TempAddr);\n\n      return true;\n    }\n\n    /// Applies new addresses to the list of the variables.\n    /// \\return true if at least one variable is using new address, false\n    /// otherwise.\n    bool apply(CodeGenFunction &CGF) {\n      copyInto(SavedTempAddresses, CGF.LocalDeclMap);\n      SavedTempAddresses.clear();\n      return !SavedLocals.empty();\n    }\n\n    /// Restores original addresses of the variables.\n    void restore(CodeGenFunction &CGF) {\n      if (!SavedLocals.empty()) {\n        copyInto(SavedLocals, CGF.LocalDeclMap);\n        SavedLocals.clear();\n      }\n    }\n\n  private:\n    /// Copy all the entries in the source map over the corresponding\n    /// entries in the destination, which must exist.\n    static void copyInto(const DeclMapTy &Src, DeclMapTy &Dest) {\n      for (auto &Pair : Src) {\n        if (!Pair.second.isValid()) {\n          Dest.erase(Pair.first);\n          continue;\n        }\n\n        auto I = Dest.find(Pair.first);\n        if (I != Dest.end())\n          I->second = Pair.second;\n        else\n          Dest.insert(Pair);\n      }\n    }\n  };\n\n  /// The scope used to remap some variables as private in the OpenMP loop body\n  /// (or other captured region emitted without outlining), and to restore old\n  /// vars back on exit.\n  class OMPPrivateScope : public RunCleanupsScope {\n    OMPMapVars MappedVars;\n    OMPPrivateScope(const OMPPrivateScope &) = delete;\n    void operator=(const OMPPrivateScope &) = delete;\n\n  public:\n    /// Enter a new OpenMP private scope.\n    explicit OMPPrivateScope(CodeGenFunction &CGF) : RunCleanupsScope(CGF) {}\n\n    /// Registers \\p LocalVD variable as a private and apply \\p PrivateGen\n    /// function for it to generate corresponding private variable. \\p\n    /// PrivateGen returns an address of the generated private variable.\n    /// \\return true if the variable is registered as private, false if it has\n    /// been privatized already.\n    bool addPrivate(const VarDecl *LocalVD,\n                    const llvm::function_ref<Address()> PrivateGen) {\n      assert(PerformCleanup && \"adding private to dead scope\");\n      return MappedVars.setVarAddr(CGF, LocalVD, PrivateGen());\n    }\n\n    /// Privatizes local variables previously registered as private.\n    /// Registration is separate from the actual privatization to allow\n    /// initializers use values of the original variables, not the private one.\n    /// This is important, for example, if the private variable is a class\n    /// variable initialized by a constructor that references other private\n    /// variables. But at initialization original variables must be used, not\n    /// private copies.\n    /// \\return true if at least one variable was privatized, false otherwise.\n    bool Privatize() { return MappedVars.apply(CGF); }\n\n    void ForceCleanup() {\n      RunCleanupsScope::ForceCleanup();\n      MappedVars.restore(CGF);\n    }\n\n    /// Exit scope - all the mapped variables are restored.\n    ~OMPPrivateScope() {\n      if (PerformCleanup)\n        ForceCleanup();\n    }\n\n    /// Checks if the global variable is captured in current function.\n    bool isGlobalVarCaptured(const VarDecl *VD) const {\n      VD = VD->getCanonicalDecl();\n      return !VD->isLocalVarDeclOrParm() && CGF.LocalDeclMap.count(VD) > 0;\n    }\n  };\n\n  /// Save/restore original map of previously emitted local vars in case when we\n  /// need to duplicate emission of the same code several times in the same\n  /// function for OpenMP code.\n  class OMPLocalDeclMapRAII {\n    CodeGenFunction &CGF;\n    DeclMapTy SavedMap;\n\n  public:\n    OMPLocalDeclMapRAII(CodeGenFunction &CGF)\n        : CGF(CGF), SavedMap(CGF.LocalDeclMap) {}\n    ~OMPLocalDeclMapRAII() { SavedMap.swap(CGF.LocalDeclMap); }\n  };\n\n  /// Takes the old cleanup stack size and emits the cleanup blocks\n  /// that have been added.\n  void\n  PopCleanupBlocks(EHScopeStack::stable_iterator OldCleanupStackSize,\n                   std::initializer_list<llvm::Value **> ValuesToReload = {});\n\n  /// Takes the old cleanup stack size and emits the cleanup blocks\n  /// that have been added, then adds all lifetime-extended cleanups from\n  /// the given position to the stack.\n  void\n  PopCleanupBlocks(EHScopeStack::stable_iterator OldCleanupStackSize,\n                   size_t OldLifetimeExtendedStackSize,\n                   std::initializer_list<llvm::Value **> ValuesToReload = {});\n\n  void ResolveBranchFixups(llvm::BasicBlock *Target);\n\n  /// The given basic block lies in the current EH scope, but may be a\n  /// target of a potentially scope-crossing jump; get a stable handle\n  /// to which we can perform this jump later.\n  JumpDest getJumpDestInCurrentScope(llvm::BasicBlock *Target) {\n    return JumpDest(Target,\n                    EHStack.getInnermostNormalCleanup(),\n                    NextCleanupDestIndex++);\n  }\n\n  /// The given basic block lies in the current EH scope, but may be a\n  /// target of a potentially scope-crossing jump; get a stable handle\n  /// to which we can perform this jump later.\n  JumpDest getJumpDestInCurrentScope(StringRef Name = StringRef()) {\n    return getJumpDestInCurrentScope(createBasicBlock(Name));\n  }\n\n  /// EmitBranchThroughCleanup - Emit a branch from the current insert\n  /// block through the normal cleanup handling code (if any) and then\n  /// on to \\arg Dest.\n  void EmitBranchThroughCleanup(JumpDest Dest);\n\n  /// isObviouslyBranchWithoutCleanups - Return true if a branch to the\n  /// specified destination obviously has no cleanups to run.  'false' is always\n  /// a conservatively correct answer for this method.\n  bool isObviouslyBranchWithoutCleanups(JumpDest Dest) const;\n\n  /// popCatchScope - Pops the catch scope at the top of the EHScope\n  /// stack, emitting any required code (other than the catch handlers\n  /// themselves).\n  void popCatchScope();\n\n  llvm::BasicBlock *getEHResumeBlock(bool isCleanup);\n  llvm::BasicBlock *getEHDispatchBlock(EHScopeStack::stable_iterator scope);\n  llvm::BasicBlock *\n  getFuncletEHDispatchBlock(EHScopeStack::stable_iterator scope);\n\n  /// An object to manage conditionally-evaluated expressions.\n  class ConditionalEvaluation {\n    llvm::BasicBlock *StartBB;\n\n  public:\n    ConditionalEvaluation(CodeGenFunction &CGF)\n      : StartBB(CGF.Builder.GetInsertBlock()) {}\n\n    void begin(CodeGenFunction &CGF) {\n      assert(CGF.OutermostConditional != this);\n      if (!CGF.OutermostConditional)\n        CGF.OutermostConditional = this;\n    }\n\n    void end(CodeGenFunction &CGF) {\n      assert(CGF.OutermostConditional != nullptr);\n      if (CGF.OutermostConditional == this)\n        CGF.OutermostConditional = nullptr;\n    }\n\n    /// Returns a block which will be executed prior to each\n    /// evaluation of the conditional code.\n    llvm::BasicBlock *getStartingBlock() const {\n      return StartBB;\n    }\n  };\n\n  /// isInConditionalBranch - Return true if we're currently emitting\n  /// one branch or the other of a conditional expression.\n  bool isInConditionalBranch() const { return OutermostConditional != nullptr; }\n\n  void setBeforeOutermostConditional(llvm::Value *value, Address addr) {\n    assert(isInConditionalBranch());\n    llvm::BasicBlock *block = OutermostConditional->getStartingBlock();\n    auto store = new llvm::StoreInst(value, addr.getPointer(), &block->back());\n    store->setAlignment(addr.getAlignment().getAsAlign());\n  }\n\n  /// An RAII object to record that we're evaluating a statement\n  /// expression.\n  class StmtExprEvaluation {\n    CodeGenFunction &CGF;\n\n    /// We have to save the outermost conditional: cleanups in a\n    /// statement expression aren't conditional just because the\n    /// StmtExpr is.\n    ConditionalEvaluation *SavedOutermostConditional;\n\n  public:\n    StmtExprEvaluation(CodeGenFunction &CGF)\n      : CGF(CGF), SavedOutermostConditional(CGF.OutermostConditional) {\n      CGF.OutermostConditional = nullptr;\n    }\n\n    ~StmtExprEvaluation() {\n      CGF.OutermostConditional = SavedOutermostConditional;\n      CGF.EnsureInsertPoint();\n    }\n  };\n\n  /// An object which temporarily prevents a value from being\n  /// destroyed by aggressive peephole optimizations that assume that\n  /// all uses of a value have been realized in the IR.\n  class PeepholeProtection {\n    llvm::Instruction *Inst;\n    friend class CodeGenFunction;\n\n  public:\n    PeepholeProtection() : Inst(nullptr) {}\n  };\n\n  /// A non-RAII class containing all the information about a bound\n  /// opaque value.  OpaqueValueMapping, below, is a RAII wrapper for\n  /// this which makes individual mappings very simple; using this\n  /// class directly is useful when you have a variable number of\n  /// opaque values or don't want the RAII functionality for some\n  /// reason.\n  class OpaqueValueMappingData {\n    const OpaqueValueExpr *OpaqueValue;\n    bool BoundLValue;\n    CodeGenFunction::PeepholeProtection Protection;\n\n    OpaqueValueMappingData(const OpaqueValueExpr *ov,\n                           bool boundLValue)\n      : OpaqueValue(ov), BoundLValue(boundLValue) {}\n  public:\n    OpaqueValueMappingData() : OpaqueValue(nullptr) {}\n\n    static bool shouldBindAsLValue(const Expr *expr) {\n      // gl-values should be bound as l-values for obvious reasons.\n      // Records should be bound as l-values because IR generation\n      // always keeps them in memory.  Expressions of function type\n      // act exactly like l-values but are formally required to be\n      // r-values in C.\n      return expr->isGLValue() ||\n             expr->getType()->isFunctionType() ||\n             hasAggregateEvaluationKind(expr->getType());\n    }\n\n    static OpaqueValueMappingData bind(CodeGenFunction &CGF,\n                                       const OpaqueValueExpr *ov,\n                                       const Expr *e) {\n      if (shouldBindAsLValue(ov))\n        return bind(CGF, ov, CGF.EmitLValue(e));\n      return bind(CGF, ov, CGF.EmitAnyExpr(e));\n    }\n\n    static OpaqueValueMappingData bind(CodeGenFunction &CGF,\n                                       const OpaqueValueExpr *ov,\n                                       const LValue &lv) {\n      assert(shouldBindAsLValue(ov));\n      CGF.OpaqueLValues.insert(std::make_pair(ov, lv));\n      return OpaqueValueMappingData(ov, true);\n    }\n\n    static OpaqueValueMappingData bind(CodeGenFunction &CGF,\n                                       const OpaqueValueExpr *ov,\n                                       const RValue &rv) {\n      assert(!shouldBindAsLValue(ov));\n      CGF.OpaqueRValues.insert(std::make_pair(ov, rv));\n\n      OpaqueValueMappingData data(ov, false);\n\n      // Work around an extremely aggressive peephole optimization in\n      // EmitScalarConversion which assumes that all other uses of a\n      // value are extant.\n      data.Protection = CGF.protectFromPeepholes(rv);\n\n      return data;\n    }\n\n    bool isValid() const { return OpaqueValue != nullptr; }\n    void clear() { OpaqueValue = nullptr; }\n\n    void unbind(CodeGenFunction &CGF) {\n      assert(OpaqueValue && \"no data to unbind!\");\n\n      if (BoundLValue) {\n        CGF.OpaqueLValues.erase(OpaqueValue);\n      } else {\n        CGF.OpaqueRValues.erase(OpaqueValue);\n        CGF.unprotectFromPeepholes(Protection);\n      }\n    }\n  };\n\n  /// An RAII object to set (and then clear) a mapping for an OpaqueValueExpr.\n  class OpaqueValueMapping {\n    CodeGenFunction &CGF;\n    OpaqueValueMappingData Data;\n\n  public:\n    static bool shouldBindAsLValue(const Expr *expr) {\n      return OpaqueValueMappingData::shouldBindAsLValue(expr);\n    }\n\n    /// Build the opaque value mapping for the given conditional\n    /// operator if it's the GNU ?: extension.  This is a common\n    /// enough pattern that the convenience operator is really\n    /// helpful.\n    ///\n    OpaqueValueMapping(CodeGenFunction &CGF,\n                       const AbstractConditionalOperator *op) : CGF(CGF) {\n      if (isa<ConditionalOperator>(op))\n        // Leave Data empty.\n        return;\n\n      const BinaryConditionalOperator *e = cast<BinaryConditionalOperator>(op);\n      Data = OpaqueValueMappingData::bind(CGF, e->getOpaqueValue(),\n                                          e->getCommon());\n    }\n\n    /// Build the opaque value mapping for an OpaqueValueExpr whose source\n    /// expression is set to the expression the OVE represents.\n    OpaqueValueMapping(CodeGenFunction &CGF, const OpaqueValueExpr *OV)\n        : CGF(CGF) {\n      if (OV) {\n        assert(OV->getSourceExpr() && \"wrong form of OpaqueValueMapping used \"\n                                      \"for OVE with no source expression\");\n        Data = OpaqueValueMappingData::bind(CGF, OV, OV->getSourceExpr());\n      }\n    }\n\n    OpaqueValueMapping(CodeGenFunction &CGF,\n                       const OpaqueValueExpr *opaqueValue,\n                       LValue lvalue)\n      : CGF(CGF), Data(OpaqueValueMappingData::bind(CGF, opaqueValue, lvalue)) {\n    }\n\n    OpaqueValueMapping(CodeGenFunction &CGF,\n                       const OpaqueValueExpr *opaqueValue,\n                       RValue rvalue)\n      : CGF(CGF), Data(OpaqueValueMappingData::bind(CGF, opaqueValue, rvalue)) {\n    }\n\n    void pop() {\n      Data.unbind(CGF);\n      Data.clear();\n    }\n\n    ~OpaqueValueMapping() {\n      if (Data.isValid()) Data.unbind(CGF);\n    }\n  };\n\nprivate:\n  CGDebugInfo *DebugInfo;\n  /// Used to create unique names for artificial VLA size debug info variables.\n  unsigned VLAExprCounter = 0;\n  bool DisableDebugInfo = false;\n\n  /// DidCallStackSave - Whether llvm.stacksave has been called. Used to avoid\n  /// calling llvm.stacksave for multiple VLAs in the same scope.\n  bool DidCallStackSave = false;\n\n  /// IndirectBranch - The first time an indirect goto is seen we create a block\n  /// with an indirect branch.  Every time we see the address of a label taken,\n  /// we add the label to the indirect goto.  Every subsequent indirect goto is\n  /// codegen'd as a jump to the IndirectBranch's basic block.\n  llvm::IndirectBrInst *IndirectBranch = nullptr;\n\n  /// LocalDeclMap - This keeps track of the LLVM allocas or globals for local C\n  /// decls.\n  DeclMapTy LocalDeclMap;\n\n  // Keep track of the cleanups for callee-destructed parameters pushed to the\n  // cleanup stack so that they can be deactivated later.\n  llvm::DenseMap<const ParmVarDecl *, EHScopeStack::stable_iterator>\n      CalleeDestructedParamCleanups;\n\n  /// SizeArguments - If a ParmVarDecl had the pass_object_size attribute, this\n  /// will contain a mapping from said ParmVarDecl to its implicit \"object_size\"\n  /// parameter.\n  llvm::SmallDenseMap<const ParmVarDecl *, const ImplicitParamDecl *, 2>\n      SizeArguments;\n\n  /// Track escaped local variables with auto storage. Used during SEH\n  /// outlining to produce a call to llvm.localescape.\n  llvm::DenseMap<llvm::AllocaInst *, int> EscapedLocals;\n\n  /// LabelMap - This keeps track of the LLVM basic block for each C label.\n  llvm::DenseMap<const LabelDecl*, JumpDest> LabelMap;\n\n  // BreakContinueStack - This keeps track of where break and continue\n  // statements should jump to.\n  struct BreakContinue {\n    BreakContinue(JumpDest Break, JumpDest Continue)\n      : BreakBlock(Break), ContinueBlock(Continue) {}\n\n    JumpDest BreakBlock;\n    JumpDest ContinueBlock;\n  };\n  SmallVector<BreakContinue, 8> BreakContinueStack;\n\n  /// Handles cancellation exit points in OpenMP-related constructs.\n  class OpenMPCancelExitStack {\n    /// Tracks cancellation exit point and join point for cancel-related exit\n    /// and normal exit.\n    struct CancelExit {\n      CancelExit() = default;\n      CancelExit(OpenMPDirectiveKind Kind, JumpDest ExitBlock,\n                 JumpDest ContBlock)\n          : Kind(Kind), ExitBlock(ExitBlock), ContBlock(ContBlock) {}\n      OpenMPDirectiveKind Kind = llvm::omp::OMPD_unknown;\n      /// true if the exit block has been emitted already by the special\n      /// emitExit() call, false if the default codegen is used.\n      bool HasBeenEmitted = false;\n      JumpDest ExitBlock;\n      JumpDest ContBlock;\n    };\n\n    SmallVector<CancelExit, 8> Stack;\n\n  public:\n    OpenMPCancelExitStack() : Stack(1) {}\n    ~OpenMPCancelExitStack() = default;\n    /// Fetches the exit block for the current OpenMP construct.\n    JumpDest getExitBlock() const { return Stack.back().ExitBlock; }\n    /// Emits exit block with special codegen procedure specific for the related\n    /// OpenMP construct + emits code for normal construct cleanup.\n    void emitExit(CodeGenFunction &CGF, OpenMPDirectiveKind Kind,\n                  const llvm::function_ref<void(CodeGenFunction &)> CodeGen) {\n      if (Stack.back().Kind == Kind && getExitBlock().isValid()) {\n        assert(CGF.getOMPCancelDestination(Kind).isValid());\n        assert(CGF.HaveInsertPoint());\n        assert(!Stack.back().HasBeenEmitted);\n        auto IP = CGF.Builder.saveAndClearIP();\n        CGF.EmitBlock(Stack.back().ExitBlock.getBlock());\n        CodeGen(CGF);\n        CGF.EmitBranch(Stack.back().ContBlock.getBlock());\n        CGF.Builder.restoreIP(IP);\n        Stack.back().HasBeenEmitted = true;\n      }\n      CodeGen(CGF);\n    }\n    /// Enter the cancel supporting \\a Kind construct.\n    /// \\param Kind OpenMP directive that supports cancel constructs.\n    /// \\param HasCancel true, if the construct has inner cancel directive,\n    /// false otherwise.\n    void enter(CodeGenFunction &CGF, OpenMPDirectiveKind Kind, bool HasCancel) {\n      Stack.push_back({Kind,\n                       HasCancel ? CGF.getJumpDestInCurrentScope(\"cancel.exit\")\n                                 : JumpDest(),\n                       HasCancel ? CGF.getJumpDestInCurrentScope(\"cancel.cont\")\n                                 : JumpDest()});\n    }\n    /// Emits default exit point for the cancel construct (if the special one\n    /// has not be used) + join point for cancel/normal exits.\n    void exit(CodeGenFunction &CGF) {\n      if (getExitBlock().isValid()) {\n        assert(CGF.getOMPCancelDestination(Stack.back().Kind).isValid());\n        bool HaveIP = CGF.HaveInsertPoint();\n        if (!Stack.back().HasBeenEmitted) {\n          if (HaveIP)\n            CGF.EmitBranchThroughCleanup(Stack.back().ContBlock);\n          CGF.EmitBlock(Stack.back().ExitBlock.getBlock());\n          CGF.EmitBranchThroughCleanup(Stack.back().ContBlock);\n        }\n        CGF.EmitBlock(Stack.back().ContBlock.getBlock());\n        if (!HaveIP) {\n          CGF.Builder.CreateUnreachable();\n          CGF.Builder.ClearInsertionPoint();\n        }\n      }\n      Stack.pop_back();\n    }\n  };\n  OpenMPCancelExitStack OMPCancelStack;\n\n  /// Calculate branch weights for the likelihood attribute\n  llvm::MDNode *createBranchWeights(Stmt::Likelihood LH) const;\n\n  CodeGenPGO PGO;\n\n  /// Calculate branch weights appropriate for PGO data\n  llvm::MDNode *createProfileWeights(uint64_t TrueCount,\n                                     uint64_t FalseCount) const;\n  llvm::MDNode *createProfileWeights(ArrayRef<uint64_t> Weights) const;\n  llvm::MDNode *createProfileWeightsForLoop(const Stmt *Cond,\n                                            uint64_t LoopCount) const;\n\n  /// Calculate the branch weight for PGO data or the likelihood attribute.\n  /// The function tries to get the weight of \\ref createProfileWeightsForLoop.\n  /// If that fails it gets the weight of \\ref createBranchWeights.\n  llvm::MDNode *createProfileOrBranchWeightsForLoop(const Stmt *Cond,\n                                                    uint64_t LoopCount,\n                                                    const Stmt *Body) const;\n\npublic:\n  /// Increment the profiler's counter for the given statement by \\p StepV.\n  /// If \\p StepV is null, the default increment is 1.\n  void incrementProfileCounter(const Stmt *S, llvm::Value *StepV = nullptr) {\n    if (CGM.getCodeGenOpts().hasProfileClangInstr() &&\n        !CurFn->hasFnAttribute(llvm::Attribute::NoProfile))\n      PGO.emitCounterIncrement(Builder, S, StepV);\n    PGO.setCurrentStmt(S);\n  }\n\n  /// Get the profiler's count for the given statement.\n  uint64_t getProfileCount(const Stmt *S) {\n    Optional<uint64_t> Count = PGO.getStmtCount(S);\n    if (!Count.hasValue())\n      return 0;\n    return *Count;\n  }\n\n  /// Set the profiler's current count.\n  void setCurrentProfileCount(uint64_t Count) {\n    PGO.setCurrentRegionCount(Count);\n  }\n\n  /// Get the profiler's current count. This is generally the count for the most\n  /// recently incremented counter.\n  uint64_t getCurrentProfileCount() {\n    return PGO.getCurrentRegionCount();\n  }\n\nprivate:\n\n  /// SwitchInsn - This is nearest current switch instruction. It is null if\n  /// current context is not in a switch.\n  llvm::SwitchInst *SwitchInsn = nullptr;\n  /// The branch weights of SwitchInsn when doing instrumentation based PGO.\n  SmallVector<uint64_t, 16> *SwitchWeights = nullptr;\n\n  /// The likelihood attributes of the SwitchCase.\n  SmallVector<Stmt::Likelihood, 16> *SwitchLikelihood = nullptr;\n\n  /// CaseRangeBlock - This block holds if condition check for last case\n  /// statement range in current switch instruction.\n  llvm::BasicBlock *CaseRangeBlock = nullptr;\n\n  /// OpaqueLValues - Keeps track of the current set of opaque value\n  /// expressions.\n  llvm::DenseMap<const OpaqueValueExpr *, LValue> OpaqueLValues;\n  llvm::DenseMap<const OpaqueValueExpr *, RValue> OpaqueRValues;\n\n  // VLASizeMap - This keeps track of the associated size for each VLA type.\n  // We track this by the size expression rather than the type itself because\n  // in certain situations, like a const qualifier applied to an VLA typedef,\n  // multiple VLA types can share the same size expression.\n  // FIXME: Maybe this could be a stack of maps that is pushed/popped as we\n  // enter/leave scopes.\n  llvm::DenseMap<const Expr*, llvm::Value*> VLASizeMap;\n\n  /// A block containing a single 'unreachable' instruction.  Created\n  /// lazily by getUnreachableBlock().\n  llvm::BasicBlock *UnreachableBlock = nullptr;\n\n  /// Counts of the number return expressions in the function.\n  unsigned NumReturnExprs = 0;\n\n  /// Count the number of simple (constant) return expressions in the function.\n  unsigned NumSimpleReturnExprs = 0;\n\n  /// The last regular (non-return) debug location (breakpoint) in the function.\n  SourceLocation LastStopPoint;\n\npublic:\n  /// Source location information about the default argument or member\n  /// initializer expression we're evaluating, if any.\n  CurrentSourceLocExprScope CurSourceLocExprScope;\n  using SourceLocExprScopeGuard =\n      CurrentSourceLocExprScope::SourceLocExprScopeGuard;\n\n  /// A scope within which we are constructing the fields of an object which\n  /// might use a CXXDefaultInitExpr. This stashes away a 'this' value to use\n  /// if we need to evaluate a CXXDefaultInitExpr within the evaluation.\n  class FieldConstructionScope {\n  public:\n    FieldConstructionScope(CodeGenFunction &CGF, Address This)\n        : CGF(CGF), OldCXXDefaultInitExprThis(CGF.CXXDefaultInitExprThis) {\n      CGF.CXXDefaultInitExprThis = This;\n    }\n    ~FieldConstructionScope() {\n      CGF.CXXDefaultInitExprThis = OldCXXDefaultInitExprThis;\n    }\n\n  private:\n    CodeGenFunction &CGF;\n    Address OldCXXDefaultInitExprThis;\n  };\n\n  /// The scope of a CXXDefaultInitExpr. Within this scope, the value of 'this'\n  /// is overridden to be the object under construction.\n  class CXXDefaultInitExprScope  {\n  public:\n    CXXDefaultInitExprScope(CodeGenFunction &CGF, const CXXDefaultInitExpr *E)\n        : CGF(CGF), OldCXXThisValue(CGF.CXXThisValue),\n          OldCXXThisAlignment(CGF.CXXThisAlignment),\n          SourceLocScope(E, CGF.CurSourceLocExprScope) {\n      CGF.CXXThisValue = CGF.CXXDefaultInitExprThis.getPointer();\n      CGF.CXXThisAlignment = CGF.CXXDefaultInitExprThis.getAlignment();\n    }\n    ~CXXDefaultInitExprScope() {\n      CGF.CXXThisValue = OldCXXThisValue;\n      CGF.CXXThisAlignment = OldCXXThisAlignment;\n    }\n\n  public:\n    CodeGenFunction &CGF;\n    llvm::Value *OldCXXThisValue;\n    CharUnits OldCXXThisAlignment;\n    SourceLocExprScopeGuard SourceLocScope;\n  };\n\n  struct CXXDefaultArgExprScope : SourceLocExprScopeGuard {\n    CXXDefaultArgExprScope(CodeGenFunction &CGF, const CXXDefaultArgExpr *E)\n        : SourceLocExprScopeGuard(E, CGF.CurSourceLocExprScope) {}\n  };\n\n  /// The scope of an ArrayInitLoopExpr. Within this scope, the value of the\n  /// current loop index is overridden.\n  class ArrayInitLoopExprScope {\n  public:\n    ArrayInitLoopExprScope(CodeGenFunction &CGF, llvm::Value *Index)\n      : CGF(CGF), OldArrayInitIndex(CGF.ArrayInitIndex) {\n      CGF.ArrayInitIndex = Index;\n    }\n    ~ArrayInitLoopExprScope() {\n      CGF.ArrayInitIndex = OldArrayInitIndex;\n    }\n\n  private:\n    CodeGenFunction &CGF;\n    llvm::Value *OldArrayInitIndex;\n  };\n\n  class InlinedInheritingConstructorScope {\n  public:\n    InlinedInheritingConstructorScope(CodeGenFunction &CGF, GlobalDecl GD)\n        : CGF(CGF), OldCurGD(CGF.CurGD), OldCurFuncDecl(CGF.CurFuncDecl),\n          OldCurCodeDecl(CGF.CurCodeDecl),\n          OldCXXABIThisDecl(CGF.CXXABIThisDecl),\n          OldCXXABIThisValue(CGF.CXXABIThisValue),\n          OldCXXThisValue(CGF.CXXThisValue),\n          OldCXXABIThisAlignment(CGF.CXXABIThisAlignment),\n          OldCXXThisAlignment(CGF.CXXThisAlignment),\n          OldReturnValue(CGF.ReturnValue), OldFnRetTy(CGF.FnRetTy),\n          OldCXXInheritedCtorInitExprArgs(\n              std::move(CGF.CXXInheritedCtorInitExprArgs)) {\n      CGF.CurGD = GD;\n      CGF.CurFuncDecl = CGF.CurCodeDecl =\n          cast<CXXConstructorDecl>(GD.getDecl());\n      CGF.CXXABIThisDecl = nullptr;\n      CGF.CXXABIThisValue = nullptr;\n      CGF.CXXThisValue = nullptr;\n      CGF.CXXABIThisAlignment = CharUnits();\n      CGF.CXXThisAlignment = CharUnits();\n      CGF.ReturnValue = Address::invalid();\n      CGF.FnRetTy = QualType();\n      CGF.CXXInheritedCtorInitExprArgs.clear();\n    }\n    ~InlinedInheritingConstructorScope() {\n      CGF.CurGD = OldCurGD;\n      CGF.CurFuncDecl = OldCurFuncDecl;\n      CGF.CurCodeDecl = OldCurCodeDecl;\n      CGF.CXXABIThisDecl = OldCXXABIThisDecl;\n      CGF.CXXABIThisValue = OldCXXABIThisValue;\n      CGF.CXXThisValue = OldCXXThisValue;\n      CGF.CXXABIThisAlignment = OldCXXABIThisAlignment;\n      CGF.CXXThisAlignment = OldCXXThisAlignment;\n      CGF.ReturnValue = OldReturnValue;\n      CGF.FnRetTy = OldFnRetTy;\n      CGF.CXXInheritedCtorInitExprArgs =\n          std::move(OldCXXInheritedCtorInitExprArgs);\n    }\n\n  private:\n    CodeGenFunction &CGF;\n    GlobalDecl OldCurGD;\n    const Decl *OldCurFuncDecl;\n    const Decl *OldCurCodeDecl;\n    ImplicitParamDecl *OldCXXABIThisDecl;\n    llvm::Value *OldCXXABIThisValue;\n    llvm::Value *OldCXXThisValue;\n    CharUnits OldCXXABIThisAlignment;\n    CharUnits OldCXXThisAlignment;\n    Address OldReturnValue;\n    QualType OldFnRetTy;\n    CallArgList OldCXXInheritedCtorInitExprArgs;\n  };\n\n  // Helper class for the OpenMP IR Builder. Allows reusability of code used for\n  // region body, and finalization codegen callbacks. This will class will also\n  // contain privatization functions used by the privatization call backs\n  //\n  // TODO: this is temporary class for things that are being moved out of\n  // CGOpenMPRuntime, new versions of current CodeGenFunction methods, or\n  // utility function for use with the OMPBuilder. Once that move to use the\n  // OMPBuilder is done, everything here will either become part of CodeGenFunc.\n  // directly, or a new helper class that will contain functions used by both\n  // this and the OMPBuilder\n\n  struct OMPBuilderCBHelpers {\n\n    OMPBuilderCBHelpers() = delete;\n    OMPBuilderCBHelpers(const OMPBuilderCBHelpers &) = delete;\n    OMPBuilderCBHelpers &operator=(const OMPBuilderCBHelpers &) = delete;\n\n    using InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;\n\n    /// Cleanup action for allocate support.\n    class OMPAllocateCleanupTy final : public EHScopeStack::Cleanup {\n\n    private:\n      llvm::CallInst *RTLFnCI;\n\n    public:\n      OMPAllocateCleanupTy(llvm::CallInst *RLFnCI) : RTLFnCI(RLFnCI) {\n        RLFnCI->removeFromParent();\n      }\n\n      void Emit(CodeGenFunction &CGF, Flags /*flags*/) override {\n        if (!CGF.HaveInsertPoint())\n          return;\n        CGF.Builder.Insert(RTLFnCI);\n      }\n    };\n\n    /// Returns address of the threadprivate variable for the current\n    /// thread. This Also create any necessary OMP runtime calls.\n    ///\n    /// \\param VD VarDecl for Threadprivate variable.\n    /// \\param VDAddr Address of the Vardecl\n    /// \\param Loc  The location where the barrier directive was encountered\n    static Address getAddrOfThreadPrivate(CodeGenFunction &CGF,\n                                          const VarDecl *VD, Address VDAddr,\n                                          SourceLocation Loc);\n\n    /// Gets the OpenMP-specific address of the local variable /p VD.\n    static Address getAddressOfLocalVariable(CodeGenFunction &CGF,\n                                             const VarDecl *VD);\n    /// Get the platform-specific name separator.\n    /// \\param Parts different parts of the final name that needs separation\n    /// \\param FirstSeparator First separator used between the initial two\n    ///        parts of the name.\n    /// \\param Separator separator used between all of the rest consecutinve\n    ///        parts of the name\n    static std::string getNameWithSeparators(ArrayRef<StringRef> Parts,\n                                             StringRef FirstSeparator = \".\",\n                                             StringRef Separator = \".\");\n    /// Emit the Finalization for an OMP region\n    /// \\param CGF\tThe Codegen function this belongs to\n    /// \\param IP\tInsertion point for generating the finalization code.\n    static void FinalizeOMPRegion(CodeGenFunction &CGF, InsertPointTy IP) {\n      CGBuilderTy::InsertPointGuard IPG(CGF.Builder);\n      assert(IP.getBlock()->end() != IP.getPoint() &&\n             \"OpenMP IR Builder should cause terminated block!\");\n\n      llvm::BasicBlock *IPBB = IP.getBlock();\n      llvm::BasicBlock *DestBB = IPBB->getUniqueSuccessor();\n      assert(DestBB && \"Finalization block should have one successor!\");\n\n      // erase and replace with cleanup branch.\n      IPBB->getTerminator()->eraseFromParent();\n      CGF.Builder.SetInsertPoint(IPBB);\n      CodeGenFunction::JumpDest Dest = CGF.getJumpDestInCurrentScope(DestBB);\n      CGF.EmitBranchThroughCleanup(Dest);\n    }\n\n    /// Emit the body of an OMP region\n    /// \\param CGF\tThe Codegen function this belongs to\n    /// \\param RegionBodyStmt\tThe body statement for the OpenMP region being\n    /// \t\t\t generated\n    /// \\param CodeGenIP\tInsertion point for generating the body code.\n    /// \\param FiniBB\tThe finalization basic block\n    static void EmitOMPRegionBody(CodeGenFunction &CGF,\n                                  const Stmt *RegionBodyStmt,\n                                  InsertPointTy CodeGenIP,\n                                  llvm::BasicBlock &FiniBB) {\n      llvm::BasicBlock *CodeGenIPBB = CodeGenIP.getBlock();\n      if (llvm::Instruction *CodeGenIPBBTI = CodeGenIPBB->getTerminator())\n        CodeGenIPBBTI->eraseFromParent();\n\n      CGF.Builder.SetInsertPoint(CodeGenIPBB);\n\n      CGF.EmitStmt(RegionBodyStmt);\n\n      if (CGF.Builder.saveIP().isSet())\n        CGF.Builder.CreateBr(&FiniBB);\n    }\n\n    /// RAII for preserving necessary info during Outlined region body codegen.\n    class OutlinedRegionBodyRAII {\n\n      llvm::AssertingVH<llvm::Instruction> OldAllocaIP;\n      CodeGenFunction::JumpDest OldReturnBlock;\n      CGBuilderTy::InsertPoint IP;\n      CodeGenFunction &CGF;\n\n    public:\n      OutlinedRegionBodyRAII(CodeGenFunction &cgf, InsertPointTy &AllocaIP,\n                             llvm::BasicBlock &RetBB)\n          : CGF(cgf) {\n        assert(AllocaIP.isSet() &&\n               \"Must specify Insertion point for allocas of outlined function\");\n        OldAllocaIP = CGF.AllocaInsertPt;\n        CGF.AllocaInsertPt = &*AllocaIP.getPoint();\n        IP = CGF.Builder.saveIP();\n\n        OldReturnBlock = CGF.ReturnBlock;\n        CGF.ReturnBlock = CGF.getJumpDestInCurrentScope(&RetBB);\n      }\n\n      ~OutlinedRegionBodyRAII() {\n        CGF.AllocaInsertPt = OldAllocaIP;\n        CGF.ReturnBlock = OldReturnBlock;\n        CGF.Builder.restoreIP(IP);\n      }\n    };\n\n    /// RAII for preserving necessary info during inlined region body codegen.\n    class InlinedRegionBodyRAII {\n\n      llvm::AssertingVH<llvm::Instruction> OldAllocaIP;\n      CodeGenFunction &CGF;\n\n    public:\n      InlinedRegionBodyRAII(CodeGenFunction &cgf, InsertPointTy &AllocaIP,\n                            llvm::BasicBlock &FiniBB)\n          : CGF(cgf) {\n        // Alloca insertion block should be in the entry block of the containing\n        // function so it expects an empty AllocaIP in which case will reuse the\n        // old alloca insertion point, or a new AllocaIP in the same block as\n        // the old one\n        assert((!AllocaIP.isSet() ||\n                CGF.AllocaInsertPt->getParent() == AllocaIP.getBlock()) &&\n               \"Insertion point should be in the entry block of containing \"\n               \"function!\");\n        OldAllocaIP = CGF.AllocaInsertPt;\n        if (AllocaIP.isSet())\n          CGF.AllocaInsertPt = &*AllocaIP.getPoint();\n\n        // TODO: Remove the call, after making sure the counter is not used by\n        //       the EHStack.\n        // Since this is an inlined region, it should not modify the\n        // ReturnBlock, and should reuse the one for the enclosing outlined\n        // region. So, the JumpDest being return by the function is discarded\n        (void)CGF.getJumpDestInCurrentScope(&FiniBB);\n      }\n\n      ~InlinedRegionBodyRAII() { CGF.AllocaInsertPt = OldAllocaIP; }\n    };\n  };\n\nprivate:\n  /// CXXThisDecl - When generating code for a C++ member function,\n  /// this will hold the implicit 'this' declaration.\n  ImplicitParamDecl *CXXABIThisDecl = nullptr;\n  llvm::Value *CXXABIThisValue = nullptr;\n  llvm::Value *CXXThisValue = nullptr;\n  CharUnits CXXABIThisAlignment;\n  CharUnits CXXThisAlignment;\n\n  /// The value of 'this' to use when evaluating CXXDefaultInitExprs within\n  /// this expression.\n  Address CXXDefaultInitExprThis = Address::invalid();\n\n  /// The current array initialization index when evaluating an\n  /// ArrayInitIndexExpr within an ArrayInitLoopExpr.\n  llvm::Value *ArrayInitIndex = nullptr;\n\n  /// The values of function arguments to use when evaluating\n  /// CXXInheritedCtorInitExprs within this context.\n  CallArgList CXXInheritedCtorInitExprArgs;\n\n  /// CXXStructorImplicitParamDecl - When generating code for a constructor or\n  /// destructor, this will hold the implicit argument (e.g. VTT).\n  ImplicitParamDecl *CXXStructorImplicitParamDecl = nullptr;\n  llvm::Value *CXXStructorImplicitParamValue = nullptr;\n\n  /// OutermostConditional - Points to the outermost active\n  /// conditional control.  This is used so that we know if a\n  /// temporary should be destroyed conditionally.\n  ConditionalEvaluation *OutermostConditional = nullptr;\n\n  /// The current lexical scope.\n  LexicalScope *CurLexicalScope = nullptr;\n\n  /// The current source location that should be used for exception\n  /// handling code.\n  SourceLocation CurEHLocation;\n\n  /// BlockByrefInfos - For each __block variable, contains\n  /// information about the layout of the variable.\n  llvm::DenseMap<const ValueDecl *, BlockByrefInfo> BlockByrefInfos;\n\n  /// Used by -fsanitize=nullability-return to determine whether the return\n  /// value can be checked.\n  llvm::Value *RetValNullabilityPrecondition = nullptr;\n\n  /// Check if -fsanitize=nullability-return instrumentation is required for\n  /// this function.\n  bool requiresReturnValueNullabilityCheck() const {\n    return RetValNullabilityPrecondition;\n  }\n\n  /// Used to store precise source locations for return statements by the\n  /// runtime return value checks.\n  Address ReturnLocation = Address::invalid();\n\n  /// Check if the return value of this function requires sanitization.\n  bool requiresReturnValueCheck() const;\n\n  llvm::BasicBlock *TerminateLandingPad = nullptr;\n  llvm::BasicBlock *TerminateHandler = nullptr;\n  llvm::SmallVector<llvm::BasicBlock *, 2> TrapBBs;\n\n  /// Terminate funclets keyed by parent funclet pad.\n  llvm::MapVector<llvm::Value *, llvm::BasicBlock *> TerminateFunclets;\n\n  /// Largest vector width used in ths function. Will be used to create a\n  /// function attribute.\n  unsigned LargestVectorWidth = 0;\n\n  /// True if we need emit the life-time markers.\n  const bool ShouldEmitLifetimeMarkers;\n\n  /// Add OpenCL kernel arg metadata and the kernel attribute metadata to\n  /// the function metadata.\n  void EmitOpenCLKernelMetadata(const FunctionDecl *FD,\n                                llvm::Function *Fn);\n\npublic:\n  CodeGenFunction(CodeGenModule &cgm, bool suppressNewContext=false);\n  ~CodeGenFunction();\n\n  CodeGenTypes &getTypes() const { return CGM.getTypes(); }\n  ASTContext &getContext() const { return CGM.getContext(); }\n  CGDebugInfo *getDebugInfo() {\n    if (DisableDebugInfo)\n      return nullptr;\n    return DebugInfo;\n  }\n  void disableDebugInfo() { DisableDebugInfo = true; }\n  void enableDebugInfo() { DisableDebugInfo = false; }\n\n  bool shouldUseFusedARCCalls() {\n    return CGM.getCodeGenOpts().OptimizationLevel == 0;\n  }\n\n  const LangOptions &getLangOpts() const { return CGM.getLangOpts(); }\n\n  /// Returns a pointer to the function's exception object and selector slot,\n  /// which is assigned in every landing pad.\n  Address getExceptionSlot();\n  Address getEHSelectorSlot();\n\n  /// Returns the contents of the function's exception object and selector\n  /// slots.\n  llvm::Value *getExceptionFromSlot();\n  llvm::Value *getSelectorFromSlot();\n\n  Address getNormalCleanupDestSlot();\n\n  llvm::BasicBlock *getUnreachableBlock() {\n    if (!UnreachableBlock) {\n      UnreachableBlock = createBasicBlock(\"unreachable\");\n      new llvm::UnreachableInst(getLLVMContext(), UnreachableBlock);\n    }\n    return UnreachableBlock;\n  }\n\n  llvm::BasicBlock *getInvokeDest() {\n    if (!EHStack.requiresLandingPad()) return nullptr;\n    return getInvokeDestImpl();\n  }\n\n  bool currentFunctionUsesSEHTry() const { return CurSEHParent != nullptr; }\n\n  const TargetInfo &getTarget() const { return Target; }\n  llvm::LLVMContext &getLLVMContext() { return CGM.getLLVMContext(); }\n  const TargetCodeGenInfo &getTargetHooks() const {\n    return CGM.getTargetCodeGenInfo();\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                                  Cleanups\n  //===--------------------------------------------------------------------===//\n\n  typedef void Destroyer(CodeGenFunction &CGF, Address addr, QualType ty);\n\n  void pushIrregularPartialArrayCleanup(llvm::Value *arrayBegin,\n                                        Address arrayEndPointer,\n                                        QualType elementType,\n                                        CharUnits elementAlignment,\n                                        Destroyer *destroyer);\n  void pushRegularPartialArrayCleanup(llvm::Value *arrayBegin,\n                                      llvm::Value *arrayEnd,\n                                      QualType elementType,\n                                      CharUnits elementAlignment,\n                                      Destroyer *destroyer);\n\n  void pushDestroy(QualType::DestructionKind dtorKind,\n                   Address addr, QualType type);\n  void pushEHDestroy(QualType::DestructionKind dtorKind,\n                     Address addr, QualType type);\n  void pushDestroy(CleanupKind kind, Address addr, QualType type,\n                   Destroyer *destroyer, bool useEHCleanupForArray);\n  void pushLifetimeExtendedDestroy(CleanupKind kind, Address addr,\n                                   QualType type, Destroyer *destroyer,\n                                   bool useEHCleanupForArray);\n  void pushCallObjectDeleteCleanup(const FunctionDecl *OperatorDelete,\n                                   llvm::Value *CompletePtr,\n                                   QualType ElementType);\n  void pushStackRestore(CleanupKind kind, Address SPMem);\n  void emitDestroy(Address addr, QualType type, Destroyer *destroyer,\n                   bool useEHCleanupForArray);\n  llvm::Function *generateDestroyHelper(Address addr, QualType type,\n                                        Destroyer *destroyer,\n                                        bool useEHCleanupForArray,\n                                        const VarDecl *VD);\n  void emitArrayDestroy(llvm::Value *begin, llvm::Value *end,\n                        QualType elementType, CharUnits elementAlign,\n                        Destroyer *destroyer,\n                        bool checkZeroLength, bool useEHCleanup);\n\n  Destroyer *getDestroyer(QualType::DestructionKind destructionKind);\n\n  /// Determines whether an EH cleanup is required to destroy a type\n  /// with the given destruction kind.\n  bool needsEHCleanup(QualType::DestructionKind kind) {\n    switch (kind) {\n    case QualType::DK_none:\n      return false;\n    case QualType::DK_cxx_destructor:\n    case QualType::DK_objc_weak_lifetime:\n    case QualType::DK_nontrivial_c_struct:\n      return getLangOpts().Exceptions;\n    case QualType::DK_objc_strong_lifetime:\n      return getLangOpts().Exceptions &&\n             CGM.getCodeGenOpts().ObjCAutoRefCountExceptions;\n    }\n    llvm_unreachable(\"bad destruction kind\");\n  }\n\n  CleanupKind getCleanupKind(QualType::DestructionKind kind) {\n    return (needsEHCleanup(kind) ? NormalAndEHCleanup : NormalCleanup);\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                                  Objective-C\n  //===--------------------------------------------------------------------===//\n\n  void GenerateObjCMethod(const ObjCMethodDecl *OMD);\n\n  void StartObjCMethod(const ObjCMethodDecl *MD, const ObjCContainerDecl *CD);\n\n  /// GenerateObjCGetter - Synthesize an Objective-C property getter function.\n  void GenerateObjCGetter(ObjCImplementationDecl *IMP,\n                          const ObjCPropertyImplDecl *PID);\n  void generateObjCGetterBody(const ObjCImplementationDecl *classImpl,\n                              const ObjCPropertyImplDecl *propImpl,\n                              const ObjCMethodDecl *GetterMothodDecl,\n                              llvm::Constant *AtomicHelperFn);\n\n  void GenerateObjCCtorDtorMethod(ObjCImplementationDecl *IMP,\n                                  ObjCMethodDecl *MD, bool ctor);\n\n  /// GenerateObjCSetter - Synthesize an Objective-C property setter function\n  /// for the given property.\n  void GenerateObjCSetter(ObjCImplementationDecl *IMP,\n                          const ObjCPropertyImplDecl *PID);\n  void generateObjCSetterBody(const ObjCImplementationDecl *classImpl,\n                              const ObjCPropertyImplDecl *propImpl,\n                              llvm::Constant *AtomicHelperFn);\n\n  //===--------------------------------------------------------------------===//\n  //                                  Block Bits\n  //===--------------------------------------------------------------------===//\n\n  /// Emit block literal.\n  /// \\return an LLVM value which is a pointer to a struct which contains\n  /// information about the block, including the block invoke function, the\n  /// captured variables, etc.\n  llvm::Value *EmitBlockLiteral(const BlockExpr *);\n\n  llvm::Function *GenerateBlockFunction(GlobalDecl GD,\n                                        const CGBlockInfo &Info,\n                                        const DeclMapTy &ldm,\n                                        bool IsLambdaConversionToBlock,\n                                        bool BuildGlobalBlock);\n\n  /// Check if \\p T is a C++ class that has a destructor that can throw.\n  static bool cxxDestructorCanThrow(QualType T);\n\n  llvm::Constant *GenerateCopyHelperFunction(const CGBlockInfo &blockInfo);\n  llvm::Constant *GenerateDestroyHelperFunction(const CGBlockInfo &blockInfo);\n  llvm::Constant *GenerateObjCAtomicSetterCopyHelperFunction(\n                                             const ObjCPropertyImplDecl *PID);\n  llvm::Constant *GenerateObjCAtomicGetterCopyHelperFunction(\n                                             const ObjCPropertyImplDecl *PID);\n  llvm::Value *EmitBlockCopyAndAutorelease(llvm::Value *Block, QualType Ty);\n\n  void BuildBlockRelease(llvm::Value *DeclPtr, BlockFieldFlags flags,\n                         bool CanThrow);\n\n  class AutoVarEmission;\n\n  void emitByrefStructureInit(const AutoVarEmission &emission);\n\n  /// Enter a cleanup to destroy a __block variable.  Note that this\n  /// cleanup should be a no-op if the variable hasn't left the stack\n  /// yet; if a cleanup is required for the variable itself, that needs\n  /// to be done externally.\n  ///\n  /// \\param Kind Cleanup kind.\n  ///\n  /// \\param Addr When \\p LoadBlockVarAddr is false, the address of the __block\n  /// structure that will be passed to _Block_object_dispose. When\n  /// \\p LoadBlockVarAddr is true, the address of the field of the block\n  /// structure that holds the address of the __block structure.\n  ///\n  /// \\param Flags The flag that will be passed to _Block_object_dispose.\n  ///\n  /// \\param LoadBlockVarAddr Indicates whether we need to emit a load from\n  /// \\p Addr to get the address of the __block structure.\n  void enterByrefCleanup(CleanupKind Kind, Address Addr, BlockFieldFlags Flags,\n                         bool LoadBlockVarAddr, bool CanThrow);\n\n  void setBlockContextParameter(const ImplicitParamDecl *D, unsigned argNum,\n                                llvm::Value *ptr);\n\n  Address LoadBlockStruct();\n  Address GetAddrOfBlockDecl(const VarDecl *var);\n\n  /// BuildBlockByrefAddress - Computes the location of the\n  /// data in a variable which is declared as __block.\n  Address emitBlockByrefAddress(Address baseAddr, const VarDecl *V,\n                                bool followForward = true);\n  Address emitBlockByrefAddress(Address baseAddr,\n                                const BlockByrefInfo &info,\n                                bool followForward,\n                                const llvm::Twine &name);\n\n  const BlockByrefInfo &getBlockByrefInfo(const VarDecl *var);\n\n  QualType BuildFunctionArgList(GlobalDecl GD, FunctionArgList &Args);\n\n  void GenerateCode(GlobalDecl GD, llvm::Function *Fn,\n                    const CGFunctionInfo &FnInfo);\n\n  /// Annotate the function with an attribute that disables TSan checking at\n  /// runtime.\n  void markAsIgnoreThreadCheckingAtRuntime(llvm::Function *Fn);\n\n  /// Emit code for the start of a function.\n  /// \\param Loc       The location to be associated with the function.\n  /// \\param StartLoc  The location of the function body.\n  void StartFunction(GlobalDecl GD,\n                     QualType RetTy,\n                     llvm::Function *Fn,\n                     const CGFunctionInfo &FnInfo,\n                     const FunctionArgList &Args,\n                     SourceLocation Loc = SourceLocation(),\n                     SourceLocation StartLoc = SourceLocation());\n\n  static bool IsConstructorDelegationValid(const CXXConstructorDecl *Ctor);\n\n  void EmitConstructorBody(FunctionArgList &Args);\n  void EmitDestructorBody(FunctionArgList &Args);\n  void emitImplicitAssignmentOperatorBody(FunctionArgList &Args);\n  void EmitFunctionBody(const Stmt *Body);\n  void EmitBlockWithFallThrough(llvm::BasicBlock *BB, const Stmt *S);\n\n  void EmitForwardingCallToLambda(const CXXMethodDecl *LambdaCallOperator,\n                                  CallArgList &CallArgs);\n  void EmitLambdaBlockInvokeBody();\n  void EmitLambdaDelegatingInvokeBody(const CXXMethodDecl *MD);\n  void EmitLambdaStaticInvokeBody(const CXXMethodDecl *MD);\n  void EmitLambdaVLACapture(const VariableArrayType *VAT, LValue LV) {\n    EmitStoreThroughLValue(RValue::get(VLASizeMap[VAT->getSizeExpr()]), LV);\n  }\n  void EmitAsanPrologueOrEpilogue(bool Prologue);\n\n  /// Emit the unified return block, trying to avoid its emission when\n  /// possible.\n  /// \\return The debug location of the user written return statement if the\n  /// return block is is avoided.\n  llvm::DebugLoc EmitReturnBlock();\n\n  /// FinishFunction - Complete IR generation of the current function. It is\n  /// legal to call this function even if there is no current insertion point.\n  void FinishFunction(SourceLocation EndLoc=SourceLocation());\n\n  void StartThunk(llvm::Function *Fn, GlobalDecl GD,\n                  const CGFunctionInfo &FnInfo, bool IsUnprototyped);\n\n  void EmitCallAndReturnForThunk(llvm::FunctionCallee Callee,\n                                 const ThunkInfo *Thunk, bool IsUnprototyped);\n\n  void FinishThunk();\n\n  /// Emit a musttail call for a thunk with a potentially adjusted this pointer.\n  void EmitMustTailThunk(GlobalDecl GD, llvm::Value *AdjustedThisPtr,\n                         llvm::FunctionCallee Callee);\n\n  /// Generate a thunk for the given method.\n  void generateThunk(llvm::Function *Fn, const CGFunctionInfo &FnInfo,\n                     GlobalDecl GD, const ThunkInfo &Thunk,\n                     bool IsUnprototyped);\n\n  llvm::Function *GenerateVarArgsThunk(llvm::Function *Fn,\n                                       const CGFunctionInfo &FnInfo,\n                                       GlobalDecl GD, const ThunkInfo &Thunk);\n\n  void EmitCtorPrologue(const CXXConstructorDecl *CD, CXXCtorType Type,\n                        FunctionArgList &Args);\n\n  void EmitInitializerForField(FieldDecl *Field, LValue LHS, Expr *Init);\n\n  /// Struct with all information about dynamic [sub]class needed to set vptr.\n  struct VPtr {\n    BaseSubobject Base;\n    const CXXRecordDecl *NearestVBase;\n    CharUnits OffsetFromNearestVBase;\n    const CXXRecordDecl *VTableClass;\n  };\n\n  /// Initialize the vtable pointer of the given subobject.\n  void InitializeVTablePointer(const VPtr &vptr);\n\n  typedef llvm::SmallVector<VPtr, 4> VPtrsVector;\n\n  typedef llvm::SmallPtrSet<const CXXRecordDecl *, 4> VisitedVirtualBasesSetTy;\n  VPtrsVector getVTablePointers(const CXXRecordDecl *VTableClass);\n\n  void getVTablePointers(BaseSubobject Base, const CXXRecordDecl *NearestVBase,\n                         CharUnits OffsetFromNearestVBase,\n                         bool BaseIsNonVirtualPrimaryBase,\n                         const CXXRecordDecl *VTableClass,\n                         VisitedVirtualBasesSetTy &VBases, VPtrsVector &vptrs);\n\n  void InitializeVTablePointers(const CXXRecordDecl *ClassDecl);\n\n  /// GetVTablePtr - Return the Value of the vtable pointer member pointed\n  /// to by This.\n  llvm::Value *GetVTablePtr(Address This, llvm::Type *VTableTy,\n                            const CXXRecordDecl *VTableClass);\n\n  enum CFITypeCheckKind {\n    CFITCK_VCall,\n    CFITCK_NVCall,\n    CFITCK_DerivedCast,\n    CFITCK_UnrelatedCast,\n    CFITCK_ICall,\n    CFITCK_NVMFCall,\n    CFITCK_VMFCall,\n  };\n\n  /// Derived is the presumed address of an object of type T after a\n  /// cast. If T is a polymorphic class type, emit a check that the virtual\n  /// table for Derived belongs to a class derived from T.\n  void EmitVTablePtrCheckForCast(QualType T, llvm::Value *Derived,\n                                 bool MayBeNull, CFITypeCheckKind TCK,\n                                 SourceLocation Loc);\n\n  /// EmitVTablePtrCheckForCall - Virtual method MD is being called via VTable.\n  /// If vptr CFI is enabled, emit a check that VTable is valid.\n  void EmitVTablePtrCheckForCall(const CXXRecordDecl *RD, llvm::Value *VTable,\n                                 CFITypeCheckKind TCK, SourceLocation Loc);\n\n  /// EmitVTablePtrCheck - Emit a check that VTable is a valid virtual table for\n  /// RD using llvm.type.test.\n  void EmitVTablePtrCheck(const CXXRecordDecl *RD, llvm::Value *VTable,\n                          CFITypeCheckKind TCK, SourceLocation Loc);\n\n  /// If whole-program virtual table optimization is enabled, emit an assumption\n  /// that VTable is a member of RD's type identifier. Or, if vptr CFI is\n  /// enabled, emit a check that VTable is a member of RD's type identifier.\n  void EmitTypeMetadataCodeForVCall(const CXXRecordDecl *RD,\n                                    llvm::Value *VTable, SourceLocation Loc);\n\n  /// Returns whether we should perform a type checked load when loading a\n  /// virtual function for virtual calls to members of RD. This is generally\n  /// true when both vcall CFI and whole-program-vtables are enabled.\n  bool ShouldEmitVTableTypeCheckedLoad(const CXXRecordDecl *RD);\n\n  /// Emit a type checked load from the given vtable.\n  llvm::Value *EmitVTableTypeCheckedLoad(const CXXRecordDecl *RD, llvm::Value *VTable,\n                                         uint64_t VTableByteOffset);\n\n  /// EnterDtorCleanups - Enter the cleanups necessary to complete the\n  /// given phase of destruction for a destructor.  The end result\n  /// should call destructors on members and base classes in reverse\n  /// order of their construction.\n  void EnterDtorCleanups(const CXXDestructorDecl *Dtor, CXXDtorType Type);\n\n  /// ShouldInstrumentFunction - Return true if the current function should be\n  /// instrumented with __cyg_profile_func_* calls\n  bool ShouldInstrumentFunction();\n\n  /// ShouldXRayInstrument - Return true if the current function should be\n  /// instrumented with XRay nop sleds.\n  bool ShouldXRayInstrumentFunction() const;\n\n  /// AlwaysEmitXRayCustomEvents - Return true if we must unconditionally emit\n  /// XRay custom event handling calls.\n  bool AlwaysEmitXRayCustomEvents() const;\n\n  /// AlwaysEmitXRayTypedEvents - Return true if clang must unconditionally emit\n  /// XRay typed event handling calls.\n  bool AlwaysEmitXRayTypedEvents() const;\n\n  /// Encode an address into a form suitable for use in a function prologue.\n  llvm::Constant *EncodeAddrForUseInPrologue(llvm::Function *F,\n                                             llvm::Constant *Addr);\n\n  /// Decode an address used in a function prologue, encoded by \\c\n  /// EncodeAddrForUseInPrologue.\n  llvm::Value *DecodeAddrUsedInPrologue(llvm::Value *F,\n                                        llvm::Value *EncodedAddr);\n\n  /// EmitFunctionProlog - Emit the target specific LLVM code to load the\n  /// arguments for the given function. This is also responsible for naming the\n  /// LLVM function arguments.\n  void EmitFunctionProlog(const CGFunctionInfo &FI,\n                          llvm::Function *Fn,\n                          const FunctionArgList &Args);\n\n  /// EmitFunctionEpilog - Emit the target specific LLVM code to return the\n  /// given temporary.\n  void EmitFunctionEpilog(const CGFunctionInfo &FI, bool EmitRetDbgLoc,\n                          SourceLocation EndLoc);\n\n  /// Emit a test that checks if the return value \\p RV is nonnull.\n  void EmitReturnValueCheck(llvm::Value *RV);\n\n  /// EmitStartEHSpec - Emit the start of the exception spec.\n  void EmitStartEHSpec(const Decl *D);\n\n  /// EmitEndEHSpec - Emit the end of the exception spec.\n  void EmitEndEHSpec(const Decl *D);\n\n  /// getTerminateLandingPad - Return a landing pad that just calls terminate.\n  llvm::BasicBlock *getTerminateLandingPad();\n\n  /// getTerminateLandingPad - Return a cleanup funclet that just calls\n  /// terminate.\n  llvm::BasicBlock *getTerminateFunclet();\n\n  /// getTerminateHandler - Return a handler (not a landing pad, just\n  /// a catch handler) that just calls terminate.  This is used when\n  /// a terminate scope encloses a try.\n  llvm::BasicBlock *getTerminateHandler();\n\n  llvm::Type *ConvertTypeForMem(QualType T);\n  llvm::Type *ConvertType(QualType T);\n  llvm::Type *ConvertType(const TypeDecl *T) {\n    return ConvertType(getContext().getTypeDeclType(T));\n  }\n\n  /// LoadObjCSelf - Load the value of self. This function is only valid while\n  /// generating code for an Objective-C method.\n  llvm::Value *LoadObjCSelf();\n\n  /// TypeOfSelfObject - Return type of object that this self represents.\n  QualType TypeOfSelfObject();\n\n  /// getEvaluationKind - Return the TypeEvaluationKind of QualType \\c T.\n  static TypeEvaluationKind getEvaluationKind(QualType T);\n\n  static bool hasScalarEvaluationKind(QualType T) {\n    return getEvaluationKind(T) == TEK_Scalar;\n  }\n\n  static bool hasAggregateEvaluationKind(QualType T) {\n    return getEvaluationKind(T) == TEK_Aggregate;\n  }\n\n  /// createBasicBlock - Create an LLVM basic block.\n  llvm::BasicBlock *createBasicBlock(const Twine &name = \"\",\n                                     llvm::Function *parent = nullptr,\n                                     llvm::BasicBlock *before = nullptr) {\n    return llvm::BasicBlock::Create(getLLVMContext(), name, parent, before);\n  }\n\n  /// getBasicBlockForLabel - Return the LLVM basicblock that the specified\n  /// label maps to.\n  JumpDest getJumpDestForLabel(const LabelDecl *S);\n\n  /// SimplifyForwardingBlocks - If the given basic block is only a branch to\n  /// another basic block, simplify it. This assumes that no other code could\n  /// potentially reference the basic block.\n  void SimplifyForwardingBlocks(llvm::BasicBlock *BB);\n\n  /// EmitBlock - Emit the given block \\arg BB and set it as the insert point,\n  /// adding a fall-through branch from the current insert block if\n  /// necessary. It is legal to call this function even if there is no current\n  /// insertion point.\n  ///\n  /// IsFinished - If true, indicates that the caller has finished emitting\n  /// branches to the given block and does not expect to emit code into it. This\n  /// means the block can be ignored if it is unreachable.\n  void EmitBlock(llvm::BasicBlock *BB, bool IsFinished=false);\n\n  /// EmitBlockAfterUses - Emit the given block somewhere hopefully\n  /// near its uses, and leave the insertion point in it.\n  void EmitBlockAfterUses(llvm::BasicBlock *BB);\n\n  /// EmitBranch - Emit a branch to the specified basic block from the current\n  /// insert block, taking care to avoid creation of branches from dummy\n  /// blocks. It is legal to call this function even if there is no current\n  /// insertion point.\n  ///\n  /// This function clears the current insertion point. The caller should follow\n  /// calls to this function with calls to Emit*Block prior to generation new\n  /// code.\n  void EmitBranch(llvm::BasicBlock *Block);\n\n  /// HaveInsertPoint - True if an insertion point is defined. If not, this\n  /// indicates that the current code being emitted is unreachable.\n  bool HaveInsertPoint() const {\n    return Builder.GetInsertBlock() != nullptr;\n  }\n\n  /// EnsureInsertPoint - Ensure that an insertion point is defined so that\n  /// emitted IR has a place to go. Note that by definition, if this function\n  /// creates a block then that block is unreachable; callers may do better to\n  /// detect when no insertion point is defined and simply skip IR generation.\n  void EnsureInsertPoint() {\n    if (!HaveInsertPoint())\n      EmitBlock(createBasicBlock());\n  }\n\n  /// ErrorUnsupported - Print out an error that codegen doesn't support the\n  /// specified stmt yet.\n  void ErrorUnsupported(const Stmt *S, const char *Type);\n\n  //===--------------------------------------------------------------------===//\n  //                                  Helpers\n  //===--------------------------------------------------------------------===//\n\n  LValue MakeAddrLValue(Address Addr, QualType T,\n                        AlignmentSource Source = AlignmentSource::Type) {\n    return LValue::MakeAddr(Addr, T, getContext(), LValueBaseInfo(Source),\n                            CGM.getTBAAAccessInfo(T));\n  }\n\n  LValue MakeAddrLValue(Address Addr, QualType T, LValueBaseInfo BaseInfo,\n                        TBAAAccessInfo TBAAInfo) {\n    return LValue::MakeAddr(Addr, T, getContext(), BaseInfo, TBAAInfo);\n  }\n\n  LValue MakeAddrLValue(llvm::Value *V, QualType T, CharUnits Alignment,\n                        AlignmentSource Source = AlignmentSource::Type) {\n    return LValue::MakeAddr(Address(V, Alignment), T, getContext(),\n                            LValueBaseInfo(Source), CGM.getTBAAAccessInfo(T));\n  }\n\n  LValue MakeAddrLValue(llvm::Value *V, QualType T, CharUnits Alignment,\n                        LValueBaseInfo BaseInfo, TBAAAccessInfo TBAAInfo) {\n    return LValue::MakeAddr(Address(V, Alignment), T, getContext(),\n                            BaseInfo, TBAAInfo);\n  }\n\n  LValue MakeNaturalAlignPointeeAddrLValue(llvm::Value *V, QualType T);\n  LValue MakeNaturalAlignAddrLValue(llvm::Value *V, QualType T);\n\n  Address EmitLoadOfReference(LValue RefLVal,\n                              LValueBaseInfo *PointeeBaseInfo = nullptr,\n                              TBAAAccessInfo *PointeeTBAAInfo = nullptr);\n  LValue EmitLoadOfReferenceLValue(LValue RefLVal);\n  LValue EmitLoadOfReferenceLValue(Address RefAddr, QualType RefTy,\n                                   AlignmentSource Source =\n                                       AlignmentSource::Type) {\n    LValue RefLVal = MakeAddrLValue(RefAddr, RefTy, LValueBaseInfo(Source),\n                                    CGM.getTBAAAccessInfo(RefTy));\n    return EmitLoadOfReferenceLValue(RefLVal);\n  }\n\n  Address EmitLoadOfPointer(Address Ptr, const PointerType *PtrTy,\n                            LValueBaseInfo *BaseInfo = nullptr,\n                            TBAAAccessInfo *TBAAInfo = nullptr);\n  LValue EmitLoadOfPointerLValue(Address Ptr, const PointerType *PtrTy);\n\n  /// CreateTempAlloca - This creates an alloca and inserts it into the entry\n  /// block if \\p ArraySize is nullptr, otherwise inserts it at the current\n  /// insertion point of the builder. The caller is responsible for setting an\n  /// appropriate alignment on\n  /// the alloca.\n  ///\n  /// \\p ArraySize is the number of array elements to be allocated if it\n  ///    is not nullptr.\n  ///\n  /// LangAS::Default is the address space of pointers to local variables and\n  /// temporaries, as exposed in the source language. In certain\n  /// configurations, this is not the same as the alloca address space, and a\n  /// cast is needed to lift the pointer from the alloca AS into\n  /// LangAS::Default. This can happen when the target uses a restricted\n  /// address space for the stack but the source language requires\n  /// LangAS::Default to be a generic address space. The latter condition is\n  /// common for most programming languages; OpenCL is an exception in that\n  /// LangAS::Default is the private address space, which naturally maps\n  /// to the stack.\n  ///\n  /// Because the address of a temporary is often exposed to the program in\n  /// various ways, this function will perform the cast. The original alloca\n  /// instruction is returned through \\p Alloca if it is not nullptr.\n  ///\n  /// The cast is not performaed in CreateTempAllocaWithoutCast. This is\n  /// more efficient if the caller knows that the address will not be exposed.\n  llvm::AllocaInst *CreateTempAlloca(llvm::Type *Ty, const Twine &Name = \"tmp\",\n                                     llvm::Value *ArraySize = nullptr);\n  Address CreateTempAlloca(llvm::Type *Ty, CharUnits align,\n                           const Twine &Name = \"tmp\",\n                           llvm::Value *ArraySize = nullptr,\n                           Address *Alloca = nullptr);\n  Address CreateTempAllocaWithoutCast(llvm::Type *Ty, CharUnits align,\n                                      const Twine &Name = \"tmp\",\n                                      llvm::Value *ArraySize = nullptr);\n\n  /// CreateDefaultAlignedTempAlloca - This creates an alloca with the\n  /// default ABI alignment of the given LLVM type.\n  ///\n  /// IMPORTANT NOTE: This is *not* generally the right alignment for\n  /// any given AST type that happens to have been lowered to the\n  /// given IR type.  This should only ever be used for function-local,\n  /// IR-driven manipulations like saving and restoring a value.  Do\n  /// not hand this address off to arbitrary IRGen routines, and especially\n  /// do not pass it as an argument to a function that might expect a\n  /// properly ABI-aligned value.\n  Address CreateDefaultAlignTempAlloca(llvm::Type *Ty,\n                                       const Twine &Name = \"tmp\");\n\n  /// InitTempAlloca - Provide an initial value for the given alloca which\n  /// will be observable at all locations in the function.\n  ///\n  /// The address should be something that was returned from one of\n  /// the CreateTempAlloca or CreateMemTemp routines, and the\n  /// initializer must be valid in the entry block (i.e. it must\n  /// either be a constant or an argument value).\n  void InitTempAlloca(Address Alloca, llvm::Value *Value);\n\n  /// CreateIRTemp - Create a temporary IR object of the given type, with\n  /// appropriate alignment. This routine should only be used when an temporary\n  /// value needs to be stored into an alloca (for example, to avoid explicit\n  /// PHI construction), but the type is the IR type, not the type appropriate\n  /// for storing in memory.\n  ///\n  /// That is, this is exactly equivalent to CreateMemTemp, but calling\n  /// ConvertType instead of ConvertTypeForMem.\n  Address CreateIRTemp(QualType T, const Twine &Name = \"tmp\");\n\n  /// CreateMemTemp - Create a temporary memory object of the given type, with\n  /// appropriate alignmen and cast it to the default address space. Returns\n  /// the original alloca instruction by \\p Alloca if it is not nullptr.\n  Address CreateMemTemp(QualType T, const Twine &Name = \"tmp\",\n                        Address *Alloca = nullptr);\n  Address CreateMemTemp(QualType T, CharUnits Align, const Twine &Name = \"tmp\",\n                        Address *Alloca = nullptr);\n\n  /// CreateMemTemp - Create a temporary memory object of the given type, with\n  /// appropriate alignmen without casting it to the default address space.\n  Address CreateMemTempWithoutCast(QualType T, const Twine &Name = \"tmp\");\n  Address CreateMemTempWithoutCast(QualType T, CharUnits Align,\n                                   const Twine &Name = \"tmp\");\n\n  /// CreateAggTemp - Create a temporary memory object for the given\n  /// aggregate type.\n  AggValueSlot CreateAggTemp(QualType T, const Twine &Name = \"tmp\",\n                             Address *Alloca = nullptr) {\n    return AggValueSlot::forAddr(CreateMemTemp(T, Name, Alloca),\n                                 T.getQualifiers(),\n                                 AggValueSlot::IsNotDestructed,\n                                 AggValueSlot::DoesNotNeedGCBarriers,\n                                 AggValueSlot::IsNotAliased,\n                                 AggValueSlot::DoesNotOverlap);\n  }\n\n  /// Emit a cast to void* in the appropriate address space.\n  llvm::Value *EmitCastToVoidPtr(llvm::Value *value);\n\n  /// EvaluateExprAsBool - Perform the usual unary conversions on the specified\n  /// expression and compare the result against zero, returning an Int1Ty value.\n  llvm::Value *EvaluateExprAsBool(const Expr *E);\n\n  /// EmitIgnoredExpr - Emit an expression in a context which ignores the result.\n  void EmitIgnoredExpr(const Expr *E);\n\n  /// EmitAnyExpr - Emit code to compute the specified expression which can have\n  /// any type.  The result is returned as an RValue struct.  If this is an\n  /// aggregate expression, the aggloc/agglocvolatile arguments indicate where\n  /// the result should be returned.\n  ///\n  /// \\param ignoreResult True if the resulting value isn't used.\n  RValue EmitAnyExpr(const Expr *E,\n                     AggValueSlot aggSlot = AggValueSlot::ignored(),\n                     bool ignoreResult = false);\n\n  // EmitVAListRef - Emit a \"reference\" to a va_list; this is either the address\n  // or the value of the expression, depending on how va_list is defined.\n  Address EmitVAListRef(const Expr *E);\n\n  /// Emit a \"reference\" to a __builtin_ms_va_list; this is\n  /// always the value of the expression, because a __builtin_ms_va_list is a\n  /// pointer to a char.\n  Address EmitMSVAListRef(const Expr *E);\n\n  /// EmitAnyExprToTemp - Similarly to EmitAnyExpr(), however, the result will\n  /// always be accessible even if no aggregate location is provided.\n  RValue EmitAnyExprToTemp(const Expr *E);\n\n  /// EmitAnyExprToMem - Emits the code necessary to evaluate an\n  /// arbitrary expression into the given memory location.\n  void EmitAnyExprToMem(const Expr *E, Address Location,\n                        Qualifiers Quals, bool IsInitializer);\n\n  void EmitAnyExprToExn(const Expr *E, Address Addr);\n\n  /// EmitExprAsInit - Emits the code necessary to initialize a\n  /// location in memory with the given initializer.\n  void EmitExprAsInit(const Expr *init, const ValueDecl *D, LValue lvalue,\n                      bool capturedByInit);\n\n  /// hasVolatileMember - returns true if aggregate type has a volatile\n  /// member.\n  bool hasVolatileMember(QualType T) {\n    if (const RecordType *RT = T->getAs<RecordType>()) {\n      const RecordDecl *RD = cast<RecordDecl>(RT->getDecl());\n      return RD->hasVolatileMember();\n    }\n    return false;\n  }\n\n  /// Determine whether a return value slot may overlap some other object.\n  AggValueSlot::Overlap_t getOverlapForReturnValue() {\n    // FIXME: Assuming no overlap here breaks guaranteed copy elision for base\n    // class subobjects. These cases may need to be revisited depending on the\n    // resolution of the relevant core issue.\n    return AggValueSlot::DoesNotOverlap;\n  }\n\n  /// Determine whether a field initialization may overlap some other object.\n  AggValueSlot::Overlap_t getOverlapForFieldInit(const FieldDecl *FD);\n\n  /// Determine whether a base class initialization may overlap some other\n  /// object.\n  AggValueSlot::Overlap_t getOverlapForBaseInit(const CXXRecordDecl *RD,\n                                                const CXXRecordDecl *BaseRD,\n                                                bool IsVirtual);\n\n  /// Emit an aggregate assignment.\n  void EmitAggregateAssign(LValue Dest, LValue Src, QualType EltTy) {\n    bool IsVolatile = hasVolatileMember(EltTy);\n    EmitAggregateCopy(Dest, Src, EltTy, AggValueSlot::MayOverlap, IsVolatile);\n  }\n\n  void EmitAggregateCopyCtor(LValue Dest, LValue Src,\n                             AggValueSlot::Overlap_t MayOverlap) {\n    EmitAggregateCopy(Dest, Src, Src.getType(), MayOverlap);\n  }\n\n  /// EmitAggregateCopy - Emit an aggregate copy.\n  ///\n  /// \\param isVolatile \\c true iff either the source or the destination is\n  ///        volatile.\n  /// \\param MayOverlap Whether the tail padding of the destination might be\n  ///        occupied by some other object. More efficient code can often be\n  ///        generated if not.\n  void EmitAggregateCopy(LValue Dest, LValue Src, QualType EltTy,\n                         AggValueSlot::Overlap_t MayOverlap,\n                         bool isVolatile = false);\n\n  /// GetAddrOfLocalVar - Return the address of a local variable.\n  Address GetAddrOfLocalVar(const VarDecl *VD) {\n    auto it = LocalDeclMap.find(VD);\n    assert(it != LocalDeclMap.end() &&\n           \"Invalid argument to GetAddrOfLocalVar(), no decl!\");\n    return it->second;\n  }\n\n  /// Given an opaque value expression, return its LValue mapping if it exists,\n  /// otherwise create one.\n  LValue getOrCreateOpaqueLValueMapping(const OpaqueValueExpr *e);\n\n  /// Given an opaque value expression, return its RValue mapping if it exists,\n  /// otherwise create one.\n  RValue getOrCreateOpaqueRValueMapping(const OpaqueValueExpr *e);\n\n  /// Get the index of the current ArrayInitLoopExpr, if any.\n  llvm::Value *getArrayInitIndex() { return ArrayInitIndex; }\n\n  /// getAccessedFieldNo - Given an encoded value and a result number, return\n  /// the input field number being accessed.\n  static unsigned getAccessedFieldNo(unsigned Idx, const llvm::Constant *Elts);\n\n  llvm::BlockAddress *GetAddrOfLabel(const LabelDecl *L);\n  llvm::BasicBlock *GetIndirectGotoBlock();\n\n  /// Check if \\p E is a C++ \"this\" pointer wrapped in value-preserving casts.\n  static bool IsWrappedCXXThis(const Expr *E);\n\n  /// EmitNullInitialization - Generate code to set a value of the given type to\n  /// null, If the type contains data member pointers, they will be initialized\n  /// to -1 in accordance with the Itanium C++ ABI.\n  void EmitNullInitialization(Address DestPtr, QualType Ty);\n\n  /// Emits a call to an LLVM variable-argument intrinsic, either\n  /// \\c llvm.va_start or \\c llvm.va_end.\n  /// \\param ArgValue A reference to the \\c va_list as emitted by either\n  /// \\c EmitVAListRef or \\c EmitMSVAListRef.\n  /// \\param IsStart If \\c true, emits a call to \\c llvm.va_start; otherwise,\n  /// calls \\c llvm.va_end.\n  llvm::Value *EmitVAStartEnd(llvm::Value *ArgValue, bool IsStart);\n\n  /// Generate code to get an argument from the passed in pointer\n  /// and update it accordingly.\n  /// \\param VE The \\c VAArgExpr for which to generate code.\n  /// \\param VAListAddr Receives a reference to the \\c va_list as emitted by\n  /// either \\c EmitVAListRef or \\c EmitMSVAListRef.\n  /// \\returns A pointer to the argument.\n  // FIXME: We should be able to get rid of this method and use the va_arg\n  // instruction in LLVM instead once it works well enough.\n  Address EmitVAArg(VAArgExpr *VE, Address &VAListAddr);\n\n  /// emitArrayLength - Compute the length of an array, even if it's a\n  /// VLA, and drill down to the base element type.\n  llvm::Value *emitArrayLength(const ArrayType *arrayType,\n                               QualType &baseType,\n                               Address &addr);\n\n  /// EmitVLASize - Capture all the sizes for the VLA expressions in\n  /// the given variably-modified type and store them in the VLASizeMap.\n  ///\n  /// This function can be called with a null (unreachable) insert point.\n  void EmitVariablyModifiedType(QualType Ty);\n\n  struct VlaSizePair {\n    llvm::Value *NumElts;\n    QualType Type;\n\n    VlaSizePair(llvm::Value *NE, QualType T) : NumElts(NE), Type(T) {}\n  };\n\n  /// Return the number of elements for a single dimension\n  /// for the given array type.\n  VlaSizePair getVLAElements1D(const VariableArrayType *vla);\n  VlaSizePair getVLAElements1D(QualType vla);\n\n  /// Returns an LLVM value that corresponds to the size,\n  /// in non-variably-sized elements, of a variable length array type,\n  /// plus that largest non-variably-sized element type.  Assumes that\n  /// the type has already been emitted with EmitVariablyModifiedType.\n  VlaSizePair getVLASize(const VariableArrayType *vla);\n  VlaSizePair getVLASize(QualType vla);\n\n  /// LoadCXXThis - Load the value of 'this'. This function is only valid while\n  /// generating code for an C++ member function.\n  llvm::Value *LoadCXXThis() {\n    assert(CXXThisValue && \"no 'this' value for this function\");\n    return CXXThisValue;\n  }\n  Address LoadCXXThisAddress();\n\n  /// LoadCXXVTT - Load the VTT parameter to base constructors/destructors have\n  /// virtual bases.\n  // FIXME: Every place that calls LoadCXXVTT is something\n  // that needs to be abstracted properly.\n  llvm::Value *LoadCXXVTT() {\n    assert(CXXStructorImplicitParamValue && \"no VTT value for this function\");\n    return CXXStructorImplicitParamValue;\n  }\n\n  /// GetAddressOfBaseOfCompleteClass - Convert the given pointer to a\n  /// complete class to the given direct base.\n  Address\n  GetAddressOfDirectBaseInCompleteClass(Address Value,\n                                        const CXXRecordDecl *Derived,\n                                        const CXXRecordDecl *Base,\n                                        bool BaseIsVirtual);\n\n  static bool ShouldNullCheckClassCastValue(const CastExpr *Cast);\n\n  /// GetAddressOfBaseClass - This function will add the necessary delta to the\n  /// load of 'this' and returns address of the base class.\n  Address GetAddressOfBaseClass(Address Value,\n                                const CXXRecordDecl *Derived,\n                                CastExpr::path_const_iterator PathBegin,\n                                CastExpr::path_const_iterator PathEnd,\n                                bool NullCheckValue, SourceLocation Loc);\n\n  Address GetAddressOfDerivedClass(Address Value,\n                                   const CXXRecordDecl *Derived,\n                                   CastExpr::path_const_iterator PathBegin,\n                                   CastExpr::path_const_iterator PathEnd,\n                                   bool NullCheckValue);\n\n  /// GetVTTParameter - Return the VTT parameter that should be passed to a\n  /// base constructor/destructor with virtual bases.\n  /// FIXME: VTTs are Itanium ABI-specific, so the definition should move\n  /// to ItaniumCXXABI.cpp together with all the references to VTT.\n  llvm::Value *GetVTTParameter(GlobalDecl GD, bool ForVirtualBase,\n                               bool Delegating);\n\n  void EmitDelegateCXXConstructorCall(const CXXConstructorDecl *Ctor,\n                                      CXXCtorType CtorType,\n                                      const FunctionArgList &Args,\n                                      SourceLocation Loc);\n  // It's important not to confuse this and the previous function. Delegating\n  // constructors are the C++0x feature. The constructor delegate optimization\n  // is used to reduce duplication in the base and complete consturctors where\n  // they are substantially the same.\n  void EmitDelegatingCXXConstructorCall(const CXXConstructorDecl *Ctor,\n                                        const FunctionArgList &Args);\n\n  /// Emit a call to an inheriting constructor (that is, one that invokes a\n  /// constructor inherited from a base class) by inlining its definition. This\n  /// is necessary if the ABI does not support forwarding the arguments to the\n  /// base class constructor (because they're variadic or similar).\n  void EmitInlinedInheritingCXXConstructorCall(const CXXConstructorDecl *Ctor,\n                                               CXXCtorType CtorType,\n                                               bool ForVirtualBase,\n                                               bool Delegating,\n                                               CallArgList &Args);\n\n  /// Emit a call to a constructor inherited from a base class, passing the\n  /// current constructor's arguments along unmodified (without even making\n  /// a copy).\n  void EmitInheritedCXXConstructorCall(const CXXConstructorDecl *D,\n                                       bool ForVirtualBase, Address This,\n                                       bool InheritedFromVBase,\n                                       const CXXInheritedCtorInitExpr *E);\n\n  void EmitCXXConstructorCall(const CXXConstructorDecl *D, CXXCtorType Type,\n                              bool ForVirtualBase, bool Delegating,\n                              AggValueSlot ThisAVS, const CXXConstructExpr *E);\n\n  void EmitCXXConstructorCall(const CXXConstructorDecl *D, CXXCtorType Type,\n                              bool ForVirtualBase, bool Delegating,\n                              Address This, CallArgList &Args,\n                              AggValueSlot::Overlap_t Overlap,\n                              SourceLocation Loc, bool NewPointerIsChecked);\n\n  /// Emit assumption load for all bases. Requires to be be called only on\n  /// most-derived class and not under construction of the object.\n  void EmitVTableAssumptionLoads(const CXXRecordDecl *ClassDecl, Address This);\n\n  /// Emit assumption that vptr load == global vtable.\n  void EmitVTableAssumptionLoad(const VPtr &vptr, Address This);\n\n  void EmitSynthesizedCXXCopyCtorCall(const CXXConstructorDecl *D,\n                                      Address This, Address Src,\n                                      const CXXConstructExpr *E);\n\n  void EmitCXXAggrConstructorCall(const CXXConstructorDecl *D,\n                                  const ArrayType *ArrayTy,\n                                  Address ArrayPtr,\n                                  const CXXConstructExpr *E,\n                                  bool NewPointerIsChecked,\n                                  bool ZeroInitialization = false);\n\n  void EmitCXXAggrConstructorCall(const CXXConstructorDecl *D,\n                                  llvm::Value *NumElements,\n                                  Address ArrayPtr,\n                                  const CXXConstructExpr *E,\n                                  bool NewPointerIsChecked,\n                                  bool ZeroInitialization = false);\n\n  static Destroyer destroyCXXObject;\n\n  void EmitCXXDestructorCall(const CXXDestructorDecl *D, CXXDtorType Type,\n                             bool ForVirtualBase, bool Delegating, Address This,\n                             QualType ThisTy);\n\n  void EmitNewArrayInitializer(const CXXNewExpr *E, QualType elementType,\n                               llvm::Type *ElementTy, Address NewPtr,\n                               llvm::Value *NumElements,\n                               llvm::Value *AllocSizeWithoutCookie);\n\n  void EmitCXXTemporary(const CXXTemporary *Temporary, QualType TempType,\n                        Address Ptr);\n\n  llvm::Value *EmitLifetimeStart(uint64_t Size, llvm::Value *Addr);\n  void EmitLifetimeEnd(llvm::Value *Size, llvm::Value *Addr);\n\n  llvm::Value *EmitCXXNewExpr(const CXXNewExpr *E);\n  void EmitCXXDeleteExpr(const CXXDeleteExpr *E);\n\n  void EmitDeleteCall(const FunctionDecl *DeleteFD, llvm::Value *Ptr,\n                      QualType DeleteTy, llvm::Value *NumElements = nullptr,\n                      CharUnits CookieSize = CharUnits());\n\n  RValue EmitBuiltinNewDeleteCall(const FunctionProtoType *Type,\n                                  const CallExpr *TheCallExpr, bool IsDelete);\n\n  llvm::Value *EmitCXXTypeidExpr(const CXXTypeidExpr *E);\n  llvm::Value *EmitDynamicCast(Address V, const CXXDynamicCastExpr *DCE);\n  Address EmitCXXUuidofExpr(const CXXUuidofExpr *E);\n\n  /// Situations in which we might emit a check for the suitability of a\n  /// pointer or glvalue. Needs to be kept in sync with ubsan_handlers.cpp in\n  /// compiler-rt.\n  enum TypeCheckKind {\n    /// Checking the operand of a load. Must be suitably sized and aligned.\n    TCK_Load,\n    /// Checking the destination of a store. Must be suitably sized and aligned.\n    TCK_Store,\n    /// Checking the bound value in a reference binding. Must be suitably sized\n    /// and aligned, but is not required to refer to an object (until the\n    /// reference is used), per core issue 453.\n    TCK_ReferenceBinding,\n    /// Checking the object expression in a non-static data member access. Must\n    /// be an object within its lifetime.\n    TCK_MemberAccess,\n    /// Checking the 'this' pointer for a call to a non-static member function.\n    /// Must be an object within its lifetime.\n    TCK_MemberCall,\n    /// Checking the 'this' pointer for a constructor call.\n    TCK_ConstructorCall,\n    /// Checking the operand of a static_cast to a derived pointer type. Must be\n    /// null or an object within its lifetime.\n    TCK_DowncastPointer,\n    /// Checking the operand of a static_cast to a derived reference type. Must\n    /// be an object within its lifetime.\n    TCK_DowncastReference,\n    /// Checking the operand of a cast to a base object. Must be suitably sized\n    /// and aligned.\n    TCK_Upcast,\n    /// Checking the operand of a cast to a virtual base object. Must be an\n    /// object within its lifetime.\n    TCK_UpcastToVirtualBase,\n    /// Checking the value assigned to a _Nonnull pointer. Must not be null.\n    TCK_NonnullAssign,\n    /// Checking the operand of a dynamic_cast or a typeid expression.  Must be\n    /// null or an object within its lifetime.\n    TCK_DynamicOperation\n  };\n\n  /// Determine whether the pointer type check \\p TCK permits null pointers.\n  static bool isNullPointerAllowed(TypeCheckKind TCK);\n\n  /// Determine whether the pointer type check \\p TCK requires a vptr check.\n  static bool isVptrCheckRequired(TypeCheckKind TCK, QualType Ty);\n\n  /// Whether any type-checking sanitizers are enabled. If \\c false,\n  /// calls to EmitTypeCheck can be skipped.\n  bool sanitizePerformTypeCheck() const;\n\n  /// Emit a check that \\p V is the address of storage of the\n  /// appropriate size and alignment for an object of type \\p Type\n  /// (or if ArraySize is provided, for an array of that bound).\n  void EmitTypeCheck(TypeCheckKind TCK, SourceLocation Loc, llvm::Value *V,\n                     QualType Type, CharUnits Alignment = CharUnits::Zero(),\n                     SanitizerSet SkippedChecks = SanitizerSet(),\n                     llvm::Value *ArraySize = nullptr);\n\n  /// Emit a check that \\p Base points into an array object, which\n  /// we can access at index \\p Index. \\p Accessed should be \\c false if we\n  /// this expression is used as an lvalue, for instance in \"&Arr[Idx]\".\n  void EmitBoundsCheck(const Expr *E, const Expr *Base, llvm::Value *Index,\n                       QualType IndexType, bool Accessed);\n\n  llvm::Value *EmitScalarPrePostIncDec(const UnaryOperator *E, LValue LV,\n                                       bool isInc, bool isPre);\n  ComplexPairTy EmitComplexPrePostIncDec(const UnaryOperator *E, LValue LV,\n                                         bool isInc, bool isPre);\n\n  /// Converts Location to a DebugLoc, if debug information is enabled.\n  llvm::DebugLoc SourceLocToDebugLoc(SourceLocation Location);\n\n  /// Get the record field index as represented in debug info.\n  unsigned getDebugInfoFIndex(const RecordDecl *Rec, unsigned FieldIndex);\n\n\n  //===--------------------------------------------------------------------===//\n  //                            Declaration Emission\n  //===--------------------------------------------------------------------===//\n\n  /// EmitDecl - Emit a declaration.\n  ///\n  /// This function can be called with a null (unreachable) insert point.\n  void EmitDecl(const Decl &D);\n\n  /// EmitVarDecl - Emit a local variable declaration.\n  ///\n  /// This function can be called with a null (unreachable) insert point.\n  void EmitVarDecl(const VarDecl &D);\n\n  void EmitScalarInit(const Expr *init, const ValueDecl *D, LValue lvalue,\n                      bool capturedByInit);\n\n  typedef void SpecialInitFn(CodeGenFunction &Init, const VarDecl &D,\n                             llvm::Value *Address);\n\n  /// Determine whether the given initializer is trivial in the sense\n  /// that it requires no code to be generated.\n  bool isTrivialInitializer(const Expr *Init);\n\n  /// EmitAutoVarDecl - Emit an auto variable declaration.\n  ///\n  /// This function can be called with a null (unreachable) insert point.\n  void EmitAutoVarDecl(const VarDecl &D);\n\n  class AutoVarEmission {\n    friend class CodeGenFunction;\n\n    const VarDecl *Variable;\n\n    /// The address of the alloca for languages with explicit address space\n    /// (e.g. OpenCL) or alloca casted to generic pointer for address space\n    /// agnostic languages (e.g. C++). Invalid if the variable was emitted\n    /// as a global constant.\n    Address Addr;\n\n    llvm::Value *NRVOFlag;\n\n    /// True if the variable is a __block variable that is captured by an\n    /// escaping block.\n    bool IsEscapingByRef;\n\n    /// True if the variable is of aggregate type and has a constant\n    /// initializer.\n    bool IsConstantAggregate;\n\n    /// Non-null if we should use lifetime annotations.\n    llvm::Value *SizeForLifetimeMarkers;\n\n    /// Address with original alloca instruction. Invalid if the variable was\n    /// emitted as a global constant.\n    Address AllocaAddr;\n\n    struct Invalid {};\n    AutoVarEmission(Invalid)\n        : Variable(nullptr), Addr(Address::invalid()),\n          AllocaAddr(Address::invalid()) {}\n\n    AutoVarEmission(const VarDecl &variable)\n        : Variable(&variable), Addr(Address::invalid()), NRVOFlag(nullptr),\n          IsEscapingByRef(false), IsConstantAggregate(false),\n          SizeForLifetimeMarkers(nullptr), AllocaAddr(Address::invalid()) {}\n\n    bool wasEmittedAsGlobal() const { return !Addr.isValid(); }\n\n  public:\n    static AutoVarEmission invalid() { return AutoVarEmission(Invalid()); }\n\n    bool useLifetimeMarkers() const {\n      return SizeForLifetimeMarkers != nullptr;\n    }\n    llvm::Value *getSizeForLifetimeMarkers() const {\n      assert(useLifetimeMarkers());\n      return SizeForLifetimeMarkers;\n    }\n\n    /// Returns the raw, allocated address, which is not necessarily\n    /// the address of the object itself. It is casted to default\n    /// address space for address space agnostic languages.\n    Address getAllocatedAddress() const {\n      return Addr;\n    }\n\n    /// Returns the address for the original alloca instruction.\n    Address getOriginalAllocatedAddress() const { return AllocaAddr; }\n\n    /// Returns the address of the object within this declaration.\n    /// Note that this does not chase the forwarding pointer for\n    /// __block decls.\n    Address getObjectAddress(CodeGenFunction &CGF) const {\n      if (!IsEscapingByRef) return Addr;\n\n      return CGF.emitBlockByrefAddress(Addr, Variable, /*forward*/ false);\n    }\n  };\n  AutoVarEmission EmitAutoVarAlloca(const VarDecl &var);\n  void EmitAutoVarInit(const AutoVarEmission &emission);\n  void EmitAutoVarCleanups(const AutoVarEmission &emission);\n  void emitAutoVarTypeCleanup(const AutoVarEmission &emission,\n                              QualType::DestructionKind dtorKind);\n\n  /// Emits the alloca and debug information for the size expressions for each\n  /// dimension of an array. It registers the association of its (1-dimensional)\n  /// QualTypes and size expression's debug node, so that CGDebugInfo can\n  /// reference this node when creating the DISubrange object to describe the\n  /// array types.\n  void EmitAndRegisterVariableArrayDimensions(CGDebugInfo *DI,\n                                              const VarDecl &D,\n                                              bool EmitDebugInfo);\n\n  void EmitStaticVarDecl(const VarDecl &D,\n                         llvm::GlobalValue::LinkageTypes Linkage);\n\n  class ParamValue {\n    llvm::Value *Value;\n    unsigned Alignment;\n    ParamValue(llvm::Value *V, unsigned A) : Value(V), Alignment(A) {}\n  public:\n    static ParamValue forDirect(llvm::Value *value) {\n      return ParamValue(value, 0);\n    }\n    static ParamValue forIndirect(Address addr) {\n      assert(!addr.getAlignment().isZero());\n      return ParamValue(addr.getPointer(), addr.getAlignment().getQuantity());\n    }\n\n    bool isIndirect() const { return Alignment != 0; }\n    llvm::Value *getAnyValue() const { return Value; }\n\n    llvm::Value *getDirectValue() const {\n      assert(!isIndirect());\n      return Value;\n    }\n\n    Address getIndirectAddress() const {\n      assert(isIndirect());\n      return Address(Value, CharUnits::fromQuantity(Alignment));\n    }\n  };\n\n  /// EmitParmDecl - Emit a ParmVarDecl or an ImplicitParamDecl.\n  void EmitParmDecl(const VarDecl &D, ParamValue Arg, unsigned ArgNo);\n\n  /// protectFromPeepholes - Protect a value that we're intending to\n  /// store to the side, but which will probably be used later, from\n  /// aggressive peepholing optimizations that might delete it.\n  ///\n  /// Pass the result to unprotectFromPeepholes to declare that\n  /// protection is no longer required.\n  ///\n  /// There's no particular reason why this shouldn't apply to\n  /// l-values, it's just that no existing peepholes work on pointers.\n  PeepholeProtection protectFromPeepholes(RValue rvalue);\n  void unprotectFromPeepholes(PeepholeProtection protection);\n\n  void emitAlignmentAssumptionCheck(llvm::Value *Ptr, QualType Ty,\n                                    SourceLocation Loc,\n                                    SourceLocation AssumptionLoc,\n                                    llvm::Value *Alignment,\n                                    llvm::Value *OffsetValue,\n                                    llvm::Value *TheCheck,\n                                    llvm::Instruction *Assumption);\n\n  void emitAlignmentAssumption(llvm::Value *PtrValue, QualType Ty,\n                               SourceLocation Loc, SourceLocation AssumptionLoc,\n                               llvm::Value *Alignment,\n                               llvm::Value *OffsetValue = nullptr);\n\n  void emitAlignmentAssumption(llvm::Value *PtrValue, const Expr *E,\n                               SourceLocation AssumptionLoc,\n                               llvm::Value *Alignment,\n                               llvm::Value *OffsetValue = nullptr);\n\n  //===--------------------------------------------------------------------===//\n  //                             Statement Emission\n  //===--------------------------------------------------------------------===//\n\n  /// EmitStopPoint - Emit a debug stoppoint if we are emitting debug info.\n  void EmitStopPoint(const Stmt *S);\n\n  /// EmitStmt - Emit the code for the statement \\arg S. It is legal to call\n  /// this function even if there is no current insertion point.\n  ///\n  /// This function may clear the current insertion point; callers should use\n  /// EnsureInsertPoint if they wish to subsequently generate code without first\n  /// calling EmitBlock, EmitBranch, or EmitStmt.\n  void EmitStmt(const Stmt *S, ArrayRef<const Attr *> Attrs = None);\n\n  /// EmitSimpleStmt - Try to emit a \"simple\" statement which does not\n  /// necessarily require an insertion point or debug information; typically\n  /// because the statement amounts to a jump or a container of other\n  /// statements.\n  ///\n  /// \\return True if the statement was handled.\n  bool EmitSimpleStmt(const Stmt *S, ArrayRef<const Attr *> Attrs);\n\n  Address EmitCompoundStmt(const CompoundStmt &S, bool GetLast = false,\n                           AggValueSlot AVS = AggValueSlot::ignored());\n  Address EmitCompoundStmtWithoutScope(const CompoundStmt &S,\n                                       bool GetLast = false,\n                                       AggValueSlot AVS =\n                                                AggValueSlot::ignored());\n\n  /// EmitLabel - Emit the block for the given label. It is legal to call this\n  /// function even if there is no current insertion point.\n  void EmitLabel(const LabelDecl *D); // helper for EmitLabelStmt.\n\n  void EmitLabelStmt(const LabelStmt &S);\n  void EmitAttributedStmt(const AttributedStmt &S);\n  void EmitGotoStmt(const GotoStmt &S);\n  void EmitIndirectGotoStmt(const IndirectGotoStmt &S);\n  void EmitIfStmt(const IfStmt &S);\n\n  void EmitWhileStmt(const WhileStmt &S,\n                     ArrayRef<const Attr *> Attrs = None);\n  void EmitDoStmt(const DoStmt &S, ArrayRef<const Attr *> Attrs = None);\n  void EmitForStmt(const ForStmt &S,\n                   ArrayRef<const Attr *> Attrs = None);\n  void EmitReturnStmt(const ReturnStmt &S);\n  void EmitDeclStmt(const DeclStmt &S);\n  void EmitBreakStmt(const BreakStmt &S);\n  void EmitContinueStmt(const ContinueStmt &S);\n  void EmitSwitchStmt(const SwitchStmt &S);\n  void EmitDefaultStmt(const DefaultStmt &S, ArrayRef<const Attr *> Attrs);\n  void EmitCaseStmt(const CaseStmt &S, ArrayRef<const Attr *> Attrs);\n  void EmitCaseStmtRange(const CaseStmt &S, ArrayRef<const Attr *> Attrs);\n  void EmitAsmStmt(const AsmStmt &S);\n\n  void EmitObjCForCollectionStmt(const ObjCForCollectionStmt &S);\n  void EmitObjCAtTryStmt(const ObjCAtTryStmt &S);\n  void EmitObjCAtThrowStmt(const ObjCAtThrowStmt &S);\n  void EmitObjCAtSynchronizedStmt(const ObjCAtSynchronizedStmt &S);\n  void EmitObjCAutoreleasePoolStmt(const ObjCAutoreleasePoolStmt &S);\n\n  void EmitCoroutineBody(const CoroutineBodyStmt &S);\n  void EmitCoreturnStmt(const CoreturnStmt &S);\n  RValue EmitCoawaitExpr(const CoawaitExpr &E,\n                         AggValueSlot aggSlot = AggValueSlot::ignored(),\n                         bool ignoreResult = false);\n  LValue EmitCoawaitLValue(const CoawaitExpr *E);\n  RValue EmitCoyieldExpr(const CoyieldExpr &E,\n                         AggValueSlot aggSlot = AggValueSlot::ignored(),\n                         bool ignoreResult = false);\n  LValue EmitCoyieldLValue(const CoyieldExpr *E);\n  RValue EmitCoroutineIntrinsic(const CallExpr *E, unsigned int IID);\n\n  void EnterCXXTryStmt(const CXXTryStmt &S, bool IsFnTryBlock = false);\n  void ExitCXXTryStmt(const CXXTryStmt &S, bool IsFnTryBlock = false);\n\n  void EmitCXXTryStmt(const CXXTryStmt &S);\n  void EmitSEHTryStmt(const SEHTryStmt &S);\n  void EmitSEHLeaveStmt(const SEHLeaveStmt &S);\n  void EnterSEHTryStmt(const SEHTryStmt &S);\n  void ExitSEHTryStmt(const SEHTryStmt &S);\n\n  void pushSEHCleanup(CleanupKind kind,\n                      llvm::Function *FinallyFunc);\n  void startOutlinedSEHHelper(CodeGenFunction &ParentCGF, bool IsFilter,\n                              const Stmt *OutlinedStmt);\n\n  llvm::Function *GenerateSEHFilterFunction(CodeGenFunction &ParentCGF,\n                                            const SEHExceptStmt &Except);\n\n  llvm::Function *GenerateSEHFinallyFunction(CodeGenFunction &ParentCGF,\n                                             const SEHFinallyStmt &Finally);\n\n  void EmitSEHExceptionCodeSave(CodeGenFunction &ParentCGF,\n                                llvm::Value *ParentFP,\n                                llvm::Value *EntryEBP);\n  llvm::Value *EmitSEHExceptionCode();\n  llvm::Value *EmitSEHExceptionInfo();\n  llvm::Value *EmitSEHAbnormalTermination();\n\n  /// Emit simple code for OpenMP directives in Simd-only mode.\n  void EmitSimpleOMPExecutableDirective(const OMPExecutableDirective &D);\n\n  /// Scan the outlined statement for captures from the parent function. For\n  /// each capture, mark the capture as escaped and emit a call to\n  /// llvm.localrecover. Insert the localrecover result into the LocalDeclMap.\n  void EmitCapturedLocals(CodeGenFunction &ParentCGF, const Stmt *OutlinedStmt,\n                          bool IsFilter);\n\n  /// Recovers the address of a local in a parent function. ParentVar is the\n  /// address of the variable used in the immediate parent function. It can\n  /// either be an alloca or a call to llvm.localrecover if there are nested\n  /// outlined functions. ParentFP is the frame pointer of the outermost parent\n  /// frame.\n  Address recoverAddrOfEscapedLocal(CodeGenFunction &ParentCGF,\n                                    Address ParentVar,\n                                    llvm::Value *ParentFP);\n\n  void EmitCXXForRangeStmt(const CXXForRangeStmt &S,\n                           ArrayRef<const Attr *> Attrs = None);\n\n  /// Controls insertion of cancellation exit blocks in worksharing constructs.\n  class OMPCancelStackRAII {\n    CodeGenFunction &CGF;\n\n  public:\n    OMPCancelStackRAII(CodeGenFunction &CGF, OpenMPDirectiveKind Kind,\n                       bool HasCancel)\n        : CGF(CGF) {\n      CGF.OMPCancelStack.enter(CGF, Kind, HasCancel);\n    }\n    ~OMPCancelStackRAII() { CGF.OMPCancelStack.exit(CGF); }\n  };\n\n  /// Returns calculated size of the specified type.\n  llvm::Value *getTypeSize(QualType Ty);\n  LValue InitCapturedStruct(const CapturedStmt &S);\n  llvm::Function *EmitCapturedStmt(const CapturedStmt &S, CapturedRegionKind K);\n  llvm::Function *GenerateCapturedStmtFunction(const CapturedStmt &S);\n  Address GenerateCapturedStmtArgument(const CapturedStmt &S);\n  llvm::Function *GenerateOpenMPCapturedStmtFunction(const CapturedStmt &S,\n                                                     SourceLocation Loc);\n  void GenerateOpenMPCapturedVars(const CapturedStmt &S,\n                                  SmallVectorImpl<llvm::Value *> &CapturedVars);\n  void emitOMPSimpleStore(LValue LVal, RValue RVal, QualType RValTy,\n                          SourceLocation Loc);\n  /// Perform element by element copying of arrays with type \\a\n  /// OriginalType from \\a SrcAddr to \\a DestAddr using copying procedure\n  /// generated by \\a CopyGen.\n  ///\n  /// \\param DestAddr Address of the destination array.\n  /// \\param SrcAddr Address of the source array.\n  /// \\param OriginalType Type of destination and source arrays.\n  /// \\param CopyGen Copying procedure that copies value of single array element\n  /// to another single array element.\n  void EmitOMPAggregateAssign(\n      Address DestAddr, Address SrcAddr, QualType OriginalType,\n      const llvm::function_ref<void(Address, Address)> CopyGen);\n  /// Emit proper copying of data from one variable to another.\n  ///\n  /// \\param OriginalType Original type of the copied variables.\n  /// \\param DestAddr Destination address.\n  /// \\param SrcAddr Source address.\n  /// \\param DestVD Destination variable used in \\a CopyExpr (for arrays, has\n  /// type of the base array element).\n  /// \\param SrcVD Source variable used in \\a CopyExpr (for arrays, has type of\n  /// the base array element).\n  /// \\param Copy Actual copygin expression for copying data from \\a SrcVD to \\a\n  /// DestVD.\n  void EmitOMPCopy(QualType OriginalType,\n                   Address DestAddr, Address SrcAddr,\n                   const VarDecl *DestVD, const VarDecl *SrcVD,\n                   const Expr *Copy);\n  /// Emit atomic update code for constructs: \\a X = \\a X \\a BO \\a E or\n  /// \\a X = \\a E \\a BO \\a E.\n  ///\n  /// \\param X Value to be updated.\n  /// \\param E Update value.\n  /// \\param BO Binary operation for update operation.\n  /// \\param IsXLHSInRHSPart true if \\a X is LHS in RHS part of the update\n  /// expression, false otherwise.\n  /// \\param AO Atomic ordering of the generated atomic instructions.\n  /// \\param CommonGen Code generator for complex expressions that cannot be\n  /// expressed through atomicrmw instruction.\n  /// \\returns <true, OldAtomicValue> if simple 'atomicrmw' instruction was\n  /// generated, <false, RValue::get(nullptr)> otherwise.\n  std::pair<bool, RValue> EmitOMPAtomicSimpleUpdateExpr(\n      LValue X, RValue E, BinaryOperatorKind BO, bool IsXLHSInRHSPart,\n      llvm::AtomicOrdering AO, SourceLocation Loc,\n      const llvm::function_ref<RValue(RValue)> CommonGen);\n  bool EmitOMPFirstprivateClause(const OMPExecutableDirective &D,\n                                 OMPPrivateScope &PrivateScope);\n  void EmitOMPPrivateClause(const OMPExecutableDirective &D,\n                            OMPPrivateScope &PrivateScope);\n  void EmitOMPUseDevicePtrClause(\n      const OMPUseDevicePtrClause &C, OMPPrivateScope &PrivateScope,\n      const llvm::DenseMap<const ValueDecl *, Address> &CaptureDeviceAddrMap);\n  void EmitOMPUseDeviceAddrClause(\n      const OMPUseDeviceAddrClause &C, OMPPrivateScope &PrivateScope,\n      const llvm::DenseMap<const ValueDecl *, Address> &CaptureDeviceAddrMap);\n  /// Emit code for copyin clause in \\a D directive. The next code is\n  /// generated at the start of outlined functions for directives:\n  /// \\code\n  /// threadprivate_var1 = master_threadprivate_var1;\n  /// operator=(threadprivate_var2, master_threadprivate_var2);\n  /// ...\n  /// __kmpc_barrier(&loc, global_tid);\n  /// \\endcode\n  ///\n  /// \\param D OpenMP directive possibly with 'copyin' clause(s).\n  /// \\returns true if at least one copyin variable is found, false otherwise.\n  bool EmitOMPCopyinClause(const OMPExecutableDirective &D);\n  /// Emit initial code for lastprivate variables. If some variable is\n  /// not also firstprivate, then the default initialization is used. Otherwise\n  /// initialization of this variable is performed by EmitOMPFirstprivateClause\n  /// method.\n  ///\n  /// \\param D Directive that may have 'lastprivate' directives.\n  /// \\param PrivateScope Private scope for capturing lastprivate variables for\n  /// proper codegen in internal captured statement.\n  ///\n  /// \\returns true if there is at least one lastprivate variable, false\n  /// otherwise.\n  bool EmitOMPLastprivateClauseInit(const OMPExecutableDirective &D,\n                                    OMPPrivateScope &PrivateScope);\n  /// Emit final copying of lastprivate values to original variables at\n  /// the end of the worksharing or simd directive.\n  ///\n  /// \\param D Directive that has at least one 'lastprivate' directives.\n  /// \\param IsLastIterCond Boolean condition that must be set to 'i1 true' if\n  /// it is the last iteration of the loop code in associated directive, or to\n  /// 'i1 false' otherwise. If this item is nullptr, no final check is required.\n  void EmitOMPLastprivateClauseFinal(const OMPExecutableDirective &D,\n                                     bool NoFinals,\n                                     llvm::Value *IsLastIterCond = nullptr);\n  /// Emit initial code for linear clauses.\n  void EmitOMPLinearClause(const OMPLoopDirective &D,\n                           CodeGenFunction::OMPPrivateScope &PrivateScope);\n  /// Emit final code for linear clauses.\n  /// \\param CondGen Optional conditional code for final part of codegen for\n  /// linear clause.\n  void EmitOMPLinearClauseFinal(\n      const OMPLoopDirective &D,\n      const llvm::function_ref<llvm::Value *(CodeGenFunction &)> CondGen);\n  /// Emit initial code for reduction variables. Creates reduction copies\n  /// and initializes them with the values according to OpenMP standard.\n  ///\n  /// \\param D Directive (possibly) with the 'reduction' clause.\n  /// \\param PrivateScope Private scope for capturing reduction variables for\n  /// proper codegen in internal captured statement.\n  ///\n  void EmitOMPReductionClauseInit(const OMPExecutableDirective &D,\n                                  OMPPrivateScope &PrivateScope,\n                                  bool ForInscan = false);\n  /// Emit final update of reduction values to original variables at\n  /// the end of the directive.\n  ///\n  /// \\param D Directive that has at least one 'reduction' directives.\n  /// \\param ReductionKind The kind of reduction to perform.\n  void EmitOMPReductionClauseFinal(const OMPExecutableDirective &D,\n                                   const OpenMPDirectiveKind ReductionKind);\n  /// Emit initial code for linear variables. Creates private copies\n  /// and initializes them with the values according to OpenMP standard.\n  ///\n  /// \\param D Directive (possibly) with the 'linear' clause.\n  /// \\return true if at least one linear variable is found that should be\n  /// initialized with the value of the original variable, false otherwise.\n  bool EmitOMPLinearClauseInit(const OMPLoopDirective &D);\n\n  typedef const llvm::function_ref<void(CodeGenFunction & /*CGF*/,\n                                        llvm::Function * /*OutlinedFn*/,\n                                        const OMPTaskDataTy & /*Data*/)>\n      TaskGenTy;\n  void EmitOMPTaskBasedDirective(const OMPExecutableDirective &S,\n                                 const OpenMPDirectiveKind CapturedRegion,\n                                 const RegionCodeGenTy &BodyGen,\n                                 const TaskGenTy &TaskGen, OMPTaskDataTy &Data);\n  struct OMPTargetDataInfo {\n    Address BasePointersArray = Address::invalid();\n    Address PointersArray = Address::invalid();\n    Address SizesArray = Address::invalid();\n    Address MappersArray = Address::invalid();\n    unsigned NumberOfTargetItems = 0;\n    explicit OMPTargetDataInfo() = default;\n    OMPTargetDataInfo(Address BasePointersArray, Address PointersArray,\n                      Address SizesArray, Address MappersArray,\n                      unsigned NumberOfTargetItems)\n        : BasePointersArray(BasePointersArray), PointersArray(PointersArray),\n          SizesArray(SizesArray), MappersArray(MappersArray),\n          NumberOfTargetItems(NumberOfTargetItems) {}\n  };\n  void EmitOMPTargetTaskBasedDirective(const OMPExecutableDirective &S,\n                                       const RegionCodeGenTy &BodyGen,\n                                       OMPTargetDataInfo &InputInfo);\n\n  void EmitOMPParallelDirective(const OMPParallelDirective &S);\n  void EmitOMPSimdDirective(const OMPSimdDirective &S);\n  void EmitOMPTileDirective(const OMPTileDirective &S);\n  void EmitOMPForDirective(const OMPForDirective &S);\n  void EmitOMPForSimdDirective(const OMPForSimdDirective &S);\n  void EmitOMPSectionsDirective(const OMPSectionsDirective &S);\n  void EmitOMPSectionDirective(const OMPSectionDirective &S);\n  void EmitOMPSingleDirective(const OMPSingleDirective &S);\n  void EmitOMPMasterDirective(const OMPMasterDirective &S);\n  void EmitOMPCriticalDirective(const OMPCriticalDirective &S);\n  void EmitOMPParallelForDirective(const OMPParallelForDirective &S);\n  void EmitOMPParallelForSimdDirective(const OMPParallelForSimdDirective &S);\n  void EmitOMPParallelSectionsDirective(const OMPParallelSectionsDirective &S);\n  void EmitOMPParallelMasterDirective(const OMPParallelMasterDirective &S);\n  void EmitOMPTaskDirective(const OMPTaskDirective &S);\n  void EmitOMPTaskyieldDirective(const OMPTaskyieldDirective &S);\n  void EmitOMPBarrierDirective(const OMPBarrierDirective &S);\n  void EmitOMPTaskwaitDirective(const OMPTaskwaitDirective &S);\n  void EmitOMPTaskgroupDirective(const OMPTaskgroupDirective &S);\n  void EmitOMPFlushDirective(const OMPFlushDirective &S);\n  void EmitOMPDepobjDirective(const OMPDepobjDirective &S);\n  void EmitOMPScanDirective(const OMPScanDirective &S);\n  void EmitOMPOrderedDirective(const OMPOrderedDirective &S);\n  void EmitOMPAtomicDirective(const OMPAtomicDirective &S);\n  void EmitOMPTargetDirective(const OMPTargetDirective &S);\n  void EmitOMPTargetDataDirective(const OMPTargetDataDirective &S);\n  void EmitOMPTargetEnterDataDirective(const OMPTargetEnterDataDirective &S);\n  void EmitOMPTargetExitDataDirective(const OMPTargetExitDataDirective &S);\n  void EmitOMPTargetUpdateDirective(const OMPTargetUpdateDirective &S);\n  void EmitOMPTargetParallelDirective(const OMPTargetParallelDirective &S);\n  void\n  EmitOMPTargetParallelForDirective(const OMPTargetParallelForDirective &S);\n  void EmitOMPTeamsDirective(const OMPTeamsDirective &S);\n  void\n  EmitOMPCancellationPointDirective(const OMPCancellationPointDirective &S);\n  void EmitOMPCancelDirective(const OMPCancelDirective &S);\n  void EmitOMPTaskLoopBasedDirective(const OMPLoopDirective &S);\n  void EmitOMPTaskLoopDirective(const OMPTaskLoopDirective &S);\n  void EmitOMPTaskLoopSimdDirective(const OMPTaskLoopSimdDirective &S);\n  void EmitOMPMasterTaskLoopDirective(const OMPMasterTaskLoopDirective &S);\n  void\n  EmitOMPMasterTaskLoopSimdDirective(const OMPMasterTaskLoopSimdDirective &S);\n  void EmitOMPParallelMasterTaskLoopDirective(\n      const OMPParallelMasterTaskLoopDirective &S);\n  void EmitOMPParallelMasterTaskLoopSimdDirective(\n      const OMPParallelMasterTaskLoopSimdDirective &S);\n  void EmitOMPDistributeDirective(const OMPDistributeDirective &S);\n  void EmitOMPDistributeParallelForDirective(\n      const OMPDistributeParallelForDirective &S);\n  void EmitOMPDistributeParallelForSimdDirective(\n      const OMPDistributeParallelForSimdDirective &S);\n  void EmitOMPDistributeSimdDirective(const OMPDistributeSimdDirective &S);\n  void EmitOMPTargetParallelForSimdDirective(\n      const OMPTargetParallelForSimdDirective &S);\n  void EmitOMPTargetSimdDirective(const OMPTargetSimdDirective &S);\n  void EmitOMPTeamsDistributeDirective(const OMPTeamsDistributeDirective &S);\n  void\n  EmitOMPTeamsDistributeSimdDirective(const OMPTeamsDistributeSimdDirective &S);\n  void EmitOMPTeamsDistributeParallelForSimdDirective(\n      const OMPTeamsDistributeParallelForSimdDirective &S);\n  void EmitOMPTeamsDistributeParallelForDirective(\n      const OMPTeamsDistributeParallelForDirective &S);\n  void EmitOMPTargetTeamsDirective(const OMPTargetTeamsDirective &S);\n  void EmitOMPTargetTeamsDistributeDirective(\n      const OMPTargetTeamsDistributeDirective &S);\n  void EmitOMPTargetTeamsDistributeParallelForDirective(\n      const OMPTargetTeamsDistributeParallelForDirective &S);\n  void EmitOMPTargetTeamsDistributeParallelForSimdDirective(\n      const OMPTargetTeamsDistributeParallelForSimdDirective &S);\n  void EmitOMPTargetTeamsDistributeSimdDirective(\n      const OMPTargetTeamsDistributeSimdDirective &S);\n\n  /// Emit device code for the target directive.\n  static void EmitOMPTargetDeviceFunction(CodeGenModule &CGM,\n                                          StringRef ParentName,\n                                          const OMPTargetDirective &S);\n  static void\n  EmitOMPTargetParallelDeviceFunction(CodeGenModule &CGM, StringRef ParentName,\n                                      const OMPTargetParallelDirective &S);\n  /// Emit device code for the target parallel for directive.\n  static void EmitOMPTargetParallelForDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetParallelForDirective &S);\n  /// Emit device code for the target parallel for simd directive.\n  static void EmitOMPTargetParallelForSimdDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetParallelForSimdDirective &S);\n  /// Emit device code for the target teams directive.\n  static void\n  EmitOMPTargetTeamsDeviceFunction(CodeGenModule &CGM, StringRef ParentName,\n                                   const OMPTargetTeamsDirective &S);\n  /// Emit device code for the target teams distribute directive.\n  static void EmitOMPTargetTeamsDistributeDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetTeamsDistributeDirective &S);\n  /// Emit device code for the target teams distribute simd directive.\n  static void EmitOMPTargetTeamsDistributeSimdDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetTeamsDistributeSimdDirective &S);\n  /// Emit device code for the target simd directive.\n  static void EmitOMPTargetSimdDeviceFunction(CodeGenModule &CGM,\n                                              StringRef ParentName,\n                                              const OMPTargetSimdDirective &S);\n  /// Emit device code for the target teams distribute parallel for simd\n  /// directive.\n  static void EmitOMPTargetTeamsDistributeParallelForSimdDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetTeamsDistributeParallelForSimdDirective &S);\n\n  static void EmitOMPTargetTeamsDistributeParallelForDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetTeamsDistributeParallelForDirective &S);\n\n  /// Emit the Stmt \\p S and return its topmost canonical loop, if any.\n  /// TODO: The \\p Depth paramter is not yet implemented and must be 1. In the\n  /// future it is meant to be the number of loops expected in the loop nests\n  /// (usually specified by the \"collapse\" clause) that are collapsed to a\n  /// single loop by this function.\n  llvm::CanonicalLoopInfo *EmitOMPCollapsedCanonicalLoopNest(const Stmt *S,\n                                                             int Depth);\n\n  /// Emit an OMPCanonicalLoop using the OpenMPIRBuilder.\n  void EmitOMPCanonicalLoop(const OMPCanonicalLoop *S);\n\n  /// Emit inner loop of the worksharing/simd construct.\n  ///\n  /// \\param S Directive, for which the inner loop must be emitted.\n  /// \\param RequiresCleanup true, if directive has some associated private\n  /// variables.\n  /// \\param LoopCond Bollean condition for loop continuation.\n  /// \\param IncExpr Increment expression for loop control variable.\n  /// \\param BodyGen Generator for the inner body of the inner loop.\n  /// \\param PostIncGen Genrator for post-increment code (required for ordered\n  /// loop directvies).\n  void EmitOMPInnerLoop(\n      const OMPExecutableDirective &S, bool RequiresCleanup,\n      const Expr *LoopCond, const Expr *IncExpr,\n      const llvm::function_ref<void(CodeGenFunction &)> BodyGen,\n      const llvm::function_ref<void(CodeGenFunction &)> PostIncGen);\n\n  JumpDest getOMPCancelDestination(OpenMPDirectiveKind Kind);\n  /// Emit initial code for loop counters of loop-based directives.\n  void EmitOMPPrivateLoopCounters(const OMPLoopDirective &S,\n                                  OMPPrivateScope &LoopScope);\n\n  /// Helper for the OpenMP loop directives.\n  void EmitOMPLoopBody(const OMPLoopDirective &D, JumpDest LoopExit);\n\n  /// Emit code for the worksharing loop-based directive.\n  /// \\return true, if this construct has any lastprivate clause, false -\n  /// otherwise.\n  bool EmitOMPWorksharingLoop(const OMPLoopDirective &S, Expr *EUB,\n                              const CodeGenLoopBoundsTy &CodeGenLoopBounds,\n                              const CodeGenDispatchBoundsTy &CGDispatchBounds);\n\n  /// Emit code for the distribute loop-based directive.\n  void EmitOMPDistributeLoop(const OMPLoopDirective &S,\n                             const CodeGenLoopTy &CodeGenLoop, Expr *IncExpr);\n\n  /// Helpers for the OpenMP loop directives.\n  void EmitOMPSimdInit(const OMPLoopDirective &D, bool IsMonotonic = false);\n  void EmitOMPSimdFinal(\n      const OMPLoopDirective &D,\n      const llvm::function_ref<llvm::Value *(CodeGenFunction &)> CondGen);\n\n  /// Emits the lvalue for the expression with possibly captured variable.\n  LValue EmitOMPSharedLValue(const Expr *E);\n\nprivate:\n  /// Helpers for blocks.\n  llvm::Value *EmitBlockLiteral(const CGBlockInfo &Info);\n\n  /// struct with the values to be passed to the OpenMP loop-related functions\n  struct OMPLoopArguments {\n    /// loop lower bound\n    Address LB = Address::invalid();\n    /// loop upper bound\n    Address UB = Address::invalid();\n    /// loop stride\n    Address ST = Address::invalid();\n    /// isLastIteration argument for runtime functions\n    Address IL = Address::invalid();\n    /// Chunk value generated by sema\n    llvm::Value *Chunk = nullptr;\n    /// EnsureUpperBound\n    Expr *EUB = nullptr;\n    /// IncrementExpression\n    Expr *IncExpr = nullptr;\n    /// Loop initialization\n    Expr *Init = nullptr;\n    /// Loop exit condition\n    Expr *Cond = nullptr;\n    /// Update of LB after a whole chunk has been executed\n    Expr *NextLB = nullptr;\n    /// Update of UB after a whole chunk has been executed\n    Expr *NextUB = nullptr;\n    OMPLoopArguments() = default;\n    OMPLoopArguments(Address LB, Address UB, Address ST, Address IL,\n                     llvm::Value *Chunk = nullptr, Expr *EUB = nullptr,\n                     Expr *IncExpr = nullptr, Expr *Init = nullptr,\n                     Expr *Cond = nullptr, Expr *NextLB = nullptr,\n                     Expr *NextUB = nullptr)\n        : LB(LB), UB(UB), ST(ST), IL(IL), Chunk(Chunk), EUB(EUB),\n          IncExpr(IncExpr), Init(Init), Cond(Cond), NextLB(NextLB),\n          NextUB(NextUB) {}\n  };\n  void EmitOMPOuterLoop(bool DynamicOrOrdered, bool IsMonotonic,\n                        const OMPLoopDirective &S, OMPPrivateScope &LoopScope,\n                        const OMPLoopArguments &LoopArgs,\n                        const CodeGenLoopTy &CodeGenLoop,\n                        const CodeGenOrderedTy &CodeGenOrdered);\n  void EmitOMPForOuterLoop(const OpenMPScheduleTy &ScheduleKind,\n                           bool IsMonotonic, const OMPLoopDirective &S,\n                           OMPPrivateScope &LoopScope, bool Ordered,\n                           const OMPLoopArguments &LoopArgs,\n                           const CodeGenDispatchBoundsTy &CGDispatchBounds);\n  void EmitOMPDistributeOuterLoop(OpenMPDistScheduleClauseKind ScheduleKind,\n                                  const OMPLoopDirective &S,\n                                  OMPPrivateScope &LoopScope,\n                                  const OMPLoopArguments &LoopArgs,\n                                  const CodeGenLoopTy &CodeGenLoopContent);\n  /// Emit code for sections directive.\n  void EmitSections(const OMPExecutableDirective &S);\n\npublic:\n\n  //===--------------------------------------------------------------------===//\n  //                         LValue Expression Emission\n  //===--------------------------------------------------------------------===//\n\n  /// Create a check that a scalar RValue is non-null.\n  llvm::Value *EmitNonNullRValueCheck(RValue RV, QualType T);\n\n  /// GetUndefRValue - Get an appropriate 'undef' rvalue for the given type.\n  RValue GetUndefRValue(QualType Ty);\n\n  /// EmitUnsupportedRValue - Emit a dummy r-value using the type of E\n  /// and issue an ErrorUnsupported style diagnostic (using the\n  /// provided Name).\n  RValue EmitUnsupportedRValue(const Expr *E,\n                               const char *Name);\n\n  /// EmitUnsupportedLValue - Emit a dummy l-value using the type of E and issue\n  /// an ErrorUnsupported style diagnostic (using the provided Name).\n  LValue EmitUnsupportedLValue(const Expr *E,\n                               const char *Name);\n\n  /// EmitLValue - Emit code to compute a designator that specifies the location\n  /// of the expression.\n  ///\n  /// This can return one of two things: a simple address or a bitfield\n  /// reference.  In either case, the LLVM Value* in the LValue structure is\n  /// guaranteed to be an LLVM pointer type.\n  ///\n  /// If this returns a bitfield reference, nothing about the pointee type of\n  /// the LLVM value is known: For example, it may not be a pointer to an\n  /// integer.\n  ///\n  /// If this returns a normal address, and if the lvalue's C type is fixed\n  /// size, this method guarantees that the returned pointer type will point to\n  /// an LLVM type of the same size of the lvalue's type.  If the lvalue has a\n  /// variable length type, this is not possible.\n  ///\n  LValue EmitLValue(const Expr *E);\n\n  /// Same as EmitLValue but additionally we generate checking code to\n  /// guard against undefined behavior.  This is only suitable when we know\n  /// that the address will be used to access the object.\n  LValue EmitCheckedLValue(const Expr *E, TypeCheckKind TCK);\n\n  RValue convertTempToRValue(Address addr, QualType type,\n                             SourceLocation Loc);\n\n  void EmitAtomicInit(Expr *E, LValue lvalue);\n\n  bool LValueIsSuitableForInlineAtomic(LValue Src);\n\n  RValue EmitAtomicLoad(LValue LV, SourceLocation SL,\n                        AggValueSlot Slot = AggValueSlot::ignored());\n\n  RValue EmitAtomicLoad(LValue lvalue, SourceLocation loc,\n                        llvm::AtomicOrdering AO, bool IsVolatile = false,\n                        AggValueSlot slot = AggValueSlot::ignored());\n\n  void EmitAtomicStore(RValue rvalue, LValue lvalue, bool isInit);\n\n  void EmitAtomicStore(RValue rvalue, LValue lvalue, llvm::AtomicOrdering AO,\n                       bool IsVolatile, bool isInit);\n\n  std::pair<RValue, llvm::Value *> EmitAtomicCompareExchange(\n      LValue Obj, RValue Expected, RValue Desired, SourceLocation Loc,\n      llvm::AtomicOrdering Success =\n          llvm::AtomicOrdering::SequentiallyConsistent,\n      llvm::AtomicOrdering Failure =\n          llvm::AtomicOrdering::SequentiallyConsistent,\n      bool IsWeak = false, AggValueSlot Slot = AggValueSlot::ignored());\n\n  void EmitAtomicUpdate(LValue LVal, llvm::AtomicOrdering AO,\n                        const llvm::function_ref<RValue(RValue)> &UpdateOp,\n                        bool IsVolatile);\n\n  /// EmitToMemory - Change a scalar value from its value\n  /// representation to its in-memory representation.\n  llvm::Value *EmitToMemory(llvm::Value *Value, QualType Ty);\n\n  /// EmitFromMemory - Change a scalar value from its memory\n  /// representation to its value representation.\n  llvm::Value *EmitFromMemory(llvm::Value *Value, QualType Ty);\n\n  /// Check if the scalar \\p Value is within the valid range for the given\n  /// type \\p Ty.\n  ///\n  /// Returns true if a check is needed (even if the range is unknown).\n  bool EmitScalarRangeCheck(llvm::Value *Value, QualType Ty,\n                            SourceLocation Loc);\n\n  /// EmitLoadOfScalar - Load a scalar value from an address, taking\n  /// care to appropriately convert from the memory representation to\n  /// the LLVM value representation.\n  llvm::Value *EmitLoadOfScalar(Address Addr, bool Volatile, QualType Ty,\n                                SourceLocation Loc,\n                                AlignmentSource Source = AlignmentSource::Type,\n                                bool isNontemporal = false) {\n    return EmitLoadOfScalar(Addr, Volatile, Ty, Loc, LValueBaseInfo(Source),\n                            CGM.getTBAAAccessInfo(Ty), isNontemporal);\n  }\n\n  llvm::Value *EmitLoadOfScalar(Address Addr, bool Volatile, QualType Ty,\n                                SourceLocation Loc, LValueBaseInfo BaseInfo,\n                                TBAAAccessInfo TBAAInfo,\n                                bool isNontemporal = false);\n\n  /// EmitLoadOfScalar - Load a scalar value from an address, taking\n  /// care to appropriately convert from the memory representation to\n  /// the LLVM value representation.  The l-value must be a simple\n  /// l-value.\n  llvm::Value *EmitLoadOfScalar(LValue lvalue, SourceLocation Loc);\n\n  /// EmitStoreOfScalar - Store a scalar value to an address, taking\n  /// care to appropriately convert from the memory representation to\n  /// the LLVM value representation.\n  void EmitStoreOfScalar(llvm::Value *Value, Address Addr,\n                         bool Volatile, QualType Ty,\n                         AlignmentSource Source = AlignmentSource::Type,\n                         bool isInit = false, bool isNontemporal = false) {\n    EmitStoreOfScalar(Value, Addr, Volatile, Ty, LValueBaseInfo(Source),\n                      CGM.getTBAAAccessInfo(Ty), isInit, isNontemporal);\n  }\n\n  void EmitStoreOfScalar(llvm::Value *Value, Address Addr,\n                         bool Volatile, QualType Ty,\n                         LValueBaseInfo BaseInfo, TBAAAccessInfo TBAAInfo,\n                         bool isInit = false, bool isNontemporal = false);\n\n  /// EmitStoreOfScalar - Store a scalar value to an address, taking\n  /// care to appropriately convert from the memory representation to\n  /// the LLVM value representation.  The l-value must be a simple\n  /// l-value.  The isInit flag indicates whether this is an initialization.\n  /// If so, atomic qualifiers are ignored and the store is always non-atomic.\n  void EmitStoreOfScalar(llvm::Value *value, LValue lvalue, bool isInit=false);\n\n  /// EmitLoadOfLValue - Given an expression that represents a value lvalue,\n  /// this method emits the address of the lvalue, then loads the result as an\n  /// rvalue, returning the rvalue.\n  RValue EmitLoadOfLValue(LValue V, SourceLocation Loc);\n  RValue EmitLoadOfExtVectorElementLValue(LValue V);\n  RValue EmitLoadOfBitfieldLValue(LValue LV, SourceLocation Loc);\n  RValue EmitLoadOfGlobalRegLValue(LValue LV);\n\n  /// EmitStoreThroughLValue - Store the specified rvalue into the specified\n  /// lvalue, where both are guaranteed to the have the same type, and that type\n  /// is 'Ty'.\n  void EmitStoreThroughLValue(RValue Src, LValue Dst, bool isInit = false);\n  void EmitStoreThroughExtVectorComponentLValue(RValue Src, LValue Dst);\n  void EmitStoreThroughGlobalRegLValue(RValue Src, LValue Dst);\n\n  /// EmitStoreThroughBitfieldLValue - Store Src into Dst with same constraints\n  /// as EmitStoreThroughLValue.\n  ///\n  /// \\param Result [out] - If non-null, this will be set to a Value* for the\n  /// bit-field contents after the store, appropriate for use as the result of\n  /// an assignment to the bit-field.\n  void EmitStoreThroughBitfieldLValue(RValue Src, LValue Dst,\n                                      llvm::Value **Result=nullptr);\n\n  /// Emit an l-value for an assignment (simple or compound) of complex type.\n  LValue EmitComplexAssignmentLValue(const BinaryOperator *E);\n  LValue EmitComplexCompoundAssignmentLValue(const CompoundAssignOperator *E);\n  LValue EmitScalarCompoundAssignWithComplex(const CompoundAssignOperator *E,\n                                             llvm::Value *&Result);\n\n  // Note: only available for agg return types\n  LValue EmitBinaryOperatorLValue(const BinaryOperator *E);\n  LValue EmitCompoundAssignmentLValue(const CompoundAssignOperator *E);\n  // Note: only available for agg return types\n  LValue EmitCallExprLValue(const CallExpr *E);\n  // Note: only available for agg return types\n  LValue EmitVAArgExprLValue(const VAArgExpr *E);\n  LValue EmitDeclRefLValue(const DeclRefExpr *E);\n  LValue EmitStringLiteralLValue(const StringLiteral *E);\n  LValue EmitObjCEncodeExprLValue(const ObjCEncodeExpr *E);\n  LValue EmitPredefinedLValue(const PredefinedExpr *E);\n  LValue EmitUnaryOpLValue(const UnaryOperator *E);\n  LValue EmitArraySubscriptExpr(const ArraySubscriptExpr *E,\n                                bool Accessed = false);\n  LValue EmitMatrixSubscriptExpr(const MatrixSubscriptExpr *E);\n  LValue EmitOMPArraySectionExpr(const OMPArraySectionExpr *E,\n                                 bool IsLowerBound = true);\n  LValue EmitExtVectorElementExpr(const ExtVectorElementExpr *E);\n  LValue EmitMemberExpr(const MemberExpr *E);\n  LValue EmitObjCIsaExpr(const ObjCIsaExpr *E);\n  LValue EmitCompoundLiteralLValue(const CompoundLiteralExpr *E);\n  LValue EmitInitListLValue(const InitListExpr *E);\n  LValue EmitConditionalOperatorLValue(const AbstractConditionalOperator *E);\n  LValue EmitCastLValue(const CastExpr *E);\n  LValue EmitMaterializeTemporaryExpr(const MaterializeTemporaryExpr *E);\n  LValue EmitOpaqueValueLValue(const OpaqueValueExpr *e);\n\n  Address EmitExtVectorElementLValue(LValue V);\n\n  RValue EmitRValueForField(LValue LV, const FieldDecl *FD, SourceLocation Loc);\n\n  Address EmitArrayToPointerDecay(const Expr *Array,\n                                  LValueBaseInfo *BaseInfo = nullptr,\n                                  TBAAAccessInfo *TBAAInfo = nullptr);\n\n  class ConstantEmission {\n    llvm::PointerIntPair<llvm::Constant*, 1, bool> ValueAndIsReference;\n    ConstantEmission(llvm::Constant *C, bool isReference)\n      : ValueAndIsReference(C, isReference) {}\n  public:\n    ConstantEmission() {}\n    static ConstantEmission forReference(llvm::Constant *C) {\n      return ConstantEmission(C, true);\n    }\n    static ConstantEmission forValue(llvm::Constant *C) {\n      return ConstantEmission(C, false);\n    }\n\n    explicit operator bool() const {\n      return ValueAndIsReference.getOpaqueValue() != nullptr;\n    }\n\n    bool isReference() const { return ValueAndIsReference.getInt(); }\n    LValue getReferenceLValue(CodeGenFunction &CGF, Expr *refExpr) const {\n      assert(isReference());\n      return CGF.MakeNaturalAlignAddrLValue(ValueAndIsReference.getPointer(),\n                                            refExpr->getType());\n    }\n\n    llvm::Constant *getValue() const {\n      assert(!isReference());\n      return ValueAndIsReference.getPointer();\n    }\n  };\n\n  ConstantEmission tryEmitAsConstant(DeclRefExpr *refExpr);\n  ConstantEmission tryEmitAsConstant(const MemberExpr *ME);\n  llvm::Value *emitScalarConstant(const ConstantEmission &Constant, Expr *E);\n\n  RValue EmitPseudoObjectRValue(const PseudoObjectExpr *e,\n                                AggValueSlot slot = AggValueSlot::ignored());\n  LValue EmitPseudoObjectLValue(const PseudoObjectExpr *e);\n\n  llvm::Value *EmitIvarOffset(const ObjCInterfaceDecl *Interface,\n                              const ObjCIvarDecl *Ivar);\n  LValue EmitLValueForField(LValue Base, const FieldDecl* Field);\n  LValue EmitLValueForLambdaField(const FieldDecl *Field);\n\n  /// EmitLValueForFieldInitialization - Like EmitLValueForField, except that\n  /// if the Field is a reference, this will return the address of the reference\n  /// and not the address of the value stored in the reference.\n  LValue EmitLValueForFieldInitialization(LValue Base,\n                                          const FieldDecl* Field);\n\n  LValue EmitLValueForIvar(QualType ObjectTy,\n                           llvm::Value* Base, const ObjCIvarDecl *Ivar,\n                           unsigned CVRQualifiers);\n\n  LValue EmitCXXConstructLValue(const CXXConstructExpr *E);\n  LValue EmitCXXBindTemporaryLValue(const CXXBindTemporaryExpr *E);\n  LValue EmitCXXTypeidLValue(const CXXTypeidExpr *E);\n  LValue EmitCXXUuidofLValue(const CXXUuidofExpr *E);\n\n  LValue EmitObjCMessageExprLValue(const ObjCMessageExpr *E);\n  LValue EmitObjCIvarRefLValue(const ObjCIvarRefExpr *E);\n  LValue EmitStmtExprLValue(const StmtExpr *E);\n  LValue EmitPointerToDataMemberBinaryExpr(const BinaryOperator *E);\n  LValue EmitObjCSelectorLValue(const ObjCSelectorExpr *E);\n  void   EmitDeclRefExprDbgValue(const DeclRefExpr *E, const APValue &Init);\n\n  //===--------------------------------------------------------------------===//\n  //                         Scalar Expression Emission\n  //===--------------------------------------------------------------------===//\n\n  /// EmitCall - Generate a call of the given function, expecting the given\n  /// result type, and using the given argument list which specifies both the\n  /// LLVM arguments and the types they were derived from.\n  RValue EmitCall(const CGFunctionInfo &CallInfo, const CGCallee &Callee,\n                  ReturnValueSlot ReturnValue, const CallArgList &Args,\n                  llvm::CallBase **callOrInvoke, SourceLocation Loc);\n  RValue EmitCall(const CGFunctionInfo &CallInfo, const CGCallee &Callee,\n                  ReturnValueSlot ReturnValue, const CallArgList &Args,\n                  llvm::CallBase **callOrInvoke = nullptr) {\n    return EmitCall(CallInfo, Callee, ReturnValue, Args, callOrInvoke,\n                    SourceLocation());\n  }\n  RValue EmitCall(QualType FnType, const CGCallee &Callee, const CallExpr *E,\n                  ReturnValueSlot ReturnValue, llvm::Value *Chain = nullptr);\n  RValue EmitCallExpr(const CallExpr *E,\n                      ReturnValueSlot ReturnValue = ReturnValueSlot());\n  RValue EmitSimpleCallExpr(const CallExpr *E, ReturnValueSlot ReturnValue);\n  CGCallee EmitCallee(const Expr *E);\n\n  void checkTargetFeatures(const CallExpr *E, const FunctionDecl *TargetDecl);\n  void checkTargetFeatures(SourceLocation Loc, const FunctionDecl *TargetDecl);\n\n  llvm::CallInst *EmitRuntimeCall(llvm::FunctionCallee callee,\n                                  const Twine &name = \"\");\n  llvm::CallInst *EmitRuntimeCall(llvm::FunctionCallee callee,\n                                  ArrayRef<llvm::Value *> args,\n                                  const Twine &name = \"\");\n  llvm::CallInst *EmitNounwindRuntimeCall(llvm::FunctionCallee callee,\n                                          const Twine &name = \"\");\n  llvm::CallInst *EmitNounwindRuntimeCall(llvm::FunctionCallee callee,\n                                          ArrayRef<llvm::Value *> args,\n                                          const Twine &name = \"\");\n\n  SmallVector<llvm::OperandBundleDef, 1>\n  getBundlesForFunclet(llvm::Value *Callee);\n\n  llvm::CallBase *EmitCallOrInvoke(llvm::FunctionCallee Callee,\n                                   ArrayRef<llvm::Value *> Args,\n                                   const Twine &Name = \"\");\n  llvm::CallBase *EmitRuntimeCallOrInvoke(llvm::FunctionCallee callee,\n                                          ArrayRef<llvm::Value *> args,\n                                          const Twine &name = \"\");\n  llvm::CallBase *EmitRuntimeCallOrInvoke(llvm::FunctionCallee callee,\n                                          const Twine &name = \"\");\n  void EmitNoreturnRuntimeCallOrInvoke(llvm::FunctionCallee callee,\n                                       ArrayRef<llvm::Value *> args);\n\n  CGCallee BuildAppleKextVirtualCall(const CXXMethodDecl *MD,\n                                     NestedNameSpecifier *Qual,\n                                     llvm::Type *Ty);\n\n  CGCallee BuildAppleKextVirtualDestructorCall(const CXXDestructorDecl *DD,\n                                               CXXDtorType Type,\n                                               const CXXRecordDecl *RD);\n\n  // Return the copy constructor name with the prefix \"__copy_constructor_\"\n  // removed.\n  static std::string getNonTrivialCopyConstructorStr(QualType QT,\n                                                     CharUnits Alignment,\n                                                     bool IsVolatile,\n                                                     ASTContext &Ctx);\n\n  // Return the destructor name with the prefix \"__destructor_\" removed.\n  static std::string getNonTrivialDestructorStr(QualType QT,\n                                                CharUnits Alignment,\n                                                bool IsVolatile,\n                                                ASTContext &Ctx);\n\n  // These functions emit calls to the special functions of non-trivial C\n  // structs.\n  void defaultInitNonTrivialCStructVar(LValue Dst);\n  void callCStructDefaultConstructor(LValue Dst);\n  void callCStructDestructor(LValue Dst);\n  void callCStructCopyConstructor(LValue Dst, LValue Src);\n  void callCStructMoveConstructor(LValue Dst, LValue Src);\n  void callCStructCopyAssignmentOperator(LValue Dst, LValue Src);\n  void callCStructMoveAssignmentOperator(LValue Dst, LValue Src);\n\n  RValue\n  EmitCXXMemberOrOperatorCall(const CXXMethodDecl *Method,\n                              const CGCallee &Callee,\n                              ReturnValueSlot ReturnValue, llvm::Value *This,\n                              llvm::Value *ImplicitParam,\n                              QualType ImplicitParamTy, const CallExpr *E,\n                              CallArgList *RtlArgs);\n  RValue EmitCXXDestructorCall(GlobalDecl Dtor, const CGCallee &Callee,\n                               llvm::Value *This, QualType ThisTy,\n                               llvm::Value *ImplicitParam,\n                               QualType ImplicitParamTy, const CallExpr *E);\n  RValue EmitCXXMemberCallExpr(const CXXMemberCallExpr *E,\n                               ReturnValueSlot ReturnValue);\n  RValue EmitCXXMemberOrOperatorMemberCallExpr(const CallExpr *CE,\n                                               const CXXMethodDecl *MD,\n                                               ReturnValueSlot ReturnValue,\n                                               bool HasQualifier,\n                                               NestedNameSpecifier *Qualifier,\n                                               bool IsArrow, const Expr *Base);\n  // Compute the object pointer.\n  Address EmitCXXMemberDataPointerAddress(const Expr *E, Address base,\n                                          llvm::Value *memberPtr,\n                                          const MemberPointerType *memberPtrType,\n                                          LValueBaseInfo *BaseInfo = nullptr,\n                                          TBAAAccessInfo *TBAAInfo = nullptr);\n  RValue EmitCXXMemberPointerCallExpr(const CXXMemberCallExpr *E,\n                                      ReturnValueSlot ReturnValue);\n\n  RValue EmitCXXOperatorMemberCallExpr(const CXXOperatorCallExpr *E,\n                                       const CXXMethodDecl *MD,\n                                       ReturnValueSlot ReturnValue);\n  RValue EmitCXXPseudoDestructorExpr(const CXXPseudoDestructorExpr *E);\n\n  RValue EmitCUDAKernelCallExpr(const CUDAKernelCallExpr *E,\n                                ReturnValueSlot ReturnValue);\n\n  RValue EmitNVPTXDevicePrintfCallExpr(const CallExpr *E,\n                                       ReturnValueSlot ReturnValue);\n  RValue EmitAMDGPUDevicePrintfCallExpr(const CallExpr *E,\n                                        ReturnValueSlot ReturnValue);\n\n  RValue EmitBuiltinExpr(const GlobalDecl GD, unsigned BuiltinID,\n                         const CallExpr *E, ReturnValueSlot ReturnValue);\n\n  RValue emitRotate(const CallExpr *E, bool IsRotateRight);\n\n  /// Emit IR for __builtin_os_log_format.\n  RValue emitBuiltinOSLogFormat(const CallExpr &E);\n\n  /// Emit IR for __builtin_is_aligned.\n  RValue EmitBuiltinIsAligned(const CallExpr *E);\n  /// Emit IR for __builtin_align_up/__builtin_align_down.\n  RValue EmitBuiltinAlignTo(const CallExpr *E, bool AlignUp);\n\n  llvm::Function *generateBuiltinOSLogHelperFunction(\n      const analyze_os_log::OSLogBufferLayout &Layout,\n      CharUnits BufferAlignment);\n\n  RValue EmitBlockCallExpr(const CallExpr *E, ReturnValueSlot ReturnValue);\n\n  /// EmitTargetBuiltinExpr - Emit the given builtin call. Returns 0 if the call\n  /// is unhandled by the current target.\n  llvm::Value *EmitTargetBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                     ReturnValueSlot ReturnValue);\n\n  llvm::Value *EmitAArch64CompareBuiltinExpr(llvm::Value *Op, llvm::Type *Ty,\n                                             const llvm::CmpInst::Predicate Fp,\n                                             const llvm::CmpInst::Predicate Ip,\n                                             const llvm::Twine &Name = \"\");\n  llvm::Value *EmitARMBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                  ReturnValueSlot ReturnValue,\n                                  llvm::Triple::ArchType Arch);\n  llvm::Value *EmitARMMVEBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                     ReturnValueSlot ReturnValue,\n                                     llvm::Triple::ArchType Arch);\n  llvm::Value *EmitARMCDEBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                     ReturnValueSlot ReturnValue,\n                                     llvm::Triple::ArchType Arch);\n  llvm::Value *EmitCMSEClearRecord(llvm::Value *V, llvm::IntegerType *ITy,\n                                   QualType RTy);\n  llvm::Value *EmitCMSEClearRecord(llvm::Value *V, llvm::ArrayType *ATy,\n                                   QualType RTy);\n\n  llvm::Value *EmitCommonNeonBuiltinExpr(unsigned BuiltinID,\n                                         unsigned LLVMIntrinsic,\n                                         unsigned AltLLVMIntrinsic,\n                                         const char *NameHint,\n                                         unsigned Modifier,\n                                         const CallExpr *E,\n                                         SmallVectorImpl<llvm::Value *> &Ops,\n                                         Address PtrOp0, Address PtrOp1,\n                                         llvm::Triple::ArchType Arch);\n\n  llvm::Function *LookupNeonLLVMIntrinsic(unsigned IntrinsicID,\n                                          unsigned Modifier, llvm::Type *ArgTy,\n                                          const CallExpr *E);\n  llvm::Value *EmitNeonCall(llvm::Function *F,\n                            SmallVectorImpl<llvm::Value*> &O,\n                            const char *name,\n                            unsigned shift = 0, bool rightshift = false);\n  llvm::Value *EmitNeonSplat(llvm::Value *V, llvm::Constant *Idx,\n                             const llvm::ElementCount &Count);\n  llvm::Value *EmitNeonSplat(llvm::Value *V, llvm::Constant *Idx);\n  llvm::Value *EmitNeonShiftVector(llvm::Value *V, llvm::Type *Ty,\n                                   bool negateForRightShift);\n  llvm::Value *EmitNeonRShiftImm(llvm::Value *Vec, llvm::Value *Amt,\n                                 llvm::Type *Ty, bool usgn, const char *name);\n  llvm::Value *vectorWrapScalar16(llvm::Value *Op);\n  /// SVEBuiltinMemEltTy - Returns the memory element type for this memory\n  /// access builtin.  Only required if it can't be inferred from the base\n  /// pointer operand.\n  llvm::Type *SVEBuiltinMemEltTy(SVETypeFlags TypeFlags);\n\n  SmallVector<llvm::Type *, 2> getSVEOverloadTypes(SVETypeFlags TypeFlags,\n                                                   llvm::Type *ReturnType,\n                                                   ArrayRef<llvm::Value *> Ops);\n  llvm::Type *getEltType(SVETypeFlags TypeFlags);\n  llvm::ScalableVectorType *getSVEType(const SVETypeFlags &TypeFlags);\n  llvm::ScalableVectorType *getSVEPredType(SVETypeFlags TypeFlags);\n  llvm::Value *EmitSVEAllTruePred(SVETypeFlags TypeFlags);\n  llvm::Value *EmitSVEDupX(llvm::Value *Scalar);\n  llvm::Value *EmitSVEDupX(llvm::Value *Scalar, llvm::Type *Ty);\n  llvm::Value *EmitSVEReinterpret(llvm::Value *Val, llvm::Type *Ty);\n  llvm::Value *EmitSVEPMull(SVETypeFlags TypeFlags,\n                            llvm::SmallVectorImpl<llvm::Value *> &Ops,\n                            unsigned BuiltinID);\n  llvm::Value *EmitSVEMovl(SVETypeFlags TypeFlags,\n                           llvm::ArrayRef<llvm::Value *> Ops,\n                           unsigned BuiltinID);\n  llvm::Value *EmitSVEPredicateCast(llvm::Value *Pred,\n                                    llvm::ScalableVectorType *VTy);\n  llvm::Value *EmitSVEGatherLoad(SVETypeFlags TypeFlags,\n                                 llvm::SmallVectorImpl<llvm::Value *> &Ops,\n                                 unsigned IntID);\n  llvm::Value *EmitSVEScatterStore(SVETypeFlags TypeFlags,\n                                   llvm::SmallVectorImpl<llvm::Value *> &Ops,\n                                   unsigned IntID);\n  llvm::Value *EmitSVEMaskedLoad(const CallExpr *, llvm::Type *ReturnTy,\n                                 SmallVectorImpl<llvm::Value *> &Ops,\n                                 unsigned BuiltinID, bool IsZExtReturn);\n  llvm::Value *EmitSVEMaskedStore(const CallExpr *,\n                                  SmallVectorImpl<llvm::Value *> &Ops,\n                                  unsigned BuiltinID);\n  llvm::Value *EmitSVEPrefetchLoad(SVETypeFlags TypeFlags,\n                                   SmallVectorImpl<llvm::Value *> &Ops,\n                                   unsigned BuiltinID);\n  llvm::Value *EmitSVEGatherPrefetch(SVETypeFlags TypeFlags,\n                                     SmallVectorImpl<llvm::Value *> &Ops,\n                                     unsigned IntID);\n  llvm::Value *EmitSVEStructLoad(SVETypeFlags TypeFlags,\n                                 SmallVectorImpl<llvm::Value *> &Ops, unsigned IntID);\n  llvm::Value *EmitSVEStructStore(SVETypeFlags TypeFlags,\n                                  SmallVectorImpl<llvm::Value *> &Ops,\n                                  unsigned IntID);\n  llvm::Value *EmitAArch64SVEBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n\n  llvm::Value *EmitAArch64BuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                      llvm::Triple::ArchType Arch);\n  llvm::Value *EmitBPFBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n\n  llvm::Value *BuildVector(ArrayRef<llvm::Value*> Ops);\n  llvm::Value *EmitX86BuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitPPCBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitAMDGPUBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitSystemZBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitNVPTXBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitWebAssemblyBuiltinExpr(unsigned BuiltinID,\n                                          const CallExpr *E);\n  llvm::Value *EmitHexagonBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitRISCVBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                    ReturnValueSlot ReturnValue);\n  bool ProcessOrderScopeAMDGCN(llvm::Value *Order, llvm::Value *Scope,\n                               llvm::AtomicOrdering &AO,\n                               llvm::SyncScope::ID &SSID);\n\n  enum class MSVCIntrin;\n  llvm::Value *EmitMSVCBuiltinExpr(MSVCIntrin BuiltinID, const CallExpr *E);\n\n  llvm::Value *EmitBuiltinAvailable(const VersionTuple &Version);\n\n  llvm::Value *EmitObjCProtocolExpr(const ObjCProtocolExpr *E);\n  llvm::Value *EmitObjCStringLiteral(const ObjCStringLiteral *E);\n  llvm::Value *EmitObjCBoxedExpr(const ObjCBoxedExpr *E);\n  llvm::Value *EmitObjCArrayLiteral(const ObjCArrayLiteral *E);\n  llvm::Value *EmitObjCDictionaryLiteral(const ObjCDictionaryLiteral *E);\n  llvm::Value *EmitObjCCollectionLiteral(const Expr *E,\n                                const ObjCMethodDecl *MethodWithObjects);\n  llvm::Value *EmitObjCSelectorExpr(const ObjCSelectorExpr *E);\n  RValue EmitObjCMessageExpr(const ObjCMessageExpr *E,\n                             ReturnValueSlot Return = ReturnValueSlot());\n\n  /// Retrieves the default cleanup kind for an ARC cleanup.\n  /// Except under -fobjc-arc-eh, ARC cleanups are normal-only.\n  CleanupKind getARCCleanupKind() {\n    return CGM.getCodeGenOpts().ObjCAutoRefCountExceptions\n             ? NormalAndEHCleanup : NormalCleanup;\n  }\n\n  // ARC primitives.\n  void EmitARCInitWeak(Address addr, llvm::Value *value);\n  void EmitARCDestroyWeak(Address addr);\n  llvm::Value *EmitARCLoadWeak(Address addr);\n  llvm::Value *EmitARCLoadWeakRetained(Address addr);\n  llvm::Value *EmitARCStoreWeak(Address addr, llvm::Value *value, bool ignored);\n  void emitARCCopyAssignWeak(QualType Ty, Address DstAddr, Address SrcAddr);\n  void emitARCMoveAssignWeak(QualType Ty, Address DstAddr, Address SrcAddr);\n  void EmitARCCopyWeak(Address dst, Address src);\n  void EmitARCMoveWeak(Address dst, Address src);\n  llvm::Value *EmitARCRetainAutorelease(QualType type, llvm::Value *value);\n  llvm::Value *EmitARCRetainAutoreleaseNonBlock(llvm::Value *value);\n  llvm::Value *EmitARCStoreStrong(LValue lvalue, llvm::Value *value,\n                                  bool resultIgnored);\n  llvm::Value *EmitARCStoreStrongCall(Address addr, llvm::Value *value,\n                                      bool resultIgnored);\n  llvm::Value *EmitARCRetain(QualType type, llvm::Value *value);\n  llvm::Value *EmitARCRetainNonBlock(llvm::Value *value);\n  llvm::Value *EmitARCRetainBlock(llvm::Value *value, bool mandatory);\n  void EmitARCDestroyStrong(Address addr, ARCPreciseLifetime_t precise);\n  void EmitARCRelease(llvm::Value *value, ARCPreciseLifetime_t precise);\n  llvm::Value *EmitARCAutorelease(llvm::Value *value);\n  llvm::Value *EmitARCAutoreleaseReturnValue(llvm::Value *value);\n  llvm::Value *EmitARCRetainAutoreleaseReturnValue(llvm::Value *value);\n  llvm::Value *EmitARCRetainAutoreleasedReturnValue(llvm::Value *value);\n  llvm::Value *EmitARCUnsafeClaimAutoreleasedReturnValue(llvm::Value *value);\n\n  llvm::Value *EmitObjCAutorelease(llvm::Value *value, llvm::Type *returnType);\n  llvm::Value *EmitObjCRetainNonBlock(llvm::Value *value,\n                                      llvm::Type *returnType);\n  void EmitObjCRelease(llvm::Value *value, ARCPreciseLifetime_t precise);\n\n  std::pair<LValue,llvm::Value*>\n  EmitARCStoreAutoreleasing(const BinaryOperator *e);\n  std::pair<LValue,llvm::Value*>\n  EmitARCStoreStrong(const BinaryOperator *e, bool ignored);\n  std::pair<LValue,llvm::Value*>\n  EmitARCStoreUnsafeUnretained(const BinaryOperator *e, bool ignored);\n\n  llvm::Value *EmitObjCAlloc(llvm::Value *value,\n                             llvm::Type *returnType);\n  llvm::Value *EmitObjCAllocWithZone(llvm::Value *value,\n                                     llvm::Type *returnType);\n  llvm::Value *EmitObjCAllocInit(llvm::Value *value, llvm::Type *resultType);\n\n  llvm::Value *EmitObjCThrowOperand(const Expr *expr);\n  llvm::Value *EmitObjCConsumeObject(QualType T, llvm::Value *Ptr);\n  llvm::Value *EmitObjCExtendObjectLifetime(QualType T, llvm::Value *Ptr);\n\n  llvm::Value *EmitARCExtendBlockObject(const Expr *expr);\n  llvm::Value *EmitARCReclaimReturnedObject(const Expr *e,\n                                            bool allowUnsafeClaim);\n  llvm::Value *EmitARCRetainScalarExpr(const Expr *expr);\n  llvm::Value *EmitARCRetainAutoreleaseScalarExpr(const Expr *expr);\n  llvm::Value *EmitARCUnsafeUnretainedScalarExpr(const Expr *expr);\n\n  void EmitARCIntrinsicUse(ArrayRef<llvm::Value*> values);\n\n  void EmitARCNoopIntrinsicUse(ArrayRef<llvm::Value *> values);\n\n  static Destroyer destroyARCStrongImprecise;\n  static Destroyer destroyARCStrongPrecise;\n  static Destroyer destroyARCWeak;\n  static Destroyer emitARCIntrinsicUse;\n  static Destroyer destroyNonTrivialCStruct;\n\n  void EmitObjCAutoreleasePoolPop(llvm::Value *Ptr);\n  llvm::Value *EmitObjCAutoreleasePoolPush();\n  llvm::Value *EmitObjCMRRAutoreleasePoolPush();\n  void EmitObjCAutoreleasePoolCleanup(llvm::Value *Ptr);\n  void EmitObjCMRRAutoreleasePoolPop(llvm::Value *Ptr);\n\n  /// Emits a reference binding to the passed in expression.\n  RValue EmitReferenceBindingToExpr(const Expr *E);\n\n  //===--------------------------------------------------------------------===//\n  //                           Expression Emission\n  //===--------------------------------------------------------------------===//\n\n  // Expressions are broken into three classes: scalar, complex, aggregate.\n\n  /// EmitScalarExpr - Emit the computation of the specified expression of LLVM\n  /// scalar type, returning the result.\n  llvm::Value *EmitScalarExpr(const Expr *E , bool IgnoreResultAssign = false);\n\n  /// Emit a conversion from the specified type to the specified destination\n  /// type, both of which are LLVM scalar types.\n  llvm::Value *EmitScalarConversion(llvm::Value *Src, QualType SrcTy,\n                                    QualType DstTy, SourceLocation Loc);\n\n  /// Emit a conversion from the specified complex type to the specified\n  /// destination type, where the destination type is an LLVM scalar type.\n  llvm::Value *EmitComplexToScalarConversion(ComplexPairTy Src, QualType SrcTy,\n                                             QualType DstTy,\n                                             SourceLocation Loc);\n\n  /// EmitAggExpr - Emit the computation of the specified expression\n  /// of aggregate type.  The result is computed into the given slot,\n  /// which may be null to indicate that the value is not needed.\n  void EmitAggExpr(const Expr *E, AggValueSlot AS);\n\n  /// EmitAggExprToLValue - Emit the computation of the specified expression of\n  /// aggregate type into a temporary LValue.\n  LValue EmitAggExprToLValue(const Expr *E);\n\n  /// Build all the stores needed to initialize an aggregate at Dest with the\n  /// value Val.\n  void EmitAggregateStore(llvm::Value *Val, Address Dest, bool DestIsVolatile);\n\n  /// EmitExtendGCLifetime - Given a pointer to an Objective-C object,\n  /// make sure it survives garbage collection until this point.\n  void EmitExtendGCLifetime(llvm::Value *object);\n\n  /// EmitComplexExpr - Emit the computation of the specified expression of\n  /// complex type, returning the result.\n  ComplexPairTy EmitComplexExpr(const Expr *E,\n                                bool IgnoreReal = false,\n                                bool IgnoreImag = false);\n\n  /// EmitComplexExprIntoLValue - Emit the given expression of complex\n  /// type and place its result into the specified l-value.\n  void EmitComplexExprIntoLValue(const Expr *E, LValue dest, bool isInit);\n\n  /// EmitStoreOfComplex - Store a complex number into the specified l-value.\n  void EmitStoreOfComplex(ComplexPairTy V, LValue dest, bool isInit);\n\n  /// EmitLoadOfComplex - Load a complex number from the specified l-value.\n  ComplexPairTy EmitLoadOfComplex(LValue src, SourceLocation loc);\n\n  Address emitAddrOfRealComponent(Address complex, QualType complexType);\n  Address emitAddrOfImagComponent(Address complex, QualType complexType);\n\n  /// AddInitializerToStaticVarDecl - Add the initializer for 'D' to the\n  /// global variable that has already been created for it.  If the initializer\n  /// has a different type than GV does, this may free GV and return a different\n  /// one.  Otherwise it just returns GV.\n  llvm::GlobalVariable *\n  AddInitializerToStaticVarDecl(const VarDecl &D,\n                                llvm::GlobalVariable *GV);\n\n  // Emit an @llvm.invariant.start call for the given memory region.\n  void EmitInvariantStart(llvm::Constant *Addr, CharUnits Size);\n\n  /// EmitCXXGlobalVarDeclInit - Create the initializer for a C++\n  /// variable with global storage.\n  void EmitCXXGlobalVarDeclInit(const VarDecl &D, llvm::Constant *DeclPtr,\n                                bool PerformInit);\n\n  llvm::Function *createAtExitStub(const VarDecl &VD, llvm::FunctionCallee Dtor,\n                                   llvm::Constant *Addr);\n\n  /// Call atexit() with a function that passes the given argument to\n  /// the given function.\n  void registerGlobalDtorWithAtExit(const VarDecl &D, llvm::FunctionCallee fn,\n                                    llvm::Constant *addr);\n\n  /// Call atexit() with function dtorStub.\n  void registerGlobalDtorWithAtExit(llvm::Constant *dtorStub);\n\n  /// Call unatexit() with function dtorStub.\n  llvm::Value *unregisterGlobalDtorWithUnAtExit(llvm::Constant *dtorStub);\n\n  /// Emit code in this function to perform a guarded variable\n  /// initialization.  Guarded initializations are used when it's not\n  /// possible to prove that an initialization will be done exactly\n  /// once, e.g. with a static local variable or a static data member\n  /// of a class template.\n  void EmitCXXGuardedInit(const VarDecl &D, llvm::GlobalVariable *DeclPtr,\n                          bool PerformInit);\n\n  enum class GuardKind { VariableGuard, TlsGuard };\n\n  /// Emit a branch to select whether or not to perform guarded initialization.\n  void EmitCXXGuardedInitBranch(llvm::Value *NeedsInit,\n                                llvm::BasicBlock *InitBlock,\n                                llvm::BasicBlock *NoInitBlock,\n                                GuardKind Kind, const VarDecl *D);\n\n  /// GenerateCXXGlobalInitFunc - Generates code for initializing global\n  /// variables.\n  void\n  GenerateCXXGlobalInitFunc(llvm::Function *Fn,\n                            ArrayRef<llvm::Function *> CXXThreadLocals,\n                            ConstantAddress Guard = ConstantAddress::invalid());\n\n  /// GenerateCXXGlobalCleanUpFunc - Generates code for cleaning up global\n  /// variables.\n  void GenerateCXXGlobalCleanUpFunc(\n      llvm::Function *Fn,\n      const std::vector<std::tuple<llvm::FunctionType *, llvm::WeakTrackingVH,\n                                   llvm::Constant *>> &DtorsOrStermFinalizers);\n\n  void GenerateCXXGlobalVarDeclInitFunc(llvm::Function *Fn,\n                                        const VarDecl *D,\n                                        llvm::GlobalVariable *Addr,\n                                        bool PerformInit);\n\n  void EmitCXXConstructExpr(const CXXConstructExpr *E, AggValueSlot Dest);\n\n  void EmitSynthesizedCXXCopyCtor(Address Dest, Address Src, const Expr *Exp);\n\n  void EmitCXXThrowExpr(const CXXThrowExpr *E, bool KeepInsertionPoint = true);\n\n  RValue EmitAtomicExpr(AtomicExpr *E);\n\n  //===--------------------------------------------------------------------===//\n  //                         Annotations Emission\n  //===--------------------------------------------------------------------===//\n\n  /// Emit an annotation call (intrinsic).\n  llvm::Value *EmitAnnotationCall(llvm::Function *AnnotationFn,\n                                  llvm::Value *AnnotatedVal,\n                                  StringRef AnnotationStr,\n                                  SourceLocation Location,\n                                  const AnnotateAttr *Attr);\n\n  /// Emit local annotations for the local variable V, declared by D.\n  void EmitVarAnnotations(const VarDecl *D, llvm::Value *V);\n\n  /// Emit field annotations for the given field & value. Returns the\n  /// annotation result.\n  Address EmitFieldAnnotations(const FieldDecl *D, Address V);\n\n  //===--------------------------------------------------------------------===//\n  //                             Internal Helpers\n  //===--------------------------------------------------------------------===//\n\n  /// ContainsLabel - Return true if the statement contains a label in it.  If\n  /// this statement is not executed normally, it not containing a label means\n  /// that we can just remove the code.\n  static bool ContainsLabel(const Stmt *S, bool IgnoreCaseStmts = false);\n\n  /// containsBreak - Return true if the statement contains a break out of it.\n  /// If the statement (recursively) contains a switch or loop with a break\n  /// inside of it, this is fine.\n  static bool containsBreak(const Stmt *S);\n\n  /// Determine if the given statement might introduce a declaration into the\n  /// current scope, by being a (possibly-labelled) DeclStmt.\n  static bool mightAddDeclToScope(const Stmt *S);\n\n  /// ConstantFoldsToSimpleInteger - If the specified expression does not fold\n  /// to a constant, or if it does but contains a label, return false.  If it\n  /// constant folds return true and set the boolean result in Result.\n  bool ConstantFoldsToSimpleInteger(const Expr *Cond, bool &Result,\n                                    bool AllowLabels = false);\n\n  /// ConstantFoldsToSimpleInteger - If the specified expression does not fold\n  /// to a constant, or if it does but contains a label, return false.  If it\n  /// constant folds return true and set the folded value.\n  bool ConstantFoldsToSimpleInteger(const Expr *Cond, llvm::APSInt &Result,\n                                    bool AllowLabels = false);\n\n  /// isInstrumentedCondition - Determine whether the given condition is an\n  /// instrumentable condition (i.e. no \"&&\" or \"||\").\n  static bool isInstrumentedCondition(const Expr *C);\n\n  /// EmitBranchToCounterBlock - Emit a conditional branch to a new block that\n  /// increments a profile counter based on the semantics of the given logical\n  /// operator opcode.  This is used to instrument branch condition coverage\n  /// for logical operators.\n  void EmitBranchToCounterBlock(const Expr *Cond, BinaryOperator::Opcode LOp,\n                                llvm::BasicBlock *TrueBlock,\n                                llvm::BasicBlock *FalseBlock,\n                                uint64_t TrueCount = 0,\n                                Stmt::Likelihood LH = Stmt::LH_None,\n                                const Expr *CntrIdx = nullptr);\n\n  /// EmitBranchOnBoolExpr - Emit a branch on a boolean condition (e.g. for an\n  /// if statement) to the specified blocks.  Based on the condition, this might\n  /// try to simplify the codegen of the conditional based on the branch.\n  /// TrueCount should be the number of times we expect the condition to\n  /// evaluate to true based on PGO data.\n  void EmitBranchOnBoolExpr(const Expr *Cond, llvm::BasicBlock *TrueBlock,\n                            llvm::BasicBlock *FalseBlock, uint64_t TrueCount,\n                            Stmt::Likelihood LH = Stmt::LH_None);\n\n  /// Given an assignment `*LHS = RHS`, emit a test that checks if \\p RHS is\n  /// nonnull, if \\p LHS is marked _Nonnull.\n  void EmitNullabilityCheck(LValue LHS, llvm::Value *RHS, SourceLocation Loc);\n\n  /// An enumeration which makes it easier to specify whether or not an\n  /// operation is a subtraction.\n  enum { NotSubtraction = false, IsSubtraction = true };\n\n  /// Same as IRBuilder::CreateInBoundsGEP, but additionally emits a check to\n  /// detect undefined behavior when the pointer overflow sanitizer is enabled.\n  /// \\p SignedIndices indicates whether any of the GEP indices are signed.\n  /// \\p IsSubtraction indicates whether the expression used to form the GEP\n  /// is a subtraction.\n  llvm::Value *EmitCheckedInBoundsGEP(llvm::Value *Ptr,\n                                      ArrayRef<llvm::Value *> IdxList,\n                                      bool SignedIndices,\n                                      bool IsSubtraction,\n                                      SourceLocation Loc,\n                                      const Twine &Name = \"\");\n\n  /// Specifies which type of sanitizer check to apply when handling a\n  /// particular builtin.\n  enum BuiltinCheckKind {\n    BCK_CTZPassedZero,\n    BCK_CLZPassedZero,\n  };\n\n  /// Emits an argument for a call to a builtin. If the builtin sanitizer is\n  /// enabled, a runtime check specified by \\p Kind is also emitted.\n  llvm::Value *EmitCheckedArgForBuiltin(const Expr *E, BuiltinCheckKind Kind);\n\n  /// Emit a description of a type in a format suitable for passing to\n  /// a runtime sanitizer handler.\n  llvm::Constant *EmitCheckTypeDescriptor(QualType T);\n\n  /// Convert a value into a format suitable for passing to a runtime\n  /// sanitizer handler.\n  llvm::Value *EmitCheckValue(llvm::Value *V);\n\n  /// Emit a description of a source location in a format suitable for\n  /// passing to a runtime sanitizer handler.\n  llvm::Constant *EmitCheckSourceLocation(SourceLocation Loc);\n\n  /// Create a basic block that will either trap or call a handler function in\n  /// the UBSan runtime with the provided arguments, and create a conditional\n  /// branch to it.\n  void EmitCheck(ArrayRef<std::pair<llvm::Value *, SanitizerMask>> Checked,\n                 SanitizerHandler Check, ArrayRef<llvm::Constant *> StaticArgs,\n                 ArrayRef<llvm::Value *> DynamicArgs);\n\n  /// Emit a slow path cross-DSO CFI check which calls __cfi_slowpath\n  /// if Cond if false.\n  void EmitCfiSlowPathCheck(SanitizerMask Kind, llvm::Value *Cond,\n                            llvm::ConstantInt *TypeId, llvm::Value *Ptr,\n                            ArrayRef<llvm::Constant *> StaticArgs);\n\n  /// Emit a reached-unreachable diagnostic if \\p Loc is valid and runtime\n  /// checking is enabled. Otherwise, just emit an unreachable instruction.\n  void EmitUnreachable(SourceLocation Loc);\n\n  /// Create a basic block that will call the trap intrinsic, and emit a\n  /// conditional branch to it, for the -ftrapv checks.\n  void EmitTrapCheck(llvm::Value *Checked, SanitizerHandler CheckHandlerID);\n\n  /// Emit a call to trap or debugtrap and attach function attribute\n  /// \"trap-func-name\" if specified.\n  llvm::CallInst *EmitTrapCall(llvm::Intrinsic::ID IntrID);\n\n  /// Emit a stub for the cross-DSO CFI check function.\n  void EmitCfiCheckStub();\n\n  /// Emit a cross-DSO CFI failure handling function.\n  void EmitCfiCheckFail();\n\n  /// Create a check for a function parameter that may potentially be\n  /// declared as non-null.\n  void EmitNonNullArgCheck(RValue RV, QualType ArgType, SourceLocation ArgLoc,\n                           AbstractCallee AC, unsigned ParmNum);\n\n  /// EmitCallArg - Emit a single call argument.\n  void EmitCallArg(CallArgList &args, const Expr *E, QualType ArgType);\n\n  /// EmitDelegateCallArg - We are performing a delegate call; that\n  /// is, the current function is delegating to another one.  Produce\n  /// a r-value suitable for passing the given parameter.\n  void EmitDelegateCallArg(CallArgList &args, const VarDecl *param,\n                           SourceLocation loc);\n\n  /// SetFPAccuracy - Set the minimum required accuracy of the given floating\n  /// point operation, expressed as the maximum relative error in ulp.\n  void SetFPAccuracy(llvm::Value *Val, float Accuracy);\n\n  /// SetFPModel - Control floating point behavior via fp-model settings.\n  void SetFPModel();\n\n  /// Set the codegen fast-math flags.\n  void SetFastMathFlags(FPOptions FPFeatures);\n\nprivate:\n  llvm::MDNode *getRangeForLoadFromType(QualType Ty);\n  void EmitReturnOfRValue(RValue RV, QualType Ty);\n\n  void deferPlaceholderReplacement(llvm::Instruction *Old, llvm::Value *New);\n\n  llvm::SmallVector<std::pair<llvm::WeakTrackingVH, llvm::Value *>, 4>\n      DeferredReplacements;\n\n  /// Set the address of a local variable.\n  void setAddrOfLocalVar(const VarDecl *VD, Address Addr) {\n    assert(!LocalDeclMap.count(VD) && \"Decl already exists in LocalDeclMap!\");\n    LocalDeclMap.insert({VD, Addr});\n  }\n\n  /// ExpandTypeFromArgs - Reconstruct a structure of type \\arg Ty\n  /// from function arguments into \\arg Dst. See ABIArgInfo::Expand.\n  ///\n  /// \\param AI - The first function argument of the expansion.\n  void ExpandTypeFromArgs(QualType Ty, LValue Dst,\n                          llvm::Function::arg_iterator &AI);\n\n  /// ExpandTypeToArgs - Expand an CallArg \\arg Arg, with the LLVM type for \\arg\n  /// Ty, into individual arguments on the provided vector \\arg IRCallArgs,\n  /// starting at index \\arg IRCallArgPos. See ABIArgInfo::Expand.\n  void ExpandTypeToArgs(QualType Ty, CallArg Arg, llvm::FunctionType *IRFuncTy,\n                        SmallVectorImpl<llvm::Value *> &IRCallArgs,\n                        unsigned &IRCallArgPos);\n\n  llvm::Value* EmitAsmInput(const TargetInfo::ConstraintInfo &Info,\n                            const Expr *InputExpr, std::string &ConstraintStr);\n\n  llvm::Value* EmitAsmInputLValue(const TargetInfo::ConstraintInfo &Info,\n                                  LValue InputValue, QualType InputType,\n                                  std::string &ConstraintStr,\n                                  SourceLocation Loc);\n\n  /// Attempts to statically evaluate the object size of E. If that\n  /// fails, emits code to figure the size of E out for us. This is\n  /// pass_object_size aware.\n  ///\n  /// If EmittedExpr is non-null, this will use that instead of re-emitting E.\n  llvm::Value *evaluateOrEmitBuiltinObjectSize(const Expr *E, unsigned Type,\n                                               llvm::IntegerType *ResType,\n                                               llvm::Value *EmittedE,\n                                               bool IsDynamic);\n\n  /// Emits the size of E, as required by __builtin_object_size. This\n  /// function is aware of pass_object_size parameters, and will act accordingly\n  /// if E is a parameter with the pass_object_size attribute.\n  llvm::Value *emitBuiltinObjectSize(const Expr *E, unsigned Type,\n                                     llvm::IntegerType *ResType,\n                                     llvm::Value *EmittedE,\n                                     bool IsDynamic);\n\n  void emitZeroOrPatternForAutoVarInit(QualType type, const VarDecl &D,\n                                       Address Loc);\n\npublic:\n  enum class EvaluationOrder {\n    ///! No language constraints on evaluation order.\n    Default,\n    ///! Language semantics require left-to-right evaluation.\n    ForceLeftToRight,\n    ///! Language semantics require right-to-left evaluation.\n    ForceRightToLeft\n  };\n\n  // Wrapper for function prototype sources. Wraps either a FunctionProtoType or\n  // an ObjCMethodDecl.\n  struct PrototypeWrapper {\n    llvm::PointerUnion<const FunctionProtoType *, const ObjCMethodDecl *> P;\n\n    PrototypeWrapper(const FunctionProtoType *FT) : P(FT) {}\n    PrototypeWrapper(const ObjCMethodDecl *MD) : P(MD) {}\n  };\n\n  void EmitCallArgs(CallArgList &Args, PrototypeWrapper Prototype,\n                    llvm::iterator_range<CallExpr::const_arg_iterator> ArgRange,\n                    AbstractCallee AC = AbstractCallee(),\n                    unsigned ParamsToSkip = 0,\n                    EvaluationOrder Order = EvaluationOrder::Default);\n\n  /// EmitPointerWithAlignment - Given an expression with a pointer type,\n  /// emit the value and compute our best estimate of the alignment of the\n  /// pointee.\n  ///\n  /// \\param BaseInfo - If non-null, this will be initialized with\n  /// information about the source of the alignment and the may-alias\n  /// attribute.  Note that this function will conservatively fall back on\n  /// the type when it doesn't recognize the expression and may-alias will\n  /// be set to false.\n  ///\n  /// One reasonable way to use this information is when there's a language\n  /// guarantee that the pointer must be aligned to some stricter value, and\n  /// we're simply trying to ensure that sufficiently obvious uses of under-\n  /// aligned objects don't get miscompiled; for example, a placement new\n  /// into the address of a local variable.  In such a case, it's quite\n  /// reasonable to just ignore the returned alignment when it isn't from an\n  /// explicit source.\n  Address EmitPointerWithAlignment(const Expr *Addr,\n                                   LValueBaseInfo *BaseInfo = nullptr,\n                                   TBAAAccessInfo *TBAAInfo = nullptr);\n\n  /// If \\p E references a parameter with pass_object_size info or a constant\n  /// array size modifier, emit the object size divided by the size of \\p EltTy.\n  /// Otherwise return null.\n  llvm::Value *LoadPassedObjectSize(const Expr *E, QualType EltTy);\n\n  void EmitSanitizerStatReport(llvm::SanitizerStatKind SSK);\n\n  struct MultiVersionResolverOption {\n    llvm::Function *Function;\n    FunctionDecl *FD;\n    struct Conds {\n      StringRef Architecture;\n      llvm::SmallVector<StringRef, 8> Features;\n\n      Conds(StringRef Arch, ArrayRef<StringRef> Feats)\n          : Architecture(Arch), Features(Feats.begin(), Feats.end()) {}\n    } Conditions;\n\n    MultiVersionResolverOption(llvm::Function *F, StringRef Arch,\n                               ArrayRef<StringRef> Feats)\n        : Function(F), Conditions(Arch, Feats) {}\n  };\n\n  // Emits the body of a multiversion function's resolver. Assumes that the\n  // options are already sorted in the proper order, with the 'default' option\n  // last (if it exists).\n  void EmitMultiVersionResolver(llvm::Function *Resolver,\n                                ArrayRef<MultiVersionResolverOption> Options);\n\n  static uint64_t GetX86CpuSupportsMask(ArrayRef<StringRef> FeatureStrs);\n\nprivate:\n  QualType getVarArgType(const Expr *Arg);\n\n  void EmitDeclMetadata();\n\n  BlockByrefHelpers *buildByrefHelpers(llvm::StructType &byrefType,\n                                  const AutoVarEmission &emission);\n\n  void AddObjCARCExceptionMetadata(llvm::Instruction *Inst);\n\n  llvm::Value *GetValueForARMHint(unsigned BuiltinID);\n  llvm::Value *EmitX86CpuIs(const CallExpr *E);\n  llvm::Value *EmitX86CpuIs(StringRef CPUStr);\n  llvm::Value *EmitX86CpuSupports(const CallExpr *E);\n  llvm::Value *EmitX86CpuSupports(ArrayRef<StringRef> FeatureStrs);\n  llvm::Value *EmitX86CpuSupports(uint64_t Mask);\n  llvm::Value *EmitX86CpuInit();\n  llvm::Value *FormResolverCondition(const MultiVersionResolverOption &RO);\n};\n\n/// TargetFeatures - This class is used to check whether the builtin function\n/// has the required tagert specific features. It is able to support the\n/// combination of ','(and), '|'(or), and '()'. By default, the priority of\n/// ',' is higher than that of '|' .\n/// E.g:\n/// A,B|C means the builtin function requires both A and B, or C.\n/// If we want the builtin function requires both A and B, or both A and C,\n/// there are two ways: A,B|A,C or A,(B|C).\n/// The FeaturesList should not contain spaces, and brackets must appear in\n/// pairs.\nclass TargetFeatures {\n  struct FeatureListStatus {\n    bool HasFeatures;\n    StringRef CurFeaturesList;\n  };\n\n  const llvm::StringMap<bool> &CallerFeatureMap;\n\n  FeatureListStatus getAndFeatures(StringRef FeatureList) {\n    int InParentheses = 0;\n    bool HasFeatures = true;\n    size_t SubexpressionStart = 0;\n    for (size_t i = 0, e = FeatureList.size(); i < e; ++i) {\n      char CurrentToken = FeatureList[i];\n      switch (CurrentToken) {\n      default:\n        break;\n      case '(':\n        if (InParentheses == 0)\n          SubexpressionStart = i + 1;\n        ++InParentheses;\n        break;\n      case ')':\n        --InParentheses;\n        assert(InParentheses >= 0 && \"Parentheses are not in pair\");\n        LLVM_FALLTHROUGH;\n      case '|':\n      case ',':\n        if (InParentheses == 0) {\n          if (HasFeatures && i != SubexpressionStart) {\n            StringRef F = FeatureList.slice(SubexpressionStart, i);\n            HasFeatures = CurrentToken == ')' ? hasRequiredFeatures(F)\n                                              : CallerFeatureMap.lookup(F);\n          }\n          SubexpressionStart = i + 1;\n          if (CurrentToken == '|') {\n            return {HasFeatures, FeatureList.substr(SubexpressionStart)};\n          }\n        }\n        break;\n      }\n    }\n    assert(InParentheses == 0 && \"Parentheses are not in pair\");\n    if (HasFeatures && SubexpressionStart != FeatureList.size())\n      HasFeatures =\n          CallerFeatureMap.lookup(FeatureList.substr(SubexpressionStart));\n    return {HasFeatures, StringRef()};\n  }\n\npublic:\n  bool hasRequiredFeatures(StringRef FeatureList) {\n    FeatureListStatus FS = {false, FeatureList};\n    while (!FS.HasFeatures && !FS.CurFeaturesList.empty())\n      FS = getAndFeatures(FS.CurFeaturesList);\n    return FS.HasFeatures;\n  }\n\n  TargetFeatures(const llvm::StringMap<bool> &CallerFeatureMap)\n      : CallerFeatureMap(CallerFeatureMap) {}\n};\n\ninline DominatingLLVMValue::saved_type\nDominatingLLVMValue::save(CodeGenFunction &CGF, llvm::Value *value) {\n  if (!needsSaving(value)) return saved_type(value, false);\n\n  // Otherwise, we need an alloca.\n  auto align = CharUnits::fromQuantity(\n            CGF.CGM.getDataLayout().getPrefTypeAlignment(value->getType()));\n  Address alloca =\n    CGF.CreateTempAlloca(value->getType(), align, \"cond-cleanup.save\");\n  CGF.Builder.CreateStore(value, alloca);\n\n  return saved_type(alloca.getPointer(), true);\n}\n\ninline llvm::Value *DominatingLLVMValue::restore(CodeGenFunction &CGF,\n                                                 saved_type value) {\n  // If the value says it wasn't saved, trust that it's still dominating.\n  if (!value.getInt()) return value.getPointer();\n\n  // Otherwise, it should be an alloca instruction, as set up in save().\n  auto alloca = cast<llvm::AllocaInst>(value.getPointer());\n  return CGF.Builder.CreateAlignedLoad(alloca->getAllocatedType(), alloca,\n                                       alloca->getAlign());\n}\n\n}  // end namespace CodeGen\n\n// Map the LangOption for floating point exception behavior into\n// the corresponding enum in the IR.\nllvm::fp::ExceptionBehavior\nToConstrainedExceptMD(LangOptions::FPExceptionModeKind Kind);\n}  // end namespace clang\n\n#endif\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "content": "//===--- CodeGenModule.h - Per-Module state for LLVM CodeGen ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This is the internal per-translation-unit state used for llvm translation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CODEGENMODULE_H\n#define LLVM_CLANG_LIB_CODEGEN_CODEGENMODULE_H\n\n#include \"CGVTables.h\"\n#include \"CodeGenTypeCache.h\"\n#include \"CodeGenTypes.h\"\n#include \"SanitizerMetadata.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/Basic/ABI.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/NoSanitizeList.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Basic/XRayLists.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Transforms/Utils/SanitizerStats.h\"\n\nnamespace llvm {\nclass Module;\nclass Constant;\nclass ConstantInt;\nclass Function;\nclass GlobalValue;\nclass DataLayout;\nclass FunctionType;\nclass LLVMContext;\nclass OpenMPIRBuilder;\nclass IndexedInstrProfReader;\n}\n\nnamespace clang {\nclass ASTContext;\nclass AtomicType;\nclass FunctionDecl;\nclass IdentifierInfo;\nclass ObjCMethodDecl;\nclass ObjCImplementationDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCProtocolDecl;\nclass ObjCEncodeExpr;\nclass BlockExpr;\nclass CharUnits;\nclass Decl;\nclass Expr;\nclass Stmt;\nclass InitListExpr;\nclass StringLiteral;\nclass NamedDecl;\nclass ValueDecl;\nclass VarDecl;\nclass LangOptions;\nclass CodeGenOptions;\nclass HeaderSearchOptions;\nclass DiagnosticsEngine;\nclass AnnotateAttr;\nclass CXXDestructorDecl;\nclass Module;\nclass CoverageSourceInfo;\nclass TargetAttr;\nclass InitSegAttr;\nstruct ParsedTargetAttr;\n\nnamespace CodeGen {\n\nclass CallArgList;\nclass CodeGenFunction;\nclass CodeGenTBAA;\nclass CGCXXABI;\nclass CGDebugInfo;\nclass CGObjCRuntime;\nclass CGOpenCLRuntime;\nclass CGOpenMPRuntime;\nclass CGCUDARuntime;\nclass BlockFieldFlags;\nclass FunctionArgList;\nclass CoverageMappingModuleGen;\nclass TargetCodeGenInfo;\n\nenum ForDefinition_t : bool {\n  NotForDefinition = false,\n  ForDefinition = true\n};\n\nstruct OrderGlobalInits {\n  unsigned int priority;\n  unsigned int lex_order;\n  OrderGlobalInits(unsigned int p, unsigned int l)\n      : priority(p), lex_order(l) {}\n\n  bool operator==(const OrderGlobalInits &RHS) const {\n    return priority == RHS.priority && lex_order == RHS.lex_order;\n  }\n\n  bool operator<(const OrderGlobalInits &RHS) const {\n    return std::tie(priority, lex_order) <\n           std::tie(RHS.priority, RHS.lex_order);\n  }\n};\n\nstruct ObjCEntrypoints {\n  ObjCEntrypoints() { memset(this, 0, sizeof(*this)); }\n\n  /// void objc_alloc(id);\n  llvm::FunctionCallee objc_alloc;\n\n  /// void objc_allocWithZone(id);\n  llvm::FunctionCallee objc_allocWithZone;\n\n  /// void objc_alloc_init(id);\n  llvm::FunctionCallee objc_alloc_init;\n\n  /// void objc_autoreleasePoolPop(void*);\n  llvm::FunctionCallee objc_autoreleasePoolPop;\n\n  /// void objc_autoreleasePoolPop(void*);\n  /// Note this method is used when we are using exception handling\n  llvm::FunctionCallee objc_autoreleasePoolPopInvoke;\n\n  /// void *objc_autoreleasePoolPush(void);\n  llvm::Function *objc_autoreleasePoolPush;\n\n  /// id objc_autorelease(id);\n  llvm::Function *objc_autorelease;\n\n  /// id objc_autorelease(id);\n  /// Note this is the runtime method not the intrinsic.\n  llvm::FunctionCallee objc_autoreleaseRuntimeFunction;\n\n  /// id objc_autoreleaseReturnValue(id);\n  llvm::Function *objc_autoreleaseReturnValue;\n\n  /// void objc_copyWeak(id *dest, id *src);\n  llvm::Function *objc_copyWeak;\n\n  /// void objc_destroyWeak(id*);\n  llvm::Function *objc_destroyWeak;\n\n  /// id objc_initWeak(id*, id);\n  llvm::Function *objc_initWeak;\n\n  /// id objc_loadWeak(id*);\n  llvm::Function *objc_loadWeak;\n\n  /// id objc_loadWeakRetained(id*);\n  llvm::Function *objc_loadWeakRetained;\n\n  /// void objc_moveWeak(id *dest, id *src);\n  llvm::Function *objc_moveWeak;\n\n  /// id objc_retain(id);\n  llvm::Function *objc_retain;\n\n  /// id objc_retain(id);\n  /// Note this is the runtime method not the intrinsic.\n  llvm::FunctionCallee objc_retainRuntimeFunction;\n\n  /// id objc_retainAutorelease(id);\n  llvm::Function *objc_retainAutorelease;\n\n  /// id objc_retainAutoreleaseReturnValue(id);\n  llvm::Function *objc_retainAutoreleaseReturnValue;\n\n  /// id objc_retainAutoreleasedReturnValue(id);\n  llvm::Function *objc_retainAutoreleasedReturnValue;\n\n  /// id objc_retainBlock(id);\n  llvm::Function *objc_retainBlock;\n\n  /// void objc_release(id);\n  llvm::Function *objc_release;\n\n  /// void objc_release(id);\n  /// Note this is the runtime method not the intrinsic.\n  llvm::FunctionCallee objc_releaseRuntimeFunction;\n\n  /// void objc_storeStrong(id*, id);\n  llvm::Function *objc_storeStrong;\n\n  /// id objc_storeWeak(id*, id);\n  llvm::Function *objc_storeWeak;\n\n  /// id objc_unsafeClaimAutoreleasedReturnValue(id);\n  llvm::Function *objc_unsafeClaimAutoreleasedReturnValue;\n\n  /// A void(void) inline asm to use to mark that the return value of\n  /// a call will be immediately retain.\n  llvm::InlineAsm *retainAutoreleasedReturnValueMarker;\n\n  /// void clang.arc.use(...);\n  llvm::Function *clang_arc_use;\n\n  /// void clang.arc.noop.use(...);\n  llvm::Function *clang_arc_noop_use;\n};\n\n/// This class records statistics on instrumentation based profiling.\nclass InstrProfStats {\n  uint32_t VisitedInMainFile;\n  uint32_t MissingInMainFile;\n  uint32_t Visited;\n  uint32_t Missing;\n  uint32_t Mismatched;\n\npublic:\n  InstrProfStats()\n      : VisitedInMainFile(0), MissingInMainFile(0), Visited(0), Missing(0),\n        Mismatched(0) {}\n  /// Record that we've visited a function and whether or not that function was\n  /// in the main source file.\n  void addVisited(bool MainFile) {\n    if (MainFile)\n      ++VisitedInMainFile;\n    ++Visited;\n  }\n  /// Record that a function we've visited has no profile data.\n  void addMissing(bool MainFile) {\n    if (MainFile)\n      ++MissingInMainFile;\n    ++Missing;\n  }\n  /// Record that a function we've visited has mismatched profile data.\n  void addMismatched(bool MainFile) { ++Mismatched; }\n  /// Whether or not the stats we've gathered indicate any potential problems.\n  bool hasDiagnostics() { return Missing || Mismatched; }\n  /// Report potential problems we've found to \\c Diags.\n  void reportDiagnostics(DiagnosticsEngine &Diags, StringRef MainFile);\n};\n\n/// A pair of helper functions for a __block variable.\nclass BlockByrefHelpers : public llvm::FoldingSetNode {\n  // MSVC requires this type to be complete in order to process this\n  // header.\npublic:\n  llvm::Constant *CopyHelper;\n  llvm::Constant *DisposeHelper;\n\n  /// The alignment of the field.  This is important because\n  /// different offsets to the field within the byref struct need to\n  /// have different helper functions.\n  CharUnits Alignment;\n\n  BlockByrefHelpers(CharUnits alignment)\n      : CopyHelper(nullptr), DisposeHelper(nullptr), Alignment(alignment) {}\n  BlockByrefHelpers(const BlockByrefHelpers &) = default;\n  virtual ~BlockByrefHelpers();\n\n  void Profile(llvm::FoldingSetNodeID &id) const {\n    id.AddInteger(Alignment.getQuantity());\n    profileImpl(id);\n  }\n  virtual void profileImpl(llvm::FoldingSetNodeID &id) const = 0;\n\n  virtual bool needsCopy() const { return true; }\n  virtual void emitCopy(CodeGenFunction &CGF, Address dest, Address src) = 0;\n\n  virtual bool needsDispose() const { return true; }\n  virtual void emitDispose(CodeGenFunction &CGF, Address field) = 0;\n};\n\n/// This class organizes the cross-function state that is used while generating\n/// LLVM code.\nclass CodeGenModule : public CodeGenTypeCache {\n  CodeGenModule(const CodeGenModule &) = delete;\n  void operator=(const CodeGenModule &) = delete;\n\npublic:\n  struct Structor {\n    Structor() : Priority(0), Initializer(nullptr), AssociatedData(nullptr) {}\n    Structor(int Priority, llvm::Constant *Initializer,\n             llvm::Constant *AssociatedData)\n        : Priority(Priority), Initializer(Initializer),\n          AssociatedData(AssociatedData) {}\n    int Priority;\n    llvm::Constant *Initializer;\n    llvm::Constant *AssociatedData;\n  };\n\n  typedef std::vector<Structor> CtorList;\n\nprivate:\n  ASTContext &Context;\n  const LangOptions &LangOpts;\n  const HeaderSearchOptions &HeaderSearchOpts; // Only used for debug info.\n  const PreprocessorOptions &PreprocessorOpts; // Only used for debug info.\n  const CodeGenOptions &CodeGenOpts;\n  unsigned NumAutoVarInit = 0;\n  llvm::Module &TheModule;\n  DiagnosticsEngine &Diags;\n  const TargetInfo &Target;\n  std::unique_ptr<CGCXXABI> ABI;\n  llvm::LLVMContext &VMContext;\n  std::string ModuleNameHash = \"\";\n\n  std::unique_ptr<CodeGenTBAA> TBAA;\n\n  mutable std::unique_ptr<TargetCodeGenInfo> TheTargetCodeGenInfo;\n\n  // This should not be moved earlier, since its initialization depends on some\n  // of the previous reference members being already initialized and also checks\n  // if TheTargetCodeGenInfo is NULL\n  CodeGenTypes Types;\n\n  /// Holds information about C++ vtables.\n  CodeGenVTables VTables;\n\n  std::unique_ptr<CGObjCRuntime> ObjCRuntime;\n  std::unique_ptr<CGOpenCLRuntime> OpenCLRuntime;\n  std::unique_ptr<CGOpenMPRuntime> OpenMPRuntime;\n  std::unique_ptr<CGCUDARuntime> CUDARuntime;\n  std::unique_ptr<CGDebugInfo> DebugInfo;\n  std::unique_ptr<ObjCEntrypoints> ObjCData;\n  llvm::MDNode *NoObjCARCExceptionsMetadata = nullptr;\n  std::unique_ptr<llvm::IndexedInstrProfReader> PGOReader;\n  InstrProfStats PGOStats;\n  std::unique_ptr<llvm::SanitizerStatReport> SanStats;\n\n  // A set of references that have only been seen via a weakref so far. This is\n  // used to remove the weak of the reference if we ever see a direct reference\n  // or a definition.\n  llvm::SmallPtrSet<llvm::GlobalValue*, 10> WeakRefReferences;\n\n  /// This contains all the decls which have definitions but/ which are deferred\n  /// for emission and therefore should only be output if they are actually\n  /// used. If a decl is in this, then it is known to have not been referenced\n  /// yet.\n  std::map<StringRef, GlobalDecl> DeferredDecls;\n\n  /// This is a list of deferred decls which we have seen that *are* actually\n  /// referenced. These get code generated when the module is done.\n  std::vector<GlobalDecl> DeferredDeclsToEmit;\n  void addDeferredDeclToEmit(GlobalDecl GD) {\n    DeferredDeclsToEmit.emplace_back(GD);\n  }\n\n  /// List of alias we have emitted. Used to make sure that what they point to\n  /// is defined once we get to the end of the of the translation unit.\n  std::vector<GlobalDecl> Aliases;\n\n  /// List of multiversion functions that have to be emitted.  Used to make sure\n  /// we properly emit the iFunc.\n  std::vector<GlobalDecl> MultiVersionFuncs;\n\n  typedef llvm::StringMap<llvm::TrackingVH<llvm::Constant> > ReplacementsTy;\n  ReplacementsTy Replacements;\n\n  /// List of global values to be replaced with something else. Used when we\n  /// want to replace a GlobalValue but can't identify it by its mangled name\n  /// anymore (because the name is already taken).\n  llvm::SmallVector<std::pair<llvm::GlobalValue *, llvm::Constant *>, 8>\n    GlobalValReplacements;\n\n  /// Variables for which we've emitted globals containing their constant\n  /// values along with the corresponding globals, for opportunistic reuse.\n  llvm::DenseMap<const VarDecl*, llvm::GlobalVariable*> InitializerConstants;\n\n  /// Set of global decls for which we already diagnosed mangled name conflict.\n  /// Required to not issue a warning (on a mangling conflict) multiple times\n  /// for the same decl.\n  llvm::DenseSet<GlobalDecl> DiagnosedConflictingDefinitions;\n\n  /// A queue of (optional) vtables to consider emitting.\n  std::vector<const CXXRecordDecl*> DeferredVTables;\n\n  /// A queue of (optional) vtables that may be emitted opportunistically.\n  std::vector<const CXXRecordDecl *> OpportunisticVTables;\n\n  /// List of global values which are required to be present in the object file;\n  /// bitcast to i8*. This is used for forcing visibility of symbols which may\n  /// otherwise be optimized out.\n  std::vector<llvm::WeakTrackingVH> LLVMUsed;\n  std::vector<llvm::WeakTrackingVH> LLVMCompilerUsed;\n\n  /// Store the list of global constructors and their respective priorities to\n  /// be emitted when the translation unit is complete.\n  CtorList GlobalCtors;\n\n  /// Store the list of global destructors and their respective priorities to be\n  /// emitted when the translation unit is complete.\n  CtorList GlobalDtors;\n\n  /// An ordered map of canonical GlobalDecls to their mangled names.\n  llvm::MapVector<GlobalDecl, StringRef> MangledDeclNames;\n  llvm::StringMap<GlobalDecl, llvm::BumpPtrAllocator> Manglings;\n\n  // An ordered map of canonical GlobalDecls paired with the cpu-index for\n  // cpu-specific name manglings.\n  llvm::MapVector<std::pair<GlobalDecl, unsigned>, StringRef>\n      CPUSpecificMangledDeclNames;\n  llvm::StringMap<std::pair<GlobalDecl, unsigned>, llvm::BumpPtrAllocator>\n      CPUSpecificManglings;\n\n  /// Global annotations.\n  std::vector<llvm::Constant*> Annotations;\n\n  /// Map used to get unique annotation strings.\n  llvm::StringMap<llvm::Constant*> AnnotationStrings;\n\n  /// Used for uniquing of annotation arguments.\n  llvm::DenseMap<unsigned, llvm::Constant *> AnnotationArgs;\n\n  llvm::StringMap<llvm::GlobalVariable *> CFConstantStringMap;\n\n  llvm::DenseMap<llvm::Constant *, llvm::GlobalVariable *> ConstantStringMap;\n  llvm::DenseMap<const Decl*, llvm::Constant *> StaticLocalDeclMap;\n  llvm::DenseMap<const Decl*, llvm::GlobalVariable*> StaticLocalDeclGuardMap;\n  llvm::DenseMap<const Expr*, llvm::Constant *> MaterializedGlobalTemporaryMap;\n\n  llvm::DenseMap<QualType, llvm::Constant *> AtomicSetterHelperFnMap;\n  llvm::DenseMap<QualType, llvm::Constant *> AtomicGetterHelperFnMap;\n\n  /// Map used to get unique type descriptor constants for sanitizers.\n  llvm::DenseMap<QualType, llvm::Constant *> TypeDescriptorMap;\n\n  /// Map used to track internal linkage functions declared within\n  /// extern \"C\" regions.\n  typedef llvm::MapVector<IdentifierInfo *,\n                          llvm::GlobalValue *> StaticExternCMap;\n  StaticExternCMap StaticExternCValues;\n\n  /// thread_local variables defined or used in this TU.\n  std::vector<const VarDecl *> CXXThreadLocals;\n\n  /// thread_local variables with initializers that need to run\n  /// before any thread_local variable in this TU is odr-used.\n  std::vector<llvm::Function *> CXXThreadLocalInits;\n  std::vector<const VarDecl *> CXXThreadLocalInitVars;\n\n  /// Global variables with initializers that need to run before main.\n  std::vector<llvm::Function *> CXXGlobalInits;\n\n  /// When a C++ decl with an initializer is deferred, null is\n  /// appended to CXXGlobalInits, and the index of that null is placed\n  /// here so that the initializer will be performed in the correct\n  /// order. Once the decl is emitted, the index is replaced with ~0U to ensure\n  /// that we don't re-emit the initializer.\n  llvm::DenseMap<const Decl*, unsigned> DelayedCXXInitPosition;\n\n  typedef std::pair<OrderGlobalInits, llvm::Function*> GlobalInitData;\n\n  struct GlobalInitPriorityCmp {\n    bool operator()(const GlobalInitData &LHS,\n                    const GlobalInitData &RHS) const {\n      return LHS.first.priority < RHS.first.priority;\n    }\n  };\n\n  /// Global variables with initializers whose order of initialization is set by\n  /// init_priority attribute.\n  SmallVector<GlobalInitData, 8> PrioritizedCXXGlobalInits;\n\n  /// Global destructor functions and arguments that need to run on termination.\n  /// When UseSinitAndSterm is set, it instead contains sterm finalizer\n  /// functions, which also run on unloading a shared library.\n  std::vector<\n      std::tuple<llvm::FunctionType *, llvm::WeakTrackingVH, llvm::Constant *>>\n      CXXGlobalDtorsOrStermFinalizers;\n\n  /// The complete set of modules that has been imported.\n  llvm::SetVector<clang::Module *> ImportedModules;\n\n  /// The set of modules for which the module initializers\n  /// have been emitted.\n  llvm::SmallPtrSet<clang::Module *, 16> EmittedModuleInitializers;\n\n  /// A vector of metadata strings for linker options.\n  SmallVector<llvm::MDNode *, 16> LinkerOptionsMetadata;\n\n  /// A vector of metadata strings for dependent libraries for ELF.\n  SmallVector<llvm::MDNode *, 16> ELFDependentLibraries;\n\n  /// @name Cache for Objective-C runtime types\n  /// @{\n\n  /// Cached reference to the class for constant strings. This value has type\n  /// int * but is actually an Obj-C class pointer.\n  llvm::WeakTrackingVH CFConstantStringClassRef;\n\n  /// The type used to describe the state of a fast enumeration in\n  /// Objective-C's for..in loop.\n  QualType ObjCFastEnumerationStateType;\n\n  /// @}\n\n  /// Lazily create the Objective-C runtime\n  void createObjCRuntime();\n\n  void createOpenCLRuntime();\n  void createOpenMPRuntime();\n  void createCUDARuntime();\n\n  bool isTriviallyRecursive(const FunctionDecl *F);\n  bool shouldEmitFunction(GlobalDecl GD);\n  bool shouldOpportunisticallyEmitVTables();\n  /// Map used to be sure we don't emit the same CompoundLiteral twice.\n  llvm::DenseMap<const CompoundLiteralExpr *, llvm::GlobalVariable *>\n      EmittedCompoundLiterals;\n\n  /// Map of the global blocks we've emitted, so that we don't have to re-emit\n  /// them if the constexpr evaluator gets aggressive.\n  llvm::DenseMap<const BlockExpr *, llvm::Constant *> EmittedGlobalBlocks;\n\n  /// @name Cache for Blocks Runtime Globals\n  /// @{\n\n  llvm::Constant *NSConcreteGlobalBlock = nullptr;\n  llvm::Constant *NSConcreteStackBlock = nullptr;\n\n  llvm::FunctionCallee BlockObjectAssign = nullptr;\n  llvm::FunctionCallee BlockObjectDispose = nullptr;\n\n  llvm::Type *BlockDescriptorType = nullptr;\n  llvm::Type *GenericBlockLiteralType = nullptr;\n\n  struct {\n    int GlobalUniqueCount;\n  } Block;\n\n  GlobalDecl initializedGlobalDecl;\n\n  /// @}\n\n  /// void @llvm.lifetime.start(i64 %size, i8* nocapture <ptr>)\n  llvm::Function *LifetimeStartFn = nullptr;\n\n  /// void @llvm.lifetime.end(i64 %size, i8* nocapture <ptr>)\n  llvm::Function *LifetimeEndFn = nullptr;\n\n  std::unique_ptr<SanitizerMetadata> SanitizerMD;\n\n  llvm::MapVector<const Decl *, bool> DeferredEmptyCoverageMappingDecls;\n\n  std::unique_ptr<CoverageMappingModuleGen> CoverageMapping;\n\n  /// Mapping from canonical types to their metadata identifiers. We need to\n  /// maintain this mapping because identifiers may be formed from distinct\n  /// MDNodes.\n  typedef llvm::DenseMap<QualType, llvm::Metadata *> MetadataTypeMap;\n  MetadataTypeMap MetadataIdMap;\n  MetadataTypeMap VirtualMetadataIdMap;\n  MetadataTypeMap GeneralizedMetadataIdMap;\n\npublic:\n  CodeGenModule(ASTContext &C, const HeaderSearchOptions &headersearchopts,\n                const PreprocessorOptions &ppopts,\n                const CodeGenOptions &CodeGenOpts, llvm::Module &M,\n                DiagnosticsEngine &Diags,\n                CoverageSourceInfo *CoverageInfo = nullptr);\n\n  ~CodeGenModule();\n\n  void clear();\n\n  /// Finalize LLVM code generation.\n  void Release();\n\n  /// Return true if we should emit location information for expressions.\n  bool getExpressionLocationsEnabled() const;\n\n  /// Return a reference to the configured Objective-C runtime.\n  CGObjCRuntime &getObjCRuntime() {\n    if (!ObjCRuntime) createObjCRuntime();\n    return *ObjCRuntime;\n  }\n\n  /// Return true iff an Objective-C runtime has been configured.\n  bool hasObjCRuntime() { return !!ObjCRuntime; }\n\n  const std::string &getModuleNameHash() const { return ModuleNameHash; }\n\n  /// Return a reference to the configured OpenCL runtime.\n  CGOpenCLRuntime &getOpenCLRuntime() {\n    assert(OpenCLRuntime != nullptr);\n    return *OpenCLRuntime;\n  }\n\n  /// Return a reference to the configured OpenMP runtime.\n  CGOpenMPRuntime &getOpenMPRuntime() {\n    assert(OpenMPRuntime != nullptr);\n    return *OpenMPRuntime;\n  }\n\n  /// Return a reference to the configured CUDA runtime.\n  CGCUDARuntime &getCUDARuntime() {\n    assert(CUDARuntime != nullptr);\n    return *CUDARuntime;\n  }\n\n  ObjCEntrypoints &getObjCEntrypoints() const {\n    assert(ObjCData != nullptr);\n    return *ObjCData;\n  }\n\n  // Version checking functions, used to implement ObjC's @available:\n  // i32 @__isOSVersionAtLeast(i32, i32, i32)\n  llvm::FunctionCallee IsOSVersionAtLeastFn = nullptr;\n  // i32 @__isPlatformVersionAtLeast(i32, i32, i32, i32)\n  llvm::FunctionCallee IsPlatformVersionAtLeastFn = nullptr;\n\n  InstrProfStats &getPGOStats() { return PGOStats; }\n  llvm::IndexedInstrProfReader *getPGOReader() const { return PGOReader.get(); }\n\n  CoverageMappingModuleGen *getCoverageMapping() const {\n    return CoverageMapping.get();\n  }\n\n  llvm::Constant *getStaticLocalDeclAddress(const VarDecl *D) {\n    return StaticLocalDeclMap[D];\n  }\n  void setStaticLocalDeclAddress(const VarDecl *D,\n                                 llvm::Constant *C) {\n    StaticLocalDeclMap[D] = C;\n  }\n\n  llvm::Constant *\n  getOrCreateStaticVarDecl(const VarDecl &D,\n                           llvm::GlobalValue::LinkageTypes Linkage);\n\n  llvm::GlobalVariable *getStaticLocalDeclGuardAddress(const VarDecl *D) {\n    return StaticLocalDeclGuardMap[D];\n  }\n  void setStaticLocalDeclGuardAddress(const VarDecl *D,\n                                      llvm::GlobalVariable *C) {\n    StaticLocalDeclGuardMap[D] = C;\n  }\n\n  Address createUnnamedGlobalFrom(const VarDecl &D, llvm::Constant *Constant,\n                                  CharUnits Align);\n\n  bool lookupRepresentativeDecl(StringRef MangledName,\n                                GlobalDecl &Result) const;\n\n  llvm::Constant *getAtomicSetterHelperFnMap(QualType Ty) {\n    return AtomicSetterHelperFnMap[Ty];\n  }\n  void setAtomicSetterHelperFnMap(QualType Ty,\n                            llvm::Constant *Fn) {\n    AtomicSetterHelperFnMap[Ty] = Fn;\n  }\n\n  llvm::Constant *getAtomicGetterHelperFnMap(QualType Ty) {\n    return AtomicGetterHelperFnMap[Ty];\n  }\n  void setAtomicGetterHelperFnMap(QualType Ty,\n                            llvm::Constant *Fn) {\n    AtomicGetterHelperFnMap[Ty] = Fn;\n  }\n\n  llvm::Constant *getTypeDescriptorFromMap(QualType Ty) {\n    return TypeDescriptorMap[Ty];\n  }\n  void setTypeDescriptorInMap(QualType Ty, llvm::Constant *C) {\n    TypeDescriptorMap[Ty] = C;\n  }\n\n  CGDebugInfo *getModuleDebugInfo() { return DebugInfo.get(); }\n\n  llvm::MDNode *getNoObjCARCExceptionsMetadata() {\n    if (!NoObjCARCExceptionsMetadata)\n      NoObjCARCExceptionsMetadata = llvm::MDNode::get(getLLVMContext(), None);\n    return NoObjCARCExceptionsMetadata;\n  }\n\n  ASTContext &getContext() const { return Context; }\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  const HeaderSearchOptions &getHeaderSearchOpts()\n    const { return HeaderSearchOpts; }\n  const PreprocessorOptions &getPreprocessorOpts()\n    const { return PreprocessorOpts; }\n  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }\n  llvm::Module &getModule() const { return TheModule; }\n  DiagnosticsEngine &getDiags() const { return Diags; }\n  const llvm::DataLayout &getDataLayout() const {\n    return TheModule.getDataLayout();\n  }\n  const TargetInfo &getTarget() const { return Target; }\n  const llvm::Triple &getTriple() const { return Target.getTriple(); }\n  bool supportsCOMDAT() const;\n  void maybeSetTrivialComdat(const Decl &D, llvm::GlobalObject &GO);\n\n  CGCXXABI &getCXXABI() const { return *ABI; }\n  llvm::LLVMContext &getLLVMContext() { return VMContext; }\n\n  bool shouldUseTBAA() const { return TBAA != nullptr; }\n\n  const TargetCodeGenInfo &getTargetCodeGenInfo();\n\n  CodeGenTypes &getTypes() { return Types; }\n\n  CodeGenVTables &getVTables() { return VTables; }\n\n  ItaniumVTableContext &getItaniumVTableContext() {\n    return VTables.getItaniumVTableContext();\n  }\n\n  MicrosoftVTableContext &getMicrosoftVTableContext() {\n    return VTables.getMicrosoftVTableContext();\n  }\n\n  CtorList &getGlobalCtors() { return GlobalCtors; }\n  CtorList &getGlobalDtors() { return GlobalDtors; }\n\n  /// getTBAATypeInfo - Get metadata used to describe accesses to objects of\n  /// the given type.\n  llvm::MDNode *getTBAATypeInfo(QualType QTy);\n\n  /// getTBAAAccessInfo - Get TBAA information that describes an access to\n  /// an object of the given type.\n  TBAAAccessInfo getTBAAAccessInfo(QualType AccessType);\n\n  /// getTBAAVTablePtrAccessInfo - Get the TBAA information that describes an\n  /// access to a virtual table pointer.\n  TBAAAccessInfo getTBAAVTablePtrAccessInfo(llvm::Type *VTablePtrType);\n\n  llvm::MDNode *getTBAAStructInfo(QualType QTy);\n\n  /// getTBAABaseTypeInfo - Get metadata that describes the given base access\n  /// type. Return null if the type is not suitable for use in TBAA access tags.\n  llvm::MDNode *getTBAABaseTypeInfo(QualType QTy);\n\n  /// getTBAAAccessTagInfo - Get TBAA tag for a given memory access.\n  llvm::MDNode *getTBAAAccessTagInfo(TBAAAccessInfo Info);\n\n  /// mergeTBAAInfoForCast - Get merged TBAA information for the purposes of\n  /// type casts.\n  TBAAAccessInfo mergeTBAAInfoForCast(TBAAAccessInfo SourceInfo,\n                                      TBAAAccessInfo TargetInfo);\n\n  /// mergeTBAAInfoForConditionalOperator - Get merged TBAA information for the\n  /// purposes of conditional operator.\n  TBAAAccessInfo mergeTBAAInfoForConditionalOperator(TBAAAccessInfo InfoA,\n                                                     TBAAAccessInfo InfoB);\n\n  /// mergeTBAAInfoForMemoryTransfer - Get merged TBAA information for the\n  /// purposes of memory transfer calls.\n  TBAAAccessInfo mergeTBAAInfoForMemoryTransfer(TBAAAccessInfo DestInfo,\n                                                TBAAAccessInfo SrcInfo);\n\n  /// getTBAAInfoForSubobject - Get TBAA information for an access with a given\n  /// base lvalue.\n  TBAAAccessInfo getTBAAInfoForSubobject(LValue Base, QualType AccessType) {\n    if (Base.getTBAAInfo().isMayAlias())\n      return TBAAAccessInfo::getMayAliasInfo();\n    return getTBAAAccessInfo(AccessType);\n  }\n\n  bool isTypeConstant(QualType QTy, bool ExcludeCtorDtor);\n\n  bool isPaddedAtomicType(QualType type);\n  bool isPaddedAtomicType(const AtomicType *type);\n\n  /// DecorateInstructionWithTBAA - Decorate the instruction with a TBAA tag.\n  void DecorateInstructionWithTBAA(llvm::Instruction *Inst,\n                                   TBAAAccessInfo TBAAInfo);\n\n  /// Adds !invariant.barrier !tag to instruction\n  void DecorateInstructionWithInvariantGroup(llvm::Instruction *I,\n                                             const CXXRecordDecl *RD);\n\n  /// Emit the given number of characters as a value of type size_t.\n  llvm::ConstantInt *getSize(CharUnits numChars);\n\n  /// Set the visibility for the given LLVM GlobalValue.\n  void setGlobalVisibility(llvm::GlobalValue *GV, const NamedDecl *D) const;\n\n  void setDSOLocal(llvm::GlobalValue *GV) const;\n\n  void setDLLImportDLLExport(llvm::GlobalValue *GV, GlobalDecl D) const;\n  void setDLLImportDLLExport(llvm::GlobalValue *GV, const NamedDecl *D) const;\n  /// Set visibility, dllimport/dllexport and dso_local.\n  /// This must be called after dllimport/dllexport is set.\n  void setGVProperties(llvm::GlobalValue *GV, GlobalDecl GD) const;\n  void setGVProperties(llvm::GlobalValue *GV, const NamedDecl *D) const;\n\n  void setGVPropertiesAux(llvm::GlobalValue *GV, const NamedDecl *D) const;\n\n  /// Set the TLS mode for the given LLVM GlobalValue for the thread-local\n  /// variable declaration D.\n  void setTLSMode(llvm::GlobalValue *GV, const VarDecl &D) const;\n\n  /// Get LLVM TLS mode from CodeGenOptions.\n  llvm::GlobalVariable::ThreadLocalMode GetDefaultLLVMTLSModel() const;\n\n  static llvm::GlobalValue::VisibilityTypes GetLLVMVisibility(Visibility V) {\n    switch (V) {\n    case DefaultVisibility:   return llvm::GlobalValue::DefaultVisibility;\n    case HiddenVisibility:    return llvm::GlobalValue::HiddenVisibility;\n    case ProtectedVisibility: return llvm::GlobalValue::ProtectedVisibility;\n    }\n    llvm_unreachable(\"unknown visibility!\");\n  }\n\n  llvm::Constant *GetAddrOfGlobal(GlobalDecl GD,\n                                  ForDefinition_t IsForDefinition\n                                    = NotForDefinition);\n\n  /// Will return a global variable of the given type. If a variable with a\n  /// different type already exists then a new  variable with the right type\n  /// will be created and all uses of the old variable will be replaced with a\n  /// bitcast to the new variable.\n  llvm::GlobalVariable *\n  CreateOrReplaceCXXRuntimeVariable(StringRef Name, llvm::Type *Ty,\n                                    llvm::GlobalValue::LinkageTypes Linkage,\n                                    unsigned Alignment);\n\n  llvm::Function *CreateGlobalInitOrCleanUpFunction(\n      llvm::FunctionType *ty, const Twine &name, const CGFunctionInfo &FI,\n      SourceLocation Loc = SourceLocation(), bool TLS = false);\n\n  /// Return the AST address space of the underlying global variable for D, as\n  /// determined by its declaration. Normally this is the same as the address\n  /// space of D's type, but in CUDA, address spaces are associated with\n  /// declarations, not types. If D is nullptr, return the default address\n  /// space for global variable.\n  ///\n  /// For languages without explicit address spaces, if D has default address\n  /// space, target-specific global or constant address space may be returned.\n  LangAS GetGlobalVarAddressSpace(const VarDecl *D);\n\n  /// Return the llvm::Constant for the address of the given global variable.\n  /// If Ty is non-null and if the global doesn't exist, then it will be created\n  /// with the specified type instead of whatever the normal requested type\n  /// would be. If IsForDefinition is true, it is guaranteed that an actual\n  /// global with type Ty will be returned, not conversion of a variable with\n  /// the same mangled name but some other type.\n  llvm::Constant *GetAddrOfGlobalVar(const VarDecl *D,\n                                     llvm::Type *Ty = nullptr,\n                                     ForDefinition_t IsForDefinition\n                                       = NotForDefinition);\n\n  /// Return the AST address space of string literal, which is used to emit\n  /// the string literal as global variable in LLVM IR.\n  /// Note: This is not necessarily the address space of the string literal\n  /// in AST. For address space agnostic language, e.g. C++, string literal\n  /// in AST is always in default address space.\n  LangAS getStringLiteralAddressSpace() const;\n\n  /// Return the address of the given function. If Ty is non-null, then this\n  /// function will use the specified type if it has to create it.\n  llvm::Constant *GetAddrOfFunction(GlobalDecl GD, llvm::Type *Ty = nullptr,\n                                    bool ForVTable = false,\n                                    bool DontDefer = false,\n                                    ForDefinition_t IsForDefinition\n                                      = NotForDefinition);\n\n  /// Get the address of the RTTI descriptor for the given type.\n  llvm::Constant *GetAddrOfRTTIDescriptor(QualType Ty, bool ForEH = false);\n\n  /// Get the address of a GUID.\n  ConstantAddress GetAddrOfMSGuidDecl(const MSGuidDecl *GD);\n\n  /// Get the address of a template parameter object.\n  ConstantAddress\n  GetAddrOfTemplateParamObject(const TemplateParamObjectDecl *TPO);\n\n  /// Get the address of the thunk for the given global decl.\n  llvm::Constant *GetAddrOfThunk(StringRef Name, llvm::Type *FnTy,\n                                 GlobalDecl GD);\n\n  /// Get a reference to the target of VD.\n  ConstantAddress GetWeakRefReference(const ValueDecl *VD);\n\n  /// Returns the assumed alignment of an opaque pointer to the given class.\n  CharUnits getClassPointerAlignment(const CXXRecordDecl *CD);\n\n  /// Returns the minimum object size for an object of the given class type\n  /// (or a class derived from it).\n  CharUnits getMinimumClassObjectSize(const CXXRecordDecl *CD);\n\n  /// Returns the minimum object size for an object of the given type.\n  CharUnits getMinimumObjectSize(QualType Ty) {\n    if (CXXRecordDecl *RD = Ty->getAsCXXRecordDecl())\n      return getMinimumClassObjectSize(RD);\n    return getContext().getTypeSizeInChars(Ty);\n  }\n\n  /// Returns the assumed alignment of a virtual base of a class.\n  CharUnits getVBaseAlignment(CharUnits DerivedAlign,\n                              const CXXRecordDecl *Derived,\n                              const CXXRecordDecl *VBase);\n\n  /// Given a class pointer with an actual known alignment, and the\n  /// expected alignment of an object at a dynamic offset w.r.t that\n  /// pointer, return the alignment to assume at the offset.\n  CharUnits getDynamicOffsetAlignment(CharUnits ActualAlign,\n                                      const CXXRecordDecl *Class,\n                                      CharUnits ExpectedTargetAlign);\n\n  CharUnits\n  computeNonVirtualBaseClassOffset(const CXXRecordDecl *DerivedClass,\n                                   CastExpr::path_const_iterator Start,\n                                   CastExpr::path_const_iterator End);\n\n  /// Returns the offset from a derived class to  a class. Returns null if the\n  /// offset is 0.\n  llvm::Constant *\n  GetNonVirtualBaseClassOffset(const CXXRecordDecl *ClassDecl,\n                               CastExpr::path_const_iterator PathBegin,\n                               CastExpr::path_const_iterator PathEnd);\n\n  llvm::FoldingSet<BlockByrefHelpers> ByrefHelpersCache;\n\n  /// Fetches the global unique block count.\n  int getUniqueBlockCount() { return ++Block.GlobalUniqueCount; }\n\n  /// Fetches the type of a generic block descriptor.\n  llvm::Type *getBlockDescriptorType();\n\n  /// The type of a generic block literal.\n  llvm::Type *getGenericBlockLiteralType();\n\n  /// Gets the address of a block which requires no captures.\n  llvm::Constant *GetAddrOfGlobalBlock(const BlockExpr *BE, StringRef Name);\n\n  /// Returns the address of a block which requires no caputres, or null if\n  /// we've yet to emit the block for BE.\n  llvm::Constant *getAddrOfGlobalBlockIfEmitted(const BlockExpr *BE) {\n    return EmittedGlobalBlocks.lookup(BE);\n  }\n\n  /// Notes that BE's global block is available via Addr. Asserts that BE\n  /// isn't already emitted.\n  void setAddrOfGlobalBlock(const BlockExpr *BE, llvm::Constant *Addr);\n\n  /// Return a pointer to a constant CFString object for the given string.\n  ConstantAddress GetAddrOfConstantCFString(const StringLiteral *Literal);\n\n  /// Return a pointer to a constant NSString object for the given string. Or a\n  /// user defined String object as defined via\n  /// -fconstant-string-class=class_name option.\n  ConstantAddress GetAddrOfConstantString(const StringLiteral *Literal);\n\n  /// Return a constant array for the given string.\n  llvm::Constant *GetConstantArrayFromStringLiteral(const StringLiteral *E);\n\n  /// Return a pointer to a constant array for the given string literal.\n  ConstantAddress\n  GetAddrOfConstantStringFromLiteral(const StringLiteral *S,\n                                     StringRef Name = \".str\");\n\n  /// Return a pointer to a constant array for the given ObjCEncodeExpr node.\n  ConstantAddress\n  GetAddrOfConstantStringFromObjCEncode(const ObjCEncodeExpr *);\n\n  /// Returns a pointer to a character array containing the literal and a\n  /// terminating '\\0' character. The result has pointer to array type.\n  ///\n  /// \\param GlobalName If provided, the name to use for the global (if one is\n  /// created).\n  ConstantAddress\n  GetAddrOfConstantCString(const std::string &Str,\n                           const char *GlobalName = nullptr);\n\n  /// Returns a pointer to a constant global variable for the given file-scope\n  /// compound literal expression.\n  ConstantAddress GetAddrOfConstantCompoundLiteral(const CompoundLiteralExpr*E);\n\n  /// If it's been emitted already, returns the GlobalVariable corresponding to\n  /// a compound literal. Otherwise, returns null.\n  llvm::GlobalVariable *\n  getAddrOfConstantCompoundLiteralIfEmitted(const CompoundLiteralExpr *E);\n\n  /// Notes that CLE's GlobalVariable is GV. Asserts that CLE isn't already\n  /// emitted.\n  void setAddrOfConstantCompoundLiteral(const CompoundLiteralExpr *CLE,\n                                        llvm::GlobalVariable *GV);\n\n  /// Returns a pointer to a global variable representing a temporary\n  /// with static or thread storage duration.\n  ConstantAddress GetAddrOfGlobalTemporary(const MaterializeTemporaryExpr *E,\n                                           const Expr *Inner);\n\n  /// Retrieve the record type that describes the state of an\n  /// Objective-C fast enumeration loop (for..in).\n  QualType getObjCFastEnumerationStateType();\n\n  // Produce code for this constructor/destructor. This method doesn't try\n  // to apply any ABI rules about which other constructors/destructors\n  // are needed or if they are alias to each other.\n  llvm::Function *codegenCXXStructor(GlobalDecl GD);\n\n  /// Return the address of the constructor/destructor of the given type.\n  llvm::Constant *\n  getAddrOfCXXStructor(GlobalDecl GD, const CGFunctionInfo *FnInfo = nullptr,\n                       llvm::FunctionType *FnType = nullptr,\n                       bool DontDefer = false,\n                       ForDefinition_t IsForDefinition = NotForDefinition) {\n    return cast<llvm::Constant>(getAddrAndTypeOfCXXStructor(GD, FnInfo, FnType,\n                                                            DontDefer,\n                                                            IsForDefinition)\n                                    .getCallee());\n  }\n\n  llvm::FunctionCallee getAddrAndTypeOfCXXStructor(\n      GlobalDecl GD, const CGFunctionInfo *FnInfo = nullptr,\n      llvm::FunctionType *FnType = nullptr, bool DontDefer = false,\n      ForDefinition_t IsForDefinition = NotForDefinition);\n\n  /// Given a builtin id for a function like \"__builtin_fabsf\", return a\n  /// Function* for \"fabsf\".\n  llvm::Constant *getBuiltinLibFunction(const FunctionDecl *FD,\n                                        unsigned BuiltinID);\n\n  llvm::Function *getIntrinsic(unsigned IID, ArrayRef<llvm::Type*> Tys = None);\n\n  /// Emit code for a single top level declaration.\n  void EmitTopLevelDecl(Decl *D);\n\n  /// Stored a deferred empty coverage mapping for an unused\n  /// and thus uninstrumented top level declaration.\n  void AddDeferredUnusedCoverageMapping(Decl *D);\n\n  /// Remove the deferred empty coverage mapping as this\n  /// declaration is actually instrumented.\n  void ClearUnusedCoverageMapping(const Decl *D);\n\n  /// Emit all the deferred coverage mappings\n  /// for the uninstrumented functions.\n  void EmitDeferredUnusedCoverageMappings();\n\n  /// Emit an alias for \"main\" if it has no arguments (needed for wasm).\n  void EmitMainVoidAlias();\n\n  /// Tell the consumer that this variable has been instantiated.\n  void HandleCXXStaticMemberVarInstantiation(VarDecl *VD);\n\n  /// If the declaration has internal linkage but is inside an\n  /// extern \"C\" linkage specification, prepare to emit an alias for it\n  /// to the expected name.\n  template<typename SomeDecl>\n  void MaybeHandleStaticInExternC(const SomeDecl *D, llvm::GlobalValue *GV);\n\n  /// Add a global to a list to be added to the llvm.used metadata.\n  void addUsedGlobal(llvm::GlobalValue *GV);\n\n  /// Add a global to a list to be added to the llvm.compiler.used metadata.\n  void addCompilerUsedGlobal(llvm::GlobalValue *GV);\n\n  /// Add a global to a list to be added to the llvm.compiler.used metadata.\n  void addUsedOrCompilerUsedGlobal(llvm::GlobalValue *GV);\n\n  /// Add a destructor and object to add to the C++ global destructor function.\n  void AddCXXDtorEntry(llvm::FunctionCallee DtorFn, llvm::Constant *Object) {\n    CXXGlobalDtorsOrStermFinalizers.emplace_back(DtorFn.getFunctionType(),\n                                                 DtorFn.getCallee(), Object);\n  }\n\n  /// Add an sterm finalizer to the C++ global cleanup function.\n  void AddCXXStermFinalizerEntry(llvm::FunctionCallee DtorFn) {\n    CXXGlobalDtorsOrStermFinalizers.emplace_back(DtorFn.getFunctionType(),\n                                                 DtorFn.getCallee(), nullptr);\n  }\n\n  /// Add an sterm finalizer to its own llvm.global_dtors entry.\n  void AddCXXStermFinalizerToGlobalDtor(llvm::Function *StermFinalizer,\n                                        int Priority) {\n    AddGlobalDtor(StermFinalizer, Priority);\n  }\n\n  /// Create or return a runtime function declaration with the specified type\n  /// and name. If \\p AssumeConvergent is true, the call will have the\n  /// convergent attribute added.\n  llvm::FunctionCallee\n  CreateRuntimeFunction(llvm::FunctionType *Ty, StringRef Name,\n                        llvm::AttributeList ExtraAttrs = llvm::AttributeList(),\n                        bool Local = false, bool AssumeConvergent = false);\n\n  /// Create a new runtime global variable with the specified type and name.\n  llvm::Constant *CreateRuntimeVariable(llvm::Type *Ty,\n                                        StringRef Name);\n\n  ///@name Custom Blocks Runtime Interfaces\n  ///@{\n\n  llvm::Constant *getNSConcreteGlobalBlock();\n  llvm::Constant *getNSConcreteStackBlock();\n  llvm::FunctionCallee getBlockObjectAssign();\n  llvm::FunctionCallee getBlockObjectDispose();\n\n  ///@}\n\n  llvm::Function *getLLVMLifetimeStartFn();\n  llvm::Function *getLLVMLifetimeEndFn();\n\n  // Make sure that this type is translated.\n  void UpdateCompletedType(const TagDecl *TD);\n\n  llvm::Constant *getMemberPointerConstant(const UnaryOperator *e);\n\n  /// Emit type info if type of an expression is a variably modified\n  /// type. Also emit proper debug info for cast types.\n  void EmitExplicitCastExprType(const ExplicitCastExpr *E,\n                                CodeGenFunction *CGF = nullptr);\n\n  /// Return the result of value-initializing the given type, i.e. a null\n  /// expression of the given type.  This is usually, but not always, an LLVM\n  /// null constant.\n  llvm::Constant *EmitNullConstant(QualType T);\n\n  /// Return a null constant appropriate for zero-initializing a base class with\n  /// the given type. This is usually, but not always, an LLVM null constant.\n  llvm::Constant *EmitNullConstantForBase(const CXXRecordDecl *Record);\n\n  /// Emit a general error that something can't be done.\n  void Error(SourceLocation loc, StringRef error);\n\n  /// Print out an error that codegen doesn't support the specified stmt yet.\n  void ErrorUnsupported(const Stmt *S, const char *Type);\n\n  /// Print out an error that codegen doesn't support the specified decl yet.\n  void ErrorUnsupported(const Decl *D, const char *Type);\n\n  /// Set the attributes on the LLVM function for the given decl and function\n  /// info. This applies attributes necessary for handling the ABI as well as\n  /// user specified attributes like section.\n  void SetInternalFunctionAttributes(GlobalDecl GD, llvm::Function *F,\n                                     const CGFunctionInfo &FI);\n\n  /// Set the LLVM function attributes (sext, zext, etc).\n  void SetLLVMFunctionAttributes(GlobalDecl GD, const CGFunctionInfo &Info,\n                                 llvm::Function *F);\n\n  /// Set the LLVM function attributes which only apply to a function\n  /// definition.\n  void SetLLVMFunctionAttributesForDefinition(const Decl *D, llvm::Function *F);\n\n  /// Set the LLVM function attributes that represent floating point\n  /// environment.\n  void setLLVMFunctionFEnvAttributes(const FunctionDecl *D, llvm::Function *F);\n\n  /// Return true iff the given type uses 'sret' when used as a return type.\n  bool ReturnTypeUsesSRet(const CGFunctionInfo &FI);\n\n  /// Return true iff the given type uses an argument slot when 'sret' is used\n  /// as a return type.\n  bool ReturnSlotInterferesWithArgs(const CGFunctionInfo &FI);\n\n  /// Return true iff the given type uses 'fpret' when used as a return type.\n  bool ReturnTypeUsesFPRet(QualType ResultType);\n\n  /// Return true iff the given type uses 'fp2ret' when used as a return type.\n  bool ReturnTypeUsesFP2Ret(QualType ResultType);\n\n  /// Get the LLVM attributes and calling convention to use for a particular\n  /// function type.\n  ///\n  /// \\param Name - The function name.\n  /// \\param Info - The function type information.\n  /// \\param CalleeInfo - The callee information these attributes are being\n  /// constructed for. If valid, the attributes applied to this decl may\n  /// contribute to the function attributes and calling convention.\n  /// \\param Attrs [out] - On return, the attribute list to use.\n  /// \\param CallingConv [out] - On return, the LLVM calling convention to use.\n  void ConstructAttributeList(StringRef Name, const CGFunctionInfo &Info,\n                              CGCalleeInfo CalleeInfo,\n                              llvm::AttributeList &Attrs, unsigned &CallingConv,\n                              bool AttrOnCallSite);\n\n  /// Adds attributes to F according to our CodeGenOptions and LangOptions, as\n  /// though we had emitted it ourselves.  We remove any attributes on F that\n  /// conflict with the attributes we add here.\n  ///\n  /// This is useful for adding attrs to bitcode modules that you want to link\n  /// with but don't control, such as CUDA's libdevice.  When linking with such\n  /// a bitcode library, you might want to set e.g. its functions'\n  /// \"unsafe-fp-math\" attribute to match the attr of the functions you're\n  /// codegen'ing.  Otherwise, LLVM will interpret the bitcode module's lack of\n  /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM\n  /// will propagate unsafe-fp-math=false up to every transitive caller of a\n  /// function in the bitcode library!\n  ///\n  /// With the exception of fast-math attrs, this will only make the attributes\n  /// on the function more conservative.  But it's unsafe to call this on a\n  /// function which relies on particular fast-math attributes for correctness.\n  /// It's up to you to ensure that this is safe.\n  void addDefaultFunctionDefinitionAttributes(llvm::Function &F);\n\n  /// Like the overload taking a `Function &`, but intended specifically\n  /// for frontends that want to build on Clang's target-configuration logic.\n  void addDefaultFunctionDefinitionAttributes(llvm::AttrBuilder &attrs);\n\n  StringRef getMangledName(GlobalDecl GD);\n  StringRef getBlockMangledName(GlobalDecl GD, const BlockDecl *BD);\n\n  void EmitTentativeDefinition(const VarDecl *D);\n\n  void EmitExternalDeclaration(const VarDecl *D);\n\n  void EmitVTable(CXXRecordDecl *Class);\n\n  void RefreshTypeCacheForClass(const CXXRecordDecl *Class);\n\n  /// Appends Opts to the \"llvm.linker.options\" metadata value.\n  void AppendLinkerOptions(StringRef Opts);\n\n  /// Appends a detect mismatch command to the linker options.\n  void AddDetectMismatch(StringRef Name, StringRef Value);\n\n  /// Appends a dependent lib to the appropriate metadata value.\n  void AddDependentLib(StringRef Lib);\n\n\n  llvm::GlobalVariable::LinkageTypes getFunctionLinkage(GlobalDecl GD);\n\n  void setFunctionLinkage(GlobalDecl GD, llvm::Function *F) {\n    F->setLinkage(getFunctionLinkage(GD));\n  }\n\n  /// Return the appropriate linkage for the vtable, VTT, and type information\n  /// of the given class.\n  llvm::GlobalVariable::LinkageTypes getVTableLinkage(const CXXRecordDecl *RD);\n\n  /// Return the store size, in character units, of the given LLVM type.\n  CharUnits GetTargetTypeStoreSize(llvm::Type *Ty) const;\n\n  /// Returns LLVM linkage for a declarator.\n  llvm::GlobalValue::LinkageTypes\n  getLLVMLinkageForDeclarator(const DeclaratorDecl *D, GVALinkage Linkage,\n                              bool IsConstantVariable);\n\n  /// Returns LLVM linkage for a declarator.\n  llvm::GlobalValue::LinkageTypes\n  getLLVMLinkageVarDefinition(const VarDecl *VD, bool IsConstant);\n\n  /// Emit all the global annotations.\n  void EmitGlobalAnnotations();\n\n  /// Emit an annotation string.\n  llvm::Constant *EmitAnnotationString(StringRef Str);\n\n  /// Emit the annotation's translation unit.\n  llvm::Constant *EmitAnnotationUnit(SourceLocation Loc);\n\n  /// Emit the annotation line number.\n  llvm::Constant *EmitAnnotationLineNo(SourceLocation L);\n\n  /// Emit additional args of the annotation.\n  llvm::Constant *EmitAnnotationArgs(const AnnotateAttr *Attr);\n\n  /// Generate the llvm::ConstantStruct which contains the annotation\n  /// information for a given GlobalValue. The annotation struct is\n  /// {i8 *, i8 *, i8 *, i32}. The first field is a constant expression, the\n  /// GlobalValue being annotated. The second field is the constant string\n  /// created from the AnnotateAttr's annotation. The third field is a constant\n  /// string containing the name of the translation unit. The fourth field is\n  /// the line number in the file of the annotated value declaration.\n  llvm::Constant *EmitAnnotateAttr(llvm::GlobalValue *GV,\n                                   const AnnotateAttr *AA,\n                                   SourceLocation L);\n\n  /// Add global annotations that are set on D, for the global GV. Those\n  /// annotations are emitted during finalization of the LLVM code.\n  void AddGlobalAnnotations(const ValueDecl *D, llvm::GlobalValue *GV);\n\n  bool isInNoSanitizeList(SanitizerMask Kind, llvm::Function *Fn,\n                          SourceLocation Loc) const;\n\n  bool isInNoSanitizeList(llvm::GlobalVariable *GV, SourceLocation Loc,\n                          QualType Ty, StringRef Category = StringRef()) const;\n\n  /// Imbue XRay attributes to a function, applying the always/never attribute\n  /// lists in the process. Returns true if we did imbue attributes this way,\n  /// false otherwise.\n  bool imbueXRayAttrs(llvm::Function *Fn, SourceLocation Loc,\n                      StringRef Category = StringRef()) const;\n\n  /// Returns true if function at the given location should be excluded from\n  /// profile instrumentation.\n  bool isProfileInstrExcluded(llvm::Function *Fn, SourceLocation Loc) const;\n\n  SanitizerMetadata *getSanitizerMetadata() {\n    return SanitizerMD.get();\n  }\n\n  void addDeferredVTable(const CXXRecordDecl *RD) {\n    DeferredVTables.push_back(RD);\n  }\n\n  /// Emit code for a single global function or var decl. Forward declarations\n  /// are emitted lazily.\n  void EmitGlobal(GlobalDecl D);\n\n  bool TryEmitBaseDestructorAsAlias(const CXXDestructorDecl *D);\n\n  llvm::GlobalValue *GetGlobalValue(StringRef Ref);\n\n  /// Set attributes which are common to any form of a global definition (alias,\n  /// Objective-C method, function, global variable).\n  ///\n  /// NOTE: This should only be called for definitions.\n  void SetCommonAttributes(GlobalDecl GD, llvm::GlobalValue *GV);\n\n  void addReplacement(StringRef Name, llvm::Constant *C);\n\n  void addGlobalValReplacement(llvm::GlobalValue *GV, llvm::Constant *C);\n\n  /// Emit a code for threadprivate directive.\n  /// \\param D Threadprivate declaration.\n  void EmitOMPThreadPrivateDecl(const OMPThreadPrivateDecl *D);\n\n  /// Emit a code for declare reduction construct.\n  void EmitOMPDeclareReduction(const OMPDeclareReductionDecl *D,\n                               CodeGenFunction *CGF = nullptr);\n\n  /// Emit a code for declare mapper construct.\n  void EmitOMPDeclareMapper(const OMPDeclareMapperDecl *D,\n                            CodeGenFunction *CGF = nullptr);\n\n  /// Emit a code for requires directive.\n  /// \\param D Requires declaration\n  void EmitOMPRequiresDecl(const OMPRequiresDecl *D);\n\n  /// Returns whether the given record has hidden LTO visibility and therefore\n  /// may participate in (single-module) CFI and whole-program vtable\n  /// optimization.\n  bool HasHiddenLTOVisibility(const CXXRecordDecl *RD);\n\n  /// Returns whether the given record has public std LTO visibility\n  /// and therefore may not participate in (single-module) CFI and whole-program\n  /// vtable optimization.\n  bool HasLTOVisibilityPublicStd(const CXXRecordDecl *RD);\n\n  /// Returns the vcall visibility of the given type. This is the scope in which\n  /// a virtual function call could be made which ends up being dispatched to a\n  /// member function of this class. This scope can be wider than the visibility\n  /// of the class itself when the class has a more-visible dynamic base class.\n  /// The client should pass in an empty Visited set, which is used to prevent\n  /// redundant recursive processing.\n  llvm::GlobalObject::VCallVisibility\n  GetVCallVisibilityLevel(const CXXRecordDecl *RD,\n                          llvm::DenseSet<const CXXRecordDecl *> &Visited);\n\n  /// Emit type metadata for the given vtable using the given layout.\n  void EmitVTableTypeMetadata(const CXXRecordDecl *RD,\n                              llvm::GlobalVariable *VTable,\n                              const VTableLayout &VTLayout);\n\n  /// Generate a cross-DSO type identifier for MD.\n  llvm::ConstantInt *CreateCrossDsoCfiTypeId(llvm::Metadata *MD);\n\n  /// Create a metadata identifier for the given type. This may either be an\n  /// MDString (for external identifiers) or a distinct unnamed MDNode (for\n  /// internal identifiers).\n  llvm::Metadata *CreateMetadataIdentifierForType(QualType T);\n\n  /// Create a metadata identifier that is intended to be used to check virtual\n  /// calls via a member function pointer.\n  llvm::Metadata *CreateMetadataIdentifierForVirtualMemPtrType(QualType T);\n\n  /// Create a metadata identifier for the generalization of the given type.\n  /// This may either be an MDString (for external identifiers) or a distinct\n  /// unnamed MDNode (for internal identifiers).\n  llvm::Metadata *CreateMetadataIdentifierGeneralized(QualType T);\n\n  /// Create and attach type metadata to the given function.\n  void CreateFunctionTypeMetadataForIcall(const FunctionDecl *FD,\n                                          llvm::Function *F);\n\n  /// Whether this function's return type has no side effects, and thus may\n  /// be trivially discarded if it is unused.\n  bool MayDropFunctionReturn(const ASTContext &Context, QualType ReturnType);\n\n  /// Returns whether this module needs the \"all-vtables\" type identifier.\n  bool NeedAllVtablesTypeId() const;\n\n  /// Create and attach type metadata for the given vtable.\n  void AddVTableTypeMetadata(llvm::GlobalVariable *VTable, CharUnits Offset,\n                             const CXXRecordDecl *RD);\n\n  /// Return a vector of most-base classes for RD. This is used to implement\n  /// control flow integrity checks for member function pointers.\n  ///\n  /// A most-base class of a class C is defined as a recursive base class of C,\n  /// including C itself, that does not have any bases.\n  std::vector<const CXXRecordDecl *>\n  getMostBaseClasses(const CXXRecordDecl *RD);\n\n  /// Get the declaration of std::terminate for the platform.\n  llvm::FunctionCallee getTerminateFn();\n\n  llvm::SanitizerStatReport &getSanStats();\n\n  llvm::Value *\n  createOpenCLIntToSamplerConversion(const Expr *E, CodeGenFunction &CGF);\n\n  /// OpenCL v1.2 s5.6.4.6 allows the compiler to store kernel argument\n  /// information in the program executable. The argument information stored\n  /// includes the argument name, its type, the address and access qualifiers\n  /// used. This helper can be used to generate metadata for source code kernel\n  /// function as well as generated implicitly kernels. If a kernel is generated\n  /// implicitly null value has to be passed to the last two parameters,\n  /// otherwise all parameters must have valid non-null values.\n  /// \\param FN is a pointer to IR function being generated.\n  /// \\param FD is a pointer to function declaration if any.\n  /// \\param CGF is a pointer to CodeGenFunction that generates this function.\n  void GenOpenCLArgMetadata(llvm::Function *FN,\n                            const FunctionDecl *FD = nullptr,\n                            CodeGenFunction *CGF = nullptr);\n\n  /// Get target specific null pointer.\n  /// \\param T is the LLVM type of the null pointer.\n  /// \\param QT is the clang QualType of the null pointer.\n  llvm::Constant *getNullPointer(llvm::PointerType *T, QualType QT);\n\n  CharUnits getNaturalTypeAlignment(QualType T,\n                                    LValueBaseInfo *BaseInfo = nullptr,\n                                    TBAAAccessInfo *TBAAInfo = nullptr,\n                                    bool forPointeeType = false);\n  CharUnits getNaturalPointeeTypeAlignment(QualType T,\n                                           LValueBaseInfo *BaseInfo = nullptr,\n                                           TBAAAccessInfo *TBAAInfo = nullptr);\n  bool stopAutoInit();\n\n  /// Print the postfix for externalized static variable for single source\n  /// offloading languages CUDA and HIP.\n  void printPostfixForExternalizedStaticVar(llvm::raw_ostream &OS) const;\n\nprivate:\n  llvm::Constant *GetOrCreateLLVMFunction(\n      StringRef MangledName, llvm::Type *Ty, GlobalDecl D, bool ForVTable,\n      bool DontDefer = false, bool IsThunk = false,\n      llvm::AttributeList ExtraAttrs = llvm::AttributeList(),\n      ForDefinition_t IsForDefinition = NotForDefinition);\n\n  llvm::Constant *GetOrCreateMultiVersionResolver(GlobalDecl GD,\n                                                  llvm::Type *DeclTy,\n                                                  const FunctionDecl *FD);\n  void UpdateMultiVersionNames(GlobalDecl GD, const FunctionDecl *FD);\n\n  llvm::Constant *GetOrCreateLLVMGlobal(StringRef MangledName,\n                                        llvm::PointerType *PTy,\n                                        const VarDecl *D,\n                                        ForDefinition_t IsForDefinition\n                                          = NotForDefinition);\n\n  bool GetCPUAndFeaturesAttributes(GlobalDecl GD,\n                                   llvm::AttrBuilder &AttrBuilder);\n  void setNonAliasAttributes(GlobalDecl GD, llvm::GlobalObject *GO);\n\n  /// Set function attributes for a function declaration.\n  void SetFunctionAttributes(GlobalDecl GD, llvm::Function *F,\n                             bool IsIncompleteFunction, bool IsThunk);\n\n  void EmitGlobalDefinition(GlobalDecl D, llvm::GlobalValue *GV = nullptr);\n\n  void EmitGlobalFunctionDefinition(GlobalDecl GD, llvm::GlobalValue *GV);\n  void EmitMultiVersionFunctionDefinition(GlobalDecl GD, llvm::GlobalValue *GV);\n\n  void EmitGlobalVarDefinition(const VarDecl *D, bool IsTentative = false);\n  void EmitExternalVarDeclaration(const VarDecl *D);\n  void EmitAliasDefinition(GlobalDecl GD);\n  void emitIFuncDefinition(GlobalDecl GD);\n  void emitCPUDispatchDefinition(GlobalDecl GD);\n  void EmitObjCPropertyImplementations(const ObjCImplementationDecl *D);\n  void EmitObjCIvarInitializations(ObjCImplementationDecl *D);\n\n  // C++ related functions.\n\n  void EmitDeclContext(const DeclContext *DC);\n  void EmitLinkageSpec(const LinkageSpecDecl *D);\n\n  /// Emit the function that initializes C++ thread_local variables.\n  void EmitCXXThreadLocalInitFunc();\n\n  /// Emit the function that initializes C++ globals.\n  void EmitCXXGlobalInitFunc();\n\n  /// Emit the function that performs cleanup associated with C++ globals.\n  void EmitCXXGlobalCleanUpFunc();\n\n  /// Emit the function that initializes the specified global (if PerformInit is\n  /// true) and registers its destructor.\n  void EmitCXXGlobalVarDeclInitFunc(const VarDecl *D,\n                                    llvm::GlobalVariable *Addr,\n                                    bool PerformInit);\n\n  void EmitPointerToInitFunc(const VarDecl *VD, llvm::GlobalVariable *Addr,\n                             llvm::Function *InitFunc, InitSegAttr *ISA);\n\n  // FIXME: Hardcoding priority here is gross.\n  void AddGlobalCtor(llvm::Function *Ctor, int Priority = 65535,\n                     llvm::Constant *AssociatedData = nullptr);\n  void AddGlobalDtor(llvm::Function *Dtor, int Priority = 65535,\n                     bool IsDtorAttrFunc = false);\n\n  /// EmitCtorList - Generates a global array of functions and priorities using\n  /// the given list and name. This array will have appending linkage and is\n  /// suitable for use as a LLVM constructor or destructor array. Clears Fns.\n  void EmitCtorList(CtorList &Fns, const char *GlobalName);\n\n  /// Emit any needed decls for which code generation was deferred.\n  void EmitDeferred();\n\n  /// Try to emit external vtables as available_externally if they have emitted\n  /// all inlined virtual functions.  It runs after EmitDeferred() and therefore\n  /// is not allowed to create new references to things that need to be emitted\n  /// lazily.\n  void EmitVTablesOpportunistically();\n\n  /// Call replaceAllUsesWith on all pairs in Replacements.\n  void applyReplacements();\n\n  /// Call replaceAllUsesWith on all pairs in GlobalValReplacements.\n  void applyGlobalValReplacements();\n\n  void checkAliases();\n\n  std::map<int, llvm::TinyPtrVector<llvm::Function *>> DtorsUsingAtExit;\n\n  /// Register functions annotated with __attribute__((destructor)) using\n  /// __cxa_atexit, if it is available, or atexit otherwise.\n  void registerGlobalDtorsWithAtExit();\n\n  // When using sinit and sterm functions, unregister\n  // __attribute__((destructor)) annotated functions which were previously\n  // registered by the atexit subroutine using unatexit.\n  void unregisterGlobalDtorsWithUnAtExit();\n\n  void emitMultiVersionFunctions();\n\n  /// Emit any vtables which we deferred and still have a use for.\n  void EmitDeferredVTables();\n\n  /// Emit a dummy function that reference a CoreFoundation symbol when\n  /// @available is used on Darwin.\n  void emitAtAvailableLinkGuard();\n\n  /// Emit the llvm.used and llvm.compiler.used metadata.\n  void emitLLVMUsed();\n\n  /// Emit the link options introduced by imported modules.\n  void EmitModuleLinkOptions();\n\n  /// Emit aliases for internal-linkage declarations inside \"C\" language\n  /// linkage specifications, giving them the \"expected\" name where possible.\n  void EmitStaticExternCAliases();\n\n  void EmitDeclMetadata();\n\n  /// Emit the Clang version as llvm.ident metadata.\n  void EmitVersionIdentMetadata();\n\n  /// Emit the Clang commandline as llvm.commandline metadata.\n  void EmitCommandLineMetadata();\n\n  /// Emit the module flag metadata used to pass options controlling the\n  /// the backend to LLVM.\n  void EmitBackendOptionsMetadata(const CodeGenOptions CodeGenOpts);\n\n  /// Emits OpenCL specific Metadata e.g. OpenCL version.\n  void EmitOpenCLMetadata();\n\n  /// Emit the llvm.gcov metadata used to tell LLVM where to emit the .gcno and\n  /// .gcda files in a way that persists in .bc files.\n  void EmitCoverageFile();\n\n  /// Determine whether the definition must be emitted; if this returns \\c\n  /// false, the definition can be emitted lazily if it's used.\n  bool MustBeEmitted(const ValueDecl *D);\n\n  /// Determine whether the definition can be emitted eagerly, or should be\n  /// delayed until the end of the translation unit. This is relevant for\n  /// definitions whose linkage can change, e.g. implicit function instantions\n  /// which may later be explicitly instantiated.\n  bool MayBeEmittedEagerly(const ValueDecl *D);\n\n  /// Check whether we can use a \"simpler\", more core exceptions personality\n  /// function.\n  void SimplifyPersonality();\n\n  /// Helper function for ConstructAttributeList and\n  /// addDefaultFunctionDefinitionAttributes.  Builds a set of function\n  /// attributes to add to a function with the given properties.\n  void getDefaultFunctionAttributes(StringRef Name, bool HasOptnone,\n                                    bool AttrOnCallSite,\n                                    llvm::AttrBuilder &FuncAttrs);\n\n  llvm::Metadata *CreateMetadataIdentifierImpl(QualType T, MetadataTypeMap &Map,\n                                               StringRef Suffix);\n};\n\n}  // end namespace CodeGen\n}  // end namespace clang\n\n#endif // LLVM_CLANG_LIB_CODEGEN_CODEGENMODULE_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/EHScopeStack.h", "content": "//===-- EHScopeStack.h - Stack for cleanup IR generation --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// These classes should be the minimum interface required for other parts of\n// CodeGen to emit cleanups.  The implementation is in CGCleanup.cpp and other\n// implemenentation details that are not widely needed are in CGCleanup.h.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_EHSCOPESTACK_H\n#define LLVM_CLANG_LIB_CODEGEN_EHSCOPESTACK_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Value.h\"\n\nnamespace clang {\nnamespace CodeGen {\n\nclass CodeGenFunction;\n\n/// A branch fixup.  These are required when emitting a goto to a\n/// label which hasn't been emitted yet.  The goto is optimistically\n/// emitted as a branch to the basic block for the label, and (if it\n/// occurs in a scope with non-trivial cleanups) a fixup is added to\n/// the innermost cleanup.  When a (normal) cleanup is popped, any\n/// unresolved fixups in that scope are threaded through the cleanup.\nstruct BranchFixup {\n  /// The block containing the terminator which needs to be modified\n  /// into a switch if this fixup is resolved into the current scope.\n  /// If null, LatestBranch points directly to the destination.\n  llvm::BasicBlock *OptimisticBranchBlock;\n\n  /// The ultimate destination of the branch.\n  ///\n  /// This can be set to null to indicate that this fixup was\n  /// successfully resolved.\n  llvm::BasicBlock *Destination;\n\n  /// The destination index value.\n  unsigned DestinationIndex;\n\n  /// The initial branch of the fixup.\n  llvm::BranchInst *InitialBranch;\n};\n\ntemplate <class T> struct InvariantValue {\n  typedef T type;\n  typedef T saved_type;\n  static bool needsSaving(type value) { return false; }\n  static saved_type save(CodeGenFunction &CGF, type value) { return value; }\n  static type restore(CodeGenFunction &CGF, saved_type value) { return value; }\n};\n\n/// A metaprogramming class for ensuring that a value will dominate an\n/// arbitrary position in a function.\ntemplate <class T> struct DominatingValue : InvariantValue<T> {};\n\ntemplate <class T, bool mightBeInstruction =\n            std::is_base_of<llvm::Value, T>::value &&\n            !std::is_base_of<llvm::Constant, T>::value &&\n            !std::is_base_of<llvm::BasicBlock, T>::value>\nstruct DominatingPointer;\ntemplate <class T> struct DominatingPointer<T,false> : InvariantValue<T*> {};\n// template <class T> struct DominatingPointer<T,true> at end of file\n\ntemplate <class T> struct DominatingValue<T*> : DominatingPointer<T> {};\n\nenum CleanupKind : unsigned {\n  /// Denotes a cleanup that should run when a scope is exited using exceptional\n  /// control flow (a throw statement leading to stack unwinding, ).\n  EHCleanup = 0x1,\n\n  /// Denotes a cleanup that should run when a scope is exited using normal\n  /// control flow (falling off the end of the scope, return, goto, ...).\n  NormalCleanup = 0x2,\n\n  NormalAndEHCleanup = EHCleanup | NormalCleanup,\n\n  LifetimeMarker = 0x8,\n  NormalEHLifetimeMarker = LifetimeMarker | NormalAndEHCleanup,\n};\n\n/// A stack of scopes which respond to exceptions, including cleanups\n/// and catch blocks.\nclass EHScopeStack {\npublic:\n  /* Should switch to alignof(uint64_t) instead of 8, when EHCleanupScope can */\n  enum { ScopeStackAlignment = 8 };\n\n  /// A saved depth on the scope stack.  This is necessary because\n  /// pushing scopes onto the stack invalidates iterators.\n  class stable_iterator {\n    friend class EHScopeStack;\n\n    /// Offset from StartOfData to EndOfBuffer.\n    ptrdiff_t Size;\n\n    stable_iterator(ptrdiff_t Size) : Size(Size) {}\n\n  public:\n    static stable_iterator invalid() { return stable_iterator(-1); }\n    stable_iterator() : Size(-1) {}\n\n    bool isValid() const { return Size >= 0; }\n\n    /// Returns true if this scope encloses I.\n    /// Returns false if I is invalid.\n    /// This scope must be valid.\n    bool encloses(stable_iterator I) const { return Size <= I.Size; }\n\n    /// Returns true if this scope strictly encloses I: that is,\n    /// if it encloses I and is not I.\n    /// Returns false is I is invalid.\n    /// This scope must be valid.\n    bool strictlyEncloses(stable_iterator I) const { return Size < I.Size; }\n\n    friend bool operator==(stable_iterator A, stable_iterator B) {\n      return A.Size == B.Size;\n    }\n    friend bool operator!=(stable_iterator A, stable_iterator B) {\n      return A.Size != B.Size;\n    }\n  };\n\n  /// Information for lazily generating a cleanup.  Subclasses must be\n  /// POD-like: cleanups will not be destructed, and they will be\n  /// allocated on the cleanup stack and freely copied and moved\n  /// around.\n  ///\n  /// Cleanup implementations should generally be declared in an\n  /// anonymous namespace.\n  class Cleanup {\n    // Anchor the construction vtable.\n    virtual void anchor();\n\n  protected:\n    ~Cleanup() = default;\n\n  public:\n    Cleanup(const Cleanup &) = default;\n    Cleanup(Cleanup &&) {}\n    Cleanup() = default;\n\n    /// Generation flags.\n    class Flags {\n      enum {\n        F_IsForEH = 0x1,\n        F_IsNormalCleanupKind = 0x2,\n        F_IsEHCleanupKind = 0x4,\n        F_HasExitSwitch = 0x8,\n      };\n      unsigned flags;\n\n    public:\n      Flags() : flags(0) {}\n\n      /// isForEH - true if the current emission is for an EH cleanup.\n      bool isForEHCleanup() const { return flags & F_IsForEH; }\n      bool isForNormalCleanup() const { return !isForEHCleanup(); }\n      void setIsForEHCleanup() { flags |= F_IsForEH; }\n\n      bool isNormalCleanupKind() const { return flags & F_IsNormalCleanupKind; }\n      void setIsNormalCleanupKind() { flags |= F_IsNormalCleanupKind; }\n\n      /// isEHCleanupKind - true if the cleanup was pushed as an EH\n      /// cleanup.\n      bool isEHCleanupKind() const { return flags & F_IsEHCleanupKind; }\n      void setIsEHCleanupKind() { flags |= F_IsEHCleanupKind; }\n\n      bool hasExitSwitch() const { return flags & F_HasExitSwitch; }\n      void setHasExitSwitch() { flags |= F_HasExitSwitch; }\n    };\n\n    /// Emit the cleanup.  For normal cleanups, this is run in the\n    /// same EH context as when the cleanup was pushed, i.e. the\n    /// immediately-enclosing context of the cleanup scope.  For\n    /// EH cleanups, this is run in a terminate context.\n    ///\n    // \\param flags cleanup kind.\n    virtual void Emit(CodeGenFunction &CGF, Flags flags) = 0;\n  };\n\n  /// ConditionalCleanup stores the saved form of its parameters,\n  /// then restores them and performs the cleanup.\n  template <class T, class... As>\n  class ConditionalCleanup final : public Cleanup {\n    typedef std::tuple<typename DominatingValue<As>::saved_type...> SavedTuple;\n    SavedTuple Saved;\n\n    template <std::size_t... Is>\n    T restore(CodeGenFunction &CGF, std::index_sequence<Is...>) {\n      // It's important that the restores are emitted in order. The braced init\n      // list guarantees that.\n      return T{DominatingValue<As>::restore(CGF, std::get<Is>(Saved))...};\n    }\n\n    void Emit(CodeGenFunction &CGF, Flags flags) override {\n      restore(CGF, std::index_sequence_for<As...>()).Emit(CGF, flags);\n    }\n\n  public:\n    ConditionalCleanup(typename DominatingValue<As>::saved_type... A)\n        : Saved(A...) {}\n\n    ConditionalCleanup(SavedTuple Tuple) : Saved(std::move(Tuple)) {}\n  };\n\nprivate:\n  // The implementation for this class is in CGException.h and\n  // CGException.cpp; the definition is here because it's used as a\n  // member of CodeGenFunction.\n\n  /// The start of the scope-stack buffer, i.e. the allocated pointer\n  /// for the buffer.  All of these pointers are either simultaneously\n  /// null or simultaneously valid.\n  char *StartOfBuffer;\n\n  /// The end of the buffer.\n  char *EndOfBuffer;\n\n  /// The first valid entry in the buffer.\n  char *StartOfData;\n\n  /// The innermost normal cleanup on the stack.\n  stable_iterator InnermostNormalCleanup;\n\n  /// The innermost EH scope on the stack.\n  stable_iterator InnermostEHScope;\n\n  /// The current set of branch fixups.  A branch fixup is a jump to\n  /// an as-yet unemitted label, i.e. a label for which we don't yet\n  /// know the EH stack depth.  Whenever we pop a cleanup, we have\n  /// to thread all the current branch fixups through it.\n  ///\n  /// Fixups are recorded as the Use of the respective branch or\n  /// switch statement.  The use points to the final destination.\n  /// When popping out of a cleanup, these uses are threaded through\n  /// the cleanup and adjusted to point to the new cleanup.\n  ///\n  /// Note that branches are allowed to jump into protected scopes\n  /// in certain situations;  e.g. the following code is legal:\n  ///     struct A { ~A(); }; // trivial ctor, non-trivial dtor\n  ///     goto foo;\n  ///     A a;\n  ///    foo:\n  ///     bar();\n  SmallVector<BranchFixup, 8> BranchFixups;\n\n  char *allocate(size_t Size);\n  void deallocate(size_t Size);\n\n  void *pushCleanup(CleanupKind K, size_t DataSize);\n\npublic:\n  EHScopeStack() : StartOfBuffer(nullptr), EndOfBuffer(nullptr),\n                   StartOfData(nullptr), InnermostNormalCleanup(stable_end()),\n                   InnermostEHScope(stable_end()) {}\n  ~EHScopeStack() { delete[] StartOfBuffer; }\n\n  /// Push a lazily-created cleanup on the stack.\n  template <class T, class... As> void pushCleanup(CleanupKind Kind, As... A) {\n    static_assert(alignof(T) <= ScopeStackAlignment,\n                  \"Cleanup's alignment is too large.\");\n    void *Buffer = pushCleanup(Kind, sizeof(T));\n    Cleanup *Obj = new (Buffer) T(A...);\n    (void) Obj;\n  }\n\n  /// Push a lazily-created cleanup on the stack. Tuple version.\n  template <class T, class... As>\n  void pushCleanupTuple(CleanupKind Kind, std::tuple<As...> A) {\n    static_assert(alignof(T) <= ScopeStackAlignment,\n                  \"Cleanup's alignment is too large.\");\n    void *Buffer = pushCleanup(Kind, sizeof(T));\n    Cleanup *Obj = new (Buffer) T(std::move(A));\n    (void) Obj;\n  }\n\n  // Feel free to add more variants of the following:\n\n  /// Push a cleanup with non-constant storage requirements on the\n  /// stack.  The cleanup type must provide an additional static method:\n  ///   static size_t getExtraSize(size_t);\n  /// The argument to this method will be the value N, which will also\n  /// be passed as the first argument to the constructor.\n  ///\n  /// The data stored in the extra storage must obey the same\n  /// restrictions as normal cleanup member data.\n  ///\n  /// The pointer returned from this method is valid until the cleanup\n  /// stack is modified.\n  template <class T, class... As>\n  T *pushCleanupWithExtra(CleanupKind Kind, size_t N, As... A) {\n    static_assert(alignof(T) <= ScopeStackAlignment,\n                  \"Cleanup's alignment is too large.\");\n    void *Buffer = pushCleanup(Kind, sizeof(T) + T::getExtraSize(N));\n    return new (Buffer) T(N, A...);\n  }\n\n  void pushCopyOfCleanup(CleanupKind Kind, const void *Cleanup, size_t Size) {\n    void *Buffer = pushCleanup(Kind, Size);\n    std::memcpy(Buffer, Cleanup, Size);\n  }\n\n  /// Pops a cleanup scope off the stack.  This is private to CGCleanup.cpp.\n  void popCleanup();\n\n  /// Push a set of catch handlers on the stack.  The catch is\n  /// uninitialized and will need to have the given number of handlers\n  /// set on it.\n  class EHCatchScope *pushCatch(unsigned NumHandlers);\n\n  /// Pops a catch scope off the stack.  This is private to CGException.cpp.\n  void popCatch();\n\n  /// Push an exceptions filter on the stack.\n  class EHFilterScope *pushFilter(unsigned NumFilters);\n\n  /// Pops an exceptions filter off the stack.\n  void popFilter();\n\n  /// Push a terminate handler on the stack.\n  void pushTerminate();\n\n  /// Pops a terminate handler off the stack.\n  void popTerminate();\n\n  // Returns true iff the current scope is either empty or contains only\n  // lifetime markers, i.e. no real cleanup code\n  bool containsOnlyLifetimeMarkers(stable_iterator Old) const;\n\n  /// Determines whether the exception-scopes stack is empty.\n  bool empty() const { return StartOfData == EndOfBuffer; }\n\n  bool requiresLandingPad() const;\n\n  /// Determines whether there are any normal cleanups on the stack.\n  bool hasNormalCleanups() const {\n    return InnermostNormalCleanup != stable_end();\n  }\n\n  /// Returns the innermost normal cleanup on the stack, or\n  /// stable_end() if there are no normal cleanups.\n  stable_iterator getInnermostNormalCleanup() const {\n    return InnermostNormalCleanup;\n  }\n  stable_iterator getInnermostActiveNormalCleanup() const;\n\n  stable_iterator getInnermostEHScope() const {\n    return InnermostEHScope;\n  }\n\n\n  /// An unstable reference to a scope-stack depth.  Invalidated by\n  /// pushes but not pops.\n  class iterator;\n\n  /// Returns an iterator pointing to the innermost EH scope.\n  iterator begin() const;\n\n  /// Returns an iterator pointing to the outermost EH scope.\n  iterator end() const;\n\n  /// Create a stable reference to the top of the EH stack.  The\n  /// returned reference is valid until that scope is popped off the\n  /// stack.\n  stable_iterator stable_begin() const {\n    return stable_iterator(EndOfBuffer - StartOfData);\n  }\n\n  /// Create a stable reference to the bottom of the EH stack.\n  static stable_iterator stable_end() {\n    return stable_iterator(0);\n  }\n\n  /// Translates an iterator into a stable_iterator.\n  stable_iterator stabilize(iterator it) const;\n\n  /// Turn a stable reference to a scope depth into a unstable pointer\n  /// to the EH stack.\n  iterator find(stable_iterator save) const;\n\n  /// Add a branch fixup to the current cleanup scope.\n  BranchFixup &addBranchFixup() {\n    assert(hasNormalCleanups() && \"adding fixup in scope without cleanups\");\n    BranchFixups.push_back(BranchFixup());\n    return BranchFixups.back();\n  }\n\n  unsigned getNumBranchFixups() const { return BranchFixups.size(); }\n  BranchFixup &getBranchFixup(unsigned I) {\n    assert(I < getNumBranchFixups());\n    return BranchFixups[I];\n  }\n\n  /// Pops lazily-removed fixups from the end of the list.  This\n  /// should only be called by procedures which have just popped a\n  /// cleanup or resolved one or more fixups.\n  void popNullFixups();\n\n  /// Clears the branch-fixups list.  This should only be called by\n  /// ResolveAllBranchFixups.\n  void clearFixups() { BranchFixups.clear(); }\n};\n\n} // namespace CodeGen\n} // namespace clang\n\n#endif\n"}, "75": {"id": 75, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h", "content": "//===- InstrProf.h - Instrumented profiling format support ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Instrumentation-based profiling data is generated by instrumented\n// binaries through library functions in compiler-rt, and read by the clang\n// frontend to feed PGO.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_PROFILEDATA_INSTRPROF_H\n#define LLVM_PROFILEDATA_INSTRPROF_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/ProfileSummary.h\"\n#include \"llvm/ProfileData/InstrProfData.inc\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/Host.h\"\n#include \"llvm/Support/MD5.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <list>\n#include <memory>\n#include <string>\n#include <system_error>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass Function;\nclass GlobalVariable;\nstruct InstrProfRecord;\nclass InstrProfSymtab;\nclass Instruction;\nclass MDNode;\nclass Module;\n\nenum InstrProfSectKind {\n#define INSTR_PROF_SECT_ENTRY(Kind, SectNameCommon, SectNameCoff, Prefix) Kind,\n#include \"llvm/ProfileData/InstrProfData.inc\"\n};\n\n/// Return the name of the profile section corresponding to \\p IPSK.\n///\n/// The name of the section depends on the object format type \\p OF. If\n/// \\p AddSegmentInfo is true, a segment prefix and additional linker hints may\n/// be added to the section name (this is the default).\nstd::string getInstrProfSectionName(InstrProfSectKind IPSK,\n                                    Triple::ObjectFormatType OF,\n                                    bool AddSegmentInfo = true);\n\n/// Return the name profile runtime entry point to do value profiling\n/// for a given site.\ninline StringRef getInstrProfValueProfFuncName() {\n  return INSTR_PROF_VALUE_PROF_FUNC_STR;\n}\n\n/// Return the name profile runtime entry point to do memop size value\n/// profiling.\ninline StringRef getInstrProfValueProfMemOpFuncName() {\n  return INSTR_PROF_VALUE_PROF_MEMOP_FUNC_STR;\n}\n\n/// Return the name prefix of variables containing instrumented function names.\ninline StringRef getInstrProfNameVarPrefix() { return \"__profn_\"; }\n\n/// Return the name prefix of variables containing per-function control data.\ninline StringRef getInstrProfDataVarPrefix() { return \"__profd_\"; }\n\n/// Return the name prefix of profile counter variables.\ninline StringRef getInstrProfCountersVarPrefix() { return \"__profc_\"; }\n\n/// Return the name prefix of value profile variables.\ninline StringRef getInstrProfValuesVarPrefix() { return \"__profvp_\"; }\n\n/// Return the name of value profile node array variables:\ninline StringRef getInstrProfVNodesVarName() { return \"__llvm_prf_vnodes\"; }\n\n/// Return the name of the variable holding the strings (possibly compressed)\n/// of all function's PGO names.\ninline StringRef getInstrProfNamesVarName() {\n  return \"__llvm_prf_nm\";\n}\n\n/// Return the name of a covarage mapping variable (internal linkage)\n/// for each instrumented source module. Such variables are allocated\n/// in the __llvm_covmap section.\ninline StringRef getCoverageMappingVarName() {\n  return \"__llvm_coverage_mapping\";\n}\n\n/// Return the name of the internal variable recording the array\n/// of PGO name vars referenced by the coverage mapping. The owning\n/// functions of those names are not emitted by FE (e.g, unused inline\n/// functions.)\ninline StringRef getCoverageUnusedNamesVarName() {\n  return \"__llvm_coverage_names\";\n}\n\n/// Return the name of function that registers all the per-function control\n/// data at program startup time by calling __llvm_register_function. This\n/// function has internal linkage and is called by  __llvm_profile_init\n/// runtime method. This function is not generated for these platforms:\n/// Darwin, Linux, and FreeBSD.\ninline StringRef getInstrProfRegFuncsName() {\n  return \"__llvm_profile_register_functions\";\n}\n\n/// Return the name of the runtime interface that registers per-function control\n/// data for one instrumented function.\ninline StringRef getInstrProfRegFuncName() {\n  return \"__llvm_profile_register_function\";\n}\n\n/// Return the name of the runtime interface that registers the PGO name strings.\ninline StringRef getInstrProfNamesRegFuncName() {\n  return \"__llvm_profile_register_names_function\";\n}\n\n/// Return the name of the runtime initialization method that is generated by\n/// the compiler. The function calls __llvm_profile_register_functions and\n/// __llvm_profile_override_default_filename functions if needed. This function\n/// has internal linkage and invoked at startup time via init_array.\ninline StringRef getInstrProfInitFuncName() { return \"__llvm_profile_init\"; }\n\n/// Return the name of the hook variable defined in profile runtime library.\n/// A reference to the variable causes the linker to link in the runtime\n/// initialization module (which defines the hook variable).\ninline StringRef getInstrProfRuntimeHookVarName() {\n  return INSTR_PROF_QUOTE(INSTR_PROF_PROFILE_RUNTIME_VAR);\n}\n\ninline StringRef getInstrProfCounterBiasVarName() {\n  return \"__llvm_profile_counter_bias\";\n}\n\n/// Return the marker used to separate PGO names during serialization.\ninline StringRef getInstrProfNameSeparator() { return \"\\01\"; }\n\n/// Return the modified name for function \\c F suitable to be\n/// used the key for profile lookup. Variable \\c InLTO indicates if this\n/// is called in LTO optimization passes.\nstd::string getPGOFuncName(const Function &F, bool InLTO = false,\n                           uint64_t Version = INSTR_PROF_INDEX_VERSION);\n\n/// Return the modified name for a function suitable to be\n/// used the key for profile lookup. The function's original\n/// name is \\c RawFuncName and has linkage of type \\c Linkage.\n/// The function is defined in module \\c FileName.\nstd::string getPGOFuncName(StringRef RawFuncName,\n                           GlobalValue::LinkageTypes Linkage,\n                           StringRef FileName,\n                           uint64_t Version = INSTR_PROF_INDEX_VERSION);\n\n/// Return the name of the global variable used to store a function\n/// name in PGO instrumentation. \\c FuncName is the name of the function\n/// returned by the \\c getPGOFuncName call.\nstd::string getPGOFuncNameVarName(StringRef FuncName,\n                                  GlobalValue::LinkageTypes Linkage);\n\n/// Create and return the global variable for function name used in PGO\n/// instrumentation. \\c FuncName is the name of the function returned\n/// by \\c getPGOFuncName call.\nGlobalVariable *createPGOFuncNameVar(Function &F, StringRef PGOFuncName);\n\n/// Create and return the global variable for function name used in PGO\n/// instrumentation.  /// \\c FuncName is the name of the function\n/// returned by \\c getPGOFuncName call, \\c M is the owning module,\n/// and \\c Linkage is the linkage of the instrumented function.\nGlobalVariable *createPGOFuncNameVar(Module &M,\n                                     GlobalValue::LinkageTypes Linkage,\n                                     StringRef PGOFuncName);\n\n/// Return the initializer in string of the PGO name var \\c NameVar.\nStringRef getPGOFuncNameVarInitializer(GlobalVariable *NameVar);\n\n/// Given a PGO function name, remove the filename prefix and return\n/// the original (static) function name.\nStringRef getFuncNameWithoutPrefix(StringRef PGOFuncName,\n                                   StringRef FileName = \"<unknown>\");\n\n/// Given a vector of strings (function PGO names) \\c NameStrs, the\n/// method generates a combined string \\c Result thatis ready to be\n/// serialized.  The \\c Result string is comprised of three fields:\n/// The first field is the legnth of the uncompressed strings, and the\n/// the second field is the length of the zlib-compressed string.\n/// Both fields are encoded in ULEB128.  If \\c doCompress is false, the\n///  third field is the uncompressed strings; otherwise it is the\n/// compressed string. When the string compression is off, the\n/// second field will have value zero.\nError collectPGOFuncNameStrings(ArrayRef<std::string> NameStrs,\n                                bool doCompression, std::string &Result);\n\n/// Produce \\c Result string with the same format described above. The input\n/// is vector of PGO function name variables that are referenced.\nError collectPGOFuncNameStrings(ArrayRef<GlobalVariable *> NameVars,\n                                std::string &Result, bool doCompression = true);\n\n/// \\c NameStrings is a string composed of one of more sub-strings encoded in\n/// the format described above. The substrings are separated by 0 or more zero\n/// bytes. This method decodes the string and populates the \\c Symtab.\nError readPGOFuncNameStrings(StringRef NameStrings, InstrProfSymtab &Symtab);\n\n/// Check if INSTR_PROF_RAW_VERSION_VAR is defined. This global is only being\n/// set in IR PGO compilation.\nbool isIRPGOFlagSet(const Module *M);\n\n/// Check if we can safely rename this Comdat function. Instances of the same\n/// comdat function may have different control flows thus can not share the\n/// same counter variable.\nbool canRenameComdatFunc(const Function &F, bool CheckAddressTaken = false);\n\nenum InstrProfValueKind : uint32_t {\n#define VALUE_PROF_KIND(Enumerator, Value, Descr) Enumerator = Value,\n#include \"llvm/ProfileData/InstrProfData.inc\"\n};\n\n/// Get the value profile data for value site \\p SiteIdx from \\p InstrProfR\n/// and annotate the instruction \\p Inst with the value profile meta data.\n/// Annotate up to \\p MaxMDCount (default 3) number of records per value site.\nvoid annotateValueSite(Module &M, Instruction &Inst,\n                       const InstrProfRecord &InstrProfR,\n                       InstrProfValueKind ValueKind, uint32_t SiteIndx,\n                       uint32_t MaxMDCount = 3);\n\n/// Same as the above interface but using an ArrayRef, as well as \\p Sum.\nvoid annotateValueSite(Module &M, Instruction &Inst,\n                       ArrayRef<InstrProfValueData> VDs, uint64_t Sum,\n                       InstrProfValueKind ValueKind, uint32_t MaxMDCount);\n\n/// Magic number in the value profile data showing a target has been\n/// promoted for the instruction and shouldn't be promoted again.\nconst uint64_t NOMORE_ICP_MAGICNUM = -1;\n\n/// Extract the value profile data from \\p Inst which is annotated with\n/// value profile meta data. Return false if there is no value data annotated,\n/// otherwise  return true.\nbool getValueProfDataFromInst(const Instruction &Inst,\n                              InstrProfValueKind ValueKind,\n                              uint32_t MaxNumValueData,\n                              InstrProfValueData ValueData[],\n                              uint32_t &ActualNumValueData, uint64_t &TotalC,\n                              bool GetNoICPValue = false);\n\ninline StringRef getPGOFuncNameMetadataName() { return \"PGOFuncName\"; }\n\n/// Return the PGOFuncName meta data associated with a function.\nMDNode *getPGOFuncNameMetadata(const Function &F);\n\n/// Create the PGOFuncName meta data if PGOFuncName is different from\n/// function's raw name. This should only apply to internal linkage functions\n/// declared by users only.\nvoid createPGOFuncNameMetadata(Function &F, StringRef PGOFuncName);\n\n/// Check if we can use Comdat for profile variables. This will eliminate\n/// the duplicated profile variables for Comdat functions.\nbool needsComdatForCounter(const Function &F, const Module &M);\n\nconst std::error_category &instrprof_category();\n\nenum class instrprof_error {\n  success = 0,\n  eof,\n  unrecognized_format,\n  bad_magic,\n  bad_header,\n  unsupported_version,\n  unsupported_hash_type,\n  too_large,\n  truncated,\n  malformed,\n  unknown_function,\n  invalid_prof,\n  hash_mismatch,\n  count_mismatch,\n  counter_overflow,\n  value_site_count_mismatch,\n  compress_failed,\n  uncompress_failed,\n  empty_raw_profile,\n  zlib_unavailable\n};\n\ninline std::error_code make_error_code(instrprof_error E) {\n  return std::error_code(static_cast<int>(E), instrprof_category());\n}\n\nclass InstrProfError : public ErrorInfo<InstrProfError> {\npublic:\n  InstrProfError(instrprof_error Err) : Err(Err) {\n    assert(Err != instrprof_error::success && \"Not an error\");\n  }\n\n  std::string message() const override;\n\n  void log(raw_ostream &OS) const override { OS << message(); }\n\n  std::error_code convertToErrorCode() const override {\n    return make_error_code(Err);\n  }\n\n  instrprof_error get() const { return Err; }\n\n  /// Consume an Error and return the raw enum value contained within it. The\n  /// Error must either be a success value, or contain a single InstrProfError.\n  static instrprof_error take(Error E) {\n    auto Err = instrprof_error::success;\n    handleAllErrors(std::move(E), [&Err](const InstrProfError &IPE) {\n      assert(Err == instrprof_error::success && \"Multiple errors encountered\");\n      Err = IPE.get();\n    });\n    return Err;\n  }\n\n  static char ID;\n\nprivate:\n  instrprof_error Err;\n};\n\nclass SoftInstrProfErrors {\n  /// Count the number of soft instrprof_errors encountered and keep track of\n  /// the first such error for reporting purposes.\n\n  /// The first soft error encountered.\n  instrprof_error FirstError = instrprof_error::success;\n\n  /// The number of hash mismatches.\n  unsigned NumHashMismatches = 0;\n\n  /// The number of count mismatches.\n  unsigned NumCountMismatches = 0;\n\n  /// The number of counter overflows.\n  unsigned NumCounterOverflows = 0;\n\n  /// The number of value site count mismatches.\n  unsigned NumValueSiteCountMismatches = 0;\n\npublic:\n  SoftInstrProfErrors() = default;\n\n  ~SoftInstrProfErrors() {\n    assert(FirstError == instrprof_error::success &&\n           \"Unchecked soft error encountered\");\n  }\n\n  /// Track a soft error (\\p IE) and increment its associated counter.\n  void addError(instrprof_error IE);\n\n  /// Get the number of hash mismatches.\n  unsigned getNumHashMismatches() const { return NumHashMismatches; }\n\n  /// Get the number of count mismatches.\n  unsigned getNumCountMismatches() const { return NumCountMismatches; }\n\n  /// Get the number of counter overflows.\n  unsigned getNumCounterOverflows() const { return NumCounterOverflows; }\n\n  /// Get the number of value site count mismatches.\n  unsigned getNumValueSiteCountMismatches() const {\n    return NumValueSiteCountMismatches;\n  }\n\n  /// Return the first encountered error and reset FirstError to a success\n  /// value.\n  Error takeError() {\n    if (FirstError == instrprof_error::success)\n      return Error::success();\n    auto E = make_error<InstrProfError>(FirstError);\n    FirstError = instrprof_error::success;\n    return E;\n  }\n};\n\nnamespace object {\n\nclass SectionRef;\n\n} // end namespace object\n\nnamespace IndexedInstrProf {\n\nuint64_t ComputeHash(StringRef K);\n\n} // end namespace IndexedInstrProf\n\n/// A symbol table used for function PGO name look-up with keys\n/// (such as pointers, md5hash values) to the function. A function's\n/// PGO name or name's md5hash are used in retrieving the profile\n/// data of the function. See \\c getPGOFuncName() method for details\n/// on how PGO name is formed.\nclass InstrProfSymtab {\npublic:\n  using AddrHashMap = std::vector<std::pair<uint64_t, uint64_t>>;\n\nprivate:\n  StringRef Data;\n  uint64_t Address = 0;\n  // Unique name strings.\n  StringSet<> NameTab;\n  // A map from MD5 keys to function name strings.\n  std::vector<std::pair<uint64_t, StringRef>> MD5NameMap;\n  // A map from MD5 keys to function define. We only populate this map\n  // when build the Symtab from a Module.\n  std::vector<std::pair<uint64_t, Function *>> MD5FuncMap;\n  // A map from function runtime address to function name MD5 hash.\n  // This map is only populated and used by raw instr profile reader.\n  AddrHashMap AddrToMD5Map;\n  bool Sorted = false;\n\n  static StringRef getExternalSymbol() {\n    return \"** External Symbol **\";\n  }\n\n  // If the symtab is created by a series of calls to \\c addFuncName, \\c\n  // finalizeSymtab needs to be called before looking up function names.\n  // This is required because the underlying map is a vector (for space\n  // efficiency) which needs to be sorted.\n  inline void finalizeSymtab();\n\npublic:\n  InstrProfSymtab() = default;\n\n  /// Create InstrProfSymtab from an object file section which\n  /// contains function PGO names. When section may contain raw\n  /// string data or string data in compressed form. This method\n  /// only initialize the symtab with reference to the data and\n  /// the section base address. The decompression will be delayed\n  /// until before it is used. See also \\c create(StringRef) method.\n  Error create(object::SectionRef &Section);\n\n  /// This interface is used by reader of CoverageMapping test\n  /// format.\n  inline Error create(StringRef D, uint64_t BaseAddr);\n\n  /// \\c NameStrings is a string composed of one of more sub-strings\n  ///  encoded in the format described in \\c collectPGOFuncNameStrings.\n  /// This method is a wrapper to \\c readPGOFuncNameStrings method.\n  inline Error create(StringRef NameStrings);\n\n  /// A wrapper interface to populate the PGO symtab with functions\n  /// decls from module \\c M. This interface is used by transformation\n  /// passes such as indirect function call promotion. Variable \\c InLTO\n  /// indicates if this is called from LTO optimization passes.\n  Error create(Module &M, bool InLTO = false);\n\n  /// Create InstrProfSymtab from a set of names iteratable from\n  /// \\p IterRange. This interface is used by IndexedProfReader.\n  template <typename NameIterRange> Error create(const NameIterRange &IterRange);\n\n  /// Update the symtab by adding \\p FuncName to the table. This interface\n  /// is used by the raw and text profile readers.\n  Error addFuncName(StringRef FuncName) {\n    if (FuncName.empty())\n      return make_error<InstrProfError>(instrprof_error::malformed);\n    auto Ins = NameTab.insert(FuncName);\n    if (Ins.second) {\n      MD5NameMap.push_back(std::make_pair(\n          IndexedInstrProf::ComputeHash(FuncName), Ins.first->getKey()));\n      Sorted = false;\n    }\n    return Error::success();\n  }\n\n  /// Map a function address to its name's MD5 hash. This interface\n  /// is only used by the raw profiler reader.\n  void mapAddress(uint64_t Addr, uint64_t MD5Val) {\n    AddrToMD5Map.push_back(std::make_pair(Addr, MD5Val));\n  }\n\n  /// Return a function's hash, or 0, if the function isn't in this SymTab.\n  uint64_t getFunctionHashFromAddress(uint64_t Address);\n\n  /// Return function's PGO name from the function name's symbol\n  /// address in the object file. If an error occurs, return\n  /// an empty string.\n  StringRef getFuncName(uint64_t FuncNameAddress, size_t NameSize);\n\n  /// Return function's PGO name from the name's md5 hash value.\n  /// If not found, return an empty string.\n  inline StringRef getFuncName(uint64_t FuncMD5Hash);\n\n  /// Just like getFuncName, except that it will return a non-empty StringRef\n  /// if the function is external to this symbol table. All such cases\n  /// will be represented using the same StringRef value.\n  inline StringRef getFuncNameOrExternalSymbol(uint64_t FuncMD5Hash);\n\n  /// True if Symbol is the value used to represent external symbols.\n  static bool isExternalSymbol(const StringRef &Symbol) {\n    return Symbol == InstrProfSymtab::getExternalSymbol();\n  }\n\n  /// Return function from the name's md5 hash. Return nullptr if not found.\n  inline Function *getFunction(uint64_t FuncMD5Hash);\n\n  /// Return the function's original assembly name by stripping off\n  /// the prefix attached (to symbols with priviate linkage). For\n  /// global functions, it returns the same string as getFuncName.\n  inline StringRef getOrigFuncName(uint64_t FuncMD5Hash);\n\n  /// Return the name section data.\n  inline StringRef getNameData() const { return Data; }\n};\n\nError InstrProfSymtab::create(StringRef D, uint64_t BaseAddr) {\n  Data = D;\n  Address = BaseAddr;\n  return Error::success();\n}\n\nError InstrProfSymtab::create(StringRef NameStrings) {\n  return readPGOFuncNameStrings(NameStrings, *this);\n}\n\ntemplate <typename NameIterRange>\nError InstrProfSymtab::create(const NameIterRange &IterRange) {\n  for (auto Name : IterRange)\n    if (Error E = addFuncName(Name))\n      return E;\n\n  finalizeSymtab();\n  return Error::success();\n}\n\nvoid InstrProfSymtab::finalizeSymtab() {\n  if (Sorted)\n    return;\n  llvm::sort(MD5NameMap, less_first());\n  llvm::sort(MD5FuncMap, less_first());\n  llvm::sort(AddrToMD5Map, less_first());\n  AddrToMD5Map.erase(std::unique(AddrToMD5Map.begin(), AddrToMD5Map.end()),\n                     AddrToMD5Map.end());\n  Sorted = true;\n}\n\nStringRef InstrProfSymtab::getFuncNameOrExternalSymbol(uint64_t FuncMD5Hash) {\n  StringRef ret = getFuncName(FuncMD5Hash);\n  if (ret.empty())\n    return InstrProfSymtab::getExternalSymbol();\n  return ret;\n}\n\nStringRef InstrProfSymtab::getFuncName(uint64_t FuncMD5Hash) {\n  finalizeSymtab();\n  auto Result = llvm::lower_bound(MD5NameMap, FuncMD5Hash,\n                                  [](const std::pair<uint64_t, StringRef> &LHS,\n                                     uint64_t RHS) { return LHS.first < RHS; });\n  if (Result != MD5NameMap.end() && Result->first == FuncMD5Hash)\n    return Result->second;\n  return StringRef();\n}\n\nFunction* InstrProfSymtab::getFunction(uint64_t FuncMD5Hash) {\n  finalizeSymtab();\n  auto Result = llvm::lower_bound(MD5FuncMap, FuncMD5Hash,\n                                  [](const std::pair<uint64_t, Function *> &LHS,\n                                     uint64_t RHS) { return LHS.first < RHS; });\n  if (Result != MD5FuncMap.end() && Result->first == FuncMD5Hash)\n    return Result->second;\n  return nullptr;\n}\n\n// See also getPGOFuncName implementation. These two need to be\n// matched.\nStringRef InstrProfSymtab::getOrigFuncName(uint64_t FuncMD5Hash) {\n  StringRef PGOName = getFuncName(FuncMD5Hash);\n  size_t S = PGOName.find_first_of(':');\n  if (S == StringRef::npos)\n    return PGOName;\n  return PGOName.drop_front(S + 1);\n}\n\n// To store the sums of profile count values, or the percentage of\n// the sums of the total count values.\nstruct CountSumOrPercent {\n  uint64_t NumEntries;\n  double CountSum;\n  double ValueCounts[IPVK_Last - IPVK_First + 1];\n  CountSumOrPercent() : NumEntries(0), CountSum(0.0f), ValueCounts() {}\n  void reset() {\n    NumEntries = 0;\n    CountSum = 0.0f;\n    for (unsigned I = 0; I < IPVK_Last - IPVK_First + 1; I++)\n      ValueCounts[I] = 0.0f;\n  }\n};\n\n// Function level or program level overlap information.\nstruct OverlapStats {\n  enum OverlapStatsLevel { ProgramLevel, FunctionLevel };\n  // Sum of the total count values for the base profile.\n  CountSumOrPercent Base;\n  // Sum of the total count values for the test profile.\n  CountSumOrPercent Test;\n  // Overlap lap score. Should be in range of [0.0f to 1.0f].\n  CountSumOrPercent Overlap;\n  CountSumOrPercent Mismatch;\n  CountSumOrPercent Unique;\n  OverlapStatsLevel Level;\n  const std::string *BaseFilename;\n  const std::string *TestFilename;\n  StringRef FuncName;\n  uint64_t FuncHash;\n  bool Valid;\n\n  OverlapStats(OverlapStatsLevel L = ProgramLevel)\n      : Level(L), BaseFilename(nullptr), TestFilename(nullptr), FuncHash(0),\n        Valid(false) {}\n\n  void dump(raw_fd_ostream &OS) const;\n\n  void setFuncInfo(StringRef Name, uint64_t Hash) {\n    FuncName = Name;\n    FuncHash = Hash;\n  }\n\n  Error accumulateCounts(const std::string &BaseFilename,\n                         const std::string &TestFilename, bool IsCS);\n  void addOneMismatch(const CountSumOrPercent &MismatchFunc);\n  void addOneUnique(const CountSumOrPercent &UniqueFunc);\n\n  static inline double score(uint64_t Val1, uint64_t Val2, double Sum1,\n                             double Sum2) {\n    if (Sum1 < 1.0f || Sum2 < 1.0f)\n      return 0.0f;\n    return std::min(Val1 / Sum1, Val2 / Sum2);\n  }\n};\n\n// This is used to filter the functions whose overlap information\n// to be output.\nstruct OverlapFuncFilters {\n  uint64_t ValueCutoff;\n  const std::string NameFilter;\n};\n\nstruct InstrProfValueSiteRecord {\n  /// Value profiling data pairs at a given value site.\n  std::list<InstrProfValueData> ValueData;\n\n  InstrProfValueSiteRecord() { ValueData.clear(); }\n  template <class InputIterator>\n  InstrProfValueSiteRecord(InputIterator F, InputIterator L)\n      : ValueData(F, L) {}\n\n  /// Sort ValueData ascending by Value\n  void sortByTargetValues() {\n    ValueData.sort(\n        [](const InstrProfValueData &left, const InstrProfValueData &right) {\n          return left.Value < right.Value;\n        });\n  }\n  /// Sort ValueData Descending by Count\n  inline void sortByCount();\n\n  /// Merge data from another InstrProfValueSiteRecord\n  /// Optionally scale merged counts by \\p Weight.\n  void merge(InstrProfValueSiteRecord &Input, uint64_t Weight,\n             function_ref<void(instrprof_error)> Warn);\n  /// Scale up value profile data counts by N (Numerator) / D (Denominator).\n  void scale(uint64_t N, uint64_t D, function_ref<void(instrprof_error)> Warn);\n\n  /// Compute the overlap b/w this record and Input record.\n  void overlap(InstrProfValueSiteRecord &Input, uint32_t ValueKind,\n               OverlapStats &Overlap, OverlapStats &FuncLevelOverlap);\n};\n\n/// Profiling information for a single function.\nstruct InstrProfRecord {\n  std::vector<uint64_t> Counts;\n\n  InstrProfRecord() = default;\n  InstrProfRecord(std::vector<uint64_t> Counts) : Counts(std::move(Counts)) {}\n  InstrProfRecord(InstrProfRecord &&) = default;\n  InstrProfRecord(const InstrProfRecord &RHS)\n      : Counts(RHS.Counts),\n        ValueData(RHS.ValueData\n                      ? std::make_unique<ValueProfData>(*RHS.ValueData)\n                      : nullptr) {}\n  InstrProfRecord &operator=(InstrProfRecord &&) = default;\n  InstrProfRecord &operator=(const InstrProfRecord &RHS) {\n    Counts = RHS.Counts;\n    if (!RHS.ValueData) {\n      ValueData = nullptr;\n      return *this;\n    }\n    if (!ValueData)\n      ValueData = std::make_unique<ValueProfData>(*RHS.ValueData);\n    else\n      *ValueData = *RHS.ValueData;\n    return *this;\n  }\n\n  /// Return the number of value profile kinds with non-zero number\n  /// of profile sites.\n  inline uint32_t getNumValueKinds() const;\n  /// Return the number of instrumented sites for ValueKind.\n  inline uint32_t getNumValueSites(uint32_t ValueKind) const;\n\n  /// Return the total number of ValueData for ValueKind.\n  inline uint32_t getNumValueData(uint32_t ValueKind) const;\n\n  /// Return the number of value data collected for ValueKind at profiling\n  /// site: Site.\n  inline uint32_t getNumValueDataForSite(uint32_t ValueKind,\n                                         uint32_t Site) const;\n\n  /// Return the array of profiled values at \\p Site. If \\p TotalC\n  /// is not null, the total count of all target values at this site\n  /// will be stored in \\c *TotalC.\n  inline std::unique_ptr<InstrProfValueData[]>\n  getValueForSite(uint32_t ValueKind, uint32_t Site,\n                  uint64_t *TotalC = nullptr) const;\n\n  /// Get the target value/counts of kind \\p ValueKind collected at site\n  /// \\p Site and store the result in array \\p Dest. Return the total\n  /// counts of all target values at this site.\n  inline uint64_t getValueForSite(InstrProfValueData Dest[], uint32_t ValueKind,\n                                  uint32_t Site) const;\n\n  /// Reserve space for NumValueSites sites.\n  inline void reserveSites(uint32_t ValueKind, uint32_t NumValueSites);\n\n  /// Add ValueData for ValueKind at value Site.\n  void addValueData(uint32_t ValueKind, uint32_t Site,\n                    InstrProfValueData *VData, uint32_t N,\n                    InstrProfSymtab *SymTab);\n\n  /// Merge the counts in \\p Other into this one.\n  /// Optionally scale merged counts by \\p Weight.\n  void merge(InstrProfRecord &Other, uint64_t Weight,\n             function_ref<void(instrprof_error)> Warn);\n\n  /// Scale up profile counts (including value profile data) by\n  /// a factor of (N / D).\n  void scale(uint64_t N, uint64_t D, function_ref<void(instrprof_error)> Warn);\n\n  /// Sort value profile data (per site) by count.\n  void sortValueData() {\n    for (uint32_t Kind = IPVK_First; Kind <= IPVK_Last; ++Kind)\n      for (auto &SR : getValueSitesForKind(Kind))\n        SR.sortByCount();\n  }\n\n  /// Clear value data entries and edge counters.\n  void Clear() {\n    Counts.clear();\n    clearValueData();\n  }\n\n  /// Clear value data entries\n  void clearValueData() { ValueData = nullptr; }\n\n  /// Compute the sums of all counts and store in Sum.\n  void accumulateCounts(CountSumOrPercent &Sum) const;\n\n  /// Compute the overlap b/w this IntrprofRecord and Other.\n  void overlap(InstrProfRecord &Other, OverlapStats &Overlap,\n               OverlapStats &FuncLevelOverlap, uint64_t ValueCutoff);\n\n  /// Compute the overlap of value profile counts.\n  void overlapValueProfData(uint32_t ValueKind, InstrProfRecord &Src,\n                            OverlapStats &Overlap,\n                            OverlapStats &FuncLevelOverlap);\n\nprivate:\n  struct ValueProfData {\n    std::vector<InstrProfValueSiteRecord> IndirectCallSites;\n    std::vector<InstrProfValueSiteRecord> MemOPSizes;\n  };\n  std::unique_ptr<ValueProfData> ValueData;\n\n  MutableArrayRef<InstrProfValueSiteRecord>\n  getValueSitesForKind(uint32_t ValueKind) {\n    // Cast to /add/ const (should be an implicit_cast, ideally, if that's ever\n    // implemented in LLVM) to call the const overload of this function, then\n    // cast away the constness from the result.\n    auto AR = const_cast<const InstrProfRecord *>(this)->getValueSitesForKind(\n        ValueKind);\n    return makeMutableArrayRef(\n        const_cast<InstrProfValueSiteRecord *>(AR.data()), AR.size());\n  }\n  ArrayRef<InstrProfValueSiteRecord>\n  getValueSitesForKind(uint32_t ValueKind) const {\n    if (!ValueData)\n      return None;\n    switch (ValueKind) {\n    case IPVK_IndirectCallTarget:\n      return ValueData->IndirectCallSites;\n    case IPVK_MemOPSize:\n      return ValueData->MemOPSizes;\n    default:\n      llvm_unreachable(\"Unknown value kind!\");\n    }\n  }\n\n  std::vector<InstrProfValueSiteRecord> &\n  getOrCreateValueSitesForKind(uint32_t ValueKind) {\n    if (!ValueData)\n      ValueData = std::make_unique<ValueProfData>();\n    switch (ValueKind) {\n    case IPVK_IndirectCallTarget:\n      return ValueData->IndirectCallSites;\n    case IPVK_MemOPSize:\n      return ValueData->MemOPSizes;\n    default:\n      llvm_unreachable(\"Unknown value kind!\");\n    }\n  }\n\n  // Map indirect call target name hash to name string.\n  uint64_t remapValue(uint64_t Value, uint32_t ValueKind,\n                      InstrProfSymtab *SymTab);\n\n  // Merge Value Profile data from Src record to this record for ValueKind.\n  // Scale merged value counts by \\p Weight.\n  void mergeValueProfData(uint32_t ValkeKind, InstrProfRecord &Src,\n                          uint64_t Weight,\n                          function_ref<void(instrprof_error)> Warn);\n\n  // Scale up value profile data count by N (Numerator) / D (Denominator).\n  void scaleValueProfData(uint32_t ValueKind, uint64_t N, uint64_t D,\n                          function_ref<void(instrprof_error)> Warn);\n};\n\nstruct NamedInstrProfRecord : InstrProfRecord {\n  StringRef Name;\n  uint64_t Hash;\n\n  // We reserve this bit as the flag for context sensitive profile record.\n  static const int CS_FLAG_IN_FUNC_HASH = 60;\n\n  NamedInstrProfRecord() = default;\n  NamedInstrProfRecord(StringRef Name, uint64_t Hash,\n                       std::vector<uint64_t> Counts)\n      : InstrProfRecord(std::move(Counts)), Name(Name), Hash(Hash) {}\n\n  static bool hasCSFlagInHash(uint64_t FuncHash) {\n    return ((FuncHash >> CS_FLAG_IN_FUNC_HASH) & 1);\n  }\n  static void setCSFlagInHash(uint64_t &FuncHash) {\n    FuncHash |= ((uint64_t)1 << CS_FLAG_IN_FUNC_HASH);\n  }\n};\n\nuint32_t InstrProfRecord::getNumValueKinds() const {\n  uint32_t NumValueKinds = 0;\n  for (uint32_t Kind = IPVK_First; Kind <= IPVK_Last; ++Kind)\n    NumValueKinds += !(getValueSitesForKind(Kind).empty());\n  return NumValueKinds;\n}\n\nuint32_t InstrProfRecord::getNumValueData(uint32_t ValueKind) const {\n  uint32_t N = 0;\n  for (auto &SR : getValueSitesForKind(ValueKind))\n    N += SR.ValueData.size();\n  return N;\n}\n\nuint32_t InstrProfRecord::getNumValueSites(uint32_t ValueKind) const {\n  return getValueSitesForKind(ValueKind).size();\n}\n\nuint32_t InstrProfRecord::getNumValueDataForSite(uint32_t ValueKind,\n                                                 uint32_t Site) const {\n  return getValueSitesForKind(ValueKind)[Site].ValueData.size();\n}\n\nstd::unique_ptr<InstrProfValueData[]>\nInstrProfRecord::getValueForSite(uint32_t ValueKind, uint32_t Site,\n                                 uint64_t *TotalC) const {\n  uint64_t Dummy = 0;\n  uint64_t &TotalCount = (TotalC == nullptr ? Dummy : *TotalC);\n  uint32_t N = getNumValueDataForSite(ValueKind, Site);\n  if (N == 0) {\n    TotalCount = 0;\n    return std::unique_ptr<InstrProfValueData[]>(nullptr);\n  }\n\n  auto VD = std::make_unique<InstrProfValueData[]>(N);\n  TotalCount = getValueForSite(VD.get(), ValueKind, Site);\n\n  return VD;\n}\n\nuint64_t InstrProfRecord::getValueForSite(InstrProfValueData Dest[],\n                                          uint32_t ValueKind,\n                                          uint32_t Site) const {\n  uint32_t I = 0;\n  uint64_t TotalCount = 0;\n  for (auto V : getValueSitesForKind(ValueKind)[Site].ValueData) {\n    Dest[I].Value = V.Value;\n    Dest[I].Count = V.Count;\n    TotalCount = SaturatingAdd(TotalCount, V.Count);\n    I++;\n  }\n  return TotalCount;\n}\n\nvoid InstrProfRecord::reserveSites(uint32_t ValueKind, uint32_t NumValueSites) {\n  if (!NumValueSites)\n    return;\n  getOrCreateValueSitesForKind(ValueKind).reserve(NumValueSites);\n}\n\ninline support::endianness getHostEndianness() {\n  return sys::IsLittleEndianHost ? support::little : support::big;\n}\n\n// Include definitions for value profile data\n#define INSTR_PROF_VALUE_PROF_DATA\n#include \"llvm/ProfileData/InstrProfData.inc\"\n\nvoid InstrProfValueSiteRecord::sortByCount() {\n  ValueData.sort(\n      [](const InstrProfValueData &left, const InstrProfValueData &right) {\n        return left.Count > right.Count;\n      });\n  // Now truncate\n  size_t max_s = INSTR_PROF_MAX_NUM_VAL_PER_SITE;\n  if (ValueData.size() > max_s)\n    ValueData.resize(max_s);\n}\n\nnamespace IndexedInstrProf {\n\nenum class HashT : uint32_t {\n  MD5,\n  Last = MD5\n};\n\ninline uint64_t ComputeHash(HashT Type, StringRef K) {\n  switch (Type) {\n  case HashT::MD5:\n    return MD5Hash(K);\n  }\n  llvm_unreachable(\"Unhandled hash type\");\n}\n\nconst uint64_t Magic = 0x8169666f72706cff; // \"\\xfflprofi\\x81\"\n\nenum ProfVersion {\n  // Version 1 is the first version. In this version, the value of\n  // a key/value pair can only include profile data of a single function.\n  // Due to this restriction, the number of block counters for a given\n  // function is not recorded but derived from the length of the value.\n  Version1 = 1,\n  // The version 2 format supports recording profile data of multiple\n  // functions which share the same key in one value field. To support this,\n  // the number block counters is recorded as an uint64_t field right after the\n  // function structural hash.\n  Version2 = 2,\n  // Version 3 supports value profile data. The value profile data is expected\n  // to follow the block counter profile data.\n  Version3 = 3,\n  // In this version, profile summary data \\c IndexedInstrProf::Summary is\n  // stored after the profile header.\n  Version4 = 4,\n  // In this version, the frontend PGO stable hash algorithm defaults to V2.\n  Version5 = 5,\n  // In this version, the frontend PGO stable hash algorithm got fixed and\n  // may produce hashes different from Version5.\n  Version6 = 6,\n  // An additional counter is added around logical operators.\n  Version7 = 7,\n  // The current version is 7.\n  CurrentVersion = INSTR_PROF_INDEX_VERSION\n};\nconst uint64_t Version = ProfVersion::CurrentVersion;\n\nconst HashT HashType = HashT::MD5;\n\ninline uint64_t ComputeHash(StringRef K) { return ComputeHash(HashType, K); }\n\n// This structure defines the file header of the LLVM profile\n// data file in indexed-format.\nstruct Header {\n  uint64_t Magic;\n  uint64_t Version;\n  uint64_t Unused; // Becomes unused since version 4\n  uint64_t HashType;\n  uint64_t HashOffset;\n};\n\n// Profile summary data recorded in the profile data file in indexed\n// format. It is introduced in version 4. The summary data follows\n// right after the profile file header.\nstruct Summary {\n  struct Entry {\n    uint64_t Cutoff; ///< The required percentile of total execution count.\n    uint64_t\n        MinBlockCount;  ///< The minimum execution count for this percentile.\n    uint64_t NumBlocks; ///< Number of blocks >= the minumum execution count.\n  };\n  // The field kind enumerator to assigned value mapping should remain\n  // unchanged  when a new kind is added or an old kind gets deleted in\n  // the future.\n  enum SummaryFieldKind {\n    /// The total number of functions instrumented.\n    TotalNumFunctions = 0,\n    /// Total number of instrumented blocks/edges.\n    TotalNumBlocks = 1,\n    /// The maximal execution count among all functions.\n    /// This field does not exist for profile data from IR based\n    /// instrumentation.\n    MaxFunctionCount = 2,\n    /// Max block count of the program.\n    MaxBlockCount = 3,\n    /// Max internal block count of the program (excluding entry blocks).\n    MaxInternalBlockCount = 4,\n    /// The sum of all instrumented block counts.\n    TotalBlockCount = 5,\n    NumKinds = TotalBlockCount + 1\n  };\n\n  // The number of summmary fields following the summary header.\n  uint64_t NumSummaryFields;\n  // The number of Cutoff Entries (Summary::Entry) following summary fields.\n  uint64_t NumCutoffEntries;\n\n  Summary() = delete;\n  Summary(uint32_t Size) { memset(this, 0, Size); }\n\n  void operator delete(void *ptr) { ::operator delete(ptr); }\n\n  static uint32_t getSize(uint32_t NumSumFields, uint32_t NumCutoffEntries) {\n    return sizeof(Summary) + NumCutoffEntries * sizeof(Entry) +\n           NumSumFields * sizeof(uint64_t);\n  }\n\n  const uint64_t *getSummaryDataBase() const {\n    return reinterpret_cast<const uint64_t *>(this + 1);\n  }\n\n  uint64_t *getSummaryDataBase() {\n    return reinterpret_cast<uint64_t *>(this + 1);\n  }\n\n  const Entry *getCutoffEntryBase() const {\n    return reinterpret_cast<const Entry *>(\n        &getSummaryDataBase()[NumSummaryFields]);\n  }\n\n  Entry *getCutoffEntryBase() {\n    return reinterpret_cast<Entry *>(&getSummaryDataBase()[NumSummaryFields]);\n  }\n\n  uint64_t get(SummaryFieldKind K) const {\n    return getSummaryDataBase()[K];\n  }\n\n  void set(SummaryFieldKind K, uint64_t V) {\n    getSummaryDataBase()[K] = V;\n  }\n\n  const Entry &getEntry(uint32_t I) const { return getCutoffEntryBase()[I]; }\n\n  void setEntry(uint32_t I, const ProfileSummaryEntry &E) {\n    Entry &ER = getCutoffEntryBase()[I];\n    ER.Cutoff = E.Cutoff;\n    ER.MinBlockCount = E.MinCount;\n    ER.NumBlocks = E.NumCounts;\n  }\n};\n\ninline std::unique_ptr<Summary> allocSummary(uint32_t TotalSize) {\n  return std::unique_ptr<Summary>(new (::operator new(TotalSize))\n                                      Summary(TotalSize));\n}\n\n} // end namespace IndexedInstrProf\n\nnamespace RawInstrProf {\n\n// Version 1: First version\n// Version 2: Added value profile data section. Per-function control data\n// struct has more fields to describe value profile information.\n// Version 3: Compressed name section support. Function PGO name reference\n// from control data struct is changed from raw pointer to Name's MD5 value.\n// Version 4: ValueDataBegin and ValueDataSizes fields are removed from the\n// raw header.\n// Version 5: Bit 60 of FuncHash is reserved for the flag for the context\n// sensitive records.\nconst uint64_t Version = INSTR_PROF_RAW_VERSION;\n\ntemplate <class IntPtrT> inline uint64_t getMagic();\ntemplate <> inline uint64_t getMagic<uint64_t>() {\n  return INSTR_PROF_RAW_MAGIC_64;\n}\n\ntemplate <> inline uint64_t getMagic<uint32_t>() {\n  return INSTR_PROF_RAW_MAGIC_32;\n}\n\n// Per-function profile data header/control structure.\n// The definition should match the structure defined in\n// compiler-rt/lib/profile/InstrProfiling.h.\n// It should also match the synthesized type in\n// Transforms/Instrumentation/InstrProfiling.cpp:getOrCreateRegionCounters.\ntemplate <class IntPtrT> struct alignas(8) ProfileData {\n  #define INSTR_PROF_DATA(Type, LLVMType, Name, Init) Type Name;\n  #include \"llvm/ProfileData/InstrProfData.inc\"\n};\n\n// File header structure of the LLVM profile data in raw format.\n// The definition should match the header referenced in\n// compiler-rt/lib/profile/InstrProfilingFile.c  and\n// InstrProfilingBuffer.c.\nstruct Header {\n#define INSTR_PROF_RAW_HEADER(Type, Name, Init) const Type Name;\n#include \"llvm/ProfileData/InstrProfData.inc\"\n};\n\n} // end namespace RawInstrProf\n\n// Parse MemOP Size range option.\nvoid getMemOPSizeRangeFromOption(StringRef Str, int64_t &RangeStart,\n                                 int64_t &RangeLast);\n\n// Create a COMDAT variable INSTR_PROF_RAW_VERSION_VAR to make the runtime\n// aware this is an ir_level profile so it can set the version flag.\nvoid createIRLevelProfileFlagVar(Module &M, bool IsCS,\n                                 bool InstrEntryBBEnabled);\n\n// Create the variable for the profile file name.\nvoid createProfileFileNameVar(Module &M, StringRef InstrProfileOutput);\n\n// Whether to compress function names in profile records, and filenames in\n// code coverage mappings. Used by the Instrumentation library and unit tests.\nextern cl::opt<bool> DoInstrProfNameCompression;\n\n} // end namespace llvm\n#endif // LLVM_PROFILEDATA_INSTRPROF_H\n"}, "76": {"id": 76, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h", "content": "//===- InstrProfReader.h - Instrumented profiling readers -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for reading profiling data for instrumentation\n// based PGO and coverage.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_PROFILEDATA_INSTRPROFREADER_H\n#define LLVM_PROFILEDATA_INSTRPROFREADER_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/ProfileSummary.h\"\n#include \"llvm/ProfileData/InstrProf.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/LineIterator.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/OnDiskHashTable.h\"\n#include \"llvm/Support/SwapByteOrder.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass InstrProfReader;\n\n/// A file format agnostic iterator over profiling data.\nclass InstrProfIterator : public std::iterator<std::input_iterator_tag,\n                                               NamedInstrProfRecord> {\n  InstrProfReader *Reader = nullptr;\n  value_type Record;\n\n  void Increment();\n\npublic:\n  InstrProfIterator() = default;\n  InstrProfIterator(InstrProfReader *Reader) : Reader(Reader) { Increment(); }\n\n  InstrProfIterator &operator++() { Increment(); return *this; }\n  bool operator==(const InstrProfIterator &RHS) const {\n    return Reader == RHS.Reader;\n  }\n  bool operator!=(const InstrProfIterator &RHS) const {\n    return Reader != RHS.Reader;\n  }\n  value_type &operator*() { return Record; }\n  value_type *operator->() { return &Record; }\n};\n\n/// Base class and interface for reading profiling data of any known instrprof\n/// format. Provides an iterator over NamedInstrProfRecords.\nclass InstrProfReader {\n  instrprof_error LastError = instrprof_error::success;\n\npublic:\n  InstrProfReader() = default;\n  virtual ~InstrProfReader() = default;\n\n  /// Read the header.  Required before reading first record.\n  virtual Error readHeader() = 0;\n\n  /// Read a single record.\n  virtual Error readNextRecord(NamedInstrProfRecord &Record) = 0;\n\n  /// Iterator over profile data.\n  InstrProfIterator begin() { return InstrProfIterator(this); }\n  InstrProfIterator end() { return InstrProfIterator(); }\n\n  virtual bool isIRLevelProfile() const = 0;\n\n  virtual bool hasCSIRLevelProfile() const = 0;\n\n  virtual bool instrEntryBBEnabled() const = 0;\n\n  /// Return the PGO symtab. There are three different readers:\n  /// Raw, Text, and Indexed profile readers. The first two types\n  /// of readers are used only by llvm-profdata tool, while the indexed\n  /// profile reader is also used by llvm-cov tool and the compiler (\n  /// backend or frontend). Since creating PGO symtab can create\n  /// significant runtime and memory overhead (as it touches data\n  /// for the whole program), InstrProfSymtab for the indexed profile\n  /// reader should be created on demand and it is recommended to be\n  /// only used for dumping purpose with llvm-proftool, not with the\n  /// compiler.\n  virtual InstrProfSymtab &getSymtab() = 0;\n\n  /// Compute the sum of counts and return in Sum.\n  void accumulateCounts(CountSumOrPercent &Sum, bool IsCS);\n\nprotected:\n  std::unique_ptr<InstrProfSymtab> Symtab;\n\n  /// Set the current error and return same.\n  Error error(instrprof_error Err) {\n    LastError = Err;\n    if (Err == instrprof_error::success)\n      return Error::success();\n    return make_error<InstrProfError>(Err);\n  }\n\n  Error error(Error &&E) { return error(InstrProfError::take(std::move(E))); }\n\n  /// Clear the current error and return a successful one.\n  Error success() { return error(instrprof_error::success); }\n\npublic:\n  /// Return true if the reader has finished reading the profile data.\n  bool isEOF() { return LastError == instrprof_error::eof; }\n\n  /// Return true if the reader encountered an error reading profiling data.\n  bool hasError() { return LastError != instrprof_error::success && !isEOF(); }\n\n  /// Get the current error.\n  Error getError() {\n    if (hasError())\n      return make_error<InstrProfError>(LastError);\n    return Error::success();\n  }\n\n  /// Factory method to create an appropriately typed reader for the given\n  /// instrprof file.\n  static Expected<std::unique_ptr<InstrProfReader>> create(const Twine &Path);\n\n  static Expected<std::unique_ptr<InstrProfReader>>\n  create(std::unique_ptr<MemoryBuffer> Buffer);\n};\n\n/// Reader for the simple text based instrprof format.\n///\n/// This format is a simple text format that's suitable for test data. Records\n/// are separated by one or more blank lines, and record fields are separated by\n/// new lines.\n///\n/// Each record consists of a function name, a function hash, a number of\n/// counters, and then each counter value, in that order.\nclass TextInstrProfReader : public InstrProfReader {\nprivate:\n  /// The profile data file contents.\n  std::unique_ptr<MemoryBuffer> DataBuffer;\n  /// Iterator over the profile data.\n  line_iterator Line;\n  bool IsIRLevelProfile = false;\n  bool HasCSIRLevelProfile = false;\n  bool InstrEntryBBEnabled = false;\n\n  Error readValueProfileData(InstrProfRecord &Record);\n\npublic:\n  TextInstrProfReader(std::unique_ptr<MemoryBuffer> DataBuffer_)\n      : DataBuffer(std::move(DataBuffer_)), Line(*DataBuffer, true, '#') {}\n  TextInstrProfReader(const TextInstrProfReader &) = delete;\n  TextInstrProfReader &operator=(const TextInstrProfReader &) = delete;\n\n  /// Return true if the given buffer is in text instrprof format.\n  static bool hasFormat(const MemoryBuffer &Buffer);\n\n  bool isIRLevelProfile() const override { return IsIRLevelProfile; }\n\n  bool hasCSIRLevelProfile() const override { return HasCSIRLevelProfile; }\n\n  bool instrEntryBBEnabled() const override { return InstrEntryBBEnabled; }\n\n  /// Read the header.\n  Error readHeader() override;\n\n  /// Read a single record.\n  Error readNextRecord(NamedInstrProfRecord &Record) override;\n\n  InstrProfSymtab &getSymtab() override {\n    assert(Symtab.get());\n    return *Symtab.get();\n  }\n};\n\n/// Reader for the raw instrprof binary format from runtime.\n///\n/// This format is a raw memory dump of the instrumentation-baed profiling data\n/// from the runtime.  It has no index.\n///\n/// Templated on the unsigned type whose size matches pointers on the platform\n/// that wrote the profile.\ntemplate <class IntPtrT>\nclass RawInstrProfReader : public InstrProfReader {\nprivate:\n  /// The profile data file contents.\n  std::unique_ptr<MemoryBuffer> DataBuffer;\n  bool ShouldSwapBytes;\n  // The value of the version field of the raw profile data header. The lower 56\n  // bits specifies the format version and the most significant 8 bits specify\n  // the variant types of the profile.\n  uint64_t Version;\n  uint64_t CountersDelta;\n  uint64_t NamesDelta;\n  const RawInstrProf::ProfileData<IntPtrT> *Data;\n  const RawInstrProf::ProfileData<IntPtrT> *DataEnd;\n  const uint64_t *CountersStart;\n  const char *NamesStart;\n  uint64_t NamesSize;\n  // After value profile is all read, this pointer points to\n  // the header of next profile data (if exists)\n  const uint8_t *ValueDataStart;\n  uint32_t ValueKindLast;\n  uint32_t CurValueDataSize;\n\npublic:\n  RawInstrProfReader(std::unique_ptr<MemoryBuffer> DataBuffer)\n      : DataBuffer(std::move(DataBuffer)) {}\n  RawInstrProfReader(const RawInstrProfReader &) = delete;\n  RawInstrProfReader &operator=(const RawInstrProfReader &) = delete;\n\n  static bool hasFormat(const MemoryBuffer &DataBuffer);\n  Error readHeader() override;\n  Error readNextRecord(NamedInstrProfRecord &Record) override;\n\n  bool isIRLevelProfile() const override {\n    return (Version & VARIANT_MASK_IR_PROF) != 0;\n  }\n\n  bool hasCSIRLevelProfile() const override {\n    return (Version & VARIANT_MASK_CSIR_PROF) != 0;\n  }\n\n  bool instrEntryBBEnabled() const override {\n    return (Version & VARIANT_MASK_INSTR_ENTRY) != 0;\n  }\n\n  InstrProfSymtab &getSymtab() override {\n    assert(Symtab.get());\n    return *Symtab.get();\n  }\n\nprivate:\n  Error createSymtab(InstrProfSymtab &Symtab);\n  Error readNextHeader(const char *CurrentPos);\n  Error readHeader(const RawInstrProf::Header &Header);\n\n  template <class IntT> IntT swap(IntT Int) const {\n    return ShouldSwapBytes ? sys::getSwappedBytes(Int) : Int;\n  }\n\n  support::endianness getDataEndianness() const {\n    support::endianness HostEndian = getHostEndianness();\n    if (!ShouldSwapBytes)\n      return HostEndian;\n    if (HostEndian == support::little)\n      return support::big;\n    else\n      return support::little;\n  }\n\n  inline uint8_t getNumPaddingBytes(uint64_t SizeInBytes) {\n    return 7 & (sizeof(uint64_t) - SizeInBytes % sizeof(uint64_t));\n  }\n\n  Error readName(NamedInstrProfRecord &Record);\n  Error readFuncHash(NamedInstrProfRecord &Record);\n  Error readRawCounts(InstrProfRecord &Record);\n  Error readValueProfilingData(InstrProfRecord &Record);\n  bool atEnd() const { return Data == DataEnd; }\n\n  void advanceData() {\n    Data++;\n    ValueDataStart += CurValueDataSize;\n  }\n\n  const char *getNextHeaderPos() const {\n      assert(atEnd());\n      return (const char *)ValueDataStart;\n  }\n\n  /// Get the offset of \\p CounterPtr from the start of the counters section of\n  /// the profile. The offset has units of \"number of counters\", i.e. increasing\n  /// the offset by 1 corresponds to an increase in the *byte offset* by 8.\n  ptrdiff_t getCounterOffset(IntPtrT CounterPtr) const {\n    return (swap(CounterPtr) - CountersDelta) / sizeof(uint64_t);\n  }\n\n  const uint64_t *getCounter(ptrdiff_t Offset) const {\n    return CountersStart + Offset;\n  }\n\n  StringRef getName(uint64_t NameRef) const {\n    return Symtab->getFuncName(swap(NameRef));\n  }\n};\n\nusing RawInstrProfReader32 = RawInstrProfReader<uint32_t>;\nusing RawInstrProfReader64 = RawInstrProfReader<uint64_t>;\n\nnamespace IndexedInstrProf {\n\nenum class HashT : uint32_t;\n\n} // end namespace IndexedInstrProf\n\n/// Trait for lookups into the on-disk hash table for the binary instrprof\n/// format.\nclass InstrProfLookupTrait {\n  std::vector<NamedInstrProfRecord> DataBuffer;\n  IndexedInstrProf::HashT HashType;\n  unsigned FormatVersion;\n  // Endianness of the input value profile data.\n  // It should be LE by default, but can be changed\n  // for testing purpose.\n  support::endianness ValueProfDataEndianness = support::little;\n\npublic:\n  InstrProfLookupTrait(IndexedInstrProf::HashT HashType, unsigned FormatVersion)\n      : HashType(HashType), FormatVersion(FormatVersion) {}\n\n  using data_type = ArrayRef<NamedInstrProfRecord>;\n\n  using internal_key_type = StringRef;\n  using external_key_type = StringRef;\n  using hash_value_type = uint64_t;\n  using offset_type = uint64_t;\n\n  static bool EqualKey(StringRef A, StringRef B) { return A == B; }\n  static StringRef GetInternalKey(StringRef K) { return K; }\n  static StringRef GetExternalKey(StringRef K) { return K; }\n\n  hash_value_type ComputeHash(StringRef K);\n\n  static std::pair<offset_type, offset_type>\n  ReadKeyDataLength(const unsigned char *&D) {\n    using namespace support;\n\n    offset_type KeyLen = endian::readNext<offset_type, little, unaligned>(D);\n    offset_type DataLen = endian::readNext<offset_type, little, unaligned>(D);\n    return std::make_pair(KeyLen, DataLen);\n  }\n\n  StringRef ReadKey(const unsigned char *D, offset_type N) {\n    return StringRef((const char *)D, N);\n  }\n\n  bool readValueProfilingData(const unsigned char *&D,\n                              const unsigned char *const End);\n  data_type ReadData(StringRef K, const unsigned char *D, offset_type N);\n\n  // Used for testing purpose only.\n  void setValueProfDataEndianness(support::endianness Endianness) {\n    ValueProfDataEndianness = Endianness;\n  }\n};\n\nstruct InstrProfReaderIndexBase {\n  virtual ~InstrProfReaderIndexBase() = default;\n\n  // Read all the profile records with the same key pointed to the current\n  // iterator.\n  virtual Error getRecords(ArrayRef<NamedInstrProfRecord> &Data) = 0;\n\n  // Read all the profile records with the key equal to FuncName\n  virtual Error getRecords(StringRef FuncName,\n                                     ArrayRef<NamedInstrProfRecord> &Data) = 0;\n  virtual void advanceToNextKey() = 0;\n  virtual bool atEnd() const = 0;\n  virtual void setValueProfDataEndianness(support::endianness Endianness) = 0;\n  virtual uint64_t getVersion() const = 0;\n  virtual bool isIRLevelProfile() const = 0;\n  virtual bool hasCSIRLevelProfile() const = 0;\n  virtual bool instrEntryBBEnabled() const = 0;\n  virtual Error populateSymtab(InstrProfSymtab &) = 0;\n};\n\nusing OnDiskHashTableImplV3 =\n    OnDiskIterableChainedHashTable<InstrProfLookupTrait>;\n\ntemplate <typename HashTableImpl>\nclass InstrProfReaderItaniumRemapper;\n\ntemplate <typename HashTableImpl>\nclass InstrProfReaderIndex : public InstrProfReaderIndexBase {\nprivate:\n  std::unique_ptr<HashTableImpl> HashTable;\n  typename HashTableImpl::data_iterator RecordIterator;\n  uint64_t FormatVersion;\n\n  friend class InstrProfReaderItaniumRemapper<HashTableImpl>;\n\npublic:\n  InstrProfReaderIndex(const unsigned char *Buckets,\n                       const unsigned char *const Payload,\n                       const unsigned char *const Base,\n                       IndexedInstrProf::HashT HashType, uint64_t Version);\n  ~InstrProfReaderIndex() override = default;\n\n  Error getRecords(ArrayRef<NamedInstrProfRecord> &Data) override;\n  Error getRecords(StringRef FuncName,\n                   ArrayRef<NamedInstrProfRecord> &Data) override;\n  void advanceToNextKey() override { RecordIterator++; }\n\n  bool atEnd() const override {\n    return RecordIterator == HashTable->data_end();\n  }\n\n  void setValueProfDataEndianness(support::endianness Endianness) override {\n    HashTable->getInfoObj().setValueProfDataEndianness(Endianness);\n  }\n\n  uint64_t getVersion() const override { return GET_VERSION(FormatVersion); }\n\n  bool isIRLevelProfile() const override {\n    return (FormatVersion & VARIANT_MASK_IR_PROF) != 0;\n  }\n\n  bool hasCSIRLevelProfile() const override {\n    return (FormatVersion & VARIANT_MASK_CSIR_PROF) != 0;\n  }\n\n  bool instrEntryBBEnabled() const override {\n    return (FormatVersion & VARIANT_MASK_INSTR_ENTRY) != 0;\n  }\n\n  Error populateSymtab(InstrProfSymtab &Symtab) override {\n    return Symtab.create(HashTable->keys());\n  }\n};\n\n/// Name matcher supporting fuzzy matching of symbol names to names in profiles.\nclass InstrProfReaderRemapper {\npublic:\n  virtual ~InstrProfReaderRemapper() {}\n  virtual Error populateRemappings() { return Error::success(); }\n  virtual Error getRecords(StringRef FuncName,\n                           ArrayRef<NamedInstrProfRecord> &Data) = 0;\n};\n\n/// Reader for the indexed binary instrprof format.\nclass IndexedInstrProfReader : public InstrProfReader {\nprivate:\n  /// The profile data file contents.\n  std::unique_ptr<MemoryBuffer> DataBuffer;\n  /// The profile remapping file contents.\n  std::unique_ptr<MemoryBuffer> RemappingBuffer;\n  /// The index into the profile data.\n  std::unique_ptr<InstrProfReaderIndexBase> Index;\n  /// The profile remapping file contents.\n  std::unique_ptr<InstrProfReaderRemapper> Remapper;\n  /// Profile summary data.\n  std::unique_ptr<ProfileSummary> Summary;\n  /// Context sensitive profile summary data.\n  std::unique_ptr<ProfileSummary> CS_Summary;\n  // Index to the current record in the record array.\n  unsigned RecordIndex;\n\n  // Read the profile summary. Return a pointer pointing to one byte past the\n  // end of the summary data if it exists or the input \\c Cur.\n  // \\c UseCS indicates whether to use the context-sensitive profile summary.\n  const unsigned char *readSummary(IndexedInstrProf::ProfVersion Version,\n                                   const unsigned char *Cur, bool UseCS);\n\npublic:\n  IndexedInstrProfReader(\n      std::unique_ptr<MemoryBuffer> DataBuffer,\n      std::unique_ptr<MemoryBuffer> RemappingBuffer = nullptr)\n      : DataBuffer(std::move(DataBuffer)),\n        RemappingBuffer(std::move(RemappingBuffer)), RecordIndex(0) {}\n  IndexedInstrProfReader(const IndexedInstrProfReader &) = delete;\n  IndexedInstrProfReader &operator=(const IndexedInstrProfReader &) = delete;\n\n  /// Return the profile version.\n  uint64_t getVersion() const { return Index->getVersion(); }\n  bool isIRLevelProfile() const override { return Index->isIRLevelProfile(); }\n  bool hasCSIRLevelProfile() const override {\n    return Index->hasCSIRLevelProfile();\n  }\n\n  bool instrEntryBBEnabled() const override {\n    return Index->instrEntryBBEnabled();\n  }\n\n  /// Return true if the given buffer is in an indexed instrprof format.\n  static bool hasFormat(const MemoryBuffer &DataBuffer);\n\n  /// Read the file header.\n  Error readHeader() override;\n  /// Read a single record.\n  Error readNextRecord(NamedInstrProfRecord &Record) override;\n\n  /// Return the NamedInstrProfRecord associated with FuncName and FuncHash\n  Expected<InstrProfRecord> getInstrProfRecord(StringRef FuncName,\n                                               uint64_t FuncHash);\n\n  /// Fill Counts with the profile data for the given function name.\n  Error getFunctionCounts(StringRef FuncName, uint64_t FuncHash,\n                          std::vector<uint64_t> &Counts);\n\n  /// Return the maximum of all known function counts.\n  /// \\c UseCS indicates whether to use the context-sensitive count.\n  uint64_t getMaximumFunctionCount(bool UseCS) {\n    if (UseCS) {\n      assert(CS_Summary && \"No context sensitive profile summary\");\n      return CS_Summary->getMaxFunctionCount();\n    } else {\n      assert(Summary && \"No profile summary\");\n      return Summary->getMaxFunctionCount();\n    }\n  }\n\n  /// Factory method to create an indexed reader.\n  static Expected<std::unique_ptr<IndexedInstrProfReader>>\n  create(const Twine &Path, const Twine &RemappingPath = \"\");\n\n  static Expected<std::unique_ptr<IndexedInstrProfReader>>\n  create(std::unique_ptr<MemoryBuffer> Buffer,\n         std::unique_ptr<MemoryBuffer> RemappingBuffer = nullptr);\n\n  // Used for testing purpose only.\n  void setValueProfDataEndianness(support::endianness Endianness) {\n    Index->setValueProfDataEndianness(Endianness);\n  }\n\n  // See description in the base class. This interface is designed\n  // to be used by llvm-profdata (for dumping). Avoid using this when\n  // the client is the compiler.\n  InstrProfSymtab &getSymtab() override;\n\n  /// Return the profile summary.\n  /// \\c UseCS indicates whether to use the context-sensitive summary.\n  ProfileSummary &getSummary(bool UseCS) {\n    if (UseCS) {\n      assert(CS_Summary && \"No context sensitive summary\");\n      return *(CS_Summary.get());\n    } else {\n      assert(Summary && \"No profile summary\");\n      return *(Summary.get());\n    }\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_PROFILEDATA_INSTRPROFREADER_H\n"}, "83": {"id": 83, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h", "content": "//===--- OnDiskHashTable.h - On-Disk Hash Table Implementation --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines facilities for reading and writing on-disk hash tables.\n///\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_SUPPORT_ONDISKHASHTABLE_H\n#define LLVM_SUPPORT_ONDISKHASHTABLE_H\n\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/EndianStream.h\"\n#include \"llvm/Support/Host.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cstdlib>\n\nnamespace llvm {\n\n/// Generates an on disk hash table.\n///\n/// This needs an \\c Info that handles storing values into the hash table's\n/// payload and computes the hash for a given key. This should provide the\n/// following interface:\n///\n/// \\code\n/// class ExampleInfo {\n/// public:\n///   typedef ExampleKey key_type;   // Must be copy constructible\n///   typedef ExampleKey &key_type_ref;\n///   typedef ExampleData data_type; // Must be copy constructible\n///   typedef ExampleData &data_type_ref;\n///   typedef uint32_t hash_value_type; // The type the hash function returns.\n///   typedef uint32_t offset_type; // The type for offsets into the table.\n///\n///   /// Calculate the hash for Key\n///   static hash_value_type ComputeHash(key_type_ref Key);\n///   /// Return the lengths, in bytes, of the given Key/Data pair.\n///   static std::pair<offset_type, offset_type>\n///   EmitKeyDataLength(raw_ostream &Out, key_type_ref Key, data_type_ref Data);\n///   /// Write Key to Out.  KeyLen is the length from EmitKeyDataLength.\n///   static void EmitKey(raw_ostream &Out, key_type_ref Key,\n///                       offset_type KeyLen);\n///   /// Write Data to Out.  DataLen is the length from EmitKeyDataLength.\n///   static void EmitData(raw_ostream &Out, key_type_ref Key,\n///                        data_type_ref Data, offset_type DataLen);\n///   /// Determine if two keys are equal. Optional, only needed by contains.\n///   static bool EqualKey(key_type_ref Key1, key_type_ref Key2);\n/// };\n/// \\endcode\ntemplate <typename Info> class OnDiskChainedHashTableGenerator {\n  /// A single item in the hash table.\n  class Item {\n  public:\n    typename Info::key_type Key;\n    typename Info::data_type Data;\n    Item *Next;\n    const typename Info::hash_value_type Hash;\n\n    Item(typename Info::key_type_ref Key, typename Info::data_type_ref Data,\n         Info &InfoObj)\n        : Key(Key), Data(Data), Next(nullptr), Hash(InfoObj.ComputeHash(Key)) {}\n  };\n\n  typedef typename Info::offset_type offset_type;\n  offset_type NumBuckets;\n  offset_type NumEntries;\n  llvm::SpecificBumpPtrAllocator<Item> BA;\n\n  /// A linked list of values in a particular hash bucket.\n  struct Bucket {\n    offset_type Off;\n    unsigned Length;\n    Item *Head;\n  };\n\n  Bucket *Buckets;\n\nprivate:\n  /// Insert an item into the appropriate hash bucket.\n  void insert(Bucket *Buckets, size_t Size, Item *E) {\n    Bucket &B = Buckets[E->Hash & (Size - 1)];\n    E->Next = B.Head;\n    ++B.Length;\n    B.Head = E;\n  }\n\n  /// Resize the hash table, moving the old entries into the new buckets.\n  void resize(size_t NewSize) {\n    Bucket *NewBuckets = static_cast<Bucket *>(\n        safe_calloc(NewSize, sizeof(Bucket)));\n    // Populate NewBuckets with the old entries.\n    for (size_t I = 0; I < NumBuckets; ++I)\n      for (Item *E = Buckets[I].Head; E;) {\n        Item *N = E->Next;\n        E->Next = nullptr;\n        insert(NewBuckets, NewSize, E);\n        E = N;\n      }\n\n    free(Buckets);\n    NumBuckets = NewSize;\n    Buckets = NewBuckets;\n  }\n\npublic:\n  /// Insert an entry into the table.\n  void insert(typename Info::key_type_ref Key,\n              typename Info::data_type_ref Data) {\n    Info InfoObj;\n    insert(Key, Data, InfoObj);\n  }\n\n  /// Insert an entry into the table.\n  ///\n  /// Uses the provided Info instead of a stack allocated one.\n  void insert(typename Info::key_type_ref Key,\n              typename Info::data_type_ref Data, Info &InfoObj) {\n    ++NumEntries;\n    if (4 * NumEntries >= 3 * NumBuckets)\n      resize(NumBuckets * 2);\n    insert(Buckets, NumBuckets, new (BA.Allocate()) Item(Key, Data, InfoObj));\n  }\n\n  /// Determine whether an entry has been inserted.\n  bool contains(typename Info::key_type_ref Key, Info &InfoObj) {\n    unsigned Hash = InfoObj.ComputeHash(Key);\n    for (Item *I = Buckets[Hash & (NumBuckets - 1)].Head; I; I = I->Next)\n      if (I->Hash == Hash && InfoObj.EqualKey(I->Key, Key))\n        return true;\n    return false;\n  }\n\n  /// Emit the table to Out, which must not be at offset 0.\n  offset_type Emit(raw_ostream &Out) {\n    Info InfoObj;\n    return Emit(Out, InfoObj);\n  }\n\n  /// Emit the table to Out, which must not be at offset 0.\n  ///\n  /// Uses the provided Info instead of a stack allocated one.\n  offset_type Emit(raw_ostream &Out, Info &InfoObj) {\n    using namespace llvm::support;\n    endian::Writer LE(Out, little);\n\n    // Now we're done adding entries, resize the bucket list if it's\n    // significantly too large. (This only happens if the number of\n    // entries is small and we're within our initial allocation of\n    // 64 buckets.) We aim for an occupancy ratio in [3/8, 3/4).\n    //\n    // As a special case, if there are two or fewer entries, just\n    // form a single bucket. A linear scan is fine in that case, and\n    // this is very common in C++ class lookup tables. This also\n    // guarantees we produce at least one bucket for an empty table.\n    //\n    // FIXME: Try computing a perfect hash function at this point.\n    unsigned TargetNumBuckets =\n        NumEntries <= 2 ? 1 : NextPowerOf2(NumEntries * 4 / 3);\n    if (TargetNumBuckets != NumBuckets)\n      resize(TargetNumBuckets);\n\n    // Emit the payload of the table.\n    for (offset_type I = 0; I < NumBuckets; ++I) {\n      Bucket &B = Buckets[I];\n      if (!B.Head)\n        continue;\n\n      // Store the offset for the data of this bucket.\n      B.Off = Out.tell();\n      assert(B.Off && \"Cannot write a bucket at offset 0. Please add padding.\");\n\n      // Write out the number of items in the bucket.\n      LE.write<uint16_t>(B.Length);\n      assert(B.Length != 0 && \"Bucket has a head but zero length?\");\n\n      // Write out the entries in the bucket.\n      for (Item *I = B.Head; I; I = I->Next) {\n        LE.write<typename Info::hash_value_type>(I->Hash);\n        const std::pair<offset_type, offset_type> &Len =\n            InfoObj.EmitKeyDataLength(Out, I->Key, I->Data);\n#ifdef NDEBUG\n        InfoObj.EmitKey(Out, I->Key, Len.first);\n        InfoObj.EmitData(Out, I->Key, I->Data, Len.second);\n#else\n        // In asserts mode, check that the users length matches the data they\n        // wrote.\n        uint64_t KeyStart = Out.tell();\n        InfoObj.EmitKey(Out, I->Key, Len.first);\n        uint64_t DataStart = Out.tell();\n        InfoObj.EmitData(Out, I->Key, I->Data, Len.second);\n        uint64_t End = Out.tell();\n        assert(offset_type(DataStart - KeyStart) == Len.first &&\n               \"key length does not match bytes written\");\n        assert(offset_type(End - DataStart) == Len.second &&\n               \"data length does not match bytes written\");\n#endif\n      }\n    }\n\n    // Pad with zeros so that we can start the hashtable at an aligned address.\n    offset_type TableOff = Out.tell();\n    uint64_t N = offsetToAlignment(TableOff, Align(alignof(offset_type)));\n    TableOff += N;\n    while (N--)\n      LE.write<uint8_t>(0);\n\n    // Emit the hashtable itself.\n    LE.write<offset_type>(NumBuckets);\n    LE.write<offset_type>(NumEntries);\n    for (offset_type I = 0; I < NumBuckets; ++I)\n      LE.write<offset_type>(Buckets[I].Off);\n\n    return TableOff;\n  }\n\n  OnDiskChainedHashTableGenerator() {\n    NumEntries = 0;\n    NumBuckets = 64;\n    // Note that we do not need to run the constructors of the individual\n    // Bucket objects since 'calloc' returns bytes that are all 0.\n    Buckets = static_cast<Bucket *>(safe_calloc(NumBuckets, sizeof(Bucket)));\n  }\n\n  ~OnDiskChainedHashTableGenerator() { std::free(Buckets); }\n};\n\n/// Provides lookup on an on disk hash table.\n///\n/// This needs an \\c Info that handles reading values from the hash table's\n/// payload and computes the hash for a given key. This should provide the\n/// following interface:\n///\n/// \\code\n/// class ExampleLookupInfo {\n/// public:\n///   typedef ExampleData data_type;\n///   typedef ExampleInternalKey internal_key_type; // The stored key type.\n///   typedef ExampleKey external_key_type; // The type to pass to find().\n///   typedef uint32_t hash_value_type; // The type the hash function returns.\n///   typedef uint32_t offset_type; // The type for offsets into the table.\n///\n///   /// Compare two keys for equality.\n///   static bool EqualKey(internal_key_type &Key1, internal_key_type &Key2);\n///   /// Calculate the hash for the given key.\n///   static hash_value_type ComputeHash(internal_key_type &IKey);\n///   /// Translate from the semantic type of a key in the hash table to the\n///   /// type that is actually stored and used for hashing and comparisons.\n///   /// The internal and external types are often the same, in which case this\n///   /// can simply return the passed in value.\n///   static const internal_key_type &GetInternalKey(external_key_type &EKey);\n///   /// Read the key and data length from Buffer, leaving it pointing at the\n///   /// following byte.\n///   static std::pair<offset_type, offset_type>\n///   ReadKeyDataLength(const unsigned char *&Buffer);\n///   /// Read the key from Buffer, given the KeyLen as reported from\n///   /// ReadKeyDataLength.\n///   const internal_key_type &ReadKey(const unsigned char *Buffer,\n///                                    offset_type KeyLen);\n///   /// Read the data for Key from Buffer, given the DataLen as reported from\n///   /// ReadKeyDataLength.\n///   data_type ReadData(StringRef Key, const unsigned char *Buffer,\n///                      offset_type DataLen);\n/// };\n/// \\endcode\ntemplate <typename Info> class OnDiskChainedHashTable {\n  const typename Info::offset_type NumBuckets;\n  const typename Info::offset_type NumEntries;\n  const unsigned char *const Buckets;\n  const unsigned char *const Base;\n  Info InfoObj;\n\npublic:\n  typedef Info InfoType;\n  typedef typename Info::internal_key_type internal_key_type;\n  typedef typename Info::external_key_type external_key_type;\n  typedef typename Info::data_type data_type;\n  typedef typename Info::hash_value_type hash_value_type;\n  typedef typename Info::offset_type offset_type;\n\n  OnDiskChainedHashTable(offset_type NumBuckets, offset_type NumEntries,\n                         const unsigned char *Buckets,\n                         const unsigned char *Base,\n                         const Info &InfoObj = Info())\n      : NumBuckets(NumBuckets), NumEntries(NumEntries), Buckets(Buckets),\n        Base(Base), InfoObj(InfoObj) {\n    assert((reinterpret_cast<uintptr_t>(Buckets) & 0x3) == 0 &&\n           \"'buckets' must have a 4-byte alignment\");\n  }\n\n  /// Read the number of buckets and the number of entries from a hash table\n  /// produced by OnDiskHashTableGenerator::Emit, and advance the Buckets\n  /// pointer past them.\n  static std::pair<offset_type, offset_type>\n  readNumBucketsAndEntries(const unsigned char *&Buckets) {\n    assert((reinterpret_cast<uintptr_t>(Buckets) & 0x3) == 0 &&\n           \"buckets should be 4-byte aligned.\");\n    using namespace llvm::support;\n    offset_type NumBuckets =\n        endian::readNext<offset_type, little, aligned>(Buckets);\n    offset_type NumEntries =\n        endian::readNext<offset_type, little, aligned>(Buckets);\n    return std::make_pair(NumBuckets, NumEntries);\n  }\n\n  offset_type getNumBuckets() const { return NumBuckets; }\n  offset_type getNumEntries() const { return NumEntries; }\n  const unsigned char *getBase() const { return Base; }\n  const unsigned char *getBuckets() const { return Buckets; }\n\n  bool isEmpty() const { return NumEntries == 0; }\n\n  class iterator {\n    internal_key_type Key;\n    const unsigned char *const Data;\n    const offset_type Len;\n    Info *InfoObj;\n\n  public:\n    iterator() : Key(), Data(nullptr), Len(0), InfoObj(nullptr) {}\n    iterator(const internal_key_type K, const unsigned char *D, offset_type L,\n             Info *InfoObj)\n        : Key(K), Data(D), Len(L), InfoObj(InfoObj) {}\n\n    data_type operator*() const { return InfoObj->ReadData(Key, Data, Len); }\n\n    const unsigned char *getDataPtr() const { return Data; }\n    offset_type getDataLen() const { return Len; }\n\n    bool operator==(const iterator &X) const { return X.Data == Data; }\n    bool operator!=(const iterator &X) const { return X.Data != Data; }\n  };\n\n  /// Look up the stored data for a particular key.\n  iterator find(const external_key_type &EKey, Info *InfoPtr = nullptr) {\n    const internal_key_type &IKey = InfoObj.GetInternalKey(EKey);\n    hash_value_type KeyHash = InfoObj.ComputeHash(IKey);\n    return find_hashed(IKey, KeyHash, InfoPtr);\n  }\n\n  /// Look up the stored data for a particular key with a known hash.\n  iterator find_hashed(const internal_key_type &IKey, hash_value_type KeyHash,\n                       Info *InfoPtr = nullptr) {\n    using namespace llvm::support;\n\n    if (!InfoPtr)\n      InfoPtr = &InfoObj;\n\n    // Each bucket is just an offset into the hash table file.\n    offset_type Idx = KeyHash & (NumBuckets - 1);\n    const unsigned char *Bucket = Buckets + sizeof(offset_type) * Idx;\n\n    offset_type Offset = endian::readNext<offset_type, little, aligned>(Bucket);\n    if (Offset == 0)\n      return iterator(); // Empty bucket.\n    const unsigned char *Items = Base + Offset;\n\n    // 'Items' starts with a 16-bit unsigned integer representing the\n    // number of items in this bucket.\n    unsigned Len = endian::readNext<uint16_t, little, unaligned>(Items);\n\n    for (unsigned i = 0; i < Len; ++i) {\n      // Read the hash.\n      hash_value_type ItemHash =\n          endian::readNext<hash_value_type, little, unaligned>(Items);\n\n      // Determine the length of the key and the data.\n      const std::pair<offset_type, offset_type> &L =\n          Info::ReadKeyDataLength(Items);\n      offset_type ItemLen = L.first + L.second;\n\n      // Compare the hashes.  If they are not the same, skip the entry entirely.\n      if (ItemHash != KeyHash) {\n        Items += ItemLen;\n        continue;\n      }\n\n      // Read the key.\n      const internal_key_type &X =\n          InfoPtr->ReadKey((const unsigned char *const)Items, L.first);\n\n      // If the key doesn't match just skip reading the value.\n      if (!InfoPtr->EqualKey(X, IKey)) {\n        Items += ItemLen;\n        continue;\n      }\n\n      // The key matches!\n      return iterator(X, Items + L.first, L.second, InfoPtr);\n    }\n\n    return iterator();\n  }\n\n  iterator end() const { return iterator(); }\n\n  Info &getInfoObj() { return InfoObj; }\n\n  /// Create the hash table.\n  ///\n  /// \\param Buckets is the beginning of the hash table itself, which follows\n  /// the payload of entire structure. This is the value returned by\n  /// OnDiskHashTableGenerator::Emit.\n  ///\n  /// \\param Base is the point from which all offsets into the structure are\n  /// based. This is offset 0 in the stream that was used when Emitting the\n  /// table.\n  static OnDiskChainedHashTable *Create(const unsigned char *Buckets,\n                                        const unsigned char *const Base,\n                                        const Info &InfoObj = Info()) {\n    assert(Buckets > Base);\n    auto NumBucketsAndEntries = readNumBucketsAndEntries(Buckets);\n    return new OnDiskChainedHashTable<Info>(NumBucketsAndEntries.first,\n                                            NumBucketsAndEntries.second,\n                                            Buckets, Base, InfoObj);\n  }\n};\n\n/// Provides lookup and iteration over an on disk hash table.\n///\n/// \\copydetails llvm::OnDiskChainedHashTable\ntemplate <typename Info>\nclass OnDiskIterableChainedHashTable : public OnDiskChainedHashTable<Info> {\n  const unsigned char *Payload;\n\npublic:\n  typedef OnDiskChainedHashTable<Info>          base_type;\n  typedef typename base_type::internal_key_type internal_key_type;\n  typedef typename base_type::external_key_type external_key_type;\n  typedef typename base_type::data_type         data_type;\n  typedef typename base_type::hash_value_type   hash_value_type;\n  typedef typename base_type::offset_type       offset_type;\n\nprivate:\n  /// Iterates over all of the keys in the table.\n  class iterator_base {\n    const unsigned char *Ptr;\n    offset_type NumItemsInBucketLeft;\n    offset_type NumEntriesLeft;\n\n  public:\n    typedef external_key_type value_type;\n\n    iterator_base(const unsigned char *const Ptr, offset_type NumEntries)\n        : Ptr(Ptr), NumItemsInBucketLeft(0), NumEntriesLeft(NumEntries) {}\n    iterator_base()\n        : Ptr(nullptr), NumItemsInBucketLeft(0), NumEntriesLeft(0) {}\n\n    friend bool operator==(const iterator_base &X, const iterator_base &Y) {\n      return X.NumEntriesLeft == Y.NumEntriesLeft;\n    }\n    friend bool operator!=(const iterator_base &X, const iterator_base &Y) {\n      return X.NumEntriesLeft != Y.NumEntriesLeft;\n    }\n\n    /// Move to the next item.\n    void advance() {\n      using namespace llvm::support;\n      if (!NumItemsInBucketLeft) {\n        // 'Items' starts with a 16-bit unsigned integer representing the\n        // number of items in this bucket.\n        NumItemsInBucketLeft =\n            endian::readNext<uint16_t, little, unaligned>(Ptr);\n      }\n      Ptr += sizeof(hash_value_type); // Skip the hash.\n      // Determine the length of the key and the data.\n      const std::pair<offset_type, offset_type> &L =\n          Info::ReadKeyDataLength(Ptr);\n      Ptr += L.first + L.second;\n      assert(NumItemsInBucketLeft);\n      --NumItemsInBucketLeft;\n      assert(NumEntriesLeft);\n      --NumEntriesLeft;\n    }\n\n    /// Get the start of the item as written by the trait (after the hash and\n    /// immediately before the key and value length).\n    const unsigned char *getItem() const {\n      return Ptr + (NumItemsInBucketLeft ? 0 : 2) + sizeof(hash_value_type);\n    }\n  };\n\npublic:\n  OnDiskIterableChainedHashTable(offset_type NumBuckets, offset_type NumEntries,\n                                 const unsigned char *Buckets,\n                                 const unsigned char *Payload,\n                                 const unsigned char *Base,\n                                 const Info &InfoObj = Info())\n      : base_type(NumBuckets, NumEntries, Buckets, Base, InfoObj),\n        Payload(Payload) {}\n\n  /// Iterates over all of the keys in the table.\n  class key_iterator : public iterator_base {\n    Info *InfoObj;\n\n  public:\n    typedef external_key_type value_type;\n\n    key_iterator(const unsigned char *const Ptr, offset_type NumEntries,\n                 Info *InfoObj)\n        : iterator_base(Ptr, NumEntries), InfoObj(InfoObj) {}\n    key_iterator() : iterator_base(), InfoObj() {}\n\n    key_iterator &operator++() {\n      this->advance();\n      return *this;\n    }\n    key_iterator operator++(int) { // Postincrement\n      key_iterator tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    internal_key_type getInternalKey() const {\n      auto *LocalPtr = this->getItem();\n\n      // Determine the length of the key and the data.\n      auto L = Info::ReadKeyDataLength(LocalPtr);\n\n      // Read the key.\n      return InfoObj->ReadKey(LocalPtr, L.first);\n    }\n\n    value_type operator*() const {\n      return InfoObj->GetExternalKey(getInternalKey());\n    }\n  };\n\n  key_iterator key_begin() {\n    return key_iterator(Payload, this->getNumEntries(), &this->getInfoObj());\n  }\n  key_iterator key_end() { return key_iterator(); }\n\n  iterator_range<key_iterator> keys() {\n    return make_range(key_begin(), key_end());\n  }\n\n  /// Iterates over all the entries in the table, returning the data.\n  class data_iterator : public iterator_base {\n    Info *InfoObj;\n\n  public:\n    typedef data_type value_type;\n\n    data_iterator(const unsigned char *const Ptr, offset_type NumEntries,\n                  Info *InfoObj)\n        : iterator_base(Ptr, NumEntries), InfoObj(InfoObj) {}\n    data_iterator() : iterator_base(), InfoObj() {}\n\n    data_iterator &operator++() { // Preincrement\n      this->advance();\n      return *this;\n    }\n    data_iterator operator++(int) { // Postincrement\n      data_iterator tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    value_type operator*() const {\n      auto *LocalPtr = this->getItem();\n\n      // Determine the length of the key and the data.\n      auto L = Info::ReadKeyDataLength(LocalPtr);\n\n      // Read the key.\n      const internal_key_type &Key = InfoObj->ReadKey(LocalPtr, L.first);\n      return InfoObj->ReadData(Key, LocalPtr + L.first, L.second);\n    }\n  };\n\n  data_iterator data_begin() {\n    return data_iterator(Payload, this->getNumEntries(), &this->getInfoObj());\n  }\n  data_iterator data_end() { return data_iterator(); }\n\n  iterator_range<data_iterator> data() {\n    return make_range(data_begin(), data_end());\n  }\n\n  /// Create the hash table.\n  ///\n  /// \\param Buckets is the beginning of the hash table itself, which follows\n  /// the payload of entire structure. This is the value returned by\n  /// OnDiskHashTableGenerator::Emit.\n  ///\n  /// \\param Payload is the beginning of the data contained in the table.  This\n  /// is Base plus any padding or header data that was stored, ie, the offset\n  /// that the stream was at when calling Emit.\n  ///\n  /// \\param Base is the point from which all offsets into the structure are\n  /// based. This is offset 0 in the stream that was used when Emitting the\n  /// table.\n  static OnDiskIterableChainedHashTable *\n  Create(const unsigned char *Buckets, const unsigned char *const Payload,\n         const unsigned char *const Base, const Info &InfoObj = Info()) {\n    assert(Buckets > Base);\n    auto NumBucketsAndEntries =\n        OnDiskIterableChainedHashTable<Info>::readNumBucketsAndEntries(Buckets);\n    return new OnDiskIterableChainedHashTable<Info>(\n        NumBucketsAndEntries.first, NumBucketsAndEntries.second,\n        Buckets, Payload, Base, InfoObj);\n  }\n};\n\n} // end namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 3, "line": 21}, "message": "'clang/AST/DeclNodes.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTFwd.h", "reportHash": "33a05be8d240acdf8a352c94adf7b2fd", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 12, "file": 5, "line": 178}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 5, "line": 178}, "message": "default constructor 'CXXBasePaths' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CXXInheritance.h", "reportHash": "dc09510d28b5fa2dd0a9092d896a4d4a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 226}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 5, "line": 226}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CXXInheritance.h", "reportHash": "5cded5454373332b43ee22105c156c27", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 524}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 524}, "message": "default constructor 'MethodVFTableLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/VTableBuilder.h", "reportHash": "3276d916736119171553fe7bc9196862", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 29, "line": 153}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 29, "line": 153}, "message": "default constructor 'OpenCLOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/OpenCLOptions.h", "reportHash": "546b85f37e22c6f272a0f2a72556fb10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 137}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 137}, "message": "default constructor 'TargetCXXABI' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/TargetCXXABI.h", "reportHash": "823e131d8dd5bec294bacf3007622f50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 128}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 128}, "message": "default constructor 'ABIArgInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h", "reportHash": "265e298717c27da94a4c47009f157643", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 594}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 594}, "message": "default constructor 'CGFunctionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h", "reportHash": "2fdebf0a5a5fd6f46dfa7a784f73f251", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 34, "line": 216}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 34, "line": 216}, "message": "default constructor 'PreprocessorOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h", "reportHash": "b11f4407ce293527e4361fc38309e4d8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 35, "line": 52}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 35, "line": 52}, "message": "default constructor 'CGCalleeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGCall.h", "reportHash": "30feda6ea9035030270806810c98eb7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 108}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 108}, "message": "default constructor 'CGCallee' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGCall.h", "reportHash": "6c990d585dc5dd9c6b7b22b2ab5f15b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 266}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 266}, "message": "default constructor 'CallArgList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGCall.h", "reportHash": "af449508359bbd1a648b1a30a94b21b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 280}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 35, "line": 280}, "message": "default constructor 'CallArgCleanup' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGCall.h", "reportHash": "a1e72592dfc3be7e2cc317da59f791c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 35, "line": 371}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 35, "line": 371}, "message": "default constructor 'ReturnValueSlot' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGCall.h", "reportHash": "328451f64688866c0206de6044be4d61", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 36, "line": 753}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 36, "line": 753}, "message": "move constructor 'ApplyDebugLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGDebugInfo.h", "reportHash": "63dd40a7b46793fb9163ddff17f33c12", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 37, "line": 37}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 37, "line": 37}, "message": "default constructor 'LoopAttributes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGLoopInfo.h", "reportHash": "06d12b8e25b2770b9ce01001d39b15af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 37, "line": 202}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 37, "line": 202}, "message": "default constructor 'LoopInfoStack' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGLoopInfo.h", "reportHash": "26df3e1396af4e6ae51c9ae43cdea04f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 38, "line": 62}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 38, "line": 62}, "message": "default constructor 'PrePostActionTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "3d5512f68d69fb69e695ea969a8a79df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 38, "line": 75}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 38, "line": 75}, "message": "default constructor 'RegionCodeGenTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "5f58b752afed2d9e0e01e9c8b43efa09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 522}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 38, "line": 522}, "message": "default constructor 'OffloadEntryInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "97e4246a34dd50a0bd0ff389f3ccef91", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 583}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 38, "line": 583}, "message": "default constructor 'OffloadEntryInfoTargetRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "72d95c9fc49321319eabf5af28e32033", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 38, "line": 644}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 38, "line": 644}, "message": "default constructor 'OffloadEntryInfoDeviceGlobalVar' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "dc1c8e53424d0d6c6ff876a98fd98e06", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 38, "line": 1662}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 38, "line": 1662}, "message": "default constructor 'TargetDataInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "0415235234c43e4f8fe381ce9fbc8287", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 39, "line": 449}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 39, "line": 449}, "message": "default constructor 'MappedVarData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h", "reportHash": "c90a19d7ce564e7ce47a1ca70555c0cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 40, "line": 244}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 40, "line": 244}, "message": "default constructor 'JumpDest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "0c7bb9adbe57b029b695bcc8dc8d81d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 40, "line": 333}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 40, "line": 333}, "message": "default constructor 'CGCoroInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "32f237a408c09978c480610def62febd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 40, "line": 378}, "message": "mark 'noexcept'"}, {"location": {"col": 14, "file": 40, "line": 378}, "message": "default constructor 'CGCapturedStmtInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "7f94125fe5b3d3899ae9a26a25863bf6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 40, "line": 463}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 40, "line": 463}, "message": "default constructor 'AbstractCallee' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "3b2686699a94bbf507a3eafbd4a9a548", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 40, "line": 1187}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 40, "line": 1187}, "message": "default constructor 'PeepholeProtection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "7714c3d707904ee3ef2a30f07537b5ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 40, "line": 1205}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 40, "line": 1205}, "message": "default constructor 'OpaqueValueMappingData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "2b01d63db3fc8e0b6c25d78b4e048aa1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 40, "line": 1393}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 40, "line": 1393}, "message": "default constructor 'OpenMPCancelExitStack' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "dc2b03d17c73c6d12d64892c618a5139", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 40, "line": 1675}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 40, "line": 1675}, "message": "default constructor 'OMPBuilderCBHelpers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "9dc7242a133f7f9b94bb328dfa858177", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 40, "line": 3848}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 40, "line": 3848}, "message": "default constructor 'ConstantEmission' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "ba742a98bc70f37355388e2c030ee44f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 41, "line": 123}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 41, "line": 123}, "message": "default constructor 'ObjCEntrypoints' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "7b6a5255293d41606355815cf082f7d7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 41, "line": 227}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 41, "line": 227}, "message": "default constructor 'InstrProfStats' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "4e8b4ea7a7cd65a45cbd28ff83d39d04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 41, "line": 290}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 41, "line": 290}, "message": "default constructor 'Structor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "3c865c763eb1ee57b4af574b1573c721", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 42, "line": 111}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 42, "line": 111}, "message": "default constructor 'stable_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/EHScopeStack.h", "reportHash": "9187a0c92c20c9a39a8a60b80fd4f966", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 42, "line": 150}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 42, "line": 150}, "message": "move constructor 'Cleanup' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/EHScopeStack.h", "reportHash": "608ccafe6e634abff9fd742b6aa84faf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 164}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 42, "line": 164}, "message": "default constructor 'Flags' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/EHScopeStack.h", "reportHash": "8e17b4733cee293f95151b65dd987714", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 42, "line": 211}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 42, "line": 211}, "message": "default constructor 'ConditionalCleanup<T, As...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/EHScopeStack.h", "reportHash": "fff2e03acd77c1105f6016869ca676b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 42, "line": 264}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 42, "line": 264}, "message": "default constructor 'EHScopeStack' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/EHScopeStack.h", "reportHash": "7f81e0058e490fc5e927bc884033f457", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 75, "line": 599}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 75, "line": 599}, "message": "default constructor 'CountSumOrPercent' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h", "reportHash": "6feac548f80e7aee8d32c4b4a3fbcd53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 75, "line": 626}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 75, "line": 626}, "message": "default constructor 'OverlapStats' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h", "reportHash": "fd0a5b38f6633c621abe7cf8e06b647c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 75, "line": 661}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 75, "line": 661}, "message": "default constructor 'InstrProfValueSiteRecord' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h", "reportHash": "3e1a93d18e9aa850124383e6b231b77a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 75, "line": 1041}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 75, "line": 1041}, "message": "default constructor 'Summary' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h", "reportHash": "2310eb64d7fa6b765c798415bfb22e19", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 76, "line": 250}, "message": "mark 'noexcept'"}, {"location": {"col": 30, "file": 76, "line": 250}, "message": "swap function 'swap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h", "reportHash": "709beaf96320808ab0cc4d7b46fe1c8d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 76, "line": 400}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 76, "line": 400}, "message": "destructor '~InstrProfReaderIndex<HashTableImpl>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h", "reportHash": "f339a6f0ffea4579e543dc688cdf022a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 83, "line": 225}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 83, "line": 225}, "message": "default constructor 'OnDiskChainedHashTableGenerator<Info>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h", "reportHash": "72efe2d17716f97b185d6366b1fbc973", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 83, "line": 233}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 83, "line": 233}, "message": "destructor '~OnDiskChainedHashTableGenerator<Info>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h", "reportHash": "88f0cd7da213d749b97d21bcee6139f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 83, "line": 328}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 83, "line": 328}, "message": "default constructor 'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h", "reportHash": "74633b8b6adada3fef2854c3bdc10211", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 83, "line": 454}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 83, "line": 454}, "message": "default constructor 'iterator_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h", "reportHash": "60c0f1bd652bfa565d9bf39ae29cf423", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 83, "line": 510}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 83, "line": 510}, "message": "default constructor 'key_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h", "reportHash": "6892b031a9c69256d9447750ce2ae894", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 83, "line": 556}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 83, "line": 556}, "message": "default constructor 'data_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h", "reportHash": "27c740965b13c48376ca7617bdd8179f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
