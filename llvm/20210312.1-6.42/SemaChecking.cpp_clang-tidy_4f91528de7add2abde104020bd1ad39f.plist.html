<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaChecking.cpp", "content": "//===- SemaChecking.cpp - Extra Semantic Checking -------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements extra semantic analysis beyond what is enforced\n//  by the C type system.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/EvaluatedExprVisitor.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/FormatString.h\"\n#include \"clang/AST/NSAPI.h\"\n#include \"clang/AST/NonTrivialTypeVisitor.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/SyncScope.h\"\n#include \"clang/Basic/TargetBuiltins.h\"\n#include \"clang/Basic/TargetCXXABI.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"clang/Lex/Lexer.h\" // TODO: Extract static functions to fix layering.\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ConvertUTF.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/Locale.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <functional>\n#include <limits>\n#include <string>\n#include <tuple>\n#include <utility>\n\nusing namespace clang;\nusing namespace sema;\n\nSourceLocation Sema::getLocationOfStringLiteralByte(const StringLiteral *SL,\n                                                    unsigned ByteNo) const {\n  return SL->getLocationOfByte(ByteNo, getSourceManager(), LangOpts,\n                               Context.getTargetInfo());\n}\n\n/// Checks that a call expression's argument count is the desired number.\n/// This is useful when doing custom type-checking.  Returns true on error.\nstatic bool checkArgCount(Sema &S, CallExpr *call, unsigned desiredArgCount) {\n  unsigned argCount = call->getNumArgs();\n  if (argCount == desiredArgCount) return false;\n\n  if (argCount < desiredArgCount)\n    return S.Diag(call->getEndLoc(), diag::err_typecheck_call_too_few_args)\n           << 0 /*function call*/ << desiredArgCount << argCount\n           << call->getSourceRange();\n\n  // Highlight all the excess arguments.\n  SourceRange range(call->getArg(desiredArgCount)->getBeginLoc(),\n                    call->getArg(argCount - 1)->getEndLoc());\n\n  return S.Diag(range.getBegin(), diag::err_typecheck_call_too_many_args)\n    << 0 /*function call*/ << desiredArgCount << argCount\n    << call->getArg(1)->getSourceRange();\n}\n\n/// Check that the first argument to __builtin_annotation is an integer\n/// and the second argument is a non-wide string literal.\nstatic bool SemaBuiltinAnnotation(Sema &S, CallExpr *TheCall) {\n  if (checkArgCount(S, TheCall, 2))\n    return true;\n\n  // First argument should be an integer.\n  Expr *ValArg = TheCall->getArg(0);\n  QualType Ty = ValArg->getType();\n  if (!Ty->isIntegerType()) {\n    S.Diag(ValArg->getBeginLoc(), diag::err_builtin_annotation_first_arg)\n        << ValArg->getSourceRange();\n    return true;\n  }\n\n  // Second argument should be a constant string.\n  Expr *StrArg = TheCall->getArg(1)->IgnoreParenCasts();\n  StringLiteral *Literal = dyn_cast<StringLiteral>(StrArg);\n  if (!Literal || !Literal->isAscii()) {\n    S.Diag(StrArg->getBeginLoc(), diag::err_builtin_annotation_second_arg)\n        << StrArg->getSourceRange();\n    return true;\n  }\n\n  TheCall->setType(Ty);\n  return false;\n}\n\nstatic bool SemaBuiltinMSVCAnnotation(Sema &S, CallExpr *TheCall) {\n  // We need at least one argument.\n  if (TheCall->getNumArgs() < 1) {\n    S.Diag(TheCall->getEndLoc(), diag::err_typecheck_call_too_few_args_at_least)\n        << 0 << 1 << TheCall->getNumArgs()\n        << TheCall->getCallee()->getSourceRange();\n    return true;\n  }\n\n  // All arguments should be wide string literals.\n  for (Expr *Arg : TheCall->arguments()) {\n    auto *Literal = dyn_cast<StringLiteral>(Arg->IgnoreParenCasts());\n    if (!Literal || !Literal->isWide()) {\n      S.Diag(Arg->getBeginLoc(), diag::err_msvc_annotation_wide_str)\n          << Arg->getSourceRange();\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// Check that the argument to __builtin_addressof is a glvalue, and set the\n/// result type to the corresponding pointer type.\nstatic bool SemaBuiltinAddressof(Sema &S, CallExpr *TheCall) {\n  if (checkArgCount(S, TheCall, 1))\n    return true;\n\n  ExprResult Arg(TheCall->getArg(0));\n  QualType ResultType = S.CheckAddressOfOperand(Arg, TheCall->getBeginLoc());\n  if (ResultType.isNull())\n    return true;\n\n  TheCall->setArg(0, Arg.get());\n  TheCall->setType(ResultType);\n  return false;\n}\n\n/// Check the number of arguments and set the result type to\n/// the argument type.\nstatic bool SemaBuiltinPreserveAI(Sema &S, CallExpr *TheCall) {\n  if (checkArgCount(S, TheCall, 1))\n    return true;\n\n  TheCall->setType(TheCall->getArg(0)->getType());\n  return false;\n}\n\n/// Check that the value argument for __builtin_is_aligned(value, alignment) and\n/// __builtin_aligned_{up,down}(value, alignment) is an integer or a pointer\n/// type (but not a function pointer) and that the alignment is a power-of-two.\nstatic bool SemaBuiltinAlignment(Sema &S, CallExpr *TheCall, unsigned ID) {\n  if (checkArgCount(S, TheCall, 2))\n    return true;\n\n  clang::Expr *Source = TheCall->getArg(0);\n  bool IsBooleanAlignBuiltin = ID == Builtin::BI__builtin_is_aligned;\n\n  auto IsValidIntegerType = [](QualType Ty) {\n    return Ty->isIntegerType() && !Ty->isEnumeralType() && !Ty->isBooleanType();\n  };\n  QualType SrcTy = Source->getType();\n  // We should also be able to use it with arrays (but not functions!).\n  if (SrcTy->canDecayToPointerType() && SrcTy->isArrayType()) {\n    SrcTy = S.Context.getDecayedType(SrcTy);\n  }\n  if ((!SrcTy->isPointerType() && !IsValidIntegerType(SrcTy)) ||\n      SrcTy->isFunctionPointerType()) {\n    // FIXME: this is not quite the right error message since we don't allow\n    // floating point types, or member pointers.\n    S.Diag(Source->getExprLoc(), diag::err_typecheck_expect_scalar_operand)\n        << SrcTy;\n    return true;\n  }\n\n  clang::Expr *AlignOp = TheCall->getArg(1);\n  if (!IsValidIntegerType(AlignOp->getType())) {\n    S.Diag(AlignOp->getExprLoc(), diag::err_typecheck_expect_int)\n        << AlignOp->getType();\n    return true;\n  }\n  Expr::EvalResult AlignResult;\n  unsigned MaxAlignmentBits = S.Context.getIntWidth(SrcTy) - 1;\n  // We can't check validity of alignment if it is value dependent.\n  if (!AlignOp->isValueDependent() &&\n      AlignOp->EvaluateAsInt(AlignResult, S.Context,\n                             Expr::SE_AllowSideEffects)) {\n    llvm::APSInt AlignValue = AlignResult.Val.getInt();\n    llvm::APSInt MaxValue(\n        llvm::APInt::getOneBitSet(MaxAlignmentBits + 1, MaxAlignmentBits));\n    if (AlignValue < 1) {\n      S.Diag(AlignOp->getExprLoc(), diag::err_alignment_too_small) << 1;\n      return true;\n    }\n    if (llvm::APSInt::compareValues(AlignValue, MaxValue) > 0) {\n      S.Diag(AlignOp->getExprLoc(), diag::err_alignment_too_big)\n          << MaxValue.toString(10);\n      return true;\n    }\n    if (!AlignValue.isPowerOf2()) {\n      S.Diag(AlignOp->getExprLoc(), diag::err_alignment_not_power_of_two);\n      return true;\n    }\n    if (AlignValue == 1) {\n      S.Diag(AlignOp->getExprLoc(), diag::warn_alignment_builtin_useless)\n          << IsBooleanAlignBuiltin;\n    }\n  }\n\n  ExprResult SrcArg = S.PerformCopyInitialization(\n      InitializedEntity::InitializeParameter(S.Context, SrcTy, false),\n      SourceLocation(), Source);\n  if (SrcArg.isInvalid())\n    return true;\n  TheCall->setArg(0, SrcArg.get());\n  ExprResult AlignArg =\n      S.PerformCopyInitialization(InitializedEntity::InitializeParameter(\n                                      S.Context, AlignOp->getType(), false),\n                                  SourceLocation(), AlignOp);\n  if (AlignArg.isInvalid())\n    return true;\n  TheCall->setArg(1, AlignArg.get());\n  // For align_up/align_down, the return type is the same as the (potentially\n  // decayed) argument type including qualifiers. For is_aligned(), the result\n  // is always bool.\n  TheCall->setType(IsBooleanAlignBuiltin ? S.Context.BoolTy : SrcTy);\n  return false;\n}\n\nstatic bool SemaBuiltinOverflow(Sema &S, CallExpr *TheCall,\n                                unsigned BuiltinID) {\n  if (checkArgCount(S, TheCall, 3))\n    return true;\n\n  // First two arguments should be integers.\n  for (unsigned I = 0; I < 2; ++I) {\n    ExprResult Arg = S.DefaultFunctionArrayLvalueConversion(TheCall->getArg(I));\n    if (Arg.isInvalid()) return true;\n    TheCall->setArg(I, Arg.get());\n\n    QualType Ty = Arg.get()->getType();\n    if (!Ty->isIntegerType()) {\n      S.Diag(Arg.get()->getBeginLoc(), diag::err_overflow_builtin_must_be_int)\n          << Ty << Arg.get()->getSourceRange();\n      return true;\n    }\n  }\n\n  // Third argument should be a pointer to a non-const integer.\n  // IRGen correctly handles volatile, restrict, and address spaces, and\n  // the other qualifiers aren't possible.\n  {\n    ExprResult Arg = S.DefaultFunctionArrayLvalueConversion(TheCall->getArg(2));\n    if (Arg.isInvalid()) return true;\n    TheCall->setArg(2, Arg.get());\n\n    QualType Ty = Arg.get()->getType();\n    const auto *PtrTy = Ty->getAs<PointerType>();\n    if (!PtrTy ||\n        !PtrTy->getPointeeType()->isIntegerType() ||\n        PtrTy->getPointeeType().isConstQualified()) {\n      S.Diag(Arg.get()->getBeginLoc(),\n             diag::err_overflow_builtin_must_be_ptr_int)\n        << Ty << Arg.get()->getSourceRange();\n      return true;\n    }\n  }\n\n  // Disallow signed ExtIntType args larger than 128 bits to mul function until\n  // we improve backend support.\n  if (BuiltinID == Builtin::BI__builtin_mul_overflow) {\n    for (unsigned I = 0; I < 3; ++I) {\n      const auto Arg = TheCall->getArg(I);\n      // Third argument will be a pointer.\n      auto Ty = I < 2 ? Arg->getType() : Arg->getType()->getPointeeType();\n      if (Ty->isExtIntType() && Ty->isSignedIntegerType() &&\n          S.getASTContext().getIntWidth(Ty) > 128)\n        return S.Diag(Arg->getBeginLoc(),\n                      diag::err_overflow_builtin_ext_int_max_size)\n               << 128;\n    }\n  }\n\n  return false;\n}\n\nstatic bool SemaBuiltinCallWithStaticChain(Sema &S, CallExpr *BuiltinCall) {\n  if (checkArgCount(S, BuiltinCall, 2))\n    return true;\n\n  SourceLocation BuiltinLoc = BuiltinCall->getBeginLoc();\n  Expr *Builtin = BuiltinCall->getCallee()->IgnoreImpCasts();\n  Expr *Call = BuiltinCall->getArg(0);\n  Expr *Chain = BuiltinCall->getArg(1);\n\n  if (Call->getStmtClass() != Stmt::CallExprClass) {\n    S.Diag(BuiltinLoc, diag::err_first_argument_to_cwsc_not_call)\n        << Call->getSourceRange();\n    return true;\n  }\n\n  auto CE = cast<CallExpr>(Call);\n  if (CE->getCallee()->getType()->isBlockPointerType()) {\n    S.Diag(BuiltinLoc, diag::err_first_argument_to_cwsc_block_call)\n        << Call->getSourceRange();\n    return true;\n  }\n\n  const Decl *TargetDecl = CE->getCalleeDecl();\n  if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(TargetDecl))\n    if (FD->getBuiltinID()) {\n      S.Diag(BuiltinLoc, diag::err_first_argument_to_cwsc_builtin_call)\n          << Call->getSourceRange();\n      return true;\n    }\n\n  if (isa<CXXPseudoDestructorExpr>(CE->getCallee()->IgnoreParens())) {\n    S.Diag(BuiltinLoc, diag::err_first_argument_to_cwsc_pdtor_call)\n        << Call->getSourceRange();\n    return true;\n  }\n\n  ExprResult ChainResult = S.UsualUnaryConversions(Chain);\n  if (ChainResult.isInvalid())\n    return true;\n  if (!ChainResult.get()->getType()->isPointerType()) {\n    S.Diag(BuiltinLoc, diag::err_second_argument_to_cwsc_not_pointer)\n        << Chain->getSourceRange();\n    return true;\n  }\n\n  QualType ReturnTy = CE->getCallReturnType(S.Context);\n  QualType ArgTys[2] = { ReturnTy, ChainResult.get()->getType() };\n  QualType BuiltinTy = S.Context.getFunctionType(\n      ReturnTy, ArgTys, FunctionProtoType::ExtProtoInfo());\n  QualType BuiltinPtrTy = S.Context.getPointerType(BuiltinTy);\n\n  Builtin =\n      S.ImpCastExprToType(Builtin, BuiltinPtrTy, CK_BuiltinFnToFnPtr).get();\n\n  BuiltinCall->setType(CE->getType());\n  BuiltinCall->setValueKind(CE->getValueKind());\n  BuiltinCall->setObjectKind(CE->getObjectKind());\n  BuiltinCall->setCallee(Builtin);\n  BuiltinCall->setArg(1, ChainResult.get());\n\n  return false;\n}\n\nnamespace {\n\nclass EstimateSizeFormatHandler\n    : public analyze_format_string::FormatStringHandler {\n  size_t Size;\n\npublic:\n  EstimateSizeFormatHandler(StringRef Format)\n      : Size(std::min(Format.find(0), Format.size()) +\n             1 /* null byte always written by sprintf */) {}\n\n  bool HandlePrintfSpecifier(const analyze_printf::PrintfSpecifier &FS,\n                             const char *, unsigned SpecifierLen) override {\n\n    const size_t FieldWidth = computeFieldWidth(FS);\n    const size_t Precision = computePrecision(FS);\n\n    // The actual format.\n    switch (FS.getConversionSpecifier().getKind()) {\n    // Just a char.\n    case analyze_format_string::ConversionSpecifier::cArg:\n    case analyze_format_string::ConversionSpecifier::CArg:\n      Size += std::max(FieldWidth, (size_t)1);\n      break;\n    // Just an integer.\n    case analyze_format_string::ConversionSpecifier::dArg:\n    case analyze_format_string::ConversionSpecifier::DArg:\n    case analyze_format_string::ConversionSpecifier::iArg:\n    case analyze_format_string::ConversionSpecifier::oArg:\n    case analyze_format_string::ConversionSpecifier::OArg:\n    case analyze_format_string::ConversionSpecifier::uArg:\n    case analyze_format_string::ConversionSpecifier::UArg:\n    case analyze_format_string::ConversionSpecifier::xArg:\n    case analyze_format_string::ConversionSpecifier::XArg:\n      Size += std::max(FieldWidth, Precision);\n      break;\n\n    // %g style conversion switches between %f or %e style dynamically.\n    // %f always takes less space, so default to it.\n    case analyze_format_string::ConversionSpecifier::gArg:\n    case analyze_format_string::ConversionSpecifier::GArg:\n\n    // Floating point number in the form '[+]ddd.ddd'.\n    case analyze_format_string::ConversionSpecifier::fArg:\n    case analyze_format_string::ConversionSpecifier::FArg:\n      Size += std::max(FieldWidth, 1 /* integer part */ +\n                                       (Precision ? 1 + Precision\n                                                  : 0) /* period + decimal */);\n      break;\n\n    // Floating point number in the form '[-]d.ddde[+-]dd'.\n    case analyze_format_string::ConversionSpecifier::eArg:\n    case analyze_format_string::ConversionSpecifier::EArg:\n      Size +=\n          std::max(FieldWidth,\n                   1 /* integer part */ +\n                       (Precision ? 1 + Precision : 0) /* period + decimal */ +\n                       1 /* e or E letter */ + 2 /* exponent */);\n      break;\n\n    // Floating point number in the form '[-]0xh.hhhhp\u00b1dd'.\n    case analyze_format_string::ConversionSpecifier::aArg:\n    case analyze_format_string::ConversionSpecifier::AArg:\n      Size +=\n          std::max(FieldWidth,\n                   2 /* 0x */ + 1 /* integer part */ +\n                       (Precision ? 1 + Precision : 0) /* period + decimal */ +\n                       1 /* p or P letter */ + 1 /* + or - */ + 1 /* value */);\n      break;\n\n    // Just a string.\n    case analyze_format_string::ConversionSpecifier::sArg:\n    case analyze_format_string::ConversionSpecifier::SArg:\n      Size += FieldWidth;\n      break;\n\n    // Just a pointer in the form '0xddd'.\n    case analyze_format_string::ConversionSpecifier::pArg:\n      Size += std::max(FieldWidth, 2 /* leading 0x */ + Precision);\n      break;\n\n    // A plain percent.\n    case analyze_format_string::ConversionSpecifier::PercentArg:\n      Size += 1;\n      break;\n\n    default:\n      break;\n    }\n\n    Size += FS.hasPlusPrefix() || FS.hasSpacePrefix();\n\n    if (FS.hasAlternativeForm()) {\n      switch (FS.getConversionSpecifier().getKind()) {\n      default:\n        break;\n      // Force a leading '0'.\n      case analyze_format_string::ConversionSpecifier::oArg:\n        Size += 1;\n        break;\n      // Force a leading '0x'.\n      case analyze_format_string::ConversionSpecifier::xArg:\n      case analyze_format_string::ConversionSpecifier::XArg:\n        Size += 2;\n        break;\n      // Force a period '.' before decimal, even if precision is 0.\n      case analyze_format_string::ConversionSpecifier::aArg:\n      case analyze_format_string::ConversionSpecifier::AArg:\n      case analyze_format_string::ConversionSpecifier::eArg:\n      case analyze_format_string::ConversionSpecifier::EArg:\n      case analyze_format_string::ConversionSpecifier::fArg:\n      case analyze_format_string::ConversionSpecifier::FArg:\n      case analyze_format_string::ConversionSpecifier::gArg:\n      case analyze_format_string::ConversionSpecifier::GArg:\n        Size += (Precision ? 0 : 1);\n        break;\n      }\n    }\n    assert(SpecifierLen <= Size && \"no underflow\");\n    Size -= SpecifierLen;\n    return true;\n  }\n\n  size_t getSizeLowerBound() const { return Size; }\n\nprivate:\n  static size_t computeFieldWidth(const analyze_printf::PrintfSpecifier &FS) {\n    const analyze_format_string::OptionalAmount &FW = FS.getFieldWidth();\n    size_t FieldWidth = 0;\n    if (FW.getHowSpecified() == analyze_format_string::OptionalAmount::Constant)\n      FieldWidth = FW.getConstantAmount();\n    return FieldWidth;\n  }\n\n  static size_t computePrecision(const analyze_printf::PrintfSpecifier &FS) {\n    const analyze_format_string::OptionalAmount &FW = FS.getPrecision();\n    size_t Precision = 0;\n\n    // See man 3 printf for default precision value based on the specifier.\n    switch (FW.getHowSpecified()) {\n    case analyze_format_string::OptionalAmount::NotSpecified:\n      switch (FS.getConversionSpecifier().getKind()) {\n      default:\n        break;\n      case analyze_format_string::ConversionSpecifier::dArg: // %d\n      case analyze_format_string::ConversionSpecifier::DArg: // %D\n      case analyze_format_string::ConversionSpecifier::iArg: // %i\n        Precision = 1;\n        break;\n      case analyze_format_string::ConversionSpecifier::oArg: // %d\n      case analyze_format_string::ConversionSpecifier::OArg: // %D\n      case analyze_format_string::ConversionSpecifier::uArg: // %d\n      case analyze_format_string::ConversionSpecifier::UArg: // %D\n      case analyze_format_string::ConversionSpecifier::xArg: // %d\n      case analyze_format_string::ConversionSpecifier::XArg: // %D\n        Precision = 1;\n        break;\n      case analyze_format_string::ConversionSpecifier::fArg: // %f\n      case analyze_format_string::ConversionSpecifier::FArg: // %F\n      case analyze_format_string::ConversionSpecifier::eArg: // %e\n      case analyze_format_string::ConversionSpecifier::EArg: // %E\n      case analyze_format_string::ConversionSpecifier::gArg: // %g\n      case analyze_format_string::ConversionSpecifier::GArg: // %G\n        Precision = 6;\n        break;\n      case analyze_format_string::ConversionSpecifier::pArg: // %d\n        Precision = 1;\n        break;\n      }\n      break;\n    case analyze_format_string::OptionalAmount::Constant:\n      Precision = FW.getConstantAmount();\n      break;\n    default:\n      break;\n    }\n    return Precision;\n  }\n};\n\n} // namespace\n\n/// Check a call to BuiltinID for buffer overflows. If BuiltinID is a\n/// __builtin_*_chk function, then use the object size argument specified in the\n/// source. Otherwise, infer the object size using __builtin_object_size.\nvoid Sema::checkFortifiedBuiltinMemoryFunction(FunctionDecl *FD,\n                                               CallExpr *TheCall) {\n  // FIXME: There are some more useful checks we could be doing here:\n  //  - Evaluate strlen of strcpy arguments, use as object size.\n\n  if (TheCall->isValueDependent() || TheCall->isTypeDependent() ||\n      isConstantEvaluated())\n    return;\n\n  unsigned BuiltinID = FD->getBuiltinID(/*ConsiderWrappers=*/true);\n  if (!BuiltinID)\n    return;\n\n  const TargetInfo &TI = getASTContext().getTargetInfo();\n  unsigned SizeTypeWidth = TI.getTypeWidth(TI.getSizeType());\n\n  unsigned DiagID = 0;\n  bool IsChkVariant = false;\n  Optional<llvm::APSInt> UsedSize;\n  unsigned SizeIndex, ObjectIndex;\n  switch (BuiltinID) {\n  default:\n    return;\n  case Builtin::BIsprintf:\n  case Builtin::BI__builtin___sprintf_chk: {\n    size_t FormatIndex = BuiltinID == Builtin::BIsprintf ? 1 : 3;\n    auto *FormatExpr = TheCall->getArg(FormatIndex)->IgnoreParenImpCasts();\n\n    if (auto *Format = dyn_cast<StringLiteral>(FormatExpr)) {\n\n      if (!Format->isAscii() && !Format->isUTF8())\n        return;\n\n      StringRef FormatStrRef = Format->getString();\n      EstimateSizeFormatHandler H(FormatStrRef);\n      const char *FormatBytes = FormatStrRef.data();\n      const ConstantArrayType *T =\n          Context.getAsConstantArrayType(Format->getType());\n      assert(T && \"String literal not of constant array type!\");\n      size_t TypeSize = T->getSize().getZExtValue();\n\n      // In case there's a null byte somewhere.\n      size_t StrLen =\n          std::min(std::max(TypeSize, size_t(1)) - 1, FormatStrRef.find(0));\n      if (!analyze_format_string::ParsePrintfString(\n              H, FormatBytes, FormatBytes + StrLen, getLangOpts(),\n              Context.getTargetInfo(), false)) {\n        DiagID = diag::warn_fortify_source_format_overflow;\n        UsedSize = llvm::APSInt::getUnsigned(H.getSizeLowerBound())\n                       .extOrTrunc(SizeTypeWidth);\n        if (BuiltinID == Builtin::BI__builtin___sprintf_chk) {\n          IsChkVariant = true;\n          ObjectIndex = 2;\n        } else {\n          IsChkVariant = false;\n          ObjectIndex = 0;\n        }\n        break;\n      }\n    }\n    return;\n  }\n  case Builtin::BI__builtin___memcpy_chk:\n  case Builtin::BI__builtin___memmove_chk:\n  case Builtin::BI__builtin___memset_chk:\n  case Builtin::BI__builtin___strlcat_chk:\n  case Builtin::BI__builtin___strlcpy_chk:\n  case Builtin::BI__builtin___strncat_chk:\n  case Builtin::BI__builtin___strncpy_chk:\n  case Builtin::BI__builtin___stpncpy_chk:\n  case Builtin::BI__builtin___memccpy_chk:\n  case Builtin::BI__builtin___mempcpy_chk: {\n    DiagID = diag::warn_builtin_chk_overflow;\n    IsChkVariant = true;\n    SizeIndex = TheCall->getNumArgs() - 2;\n    ObjectIndex = TheCall->getNumArgs() - 1;\n    break;\n  }\n\n  case Builtin::BI__builtin___snprintf_chk:\n  case Builtin::BI__builtin___vsnprintf_chk: {\n    DiagID = diag::warn_builtin_chk_overflow;\n    IsChkVariant = true;\n    SizeIndex = 1;\n    ObjectIndex = 3;\n    break;\n  }\n\n  case Builtin::BIstrncat:\n  case Builtin::BI__builtin_strncat:\n  case Builtin::BIstrncpy:\n  case Builtin::BI__builtin_strncpy:\n  case Builtin::BIstpncpy:\n  case Builtin::BI__builtin_stpncpy: {\n    // Whether these functions overflow depends on the runtime strlen of the\n    // string, not just the buffer size, so emitting the \"always overflow\"\n    // diagnostic isn't quite right. We should still diagnose passing a buffer\n    // size larger than the destination buffer though; this is a runtime abort\n    // in _FORTIFY_SOURCE mode, and is quite suspicious otherwise.\n    DiagID = diag::warn_fortify_source_size_mismatch;\n    SizeIndex = TheCall->getNumArgs() - 1;\n    ObjectIndex = 0;\n    break;\n  }\n\n  case Builtin::BImemcpy:\n  case Builtin::BI__builtin_memcpy:\n  case Builtin::BImemmove:\n  case Builtin::BI__builtin_memmove:\n  case Builtin::BImemset:\n  case Builtin::BI__builtin_memset:\n  case Builtin::BImempcpy:\n  case Builtin::BI__builtin_mempcpy: {\n    DiagID = diag::warn_fortify_source_overflow;\n    SizeIndex = TheCall->getNumArgs() - 1;\n    ObjectIndex = 0;\n    break;\n  }\n  case Builtin::BIsnprintf:\n  case Builtin::BI__builtin_snprintf:\n  case Builtin::BIvsnprintf:\n  case Builtin::BI__builtin_vsnprintf: {\n    DiagID = diag::warn_fortify_source_size_mismatch;\n    SizeIndex = 1;\n    ObjectIndex = 0;\n    break;\n  }\n  }\n\n  llvm::APSInt ObjectSize;\n  // For __builtin___*_chk, the object size is explicitly provided by the caller\n  // (usually using __builtin_object_size). Use that value to check this call.\n  if (IsChkVariant) {\n    Expr::EvalResult Result;\n    Expr *SizeArg = TheCall->getArg(ObjectIndex);\n    if (!SizeArg->EvaluateAsInt(Result, getASTContext()))\n      return;\n    ObjectSize = Result.Val.getInt();\n\n  // Otherwise, try to evaluate an imaginary call to __builtin_object_size.\n  } else {\n    // If the parameter has a pass_object_size attribute, then we should use its\n    // (potentially) more strict checking mode. Otherwise, conservatively assume\n    // type 0.\n    int BOSType = 0;\n    if (const auto *POS =\n            FD->getParamDecl(ObjectIndex)->getAttr<PassObjectSizeAttr>())\n      BOSType = POS->getType();\n\n    Expr *ObjArg = TheCall->getArg(ObjectIndex);\n    uint64_t Result;\n    if (!ObjArg->tryEvaluateObjectSize(Result, getASTContext(), BOSType))\n      return;\n    // Get the object size in the target's size_t width.\n    ObjectSize = llvm::APSInt::getUnsigned(Result).extOrTrunc(SizeTypeWidth);\n  }\n\n  // Evaluate the number of bytes of the object that this call will use.\n  if (!UsedSize) {\n    Expr::EvalResult Result;\n    Expr *UsedSizeArg = TheCall->getArg(SizeIndex);\n    if (!UsedSizeArg->EvaluateAsInt(Result, getASTContext()))\n      return;\n    UsedSize = Result.Val.getInt().extOrTrunc(SizeTypeWidth);\n  }\n\n  if (UsedSize.getValue().ule(ObjectSize))\n    return;\n\n  StringRef FunctionName = getASTContext().BuiltinInfo.getName(BuiltinID);\n  // Skim off the details of whichever builtin was called to produce a better\n  // diagnostic, as it's unlikley that the user wrote the __builtin explicitly.\n  if (IsChkVariant) {\n    FunctionName = FunctionName.drop_front(std::strlen(\"__builtin___\"));\n    FunctionName = FunctionName.drop_back(std::strlen(\"_chk\"));\n  } else if (FunctionName.startswith(\"__builtin_\")) {\n    FunctionName = FunctionName.drop_front(std::strlen(\"__builtin_\"));\n  }\n\n  DiagRuntimeBehavior(TheCall->getBeginLoc(), TheCall,\n                      PDiag(DiagID)\n                          << FunctionName << ObjectSize.toString(/*Radix=*/10)\n                          << UsedSize.getValue().toString(/*Radix=*/10));\n}\n\nstatic bool SemaBuiltinSEHScopeCheck(Sema &SemaRef, CallExpr *TheCall,\n                                     Scope::ScopeFlags NeededScopeFlags,\n                                     unsigned DiagID) {\n  // Scopes aren't available during instantiation. Fortunately, builtin\n  // functions cannot be template args so they cannot be formed through template\n  // instantiation. Therefore checking once during the parse is sufficient.\n  if (SemaRef.inTemplateInstantiation())\n    return false;\n\n  Scope *S = SemaRef.getCurScope();\n  while (S && !S->isSEHExceptScope())\n    S = S->getParent();\n  if (!S || !(S->getFlags() & NeededScopeFlags)) {\n    auto *DRE = cast<DeclRefExpr>(TheCall->getCallee()->IgnoreParenCasts());\n    SemaRef.Diag(TheCall->getExprLoc(), DiagID)\n        << DRE->getDecl()->getIdentifier();\n    return true;\n  }\n\n  return false;\n}\n\nstatic inline bool isBlockPointer(Expr *Arg) {\n  return Arg->getType()->isBlockPointerType();\n}\n\n/// OpenCL C v2.0, s6.13.17.2 - Checks that the block parameters are all local\n/// void*, which is a requirement of device side enqueue.\nstatic bool checkOpenCLBlockArgs(Sema &S, Expr *BlockArg) {\n  const BlockPointerType *BPT =\n      cast<BlockPointerType>(BlockArg->getType().getCanonicalType());\n  ArrayRef<QualType> Params =\n      BPT->getPointeeType()->castAs<FunctionProtoType>()->getParamTypes();\n  unsigned ArgCounter = 0;\n  bool IllegalParams = false;\n  // Iterate through the block parameters until either one is found that is not\n  // a local void*, or the block is valid.\n  for (ArrayRef<QualType>::iterator I = Params.begin(), E = Params.end();\n       I != E; ++I, ++ArgCounter) {\n    if (!(*I)->isPointerType() || !(*I)->getPointeeType()->isVoidType() ||\n        (*I)->getPointeeType().getQualifiers().getAddressSpace() !=\n            LangAS::opencl_local) {\n      // Get the location of the error. If a block literal has been passed\n      // (BlockExpr) then we can point straight to the offending argument,\n      // else we just point to the variable reference.\n      SourceLocation ErrorLoc;\n      if (isa<BlockExpr>(BlockArg)) {\n        BlockDecl *BD = cast<BlockExpr>(BlockArg)->getBlockDecl();\n        ErrorLoc = BD->getParamDecl(ArgCounter)->getBeginLoc();\n      } else if (isa<DeclRefExpr>(BlockArg)) {\n        ErrorLoc = cast<DeclRefExpr>(BlockArg)->getBeginLoc();\n      }\n      S.Diag(ErrorLoc,\n             diag::err_opencl_enqueue_kernel_blocks_non_local_void_args);\n      IllegalParams = true;\n    }\n  }\n\n  return IllegalParams;\n}\n\nstatic bool checkOpenCLSubgroupExt(Sema &S, CallExpr *Call) {\n  if (!S.getOpenCLOptions().isEnabled(\"cl_khr_subgroups\")) {\n    S.Diag(Call->getBeginLoc(), diag::err_opencl_requires_extension)\n        << 1 << Call->getDirectCallee() << \"cl_khr_subgroups\";\n    return true;\n  }\n  return false;\n}\n\nstatic bool SemaOpenCLBuiltinNDRangeAndBlock(Sema &S, CallExpr *TheCall) {\n  if (checkArgCount(S, TheCall, 2))\n    return true;\n\n  if (checkOpenCLSubgroupExt(S, TheCall))\n    return true;\n\n  // First argument is an ndrange_t type.\n  Expr *NDRangeArg = TheCall->getArg(0);\n  if (NDRangeArg->getType().getUnqualifiedType().getAsString() != \"ndrange_t\") {\n    S.Diag(NDRangeArg->getBeginLoc(), diag::err_opencl_builtin_expected_type)\n        << TheCall->getDirectCallee() << \"'ndrange_t'\";\n    return true;\n  }\n\n  Expr *BlockArg = TheCall->getArg(1);\n  if (!isBlockPointer(BlockArg)) {\n    S.Diag(BlockArg->getBeginLoc(), diag::err_opencl_builtin_expected_type)\n        << TheCall->getDirectCallee() << \"block\";\n    return true;\n  }\n  return checkOpenCLBlockArgs(S, BlockArg);\n}\n\n/// OpenCL C v2.0, s6.13.17.6 - Check the argument to the\n/// get_kernel_work_group_size\n/// and get_kernel_preferred_work_group_size_multiple builtin functions.\nstatic bool SemaOpenCLBuiltinKernelWorkGroupSize(Sema &S, CallExpr *TheCall) {\n  if (checkArgCount(S, TheCall, 1))\n    return true;\n\n  Expr *BlockArg = TheCall->getArg(0);\n  if (!isBlockPointer(BlockArg)) {\n    S.Diag(BlockArg->getBeginLoc(), diag::err_opencl_builtin_expected_type)\n        << TheCall->getDirectCallee() << \"block\";\n    return true;\n  }\n  return checkOpenCLBlockArgs(S, BlockArg);\n}\n\n/// Diagnose integer type and any valid implicit conversion to it.\nstatic bool checkOpenCLEnqueueIntType(Sema &S, Expr *E,\n                                      const QualType &IntType);\n\nstatic bool checkOpenCLEnqueueLocalSizeArgs(Sema &S, CallExpr *TheCall,\n                                            unsigned Start, unsigned End) {\n  bool IllegalParams = false;\n  for (unsigned I = Start; I <= End; ++I)\n    IllegalParams |= checkOpenCLEnqueueIntType(S, TheCall->getArg(I),\n                                              S.Context.getSizeType());\n  return IllegalParams;\n}\n\n/// OpenCL v2.0, s6.13.17.1 - Check that sizes are provided for all\n/// 'local void*' parameter of passed block.\nstatic bool checkOpenCLEnqueueVariadicArgs(Sema &S, CallExpr *TheCall,\n                                           Expr *BlockArg,\n                                           unsigned NumNonVarArgs) {\n  const BlockPointerType *BPT =\n      cast<BlockPointerType>(BlockArg->getType().getCanonicalType());\n  unsigned NumBlockParams =\n      BPT->getPointeeType()->castAs<FunctionProtoType>()->getNumParams();\n  unsigned TotalNumArgs = TheCall->getNumArgs();\n\n  // For each argument passed to the block, a corresponding uint needs to\n  // be passed to describe the size of the local memory.\n  if (TotalNumArgs != NumBlockParams + NumNonVarArgs) {\n    S.Diag(TheCall->getBeginLoc(),\n           diag::err_opencl_enqueue_kernel_local_size_args);\n    return true;\n  }\n\n  // Check that the sizes of the local memory are specified by integers.\n  return checkOpenCLEnqueueLocalSizeArgs(S, TheCall, NumNonVarArgs,\n                                         TotalNumArgs - 1);\n}\n\n/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different\n/// overload formats specified in Table 6.13.17.1.\n/// int enqueue_kernel(queue_t queue,\n///                    kernel_enqueue_flags_t flags,\n///                    const ndrange_t ndrange,\n///                    void (^block)(void))\n/// int enqueue_kernel(queue_t queue,\n///                    kernel_enqueue_flags_t flags,\n///                    const ndrange_t ndrange,\n///                    uint num_events_in_wait_list,\n///                    clk_event_t *event_wait_list,\n///                    clk_event_t *event_ret,\n///                    void (^block)(void))\n/// int enqueue_kernel(queue_t queue,\n///                    kernel_enqueue_flags_t flags,\n///                    const ndrange_t ndrange,\n///                    void (^block)(local void*, ...),\n///                    uint size0, ...)\n/// int enqueue_kernel(queue_t queue,\n///                    kernel_enqueue_flags_t flags,\n///                    const ndrange_t ndrange,\n///                    uint num_events_in_wait_list,\n///                    clk_event_t *event_wait_list,\n///                    clk_event_t *event_ret,\n///                    void (^block)(local void*, ...),\n///                    uint size0, ...)\nstatic bool SemaOpenCLBuiltinEnqueueKernel(Sema &S, CallExpr *TheCall) {\n  unsigned NumArgs = TheCall->getNumArgs();\n\n  if (NumArgs < 4) {\n    S.Diag(TheCall->getBeginLoc(),\n           diag::err_typecheck_call_too_few_args_at_least)\n        << 0 << 4 << NumArgs;\n    return true;\n  }\n\n  Expr *Arg0 = TheCall->getArg(0);\n  Expr *Arg1 = TheCall->getArg(1);\n  Expr *Arg2 = TheCall->getArg(2);\n  Expr *Arg3 = TheCall->getArg(3);\n\n  // First argument always needs to be a queue_t type.\n  if (!Arg0->getType()->isQueueT()) {\n    S.Diag(TheCall->getArg(0)->getBeginLoc(),\n           diag::err_opencl_builtin_expected_type)\n        << TheCall->getDirectCallee() << S.Context.OCLQueueTy;\n    return true;\n  }\n\n  // Second argument always needs to be a kernel_enqueue_flags_t enum value.\n  if (!Arg1->getType()->isIntegerType()) {\n    S.Diag(TheCall->getArg(1)->getBeginLoc(),\n           diag::err_opencl_builtin_expected_type)\n        << TheCall->getDirectCallee() << \"'kernel_enqueue_flags_t' (i.e. uint)\";\n    return true;\n  }\n\n  // Third argument is always an ndrange_t type.\n  if (Arg2->getType().getUnqualifiedType().getAsString() != \"ndrange_t\") {\n    S.Diag(TheCall->getArg(2)->getBeginLoc(),\n           diag::err_opencl_builtin_expected_type)\n        << TheCall->getDirectCallee() << \"'ndrange_t'\";\n    return true;\n  }\n\n  // With four arguments, there is only one form that the function could be\n  // called in: no events and no variable arguments.\n  if (NumArgs == 4) {\n    // check that the last argument is the right block type.\n    if (!isBlockPointer(Arg3)) {\n      S.Diag(Arg3->getBeginLoc(), diag::err_opencl_builtin_expected_type)\n          << TheCall->getDirectCallee() << \"block\";\n      return true;\n    }\n    // we have a block type, check the prototype\n    const BlockPointerType *BPT =\n        cast<BlockPointerType>(Arg3->getType().getCanonicalType());\n    if (BPT->getPointeeType()->castAs<FunctionProtoType>()->getNumParams() > 0) {\n      S.Diag(Arg3->getBeginLoc(),\n             diag::err_opencl_enqueue_kernel_blocks_no_args);\n      return true;\n    }\n    return false;\n  }\n  // we can have block + varargs.\n  if (isBlockPointer(Arg3))\n    return (checkOpenCLBlockArgs(S, Arg3) ||\n            checkOpenCLEnqueueVariadicArgs(S, TheCall, Arg3, 4));\n  // last two cases with either exactly 7 args or 7 args and varargs.\n  if (NumArgs >= 7) {\n    // check common block argument.\n    Expr *Arg6 = TheCall->getArg(6);\n    if (!isBlockPointer(Arg6)) {\n      S.Diag(Arg6->getBeginLoc(), diag::err_opencl_builtin_expected_type)\n          << TheCall->getDirectCallee() << \"block\";\n      return true;\n    }\n    if (checkOpenCLBlockArgs(S, Arg6))\n      return true;\n\n    // Forth argument has to be any integer type.\n    if (!Arg3->getType()->isIntegerType()) {\n      S.Diag(TheCall->getArg(3)->getBeginLoc(),\n             diag::err_opencl_builtin_expected_type)\n          << TheCall->getDirectCallee() << \"integer\";\n      return true;\n    }\n    // check remaining common arguments.\n    Expr *Arg4 = TheCall->getArg(4);\n    Expr *Arg5 = TheCall->getArg(5);\n\n    // Fifth argument is always passed as a pointer to clk_event_t.\n    if (!Arg4->isNullPointerConstant(S.Context,\n                                     Expr::NPC_ValueDependentIsNotNull) &&\n        !Arg4->getType()->getPointeeOrArrayElementType()->isClkEventT()) {\n      S.Diag(TheCall->getArg(4)->getBeginLoc(),\n             diag::err_opencl_builtin_expected_type)\n          << TheCall->getDirectCallee()\n          << S.Context.getPointerType(S.Context.OCLClkEventTy);\n      return true;\n    }\n\n    // Sixth argument is always passed as a pointer to clk_event_t.\n    if (!Arg5->isNullPointerConstant(S.Context,\n                                     Expr::NPC_ValueDependentIsNotNull) &&\n        !(Arg5->getType()->isPointerType() &&\n          Arg5->getType()->getPointeeType()->isClkEventT())) {\n      S.Diag(TheCall->getArg(5)->getBeginLoc(),\n             diag::err_opencl_builtin_expected_type)\n          << TheCall->getDirectCallee()\n          << S.Context.getPointerType(S.Context.OCLClkEventTy);\n      return true;\n    }\n\n    if (NumArgs == 7)\n      return false;\n\n    return checkOpenCLEnqueueVariadicArgs(S, TheCall, Arg6, 7);\n  }\n\n  // None of the specific case has been detected, give generic error\n  S.Diag(TheCall->getBeginLoc(),\n         diag::err_opencl_enqueue_kernel_incorrect_args);\n  return true;\n}\n\n/// Returns OpenCL access qual.\nstatic OpenCLAccessAttr *getOpenCLArgAccess(const Decl *D) {\n    return D->getAttr<OpenCLAccessAttr>();\n}\n\n/// Returns true if pipe element type is different from the pointer.\nstatic bool checkOpenCLPipeArg(Sema &S, CallExpr *Call) {\n  const Expr *Arg0 = Call->getArg(0);\n  // First argument type should always be pipe.\n  if (!Arg0->getType()->isPipeType()) {\n    S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_pipe_first_arg)\n        << Call->getDirectCallee() << Arg0->getSourceRange();\n    return true;\n  }\n  OpenCLAccessAttr *AccessQual =\n      getOpenCLArgAccess(cast<DeclRefExpr>(Arg0)->getDecl());\n  // Validates the access qualifier is compatible with the call.\n  // OpenCL v2.0 s6.13.16 - The access qualifiers for pipe should only be\n  // read_only and write_only, and assumed to be read_only if no qualifier is\n  // specified.\n  switch (Call->getDirectCallee()->getBuiltinID()) {\n  case Builtin::BIread_pipe:\n  case Builtin::BIreserve_read_pipe:\n  case Builtin::BIcommit_read_pipe:\n  case Builtin::BIwork_group_reserve_read_pipe:\n  case Builtin::BIsub_group_reserve_read_pipe:\n  case Builtin::BIwork_group_commit_read_pipe:\n  case Builtin::BIsub_group_commit_read_pipe:\n    if (!(!AccessQual || AccessQual->isReadOnly())) {\n      S.Diag(Arg0->getBeginLoc(),\n             diag::err_opencl_builtin_pipe_invalid_access_modifier)\n          << \"read_only\" << Arg0->getSourceRange();\n      return true;\n    }\n    break;\n  case Builtin::BIwrite_pipe:\n  case Builtin::BIreserve_write_pipe:\n  case Builtin::BIcommit_write_pipe:\n  case Builtin::BIwork_group_reserve_write_pipe:\n  case Builtin::BIsub_group_reserve_write_pipe:\n  case Builtin::BIwork_group_commit_write_pipe:\n  case Builtin::BIsub_group_commit_write_pipe:\n    if (!(AccessQual && AccessQual->isWriteOnly())) {\n      S.Diag(Arg0->getBeginLoc(),\n             diag::err_opencl_builtin_pipe_invalid_access_modifier)\n          << \"write_only\" << Arg0->getSourceRange();\n      return true;\n    }\n    break;\n  default:\n    break;\n  }\n  return false;\n}\n\n/// Returns true if pipe element type is different from the pointer.\nstatic bool checkOpenCLPipePacketType(Sema &S, CallExpr *Call, unsigned Idx) {\n  const Expr *Arg0 = Call->getArg(0);\n  const Expr *ArgIdx = Call->getArg(Idx);\n  const PipeType *PipeTy = cast<PipeType>(Arg0->getType());\n  const QualType EltTy = PipeTy->getElementType();\n  const PointerType *ArgTy = ArgIdx->getType()->getAs<PointerType>();\n  // The Idx argument should be a pointer and the type of the pointer and\n  // the type of pipe element should also be the same.\n  if (!ArgTy ||\n      !S.Context.hasSameType(\n          EltTy, ArgTy->getPointeeType()->getCanonicalTypeInternal())) {\n    S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_pipe_invalid_arg)\n        << Call->getDirectCallee() << S.Context.getPointerType(EltTy)\n        << ArgIdx->getType() << ArgIdx->getSourceRange();\n    return true;\n  }\n  return false;\n}\n\n// Performs semantic analysis for the read/write_pipe call.\n// \\param S Reference to the semantic analyzer.\n// \\param Call A pointer to the builtin call.\n// \\return True if a semantic error has been found, false otherwise.\nstatic bool SemaBuiltinRWPipe(Sema &S, CallExpr *Call) {\n  // OpenCL v2.0 s6.13.16.2 - The built-in read/write\n  // functions have two forms.\n  switch (Call->getNumArgs()) {\n  case 2:\n    if (checkOpenCLPipeArg(S, Call))\n      return true;\n    // The call with 2 arguments should be\n    // read/write_pipe(pipe T, T*).\n    // Check packet type T.\n    if (checkOpenCLPipePacketType(S, Call, 1))\n      return true;\n    break;\n\n  case 4: {\n    if (checkOpenCLPipeArg(S, Call))\n      return true;\n    // The call with 4 arguments should be\n    // read/write_pipe(pipe T, reserve_id_t, uint, T*).\n    // Check reserve_id_t.\n    if (!Call->getArg(1)->getType()->isReserveIDT()) {\n      S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_pipe_invalid_arg)\n          << Call->getDirectCallee() << S.Context.OCLReserveIDTy\n          << Call->getArg(1)->getType() << Call->getArg(1)->getSourceRange();\n      return true;\n    }\n\n    // Check the index.\n    const Expr *Arg2 = Call->getArg(2);\n    if (!Arg2->getType()->isIntegerType() &&\n        !Arg2->getType()->isUnsignedIntegerType()) {\n      S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_pipe_invalid_arg)\n          << Call->getDirectCallee() << S.Context.UnsignedIntTy\n          << Arg2->getType() << Arg2->getSourceRange();\n      return true;\n    }\n\n    // Check packet type T.\n    if (checkOpenCLPipePacketType(S, Call, 3))\n      return true;\n  } break;\n  default:\n    S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_pipe_arg_num)\n        << Call->getDirectCallee() << Call->getSourceRange();\n    return true;\n  }\n\n  return false;\n}\n\n// Performs a semantic analysis on the {work_group_/sub_group_\n//        /_}reserve_{read/write}_pipe\n// \\param S Reference to the semantic analyzer.\n// \\param Call The call to the builtin function to be analyzed.\n// \\return True if a semantic error was found, false otherwise.\nstatic bool SemaBuiltinReserveRWPipe(Sema &S, CallExpr *Call) {\n  if (checkArgCount(S, Call, 2))\n    return true;\n\n  if (checkOpenCLPipeArg(S, Call))\n    return true;\n\n  // Check the reserve size.\n  if (!Call->getArg(1)->getType()->isIntegerType() &&\n      !Call->getArg(1)->getType()->isUnsignedIntegerType()) {\n    S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_pipe_invalid_arg)\n        << Call->getDirectCallee() << S.Context.UnsignedIntTy\n        << Call->getArg(1)->getType() << Call->getArg(1)->getSourceRange();\n    return true;\n  }\n\n  // Since return type of reserve_read/write_pipe built-in function is\n  // reserve_id_t, which is not defined in the builtin def file , we used int\n  // as return type and need to override the return type of these functions.\n  Call->setType(S.Context.OCLReserveIDTy);\n\n  return false;\n}\n\n// Performs a semantic analysis on {work_group_/sub_group_\n//        /_}commit_{read/write}_pipe\n// \\param S Reference to the semantic analyzer.\n// \\param Call The call to the builtin function to be analyzed.\n// \\return True if a semantic error was found, false otherwise.\nstatic bool SemaBuiltinCommitRWPipe(Sema &S, CallExpr *Call) {\n  if (checkArgCount(S, Call, 2))\n    return true;\n\n  if (checkOpenCLPipeArg(S, Call))\n    return true;\n\n  // Check reserve_id_t.\n  if (!Call->getArg(1)->getType()->isReserveIDT()) {\n    S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_pipe_invalid_arg)\n        << Call->getDirectCallee() << S.Context.OCLReserveIDTy\n        << Call->getArg(1)->getType() << Call->getArg(1)->getSourceRange();\n    return true;\n  }\n\n  return false;\n}\n\n// Performs a semantic analysis on the call to built-in Pipe\n//        Query Functions.\n// \\param S Reference to the semantic analyzer.\n// \\param Call The call to the builtin function to be analyzed.\n// \\return True if a semantic error was found, false otherwise.\nstatic bool SemaBuiltinPipePackets(Sema &S, CallExpr *Call) {\n  if (checkArgCount(S, Call, 1))\n    return true;\n\n  if (!Call->getArg(0)->getType()->isPipeType()) {\n    S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_pipe_first_arg)\n        << Call->getDirectCallee() << Call->getArg(0)->getSourceRange();\n    return true;\n  }\n\n  return false;\n}\n\n// OpenCL v2.0 s6.13.9 - Address space qualifier functions.\n// Performs semantic analysis for the to_global/local/private call.\n// \\param S Reference to the semantic analyzer.\n// \\param BuiltinID ID of the builtin function.\n// \\param Call A pointer to the builtin call.\n// \\return True if a semantic error has been found, false otherwise.\nstatic bool SemaOpenCLBuiltinToAddr(Sema &S, unsigned BuiltinID,\n                                    CallExpr *Call) {\n  if (checkArgCount(S, Call, 1))\n    return true;\n\n  auto RT = Call->getArg(0)->getType();\n  if (!RT->isPointerType() || RT->getPointeeType()\n      .getAddressSpace() == LangAS::opencl_constant) {\n    S.Diag(Call->getBeginLoc(), diag::err_opencl_builtin_to_addr_invalid_arg)\n        << Call->getArg(0) << Call->getDirectCallee() << Call->getSourceRange();\n    return true;\n  }\n\n  if (RT->getPointeeType().getAddressSpace() != LangAS::opencl_generic) {\n    S.Diag(Call->getArg(0)->getBeginLoc(),\n           diag::warn_opencl_generic_address_space_arg)\n        << Call->getDirectCallee()->getNameInfo().getAsString()\n        << Call->getArg(0)->getSourceRange();\n  }\n\n  RT = RT->getPointeeType();\n  auto Qual = RT.getQualifiers();\n  switch (BuiltinID) {\n  case Builtin::BIto_global:\n    Qual.setAddressSpace(LangAS::opencl_global);\n    break;\n  case Builtin::BIto_local:\n    Qual.setAddressSpace(LangAS::opencl_local);\n    break;\n  case Builtin::BIto_private:\n    Qual.setAddressSpace(LangAS::opencl_private);\n    break;\n  default:\n    llvm_unreachable(\"Invalid builtin function\");\n  }\n  Call->setType(S.Context.getPointerType(S.Context.getQualifiedType(\n      RT.getUnqualifiedType(), Qual)));\n\n  return false;\n}\n\nstatic ExprResult SemaBuiltinLaunder(Sema &S, CallExpr *TheCall) {\n  if (checkArgCount(S, TheCall, 1))\n    return ExprError();\n\n  // Compute __builtin_launder's parameter type from the argument.\n  // The parameter type is:\n  //  * The type of the argument if it's not an array or function type,\n  //  Otherwise,\n  //  * The decayed argument type.\n  QualType ParamTy = [&]() {\n    QualType ArgTy = TheCall->getArg(0)->getType();\n    if (const ArrayType *Ty = ArgTy->getAsArrayTypeUnsafe())\n      return S.Context.getPointerType(Ty->getElementType());\n    if (ArgTy->isFunctionType()) {\n      return S.Context.getPointerType(ArgTy);\n    }\n    return ArgTy;\n  }();\n\n  TheCall->setType(ParamTy);\n\n  auto DiagSelect = [&]() -> llvm::Optional<unsigned> {\n    if (!ParamTy->isPointerType())\n      return 0;\n    if (ParamTy->isFunctionPointerType())\n      return 1;\n    if (ParamTy->isVoidPointerType())\n      return 2;\n    return llvm::Optional<unsigned>{};\n  }();\n  if (DiagSelect.hasValue()) {\n    S.Diag(TheCall->getBeginLoc(), diag::err_builtin_launder_invalid_arg)\n        << DiagSelect.getValue() << TheCall->getSourceRange();\n    return ExprError();\n  }\n\n  // We either have an incomplete class type, or we have a class template\n  // whose instantiation has not been forced. Example:\n  //\n  //   template <class T> struct Foo { T value; };\n  //   Foo<int> *p = nullptr;\n  //   auto *d = __builtin_launder(p);\n  if (S.RequireCompleteType(TheCall->getBeginLoc(), ParamTy->getPointeeType(),\n                            diag::err_incomplete_type))\n    return ExprError();\n\n  assert(ParamTy->getPointeeType()->isObjectType() &&\n         \"Unhandled non-object pointer case\");\n\n  InitializedEntity Entity =\n      InitializedEntity::InitializeParameter(S.Context, ParamTy, false);\n  ExprResult Arg =\n      S.PerformCopyInitialization(Entity, SourceLocation(), TheCall->getArg(0));\n  if (Arg.isInvalid())\n    return ExprError();\n  TheCall->setArg(0, Arg.get());\n\n  return TheCall;\n}\n\n// Emit an error and return true if the current architecture is not in the list\n// of supported architectures.\nstatic bool\nCheckBuiltinTargetSupport(Sema &S, unsigned BuiltinID, CallExpr *TheCall,\n                          ArrayRef<llvm::Triple::ArchType> SupportedArchs) {\n  llvm::Triple::ArchType CurArch =\n      S.getASTContext().getTargetInfo().getTriple().getArch();\n  if (llvm::is_contained(SupportedArchs, CurArch))\n    return false;\n  S.Diag(TheCall->getBeginLoc(), diag::err_builtin_target_unsupported)\n      << TheCall->getSourceRange();\n  return true;\n}\n\nstatic void CheckNonNullArgument(Sema &S, const Expr *ArgExpr,\n                                 SourceLocation CallSiteLoc);\n\nbool Sema::CheckTSBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                      CallExpr *TheCall) {\n  switch (TI.getTriple().getArch()) {\n  default:\n    // Some builtins don't require additional checking, so just consider these\n    // acceptable.\n    return false;\n  case llvm::Triple::arm:\n  case llvm::Triple::armeb:\n  case llvm::Triple::thumb:\n  case llvm::Triple::thumbeb:\n    return CheckARMBuiltinFunctionCall(TI, BuiltinID, TheCall);\n  case llvm::Triple::aarch64:\n  case llvm::Triple::aarch64_32:\n  case llvm::Triple::aarch64_be:\n    return CheckAArch64BuiltinFunctionCall(TI, BuiltinID, TheCall);\n  case llvm::Triple::bpfeb:\n  case llvm::Triple::bpfel:\n    return CheckBPFBuiltinFunctionCall(BuiltinID, TheCall);\n  case llvm::Triple::hexagon:\n    return CheckHexagonBuiltinFunctionCall(BuiltinID, TheCall);\n  case llvm::Triple::mips:\n  case llvm::Triple::mipsel:\n  case llvm::Triple::mips64:\n  case llvm::Triple::mips64el:\n    return CheckMipsBuiltinFunctionCall(TI, BuiltinID, TheCall);\n  case llvm::Triple::systemz:\n    return CheckSystemZBuiltinFunctionCall(BuiltinID, TheCall);\n  case llvm::Triple::x86:\n  case llvm::Triple::x86_64:\n    return CheckX86BuiltinFunctionCall(TI, BuiltinID, TheCall);\n  case llvm::Triple::ppc:\n  case llvm::Triple::ppcle:\n  case llvm::Triple::ppc64:\n  case llvm::Triple::ppc64le:\n    return CheckPPCBuiltinFunctionCall(TI, BuiltinID, TheCall);\n  case llvm::Triple::amdgcn:\n    return CheckAMDGCNBuiltinFunctionCall(BuiltinID, TheCall);\n  case llvm::Triple::riscv32:\n  case llvm::Triple::riscv64:\n    return CheckRISCVBuiltinFunctionCall(TI, BuiltinID, TheCall);\n  }\n}\n\nExprResult\nSema::CheckBuiltinFunctionCall(FunctionDecl *FDecl, unsigned BuiltinID,\n                               CallExpr *TheCall) {\n  ExprResult TheCallResult(TheCall);\n\n  // Find out if any arguments are required to be integer constant expressions.\n  unsigned ICEArguments = 0;\n  ASTContext::GetBuiltinTypeError Error;\n  Context.GetBuiltinType(BuiltinID, Error, &ICEArguments);\n  if (Error != ASTContext::GE_None)\n    ICEArguments = 0;  // Don't diagnose previously diagnosed errors.\n\n  // If any arguments are required to be ICE's, check and diagnose.\n  for (unsigned ArgNo = 0; ICEArguments != 0; ++ArgNo) {\n    // Skip arguments not required to be ICE's.\n    if ((ICEArguments & (1 << ArgNo)) == 0) continue;\n\n    llvm::APSInt Result;\n    if (SemaBuiltinConstantArg(TheCall, ArgNo, Result))\n      return true;\n    ICEArguments &= ~(1 << ArgNo);\n  }\n\n  switch (BuiltinID) {\n  case Builtin::BI__builtin___CFStringMakeConstantString:\n    assert(TheCall->getNumArgs() == 1 &&\n           \"Wrong # arguments to builtin CFStringMakeConstantString\");\n    if (CheckObjCString(TheCall->getArg(0)))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_ms_va_start:\n  case Builtin::BI__builtin_stdarg_start:\n  case Builtin::BI__builtin_va_start:\n    if (SemaBuiltinVAStart(BuiltinID, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__va_start: {\n    switch (Context.getTargetInfo().getTriple().getArch()) {\n    case llvm::Triple::aarch64:\n    case llvm::Triple::arm:\n    case llvm::Triple::thumb:\n      if (SemaBuiltinVAStartARMMicrosoft(TheCall))\n        return ExprError();\n      break;\n    default:\n      if (SemaBuiltinVAStart(BuiltinID, TheCall))\n        return ExprError();\n      break;\n    }\n    break;\n  }\n\n  // The acquire, release, and no fence variants are ARM and AArch64 only.\n  case Builtin::BI_interlockedbittestandset_acq:\n  case Builtin::BI_interlockedbittestandset_rel:\n  case Builtin::BI_interlockedbittestandset_nf:\n  case Builtin::BI_interlockedbittestandreset_acq:\n  case Builtin::BI_interlockedbittestandreset_rel:\n  case Builtin::BI_interlockedbittestandreset_nf:\n    if (CheckBuiltinTargetSupport(\n            *this, BuiltinID, TheCall,\n            {llvm::Triple::arm, llvm::Triple::thumb, llvm::Triple::aarch64}))\n      return ExprError();\n    break;\n\n  // The 64-bit bittest variants are x64, ARM, and AArch64 only.\n  case Builtin::BI_bittest64:\n  case Builtin::BI_bittestandcomplement64:\n  case Builtin::BI_bittestandreset64:\n  case Builtin::BI_bittestandset64:\n  case Builtin::BI_interlockedbittestandreset64:\n  case Builtin::BI_interlockedbittestandset64:\n    if (CheckBuiltinTargetSupport(*this, BuiltinID, TheCall,\n                                  {llvm::Triple::x86_64, llvm::Triple::arm,\n                                   llvm::Triple::thumb, llvm::Triple::aarch64}))\n      return ExprError();\n    break;\n\n  case Builtin::BI__builtin_isgreater:\n  case Builtin::BI__builtin_isgreaterequal:\n  case Builtin::BI__builtin_isless:\n  case Builtin::BI__builtin_islessequal:\n  case Builtin::BI__builtin_islessgreater:\n  case Builtin::BI__builtin_isunordered:\n    if (SemaBuiltinUnorderedCompare(TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_fpclassify:\n    if (SemaBuiltinFPClassification(TheCall, 6))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_isfinite:\n  case Builtin::BI__builtin_isinf:\n  case Builtin::BI__builtin_isinf_sign:\n  case Builtin::BI__builtin_isnan:\n  case Builtin::BI__builtin_isnormal:\n  case Builtin::BI__builtin_signbit:\n  case Builtin::BI__builtin_signbitf:\n  case Builtin::BI__builtin_signbitl:\n    if (SemaBuiltinFPClassification(TheCall, 1))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_shufflevector:\n    return SemaBuiltinShuffleVector(TheCall);\n    // TheCall will be freed by the smart pointer here, but that's fine, since\n    // SemaBuiltinShuffleVector guts it, but then doesn't release it.\n  case Builtin::BI__builtin_prefetch:\n    if (SemaBuiltinPrefetch(TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_alloca_with_align:\n    if (SemaBuiltinAllocaWithAlign(TheCall))\n      return ExprError();\n    LLVM_FALLTHROUGH;\n  case Builtin::BI__builtin_alloca:\n    Diag(TheCall->getBeginLoc(), diag::warn_alloca)\n        << TheCall->getDirectCallee();\n    break;\n  case Builtin::BI__assume:\n  case Builtin::BI__builtin_assume:\n    if (SemaBuiltinAssume(TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_assume_aligned:\n    if (SemaBuiltinAssumeAligned(TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_dynamic_object_size:\n  case Builtin::BI__builtin_object_size:\n    if (SemaBuiltinConstantArgRange(TheCall, 1, 0, 3))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_longjmp:\n    if (SemaBuiltinLongjmp(TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_setjmp:\n    if (SemaBuiltinSetjmp(TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_classify_type:\n    if (checkArgCount(*this, TheCall, 1)) return true;\n    TheCall->setType(Context.IntTy);\n    break;\n  case Builtin::BI__builtin_complex:\n    if (SemaBuiltinComplex(TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_constant_p: {\n    if (checkArgCount(*this, TheCall, 1)) return true;\n    ExprResult Arg = DefaultFunctionArrayLvalueConversion(TheCall->getArg(0));\n    if (Arg.isInvalid()) return true;\n    TheCall->setArg(0, Arg.get());\n    TheCall->setType(Context.IntTy);\n    break;\n  }\n  case Builtin::BI__builtin_launder:\n    return SemaBuiltinLaunder(*this, TheCall);\n  case Builtin::BI__sync_fetch_and_add:\n  case Builtin::BI__sync_fetch_and_add_1:\n  case Builtin::BI__sync_fetch_and_add_2:\n  case Builtin::BI__sync_fetch_and_add_4:\n  case Builtin::BI__sync_fetch_and_add_8:\n  case Builtin::BI__sync_fetch_and_add_16:\n  case Builtin::BI__sync_fetch_and_sub:\n  case Builtin::BI__sync_fetch_and_sub_1:\n  case Builtin::BI__sync_fetch_and_sub_2:\n  case Builtin::BI__sync_fetch_and_sub_4:\n  case Builtin::BI__sync_fetch_and_sub_8:\n  case Builtin::BI__sync_fetch_and_sub_16:\n  case Builtin::BI__sync_fetch_and_or:\n  case Builtin::BI__sync_fetch_and_or_1:\n  case Builtin::BI__sync_fetch_and_or_2:\n  case Builtin::BI__sync_fetch_and_or_4:\n  case Builtin::BI__sync_fetch_and_or_8:\n  case Builtin::BI__sync_fetch_and_or_16:\n  case Builtin::BI__sync_fetch_and_and:\n  case Builtin::BI__sync_fetch_and_and_1:\n  case Builtin::BI__sync_fetch_and_and_2:\n  case Builtin::BI__sync_fetch_and_and_4:\n  case Builtin::BI__sync_fetch_and_and_8:\n  case Builtin::BI__sync_fetch_and_and_16:\n  case Builtin::BI__sync_fetch_and_xor:\n  case Builtin::BI__sync_fetch_and_xor_1:\n  case Builtin::BI__sync_fetch_and_xor_2:\n  case Builtin::BI__sync_fetch_and_xor_4:\n  case Builtin::BI__sync_fetch_and_xor_8:\n  case Builtin::BI__sync_fetch_and_xor_16:\n  case Builtin::BI__sync_fetch_and_nand:\n  case Builtin::BI__sync_fetch_and_nand_1:\n  case Builtin::BI__sync_fetch_and_nand_2:\n  case Builtin::BI__sync_fetch_and_nand_4:\n  case Builtin::BI__sync_fetch_and_nand_8:\n  case Builtin::BI__sync_fetch_and_nand_16:\n  case Builtin::BI__sync_add_and_fetch:\n  case Builtin::BI__sync_add_and_fetch_1:\n  case Builtin::BI__sync_add_and_fetch_2:\n  case Builtin::BI__sync_add_and_fetch_4:\n  case Builtin::BI__sync_add_and_fetch_8:\n  case Builtin::BI__sync_add_and_fetch_16:\n  case Builtin::BI__sync_sub_and_fetch:\n  case Builtin::BI__sync_sub_and_fetch_1:\n  case Builtin::BI__sync_sub_and_fetch_2:\n  case Builtin::BI__sync_sub_and_fetch_4:\n  case Builtin::BI__sync_sub_and_fetch_8:\n  case Builtin::BI__sync_sub_and_fetch_16:\n  case Builtin::BI__sync_and_and_fetch:\n  case Builtin::BI__sync_and_and_fetch_1:\n  case Builtin::BI__sync_and_and_fetch_2:\n  case Builtin::BI__sync_and_and_fetch_4:\n  case Builtin::BI__sync_and_and_fetch_8:\n  case Builtin::BI__sync_and_and_fetch_16:\n  case Builtin::BI__sync_or_and_fetch:\n  case Builtin::BI__sync_or_and_fetch_1:\n  case Builtin::BI__sync_or_and_fetch_2:\n  case Builtin::BI__sync_or_and_fetch_4:\n  case Builtin::BI__sync_or_and_fetch_8:\n  case Builtin::BI__sync_or_and_fetch_16:\n  case Builtin::BI__sync_xor_and_fetch:\n  case Builtin::BI__sync_xor_and_fetch_1:\n  case Builtin::BI__sync_xor_and_fetch_2:\n  case Builtin::BI__sync_xor_and_fetch_4:\n  case Builtin::BI__sync_xor_and_fetch_8:\n  case Builtin::BI__sync_xor_and_fetch_16:\n  case Builtin::BI__sync_nand_and_fetch:\n  case Builtin::BI__sync_nand_and_fetch_1:\n  case Builtin::BI__sync_nand_and_fetch_2:\n  case Builtin::BI__sync_nand_and_fetch_4:\n  case Builtin::BI__sync_nand_and_fetch_8:\n  case Builtin::BI__sync_nand_and_fetch_16:\n  case Builtin::BI__sync_val_compare_and_swap:\n  case Builtin::BI__sync_val_compare_and_swap_1:\n  case Builtin::BI__sync_val_compare_and_swap_2:\n  case Builtin::BI__sync_val_compare_and_swap_4:\n  case Builtin::BI__sync_val_compare_and_swap_8:\n  case Builtin::BI__sync_val_compare_and_swap_16:\n  case Builtin::BI__sync_bool_compare_and_swap:\n  case Builtin::BI__sync_bool_compare_and_swap_1:\n  case Builtin::BI__sync_bool_compare_and_swap_2:\n  case Builtin::BI__sync_bool_compare_and_swap_4:\n  case Builtin::BI__sync_bool_compare_and_swap_8:\n  case Builtin::BI__sync_bool_compare_and_swap_16:\n  case Builtin::BI__sync_lock_test_and_set:\n  case Builtin::BI__sync_lock_test_and_set_1:\n  case Builtin::BI__sync_lock_test_and_set_2:\n  case Builtin::BI__sync_lock_test_and_set_4:\n  case Builtin::BI__sync_lock_test_and_set_8:\n  case Builtin::BI__sync_lock_test_and_set_16:\n  case Builtin::BI__sync_lock_release:\n  case Builtin::BI__sync_lock_release_1:\n  case Builtin::BI__sync_lock_release_2:\n  case Builtin::BI__sync_lock_release_4:\n  case Builtin::BI__sync_lock_release_8:\n  case Builtin::BI__sync_lock_release_16:\n  case Builtin::BI__sync_swap:\n  case Builtin::BI__sync_swap_1:\n  case Builtin::BI__sync_swap_2:\n  case Builtin::BI__sync_swap_4:\n  case Builtin::BI__sync_swap_8:\n  case Builtin::BI__sync_swap_16:\n    return SemaBuiltinAtomicOverloaded(TheCallResult);\n  case Builtin::BI__sync_synchronize:\n    Diag(TheCall->getBeginLoc(), diag::warn_atomic_implicit_seq_cst)\n        << TheCall->getCallee()->getSourceRange();\n    break;\n  case Builtin::BI__builtin_nontemporal_load:\n  case Builtin::BI__builtin_nontemporal_store:\n    return SemaBuiltinNontemporalOverloaded(TheCallResult);\n  case Builtin::BI__builtin_memcpy_inline: {\n    clang::Expr *SizeOp = TheCall->getArg(2);\n    // We warn about copying to or from `nullptr` pointers when `size` is\n    // greater than 0. When `size` is value dependent we cannot evaluate its\n    // value so we bail out.\n    if (SizeOp->isValueDependent())\n      break;\n    if (!SizeOp->EvaluateKnownConstInt(Context).isNullValue()) {\n      CheckNonNullArgument(*this, TheCall->getArg(0), TheCall->getExprLoc());\n      CheckNonNullArgument(*this, TheCall->getArg(1), TheCall->getExprLoc());\n    }\n    break;\n  }\n#define BUILTIN(ID, TYPE, ATTRS)\n#define ATOMIC_BUILTIN(ID, TYPE, ATTRS) \\\n  case Builtin::BI##ID: \\\n    return SemaAtomicOpsOverloaded(TheCallResult, AtomicExpr::AO##ID);\n#include \"clang/Basic/Builtins.def\"\n  case Builtin::BI__annotation:\n    if (SemaBuiltinMSVCAnnotation(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_annotation:\n    if (SemaBuiltinAnnotation(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_addressof:\n    if (SemaBuiltinAddressof(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_is_aligned:\n  case Builtin::BI__builtin_align_up:\n  case Builtin::BI__builtin_align_down:\n    if (SemaBuiltinAlignment(*this, TheCall, BuiltinID))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_add_overflow:\n  case Builtin::BI__builtin_sub_overflow:\n  case Builtin::BI__builtin_mul_overflow:\n    if (SemaBuiltinOverflow(*this, TheCall, BuiltinID))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_operator_new:\n  case Builtin::BI__builtin_operator_delete: {\n    bool IsDelete = BuiltinID == Builtin::BI__builtin_operator_delete;\n    ExprResult Res =\n        SemaBuiltinOperatorNewDeleteOverloaded(TheCallResult, IsDelete);\n    if (Res.isInvalid())\n      CorrectDelayedTyposInExpr(TheCallResult.get());\n    return Res;\n  }\n  case Builtin::BI__builtin_dump_struct: {\n    // We first want to ensure we are called with 2 arguments\n    if (checkArgCount(*this, TheCall, 2))\n      return ExprError();\n    // Ensure that the first argument is of type 'struct XX *'\n    const Expr *PtrArg = TheCall->getArg(0)->IgnoreParenImpCasts();\n    const QualType PtrArgType = PtrArg->getType();\n    if (!PtrArgType->isPointerType() ||\n        !PtrArgType->getPointeeType()->isRecordType()) {\n      Diag(PtrArg->getBeginLoc(), diag::err_typecheck_convert_incompatible)\n          << PtrArgType << \"structure pointer\" << 1 << 0 << 3 << 1 << PtrArgType\n          << \"structure pointer\";\n      return ExprError();\n    }\n\n    // Ensure that the second argument is of type 'FunctionType'\n    const Expr *FnPtrArg = TheCall->getArg(1)->IgnoreImpCasts();\n    const QualType FnPtrArgType = FnPtrArg->getType();\n    if (!FnPtrArgType->isPointerType()) {\n      Diag(FnPtrArg->getBeginLoc(), diag::err_typecheck_convert_incompatible)\n          << FnPtrArgType << \"'int (*)(const char *, ...)'\" << 1 << 0 << 3 << 2\n          << FnPtrArgType << \"'int (*)(const char *, ...)'\";\n      return ExprError();\n    }\n\n    const auto *FuncType =\n        FnPtrArgType->getPointeeType()->getAs<FunctionType>();\n\n    if (!FuncType) {\n      Diag(FnPtrArg->getBeginLoc(), diag::err_typecheck_convert_incompatible)\n          << FnPtrArgType << \"'int (*)(const char *, ...)'\" << 1 << 0 << 3 << 2\n          << FnPtrArgType << \"'int (*)(const char *, ...)'\";\n      return ExprError();\n    }\n\n    if (const auto *FT = dyn_cast<FunctionProtoType>(FuncType)) {\n      if (!FT->getNumParams()) {\n        Diag(FnPtrArg->getBeginLoc(), diag::err_typecheck_convert_incompatible)\n            << FnPtrArgType << \"'int (*)(const char *, ...)'\" << 1 << 0 << 3\n            << 2 << FnPtrArgType << \"'int (*)(const char *, ...)'\";\n        return ExprError();\n      }\n      QualType PT = FT->getParamType(0);\n      if (!FT->isVariadic() || FT->getReturnType() != Context.IntTy ||\n          !PT->isPointerType() || !PT->getPointeeType()->isCharType() ||\n          !PT->getPointeeType().isConstQualified()) {\n        Diag(FnPtrArg->getBeginLoc(), diag::err_typecheck_convert_incompatible)\n            << FnPtrArgType << \"'int (*)(const char *, ...)'\" << 1 << 0 << 3\n            << 2 << FnPtrArgType << \"'int (*)(const char *, ...)'\";\n        return ExprError();\n      }\n    }\n\n    TheCall->setType(Context.IntTy);\n    break;\n  }\n  case Builtin::BI__builtin_expect_with_probability: {\n    // We first want to ensure we are called with 3 arguments\n    if (checkArgCount(*this, TheCall, 3))\n      return ExprError();\n    // then check probability is constant float in range [0.0, 1.0]\n    const Expr *ProbArg = TheCall->getArg(2);\n    SmallVector<PartialDiagnosticAt, 8> Notes;\n    Expr::EvalResult Eval;\n    Eval.Diag = &Notes;\n    if ((!ProbArg->EvaluateAsConstantExpr(Eval, Context)) ||\n        !Eval.Val.isFloat()) {\n      Diag(ProbArg->getBeginLoc(), diag::err_probability_not_constant_float)\n          << ProbArg->getSourceRange();\n      for (const PartialDiagnosticAt &PDiag : Notes)\n        Diag(PDiag.first, PDiag.second);\n      return ExprError();\n    }\n    llvm::APFloat Probability = Eval.Val.getFloat();\n    bool LoseInfo = false;\n    Probability.convert(llvm::APFloat::IEEEdouble(),\n                        llvm::RoundingMode::Dynamic, &LoseInfo);\n    if (!(Probability >= llvm::APFloat(0.0) &&\n          Probability <= llvm::APFloat(1.0))) {\n      Diag(ProbArg->getBeginLoc(), diag::err_probability_out_of_range)\n          << ProbArg->getSourceRange();\n      return ExprError();\n    }\n    break;\n  }\n  case Builtin::BI__builtin_preserve_access_index:\n    if (SemaBuiltinPreserveAI(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_call_with_static_chain:\n    if (SemaBuiltinCallWithStaticChain(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__exception_code:\n  case Builtin::BI_exception_code:\n    if (SemaBuiltinSEHScopeCheck(*this, TheCall, Scope::SEHExceptScope,\n                                 diag::err_seh___except_block))\n      return ExprError();\n    break;\n  case Builtin::BI__exception_info:\n  case Builtin::BI_exception_info:\n    if (SemaBuiltinSEHScopeCheck(*this, TheCall, Scope::SEHFilterScope,\n                                 diag::err_seh___except_filter))\n      return ExprError();\n    break;\n  case Builtin::BI__GetExceptionInfo:\n    if (checkArgCount(*this, TheCall, 1))\n      return ExprError();\n\n    if (CheckCXXThrowOperand(\n            TheCall->getBeginLoc(),\n            Context.getExceptionObjectType(FDecl->getParamDecl(0)->getType()),\n            TheCall))\n      return ExprError();\n\n    TheCall->setType(Context.VoidPtrTy);\n    break;\n  // OpenCL v2.0, s6.13.16 - Pipe functions\n  case Builtin::BIread_pipe:\n  case Builtin::BIwrite_pipe:\n    // Since those two functions are declared with var args, we need a semantic\n    // check for the argument.\n    if (SemaBuiltinRWPipe(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BIreserve_read_pipe:\n  case Builtin::BIreserve_write_pipe:\n  case Builtin::BIwork_group_reserve_read_pipe:\n  case Builtin::BIwork_group_reserve_write_pipe:\n    if (SemaBuiltinReserveRWPipe(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BIsub_group_reserve_read_pipe:\n  case Builtin::BIsub_group_reserve_write_pipe:\n    if (checkOpenCLSubgroupExt(*this, TheCall) ||\n        SemaBuiltinReserveRWPipe(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BIcommit_read_pipe:\n  case Builtin::BIcommit_write_pipe:\n  case Builtin::BIwork_group_commit_read_pipe:\n  case Builtin::BIwork_group_commit_write_pipe:\n    if (SemaBuiltinCommitRWPipe(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BIsub_group_commit_read_pipe:\n  case Builtin::BIsub_group_commit_write_pipe:\n    if (checkOpenCLSubgroupExt(*this, TheCall) ||\n        SemaBuiltinCommitRWPipe(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BIget_pipe_num_packets:\n  case Builtin::BIget_pipe_max_packets:\n    if (SemaBuiltinPipePackets(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BIto_global:\n  case Builtin::BIto_local:\n  case Builtin::BIto_private:\n    if (SemaOpenCLBuiltinToAddr(*this, BuiltinID, TheCall))\n      return ExprError();\n    break;\n  // OpenCL v2.0, s6.13.17 - Enqueue kernel functions.\n  case Builtin::BIenqueue_kernel:\n    if (SemaOpenCLBuiltinEnqueueKernel(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BIget_kernel_work_group_size:\n  case Builtin::BIget_kernel_preferred_work_group_size_multiple:\n    if (SemaOpenCLBuiltinKernelWorkGroupSize(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BIget_kernel_max_sub_group_size_for_ndrange:\n  case Builtin::BIget_kernel_sub_group_count_for_ndrange:\n    if (SemaOpenCLBuiltinNDRangeAndBlock(*this, TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_os_log_format:\n    Cleanup.setExprNeedsCleanups(true);\n    LLVM_FALLTHROUGH;\n  case Builtin::BI__builtin_os_log_format_buffer_size:\n    if (SemaBuiltinOSLogFormat(TheCall))\n      return ExprError();\n    break;\n  case Builtin::BI__builtin_frame_address:\n  case Builtin::BI__builtin_return_address: {\n    if (SemaBuiltinConstantArgRange(TheCall, 0, 0, 0xFFFF))\n      return ExprError();\n\n    // -Wframe-address warning if non-zero passed to builtin\n    // return/frame address.\n    Expr::EvalResult Result;\n    if (!TheCall->getArg(0)->isValueDependent() &&\n        TheCall->getArg(0)->EvaluateAsInt(Result, getASTContext()) &&\n        Result.Val.getInt() != 0)\n      Diag(TheCall->getBeginLoc(), diag::warn_frame_address)\n          << ((BuiltinID == Builtin::BI__builtin_return_address)\n                  ? \"__builtin_return_address\"\n                  : \"__builtin_frame_address\")\n          << TheCall->getSourceRange();\n    break;\n  }\n\n  case Builtin::BI__builtin_matrix_transpose:\n    return SemaBuiltinMatrixTranspose(TheCall, TheCallResult);\n\n  case Builtin::BI__builtin_matrix_column_major_load:\n    return SemaBuiltinMatrixColumnMajorLoad(TheCall, TheCallResult);\n\n  case Builtin::BI__builtin_matrix_column_major_store:\n    return SemaBuiltinMatrixColumnMajorStore(TheCall, TheCallResult);\n  }\n\n  // Since the target specific builtins for each arch overlap, only check those\n  // of the arch we are compiling for.\n  if (Context.BuiltinInfo.isTSBuiltin(BuiltinID)) {\n    if (Context.BuiltinInfo.isAuxBuiltinID(BuiltinID)) {\n      assert(Context.getAuxTargetInfo() &&\n             \"Aux Target Builtin, but not an aux target?\");\n\n      if (CheckTSBuiltinFunctionCall(\n              *Context.getAuxTargetInfo(),\n              Context.BuiltinInfo.getAuxBuiltinID(BuiltinID), TheCall))\n        return ExprError();\n    } else {\n      if (CheckTSBuiltinFunctionCall(Context.getTargetInfo(), BuiltinID,\n                                     TheCall))\n        return ExprError();\n    }\n  }\n\n  return TheCallResult;\n}\n\n// Get the valid immediate range for the specified NEON type code.\nstatic unsigned RFT(unsigned t, bool shift = false, bool ForceQuad = false) {\n  NeonTypeFlags Type(t);\n  int IsQuad = ForceQuad ? true : Type.isQuad();\n  switch (Type.getEltType()) {\n  case NeonTypeFlags::Int8:\n  case NeonTypeFlags::Poly8:\n    return shift ? 7 : (8 << IsQuad) - 1;\n  case NeonTypeFlags::Int16:\n  case NeonTypeFlags::Poly16:\n    return shift ? 15 : (4 << IsQuad) - 1;\n  case NeonTypeFlags::Int32:\n    return shift ? 31 : (2 << IsQuad) - 1;\n  case NeonTypeFlags::Int64:\n  case NeonTypeFlags::Poly64:\n    return shift ? 63 : (1 << IsQuad) - 1;\n  case NeonTypeFlags::Poly128:\n    return shift ? 127 : (1 << IsQuad) - 1;\n  case NeonTypeFlags::Float16:\n    assert(!shift && \"cannot shift float types!\");\n    return (4 << IsQuad) - 1;\n  case NeonTypeFlags::Float32:\n    assert(!shift && \"cannot shift float types!\");\n    return (2 << IsQuad) - 1;\n  case NeonTypeFlags::Float64:\n    assert(!shift && \"cannot shift float types!\");\n    return (1 << IsQuad) - 1;\n  case NeonTypeFlags::BFloat16:\n    assert(!shift && \"cannot shift float types!\");\n    return (4 << IsQuad) - 1;\n  }\n  llvm_unreachable(\"Invalid NeonTypeFlag!\");\n}\n\n/// getNeonEltType - Return the QualType corresponding to the elements of\n/// the vector type specified by the NeonTypeFlags.  This is used to check\n/// the pointer arguments for Neon load/store intrinsics.\nstatic QualType getNeonEltType(NeonTypeFlags Flags, ASTContext &Context,\n                               bool IsPolyUnsigned, bool IsInt64Long) {\n  switch (Flags.getEltType()) {\n  case NeonTypeFlags::Int8:\n    return Flags.isUnsigned() ? Context.UnsignedCharTy : Context.SignedCharTy;\n  case NeonTypeFlags::Int16:\n    return Flags.isUnsigned() ? Context.UnsignedShortTy : Context.ShortTy;\n  case NeonTypeFlags::Int32:\n    return Flags.isUnsigned() ? Context.UnsignedIntTy : Context.IntTy;\n  case NeonTypeFlags::Int64:\n    if (IsInt64Long)\n      return Flags.isUnsigned() ? Context.UnsignedLongTy : Context.LongTy;\n    else\n      return Flags.isUnsigned() ? Context.UnsignedLongLongTy\n                                : Context.LongLongTy;\n  case NeonTypeFlags::Poly8:\n    return IsPolyUnsigned ? Context.UnsignedCharTy : Context.SignedCharTy;\n  case NeonTypeFlags::Poly16:\n    return IsPolyUnsigned ? Context.UnsignedShortTy : Context.ShortTy;\n  case NeonTypeFlags::Poly64:\n    if (IsInt64Long)\n      return Context.UnsignedLongTy;\n    else\n      return Context.UnsignedLongLongTy;\n  case NeonTypeFlags::Poly128:\n    break;\n  case NeonTypeFlags::Float16:\n    return Context.HalfTy;\n  case NeonTypeFlags::Float32:\n    return Context.FloatTy;\n  case NeonTypeFlags::Float64:\n    return Context.DoubleTy;\n  case NeonTypeFlags::BFloat16:\n    return Context.BFloat16Ty;\n  }\n  llvm_unreachable(\"Invalid NeonTypeFlag!\");\n}\n\nbool Sema::CheckSVEBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall) {\n  // Range check SVE intrinsics that take immediate values.\n  SmallVector<std::tuple<int,int,int>, 3> ImmChecks;\n\n  switch (BuiltinID) {\n  default:\n    return false;\n#define GET_SVE_IMMEDIATE_CHECK\n#include \"clang/Basic/arm_sve_sema_rangechecks.inc\"\n#undef GET_SVE_IMMEDIATE_CHECK\n  }\n\n  // Perform all the immediate checks for this builtin call.\n  bool HasError = false;\n  for (auto &I : ImmChecks) {\n    int ArgNum, CheckTy, ElementSizeInBits;\n    std::tie(ArgNum, CheckTy, ElementSizeInBits) = I;\n\n    typedef bool(*OptionSetCheckFnTy)(int64_t Value);\n\n    // Function that checks whether the operand (ArgNum) is an immediate\n    // that is one of the predefined values.\n    auto CheckImmediateInSet = [&](OptionSetCheckFnTy CheckImm,\n                                   int ErrDiag) -> bool {\n      // We can't check the value of a dependent argument.\n      Expr *Arg = TheCall->getArg(ArgNum);\n      if (Arg->isTypeDependent() || Arg->isValueDependent())\n        return false;\n\n      // Check constant-ness first.\n      llvm::APSInt Imm;\n      if (SemaBuiltinConstantArg(TheCall, ArgNum, Imm))\n        return true;\n\n      if (!CheckImm(Imm.getSExtValue()))\n        return Diag(TheCall->getBeginLoc(), ErrDiag) << Arg->getSourceRange();\n      return false;\n    };\n\n    switch ((SVETypeFlags::ImmCheckType)CheckTy) {\n    case SVETypeFlags::ImmCheck0_31:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0, 31))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheck0_13:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0, 13))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheck1_16:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 1, 16))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheck0_7:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0, 7))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckExtract:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0,\n                                      (2048 / ElementSizeInBits) - 1))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckShiftRight:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 1, ElementSizeInBits))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckShiftRightNarrow:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 1,\n                                      ElementSizeInBits / 2))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckShiftLeft:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0,\n                                      ElementSizeInBits - 1))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckLaneIndex:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0,\n                                      (128 / (1 * ElementSizeInBits)) - 1))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckLaneIndexCompRotate:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0,\n                                      (128 / (2 * ElementSizeInBits)) - 1))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckLaneIndexDot:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0,\n                                      (128 / (4 * ElementSizeInBits)) - 1))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckComplexRot90_270:\n      if (CheckImmediateInSet([](int64_t V) { return V == 90 || V == 270; },\n                              diag::err_rotation_argument_to_cadd))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheckComplexRotAll90:\n      if (CheckImmediateInSet(\n              [](int64_t V) {\n                return V == 0 || V == 90 || V == 180 || V == 270;\n              },\n              diag::err_rotation_argument_to_cmla))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheck0_1:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0, 1))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheck0_2:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0, 2))\n        HasError = true;\n      break;\n    case SVETypeFlags::ImmCheck0_3:\n      if (SemaBuiltinConstantArgRange(TheCall, ArgNum, 0, 3))\n        HasError = true;\n      break;\n    }\n  }\n\n  return HasError;\n}\n\nbool Sema::CheckNeonBuiltinFunctionCall(const TargetInfo &TI,\n                                        unsigned BuiltinID, CallExpr *TheCall) {\n  llvm::APSInt Result;\n  uint64_t mask = 0;\n  unsigned TV = 0;\n  int PtrArgNum = -1;\n  bool HasConstPtr = false;\n  switch (BuiltinID) {\n#define GET_NEON_OVERLOAD_CHECK\n#include \"clang/Basic/arm_neon.inc\"\n#include \"clang/Basic/arm_fp16.inc\"\n#undef GET_NEON_OVERLOAD_CHECK\n  }\n\n  // For NEON intrinsics which are overloaded on vector element type, validate\n  // the immediate which specifies which variant to emit.\n  unsigned ImmArg = TheCall->getNumArgs()-1;\n  if (mask) {\n    if (SemaBuiltinConstantArg(TheCall, ImmArg, Result))\n      return true;\n\n    TV = Result.getLimitedValue(64);\n    if ((TV > 63) || (mask & (1ULL << TV)) == 0)\n      return Diag(TheCall->getBeginLoc(), diag::err_invalid_neon_type_code)\n             << TheCall->getArg(ImmArg)->getSourceRange();\n  }\n\n  if (PtrArgNum >= 0) {\n    // Check that pointer arguments have the specified type.\n    Expr *Arg = TheCall->getArg(PtrArgNum);\n    if (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(Arg))\n      Arg = ICE->getSubExpr();\n    ExprResult RHS = DefaultFunctionArrayLvalueConversion(Arg);\n    QualType RHSTy = RHS.get()->getType();\n\n    llvm::Triple::ArchType Arch = TI.getTriple().getArch();\n    bool IsPolyUnsigned = Arch == llvm::Triple::aarch64 ||\n                          Arch == llvm::Triple::aarch64_32 ||\n                          Arch == llvm::Triple::aarch64_be;\n    bool IsInt64Long = TI.getInt64Type() == TargetInfo::SignedLong;\n    QualType EltTy =\n        getNeonEltType(NeonTypeFlags(TV), Context, IsPolyUnsigned, IsInt64Long);\n    if (HasConstPtr)\n      EltTy = EltTy.withConst();\n    QualType LHSTy = Context.getPointerType(EltTy);\n    AssignConvertType ConvTy;\n    ConvTy = CheckSingleAssignmentConstraints(LHSTy, RHS);\n    if (RHS.isInvalid())\n      return true;\n    if (DiagnoseAssignmentResult(ConvTy, Arg->getBeginLoc(), LHSTy, RHSTy,\n                                 RHS.get(), AA_Assigning))\n      return true;\n  }\n\n  // For NEON intrinsics which take an immediate value as part of the\n  // instruction, range check them here.\n  unsigned i = 0, l = 0, u = 0;\n  switch (BuiltinID) {\n  default:\n    return false;\n  #define GET_NEON_IMMEDIATE_CHECK\n  #include \"clang/Basic/arm_neon.inc\"\n  #include \"clang/Basic/arm_fp16.inc\"\n  #undef GET_NEON_IMMEDIATE_CHECK\n  }\n\n  return SemaBuiltinConstantArgRange(TheCall, i, l, u + l);\n}\n\nbool Sema::CheckMVEBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall) {\n  switch (BuiltinID) {\n  default:\n    return false;\n  #include \"clang/Basic/arm_mve_builtin_sema.inc\"\n  }\n}\n\nbool Sema::CheckCDEBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                       CallExpr *TheCall) {\n  bool Err = false;\n  switch (BuiltinID) {\n  default:\n    return false;\n#include \"clang/Basic/arm_cde_builtin_sema.inc\"\n  }\n\n  if (Err)\n    return true;\n\n  return CheckARMCoprocessorImmediate(TI, TheCall->getArg(0), /*WantCDE*/ true);\n}\n\nbool Sema::CheckARMCoprocessorImmediate(const TargetInfo &TI,\n                                        const Expr *CoprocArg, bool WantCDE) {\n  if (isConstantEvaluated())\n    return false;\n\n  // We can't check the value of a dependent argument.\n  if (CoprocArg->isTypeDependent() || CoprocArg->isValueDependent())\n    return false;\n\n  llvm::APSInt CoprocNoAP = *CoprocArg->getIntegerConstantExpr(Context);\n  int64_t CoprocNo = CoprocNoAP.getExtValue();\n  assert(CoprocNo >= 0 && \"Coprocessor immediate must be non-negative\");\n\n  uint32_t CDECoprocMask = TI.getARMCDECoprocMask();\n  bool IsCDECoproc = CoprocNo <= 7 && (CDECoprocMask & (1 << CoprocNo));\n\n  if (IsCDECoproc != WantCDE)\n    return Diag(CoprocArg->getBeginLoc(), diag::err_arm_invalid_coproc)\n           << (int)CoprocNo << (int)WantCDE << CoprocArg->getSourceRange();\n\n  return false;\n}\n\nbool Sema::CheckARMBuiltinExclusiveCall(unsigned BuiltinID, CallExpr *TheCall,\n                                        unsigned MaxWidth) {\n  assert((BuiltinID == ARM::BI__builtin_arm_ldrex ||\n          BuiltinID == ARM::BI__builtin_arm_ldaex ||\n          BuiltinID == ARM::BI__builtin_arm_strex ||\n          BuiltinID == ARM::BI__builtin_arm_stlex ||\n          BuiltinID == AArch64::BI__builtin_arm_ldrex ||\n          BuiltinID == AArch64::BI__builtin_arm_ldaex ||\n          BuiltinID == AArch64::BI__builtin_arm_strex ||\n          BuiltinID == AArch64::BI__builtin_arm_stlex) &&\n         \"unexpected ARM builtin\");\n  bool IsLdrex = BuiltinID == ARM::BI__builtin_arm_ldrex ||\n                 BuiltinID == ARM::BI__builtin_arm_ldaex ||\n                 BuiltinID == AArch64::BI__builtin_arm_ldrex ||\n                 BuiltinID == AArch64::BI__builtin_arm_ldaex;\n\n  DeclRefExpr *DRE =cast<DeclRefExpr>(TheCall->getCallee()->IgnoreParenCasts());\n\n  // Ensure that we have the proper number of arguments.\n  if (checkArgCount(*this, TheCall, IsLdrex ? 1 : 2))\n    return true;\n\n  // Inspect the pointer argument of the atomic builtin.  This should always be\n  // a pointer type, whose element is an integral scalar or pointer type.\n  // Because it is a pointer type, we don't have to worry about any implicit\n  // casts here.\n  Expr *PointerArg = TheCall->getArg(IsLdrex ? 0 : 1);\n  ExprResult PointerArgRes = DefaultFunctionArrayLvalueConversion(PointerArg);\n  if (PointerArgRes.isInvalid())\n    return true;\n  PointerArg = PointerArgRes.get();\n\n  const PointerType *pointerType = PointerArg->getType()->getAs<PointerType>();\n  if (!pointerType) {\n    Diag(DRE->getBeginLoc(), diag::err_atomic_builtin_must_be_pointer)\n        << PointerArg->getType() << PointerArg->getSourceRange();\n    return true;\n  }\n\n  // ldrex takes a \"const volatile T*\" and strex takes a \"volatile T*\". Our next\n  // task is to insert the appropriate casts into the AST. First work out just\n  // what the appropriate type is.\n  QualType ValType = pointerType->getPointeeType();\n  QualType AddrType = ValType.getUnqualifiedType().withVolatile();\n  if (IsLdrex)\n    AddrType.addConst();\n\n  // Issue a warning if the cast is dodgy.\n  CastKind CastNeeded = CK_NoOp;\n  if (!AddrType.isAtLeastAsQualifiedAs(ValType)) {\n    CastNeeded = CK_BitCast;\n    Diag(DRE->getBeginLoc(), diag::ext_typecheck_convert_discards_qualifiers)\n        << PointerArg->getType() << Context.getPointerType(AddrType)\n        << AA_Passing << PointerArg->getSourceRange();\n  }\n\n  // Finally, do the cast and replace the argument with the corrected version.\n  AddrType = Context.getPointerType(AddrType);\n  PointerArgRes = ImpCastExprToType(PointerArg, AddrType, CastNeeded);\n  if (PointerArgRes.isInvalid())\n    return true;\n  PointerArg = PointerArgRes.get();\n\n  TheCall->setArg(IsLdrex ? 0 : 1, PointerArg);\n\n  // In general, we allow ints, floats and pointers to be loaded and stored.\n  if (!ValType->isIntegerType() && !ValType->isAnyPointerType() &&\n      !ValType->isBlockPointerType() && !ValType->isFloatingType()) {\n    Diag(DRE->getBeginLoc(), diag::err_atomic_builtin_must_be_pointer_intfltptr)\n        << PointerArg->getType() << PointerArg->getSourceRange();\n    return true;\n  }\n\n  // But ARM doesn't have instructions to deal with 128-bit versions.\n  if (Context.getTypeSize(ValType) > MaxWidth) {\n    assert(MaxWidth == 64 && \"Diagnostic unexpectedly inaccurate\");\n    Diag(DRE->getBeginLoc(), diag::err_atomic_exclusive_builtin_pointer_size)\n        << PointerArg->getType() << PointerArg->getSourceRange();\n    return true;\n  }\n\n  switch (ValType.getObjCLifetime()) {\n  case Qualifiers::OCL_None:\n  case Qualifiers::OCL_ExplicitNone:\n    // okay\n    break;\n\n  case Qualifiers::OCL_Weak:\n  case Qualifiers::OCL_Strong:\n  case Qualifiers::OCL_Autoreleasing:\n    Diag(DRE->getBeginLoc(), diag::err_arc_atomic_ownership)\n        << ValType << PointerArg->getSourceRange();\n    return true;\n  }\n\n  if (IsLdrex) {\n    TheCall->setType(ValType);\n    return false;\n  }\n\n  // Initialize the argument to be stored.\n  ExprResult ValArg = TheCall->getArg(0);\n  InitializedEntity Entity = InitializedEntity::InitializeParameter(\n      Context, ValType, /*consume*/ false);\n  ValArg = PerformCopyInitialization(Entity, SourceLocation(), ValArg);\n  if (ValArg.isInvalid())\n    return true;\n  TheCall->setArg(0, ValArg.get());\n\n  // __builtin_arm_strex always returns an int. It's marked as such in the .def,\n  // but the custom checker bypasses all default analysis.\n  TheCall->setType(Context.IntTy);\n  return false;\n}\n\nbool Sema::CheckARMBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                       CallExpr *TheCall) {\n  if (BuiltinID == ARM::BI__builtin_arm_ldrex ||\n      BuiltinID == ARM::BI__builtin_arm_ldaex ||\n      BuiltinID == ARM::BI__builtin_arm_strex ||\n      BuiltinID == ARM::BI__builtin_arm_stlex) {\n    return CheckARMBuiltinExclusiveCall(BuiltinID, TheCall, 64);\n  }\n\n  if (BuiltinID == ARM::BI__builtin_arm_prefetch) {\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 1) ||\n      SemaBuiltinConstantArgRange(TheCall, 2, 0, 1);\n  }\n\n  if (BuiltinID == ARM::BI__builtin_arm_rsr64 ||\n      BuiltinID == ARM::BI__builtin_arm_wsr64)\n    return SemaBuiltinARMSpecialReg(BuiltinID, TheCall, 0, 3, false);\n\n  if (BuiltinID == ARM::BI__builtin_arm_rsr ||\n      BuiltinID == ARM::BI__builtin_arm_rsrp ||\n      BuiltinID == ARM::BI__builtin_arm_wsr ||\n      BuiltinID == ARM::BI__builtin_arm_wsrp)\n    return SemaBuiltinARMSpecialReg(BuiltinID, TheCall, 0, 5, true);\n\n  if (CheckNeonBuiltinFunctionCall(TI, BuiltinID, TheCall))\n    return true;\n  if (CheckMVEBuiltinFunctionCall(BuiltinID, TheCall))\n    return true;\n  if (CheckCDEBuiltinFunctionCall(TI, BuiltinID, TheCall))\n    return true;\n\n  // For intrinsics which take an immediate value as part of the instruction,\n  // range check them here.\n  // FIXME: VFP Intrinsics should error if VFP not present.\n  switch (BuiltinID) {\n  default: return false;\n  case ARM::BI__builtin_arm_ssat:\n    return SemaBuiltinConstantArgRange(TheCall, 1, 1, 32);\n  case ARM::BI__builtin_arm_usat:\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 31);\n  case ARM::BI__builtin_arm_ssat16:\n    return SemaBuiltinConstantArgRange(TheCall, 1, 1, 16);\n  case ARM::BI__builtin_arm_usat16:\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 15);\n  case ARM::BI__builtin_arm_vcvtr_f:\n  case ARM::BI__builtin_arm_vcvtr_d:\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 1);\n  case ARM::BI__builtin_arm_dmb:\n  case ARM::BI__builtin_arm_dsb:\n  case ARM::BI__builtin_arm_isb:\n  case ARM::BI__builtin_arm_dbg:\n    return SemaBuiltinConstantArgRange(TheCall, 0, 0, 15);\n  case ARM::BI__builtin_arm_cdp:\n  case ARM::BI__builtin_arm_cdp2:\n  case ARM::BI__builtin_arm_mcr:\n  case ARM::BI__builtin_arm_mcr2:\n  case ARM::BI__builtin_arm_mrc:\n  case ARM::BI__builtin_arm_mrc2:\n  case ARM::BI__builtin_arm_mcrr:\n  case ARM::BI__builtin_arm_mcrr2:\n  case ARM::BI__builtin_arm_mrrc:\n  case ARM::BI__builtin_arm_mrrc2:\n  case ARM::BI__builtin_arm_ldc:\n  case ARM::BI__builtin_arm_ldcl:\n  case ARM::BI__builtin_arm_ldc2:\n  case ARM::BI__builtin_arm_ldc2l:\n  case ARM::BI__builtin_arm_stc:\n  case ARM::BI__builtin_arm_stcl:\n  case ARM::BI__builtin_arm_stc2:\n  case ARM::BI__builtin_arm_stc2l:\n    return SemaBuiltinConstantArgRange(TheCall, 0, 0, 15) ||\n           CheckARMCoprocessorImmediate(TI, TheCall->getArg(0),\n                                        /*WantCDE*/ false);\n  }\n}\n\nbool Sema::CheckAArch64BuiltinFunctionCall(const TargetInfo &TI,\n                                           unsigned BuiltinID,\n                                           CallExpr *TheCall) {\n  if (BuiltinID == AArch64::BI__builtin_arm_ldrex ||\n      BuiltinID == AArch64::BI__builtin_arm_ldaex ||\n      BuiltinID == AArch64::BI__builtin_arm_strex ||\n      BuiltinID == AArch64::BI__builtin_arm_stlex) {\n    return CheckARMBuiltinExclusiveCall(BuiltinID, TheCall, 128);\n  }\n\n  if (BuiltinID == AArch64::BI__builtin_arm_prefetch) {\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 1) ||\n      SemaBuiltinConstantArgRange(TheCall, 2, 0, 2) ||\n      SemaBuiltinConstantArgRange(TheCall, 3, 0, 1) ||\n      SemaBuiltinConstantArgRange(TheCall, 4, 0, 1);\n  }\n\n  if (BuiltinID == AArch64::BI__builtin_arm_rsr64 ||\n      BuiltinID == AArch64::BI__builtin_arm_wsr64)\n    return SemaBuiltinARMSpecialReg(BuiltinID, TheCall, 0, 5, true);\n\n  // Memory Tagging Extensions (MTE) Intrinsics\n  if (BuiltinID == AArch64::BI__builtin_arm_irg ||\n      BuiltinID == AArch64::BI__builtin_arm_addg ||\n      BuiltinID == AArch64::BI__builtin_arm_gmi ||\n      BuiltinID == AArch64::BI__builtin_arm_ldg ||\n      BuiltinID == AArch64::BI__builtin_arm_stg ||\n      BuiltinID == AArch64::BI__builtin_arm_subp) {\n    return SemaBuiltinARMMemoryTaggingCall(BuiltinID, TheCall);\n  }\n\n  if (BuiltinID == AArch64::BI__builtin_arm_rsr ||\n      BuiltinID == AArch64::BI__builtin_arm_rsrp ||\n      BuiltinID == AArch64::BI__builtin_arm_wsr ||\n      BuiltinID == AArch64::BI__builtin_arm_wsrp)\n    return SemaBuiltinARMSpecialReg(BuiltinID, TheCall, 0, 5, true);\n\n  // Only check the valid encoding range. Any constant in this range would be\n  // converted to a register of the form S1_2_C3_C4_5. Let the hardware throw\n  // an exception for incorrect registers. This matches MSVC behavior.\n  if (BuiltinID == AArch64::BI_ReadStatusReg ||\n      BuiltinID == AArch64::BI_WriteStatusReg)\n    return SemaBuiltinConstantArgRange(TheCall, 0, 0, 0x7fff);\n\n  if (BuiltinID == AArch64::BI__getReg)\n    return SemaBuiltinConstantArgRange(TheCall, 0, 0, 31);\n\n  if (CheckNeonBuiltinFunctionCall(TI, BuiltinID, TheCall))\n    return true;\n\n  if (CheckSVEBuiltinFunctionCall(BuiltinID, TheCall))\n    return true;\n\n  // For intrinsics which take an immediate value as part of the instruction,\n  // range check them here.\n  unsigned i = 0, l = 0, u = 0;\n  switch (BuiltinID) {\n  default: return false;\n  case AArch64::BI__builtin_arm_dmb:\n  case AArch64::BI__builtin_arm_dsb:\n  case AArch64::BI__builtin_arm_isb: l = 0; u = 15; break;\n  case AArch64::BI__builtin_arm_tcancel: l = 0; u = 65535; break;\n  }\n\n  return SemaBuiltinConstantArgRange(TheCall, i, l, u + l);\n}\n\nstatic bool isValidBPFPreserveFieldInfoArg(Expr *Arg) {\n  if (Arg->getType()->getAsPlaceholderType())\n    return false;\n\n  // The first argument needs to be a record field access.\n  // If it is an array element access, we delay decision\n  // to BPF backend to check whether the access is a\n  // field access or not.\n  return (Arg->IgnoreParens()->getObjectKind() == OK_BitField ||\n          dyn_cast<MemberExpr>(Arg->IgnoreParens()) ||\n          dyn_cast<ArraySubscriptExpr>(Arg->IgnoreParens()));\n}\n\nstatic bool isEltOfVectorTy(ASTContext &Context, CallExpr *Call, Sema &S,\n                            QualType VectorTy, QualType EltTy) {\n  QualType VectorEltTy = VectorTy->castAs<VectorType>()->getElementType();\n  if (!Context.hasSameType(VectorEltTy, EltTy)) {\n    S.Diag(Call->getBeginLoc(), diag::err_typecheck_call_different_arg_types)\n        << Call->getSourceRange() << VectorEltTy << EltTy;\n    return false;\n  }\n  return true;\n}\n\nstatic bool isValidBPFPreserveTypeInfoArg(Expr *Arg) {\n  QualType ArgType = Arg->getType();\n  if (ArgType->getAsPlaceholderType())\n    return false;\n\n  // for TYPE_EXISTENCE/TYPE_SIZEOF reloc type\n  // format:\n  //   1. __builtin_preserve_type_info(*(<type> *)0, flag);\n  //   2. <type> var;\n  //      __builtin_preserve_type_info(var, flag);\n  if (!dyn_cast<DeclRefExpr>(Arg->IgnoreParens()) &&\n      !dyn_cast<UnaryOperator>(Arg->IgnoreParens()))\n    return false;\n\n  // Typedef type.\n  if (ArgType->getAs<TypedefType>())\n    return true;\n\n  // Record type or Enum type.\n  const Type *Ty = ArgType->getUnqualifiedDesugaredType();\n  if (const auto *RT = Ty->getAs<RecordType>()) {\n    if (!RT->getDecl()->getDeclName().isEmpty())\n      return true;\n  } else if (const auto *ET = Ty->getAs<EnumType>()) {\n    if (!ET->getDecl()->getDeclName().isEmpty())\n      return true;\n  }\n\n  return false;\n}\n\nstatic bool isValidBPFPreserveEnumValueArg(Expr *Arg) {\n  QualType ArgType = Arg->getType();\n  if (ArgType->getAsPlaceholderType())\n    return false;\n\n  // for ENUM_VALUE_EXISTENCE/ENUM_VALUE reloc type\n  // format:\n  //   __builtin_preserve_enum_value(*(<enum_type> *)<enum_value>,\n  //                                 flag);\n  const auto *UO = dyn_cast<UnaryOperator>(Arg->IgnoreParens());\n  if (!UO)\n    return false;\n\n  const auto *CE = dyn_cast<CStyleCastExpr>(UO->getSubExpr());\n  if (!CE)\n    return false;\n  if (CE->getCastKind() != CK_IntegralToPointer &&\n      CE->getCastKind() != CK_NullToPointer)\n    return false;\n\n  // The integer must be from an EnumConstantDecl.\n  const auto *DR = dyn_cast<DeclRefExpr>(CE->getSubExpr());\n  if (!DR)\n    return false;\n\n  const EnumConstantDecl *Enumerator =\n      dyn_cast<EnumConstantDecl>(DR->getDecl());\n  if (!Enumerator)\n    return false;\n\n  // The type must be EnumType.\n  const Type *Ty = ArgType->getUnqualifiedDesugaredType();\n  const auto *ET = Ty->getAs<EnumType>();\n  if (!ET)\n    return false;\n\n  // The enum value must be supported.\n  for (auto *EDI : ET->getDecl()->enumerators()) {\n    if (EDI == Enumerator)\n      return true;\n  }\n\n  return false;\n}\n\nbool Sema::CheckBPFBuiltinFunctionCall(unsigned BuiltinID,\n                                       CallExpr *TheCall) {\n  assert((BuiltinID == BPF::BI__builtin_preserve_field_info ||\n          BuiltinID == BPF::BI__builtin_btf_type_id ||\n          BuiltinID == BPF::BI__builtin_preserve_type_info ||\n          BuiltinID == BPF::BI__builtin_preserve_enum_value) &&\n         \"unexpected BPF builtin\");\n\n  if (checkArgCount(*this, TheCall, 2))\n    return true;\n\n  // The second argument needs to be a constant int\n  Expr *Arg = TheCall->getArg(1);\n  Optional<llvm::APSInt> Value = Arg->getIntegerConstantExpr(Context);\n  diag::kind kind;\n  if (!Value) {\n    if (BuiltinID == BPF::BI__builtin_preserve_field_info)\n      kind = diag::err_preserve_field_info_not_const;\n    else if (BuiltinID == BPF::BI__builtin_btf_type_id)\n      kind = diag::err_btf_type_id_not_const;\n    else if (BuiltinID == BPF::BI__builtin_preserve_type_info)\n      kind = diag::err_preserve_type_info_not_const;\n    else\n      kind = diag::err_preserve_enum_value_not_const;\n    Diag(Arg->getBeginLoc(), kind) << 2 << Arg->getSourceRange();\n    return true;\n  }\n\n  // The first argument\n  Arg = TheCall->getArg(0);\n  bool InvalidArg = false;\n  bool ReturnUnsignedInt = true;\n  if (BuiltinID == BPF::BI__builtin_preserve_field_info) {\n    if (!isValidBPFPreserveFieldInfoArg(Arg)) {\n      InvalidArg = true;\n      kind = diag::err_preserve_field_info_not_field;\n    }\n  } else if (BuiltinID == BPF::BI__builtin_preserve_type_info) {\n    if (!isValidBPFPreserveTypeInfoArg(Arg)) {\n      InvalidArg = true;\n      kind = diag::err_preserve_type_info_invalid;\n    }\n  } else if (BuiltinID == BPF::BI__builtin_preserve_enum_value) {\n    if (!isValidBPFPreserveEnumValueArg(Arg)) {\n      InvalidArg = true;\n      kind = diag::err_preserve_enum_value_invalid;\n    }\n    ReturnUnsignedInt = false;\n  } else if (BuiltinID == BPF::BI__builtin_btf_type_id) {\n    ReturnUnsignedInt = false;\n  }\n\n  if (InvalidArg) {\n    Diag(Arg->getBeginLoc(), kind) << 1 << Arg->getSourceRange();\n    return true;\n  }\n\n  if (ReturnUnsignedInt)\n    TheCall->setType(Context.UnsignedIntTy);\n  else\n    TheCall->setType(Context.UnsignedLongTy);\n  return false;\n}\n\nbool Sema::CheckHexagonBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall) {\n  struct ArgInfo {\n    uint8_t OpNum;\n    bool IsSigned;\n    uint8_t BitWidth;\n    uint8_t Align;\n  };\n  struct BuiltinInfo {\n    unsigned BuiltinID;\n    ArgInfo Infos[2];\n  };\n\n  static BuiltinInfo Infos[] = {\n    { Hexagon::BI__builtin_circ_ldd,                  {{ 3, true,  4,  3 }} },\n    { Hexagon::BI__builtin_circ_ldw,                  {{ 3, true,  4,  2 }} },\n    { Hexagon::BI__builtin_circ_ldh,                  {{ 3, true,  4,  1 }} },\n    { Hexagon::BI__builtin_circ_lduh,                 {{ 3, true,  4,  1 }} },\n    { Hexagon::BI__builtin_circ_ldb,                  {{ 3, true,  4,  0 }} },\n    { Hexagon::BI__builtin_circ_ldub,                 {{ 3, true,  4,  0 }} },\n    { Hexagon::BI__builtin_circ_std,                  {{ 3, true,  4,  3 }} },\n    { Hexagon::BI__builtin_circ_stw,                  {{ 3, true,  4,  2 }} },\n    { Hexagon::BI__builtin_circ_sth,                  {{ 3, true,  4,  1 }} },\n    { Hexagon::BI__builtin_circ_sthhi,                {{ 3, true,  4,  1 }} },\n    { Hexagon::BI__builtin_circ_stb,                  {{ 3, true,  4,  0 }} },\n\n    { Hexagon::BI__builtin_HEXAGON_L2_loadrub_pci,    {{ 1, true,  4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_L2_loadrb_pci,     {{ 1, true,  4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_L2_loadruh_pci,    {{ 1, true,  4,  1 }} },\n    { Hexagon::BI__builtin_HEXAGON_L2_loadrh_pci,     {{ 1, true,  4,  1 }} },\n    { Hexagon::BI__builtin_HEXAGON_L2_loadri_pci,     {{ 1, true,  4,  2 }} },\n    { Hexagon::BI__builtin_HEXAGON_L2_loadrd_pci,     {{ 1, true,  4,  3 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_storerb_pci,    {{ 1, true,  4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_storerh_pci,    {{ 1, true,  4,  1 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_storerf_pci,    {{ 1, true,  4,  1 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_storeri_pci,    {{ 1, true,  4,  2 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_storerd_pci,    {{ 1, true,  4,  3 }} },\n\n    { Hexagon::BI__builtin_HEXAGON_A2_combineii,      {{ 1, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A2_tfrih,          {{ 1, false, 16, 0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A2_tfril,          {{ 1, false, 16, 0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A2_tfrpi,          {{ 0, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_bitspliti,      {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_cmpbeqi,        {{ 1, false, 8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_cmpbgti,        {{ 1, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_cround_ri,      {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_round_ri,       {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_round_ri_sat,   {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmpbeqi,       {{ 1, false, 8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmpbgti,       {{ 1, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmpbgtui,      {{ 1, false, 7,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmpheqi,       {{ 1, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmphgti,       {{ 1, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmphgtui,      {{ 1, false, 7,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmpweqi,       {{ 1, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmpwgti,       {{ 1, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_A4_vcmpwgtui,      {{ 1, false, 7,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_C2_bitsclri,       {{ 1, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_C2_muxii,          {{ 2, true,  8,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_C4_nbitsclri,      {{ 1, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_F2_dfclass,        {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_F2_dfimm_n,        {{ 0, false, 10, 0 }} },\n    { Hexagon::BI__builtin_HEXAGON_F2_dfimm_p,        {{ 0, false, 10, 0 }} },\n    { Hexagon::BI__builtin_HEXAGON_F2_sfclass,        {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_F2_sfimm_n,        {{ 0, false, 10, 0 }} },\n    { Hexagon::BI__builtin_HEXAGON_F2_sfimm_p,        {{ 0, false, 10, 0 }} },\n    { Hexagon::BI__builtin_HEXAGON_M4_mpyri_addi,     {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_M4_mpyri_addr_u2,  {{ 1, false, 6,  2 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_addasl_rrri,    {{ 2, false, 3,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_p_acc,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_p_and,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_p,        {{ 1, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_p_nac,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_p_or,     {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_p_xacc,   {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_r_acc,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_r_and,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_r,        {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_r_nac,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_r_or,     {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_r_sat,    {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_r_xacc,   {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_vh,       {{ 1, false, 4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asl_i_vw,       {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_p_acc,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_p_and,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_p,        {{ 1, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_p_nac,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_p_or,     {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_p_rnd_goodsyntax,\n                                                      {{ 1, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_p_rnd,    {{ 1, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_r_acc,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_r_and,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_r,        {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_r_nac,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_r_or,     {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_r_rnd_goodsyntax,\n                                                      {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_r_rnd,    {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_svw_trun, {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_vh,       {{ 1, false, 4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_asr_i_vw,       {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_clrbit_i,       {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_extractu,       {{ 1, false, 5,  0 },\n                                                       { 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_extractup,      {{ 1, false, 6,  0 },\n                                                       { 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_insert,         {{ 2, false, 5,  0 },\n                                                       { 3, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_insertp,        {{ 2, false, 6,  0 },\n                                                       { 3, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_p_acc,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_p_and,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_p,        {{ 1, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_p_nac,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_p_or,     {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_p_xacc,   {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_r_acc,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_r_and,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_r,        {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_r_nac,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_r_or,     {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_r_xacc,   {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_vh,       {{ 1, false, 4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_lsr_i_vw,       {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_setbit_i,       {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_tableidxb_goodsyntax,\n                                                      {{ 2, false, 4,  0 },\n                                                       { 3, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_tableidxd_goodsyntax,\n                                                      {{ 2, false, 4,  0 },\n                                                       { 3, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_tableidxh_goodsyntax,\n                                                      {{ 2, false, 4,  0 },\n                                                       { 3, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_tableidxw_goodsyntax,\n                                                      {{ 2, false, 4,  0 },\n                                                       { 3, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_togglebit_i,    {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_tstbit_i,       {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_valignib,       {{ 2, false, 3,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S2_vspliceib,      {{ 2, false, 3,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_addi_asl_ri,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_addi_lsr_ri,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_andi_asl_ri,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_andi_lsr_ri,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_clbaddi,        {{ 1, true , 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_clbpaddi,       {{ 1, true,  6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_extract,        {{ 1, false, 5,  0 },\n                                                       { 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_extractp,       {{ 1, false, 6,  0 },\n                                                       { 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_lsli,           {{ 0, true,  6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_ntstbit_i,      {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_ori_asl_ri,     {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_ori_lsr_ri,     {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_subi_asl_ri,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_subi_lsr_ri,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_vrcrotate_acc,  {{ 3, false, 2,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S4_vrcrotate,      {{ 2, false, 2,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S5_asrhub_rnd_sat_goodsyntax,\n                                                      {{ 1, false, 4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S5_asrhub_sat,     {{ 1, false, 4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S5_vasrhrnd_goodsyntax,\n                                                      {{ 1, false, 4,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_p,        {{ 1, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_p_acc,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_p_and,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_p_nac,    {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_p_or,     {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_p_xacc,   {{ 2, false, 6,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_r,        {{ 1, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_r_acc,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_r_and,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_r_nac,    {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_r_or,     {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_S6_rol_i_r_xacc,   {{ 2, false, 5,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_valignbi,       {{ 2, false, 3,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_valignbi_128B,  {{ 2, false, 3,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vlalignbi,      {{ 2, false, 3,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vlalignbi_128B, {{ 2, false, 3,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrmpybusi,      {{ 2, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrmpybusi_128B, {{ 2, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrmpybusi_acc,  {{ 3, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrmpybusi_acc_128B,\n                                                      {{ 3, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrmpyubi,       {{ 2, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrmpyubi_128B,  {{ 2, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrmpyubi_acc,   {{ 3, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrmpyubi_acc_128B,\n                                                      {{ 3, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrsadubi,       {{ 2, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrsadubi_128B,  {{ 2, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrsadubi_acc,   {{ 3, false, 1,  0 }} },\n    { Hexagon::BI__builtin_HEXAGON_V6_vrsadubi_acc_128B,\n                                                      {{ 3, false, 1,  0 }} },\n  };\n\n  // Use a dynamically initialized static to sort the table exactly once on\n  // first run.\n  static const bool SortOnce =\n      (llvm::sort(Infos,\n                 [](const BuiltinInfo &LHS, const BuiltinInfo &RHS) {\n                   return LHS.BuiltinID < RHS.BuiltinID;\n                 }),\n       true);\n  (void)SortOnce;\n\n  const BuiltinInfo *F = llvm::partition_point(\n      Infos, [=](const BuiltinInfo &BI) { return BI.BuiltinID < BuiltinID; });\n  if (F == std::end(Infos) || F->BuiltinID != BuiltinID)\n    return false;\n\n  bool Error = false;\n\n  for (const ArgInfo &A : F->Infos) {\n    // Ignore empty ArgInfo elements.\n    if (A.BitWidth == 0)\n      continue;\n\n    int32_t Min = A.IsSigned ? -(1 << (A.BitWidth - 1)) : 0;\n    int32_t Max = (1 << (A.IsSigned ? A.BitWidth - 1 : A.BitWidth)) - 1;\n    if (!A.Align) {\n      Error |= SemaBuiltinConstantArgRange(TheCall, A.OpNum, Min, Max);\n    } else {\n      unsigned M = 1 << A.Align;\n      Min *= M;\n      Max *= M;\n      Error |= SemaBuiltinConstantArgRange(TheCall, A.OpNum, Min, Max) |\n               SemaBuiltinConstantArgMultiple(TheCall, A.OpNum, M);\n    }\n  }\n  return Error;\n}\n\nbool Sema::CheckHexagonBuiltinFunctionCall(unsigned BuiltinID,\n                                           CallExpr *TheCall) {\n  return CheckHexagonBuiltinArgument(BuiltinID, TheCall);\n}\n\nbool Sema::CheckMipsBuiltinFunctionCall(const TargetInfo &TI,\n                                        unsigned BuiltinID, CallExpr *TheCall) {\n  return CheckMipsBuiltinCpu(TI, BuiltinID, TheCall) ||\n         CheckMipsBuiltinArgument(BuiltinID, TheCall);\n}\n\nbool Sema::CheckMipsBuiltinCpu(const TargetInfo &TI, unsigned BuiltinID,\n                               CallExpr *TheCall) {\n\n  if (Mips::BI__builtin_mips_addu_qb <= BuiltinID &&\n      BuiltinID <= Mips::BI__builtin_mips_lwx) {\n    if (!TI.hasFeature(\"dsp\"))\n      return Diag(TheCall->getBeginLoc(), diag::err_mips_builtin_requires_dsp);\n  }\n\n  if (Mips::BI__builtin_mips_absq_s_qb <= BuiltinID &&\n      BuiltinID <= Mips::BI__builtin_mips_subuh_r_qb) {\n    if (!TI.hasFeature(\"dspr2\"))\n      return Diag(TheCall->getBeginLoc(),\n                  diag::err_mips_builtin_requires_dspr2);\n  }\n\n  if (Mips::BI__builtin_msa_add_a_b <= BuiltinID &&\n      BuiltinID <= Mips::BI__builtin_msa_xori_b) {\n    if (!TI.hasFeature(\"msa\"))\n      return Diag(TheCall->getBeginLoc(), diag::err_mips_builtin_requires_msa);\n  }\n\n  return false;\n}\n\n// CheckMipsBuiltinArgument - Checks the constant value passed to the\n// intrinsic is correct. The switch statement is ordered by DSP, MSA. The\n// ordering for DSP is unspecified. MSA is ordered by the data format used\n// by the underlying instruction i.e., df/m, df/n and then by size.\n//\n// FIXME: The size tests here should instead be tablegen'd along with the\n//        definitions from include/clang/Basic/BuiltinsMips.def.\n// FIXME: GCC is strict on signedness for some of these intrinsics, we should\n//        be too.\nbool Sema::CheckMipsBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall) {\n  unsigned i = 0, l = 0, u = 0, m = 0;\n  switch (BuiltinID) {\n  default: return false;\n  case Mips::BI__builtin_mips_wrdsp: i = 1; l = 0; u = 63; break;\n  case Mips::BI__builtin_mips_rddsp: i = 0; l = 0; u = 63; break;\n  case Mips::BI__builtin_mips_append: i = 2; l = 0; u = 31; break;\n  case Mips::BI__builtin_mips_balign: i = 2; l = 0; u = 3; break;\n  case Mips::BI__builtin_mips_precr_sra_ph_w: i = 2; l = 0; u = 31; break;\n  case Mips::BI__builtin_mips_precr_sra_r_ph_w: i = 2; l = 0; u = 31; break;\n  case Mips::BI__builtin_mips_prepend: i = 2; l = 0; u = 31; break;\n  // MSA intrinsics. Instructions (which the intrinsics maps to) which use the\n  // df/m field.\n  // These intrinsics take an unsigned 3 bit immediate.\n  case Mips::BI__builtin_msa_bclri_b:\n  case Mips::BI__builtin_msa_bnegi_b:\n  case Mips::BI__builtin_msa_bseti_b:\n  case Mips::BI__builtin_msa_sat_s_b:\n  case Mips::BI__builtin_msa_sat_u_b:\n  case Mips::BI__builtin_msa_slli_b:\n  case Mips::BI__builtin_msa_srai_b:\n  case Mips::BI__builtin_msa_srari_b:\n  case Mips::BI__builtin_msa_srli_b:\n  case Mips::BI__builtin_msa_srlri_b: i = 1; l = 0; u = 7; break;\n  case Mips::BI__builtin_msa_binsli_b:\n  case Mips::BI__builtin_msa_binsri_b: i = 2; l = 0; u = 7; break;\n  // These intrinsics take an unsigned 4 bit immediate.\n  case Mips::BI__builtin_msa_bclri_h:\n  case Mips::BI__builtin_msa_bnegi_h:\n  case Mips::BI__builtin_msa_bseti_h:\n  case Mips::BI__builtin_msa_sat_s_h:\n  case Mips::BI__builtin_msa_sat_u_h:\n  case Mips::BI__builtin_msa_slli_h:\n  case Mips::BI__builtin_msa_srai_h:\n  case Mips::BI__builtin_msa_srari_h:\n  case Mips::BI__builtin_msa_srli_h:\n  case Mips::BI__builtin_msa_srlri_h: i = 1; l = 0; u = 15; break;\n  case Mips::BI__builtin_msa_binsli_h:\n  case Mips::BI__builtin_msa_binsri_h: i = 2; l = 0; u = 15; break;\n  // These intrinsics take an unsigned 5 bit immediate.\n  // The first block of intrinsics actually have an unsigned 5 bit field,\n  // not a df/n field.\n  case Mips::BI__builtin_msa_cfcmsa:\n  case Mips::BI__builtin_msa_ctcmsa: i = 0; l = 0; u = 31; break;\n  case Mips::BI__builtin_msa_clei_u_b:\n  case Mips::BI__builtin_msa_clei_u_h:\n  case Mips::BI__builtin_msa_clei_u_w:\n  case Mips::BI__builtin_msa_clei_u_d:\n  case Mips::BI__builtin_msa_clti_u_b:\n  case Mips::BI__builtin_msa_clti_u_h:\n  case Mips::BI__builtin_msa_clti_u_w:\n  case Mips::BI__builtin_msa_clti_u_d:\n  case Mips::BI__builtin_msa_maxi_u_b:\n  case Mips::BI__builtin_msa_maxi_u_h:\n  case Mips::BI__builtin_msa_maxi_u_w:\n  case Mips::BI__builtin_msa_maxi_u_d:\n  case Mips::BI__builtin_msa_mini_u_b:\n  case Mips::BI__builtin_msa_mini_u_h:\n  case Mips::BI__builtin_msa_mini_u_w:\n  case Mips::BI__builtin_msa_mini_u_d:\n  case Mips::BI__builtin_msa_addvi_b:\n  case Mips::BI__builtin_msa_addvi_h:\n  case Mips::BI__builtin_msa_addvi_w:\n  case Mips::BI__builtin_msa_addvi_d:\n  case Mips::BI__builtin_msa_bclri_w:\n  case Mips::BI__builtin_msa_bnegi_w:\n  case Mips::BI__builtin_msa_bseti_w:\n  case Mips::BI__builtin_msa_sat_s_w:\n  case Mips::BI__builtin_msa_sat_u_w:\n  case Mips::BI__builtin_msa_slli_w:\n  case Mips::BI__builtin_msa_srai_w:\n  case Mips::BI__builtin_msa_srari_w:\n  case Mips::BI__builtin_msa_srli_w:\n  case Mips::BI__builtin_msa_srlri_w:\n  case Mips::BI__builtin_msa_subvi_b:\n  case Mips::BI__builtin_msa_subvi_h:\n  case Mips::BI__builtin_msa_subvi_w:\n  case Mips::BI__builtin_msa_subvi_d: i = 1; l = 0; u = 31; break;\n  case Mips::BI__builtin_msa_binsli_w:\n  case Mips::BI__builtin_msa_binsri_w: i = 2; l = 0; u = 31; break;\n  // These intrinsics take an unsigned 6 bit immediate.\n  case Mips::BI__builtin_msa_bclri_d:\n  case Mips::BI__builtin_msa_bnegi_d:\n  case Mips::BI__builtin_msa_bseti_d:\n  case Mips::BI__builtin_msa_sat_s_d:\n  case Mips::BI__builtin_msa_sat_u_d:\n  case Mips::BI__builtin_msa_slli_d:\n  case Mips::BI__builtin_msa_srai_d:\n  case Mips::BI__builtin_msa_srari_d:\n  case Mips::BI__builtin_msa_srli_d:\n  case Mips::BI__builtin_msa_srlri_d: i = 1; l = 0; u = 63; break;\n  case Mips::BI__builtin_msa_binsli_d:\n  case Mips::BI__builtin_msa_binsri_d: i = 2; l = 0; u = 63; break;\n  // These intrinsics take a signed 5 bit immediate.\n  case Mips::BI__builtin_msa_ceqi_b:\n  case Mips::BI__builtin_msa_ceqi_h:\n  case Mips::BI__builtin_msa_ceqi_w:\n  case Mips::BI__builtin_msa_ceqi_d:\n  case Mips::BI__builtin_msa_clti_s_b:\n  case Mips::BI__builtin_msa_clti_s_h:\n  case Mips::BI__builtin_msa_clti_s_w:\n  case Mips::BI__builtin_msa_clti_s_d:\n  case Mips::BI__builtin_msa_clei_s_b:\n  case Mips::BI__builtin_msa_clei_s_h:\n  case Mips::BI__builtin_msa_clei_s_w:\n  case Mips::BI__builtin_msa_clei_s_d:\n  case Mips::BI__builtin_msa_maxi_s_b:\n  case Mips::BI__builtin_msa_maxi_s_h:\n  case Mips::BI__builtin_msa_maxi_s_w:\n  case Mips::BI__builtin_msa_maxi_s_d:\n  case Mips::BI__builtin_msa_mini_s_b:\n  case Mips::BI__builtin_msa_mini_s_h:\n  case Mips::BI__builtin_msa_mini_s_w:\n  case Mips::BI__builtin_msa_mini_s_d: i = 1; l = -16; u = 15; break;\n  // These intrinsics take an unsigned 8 bit immediate.\n  case Mips::BI__builtin_msa_andi_b:\n  case Mips::BI__builtin_msa_nori_b:\n  case Mips::BI__builtin_msa_ori_b:\n  case Mips::BI__builtin_msa_shf_b:\n  case Mips::BI__builtin_msa_shf_h:\n  case Mips::BI__builtin_msa_shf_w:\n  case Mips::BI__builtin_msa_xori_b: i = 1; l = 0; u = 255; break;\n  case Mips::BI__builtin_msa_bseli_b:\n  case Mips::BI__builtin_msa_bmnzi_b:\n  case Mips::BI__builtin_msa_bmzi_b: i = 2; l = 0; u = 255; break;\n  // df/n format\n  // These intrinsics take an unsigned 4 bit immediate.\n  case Mips::BI__builtin_msa_copy_s_b:\n  case Mips::BI__builtin_msa_copy_u_b:\n  case Mips::BI__builtin_msa_insve_b:\n  case Mips::BI__builtin_msa_splati_b: i = 1; l = 0; u = 15; break;\n  case Mips::BI__builtin_msa_sldi_b: i = 2; l = 0; u = 15; break;\n  // These intrinsics take an unsigned 3 bit immediate.\n  case Mips::BI__builtin_msa_copy_s_h:\n  case Mips::BI__builtin_msa_copy_u_h:\n  case Mips::BI__builtin_msa_insve_h:\n  case Mips::BI__builtin_msa_splati_h: i = 1; l = 0; u = 7; break;\n  case Mips::BI__builtin_msa_sldi_h: i = 2; l = 0; u = 7; break;\n  // These intrinsics take an unsigned 2 bit immediate.\n  case Mips::BI__builtin_msa_copy_s_w:\n  case Mips::BI__builtin_msa_copy_u_w:\n  case Mips::BI__builtin_msa_insve_w:\n  case Mips::BI__builtin_msa_splati_w: i = 1; l = 0; u = 3; break;\n  case Mips::BI__builtin_msa_sldi_w: i = 2; l = 0; u = 3; break;\n  // These intrinsics take an unsigned 1 bit immediate.\n  case Mips::BI__builtin_msa_copy_s_d:\n  case Mips::BI__builtin_msa_copy_u_d:\n  case Mips::BI__builtin_msa_insve_d:\n  case Mips::BI__builtin_msa_splati_d: i = 1; l = 0; u = 1; break;\n  case Mips::BI__builtin_msa_sldi_d: i = 2; l = 0; u = 1; break;\n  // Memory offsets and immediate loads.\n  // These intrinsics take a signed 10 bit immediate.\n  case Mips::BI__builtin_msa_ldi_b: i = 0; l = -128; u = 255; break;\n  case Mips::BI__builtin_msa_ldi_h:\n  case Mips::BI__builtin_msa_ldi_w:\n  case Mips::BI__builtin_msa_ldi_d: i = 0; l = -512; u = 511; break;\n  case Mips::BI__builtin_msa_ld_b: i = 1; l = -512; u = 511; m = 1; break;\n  case Mips::BI__builtin_msa_ld_h: i = 1; l = -1024; u = 1022; m = 2; break;\n  case Mips::BI__builtin_msa_ld_w: i = 1; l = -2048; u = 2044; m = 4; break;\n  case Mips::BI__builtin_msa_ld_d: i = 1; l = -4096; u = 4088; m = 8; break;\n  case Mips::BI__builtin_msa_ldr_d: i = 1; l = -4096; u = 4088; m = 8; break;\n  case Mips::BI__builtin_msa_ldr_w: i = 1; l = -2048; u = 2044; m = 4; break;\n  case Mips::BI__builtin_msa_st_b: i = 2; l = -512; u = 511; m = 1; break;\n  case Mips::BI__builtin_msa_st_h: i = 2; l = -1024; u = 1022; m = 2; break;\n  case Mips::BI__builtin_msa_st_w: i = 2; l = -2048; u = 2044; m = 4; break;\n  case Mips::BI__builtin_msa_st_d: i = 2; l = -4096; u = 4088; m = 8; break;\n  case Mips::BI__builtin_msa_str_d: i = 2; l = -4096; u = 4088; m = 8; break;\n  case Mips::BI__builtin_msa_str_w: i = 2; l = -2048; u = 2044; m = 4; break;\n  }\n\n  if (!m)\n    return SemaBuiltinConstantArgRange(TheCall, i, l, u);\n\n  return SemaBuiltinConstantArgRange(TheCall, i, l, u) ||\n         SemaBuiltinConstantArgMultiple(TheCall, i, m);\n}\n\n/// DecodePPCMMATypeFromStr - This decodes one PPC MMA type descriptor from Str,\n/// advancing the pointer over the consumed characters. The decoded type is\n/// returned. If the decoded type represents a constant integer with a\n/// constraint on its value then Mask is set to that value. The type descriptors\n/// used in Str are specific to PPC MMA builtins and are documented in the file\n/// defining the PPC builtins.\nstatic QualType DecodePPCMMATypeFromStr(ASTContext &Context, const char *&Str,\n                                        unsigned &Mask) {\n  bool RequireICE = false;\n  ASTContext::GetBuiltinTypeError Error = ASTContext::GE_None;\n  switch (*Str++) {\n  case 'V':\n    return Context.getVectorType(Context.UnsignedCharTy, 16,\n                                 VectorType::VectorKind::AltiVecVector);\n  case 'i': {\n    char *End;\n    unsigned size = strtoul(Str, &End, 10);\n    assert(End != Str && \"Missing constant parameter constraint\");\n    Str = End;\n    Mask = size;\n    return Context.IntTy;\n  }\n  case 'W': {\n    char *End;\n    unsigned size = strtoul(Str, &End, 10);\n    assert(End != Str && \"Missing PowerPC MMA type size\");\n    Str = End;\n    QualType Type;\n    switch (size) {\n  #define PPC_VECTOR_TYPE(typeName, Id, size) \\\n    case size: Type = Context.Id##Ty; break;\n  #include \"clang/Basic/PPCTypes.def\"\n    default: llvm_unreachable(\"Invalid PowerPC MMA vector type\");\n    }\n    bool CheckVectorArgs = false;\n    while (!CheckVectorArgs) {\n      switch (*Str++) {\n      case '*':\n        Type = Context.getPointerType(Type);\n        break;\n      case 'C':\n        Type = Type.withConst();\n        break;\n      default:\n        CheckVectorArgs = true;\n        --Str;\n        break;\n      }\n    }\n    return Type;\n  }\n  default:\n    return Context.DecodeTypeStr(--Str, Context, Error, RequireICE, true);\n  }\n}\n\nbool Sema::CheckPPCBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                       CallExpr *TheCall) {\n  unsigned i = 0, l = 0, u = 0;\n  bool Is64BitBltin = BuiltinID == PPC::BI__builtin_divde ||\n                      BuiltinID == PPC::BI__builtin_divdeu ||\n                      BuiltinID == PPC::BI__builtin_bpermd;\n  bool IsTarget64Bit = TI.getTypeWidth(TI.getIntPtrType()) == 64;\n  bool IsBltinExtDiv = BuiltinID == PPC::BI__builtin_divwe ||\n                       BuiltinID == PPC::BI__builtin_divweu ||\n                       BuiltinID == PPC::BI__builtin_divde ||\n                       BuiltinID == PPC::BI__builtin_divdeu;\n\n  if (Is64BitBltin && !IsTarget64Bit)\n    return Diag(TheCall->getBeginLoc(), diag::err_64_bit_builtin_32_bit_tgt)\n           << TheCall->getSourceRange();\n\n  if ((IsBltinExtDiv && !TI.hasFeature(\"extdiv\")) ||\n      (BuiltinID == PPC::BI__builtin_bpermd && !TI.hasFeature(\"bpermd\")))\n    return Diag(TheCall->getBeginLoc(), diag::err_ppc_builtin_only_on_pwr7)\n           << TheCall->getSourceRange();\n\n  auto SemaVSXCheck = [&](CallExpr *TheCall) -> bool {\n    if (!TI.hasFeature(\"vsx\"))\n      return Diag(TheCall->getBeginLoc(), diag::err_ppc_builtin_only_on_pwr7)\n             << TheCall->getSourceRange();\n    return false;\n  };\n\n  switch (BuiltinID) {\n  default: return false;\n  case PPC::BI__builtin_altivec_crypto_vshasigmaw:\n  case PPC::BI__builtin_altivec_crypto_vshasigmad:\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 1) ||\n           SemaBuiltinConstantArgRange(TheCall, 2, 0, 15);\n  case PPC::BI__builtin_altivec_dss:\n    return SemaBuiltinConstantArgRange(TheCall, 0, 0, 3);\n  case PPC::BI__builtin_tbegin:\n  case PPC::BI__builtin_tend: i = 0; l = 0; u = 1; break;\n  case PPC::BI__builtin_tsr: i = 0; l = 0; u = 7; break;\n  case PPC::BI__builtin_tabortwc:\n  case PPC::BI__builtin_tabortdc: i = 0; l = 0; u = 31; break;\n  case PPC::BI__builtin_tabortwci:\n  case PPC::BI__builtin_tabortdci:\n    return SemaBuiltinConstantArgRange(TheCall, 0, 0, 31) ||\n           SemaBuiltinConstantArgRange(TheCall, 2, 0, 31);\n  case PPC::BI__builtin_altivec_dst:\n  case PPC::BI__builtin_altivec_dstt:\n  case PPC::BI__builtin_altivec_dstst:\n  case PPC::BI__builtin_altivec_dststt:\n    return SemaBuiltinConstantArgRange(TheCall, 2, 0, 3);\n  case PPC::BI__builtin_vsx_xxpermdi:\n  case PPC::BI__builtin_vsx_xxsldwi:\n    return SemaBuiltinVSX(TheCall);\n  case PPC::BI__builtin_unpack_vector_int128:\n    return SemaVSXCheck(TheCall) ||\n           SemaBuiltinConstantArgRange(TheCall, 1, 0, 1);\n  case PPC::BI__builtin_pack_vector_int128:\n    return SemaVSXCheck(TheCall);\n  case PPC::BI__builtin_altivec_vgnb:\n     return SemaBuiltinConstantArgRange(TheCall, 1, 2, 7);\n  case PPC::BI__builtin_altivec_vec_replace_elt:\n  case PPC::BI__builtin_altivec_vec_replace_unaligned: {\n    QualType VecTy = TheCall->getArg(0)->getType();\n    QualType EltTy = TheCall->getArg(1)->getType();\n    unsigned Width = Context.getIntWidth(EltTy);\n    return SemaBuiltinConstantArgRange(TheCall, 2, 0, Width == 32 ? 12 : 8) ||\n           !isEltOfVectorTy(Context, TheCall, *this, VecTy, EltTy);\n  }\n  case PPC::BI__builtin_vsx_xxeval:\n     return SemaBuiltinConstantArgRange(TheCall, 3, 0, 255);\n  case PPC::BI__builtin_altivec_vsldbi:\n     return SemaBuiltinConstantArgRange(TheCall, 2, 0, 7);\n  case PPC::BI__builtin_altivec_vsrdbi:\n     return SemaBuiltinConstantArgRange(TheCall, 2, 0, 7);\n  case PPC::BI__builtin_vsx_xxpermx:\n     return SemaBuiltinConstantArgRange(TheCall, 3, 0, 7);\n#define CUSTOM_BUILTIN(Name, Types, Acc) \\\n  case PPC::BI__builtin_##Name: \\\n    return SemaBuiltinPPCMMACall(TheCall, Types);\n#include \"clang/Basic/BuiltinsPPC.def\"\n  }\n  return SemaBuiltinConstantArgRange(TheCall, i, l, u);\n}\n\n// Check if the given type is a non-pointer PPC MMA type. This function is used\n// in Sema to prevent invalid uses of restricted PPC MMA types.\nbool Sema::CheckPPCMMAType(QualType Type, SourceLocation TypeLoc) {\n  if (Type->isPointerType() || Type->isArrayType())\n    return false;\n\n  QualType CoreType = Type.getCanonicalType().getUnqualifiedType();\n#define PPC_VECTOR_TYPE(Name, Id, Size) || CoreType == Context.Id##Ty\n  if (false\n#include \"clang/Basic/PPCTypes.def\"\n     ) {\n    Diag(TypeLoc, diag::err_ppc_invalid_use_mma_type);\n    return true;\n  }\n  return false;\n}\n\nbool Sema::CheckAMDGCNBuiltinFunctionCall(unsigned BuiltinID,\n                                          CallExpr *TheCall) {\n  // position of memory order and scope arguments in the builtin\n  unsigned OrderIndex, ScopeIndex;\n  switch (BuiltinID) {\n  case AMDGPU::BI__builtin_amdgcn_atomic_inc32:\n  case AMDGPU::BI__builtin_amdgcn_atomic_inc64:\n  case AMDGPU::BI__builtin_amdgcn_atomic_dec32:\n  case AMDGPU::BI__builtin_amdgcn_atomic_dec64:\n    OrderIndex = 2;\n    ScopeIndex = 3;\n    break;\n  case AMDGPU::BI__builtin_amdgcn_fence:\n    OrderIndex = 0;\n    ScopeIndex = 1;\n    break;\n  default:\n    return false;\n  }\n\n  ExprResult Arg = TheCall->getArg(OrderIndex);\n  auto ArgExpr = Arg.get();\n  Expr::EvalResult ArgResult;\n\n  if (!ArgExpr->EvaluateAsInt(ArgResult, Context))\n    return Diag(ArgExpr->getExprLoc(), diag::err_typecheck_expect_int)\n           << ArgExpr->getType();\n  int ord = ArgResult.Val.getInt().getZExtValue();\n\n  // Check valididty of memory ordering as per C11 / C++11's memody model.\n  switch (static_cast<llvm::AtomicOrderingCABI>(ord)) {\n  case llvm::AtomicOrderingCABI::acquire:\n  case llvm::AtomicOrderingCABI::release:\n  case llvm::AtomicOrderingCABI::acq_rel:\n  case llvm::AtomicOrderingCABI::seq_cst:\n    break;\n  default: {\n    return Diag(ArgExpr->getBeginLoc(),\n                diag::warn_atomic_op_has_invalid_memory_order)\n           << ArgExpr->getSourceRange();\n  }\n  }\n\n  Arg = TheCall->getArg(ScopeIndex);\n  ArgExpr = Arg.get();\n  Expr::EvalResult ArgResult1;\n  // Check that sync scope is a constant literal\n  if (!ArgExpr->EvaluateAsConstantExpr(ArgResult1, Context))\n    return Diag(ArgExpr->getExprLoc(), diag::err_expr_not_string_literal)\n           << ArgExpr->getType();\n\n  return false;\n}\n\nbool Sema::CheckRISCVBuiltinFunctionCall(const TargetInfo &TI,\n                                         unsigned BuiltinID,\n                                         CallExpr *TheCall) {\n  // CodeGenFunction can also detect this, but this gives a better error\n  // message.\n  StringRef Features = Context.BuiltinInfo.getRequiredFeatures(BuiltinID);\n  if (Features.find(\"experimental-v\") != StringRef::npos &&\n      !TI.hasFeature(\"experimental-v\"))\n    return Diag(TheCall->getBeginLoc(), diag::err_riscvv_builtin_requires_v)\n           << TheCall->getSourceRange();\n\n  return false;\n}\n\nbool Sema::CheckSystemZBuiltinFunctionCall(unsigned BuiltinID,\n                                           CallExpr *TheCall) {\n  if (BuiltinID == SystemZ::BI__builtin_tabort) {\n    Expr *Arg = TheCall->getArg(0);\n    if (Optional<llvm::APSInt> AbortCode = Arg->getIntegerConstantExpr(Context))\n      if (AbortCode->getSExtValue() >= 0 && AbortCode->getSExtValue() < 256)\n        return Diag(Arg->getBeginLoc(), diag::err_systemz_invalid_tabort_code)\n               << Arg->getSourceRange();\n  }\n\n  // For intrinsics which take an immediate value as part of the instruction,\n  // range check them here.\n  unsigned i = 0, l = 0, u = 0;\n  switch (BuiltinID) {\n  default: return false;\n  case SystemZ::BI__builtin_s390_lcbb: i = 1; l = 0; u = 15; break;\n  case SystemZ::BI__builtin_s390_verimb:\n  case SystemZ::BI__builtin_s390_verimh:\n  case SystemZ::BI__builtin_s390_verimf:\n  case SystemZ::BI__builtin_s390_verimg: i = 3; l = 0; u = 255; break;\n  case SystemZ::BI__builtin_s390_vfaeb:\n  case SystemZ::BI__builtin_s390_vfaeh:\n  case SystemZ::BI__builtin_s390_vfaef:\n  case SystemZ::BI__builtin_s390_vfaebs:\n  case SystemZ::BI__builtin_s390_vfaehs:\n  case SystemZ::BI__builtin_s390_vfaefs:\n  case SystemZ::BI__builtin_s390_vfaezb:\n  case SystemZ::BI__builtin_s390_vfaezh:\n  case SystemZ::BI__builtin_s390_vfaezf:\n  case SystemZ::BI__builtin_s390_vfaezbs:\n  case SystemZ::BI__builtin_s390_vfaezhs:\n  case SystemZ::BI__builtin_s390_vfaezfs: i = 2; l = 0; u = 15; break;\n  case SystemZ::BI__builtin_s390_vfisb:\n  case SystemZ::BI__builtin_s390_vfidb:\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 15) ||\n           SemaBuiltinConstantArgRange(TheCall, 2, 0, 15);\n  case SystemZ::BI__builtin_s390_vftcisb:\n  case SystemZ::BI__builtin_s390_vftcidb: i = 1; l = 0; u = 4095; break;\n  case SystemZ::BI__builtin_s390_vlbb: i = 1; l = 0; u = 15; break;\n  case SystemZ::BI__builtin_s390_vpdi: i = 2; l = 0; u = 15; break;\n  case SystemZ::BI__builtin_s390_vsldb: i = 2; l = 0; u = 15; break;\n  case SystemZ::BI__builtin_s390_vstrcb:\n  case SystemZ::BI__builtin_s390_vstrch:\n  case SystemZ::BI__builtin_s390_vstrcf:\n  case SystemZ::BI__builtin_s390_vstrczb:\n  case SystemZ::BI__builtin_s390_vstrczh:\n  case SystemZ::BI__builtin_s390_vstrczf:\n  case SystemZ::BI__builtin_s390_vstrcbs:\n  case SystemZ::BI__builtin_s390_vstrchs:\n  case SystemZ::BI__builtin_s390_vstrcfs:\n  case SystemZ::BI__builtin_s390_vstrczbs:\n  case SystemZ::BI__builtin_s390_vstrczhs:\n  case SystemZ::BI__builtin_s390_vstrczfs: i = 3; l = 0; u = 15; break;\n  case SystemZ::BI__builtin_s390_vmslg: i = 3; l = 0; u = 15; break;\n  case SystemZ::BI__builtin_s390_vfminsb:\n  case SystemZ::BI__builtin_s390_vfmaxsb:\n  case SystemZ::BI__builtin_s390_vfmindb:\n  case SystemZ::BI__builtin_s390_vfmaxdb: i = 2; l = 0; u = 15; break;\n  case SystemZ::BI__builtin_s390_vsld: i = 2; l = 0; u = 7; break;\n  case SystemZ::BI__builtin_s390_vsrd: i = 2; l = 0; u = 7; break;\n  }\n  return SemaBuiltinConstantArgRange(TheCall, i, l, u);\n}\n\n/// SemaBuiltinCpuSupports - Handle __builtin_cpu_supports(char *).\n/// This checks that the target supports __builtin_cpu_supports and\n/// that the string argument is constant and valid.\nstatic bool SemaBuiltinCpuSupports(Sema &S, const TargetInfo &TI,\n                                   CallExpr *TheCall) {\n  Expr *Arg = TheCall->getArg(0);\n\n  // Check if the argument is a string literal.\n  if (!isa<StringLiteral>(Arg->IgnoreParenImpCasts()))\n    return S.Diag(TheCall->getBeginLoc(), diag::err_expr_not_string_literal)\n           << Arg->getSourceRange();\n\n  // Check the contents of the string.\n  StringRef Feature =\n      cast<StringLiteral>(Arg->IgnoreParenImpCasts())->getString();\n  if (!TI.validateCpuSupports(Feature))\n    return S.Diag(TheCall->getBeginLoc(), diag::err_invalid_cpu_supports)\n           << Arg->getSourceRange();\n  return false;\n}\n\n/// SemaBuiltinCpuIs - Handle __builtin_cpu_is(char *).\n/// This checks that the target supports __builtin_cpu_is and\n/// that the string argument is constant and valid.\nstatic bool SemaBuiltinCpuIs(Sema &S, const TargetInfo &TI, CallExpr *TheCall) {\n  Expr *Arg = TheCall->getArg(0);\n\n  // Check if the argument is a string literal.\n  if (!isa<StringLiteral>(Arg->IgnoreParenImpCasts()))\n    return S.Diag(TheCall->getBeginLoc(), diag::err_expr_not_string_literal)\n           << Arg->getSourceRange();\n\n  // Check the contents of the string.\n  StringRef Feature =\n      cast<StringLiteral>(Arg->IgnoreParenImpCasts())->getString();\n  if (!TI.validateCpuIs(Feature))\n    return S.Diag(TheCall->getBeginLoc(), diag::err_invalid_cpu_is)\n           << Arg->getSourceRange();\n  return false;\n}\n\n// Check if the rounding mode is legal.\nbool Sema::CheckX86BuiltinRoundingOrSAE(unsigned BuiltinID, CallExpr *TheCall) {\n  // Indicates if this instruction has rounding control or just SAE.\n  bool HasRC = false;\n\n  unsigned ArgNum = 0;\n  switch (BuiltinID) {\n  default:\n    return false;\n  case X86::BI__builtin_ia32_vcvttsd2si32:\n  case X86::BI__builtin_ia32_vcvttsd2si64:\n  case X86::BI__builtin_ia32_vcvttsd2usi32:\n  case X86::BI__builtin_ia32_vcvttsd2usi64:\n  case X86::BI__builtin_ia32_vcvttss2si32:\n  case X86::BI__builtin_ia32_vcvttss2si64:\n  case X86::BI__builtin_ia32_vcvttss2usi32:\n  case X86::BI__builtin_ia32_vcvttss2usi64:\n    ArgNum = 1;\n    break;\n  case X86::BI__builtin_ia32_maxpd512:\n  case X86::BI__builtin_ia32_maxps512:\n  case X86::BI__builtin_ia32_minpd512:\n  case X86::BI__builtin_ia32_minps512:\n    ArgNum = 2;\n    break;\n  case X86::BI__builtin_ia32_cvtps2pd512_mask:\n  case X86::BI__builtin_ia32_cvttpd2dq512_mask:\n  case X86::BI__builtin_ia32_cvttpd2qq512_mask:\n  case X86::BI__builtin_ia32_cvttpd2udq512_mask:\n  case X86::BI__builtin_ia32_cvttpd2uqq512_mask:\n  case X86::BI__builtin_ia32_cvttps2dq512_mask:\n  case X86::BI__builtin_ia32_cvttps2qq512_mask:\n  case X86::BI__builtin_ia32_cvttps2udq512_mask:\n  case X86::BI__builtin_ia32_cvttps2uqq512_mask:\n  case X86::BI__builtin_ia32_exp2pd_mask:\n  case X86::BI__builtin_ia32_exp2ps_mask:\n  case X86::BI__builtin_ia32_getexppd512_mask:\n  case X86::BI__builtin_ia32_getexpps512_mask:\n  case X86::BI__builtin_ia32_rcp28pd_mask:\n  case X86::BI__builtin_ia32_rcp28ps_mask:\n  case X86::BI__builtin_ia32_rsqrt28pd_mask:\n  case X86::BI__builtin_ia32_rsqrt28ps_mask:\n  case X86::BI__builtin_ia32_vcomisd:\n  case X86::BI__builtin_ia32_vcomiss:\n  case X86::BI__builtin_ia32_vcvtph2ps512_mask:\n    ArgNum = 3;\n    break;\n  case X86::BI__builtin_ia32_cmppd512_mask:\n  case X86::BI__builtin_ia32_cmpps512_mask:\n  case X86::BI__builtin_ia32_cmpsd_mask:\n  case X86::BI__builtin_ia32_cmpss_mask:\n  case X86::BI__builtin_ia32_cvtss2sd_round_mask:\n  case X86::BI__builtin_ia32_getexpsd128_round_mask:\n  case X86::BI__builtin_ia32_getexpss128_round_mask:\n  case X86::BI__builtin_ia32_getmantpd512_mask:\n  case X86::BI__builtin_ia32_getmantps512_mask:\n  case X86::BI__builtin_ia32_maxsd_round_mask:\n  case X86::BI__builtin_ia32_maxss_round_mask:\n  case X86::BI__builtin_ia32_minsd_round_mask:\n  case X86::BI__builtin_ia32_minss_round_mask:\n  case X86::BI__builtin_ia32_rcp28sd_round_mask:\n  case X86::BI__builtin_ia32_rcp28ss_round_mask:\n  case X86::BI__builtin_ia32_reducepd512_mask:\n  case X86::BI__builtin_ia32_reduceps512_mask:\n  case X86::BI__builtin_ia32_rndscalepd_mask:\n  case X86::BI__builtin_ia32_rndscaleps_mask:\n  case X86::BI__builtin_ia32_rsqrt28sd_round_mask:\n  case X86::BI__builtin_ia32_rsqrt28ss_round_mask:\n    ArgNum = 4;\n    break;\n  case X86::BI__builtin_ia32_fixupimmpd512_mask:\n  case X86::BI__builtin_ia32_fixupimmpd512_maskz:\n  case X86::BI__builtin_ia32_fixupimmps512_mask:\n  case X86::BI__builtin_ia32_fixupimmps512_maskz:\n  case X86::BI__builtin_ia32_fixupimmsd_mask:\n  case X86::BI__builtin_ia32_fixupimmsd_maskz:\n  case X86::BI__builtin_ia32_fixupimmss_mask:\n  case X86::BI__builtin_ia32_fixupimmss_maskz:\n  case X86::BI__builtin_ia32_getmantsd_round_mask:\n  case X86::BI__builtin_ia32_getmantss_round_mask:\n  case X86::BI__builtin_ia32_rangepd512_mask:\n  case X86::BI__builtin_ia32_rangeps512_mask:\n  case X86::BI__builtin_ia32_rangesd128_round_mask:\n  case X86::BI__builtin_ia32_rangess128_round_mask:\n  case X86::BI__builtin_ia32_reducesd_mask:\n  case X86::BI__builtin_ia32_reducess_mask:\n  case X86::BI__builtin_ia32_rndscalesd_round_mask:\n  case X86::BI__builtin_ia32_rndscaless_round_mask:\n    ArgNum = 5;\n    break;\n  case X86::BI__builtin_ia32_vcvtsd2si64:\n  case X86::BI__builtin_ia32_vcvtsd2si32:\n  case X86::BI__builtin_ia32_vcvtsd2usi32:\n  case X86::BI__builtin_ia32_vcvtsd2usi64:\n  case X86::BI__builtin_ia32_vcvtss2si32:\n  case X86::BI__builtin_ia32_vcvtss2si64:\n  case X86::BI__builtin_ia32_vcvtss2usi32:\n  case X86::BI__builtin_ia32_vcvtss2usi64:\n  case X86::BI__builtin_ia32_sqrtpd512:\n  case X86::BI__builtin_ia32_sqrtps512:\n    ArgNum = 1;\n    HasRC = true;\n    break;\n  case X86::BI__builtin_ia32_addpd512:\n  case X86::BI__builtin_ia32_addps512:\n  case X86::BI__builtin_ia32_divpd512:\n  case X86::BI__builtin_ia32_divps512:\n  case X86::BI__builtin_ia32_mulpd512:\n  case X86::BI__builtin_ia32_mulps512:\n  case X86::BI__builtin_ia32_subpd512:\n  case X86::BI__builtin_ia32_subps512:\n  case X86::BI__builtin_ia32_cvtsi2sd64:\n  case X86::BI__builtin_ia32_cvtsi2ss32:\n  case X86::BI__builtin_ia32_cvtsi2ss64:\n  case X86::BI__builtin_ia32_cvtusi2sd64:\n  case X86::BI__builtin_ia32_cvtusi2ss32:\n  case X86::BI__builtin_ia32_cvtusi2ss64:\n    ArgNum = 2;\n    HasRC = true;\n    break;\n  case X86::BI__builtin_ia32_cvtdq2ps512_mask:\n  case X86::BI__builtin_ia32_cvtudq2ps512_mask:\n  case X86::BI__builtin_ia32_cvtpd2ps512_mask:\n  case X86::BI__builtin_ia32_cvtpd2dq512_mask:\n  case X86::BI__builtin_ia32_cvtpd2qq512_mask:\n  case X86::BI__builtin_ia32_cvtpd2udq512_mask:\n  case X86::BI__builtin_ia32_cvtpd2uqq512_mask:\n  case X86::BI__builtin_ia32_cvtps2dq512_mask:\n  case X86::BI__builtin_ia32_cvtps2qq512_mask:\n  case X86::BI__builtin_ia32_cvtps2udq512_mask:\n  case X86::BI__builtin_ia32_cvtps2uqq512_mask:\n  case X86::BI__builtin_ia32_cvtqq2pd512_mask:\n  case X86::BI__builtin_ia32_cvtqq2ps512_mask:\n  case X86::BI__builtin_ia32_cvtuqq2pd512_mask:\n  case X86::BI__builtin_ia32_cvtuqq2ps512_mask:\n    ArgNum = 3;\n    HasRC = true;\n    break;\n  case X86::BI__builtin_ia32_addss_round_mask:\n  case X86::BI__builtin_ia32_addsd_round_mask:\n  case X86::BI__builtin_ia32_divss_round_mask:\n  case X86::BI__builtin_ia32_divsd_round_mask:\n  case X86::BI__builtin_ia32_mulss_round_mask:\n  case X86::BI__builtin_ia32_mulsd_round_mask:\n  case X86::BI__builtin_ia32_subss_round_mask:\n  case X86::BI__builtin_ia32_subsd_round_mask:\n  case X86::BI__builtin_ia32_scalefpd512_mask:\n  case X86::BI__builtin_ia32_scalefps512_mask:\n  case X86::BI__builtin_ia32_scalefsd_round_mask:\n  case X86::BI__builtin_ia32_scalefss_round_mask:\n  case X86::BI__builtin_ia32_cvtsd2ss_round_mask:\n  case X86::BI__builtin_ia32_sqrtsd_round_mask:\n  case X86::BI__builtin_ia32_sqrtss_round_mask:\n  case X86::BI__builtin_ia32_vfmaddsd3_mask:\n  case X86::BI__builtin_ia32_vfmaddsd3_maskz:\n  case X86::BI__builtin_ia32_vfmaddsd3_mask3:\n  case X86::BI__builtin_ia32_vfmaddss3_mask:\n  case X86::BI__builtin_ia32_vfmaddss3_maskz:\n  case X86::BI__builtin_ia32_vfmaddss3_mask3:\n  case X86::BI__builtin_ia32_vfmaddpd512_mask:\n  case X86::BI__builtin_ia32_vfmaddpd512_maskz:\n  case X86::BI__builtin_ia32_vfmaddpd512_mask3:\n  case X86::BI__builtin_ia32_vfmsubpd512_mask3:\n  case X86::BI__builtin_ia32_vfmaddps512_mask:\n  case X86::BI__builtin_ia32_vfmaddps512_maskz:\n  case X86::BI__builtin_ia32_vfmaddps512_mask3:\n  case X86::BI__builtin_ia32_vfmsubps512_mask3:\n  case X86::BI__builtin_ia32_vfmaddsubpd512_mask:\n  case X86::BI__builtin_ia32_vfmaddsubpd512_maskz:\n  case X86::BI__builtin_ia32_vfmaddsubpd512_mask3:\n  case X86::BI__builtin_ia32_vfmsubaddpd512_mask3:\n  case X86::BI__builtin_ia32_vfmaddsubps512_mask:\n  case X86::BI__builtin_ia32_vfmaddsubps512_maskz:\n  case X86::BI__builtin_ia32_vfmaddsubps512_mask3:\n  case X86::BI__builtin_ia32_vfmsubaddps512_mask3:\n    ArgNum = 4;\n    HasRC = true;\n    break;\n  }\n\n  llvm::APSInt Result;\n\n  // We can't check the value of a dependent argument.\n  Expr *Arg = TheCall->getArg(ArgNum);\n  if (Arg->isTypeDependent() || Arg->isValueDependent())\n    return false;\n\n  // Check constant-ness first.\n  if (SemaBuiltinConstantArg(TheCall, ArgNum, Result))\n    return true;\n\n  // Make sure rounding mode is either ROUND_CUR_DIRECTION or ROUND_NO_EXC bit\n  // is set. If the intrinsic has rounding control(bits 1:0), make sure its only\n  // combined with ROUND_NO_EXC. If the intrinsic does not have rounding\n  // control, allow ROUND_NO_EXC and ROUND_CUR_DIRECTION together.\n  if (Result == 4/*ROUND_CUR_DIRECTION*/ ||\n      Result == 8/*ROUND_NO_EXC*/ ||\n      (!HasRC && Result == 12/*ROUND_CUR_DIRECTION|ROUND_NO_EXC*/) ||\n      (HasRC && Result.getZExtValue() >= 8 && Result.getZExtValue() <= 11))\n    return false;\n\n  return Diag(TheCall->getBeginLoc(), diag::err_x86_builtin_invalid_rounding)\n         << Arg->getSourceRange();\n}\n\n// Check if the gather/scatter scale is legal.\nbool Sema::CheckX86BuiltinGatherScatterScale(unsigned BuiltinID,\n                                             CallExpr *TheCall) {\n  unsigned ArgNum = 0;\n  switch (BuiltinID) {\n  default:\n    return false;\n  case X86::BI__builtin_ia32_gatherpfdpd:\n  case X86::BI__builtin_ia32_gatherpfdps:\n  case X86::BI__builtin_ia32_gatherpfqpd:\n  case X86::BI__builtin_ia32_gatherpfqps:\n  case X86::BI__builtin_ia32_scatterpfdpd:\n  case X86::BI__builtin_ia32_scatterpfdps:\n  case X86::BI__builtin_ia32_scatterpfqpd:\n  case X86::BI__builtin_ia32_scatterpfqps:\n    ArgNum = 3;\n    break;\n  case X86::BI__builtin_ia32_gatherd_pd:\n  case X86::BI__builtin_ia32_gatherd_pd256:\n  case X86::BI__builtin_ia32_gatherq_pd:\n  case X86::BI__builtin_ia32_gatherq_pd256:\n  case X86::BI__builtin_ia32_gatherd_ps:\n  case X86::BI__builtin_ia32_gatherd_ps256:\n  case X86::BI__builtin_ia32_gatherq_ps:\n  case X86::BI__builtin_ia32_gatherq_ps256:\n  case X86::BI__builtin_ia32_gatherd_q:\n  case X86::BI__builtin_ia32_gatherd_q256:\n  case X86::BI__builtin_ia32_gatherq_q:\n  case X86::BI__builtin_ia32_gatherq_q256:\n  case X86::BI__builtin_ia32_gatherd_d:\n  case X86::BI__builtin_ia32_gatherd_d256:\n  case X86::BI__builtin_ia32_gatherq_d:\n  case X86::BI__builtin_ia32_gatherq_d256:\n  case X86::BI__builtin_ia32_gather3div2df:\n  case X86::BI__builtin_ia32_gather3div2di:\n  case X86::BI__builtin_ia32_gather3div4df:\n  case X86::BI__builtin_ia32_gather3div4di:\n  case X86::BI__builtin_ia32_gather3div4sf:\n  case X86::BI__builtin_ia32_gather3div4si:\n  case X86::BI__builtin_ia32_gather3div8sf:\n  case X86::BI__builtin_ia32_gather3div8si:\n  case X86::BI__builtin_ia32_gather3siv2df:\n  case X86::BI__builtin_ia32_gather3siv2di:\n  case X86::BI__builtin_ia32_gather3siv4df:\n  case X86::BI__builtin_ia32_gather3siv4di:\n  case X86::BI__builtin_ia32_gather3siv4sf:\n  case X86::BI__builtin_ia32_gather3siv4si:\n  case X86::BI__builtin_ia32_gather3siv8sf:\n  case X86::BI__builtin_ia32_gather3siv8si:\n  case X86::BI__builtin_ia32_gathersiv8df:\n  case X86::BI__builtin_ia32_gathersiv16sf:\n  case X86::BI__builtin_ia32_gatherdiv8df:\n  case X86::BI__builtin_ia32_gatherdiv16sf:\n  case X86::BI__builtin_ia32_gathersiv8di:\n  case X86::BI__builtin_ia32_gathersiv16si:\n  case X86::BI__builtin_ia32_gatherdiv8di:\n  case X86::BI__builtin_ia32_gatherdiv16si:\n  case X86::BI__builtin_ia32_scatterdiv2df:\n  case X86::BI__builtin_ia32_scatterdiv2di:\n  case X86::BI__builtin_ia32_scatterdiv4df:\n  case X86::BI__builtin_ia32_scatterdiv4di:\n  case X86::BI__builtin_ia32_scatterdiv4sf:\n  case X86::BI__builtin_ia32_scatterdiv4si:\n  case X86::BI__builtin_ia32_scatterdiv8sf:\n  case X86::BI__builtin_ia32_scatterdiv8si:\n  case X86::BI__builtin_ia32_scattersiv2df:\n  case X86::BI__builtin_ia32_scattersiv2di:\n  case X86::BI__builtin_ia32_scattersiv4df:\n  case X86::BI__builtin_ia32_scattersiv4di:\n  case X86::BI__builtin_ia32_scattersiv4sf:\n  case X86::BI__builtin_ia32_scattersiv4si:\n  case X86::BI__builtin_ia32_scattersiv8sf:\n  case X86::BI__builtin_ia32_scattersiv8si:\n  case X86::BI__builtin_ia32_scattersiv8df:\n  case X86::BI__builtin_ia32_scattersiv16sf:\n  case X86::BI__builtin_ia32_scatterdiv8df:\n  case X86::BI__builtin_ia32_scatterdiv16sf:\n  case X86::BI__builtin_ia32_scattersiv8di:\n  case X86::BI__builtin_ia32_scattersiv16si:\n  case X86::BI__builtin_ia32_scatterdiv8di:\n  case X86::BI__builtin_ia32_scatterdiv16si:\n    ArgNum = 4;\n    break;\n  }\n\n  llvm::APSInt Result;\n\n  // We can't check the value of a dependent argument.\n  Expr *Arg = TheCall->getArg(ArgNum);\n  if (Arg->isTypeDependent() || Arg->isValueDependent())\n    return false;\n\n  // Check constant-ness first.\n  if (SemaBuiltinConstantArg(TheCall, ArgNum, Result))\n    return true;\n\n  if (Result == 1 || Result == 2 || Result == 4 || Result == 8)\n    return false;\n\n  return Diag(TheCall->getBeginLoc(), diag::err_x86_builtin_invalid_scale)\n         << Arg->getSourceRange();\n}\n\nenum { TileRegLow = 0, TileRegHigh = 7 };\n\nbool Sema::CheckX86BuiltinTileArgumentsRange(CallExpr *TheCall,\n                                             ArrayRef<int> ArgNums) {\n  for (int ArgNum : ArgNums) {\n    if (SemaBuiltinConstantArgRange(TheCall, ArgNum, TileRegLow, TileRegHigh))\n      return true;\n  }\n  return false;\n}\n\nbool Sema::CheckX86BuiltinTileDuplicate(CallExpr *TheCall,\n                                        ArrayRef<int> ArgNums) {\n  // Because the max number of tile register is TileRegHigh + 1, so here we use\n  // each bit to represent the usage of them in bitset.\n  std::bitset<TileRegHigh + 1> ArgValues;\n  for (int ArgNum : ArgNums) {\n    Expr *Arg = TheCall->getArg(ArgNum);\n    if (Arg->isTypeDependent() || Arg->isValueDependent())\n      continue;\n\n    llvm::APSInt Result;\n    if (SemaBuiltinConstantArg(TheCall, ArgNum, Result))\n      return true;\n    int ArgExtValue = Result.getExtValue();\n    assert((ArgExtValue >= TileRegLow || ArgExtValue <= TileRegHigh) &&\n           \"Incorrect tile register num.\");\n    if (ArgValues.test(ArgExtValue))\n      return Diag(TheCall->getBeginLoc(),\n                  diag::err_x86_builtin_tile_arg_duplicate)\n             << TheCall->getArg(ArgNum)->getSourceRange();\n    ArgValues.set(ArgExtValue);\n  }\n  return false;\n}\n\nbool Sema::CheckX86BuiltinTileRangeAndDuplicate(CallExpr *TheCall,\n                                                ArrayRef<int> ArgNums) {\n  return CheckX86BuiltinTileArgumentsRange(TheCall, ArgNums) ||\n         CheckX86BuiltinTileDuplicate(TheCall, ArgNums);\n}\n\nbool Sema::CheckX86BuiltinTileArguments(unsigned BuiltinID, CallExpr *TheCall) {\n  switch (BuiltinID) {\n  default:\n    return false;\n  case X86::BI__builtin_ia32_tileloadd64:\n  case X86::BI__builtin_ia32_tileloaddt164:\n  case X86::BI__builtin_ia32_tilestored64:\n  case X86::BI__builtin_ia32_tilezero:\n    return CheckX86BuiltinTileArgumentsRange(TheCall, 0);\n  case X86::BI__builtin_ia32_tdpbssd:\n  case X86::BI__builtin_ia32_tdpbsud:\n  case X86::BI__builtin_ia32_tdpbusd:\n  case X86::BI__builtin_ia32_tdpbuud:\n  case X86::BI__builtin_ia32_tdpbf16ps:\n    return CheckX86BuiltinTileRangeAndDuplicate(TheCall, {0, 1, 2});\n  }\n}\nstatic bool isX86_32Builtin(unsigned BuiltinID) {\n  // These builtins only work on x86-32 targets.\n  switch (BuiltinID) {\n  case X86::BI__builtin_ia32_readeflags_u32:\n  case X86::BI__builtin_ia32_writeeflags_u32:\n    return true;\n  }\n\n  return false;\n}\n\nbool Sema::CheckX86BuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                       CallExpr *TheCall) {\n  if (BuiltinID == X86::BI__builtin_cpu_supports)\n    return SemaBuiltinCpuSupports(*this, TI, TheCall);\n\n  if (BuiltinID == X86::BI__builtin_cpu_is)\n    return SemaBuiltinCpuIs(*this, TI, TheCall);\n\n  // Check for 32-bit only builtins on a 64-bit target.\n  const llvm::Triple &TT = TI.getTriple();\n  if (TT.getArch() != llvm::Triple::x86 && isX86_32Builtin(BuiltinID))\n    return Diag(TheCall->getCallee()->getBeginLoc(),\n                diag::err_32_bit_builtin_64_bit_tgt);\n\n  // If the intrinsic has rounding or SAE make sure its valid.\n  if (CheckX86BuiltinRoundingOrSAE(BuiltinID, TheCall))\n    return true;\n\n  // If the intrinsic has a gather/scatter scale immediate make sure its valid.\n  if (CheckX86BuiltinGatherScatterScale(BuiltinID, TheCall))\n    return true;\n\n  // If the intrinsic has a tile arguments, make sure they are valid.\n  if (CheckX86BuiltinTileArguments(BuiltinID, TheCall))\n    return true;\n\n  // For intrinsics which take an immediate value as part of the instruction,\n  // range check them here.\n  int i = 0, l = 0, u = 0;\n  switch (BuiltinID) {\n  default:\n    return false;\n  case X86::BI__builtin_ia32_vec_ext_v2si:\n  case X86::BI__builtin_ia32_vec_ext_v2di:\n  case X86::BI__builtin_ia32_vextractf128_pd256:\n  case X86::BI__builtin_ia32_vextractf128_ps256:\n  case X86::BI__builtin_ia32_vextractf128_si256:\n  case X86::BI__builtin_ia32_extract128i256:\n  case X86::BI__builtin_ia32_extractf64x4_mask:\n  case X86::BI__builtin_ia32_extracti64x4_mask:\n  case X86::BI__builtin_ia32_extractf32x8_mask:\n  case X86::BI__builtin_ia32_extracti32x8_mask:\n  case X86::BI__builtin_ia32_extractf64x2_256_mask:\n  case X86::BI__builtin_ia32_extracti64x2_256_mask:\n  case X86::BI__builtin_ia32_extractf32x4_256_mask:\n  case X86::BI__builtin_ia32_extracti32x4_256_mask:\n    i = 1; l = 0; u = 1;\n    break;\n  case X86::BI__builtin_ia32_vec_set_v2di:\n  case X86::BI__builtin_ia32_vinsertf128_pd256:\n  case X86::BI__builtin_ia32_vinsertf128_ps256:\n  case X86::BI__builtin_ia32_vinsertf128_si256:\n  case X86::BI__builtin_ia32_insert128i256:\n  case X86::BI__builtin_ia32_insertf32x8:\n  case X86::BI__builtin_ia32_inserti32x8:\n  case X86::BI__builtin_ia32_insertf64x4:\n  case X86::BI__builtin_ia32_inserti64x4:\n  case X86::BI__builtin_ia32_insertf64x2_256:\n  case X86::BI__builtin_ia32_inserti64x2_256:\n  case X86::BI__builtin_ia32_insertf32x4_256:\n  case X86::BI__builtin_ia32_inserti32x4_256:\n    i = 2; l = 0; u = 1;\n    break;\n  case X86::BI__builtin_ia32_vpermilpd:\n  case X86::BI__builtin_ia32_vec_ext_v4hi:\n  case X86::BI__builtin_ia32_vec_ext_v4si:\n  case X86::BI__builtin_ia32_vec_ext_v4sf:\n  case X86::BI__builtin_ia32_vec_ext_v4di:\n  case X86::BI__builtin_ia32_extractf32x4_mask:\n  case X86::BI__builtin_ia32_extracti32x4_mask:\n  case X86::BI__builtin_ia32_extractf64x2_512_mask:\n  case X86::BI__builtin_ia32_extracti64x2_512_mask:\n    i = 1; l = 0; u = 3;\n    break;\n  case X86::BI_mm_prefetch:\n  case X86::BI__builtin_ia32_vec_ext_v8hi:\n  case X86::BI__builtin_ia32_vec_ext_v8si:\n    i = 1; l = 0; u = 7;\n    break;\n  case X86::BI__builtin_ia32_sha1rnds4:\n  case X86::BI__builtin_ia32_blendpd:\n  case X86::BI__builtin_ia32_shufpd:\n  case X86::BI__builtin_ia32_vec_set_v4hi:\n  case X86::BI__builtin_ia32_vec_set_v4si:\n  case X86::BI__builtin_ia32_vec_set_v4di:\n  case X86::BI__builtin_ia32_shuf_f32x4_256:\n  case X86::BI__builtin_ia32_shuf_f64x2_256:\n  case X86::BI__builtin_ia32_shuf_i32x4_256:\n  case X86::BI__builtin_ia32_shuf_i64x2_256:\n  case X86::BI__builtin_ia32_insertf64x2_512:\n  case X86::BI__builtin_ia32_inserti64x2_512:\n  case X86::BI__builtin_ia32_insertf32x4:\n  case X86::BI__builtin_ia32_inserti32x4:\n    i = 2; l = 0; u = 3;\n    break;\n  case X86::BI__builtin_ia32_vpermil2pd:\n  case X86::BI__builtin_ia32_vpermil2pd256:\n  case X86::BI__builtin_ia32_vpermil2ps:\n  case X86::BI__builtin_ia32_vpermil2ps256:\n    i = 3; l = 0; u = 3;\n    break;\n  case X86::BI__builtin_ia32_cmpb128_mask:\n  case X86::BI__builtin_ia32_cmpw128_mask:\n  case X86::BI__builtin_ia32_cmpd128_mask:\n  case X86::BI__builtin_ia32_cmpq128_mask:\n  case X86::BI__builtin_ia32_cmpb256_mask:\n  case X86::BI__builtin_ia32_cmpw256_mask:\n  case X86::BI__builtin_ia32_cmpd256_mask:\n  case X86::BI__builtin_ia32_cmpq256_mask:\n  case X86::BI__builtin_ia32_cmpb512_mask:\n  case X86::BI__builtin_ia32_cmpw512_mask:\n  case X86::BI__builtin_ia32_cmpd512_mask:\n  case X86::BI__builtin_ia32_cmpq512_mask:\n  case X86::BI__builtin_ia32_ucmpb128_mask:\n  case X86::BI__builtin_ia32_ucmpw128_mask:\n  case X86::BI__builtin_ia32_ucmpd128_mask:\n  case X86::BI__builtin_ia32_ucmpq128_mask:\n  case X86::BI__builtin_ia32_ucmpb256_mask:\n  case X86::BI__builtin_ia32_ucmpw256_mask:\n  case X86::BI__builtin_ia32_ucmpd256_mask:\n  case X86::BI__builtin_ia32_ucmpq256_mask:\n  case X86::BI__builtin_ia32_ucmpb512_mask:\n  case X86::BI__builtin_ia32_ucmpw512_mask:\n  case X86::BI__builtin_ia32_ucmpd512_mask:\n  case X86::BI__builtin_ia32_ucmpq512_mask:\n  case X86::BI__builtin_ia32_vpcomub:\n  case X86::BI__builtin_ia32_vpcomuw:\n  case X86::BI__builtin_ia32_vpcomud:\n  case X86::BI__builtin_ia32_vpcomuq:\n  case X86::BI__builtin_ia32_vpcomb:\n  case X86::BI__builtin_ia32_vpcomw:\n  case X86::BI__builtin_ia32_vpcomd:\n  case X86::BI__builtin_ia32_vpcomq:\n  case X86::BI__builtin_ia32_vec_set_v8hi:\n  case X86::BI__builtin_ia32_vec_set_v8si:\n    i = 2; l = 0; u = 7;\n    break;\n  case X86::BI__builtin_ia32_vpermilpd256:\n  case X86::BI__builtin_ia32_roundps:\n  case X86::BI__builtin_ia32_roundpd:\n  case X86::BI__builtin_ia32_roundps256:\n  case X86::BI__builtin_ia32_roundpd256:\n  case X86::BI__builtin_ia32_getmantpd128_mask:\n  case X86::BI__builtin_ia32_getmantpd256_mask:\n  case X86::BI__builtin_ia32_getmantps128_mask:\n  case X86::BI__builtin_ia32_getmantps256_mask:\n  case X86::BI__builtin_ia32_getmantpd512_mask:\n  case X86::BI__builtin_ia32_getmantps512_mask:\n  case X86::BI__builtin_ia32_vec_ext_v16qi:\n  case X86::BI__builtin_ia32_vec_ext_v16hi:\n    i = 1; l = 0; u = 15;\n    break;\n  case X86::BI__builtin_ia32_pblendd128:\n  case X86::BI__builtin_ia32_blendps:\n  case X86::BI__builtin_ia32_blendpd256:\n  case X86::BI__builtin_ia32_shufpd256:\n  case X86::BI__builtin_ia32_roundss:\n  case X86::BI__builtin_ia32_roundsd:\n  case X86::BI__builtin_ia32_rangepd128_mask:\n  case X86::BI__builtin_ia32_rangepd256_mask:\n  case X86::BI__builtin_ia32_rangepd512_mask:\n  case X86::BI__builtin_ia32_rangeps128_mask:\n  case X86::BI__builtin_ia32_rangeps256_mask:\n  case X86::BI__builtin_ia32_rangeps512_mask:\n  case X86::BI__builtin_ia32_getmantsd_round_mask:\n  case X86::BI__builtin_ia32_getmantss_round_mask:\n  case X86::BI__builtin_ia32_vec_set_v16qi:\n  case X86::BI__builtin_ia32_vec_set_v16hi:\n    i = 2; l = 0; u = 15;\n    break;\n  case X86::BI__builtin_ia32_vec_ext_v32qi:\n    i = 1; l = 0; u = 31;\n    break;\n  case X86::BI__builtin_ia32_cmpps:\n  case X86::BI__builtin_ia32_cmpss:\n  case X86::BI__builtin_ia32_cmppd:\n  case X86::BI__builtin_ia32_cmpsd:\n  case X86::BI__builtin_ia32_cmpps256:\n  case X86::BI__builtin_ia32_cmppd256:\n  case X86::BI__builtin_ia32_cmpps128_mask:\n  case X86::BI__builtin_ia32_cmppd128_mask:\n  case X86::BI__builtin_ia32_cmpps256_mask:\n  case X86::BI__builtin_ia32_cmppd256_mask:\n  case X86::BI__builtin_ia32_cmpps512_mask:\n  case X86::BI__builtin_ia32_cmppd512_mask:\n  case X86::BI__builtin_ia32_cmpsd_mask:\n  case X86::BI__builtin_ia32_cmpss_mask:\n  case X86::BI__builtin_ia32_vec_set_v32qi:\n    i = 2; l = 0; u = 31;\n    break;\n  case X86::BI__builtin_ia32_permdf256:\n  case X86::BI__builtin_ia32_permdi256:\n  case X86::BI__builtin_ia32_permdf512:\n  case X86::BI__builtin_ia32_permdi512:\n  case X86::BI__builtin_ia32_vpermilps:\n  case X86::BI__builtin_ia32_vpermilps256:\n  case X86::BI__builtin_ia32_vpermilpd512:\n  case X86::BI__builtin_ia32_vpermilps512:\n  case X86::BI__builtin_ia32_pshufd:\n  case X86::BI__builtin_ia32_pshufd256:\n  case X86::BI__builtin_ia32_pshufd512:\n  case X86::BI__builtin_ia32_pshufhw:\n  case X86::BI__builtin_ia32_pshufhw256:\n  case X86::BI__builtin_ia32_pshufhw512:\n  case X86::BI__builtin_ia32_pshuflw:\n  case X86::BI__builtin_ia32_pshuflw256:\n  case X86::BI__builtin_ia32_pshuflw512:\n  case X86::BI__builtin_ia32_vcvtps2ph:\n  case X86::BI__builtin_ia32_vcvtps2ph_mask:\n  case X86::BI__builtin_ia32_vcvtps2ph256:\n  case X86::BI__builtin_ia32_vcvtps2ph256_mask:\n  case X86::BI__builtin_ia32_vcvtps2ph512_mask:\n  case X86::BI__builtin_ia32_rndscaleps_128_mask:\n  case X86::BI__builtin_ia32_rndscalepd_128_mask:\n  case X86::BI__builtin_ia32_rndscaleps_256_mask:\n  case X86::BI__builtin_ia32_rndscalepd_256_mask:\n  case X86::BI__builtin_ia32_rndscaleps_mask:\n  case X86::BI__builtin_ia32_rndscalepd_mask:\n  case X86::BI__builtin_ia32_reducepd128_mask:\n  case X86::BI__builtin_ia32_reducepd256_mask:\n  case X86::BI__builtin_ia32_reducepd512_mask:\n  case X86::BI__builtin_ia32_reduceps128_mask:\n  case X86::BI__builtin_ia32_reduceps256_mask:\n  case X86::BI__builtin_ia32_reduceps512_mask:\n  case X86::BI__builtin_ia32_prold512:\n  case X86::BI__builtin_ia32_prolq512:\n  case X86::BI__builtin_ia32_prold128:\n  case X86::BI__builtin_ia32_prold256:\n  case X86::BI__builtin_ia32_prolq128:\n  case X86::BI__builtin_ia32_prolq256:\n  case X86::BI__builtin_ia32_prord512:\n  case X86::BI__builtin_ia32_prorq512:\n  case X86::BI__builtin_ia32_prord128:\n  case X86::BI__builtin_ia32_prord256:\n  case X86::BI__builtin_ia32_prorq128:\n  case X86::BI__builtin_ia32_prorq256:\n  case X86::BI__builtin_ia32_fpclasspd128_mask:\n  case X86::BI__builtin_ia32_fpclasspd256_mask:\n  case X86::BI__builtin_ia32_fpclassps128_mask:\n  case X86::BI__builtin_ia32_fpclassps256_mask:\n  case X86::BI__builtin_ia32_fpclassps512_mask:\n  case X86::BI__builtin_ia32_fpclasspd512_mask:\n  case X86::BI__builtin_ia32_fpclasssd_mask:\n  case X86::BI__builtin_ia32_fpclassss_mask:\n  case X86::BI__builtin_ia32_pslldqi128_byteshift:\n  case X86::BI__builtin_ia32_pslldqi256_byteshift:\n  case X86::BI__builtin_ia32_pslldqi512_byteshift:\n  case X86::BI__builtin_ia32_psrldqi128_byteshift:\n  case X86::BI__builtin_ia32_psrldqi256_byteshift:\n  case X86::BI__builtin_ia32_psrldqi512_byteshift:\n  case X86::BI__builtin_ia32_kshiftliqi:\n  case X86::BI__builtin_ia32_kshiftlihi:\n  case X86::BI__builtin_ia32_kshiftlisi:\n  case X86::BI__builtin_ia32_kshiftlidi:\n  case X86::BI__builtin_ia32_kshiftriqi:\n  case X86::BI__builtin_ia32_kshiftrihi:\n  case X86::BI__builtin_ia32_kshiftrisi:\n  case X86::BI__builtin_ia32_kshiftridi:\n    i = 1; l = 0; u = 255;\n    break;\n  case X86::BI__builtin_ia32_vperm2f128_pd256:\n  case X86::BI__builtin_ia32_vperm2f128_ps256:\n  case X86::BI__builtin_ia32_vperm2f128_si256:\n  case X86::BI__builtin_ia32_permti256:\n  case X86::BI__builtin_ia32_pblendw128:\n  case X86::BI__builtin_ia32_pblendw256:\n  case X86::BI__builtin_ia32_blendps256:\n  case X86::BI__builtin_ia32_pblendd256:\n  case X86::BI__builtin_ia32_palignr128:\n  case X86::BI__builtin_ia32_palignr256:\n  case X86::BI__builtin_ia32_palignr512:\n  case X86::BI__builtin_ia32_alignq512:\n  case X86::BI__builtin_ia32_alignd512:\n  case X86::BI__builtin_ia32_alignd128:\n  case X86::BI__builtin_ia32_alignd256:\n  case X86::BI__builtin_ia32_alignq128:\n  case X86::BI__builtin_ia32_alignq256:\n  case X86::BI__builtin_ia32_vcomisd:\n  case X86::BI__builtin_ia32_vcomiss:\n  case X86::BI__builtin_ia32_shuf_f32x4:\n  case X86::BI__builtin_ia32_shuf_f64x2:\n  case X86::BI__builtin_ia32_shuf_i32x4:\n  case X86::BI__builtin_ia32_shuf_i64x2:\n  case X86::BI__builtin_ia32_shufpd512:\n  case X86::BI__builtin_ia32_shufps:\n  case X86::BI__builtin_ia32_shufps256:\n  case X86::BI__builtin_ia32_shufps512:\n  case X86::BI__builtin_ia32_dbpsadbw128:\n  case X86::BI__builtin_ia32_dbpsadbw256:\n  case X86::BI__builtin_ia32_dbpsadbw512:\n  case X86::BI__builtin_ia32_vpshldd128:\n  case X86::BI__builtin_ia32_vpshldd256:\n  case X86::BI__builtin_ia32_vpshldd512:\n  case X86::BI__builtin_ia32_vpshldq128:\n  case X86::BI__builtin_ia32_vpshldq256:\n  case X86::BI__builtin_ia32_vpshldq512:\n  case X86::BI__builtin_ia32_vpshldw128:\n  case X86::BI__builtin_ia32_vpshldw256:\n  case X86::BI__builtin_ia32_vpshldw512:\n  case X86::BI__builtin_ia32_vpshrdd128:\n  case X86::BI__builtin_ia32_vpshrdd256:\n  case X86::BI__builtin_ia32_vpshrdd512:\n  case X86::BI__builtin_ia32_vpshrdq128:\n  case X86::BI__builtin_ia32_vpshrdq256:\n  case X86::BI__builtin_ia32_vpshrdq512:\n  case X86::BI__builtin_ia32_vpshrdw128:\n  case X86::BI__builtin_ia32_vpshrdw256:\n  case X86::BI__builtin_ia32_vpshrdw512:\n    i = 2; l = 0; u = 255;\n    break;\n  case X86::BI__builtin_ia32_fixupimmpd512_mask:\n  case X86::BI__builtin_ia32_fixupimmpd512_maskz:\n  case X86::BI__builtin_ia32_fixupimmps512_mask:\n  case X86::BI__builtin_ia32_fixupimmps512_maskz:\n  case X86::BI__builtin_ia32_fixupimmsd_mask:\n  case X86::BI__builtin_ia32_fixupimmsd_maskz:\n  case X86::BI__builtin_ia32_fixupimmss_mask:\n  case X86::BI__builtin_ia32_fixupimmss_maskz:\n  case X86::BI__builtin_ia32_fixupimmpd128_mask:\n  case X86::BI__builtin_ia32_fixupimmpd128_maskz:\n  case X86::BI__builtin_ia32_fixupimmpd256_mask:\n  case X86::BI__builtin_ia32_fixupimmpd256_maskz:\n  case X86::BI__builtin_ia32_fixupimmps128_mask:\n  case X86::BI__builtin_ia32_fixupimmps128_maskz:\n  case X86::BI__builtin_ia32_fixupimmps256_mask:\n  case X86::BI__builtin_ia32_fixupimmps256_maskz:\n  case X86::BI__builtin_ia32_pternlogd512_mask:\n  case X86::BI__builtin_ia32_pternlogd512_maskz:\n  case X86::BI__builtin_ia32_pternlogq512_mask:\n  case X86::BI__builtin_ia32_pternlogq512_maskz:\n  case X86::BI__builtin_ia32_pternlogd128_mask:\n  case X86::BI__builtin_ia32_pternlogd128_maskz:\n  case X86::BI__builtin_ia32_pternlogd256_mask:\n  case X86::BI__builtin_ia32_pternlogd256_maskz:\n  case X86::BI__builtin_ia32_pternlogq128_mask:\n  case X86::BI__builtin_ia32_pternlogq128_maskz:\n  case X86::BI__builtin_ia32_pternlogq256_mask:\n  case X86::BI__builtin_ia32_pternlogq256_maskz:\n    i = 3; l = 0; u = 255;\n    break;\n  case X86::BI__builtin_ia32_gatherpfdpd:\n  case X86::BI__builtin_ia32_gatherpfdps:\n  case X86::BI__builtin_ia32_gatherpfqpd:\n  case X86::BI__builtin_ia32_gatherpfqps:\n  case X86::BI__builtin_ia32_scatterpfdpd:\n  case X86::BI__builtin_ia32_scatterpfdps:\n  case X86::BI__builtin_ia32_scatterpfqpd:\n  case X86::BI__builtin_ia32_scatterpfqps:\n    i = 4; l = 2; u = 3;\n    break;\n  case X86::BI__builtin_ia32_reducesd_mask:\n  case X86::BI__builtin_ia32_reducess_mask:\n  case X86::BI__builtin_ia32_rndscalesd_round_mask:\n  case X86::BI__builtin_ia32_rndscaless_round_mask:\n    i = 4; l = 0; u = 255;\n    break;\n  }\n\n  // Note that we don't force a hard error on the range check here, allowing\n  // template-generated or macro-generated dead code to potentially have out-of-\n  // range values. These need to code generate, but don't need to necessarily\n  // make any sense. We use a warning that defaults to an error.\n  return SemaBuiltinConstantArgRange(TheCall, i, l, u, /*RangeIsError*/ false);\n}\n\n/// Given a FunctionDecl's FormatAttr, attempts to populate the FomatStringInfo\n/// parameter with the FormatAttr's correct format_idx and firstDataArg.\n/// Returns true when the format fits the function and the FormatStringInfo has\n/// been populated.\nbool Sema::getFormatStringInfo(const FormatAttr *Format, bool IsCXXMember,\n                               FormatStringInfo *FSI) {\n  FSI->HasVAListArg = Format->getFirstArg() == 0;\n  FSI->FormatIdx = Format->getFormatIdx() - 1;\n  FSI->FirstDataArg = FSI->HasVAListArg ? 0 : Format->getFirstArg() - 1;\n\n  // The way the format attribute works in GCC, the implicit this argument\n  // of member functions is counted. However, it doesn't appear in our own\n  // lists, so decrement format_idx in that case.\n  if (IsCXXMember) {\n    if(FSI->FormatIdx == 0)\n      return false;\n    --FSI->FormatIdx;\n    if (FSI->FirstDataArg != 0)\n      --FSI->FirstDataArg;\n  }\n  return true;\n}\n\n/// Checks if a the given expression evaluates to null.\n///\n/// Returns true if the value evaluates to null.\nstatic bool CheckNonNullExpr(Sema &S, const Expr *Expr) {\n  // If the expression has non-null type, it doesn't evaluate to null.\n  if (auto nullability\n        = Expr->IgnoreImplicit()->getType()->getNullability(S.Context)) {\n    if (*nullability == NullabilityKind::NonNull)\n      return false;\n  }\n\n  // As a special case, transparent unions initialized with zero are\n  // considered null for the purposes of the nonnull attribute.\n  if (const RecordType *UT = Expr->getType()->getAsUnionType()) {\n    if (UT->getDecl()->hasAttr<TransparentUnionAttr>())\n      if (const CompoundLiteralExpr *CLE =\n          dyn_cast<CompoundLiteralExpr>(Expr))\n        if (const InitListExpr *ILE =\n            dyn_cast<InitListExpr>(CLE->getInitializer()))\n          Expr = ILE->getInit(0);\n  }\n\n  bool Result;\n  return (!Expr->isValueDependent() &&\n          Expr->EvaluateAsBooleanCondition(Result, S.Context) &&\n          !Result);\n}\n\nstatic void CheckNonNullArgument(Sema &S,\n                                 const Expr *ArgExpr,\n                                 SourceLocation CallSiteLoc) {\n  if (CheckNonNullExpr(S, ArgExpr))\n    S.DiagRuntimeBehavior(CallSiteLoc, ArgExpr,\n                          S.PDiag(diag::warn_null_arg)\n                              << ArgExpr->getSourceRange());\n}\n\nbool Sema::GetFormatNSStringIdx(const FormatAttr *Format, unsigned &Idx) {\n  FormatStringInfo FSI;\n  if ((GetFormatStringType(Format) == FST_NSString) &&\n      getFormatStringInfo(Format, false, &FSI)) {\n    Idx = FSI.FormatIdx;\n    return true;\n  }\n  return false;\n}\n\n/// Diagnose use of %s directive in an NSString which is being passed\n/// as formatting string to formatting method.\nstatic void\nDiagnoseCStringFormatDirectiveInCFAPI(Sema &S,\n                                        const NamedDecl *FDecl,\n                                        Expr **Args,\n                                        unsigned NumArgs) {\n  unsigned Idx = 0;\n  bool Format = false;\n  ObjCStringFormatFamily SFFamily = FDecl->getObjCFStringFormattingFamily();\n  if (SFFamily == ObjCStringFormatFamily::SFF_CFString) {\n    Idx = 2;\n    Format = true;\n  }\n  else\n    for (const auto *I : FDecl->specific_attrs<FormatAttr>()) {\n      if (S.GetFormatNSStringIdx(I, Idx)) {\n        Format = true;\n        break;\n      }\n    }\n  if (!Format || NumArgs <= Idx)\n    return;\n  const Expr *FormatExpr = Args[Idx];\n  if (const CStyleCastExpr *CSCE = dyn_cast<CStyleCastExpr>(FormatExpr))\n    FormatExpr = CSCE->getSubExpr();\n  const StringLiteral *FormatString;\n  if (const ObjCStringLiteral *OSL =\n      dyn_cast<ObjCStringLiteral>(FormatExpr->IgnoreParenImpCasts()))\n    FormatString = OSL->getString();\n  else\n    FormatString = dyn_cast<StringLiteral>(FormatExpr->IgnoreParenImpCasts());\n  if (!FormatString)\n    return;\n  if (S.FormatStringHasSArg(FormatString)) {\n    S.Diag(FormatExpr->getExprLoc(), diag::warn_objc_cdirective_format_string)\n      << \"%s\" << 1 << 1;\n    S.Diag(FDecl->getLocation(), diag::note_entity_declared_at)\n      << FDecl->getDeclName();\n  }\n}\n\n/// Determine whether the given type has a non-null nullability annotation.\nstatic bool isNonNullType(ASTContext &ctx, QualType type) {\n  if (auto nullability = type->getNullability(ctx))\n    return *nullability == NullabilityKind::NonNull;\n\n  return false;\n}\n\nstatic void CheckNonNullArguments(Sema &S,\n                                  const NamedDecl *FDecl,\n                                  const FunctionProtoType *Proto,\n                                  ArrayRef<const Expr *> Args,\n                                  SourceLocation CallSiteLoc) {\n  assert((FDecl || Proto) && \"Need a function declaration or prototype\");\n\n  // Already checked by by constant evaluator.\n  if (S.isConstantEvaluated())\n    return;\n  // Check the attributes attached to the method/function itself.\n  llvm::SmallBitVector NonNullArgs;\n  if (FDecl) {\n    // Handle the nonnull attribute on the function/method declaration itself.\n    for (const auto *NonNull : FDecl->specific_attrs<NonNullAttr>()) {\n      if (!NonNull->args_size()) {\n        // Easy case: all pointer arguments are nonnull.\n        for (const auto *Arg : Args)\n          if (S.isValidPointerAttrType(Arg->getType()))\n            CheckNonNullArgument(S, Arg, CallSiteLoc);\n        return;\n      }\n\n      for (const ParamIdx &Idx : NonNull->args()) {\n        unsigned IdxAST = Idx.getASTIndex();\n        if (IdxAST >= Args.size())\n          continue;\n        if (NonNullArgs.empty())\n          NonNullArgs.resize(Args.size());\n        NonNullArgs.set(IdxAST);\n      }\n    }\n  }\n\n  if (FDecl && (isa<FunctionDecl>(FDecl) || isa<ObjCMethodDecl>(FDecl))) {\n    // Handle the nonnull attribute on the parameters of the\n    // function/method.\n    ArrayRef<ParmVarDecl*> parms;\n    if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(FDecl))\n      parms = FD->parameters();\n    else\n      parms = cast<ObjCMethodDecl>(FDecl)->parameters();\n\n    unsigned ParamIndex = 0;\n    for (ArrayRef<ParmVarDecl*>::iterator I = parms.begin(), E = parms.end();\n         I != E; ++I, ++ParamIndex) {\n      const ParmVarDecl *PVD = *I;\n      if (PVD->hasAttr<NonNullAttr>() ||\n          isNonNullType(S.Context, PVD->getType())) {\n        if (NonNullArgs.empty())\n          NonNullArgs.resize(Args.size());\n\n        NonNullArgs.set(ParamIndex);\n      }\n    }\n  } else {\n    // If we have a non-function, non-method declaration but no\n    // function prototype, try to dig out the function prototype.\n    if (!Proto) {\n      if (const ValueDecl *VD = dyn_cast<ValueDecl>(FDecl)) {\n        QualType type = VD->getType().getNonReferenceType();\n        if (auto pointerType = type->getAs<PointerType>())\n          type = pointerType->getPointeeType();\n        else if (auto blockType = type->getAs<BlockPointerType>())\n          type = blockType->getPointeeType();\n        // FIXME: data member pointers?\n\n        // Dig out the function prototype, if there is one.\n        Proto = type->getAs<FunctionProtoType>();\n      }\n    }\n\n    // Fill in non-null argument information from the nullability\n    // information on the parameter types (if we have them).\n    if (Proto) {\n      unsigned Index = 0;\n      for (auto paramType : Proto->getParamTypes()) {\n        if (isNonNullType(S.Context, paramType)) {\n          if (NonNullArgs.empty())\n            NonNullArgs.resize(Args.size());\n\n          NonNullArgs.set(Index);\n        }\n\n        ++Index;\n      }\n    }\n  }\n\n  // Check for non-null arguments.\n  for (unsigned ArgIndex = 0, ArgIndexEnd = NonNullArgs.size();\n       ArgIndex != ArgIndexEnd; ++ArgIndex) {\n    if (NonNullArgs[ArgIndex])\n      CheckNonNullArgument(S, Args[ArgIndex], CallSiteLoc);\n  }\n}\n\n/// Warn if a pointer or reference argument passed to a function points to an\n/// object that is less aligned than the parameter. This can happen when\n/// creating a typedef with a lower alignment than the original type and then\n/// calling functions defined in terms of the original type.\nvoid Sema::CheckArgAlignment(SourceLocation Loc, NamedDecl *FDecl,\n                             StringRef ParamName, QualType ArgTy,\n                             QualType ParamTy) {\n\n  // If a function accepts a pointer or reference type\n  if (!ParamTy->isPointerType() && !ParamTy->isReferenceType())\n    return;\n\n  // If the parameter is a pointer type, get the pointee type for the\n  // argument too. If the parameter is a reference type, don't try to get\n  // the pointee type for the argument.\n  if (ParamTy->isPointerType())\n    ArgTy = ArgTy->getPointeeType();\n\n  // Remove reference or pointer\n  ParamTy = ParamTy->getPointeeType();\n\n  // Find expected alignment, and the actual alignment of the passed object.\n  // getTypeAlignInChars requires complete types\n  if (ParamTy->isIncompleteType() || ArgTy->isIncompleteType())\n    return;\n\n  CharUnits ParamAlign = Context.getTypeAlignInChars(ParamTy);\n  CharUnits ArgAlign = Context.getTypeAlignInChars(ArgTy);\n\n  // If the argument is less aligned than the parameter, there is a\n  // potential alignment issue.\n  if (ArgAlign < ParamAlign)\n    Diag(Loc, diag::warn_param_mismatched_alignment)\n        << (int)ArgAlign.getQuantity() << (int)ParamAlign.getQuantity()\n        << ParamName << FDecl;\n}\n\n/// Handles the checks for format strings, non-POD arguments to vararg\n/// functions, NULL arguments passed to non-NULL parameters, and diagnose_if\n/// attributes.\nvoid Sema::checkCall(NamedDecl *FDecl, const FunctionProtoType *Proto,\n                     const Expr *ThisArg, ArrayRef<const Expr *> Args,\n                     bool IsMemberFunction, SourceLocation Loc,\n                     SourceRange Range, VariadicCallType CallType) {\n  // FIXME: We should check as much as we can in the template definition.\n  if (CurContext->isDependentContext())\n    return;\n\n  // Printf and scanf checking.\n  llvm::SmallBitVector CheckedVarArgs;\n  if (FDecl) {\n    for (const auto *I : FDecl->specific_attrs<FormatAttr>()) {\n      // Only create vector if there are format attributes.\n      CheckedVarArgs.resize(Args.size());\n\n      CheckFormatArguments(I, Args, IsMemberFunction, CallType, Loc, Range,\n                           CheckedVarArgs);\n    }\n  }\n\n  // Refuse POD arguments that weren't caught by the format string\n  // checks above.\n  auto *FD = dyn_cast_or_null<FunctionDecl>(FDecl);\n  if (CallType != VariadicDoesNotApply &&\n      (!FD || FD->getBuiltinID() != Builtin::BI__noop)) {\n    unsigned NumParams = Proto ? Proto->getNumParams()\n                       : FDecl && isa<FunctionDecl>(FDecl)\n                           ? cast<FunctionDecl>(FDecl)->getNumParams()\n                       : FDecl && isa<ObjCMethodDecl>(FDecl)\n                           ? cast<ObjCMethodDecl>(FDecl)->param_size()\n                       : 0;\n\n    for (unsigned ArgIdx = NumParams; ArgIdx < Args.size(); ++ArgIdx) {\n      // Args[ArgIdx] can be null in malformed code.\n      if (const Expr *Arg = Args[ArgIdx]) {\n        if (CheckedVarArgs.empty() || !CheckedVarArgs[ArgIdx])\n          checkVariadicArgument(Arg, CallType);\n      }\n    }\n  }\n\n  if (FDecl || Proto) {\n    CheckNonNullArguments(*this, FDecl, Proto, Args, Loc);\n\n    // Type safety checking.\n    if (FDecl) {\n      for (const auto *I : FDecl->specific_attrs<ArgumentWithTypeTagAttr>())\n        CheckArgumentWithTypeTag(I, Args, Loc);\n    }\n  }\n\n  // Check that passed arguments match the alignment of original arguments.\n  // Try to get the missing prototype from the declaration.\n  if (!Proto && FDecl) {\n    const auto *FT = FDecl->getFunctionType();\n    if (isa_and_nonnull<FunctionProtoType>(FT))\n      Proto = cast<FunctionProtoType>(FDecl->getFunctionType());\n  }\n  if (Proto) {\n    // For variadic functions, we may have more args than parameters.\n    // For some K&R functions, we may have less args than parameters.\n    const auto N = std::min<unsigned>(Proto->getNumParams(), Args.size());\n    for (unsigned ArgIdx = 0; ArgIdx < N; ++ArgIdx) {\n      // Args[ArgIdx] can be null in malformed code.\n      if (const Expr *Arg = Args[ArgIdx]) {\n        QualType ParamTy = Proto->getParamType(ArgIdx);\n        QualType ArgTy = Arg->getType();\n        CheckArgAlignment(Arg->getExprLoc(), FDecl, std::to_string(ArgIdx + 1),\n                          ArgTy, ParamTy);\n      }\n    }\n  }\n\n  if (FDecl && FDecl->hasAttr<AllocAlignAttr>()) {\n    auto *AA = FDecl->getAttr<AllocAlignAttr>();\n    const Expr *Arg = Args[AA->getParamIndex().getASTIndex()];\n    if (!Arg->isValueDependent()) {\n      Expr::EvalResult Align;\n      if (Arg->EvaluateAsInt(Align, Context)) {\n        const llvm::APSInt &I = Align.Val.getInt();\n        if (!I.isPowerOf2())\n          Diag(Arg->getExprLoc(), diag::warn_alignment_not_power_of_two)\n              << Arg->getSourceRange();\n\n        if (I > Sema::MaximumAlignment)\n          Diag(Arg->getExprLoc(), diag::warn_assume_aligned_too_great)\n              << Arg->getSourceRange() << Sema::MaximumAlignment;\n      }\n    }\n  }\n\n  if (FD)\n    diagnoseArgDependentDiagnoseIfAttrs(FD, ThisArg, Args, Loc);\n}\n\n/// CheckConstructorCall - Check a constructor call for correctness and safety\n/// properties not enforced by the C type system.\nvoid Sema::CheckConstructorCall(FunctionDecl *FDecl, QualType ThisType,\n                                ArrayRef<const Expr *> Args,\n                                const FunctionProtoType *Proto,\n                                SourceLocation Loc) {\n  VariadicCallType CallType =\n      Proto->isVariadic() ? VariadicConstructor : VariadicDoesNotApply;\n\n  auto *Ctor = cast<CXXConstructorDecl>(FDecl);\n  CheckArgAlignment(Loc, FDecl, \"'this'\", Context.getPointerType(ThisType),\n                    Context.getPointerType(Ctor->getThisObjectType()));\n\n  checkCall(FDecl, Proto, /*ThisArg=*/nullptr, Args, /*IsMemberFunction=*/true,\n            Loc, SourceRange(), CallType);\n}\n\n/// CheckFunctionCall - Check a direct function call for various correctness\n/// and safety properties not strictly enforced by the C type system.\nbool Sema::CheckFunctionCall(FunctionDecl *FDecl, CallExpr *TheCall,\n                             const FunctionProtoType *Proto) {\n  bool IsMemberOperatorCall = isa<CXXOperatorCallExpr>(TheCall) &&\n                              isa<CXXMethodDecl>(FDecl);\n  bool IsMemberFunction = isa<CXXMemberCallExpr>(TheCall) ||\n                          IsMemberOperatorCall;\n  VariadicCallType CallType = getVariadicCallType(FDecl, Proto,\n                                                  TheCall->getCallee());\n  Expr** Args = TheCall->getArgs();\n  unsigned NumArgs = TheCall->getNumArgs();\n\n  Expr *ImplicitThis = nullptr;\n  if (IsMemberOperatorCall) {\n    // If this is a call to a member operator, hide the first argument\n    // from checkCall.\n    // FIXME: Our choice of AST representation here is less than ideal.\n    ImplicitThis = Args[0];\n    ++Args;\n    --NumArgs;\n  } else if (IsMemberFunction)\n    ImplicitThis =\n        cast<CXXMemberCallExpr>(TheCall)->getImplicitObjectArgument();\n\n  if (ImplicitThis) {\n    // ImplicitThis may or may not be a pointer, depending on whether . or -> is\n    // used.\n    QualType ThisType = ImplicitThis->getType();\n    if (!ThisType->isPointerType()) {\n      assert(!ThisType->isReferenceType());\n      ThisType = Context.getPointerType(ThisType);\n    }\n\n    QualType ThisTypeFromDecl =\n        Context.getPointerType(cast<CXXMethodDecl>(FDecl)->getThisObjectType());\n\n    CheckArgAlignment(TheCall->getRParenLoc(), FDecl, \"'this'\", ThisType,\n                      ThisTypeFromDecl);\n  }\n\n  checkCall(FDecl, Proto, ImplicitThis, llvm::makeArrayRef(Args, NumArgs),\n            IsMemberFunction, TheCall->getRParenLoc(),\n            TheCall->getCallee()->getSourceRange(), CallType);\n\n  IdentifierInfo *FnInfo = FDecl->getIdentifier();\n  // None of the checks below are needed for functions that don't have\n  // simple names (e.g., C++ conversion functions).\n  if (!FnInfo)\n    return false;\n\n  CheckTCBEnforcement(TheCall, FDecl);\n\n  CheckAbsoluteValueFunction(TheCall, FDecl);\n  CheckMaxUnsignedZero(TheCall, FDecl);\n\n  if (getLangOpts().ObjC)\n    DiagnoseCStringFormatDirectiveInCFAPI(*this, FDecl, Args, NumArgs);\n\n  unsigned CMId = FDecl->getMemoryFunctionKind();\n\n  // Handle memory setting and copying functions.\n  switch (CMId) {\n  case 0:\n    return false;\n  case Builtin::BIstrlcpy: // fallthrough\n  case Builtin::BIstrlcat:\n    CheckStrlcpycatArguments(TheCall, FnInfo);\n    break;\n  case Builtin::BIstrncat:\n    CheckStrncatArguments(TheCall, FnInfo);\n    break;\n  case Builtin::BIfree:\n    CheckFreeArguments(TheCall);\n    break;\n  default:\n    CheckMemaccessArguments(TheCall, CMId, FnInfo);\n  }\n\n  return false;\n}\n\nbool Sema::CheckObjCMethodCall(ObjCMethodDecl *Method, SourceLocation lbrac,\n                               ArrayRef<const Expr *> Args) {\n  VariadicCallType CallType =\n      Method->isVariadic() ? VariadicMethod : VariadicDoesNotApply;\n\n  checkCall(Method, nullptr, /*ThisArg=*/nullptr, Args,\n            /*IsMemberFunction=*/false, lbrac, Method->getSourceRange(),\n            CallType);\n\n  return false;\n}\n\nbool Sema::CheckPointerCall(NamedDecl *NDecl, CallExpr *TheCall,\n                            const FunctionProtoType *Proto) {\n  QualType Ty;\n  if (const auto *V = dyn_cast<VarDecl>(NDecl))\n    Ty = V->getType().getNonReferenceType();\n  else if (const auto *F = dyn_cast<FieldDecl>(NDecl))\n    Ty = F->getType().getNonReferenceType();\n  else\n    return false;\n\n  if (!Ty->isBlockPointerType() && !Ty->isFunctionPointerType() &&\n      !Ty->isFunctionProtoType())\n    return false;\n\n  VariadicCallType CallType;\n  if (!Proto || !Proto->isVariadic()) {\n    CallType = VariadicDoesNotApply;\n  } else if (Ty->isBlockPointerType()) {\n    CallType = VariadicBlock;\n  } else { // Ty->isFunctionPointerType()\n    CallType = VariadicFunction;\n  }\n\n  checkCall(NDecl, Proto, /*ThisArg=*/nullptr,\n            llvm::makeArrayRef(TheCall->getArgs(), TheCall->getNumArgs()),\n            /*IsMemberFunction=*/false, TheCall->getRParenLoc(),\n            TheCall->getCallee()->getSourceRange(), CallType);\n\n  return false;\n}\n\n/// Checks function calls when a FunctionDecl or a NamedDecl is not available,\n/// such as function pointers returned from functions.\nbool Sema::CheckOtherCall(CallExpr *TheCall, const FunctionProtoType *Proto) {\n  VariadicCallType CallType = getVariadicCallType(/*FDecl=*/nullptr, Proto,\n                                                  TheCall->getCallee());\n  checkCall(/*FDecl=*/nullptr, Proto, /*ThisArg=*/nullptr,\n            llvm::makeArrayRef(TheCall->getArgs(), TheCall->getNumArgs()),\n            /*IsMemberFunction=*/false, TheCall->getRParenLoc(),\n            TheCall->getCallee()->getSourceRange(), CallType);\n\n  return false;\n}\n\nstatic bool isValidOrderingForOp(int64_t Ordering, AtomicExpr::AtomicOp Op) {\n  if (!llvm::isValidAtomicOrderingCABI(Ordering))\n    return false;\n\n  auto OrderingCABI = (llvm::AtomicOrderingCABI)Ordering;\n  switch (Op) {\n  case AtomicExpr::AO__c11_atomic_init:\n  case AtomicExpr::AO__opencl_atomic_init:\n    llvm_unreachable(\"There is no ordering argument for an init\");\n\n  case AtomicExpr::AO__c11_atomic_load:\n  case AtomicExpr::AO__opencl_atomic_load:\n  case AtomicExpr::AO__atomic_load_n:\n  case AtomicExpr::AO__atomic_load:\n    return OrderingCABI != llvm::AtomicOrderingCABI::release &&\n           OrderingCABI != llvm::AtomicOrderingCABI::acq_rel;\n\n  case AtomicExpr::AO__c11_atomic_store:\n  case AtomicExpr::AO__opencl_atomic_store:\n  case AtomicExpr::AO__atomic_store:\n  case AtomicExpr::AO__atomic_store_n:\n    return OrderingCABI != llvm::AtomicOrderingCABI::consume &&\n           OrderingCABI != llvm::AtomicOrderingCABI::acquire &&\n           OrderingCABI != llvm::AtomicOrderingCABI::acq_rel;\n\n  default:\n    return true;\n  }\n}\n\nExprResult Sema::SemaAtomicOpsOverloaded(ExprResult TheCallResult,\n                                         AtomicExpr::AtomicOp Op) {\n  CallExpr *TheCall = cast<CallExpr>(TheCallResult.get());\n  DeclRefExpr *DRE =cast<DeclRefExpr>(TheCall->getCallee()->IgnoreParenCasts());\n  MultiExprArg Args{TheCall->getArgs(), TheCall->getNumArgs()};\n  return BuildAtomicExpr({TheCall->getBeginLoc(), TheCall->getEndLoc()},\n                         DRE->getSourceRange(), TheCall->getRParenLoc(), Args,\n                         Op);\n}\n\nExprResult Sema::BuildAtomicExpr(SourceRange CallRange, SourceRange ExprRange,\n                                 SourceLocation RParenLoc, MultiExprArg Args,\n                                 AtomicExpr::AtomicOp Op,\n                                 AtomicArgumentOrder ArgOrder) {\n  // All the non-OpenCL operations take one of the following forms.\n  // The OpenCL operations take the __c11 forms with one extra argument for\n  // synchronization scope.\n  enum {\n    // C    __c11_atomic_init(A *, C)\n    Init,\n\n    // C    __c11_atomic_load(A *, int)\n    Load,\n\n    // void __atomic_load(A *, CP, int)\n    LoadCopy,\n\n    // void __atomic_store(A *, CP, int)\n    Copy,\n\n    // C    __c11_atomic_add(A *, M, int)\n    Arithmetic,\n\n    // C    __atomic_exchange_n(A *, CP, int)\n    Xchg,\n\n    // void __atomic_exchange(A *, C *, CP, int)\n    GNUXchg,\n\n    // bool __c11_atomic_compare_exchange_strong(A *, C *, CP, int, int)\n    C11CmpXchg,\n\n    // bool __atomic_compare_exchange(A *, C *, CP, bool, int, int)\n    GNUCmpXchg\n  } Form = Init;\n\n  const unsigned NumForm = GNUCmpXchg + 1;\n  const unsigned NumArgs[] = { 2, 2, 3, 3, 3, 3, 4, 5, 6 };\n  const unsigned NumVals[] = { 1, 0, 1, 1, 1, 1, 2, 2, 3 };\n  // where:\n  //   C is an appropriate type,\n  //   A is volatile _Atomic(C) for __c11 builtins and is C for GNU builtins,\n  //   CP is C for __c11 builtins and GNU _n builtins and is C * otherwise,\n  //   M is C if C is an integer, and ptrdiff_t if C is a pointer, and\n  //   the int parameters are for orderings.\n\n  static_assert(sizeof(NumArgs)/sizeof(NumArgs[0]) == NumForm\n      && sizeof(NumVals)/sizeof(NumVals[0]) == NumForm,\n      \"need to update code for modified forms\");\n  static_assert(AtomicExpr::AO__c11_atomic_init == 0 &&\n                    AtomicExpr::AO__c11_atomic_fetch_min + 1 ==\n                        AtomicExpr::AO__atomic_load,\n                \"need to update code for modified C11 atomics\");\n  bool IsOpenCL = Op >= AtomicExpr::AO__opencl_atomic_init &&\n                  Op <= AtomicExpr::AO__opencl_atomic_fetch_max;\n  bool IsC11 = (Op >= AtomicExpr::AO__c11_atomic_init &&\n               Op <= AtomicExpr::AO__c11_atomic_fetch_min) ||\n               IsOpenCL;\n  bool IsN = Op == AtomicExpr::AO__atomic_load_n ||\n             Op == AtomicExpr::AO__atomic_store_n ||\n             Op == AtomicExpr::AO__atomic_exchange_n ||\n             Op == AtomicExpr::AO__atomic_compare_exchange_n;\n  bool IsAddSub = false;\n\n  switch (Op) {\n  case AtomicExpr::AO__c11_atomic_init:\n  case AtomicExpr::AO__opencl_atomic_init:\n    Form = Init;\n    break;\n\n  case AtomicExpr::AO__c11_atomic_load:\n  case AtomicExpr::AO__opencl_atomic_load:\n  case AtomicExpr::AO__atomic_load_n:\n    Form = Load;\n    break;\n\n  case AtomicExpr::AO__atomic_load:\n    Form = LoadCopy;\n    break;\n\n  case AtomicExpr::AO__c11_atomic_store:\n  case AtomicExpr::AO__opencl_atomic_store:\n  case AtomicExpr::AO__atomic_store:\n  case AtomicExpr::AO__atomic_store_n:\n    Form = Copy;\n    break;\n\n  case AtomicExpr::AO__c11_atomic_fetch_add:\n  case AtomicExpr::AO__c11_atomic_fetch_sub:\n  case AtomicExpr::AO__opencl_atomic_fetch_add:\n  case AtomicExpr::AO__opencl_atomic_fetch_sub:\n  case AtomicExpr::AO__atomic_fetch_add:\n  case AtomicExpr::AO__atomic_fetch_sub:\n  case AtomicExpr::AO__atomic_add_fetch:\n  case AtomicExpr::AO__atomic_sub_fetch:\n    IsAddSub = true;\n    LLVM_FALLTHROUGH;\n  case AtomicExpr::AO__c11_atomic_fetch_and:\n  case AtomicExpr::AO__c11_atomic_fetch_or:\n  case AtomicExpr::AO__c11_atomic_fetch_xor:\n  case AtomicExpr::AO__opencl_atomic_fetch_and:\n  case AtomicExpr::AO__opencl_atomic_fetch_or:\n  case AtomicExpr::AO__opencl_atomic_fetch_xor:\n  case AtomicExpr::AO__atomic_fetch_and:\n  case AtomicExpr::AO__atomic_fetch_or:\n  case AtomicExpr::AO__atomic_fetch_xor:\n  case AtomicExpr::AO__atomic_fetch_nand:\n  case AtomicExpr::AO__atomic_and_fetch:\n  case AtomicExpr::AO__atomic_or_fetch:\n  case AtomicExpr::AO__atomic_xor_fetch:\n  case AtomicExpr::AO__atomic_nand_fetch:\n  case AtomicExpr::AO__c11_atomic_fetch_min:\n  case AtomicExpr::AO__c11_atomic_fetch_max:\n  case AtomicExpr::AO__opencl_atomic_fetch_min:\n  case AtomicExpr::AO__opencl_atomic_fetch_max:\n  case AtomicExpr::AO__atomic_min_fetch:\n  case AtomicExpr::AO__atomic_max_fetch:\n  case AtomicExpr::AO__atomic_fetch_min:\n  case AtomicExpr::AO__atomic_fetch_max:\n    Form = Arithmetic;\n    break;\n\n  case AtomicExpr::AO__c11_atomic_exchange:\n  case AtomicExpr::AO__opencl_atomic_exchange:\n  case AtomicExpr::AO__atomic_exchange_n:\n    Form = Xchg;\n    break;\n\n  case AtomicExpr::AO__atomic_exchange:\n    Form = GNUXchg;\n    break;\n\n  case AtomicExpr::AO__c11_atomic_compare_exchange_strong:\n  case AtomicExpr::AO__c11_atomic_compare_exchange_weak:\n  case AtomicExpr::AO__opencl_atomic_compare_exchange_strong:\n  case AtomicExpr::AO__opencl_atomic_compare_exchange_weak:\n    Form = C11CmpXchg;\n    break;\n\n  case AtomicExpr::AO__atomic_compare_exchange:\n  case AtomicExpr::AO__atomic_compare_exchange_n:\n    Form = GNUCmpXchg;\n    break;\n  }\n\n  unsigned AdjustedNumArgs = NumArgs[Form];\n  if (IsOpenCL && Op != AtomicExpr::AO__opencl_atomic_init)\n    ++AdjustedNumArgs;\n  // Check we have the right number of arguments.\n  if (Args.size() < AdjustedNumArgs) {\n    Diag(CallRange.getEnd(), diag::err_typecheck_call_too_few_args)\n        << 0 << AdjustedNumArgs << static_cast<unsigned>(Args.size())\n        << ExprRange;\n    return ExprError();\n  } else if (Args.size() > AdjustedNumArgs) {\n    Diag(Args[AdjustedNumArgs]->getBeginLoc(),\n         diag::err_typecheck_call_too_many_args)\n        << 0 << AdjustedNumArgs << static_cast<unsigned>(Args.size())\n        << ExprRange;\n    return ExprError();\n  }\n\n  // Inspect the first argument of the atomic operation.\n  Expr *Ptr = Args[0];\n  ExprResult ConvertedPtr = DefaultFunctionArrayLvalueConversion(Ptr);\n  if (ConvertedPtr.isInvalid())\n    return ExprError();\n\n  Ptr = ConvertedPtr.get();\n  const PointerType *pointerType = Ptr->getType()->getAs<PointerType>();\n  if (!pointerType) {\n    Diag(ExprRange.getBegin(), diag::err_atomic_builtin_must_be_pointer)\n        << Ptr->getType() << Ptr->getSourceRange();\n    return ExprError();\n  }\n\n  // For a __c11 builtin, this should be a pointer to an _Atomic type.\n  QualType AtomTy = pointerType->getPointeeType(); // 'A'\n  QualType ValType = AtomTy; // 'C'\n  if (IsC11) {\n    if (!AtomTy->isAtomicType()) {\n      Diag(ExprRange.getBegin(), diag::err_atomic_op_needs_atomic)\n          << Ptr->getType() << Ptr->getSourceRange();\n      return ExprError();\n    }\n    if ((Form != Load && Form != LoadCopy && AtomTy.isConstQualified()) ||\n        AtomTy.getAddressSpace() == LangAS::opencl_constant) {\n      Diag(ExprRange.getBegin(), diag::err_atomic_op_needs_non_const_atomic)\n          << (AtomTy.isConstQualified() ? 0 : 1) << Ptr->getType()\n          << Ptr->getSourceRange();\n      return ExprError();\n    }\n    ValType = AtomTy->castAs<AtomicType>()->getValueType();\n  } else if (Form != Load && Form != LoadCopy) {\n    if (ValType.isConstQualified()) {\n      Diag(ExprRange.getBegin(), diag::err_atomic_op_needs_non_const_pointer)\n          << Ptr->getType() << Ptr->getSourceRange();\n      return ExprError();\n    }\n  }\n\n  // For an arithmetic operation, the implied arithmetic must be well-formed.\n  if (Form == Arithmetic) {\n    // gcc does not enforce these rules for GNU atomics, but we do so for sanity.\n    if (IsAddSub && !ValType->isIntegerType()\n        && !ValType->isPointerType()) {\n      Diag(ExprRange.getBegin(), diag::err_atomic_op_needs_atomic_int_or_ptr)\n          << IsC11 << Ptr->getType() << Ptr->getSourceRange();\n      return ExprError();\n    }\n    if (!IsAddSub && !ValType->isIntegerType()) {\n      Diag(ExprRange.getBegin(), diag::err_atomic_op_needs_atomic_int)\n          << IsC11 << Ptr->getType() << Ptr->getSourceRange();\n      return ExprError();\n    }\n    if (IsC11 && ValType->isPointerType() &&\n        RequireCompleteType(Ptr->getBeginLoc(), ValType->getPointeeType(),\n                            diag::err_incomplete_type)) {\n      return ExprError();\n    }\n  } else if (IsN && !ValType->isIntegerType() && !ValType->isPointerType()) {\n    // For __atomic_*_n operations, the value type must be a scalar integral or\n    // pointer type which is 1, 2, 4, 8 or 16 bytes in length.\n    Diag(ExprRange.getBegin(), diag::err_atomic_op_needs_atomic_int_or_ptr)\n        << IsC11 << Ptr->getType() << Ptr->getSourceRange();\n    return ExprError();\n  }\n\n  if (!IsC11 && !AtomTy.isTriviallyCopyableType(Context) &&\n      !AtomTy->isScalarType()) {\n    // For GNU atomics, require a trivially-copyable type. This is not part of\n    // the GNU atomics specification, but we enforce it for sanity.\n    Diag(ExprRange.getBegin(), diag::err_atomic_op_needs_trivial_copy)\n        << Ptr->getType() << Ptr->getSourceRange();\n    return ExprError();\n  }\n\n  switch (ValType.getObjCLifetime()) {\n  case Qualifiers::OCL_None:\n  case Qualifiers::OCL_ExplicitNone:\n    // okay\n    break;\n\n  case Qualifiers::OCL_Weak:\n  case Qualifiers::OCL_Strong:\n  case Qualifiers::OCL_Autoreleasing:\n    // FIXME: Can this happen? By this point, ValType should be known\n    // to be trivially copyable.\n    Diag(ExprRange.getBegin(), diag::err_arc_atomic_ownership)\n        << ValType << Ptr->getSourceRange();\n    return ExprError();\n  }\n\n  // All atomic operations have an overload which takes a pointer to a volatile\n  // 'A'.  We shouldn't let the volatile-ness of the pointee-type inject itself\n  // into the result or the other operands. Similarly atomic_load takes a\n  // pointer to a const 'A'.\n  ValType.removeLocalVolatile();\n  ValType.removeLocalConst();\n  QualType ResultType = ValType;\n  if (Form == Copy || Form == LoadCopy || Form == GNUXchg ||\n      Form == Init)\n    ResultType = Context.VoidTy;\n  else if (Form == C11CmpXchg || Form == GNUCmpXchg)\n    ResultType = Context.BoolTy;\n\n  // The type of a parameter passed 'by value'. In the GNU atomics, such\n  // arguments are actually passed as pointers.\n  QualType ByValType = ValType; // 'CP'\n  bool IsPassedByAddress = false;\n  if (!IsC11 && !IsN) {\n    ByValType = Ptr->getType();\n    IsPassedByAddress = true;\n  }\n\n  SmallVector<Expr *, 5> APIOrderedArgs;\n  if (ArgOrder == Sema::AtomicArgumentOrder::AST) {\n    APIOrderedArgs.push_back(Args[0]);\n    switch (Form) {\n    case Init:\n    case Load:\n      APIOrderedArgs.push_back(Args[1]); // Val1/Order\n      break;\n    case LoadCopy:\n    case Copy:\n    case Arithmetic:\n    case Xchg:\n      APIOrderedArgs.push_back(Args[2]); // Val1\n      APIOrderedArgs.push_back(Args[1]); // Order\n      break;\n    case GNUXchg:\n      APIOrderedArgs.push_back(Args[2]); // Val1\n      APIOrderedArgs.push_back(Args[3]); // Val2\n      APIOrderedArgs.push_back(Args[1]); // Order\n      break;\n    case C11CmpXchg:\n      APIOrderedArgs.push_back(Args[2]); // Val1\n      APIOrderedArgs.push_back(Args[4]); // Val2\n      APIOrderedArgs.push_back(Args[1]); // Order\n      APIOrderedArgs.push_back(Args[3]); // OrderFail\n      break;\n    case GNUCmpXchg:\n      APIOrderedArgs.push_back(Args[2]); // Val1\n      APIOrderedArgs.push_back(Args[4]); // Val2\n      APIOrderedArgs.push_back(Args[5]); // Weak\n      APIOrderedArgs.push_back(Args[1]); // Order\n      APIOrderedArgs.push_back(Args[3]); // OrderFail\n      break;\n    }\n  } else\n    APIOrderedArgs.append(Args.begin(), Args.end());\n\n  // The first argument's non-CV pointer type is used to deduce the type of\n  // subsequent arguments, except for:\n  //  - weak flag (always converted to bool)\n  //  - memory order (always converted to int)\n  //  - scope  (always converted to int)\n  for (unsigned i = 0; i != APIOrderedArgs.size(); ++i) {\n    QualType Ty;\n    if (i < NumVals[Form] + 1) {\n      switch (i) {\n      case 0:\n        // The first argument is always a pointer. It has a fixed type.\n        // It is always dereferenced, a nullptr is undefined.\n        CheckNonNullArgument(*this, APIOrderedArgs[i], ExprRange.getBegin());\n        // Nothing else to do: we already know all we want about this pointer.\n        continue;\n      case 1:\n        // The second argument is the non-atomic operand. For arithmetic, this\n        // is always passed by value, and for a compare_exchange it is always\n        // passed by address. For the rest, GNU uses by-address and C11 uses\n        // by-value.\n        assert(Form != Load);\n        if (Form == Init || (Form == Arithmetic && ValType->isIntegerType()))\n          Ty = ValType;\n        else if (Form == Copy || Form == Xchg) {\n          if (IsPassedByAddress) {\n            // The value pointer is always dereferenced, a nullptr is undefined.\n            CheckNonNullArgument(*this, APIOrderedArgs[i],\n                                 ExprRange.getBegin());\n          }\n          Ty = ByValType;\n        } else if (Form == Arithmetic)\n          Ty = Context.getPointerDiffType();\n        else {\n          Expr *ValArg = APIOrderedArgs[i];\n          // The value pointer is always dereferenced, a nullptr is undefined.\n          CheckNonNullArgument(*this, ValArg, ExprRange.getBegin());\n          LangAS AS = LangAS::Default;\n          // Keep address space of non-atomic pointer type.\n          if (const PointerType *PtrTy =\n                  ValArg->getType()->getAs<PointerType>()) {\n            AS = PtrTy->getPointeeType().getAddressSpace();\n          }\n          Ty = Context.getPointerType(\n              Context.getAddrSpaceQualType(ValType.getUnqualifiedType(), AS));\n        }\n        break;\n      case 2:\n        // The third argument to compare_exchange / GNU exchange is the desired\n        // value, either by-value (for the C11 and *_n variant) or as a pointer.\n        if (IsPassedByAddress)\n          CheckNonNullArgument(*this, APIOrderedArgs[i], ExprRange.getBegin());\n        Ty = ByValType;\n        break;\n      case 3:\n        // The fourth argument to GNU compare_exchange is a 'weak' flag.\n        Ty = Context.BoolTy;\n        break;\n      }\n    } else {\n      // The order(s) and scope are always converted to int.\n      Ty = Context.IntTy;\n    }\n\n    InitializedEntity Entity =\n        InitializedEntity::InitializeParameter(Context, Ty, false);\n    ExprResult Arg = APIOrderedArgs[i];\n    Arg = PerformCopyInitialization(Entity, SourceLocation(), Arg);\n    if (Arg.isInvalid())\n      return true;\n    APIOrderedArgs[i] = Arg.get();\n  }\n\n  // Permute the arguments into a 'consistent' order.\n  SmallVector<Expr*, 5> SubExprs;\n  SubExprs.push_back(Ptr);\n  switch (Form) {\n  case Init:\n    // Note, AtomicExpr::getVal1() has a special case for this atomic.\n    SubExprs.push_back(APIOrderedArgs[1]); // Val1\n    break;\n  case Load:\n    SubExprs.push_back(APIOrderedArgs[1]); // Order\n    break;\n  case LoadCopy:\n  case Copy:\n  case Arithmetic:\n  case Xchg:\n    SubExprs.push_back(APIOrderedArgs[2]); // Order\n    SubExprs.push_back(APIOrderedArgs[1]); // Val1\n    break;\n  case GNUXchg:\n    // Note, AtomicExpr::getVal2() has a special case for this atomic.\n    SubExprs.push_back(APIOrderedArgs[3]); // Order\n    SubExprs.push_back(APIOrderedArgs[1]); // Val1\n    SubExprs.push_back(APIOrderedArgs[2]); // Val2\n    break;\n  case C11CmpXchg:\n    SubExprs.push_back(APIOrderedArgs[3]); // Order\n    SubExprs.push_back(APIOrderedArgs[1]); // Val1\n    SubExprs.push_back(APIOrderedArgs[4]); // OrderFail\n    SubExprs.push_back(APIOrderedArgs[2]); // Val2\n    break;\n  case GNUCmpXchg:\n    SubExprs.push_back(APIOrderedArgs[4]); // Order\n    SubExprs.push_back(APIOrderedArgs[1]); // Val1\n    SubExprs.push_back(APIOrderedArgs[5]); // OrderFail\n    SubExprs.push_back(APIOrderedArgs[2]); // Val2\n    SubExprs.push_back(APIOrderedArgs[3]); // Weak\n    break;\n  }\n\n  if (SubExprs.size() >= 2 && Form != Init) {\n    if (Optional<llvm::APSInt> Result =\n            SubExprs[1]->getIntegerConstantExpr(Context))\n      if (!isValidOrderingForOp(Result->getSExtValue(), Op))\n        Diag(SubExprs[1]->getBeginLoc(),\n             diag::warn_atomic_op_has_invalid_memory_order)\n            << SubExprs[1]->getSourceRange();\n  }\n\n  if (auto ScopeModel = AtomicExpr::getScopeModel(Op)) {\n    auto *Scope = Args[Args.size() - 1];\n    if (Optional<llvm::APSInt> Result =\n            Scope->getIntegerConstantExpr(Context)) {\n      if (!ScopeModel->isValid(Result->getZExtValue()))\n        Diag(Scope->getBeginLoc(), diag::err_atomic_op_has_invalid_synch_scope)\n            << Scope->getSourceRange();\n    }\n    SubExprs.push_back(Scope);\n  }\n\n  AtomicExpr *AE = new (Context)\n      AtomicExpr(ExprRange.getBegin(), SubExprs, ResultType, Op, RParenLoc);\n\n  if ((Op == AtomicExpr::AO__c11_atomic_load ||\n       Op == AtomicExpr::AO__c11_atomic_store ||\n       Op == AtomicExpr::AO__opencl_atomic_load ||\n       Op == AtomicExpr::AO__opencl_atomic_store ) &&\n      Context.AtomicUsesUnsupportedLibcall(AE))\n    Diag(AE->getBeginLoc(), diag::err_atomic_load_store_uses_lib)\n        << ((Op == AtomicExpr::AO__c11_atomic_load ||\n             Op == AtomicExpr::AO__opencl_atomic_load)\n                ? 0\n                : 1);\n\n  if (ValType->isExtIntType()) {\n    Diag(Ptr->getExprLoc(), diag::err_atomic_builtin_ext_int_prohibit);\n    return ExprError();\n  }\n\n  return AE;\n}\n\n/// checkBuiltinArgument - Given a call to a builtin function, perform\n/// normal type-checking on the given argument, updating the call in\n/// place.  This is useful when a builtin function requires custom\n/// type-checking for some of its arguments but not necessarily all of\n/// them.\n///\n/// Returns true on error.\nstatic bool checkBuiltinArgument(Sema &S, CallExpr *E, unsigned ArgIndex) {\n  FunctionDecl *Fn = E->getDirectCallee();\n  assert(Fn && \"builtin call without direct callee!\");\n\n  ParmVarDecl *Param = Fn->getParamDecl(ArgIndex);\n  InitializedEntity Entity =\n    InitializedEntity::InitializeParameter(S.Context, Param);\n\n  ExprResult Arg = E->getArg(0);\n  Arg = S.PerformCopyInitialization(Entity, SourceLocation(), Arg);\n  if (Arg.isInvalid())\n    return true;\n\n  E->setArg(ArgIndex, Arg.get());\n  return false;\n}\n\n/// We have a call to a function like __sync_fetch_and_add, which is an\n/// overloaded function based on the pointer type of its first argument.\n/// The main BuildCallExpr routines have already promoted the types of\n/// arguments because all of these calls are prototyped as void(...).\n///\n/// This function goes through and does final semantic checking for these\n/// builtins, as well as generating any warnings.\nExprResult\nSema::SemaBuiltinAtomicOverloaded(ExprResult TheCallResult) {\n  CallExpr *TheCall = static_cast<CallExpr *>(TheCallResult.get());\n  Expr *Callee = TheCall->getCallee();\n  DeclRefExpr *DRE = cast<DeclRefExpr>(Callee->IgnoreParenCasts());\n  FunctionDecl *FDecl = cast<FunctionDecl>(DRE->getDecl());\n\n  // Ensure that we have at least one argument to do type inference from.\n  if (TheCall->getNumArgs() < 1) {\n    Diag(TheCall->getEndLoc(), diag::err_typecheck_call_too_few_args_at_least)\n        << 0 << 1 << TheCall->getNumArgs() << Callee->getSourceRange();\n    return ExprError();\n  }\n\n  // Inspect the first argument of the atomic builtin.  This should always be\n  // a pointer type, whose element is an integral scalar or pointer type.\n  // Because it is a pointer type, we don't have to worry about any implicit\n  // casts here.\n  // FIXME: We don't allow floating point scalars as input.\n  Expr *FirstArg = TheCall->getArg(0);\n  ExprResult FirstArgResult = DefaultFunctionArrayLvalueConversion(FirstArg);\n  if (FirstArgResult.isInvalid())\n    return ExprError();\n  FirstArg = FirstArgResult.get();\n  TheCall->setArg(0, FirstArg);\n\n  const PointerType *pointerType = FirstArg->getType()->getAs<PointerType>();\n  if (!pointerType) {\n    Diag(DRE->getBeginLoc(), diag::err_atomic_builtin_must_be_pointer)\n        << FirstArg->getType() << FirstArg->getSourceRange();\n    return ExprError();\n  }\n\n  QualType ValType = pointerType->getPointeeType();\n  if (!ValType->isIntegerType() && !ValType->isAnyPointerType() &&\n      !ValType->isBlockPointerType()) {\n    Diag(DRE->getBeginLoc(), diag::err_atomic_builtin_must_be_pointer_intptr)\n        << FirstArg->getType() << FirstArg->getSourceRange();\n    return ExprError();\n  }\n\n  if (ValType.isConstQualified()) {\n    Diag(DRE->getBeginLoc(), diag::err_atomic_builtin_cannot_be_const)\n        << FirstArg->getType() << FirstArg->getSourceRange();\n    return ExprError();\n  }\n\n  switch (ValType.getObjCLifetime()) {\n  case Qualifiers::OCL_None:\n  case Qualifiers::OCL_ExplicitNone:\n    // okay\n    break;\n\n  case Qualifiers::OCL_Weak:\n  case Qualifiers::OCL_Strong:\n  case Qualifiers::OCL_Autoreleasing:\n    Diag(DRE->getBeginLoc(), diag::err_arc_atomic_ownership)\n        << ValType << FirstArg->getSourceRange();\n    return ExprError();\n  }\n\n  // Strip any qualifiers off ValType.\n  ValType = ValType.getUnqualifiedType();\n\n  // The majority of builtins return a value, but a few have special return\n  // types, so allow them to override appropriately below.\n  QualType ResultType = ValType;\n\n  // We need to figure out which concrete builtin this maps onto.  For example,\n  // __sync_fetch_and_add with a 2 byte object turns into\n  // __sync_fetch_and_add_2.\n#define BUILTIN_ROW(x) \\\n  { Builtin::BI##x##_1, Builtin::BI##x##_2, Builtin::BI##x##_4, \\\n    Builtin::BI##x##_8, Builtin::BI##x##_16 }\n\n  static const unsigned BuiltinIndices[][5] = {\n    BUILTIN_ROW(__sync_fetch_and_add),\n    BUILTIN_ROW(__sync_fetch_and_sub),\n    BUILTIN_ROW(__sync_fetch_and_or),\n    BUILTIN_ROW(__sync_fetch_and_and),\n    BUILTIN_ROW(__sync_fetch_and_xor),\n    BUILTIN_ROW(__sync_fetch_and_nand),\n\n    BUILTIN_ROW(__sync_add_and_fetch),\n    BUILTIN_ROW(__sync_sub_and_fetch),\n    BUILTIN_ROW(__sync_and_and_fetch),\n    BUILTIN_ROW(__sync_or_and_fetch),\n    BUILTIN_ROW(__sync_xor_and_fetch),\n    BUILTIN_ROW(__sync_nand_and_fetch),\n\n    BUILTIN_ROW(__sync_val_compare_and_swap),\n    BUILTIN_ROW(__sync_bool_compare_and_swap),\n    BUILTIN_ROW(__sync_lock_test_and_set),\n    BUILTIN_ROW(__sync_lock_release),\n    BUILTIN_ROW(__sync_swap)\n  };\n#undef BUILTIN_ROW\n\n  // Determine the index of the size.\n  unsigned SizeIndex;\n  switch (Context.getTypeSizeInChars(ValType).getQuantity()) {\n  case 1: SizeIndex = 0; break;\n  case 2: SizeIndex = 1; break;\n  case 4: SizeIndex = 2; break;\n  case 8: SizeIndex = 3; break;\n  case 16: SizeIndex = 4; break;\n  default:\n    Diag(DRE->getBeginLoc(), diag::err_atomic_builtin_pointer_size)\n        << FirstArg->getType() << FirstArg->getSourceRange();\n    return ExprError();\n  }\n\n  // Each of these builtins has one pointer argument, followed by some number of\n  // values (0, 1 or 2) followed by a potentially empty varags list of stuff\n  // that we ignore.  Find out which row of BuiltinIndices to read from as well\n  // as the number of fixed args.\n  unsigned BuiltinID = FDecl->getBuiltinID();\n  unsigned BuiltinIndex, NumFixed = 1;\n  bool WarnAboutSemanticsChange = false;\n  switch (BuiltinID) {\n  default: llvm_unreachable(\"Unknown overloaded atomic builtin!\");\n  case Builtin::BI__sync_fetch_and_add:\n  case Builtin::BI__sync_fetch_and_add_1:\n  case Builtin::BI__sync_fetch_and_add_2:\n  case Builtin::BI__sync_fetch_and_add_4:\n  case Builtin::BI__sync_fetch_and_add_8:\n  case Builtin::BI__sync_fetch_and_add_16:\n    BuiltinIndex = 0;\n    break;\n\n  case Builtin::BI__sync_fetch_and_sub:\n  case Builtin::BI__sync_fetch_and_sub_1:\n  case Builtin::BI__sync_fetch_and_sub_2:\n  case Builtin::BI__sync_fetch_and_sub_4:\n  case Builtin::BI__sync_fetch_and_sub_8:\n  case Builtin::BI__sync_fetch_and_sub_16:\n    BuiltinIndex = 1;\n    break;\n\n  case Builtin::BI__sync_fetch_and_or:\n  case Builtin::BI__sync_fetch_and_or_1:\n  case Builtin::BI__sync_fetch_and_or_2:\n  case Builtin::BI__sync_fetch_and_or_4:\n  case Builtin::BI__sync_fetch_and_or_8:\n  case Builtin::BI__sync_fetch_and_or_16:\n    BuiltinIndex = 2;\n    break;\n\n  case Builtin::BI__sync_fetch_and_and:\n  case Builtin::BI__sync_fetch_and_and_1:\n  case Builtin::BI__sync_fetch_and_and_2:\n  case Builtin::BI__sync_fetch_and_and_4:\n  case Builtin::BI__sync_fetch_and_and_8:\n  case Builtin::BI__sync_fetch_and_and_16:\n    BuiltinIndex = 3;\n    break;\n\n  case Builtin::BI__sync_fetch_and_xor:\n  case Builtin::BI__sync_fetch_and_xor_1:\n  case Builtin::BI__sync_fetch_and_xor_2:\n  case Builtin::BI__sync_fetch_and_xor_4:\n  case Builtin::BI__sync_fetch_and_xor_8:\n  case Builtin::BI__sync_fetch_and_xor_16:\n    BuiltinIndex = 4;\n    break;\n\n  case Builtin::BI__sync_fetch_and_nand:\n  case Builtin::BI__sync_fetch_and_nand_1:\n  case Builtin::BI__sync_fetch_and_nand_2:\n  case Builtin::BI__sync_fetch_and_nand_4:\n  case Builtin::BI__sync_fetch_and_nand_8:\n  case Builtin::BI__sync_fetch_and_nand_16:\n    BuiltinIndex = 5;\n    WarnAboutSemanticsChange = true;\n    break;\n\n  case Builtin::BI__sync_add_and_fetch:\n  case Builtin::BI__sync_add_and_fetch_1:\n  case Builtin::BI__sync_add_and_fetch_2:\n  case Builtin::BI__sync_add_and_fetch_4:\n  case Builtin::BI__sync_add_and_fetch_8:\n  case Builtin::BI__sync_add_and_fetch_16:\n    BuiltinIndex = 6;\n    break;\n\n  case Builtin::BI__sync_sub_and_fetch:\n  case Builtin::BI__sync_sub_and_fetch_1:\n  case Builtin::BI__sync_sub_and_fetch_2:\n  case Builtin::BI__sync_sub_and_fetch_4:\n  case Builtin::BI__sync_sub_and_fetch_8:\n  case Builtin::BI__sync_sub_and_fetch_16:\n    BuiltinIndex = 7;\n    break;\n\n  case Builtin::BI__sync_and_and_fetch:\n  case Builtin::BI__sync_and_and_fetch_1:\n  case Builtin::BI__sync_and_and_fetch_2:\n  case Builtin::BI__sync_and_and_fetch_4:\n  case Builtin::BI__sync_and_and_fetch_8:\n  case Builtin::BI__sync_and_and_fetch_16:\n    BuiltinIndex = 8;\n    break;\n\n  case Builtin::BI__sync_or_and_fetch:\n  case Builtin::BI__sync_or_and_fetch_1:\n  case Builtin::BI__sync_or_and_fetch_2:\n  case Builtin::BI__sync_or_and_fetch_4:\n  case Builtin::BI__sync_or_and_fetch_8:\n  case Builtin::BI__sync_or_and_fetch_16:\n    BuiltinIndex = 9;\n    break;\n\n  case Builtin::BI__sync_xor_and_fetch:\n  case Builtin::BI__sync_xor_and_fetch_1:\n  case Builtin::BI__sync_xor_and_fetch_2:\n  case Builtin::BI__sync_xor_and_fetch_4:\n  case Builtin::BI__sync_xor_and_fetch_8:\n  case Builtin::BI__sync_xor_and_fetch_16:\n    BuiltinIndex = 10;\n    break;\n\n  case Builtin::BI__sync_nand_and_fetch:\n  case Builtin::BI__sync_nand_and_fetch_1:\n  case Builtin::BI__sync_nand_and_fetch_2:\n  case Builtin::BI__sync_nand_and_fetch_4:\n  case Builtin::BI__sync_nand_and_fetch_8:\n  case Builtin::BI__sync_nand_and_fetch_16:\n    BuiltinIndex = 11;\n    WarnAboutSemanticsChange = true;\n    break;\n\n  case Builtin::BI__sync_val_compare_and_swap:\n  case Builtin::BI__sync_val_compare_and_swap_1:\n  case Builtin::BI__sync_val_compare_and_swap_2:\n  case Builtin::BI__sync_val_compare_and_swap_4:\n  case Builtin::BI__sync_val_compare_and_swap_8:\n  case Builtin::BI__sync_val_compare_and_swap_16:\n    BuiltinIndex = 12;\n    NumFixed = 2;\n    break;\n\n  case Builtin::BI__sync_bool_compare_and_swap:\n  case Builtin::BI__sync_bool_compare_and_swap_1:\n  case Builtin::BI__sync_bool_compare_and_swap_2:\n  case Builtin::BI__sync_bool_compare_and_swap_4:\n  case Builtin::BI__sync_bool_compare_and_swap_8:\n  case Builtin::BI__sync_bool_compare_and_swap_16:\n    BuiltinIndex = 13;\n    NumFixed = 2;\n    ResultType = Context.BoolTy;\n    break;\n\n  case Builtin::BI__sync_lock_test_and_set:\n  case Builtin::BI__sync_lock_test_and_set_1:\n  case Builtin::BI__sync_lock_test_and_set_2:\n  case Builtin::BI__sync_lock_test_and_set_4:\n  case Builtin::BI__sync_lock_test_and_set_8:\n  case Builtin::BI__sync_lock_test_and_set_16:\n    BuiltinIndex = 14;\n    break;\n\n  case Builtin::BI__sync_lock_release:\n  case Builtin::BI__sync_lock_release_1:\n  case Builtin::BI__sync_lock_release_2:\n  case Builtin::BI__sync_lock_release_4:\n  case Builtin::BI__sync_lock_release_8:\n  case Builtin::BI__sync_lock_release_16:\n    BuiltinIndex = 15;\n    NumFixed = 0;\n    ResultType = Context.VoidTy;\n    break;\n\n  case Builtin::BI__sync_swap:\n  case Builtin::BI__sync_swap_1:\n  case Builtin::BI__sync_swap_2:\n  case Builtin::BI__sync_swap_4:\n  case Builtin::BI__sync_swap_8:\n  case Builtin::BI__sync_swap_16:\n    BuiltinIndex = 16;\n    break;\n  }\n\n  // Now that we know how many fixed arguments we expect, first check that we\n  // have at least that many.\n  if (TheCall->getNumArgs() < 1+NumFixed) {\n    Diag(TheCall->getEndLoc(), diag::err_typecheck_call_too_few_args_at_least)\n        << 0 << 1 + NumFixed << TheCall->getNumArgs()\n        << Callee->getSourceRange();\n    return ExprError();\n  }\n\n  Diag(TheCall->getEndLoc(), diag::warn_atomic_implicit_seq_cst)\n      << Callee->getSourceRange();\n\n  if (WarnAboutSemanticsChange) {\n    Diag(TheCall->getEndLoc(), diag::warn_sync_fetch_and_nand_semantics_change)\n        << Callee->getSourceRange();\n  }\n\n  // Get the decl for the concrete builtin from this, we can tell what the\n  // concrete integer type we should convert to is.\n  unsigned NewBuiltinID = BuiltinIndices[BuiltinIndex][SizeIndex];\n  const char *NewBuiltinName = Context.BuiltinInfo.getName(NewBuiltinID);\n  FunctionDecl *NewBuiltinDecl;\n  if (NewBuiltinID == BuiltinID)\n    NewBuiltinDecl = FDecl;\n  else {\n    // Perform builtin lookup to avoid redeclaring it.\n    DeclarationName DN(&Context.Idents.get(NewBuiltinName));\n    LookupResult Res(*this, DN, DRE->getBeginLoc(), LookupOrdinaryName);\n    LookupName(Res, TUScope, /*AllowBuiltinCreation=*/true);\n    assert(Res.getFoundDecl());\n    NewBuiltinDecl = dyn_cast<FunctionDecl>(Res.getFoundDecl());\n    if (!NewBuiltinDecl)\n      return ExprError();\n  }\n\n  // The first argument --- the pointer --- has a fixed type; we\n  // deduce the types of the rest of the arguments accordingly.  Walk\n  // the remaining arguments, converting them to the deduced value type.\n  for (unsigned i = 0; i != NumFixed; ++i) {\n    ExprResult Arg = TheCall->getArg(i+1);\n\n    // GCC does an implicit conversion to the pointer or integer ValType.  This\n    // can fail in some cases (1i -> int**), check for this error case now.\n    // Initialize the argument.\n    InitializedEntity Entity = InitializedEntity::InitializeParameter(Context,\n                                                   ValType, /*consume*/ false);\n    Arg = PerformCopyInitialization(Entity, SourceLocation(), Arg);\n    if (Arg.isInvalid())\n      return ExprError();\n\n    // Okay, we have something that *can* be converted to the right type.  Check\n    // to see if there is a potentially weird extension going on here.  This can\n    // happen when you do an atomic operation on something like an char* and\n    // pass in 42.  The 42 gets converted to char.  This is even more strange\n    // for things like 45.123 -> char, etc.\n    // FIXME: Do this check.\n    TheCall->setArg(i+1, Arg.get());\n  }\n\n  // Create a new DeclRefExpr to refer to the new decl.\n  DeclRefExpr *NewDRE = DeclRefExpr::Create(\n      Context, DRE->getQualifierLoc(), SourceLocation(), NewBuiltinDecl,\n      /*enclosing*/ false, DRE->getLocation(), Context.BuiltinFnTy,\n      DRE->getValueKind(), nullptr, nullptr, DRE->isNonOdrUse());\n\n  // Set the callee in the CallExpr.\n  // FIXME: This loses syntactic information.\n  QualType CalleePtrTy = Context.getPointerType(NewBuiltinDecl->getType());\n  ExprResult PromotedCall = ImpCastExprToType(NewDRE, CalleePtrTy,\n                                              CK_BuiltinFnToFnPtr);\n  TheCall->setCallee(PromotedCall.get());\n\n  // Change the result type of the call to match the original value type. This\n  // is arbitrary, but the codegen for these builtins ins design to handle it\n  // gracefully.\n  TheCall->setType(ResultType);\n\n  // Prohibit use of _ExtInt with atomic builtins.\n  // The arguments would have already been converted to the first argument's\n  // type, so only need to check the first argument.\n  const auto *ExtIntValType = ValType->getAs<ExtIntType>();\n  if (ExtIntValType && !llvm::isPowerOf2_64(ExtIntValType->getNumBits())) {\n    Diag(FirstArg->getExprLoc(), diag::err_atomic_builtin_ext_int_size);\n    return ExprError();\n  }\n\n  return TheCallResult;\n}\n\n/// SemaBuiltinNontemporalOverloaded - We have a call to\n/// __builtin_nontemporal_store or __builtin_nontemporal_load, which is an\n/// overloaded function based on the pointer type of its last argument.\n///\n/// This function goes through and does final semantic checking for these\n/// builtins.\nExprResult Sema::SemaBuiltinNontemporalOverloaded(ExprResult TheCallResult) {\n  CallExpr *TheCall = (CallExpr *)TheCallResult.get();\n  DeclRefExpr *DRE =\n      cast<DeclRefExpr>(TheCall->getCallee()->IgnoreParenCasts());\n  FunctionDecl *FDecl = cast<FunctionDecl>(DRE->getDecl());\n  unsigned BuiltinID = FDecl->getBuiltinID();\n  assert((BuiltinID == Builtin::BI__builtin_nontemporal_store ||\n          BuiltinID == Builtin::BI__builtin_nontemporal_load) &&\n         \"Unexpected nontemporal load/store builtin!\");\n  bool isStore = BuiltinID == Builtin::BI__builtin_nontemporal_store;\n  unsigned numArgs = isStore ? 2 : 1;\n\n  // Ensure that we have the proper number of arguments.\n  if (checkArgCount(*this, TheCall, numArgs))\n    return ExprError();\n\n  // Inspect the last argument of the nontemporal builtin.  This should always\n  // be a pointer type, from which we imply the type of the memory access.\n  // Because it is a pointer type, we don't have to worry about any implicit\n  // casts here.\n  Expr *PointerArg = TheCall->getArg(numArgs - 1);\n  ExprResult PointerArgResult =\n      DefaultFunctionArrayLvalueConversion(PointerArg);\n\n  if (PointerArgResult.isInvalid())\n    return ExprError();\n  PointerArg = PointerArgResult.get();\n  TheCall->setArg(numArgs - 1, PointerArg);\n\n  const PointerType *pointerType = PointerArg->getType()->getAs<PointerType>();\n  if (!pointerType) {\n    Diag(DRE->getBeginLoc(), diag::err_nontemporal_builtin_must_be_pointer)\n        << PointerArg->getType() << PointerArg->getSourceRange();\n    return ExprError();\n  }\n\n  QualType ValType = pointerType->getPointeeType();\n\n  // Strip any qualifiers off ValType.\n  ValType = ValType.getUnqualifiedType();\n  if (!ValType->isIntegerType() && !ValType->isAnyPointerType() &&\n      !ValType->isBlockPointerType() && !ValType->isFloatingType() &&\n      !ValType->isVectorType()) {\n    Diag(DRE->getBeginLoc(),\n         diag::err_nontemporal_builtin_must_be_pointer_intfltptr_or_vector)\n        << PointerArg->getType() << PointerArg->getSourceRange();\n    return ExprError();\n  }\n\n  if (!isStore) {\n    TheCall->setType(ValType);\n    return TheCallResult;\n  }\n\n  ExprResult ValArg = TheCall->getArg(0);\n  InitializedEntity Entity = InitializedEntity::InitializeParameter(\n      Context, ValType, /*consume*/ false);\n  ValArg = PerformCopyInitialization(Entity, SourceLocation(), ValArg);\n  if (ValArg.isInvalid())\n    return ExprError();\n\n  TheCall->setArg(0, ValArg.get());\n  TheCall->setType(Context.VoidTy);\n  return TheCallResult;\n}\n\n/// CheckObjCString - Checks that the argument to the builtin\n/// CFString constructor is correct\n/// Note: It might also make sense to do the UTF-16 conversion here (would\n/// simplify the backend).\nbool Sema::CheckObjCString(Expr *Arg) {\n  Arg = Arg->IgnoreParenCasts();\n  StringLiteral *Literal = dyn_cast<StringLiteral>(Arg);\n\n  if (!Literal || !Literal->isAscii()) {\n    Diag(Arg->getBeginLoc(), diag::err_cfstring_literal_not_string_constant)\n        << Arg->getSourceRange();\n    return true;\n  }\n\n  if (Literal->containsNonAsciiOrNull()) {\n    StringRef String = Literal->getString();\n    unsigned NumBytes = String.size();\n    SmallVector<llvm::UTF16, 128> ToBuf(NumBytes);\n    const llvm::UTF8 *FromPtr = (const llvm::UTF8 *)String.data();\n    llvm::UTF16 *ToPtr = &ToBuf[0];\n\n    llvm::ConversionResult Result =\n        llvm::ConvertUTF8toUTF16(&FromPtr, FromPtr + NumBytes, &ToPtr,\n                                 ToPtr + NumBytes, llvm::strictConversion);\n    // Check for conversion failure.\n    if (Result != llvm::conversionOK)\n      Diag(Arg->getBeginLoc(), diag::warn_cfstring_truncated)\n          << Arg->getSourceRange();\n  }\n  return false;\n}\n\n/// CheckObjCString - Checks that the format string argument to the os_log()\n/// and os_trace() functions is correct, and converts it to const char *.\nExprResult Sema::CheckOSLogFormatStringArg(Expr *Arg) {\n  Arg = Arg->IgnoreParenCasts();\n  auto *Literal = dyn_cast<StringLiteral>(Arg);\n  if (!Literal) {\n    if (auto *ObjcLiteral = dyn_cast<ObjCStringLiteral>(Arg)) {\n      Literal = ObjcLiteral->getString();\n    }\n  }\n\n  if (!Literal || (!Literal->isAscii() && !Literal->isUTF8())) {\n    return ExprError(\n        Diag(Arg->getBeginLoc(), diag::err_os_log_format_not_string_constant)\n        << Arg->getSourceRange());\n  }\n\n  ExprResult Result(Literal);\n  QualType ResultTy = Context.getPointerType(Context.CharTy.withConst());\n  InitializedEntity Entity =\n      InitializedEntity::InitializeParameter(Context, ResultTy, false);\n  Result = PerformCopyInitialization(Entity, SourceLocation(), Result);\n  return Result;\n}\n\n/// Check that the user is calling the appropriate va_start builtin for the\n/// target and calling convention.\nstatic bool checkVAStartABI(Sema &S, unsigned BuiltinID, Expr *Fn) {\n  const llvm::Triple &TT = S.Context.getTargetInfo().getTriple();\n  bool IsX64 = TT.getArch() == llvm::Triple::x86_64;\n  bool IsAArch64 = (TT.getArch() == llvm::Triple::aarch64 ||\n                    TT.getArch() == llvm::Triple::aarch64_32);\n  bool IsWindows = TT.isOSWindows();\n  bool IsMSVAStart = BuiltinID == Builtin::BI__builtin_ms_va_start;\n  if (IsX64 || IsAArch64) {\n    CallingConv CC = CC_C;\n    if (const FunctionDecl *FD = S.getCurFunctionDecl())\n      CC = FD->getType()->castAs<FunctionType>()->getCallConv();\n    if (IsMSVAStart) {\n      // Don't allow this in System V ABI functions.\n      if (CC == CC_X86_64SysV || (!IsWindows && CC != CC_Win64))\n        return S.Diag(Fn->getBeginLoc(),\n                      diag::err_ms_va_start_used_in_sysv_function);\n    } else {\n      // On x86-64/AArch64 Unix, don't allow this in Win64 ABI functions.\n      // On x64 Windows, don't allow this in System V ABI functions.\n      // (Yes, that means there's no corresponding way to support variadic\n      // System V ABI functions on Windows.)\n      if ((IsWindows && CC == CC_X86_64SysV) ||\n          (!IsWindows && CC == CC_Win64))\n        return S.Diag(Fn->getBeginLoc(),\n                      diag::err_va_start_used_in_wrong_abi_function)\n               << !IsWindows;\n    }\n    return false;\n  }\n\n  if (IsMSVAStart)\n    return S.Diag(Fn->getBeginLoc(), diag::err_builtin_x64_aarch64_only);\n  return false;\n}\n\nstatic bool checkVAStartIsInVariadicFunction(Sema &S, Expr *Fn,\n                                             ParmVarDecl **LastParam = nullptr) {\n  // Determine whether the current function, block, or obj-c method is variadic\n  // and get its parameter list.\n  bool IsVariadic = false;\n  ArrayRef<ParmVarDecl *> Params;\n  DeclContext *Caller = S.CurContext;\n  if (auto *Block = dyn_cast<BlockDecl>(Caller)) {\n    IsVariadic = Block->isVariadic();\n    Params = Block->parameters();\n  } else if (auto *FD = dyn_cast<FunctionDecl>(Caller)) {\n    IsVariadic = FD->isVariadic();\n    Params = FD->parameters();\n  } else if (auto *MD = dyn_cast<ObjCMethodDecl>(Caller)) {\n    IsVariadic = MD->isVariadic();\n    // FIXME: This isn't correct for methods (results in bogus warning).\n    Params = MD->parameters();\n  } else if (isa<CapturedDecl>(Caller)) {\n    // We don't support va_start in a CapturedDecl.\n    S.Diag(Fn->getBeginLoc(), diag::err_va_start_captured_stmt);\n    return true;\n  } else {\n    // This must be some other declcontext that parses exprs.\n    S.Diag(Fn->getBeginLoc(), diag::err_va_start_outside_function);\n    return true;\n  }\n\n  if (!IsVariadic) {\n    S.Diag(Fn->getBeginLoc(), diag::err_va_start_fixed_function);\n    return true;\n  }\n\n  if (LastParam)\n    *LastParam = Params.empty() ? nullptr : Params.back();\n\n  return false;\n}\n\n/// Check the arguments to '__builtin_va_start' or '__builtin_ms_va_start'\n/// for validity.  Emit an error and return true on failure; return false\n/// on success.\nbool Sema::SemaBuiltinVAStart(unsigned BuiltinID, CallExpr *TheCall) {\n  Expr *Fn = TheCall->getCallee();\n\n  if (checkVAStartABI(*this, BuiltinID, Fn))\n    return true;\n\n  if (checkArgCount(*this, TheCall, 2))\n    return true;\n\n  // Type-check the first argument normally.\n  if (checkBuiltinArgument(*this, TheCall, 0))\n    return true;\n\n  // Check that the current function is variadic, and get its last parameter.\n  ParmVarDecl *LastParam;\n  if (checkVAStartIsInVariadicFunction(*this, Fn, &LastParam))\n    return true;\n\n  // Verify that the second argument to the builtin is the last argument of the\n  // current function or method.\n  bool SecondArgIsLastNamedArgument = false;\n  const Expr *Arg = TheCall->getArg(1)->IgnoreParenCasts();\n\n  // These are valid if SecondArgIsLastNamedArgument is false after the next\n  // block.\n  QualType Type;\n  SourceLocation ParamLoc;\n  bool IsCRegister = false;\n\n  if (const DeclRefExpr *DR = dyn_cast<DeclRefExpr>(Arg)) {\n    if (const ParmVarDecl *PV = dyn_cast<ParmVarDecl>(DR->getDecl())) {\n      SecondArgIsLastNamedArgument = PV == LastParam;\n\n      Type = PV->getType();\n      ParamLoc = PV->getLocation();\n      IsCRegister =\n          PV->getStorageClass() == SC_Register && !getLangOpts().CPlusPlus;\n    }\n  }\n\n  if (!SecondArgIsLastNamedArgument)\n    Diag(TheCall->getArg(1)->getBeginLoc(),\n         diag::warn_second_arg_of_va_start_not_last_named_param);\n  else if (IsCRegister || Type->isReferenceType() ||\n           Type->isSpecificBuiltinType(BuiltinType::Float) || [=] {\n             // Promotable integers are UB, but enumerations need a bit of\n             // extra checking to see what their promotable type actually is.\n             if (!Type->isPromotableIntegerType())\n               return false;\n             if (!Type->isEnumeralType())\n               return true;\n             const EnumDecl *ED = Type->castAs<EnumType>()->getDecl();\n             return !(ED &&\n                      Context.typesAreCompatible(ED->getPromotionType(), Type));\n           }()) {\n    unsigned Reason = 0;\n    if (Type->isReferenceType())  Reason = 1;\n    else if (IsCRegister)         Reason = 2;\n    Diag(Arg->getBeginLoc(), diag::warn_va_start_type_is_undefined) << Reason;\n    Diag(ParamLoc, diag::note_parameter_type) << Type;\n  }\n\n  TheCall->setType(Context.VoidTy);\n  return false;\n}\n\nbool Sema::SemaBuiltinVAStartARMMicrosoft(CallExpr *Call) {\n  // void __va_start(va_list *ap, const char *named_addr, size_t slot_size,\n  //                 const char *named_addr);\n\n  Expr *Func = Call->getCallee();\n\n  if (Call->getNumArgs() < 3)\n    return Diag(Call->getEndLoc(),\n                diag::err_typecheck_call_too_few_args_at_least)\n           << 0 /*function call*/ << 3 << Call->getNumArgs();\n\n  // Type-check the first argument normally.\n  if (checkBuiltinArgument(*this, Call, 0))\n    return true;\n\n  // Check that the current function is variadic.\n  if (checkVAStartIsInVariadicFunction(*this, Func))\n    return true;\n\n  // __va_start on Windows does not validate the parameter qualifiers\n\n  const Expr *Arg1 = Call->getArg(1)->IgnoreParens();\n  const Type *Arg1Ty = Arg1->getType().getCanonicalType().getTypePtr();\n\n  const Expr *Arg2 = Call->getArg(2)->IgnoreParens();\n  const Type *Arg2Ty = Arg2->getType().getCanonicalType().getTypePtr();\n\n  const QualType &ConstCharPtrTy =\n      Context.getPointerType(Context.CharTy.withConst());\n  if (!Arg1Ty->isPointerType() ||\n      Arg1Ty->getPointeeType().withoutLocalFastQualifiers() != Context.CharTy)\n    Diag(Arg1->getBeginLoc(), diag::err_typecheck_convert_incompatible)\n        << Arg1->getType() << ConstCharPtrTy << 1 /* different class */\n        << 0                                      /* qualifier difference */\n        << 3                                      /* parameter mismatch */\n        << 2 << Arg1->getType() << ConstCharPtrTy;\n\n  const QualType SizeTy = Context.getSizeType();\n  if (Arg2Ty->getCanonicalTypeInternal().withoutLocalFastQualifiers() != SizeTy)\n    Diag(Arg2->getBeginLoc(), diag::err_typecheck_convert_incompatible)\n        << Arg2->getType() << SizeTy << 1 /* different class */\n        << 0                              /* qualifier difference */\n        << 3                              /* parameter mismatch */\n        << 3 << Arg2->getType() << SizeTy;\n\n  return false;\n}\n\n/// SemaBuiltinUnorderedCompare - Handle functions like __builtin_isgreater and\n/// friends.  This is declared to take (...), so we have to check everything.\nbool Sema::SemaBuiltinUnorderedCompare(CallExpr *TheCall) {\n  if (checkArgCount(*this, TheCall, 2))\n    return true;\n\n  ExprResult OrigArg0 = TheCall->getArg(0);\n  ExprResult OrigArg1 = TheCall->getArg(1);\n\n  // Do standard promotions between the two arguments, returning their common\n  // type.\n  QualType Res = UsualArithmeticConversions(\n      OrigArg0, OrigArg1, TheCall->getExprLoc(), ACK_Comparison);\n  if (OrigArg0.isInvalid() || OrigArg1.isInvalid())\n    return true;\n\n  // Make sure any conversions are pushed back into the call; this is\n  // type safe since unordered compare builtins are declared as \"_Bool\n  // foo(...)\".\n  TheCall->setArg(0, OrigArg0.get());\n  TheCall->setArg(1, OrigArg1.get());\n\n  if (OrigArg0.get()->isTypeDependent() || OrigArg1.get()->isTypeDependent())\n    return false;\n\n  // If the common type isn't a real floating type, then the arguments were\n  // invalid for this operation.\n  if (Res.isNull() || !Res->isRealFloatingType())\n    return Diag(OrigArg0.get()->getBeginLoc(),\n                diag::err_typecheck_call_invalid_ordered_compare)\n           << OrigArg0.get()->getType() << OrigArg1.get()->getType()\n           << SourceRange(OrigArg0.get()->getBeginLoc(),\n                          OrigArg1.get()->getEndLoc());\n\n  return false;\n}\n\n/// SemaBuiltinSemaBuiltinFPClassification - Handle functions like\n/// __builtin_isnan and friends.  This is declared to take (...), so we have\n/// to check everything. We expect the last argument to be a floating point\n/// value.\nbool Sema::SemaBuiltinFPClassification(CallExpr *TheCall, unsigned NumArgs) {\n  if (checkArgCount(*this, TheCall, NumArgs))\n    return true;\n\n  // __builtin_fpclassify is the only case where NumArgs != 1, so we can count\n  // on all preceding parameters just being int.  Try all of those.\n  for (unsigned i = 0; i < NumArgs - 1; ++i) {\n    Expr *Arg = TheCall->getArg(i);\n\n    if (Arg->isTypeDependent())\n      return false;\n\n    ExprResult Res = PerformImplicitConversion(Arg, Context.IntTy, AA_Passing);\n\n    if (Res.isInvalid())\n      return true;\n    TheCall->setArg(i, Res.get());\n  }\n\n  Expr *OrigArg = TheCall->getArg(NumArgs-1);\n\n  if (OrigArg->isTypeDependent())\n    return false;\n\n  // Usual Unary Conversions will convert half to float, which we want for\n  // machines that use fp16 conversion intrinsics. Else, we wnat to leave the\n  // type how it is, but do normal L->Rvalue conversions.\n  if (Context.getTargetInfo().useFP16ConversionIntrinsics())\n    OrigArg = UsualUnaryConversions(OrigArg).get();\n  else\n    OrigArg = DefaultFunctionArrayLvalueConversion(OrigArg).get();\n  TheCall->setArg(NumArgs - 1, OrigArg);\n\n  // This operation requires a non-_Complex floating-point number.\n  if (!OrigArg->getType()->isRealFloatingType())\n    return Diag(OrigArg->getBeginLoc(),\n                diag::err_typecheck_call_invalid_unary_fp)\n           << OrigArg->getType() << OrigArg->getSourceRange();\n\n  return false;\n}\n\n/// Perform semantic analysis for a call to __builtin_complex.\nbool Sema::SemaBuiltinComplex(CallExpr *TheCall) {\n  if (checkArgCount(*this, TheCall, 2))\n    return true;\n\n  bool Dependent = false;\n  for (unsigned I = 0; I != 2; ++I) {\n    Expr *Arg = TheCall->getArg(I);\n    QualType T = Arg->getType();\n    if (T->isDependentType()) {\n      Dependent = true;\n      continue;\n    }\n\n    // Despite supporting _Complex int, GCC requires a real floating point type\n    // for the operands of __builtin_complex.\n    if (!T->isRealFloatingType()) {\n      return Diag(Arg->getBeginLoc(), diag::err_typecheck_call_requires_real_fp)\n             << Arg->getType() << Arg->getSourceRange();\n    }\n\n    ExprResult Converted = DefaultLvalueConversion(Arg);\n    if (Converted.isInvalid())\n      return true;\n    TheCall->setArg(I, Converted.get());\n  }\n\n  if (Dependent) {\n    TheCall->setType(Context.DependentTy);\n    return false;\n  }\n\n  Expr *Real = TheCall->getArg(0);\n  Expr *Imag = TheCall->getArg(1);\n  if (!Context.hasSameType(Real->getType(), Imag->getType())) {\n    return Diag(Real->getBeginLoc(),\n                diag::err_typecheck_call_different_arg_types)\n           << Real->getType() << Imag->getType()\n           << Real->getSourceRange() << Imag->getSourceRange();\n  }\n\n  // We don't allow _Complex _Float16 nor _Complex __fp16 as type specifiers;\n  // don't allow this builtin to form those types either.\n  // FIXME: Should we allow these types?\n  if (Real->getType()->isFloat16Type())\n    return Diag(TheCall->getBeginLoc(), diag::err_invalid_complex_spec)\n           << \"_Float16\";\n  if (Real->getType()->isHalfType())\n    return Diag(TheCall->getBeginLoc(), diag::err_invalid_complex_spec)\n           << \"half\";\n\n  TheCall->setType(Context.getComplexType(Real->getType()));\n  return false;\n}\n\n// Customized Sema Checking for VSX builtins that have the following signature:\n// vector [...] builtinName(vector [...], vector [...], const int);\n// Which takes the same type of vectors (any legal vector type) for the first\n// two arguments and takes compile time constant for the third argument.\n// Example builtins are :\n// vector double vec_xxpermdi(vector double, vector double, int);\n// vector short vec_xxsldwi(vector short, vector short, int);\nbool Sema::SemaBuiltinVSX(CallExpr *TheCall) {\n  unsigned ExpectedNumArgs = 3;\n  if (checkArgCount(*this, TheCall, ExpectedNumArgs))\n    return true;\n\n  // Check the third argument is a compile time constant\n  if (!TheCall->getArg(2)->isIntegerConstantExpr(Context))\n    return Diag(TheCall->getBeginLoc(),\n                diag::err_vsx_builtin_nonconstant_argument)\n           << 3 /* argument index */ << TheCall->getDirectCallee()\n           << SourceRange(TheCall->getArg(2)->getBeginLoc(),\n                          TheCall->getArg(2)->getEndLoc());\n\n  QualType Arg1Ty = TheCall->getArg(0)->getType();\n  QualType Arg2Ty = TheCall->getArg(1)->getType();\n\n  // Check the type of argument 1 and argument 2 are vectors.\n  SourceLocation BuiltinLoc = TheCall->getBeginLoc();\n  if ((!Arg1Ty->isVectorType() && !Arg1Ty->isDependentType()) ||\n      (!Arg2Ty->isVectorType() && !Arg2Ty->isDependentType())) {\n    return Diag(BuiltinLoc, diag::err_vec_builtin_non_vector)\n           << TheCall->getDirectCallee()\n           << SourceRange(TheCall->getArg(0)->getBeginLoc(),\n                          TheCall->getArg(1)->getEndLoc());\n  }\n\n  // Check the first two arguments are the same type.\n  if (!Context.hasSameUnqualifiedType(Arg1Ty, Arg2Ty)) {\n    return Diag(BuiltinLoc, diag::err_vec_builtin_incompatible_vector)\n           << TheCall->getDirectCallee()\n           << SourceRange(TheCall->getArg(0)->getBeginLoc(),\n                          TheCall->getArg(1)->getEndLoc());\n  }\n\n  // When default clang type checking is turned off and the customized type\n  // checking is used, the returning type of the function must be explicitly\n  // set. Otherwise it is _Bool by default.\n  TheCall->setType(Arg1Ty);\n\n  return false;\n}\n\n/// SemaBuiltinShuffleVector - Handle __builtin_shufflevector.\n// This is declared to take (...), so we have to check everything.\nExprResult Sema::SemaBuiltinShuffleVector(CallExpr *TheCall) {\n  if (TheCall->getNumArgs() < 2)\n    return ExprError(Diag(TheCall->getEndLoc(),\n                          diag::err_typecheck_call_too_few_args_at_least)\n                     << 0 /*function call*/ << 2 << TheCall->getNumArgs()\n                     << TheCall->getSourceRange());\n\n  // Determine which of the following types of shufflevector we're checking:\n  // 1) unary, vector mask: (lhs, mask)\n  // 2) binary, scalar mask: (lhs, rhs, index, ..., index)\n  QualType resType = TheCall->getArg(0)->getType();\n  unsigned numElements = 0;\n\n  if (!TheCall->getArg(0)->isTypeDependent() &&\n      !TheCall->getArg(1)->isTypeDependent()) {\n    QualType LHSType = TheCall->getArg(0)->getType();\n    QualType RHSType = TheCall->getArg(1)->getType();\n\n    if (!LHSType->isVectorType() || !RHSType->isVectorType())\n      return ExprError(\n          Diag(TheCall->getBeginLoc(), diag::err_vec_builtin_non_vector)\n          << TheCall->getDirectCallee()\n          << SourceRange(TheCall->getArg(0)->getBeginLoc(),\n                         TheCall->getArg(1)->getEndLoc()));\n\n    numElements = LHSType->castAs<VectorType>()->getNumElements();\n    unsigned numResElements = TheCall->getNumArgs() - 2;\n\n    // Check to see if we have a call with 2 vector arguments, the unary shuffle\n    // with mask.  If so, verify that RHS is an integer vector type with the\n    // same number of elts as lhs.\n    if (TheCall->getNumArgs() == 2) {\n      if (!RHSType->hasIntegerRepresentation() ||\n          RHSType->castAs<VectorType>()->getNumElements() != numElements)\n        return ExprError(Diag(TheCall->getBeginLoc(),\n                              diag::err_vec_builtin_incompatible_vector)\n                         << TheCall->getDirectCallee()\n                         << SourceRange(TheCall->getArg(1)->getBeginLoc(),\n                                        TheCall->getArg(1)->getEndLoc()));\n    } else if (!Context.hasSameUnqualifiedType(LHSType, RHSType)) {\n      return ExprError(Diag(TheCall->getBeginLoc(),\n                            diag::err_vec_builtin_incompatible_vector)\n                       << TheCall->getDirectCallee()\n                       << SourceRange(TheCall->getArg(0)->getBeginLoc(),\n                                      TheCall->getArg(1)->getEndLoc()));\n    } else if (numElements != numResElements) {\n      QualType eltType = LHSType->castAs<VectorType>()->getElementType();\n      resType = Context.getVectorType(eltType, numResElements,\n                                      VectorType::GenericVector);\n    }\n  }\n\n  for (unsigned i = 2; i < TheCall->getNumArgs(); i++) {\n    if (TheCall->getArg(i)->isTypeDependent() ||\n        TheCall->getArg(i)->isValueDependent())\n      continue;\n\n    Optional<llvm::APSInt> Result;\n    if (!(Result = TheCall->getArg(i)->getIntegerConstantExpr(Context)))\n      return ExprError(Diag(TheCall->getBeginLoc(),\n                            diag::err_shufflevector_nonconstant_argument)\n                       << TheCall->getArg(i)->getSourceRange());\n\n    // Allow -1 which will be translated to undef in the IR.\n    if (Result->isSigned() && Result->isAllOnesValue())\n      continue;\n\n    if (Result->getActiveBits() > 64 ||\n        Result->getZExtValue() >= numElements * 2)\n      return ExprError(Diag(TheCall->getBeginLoc(),\n                            diag::err_shufflevector_argument_too_large)\n                       << TheCall->getArg(i)->getSourceRange());\n  }\n\n  SmallVector<Expr*, 32> exprs;\n\n  for (unsigned i = 0, e = TheCall->getNumArgs(); i != e; i++) {\n    exprs.push_back(TheCall->getArg(i));\n    TheCall->setArg(i, nullptr);\n  }\n\n  return new (Context) ShuffleVectorExpr(Context, exprs, resType,\n                                         TheCall->getCallee()->getBeginLoc(),\n                                         TheCall->getRParenLoc());\n}\n\n/// SemaConvertVectorExpr - Handle __builtin_convertvector\nExprResult Sema::SemaConvertVectorExpr(Expr *E, TypeSourceInfo *TInfo,\n                                       SourceLocation BuiltinLoc,\n                                       SourceLocation RParenLoc) {\n  ExprValueKind VK = VK_RValue;\n  ExprObjectKind OK = OK_Ordinary;\n  QualType DstTy = TInfo->getType();\n  QualType SrcTy = E->getType();\n\n  if (!SrcTy->isVectorType() && !SrcTy->isDependentType())\n    return ExprError(Diag(BuiltinLoc,\n                          diag::err_convertvector_non_vector)\n                     << E->getSourceRange());\n  if (!DstTy->isVectorType() && !DstTy->isDependentType())\n    return ExprError(Diag(BuiltinLoc,\n                          diag::err_convertvector_non_vector_type));\n\n  if (!SrcTy->isDependentType() && !DstTy->isDependentType()) {\n    unsigned SrcElts = SrcTy->castAs<VectorType>()->getNumElements();\n    unsigned DstElts = DstTy->castAs<VectorType>()->getNumElements();\n    if (SrcElts != DstElts)\n      return ExprError(Diag(BuiltinLoc,\n                            diag::err_convertvector_incompatible_vector)\n                       << E->getSourceRange());\n  }\n\n  return new (Context)\n      ConvertVectorExpr(E, TInfo, DstTy, VK, OK, BuiltinLoc, RParenLoc);\n}\n\n/// SemaBuiltinPrefetch - Handle __builtin_prefetch.\n// This is declared to take (const void*, ...) and can take two\n// optional constant int args.\nbool Sema::SemaBuiltinPrefetch(CallExpr *TheCall) {\n  unsigned NumArgs = TheCall->getNumArgs();\n\n  if (NumArgs > 3)\n    return Diag(TheCall->getEndLoc(),\n                diag::err_typecheck_call_too_many_args_at_most)\n           << 0 /*function call*/ << 3 << NumArgs << TheCall->getSourceRange();\n\n  // Argument 0 is checked for us and the remaining arguments must be\n  // constant integers.\n  for (unsigned i = 1; i != NumArgs; ++i)\n    if (SemaBuiltinConstantArgRange(TheCall, i, 0, i == 1 ? 1 : 3))\n      return true;\n\n  return false;\n}\n\n/// SemaBuiltinAssume - Handle __assume (MS Extension).\n// __assume does not evaluate its arguments, and should warn if its argument\n// has side effects.\nbool Sema::SemaBuiltinAssume(CallExpr *TheCall) {\n  Expr *Arg = TheCall->getArg(0);\n  if (Arg->isInstantiationDependent()) return false;\n\n  if (Arg->HasSideEffects(Context))\n    Diag(Arg->getBeginLoc(), diag::warn_assume_side_effects)\n        << Arg->getSourceRange()\n        << cast<FunctionDecl>(TheCall->getCalleeDecl())->getIdentifier();\n\n  return false;\n}\n\n/// Handle __builtin_alloca_with_align. This is declared\n/// as (size_t, size_t) where the second size_t must be a power of 2 greater\n/// than 8.\nbool Sema::SemaBuiltinAllocaWithAlign(CallExpr *TheCall) {\n  // The alignment must be a constant integer.\n  Expr *Arg = TheCall->getArg(1);\n\n  // We can't check the value of a dependent argument.\n  if (!Arg->isTypeDependent() && !Arg->isValueDependent()) {\n    if (const auto *UE =\n            dyn_cast<UnaryExprOrTypeTraitExpr>(Arg->IgnoreParenImpCasts()))\n      if (UE->getKind() == UETT_AlignOf ||\n          UE->getKind() == UETT_PreferredAlignOf)\n        Diag(TheCall->getBeginLoc(), diag::warn_alloca_align_alignof)\n            << Arg->getSourceRange();\n\n    llvm::APSInt Result = Arg->EvaluateKnownConstInt(Context);\n\n    if (!Result.isPowerOf2())\n      return Diag(TheCall->getBeginLoc(), diag::err_alignment_not_power_of_two)\n             << Arg->getSourceRange();\n\n    if (Result < Context.getCharWidth())\n      return Diag(TheCall->getBeginLoc(), diag::err_alignment_too_small)\n             << (unsigned)Context.getCharWidth() << Arg->getSourceRange();\n\n    if (Result > std::numeric_limits<int32_t>::max())\n      return Diag(TheCall->getBeginLoc(), diag::err_alignment_too_big)\n             << std::numeric_limits<int32_t>::max() << Arg->getSourceRange();\n  }\n\n  return false;\n}\n\n/// Handle __builtin_assume_aligned. This is declared\n/// as (const void*, size_t, ...) and can take one optional constant int arg.\nbool Sema::SemaBuiltinAssumeAligned(CallExpr *TheCall) {\n  unsigned NumArgs = TheCall->getNumArgs();\n\n  if (NumArgs > 3)\n    return Diag(TheCall->getEndLoc(),\n                diag::err_typecheck_call_too_many_args_at_most)\n           << 0 /*function call*/ << 3 << NumArgs << TheCall->getSourceRange();\n\n  // The alignment must be a constant integer.\n  Expr *Arg = TheCall->getArg(1);\n\n  // We can't check the value of a dependent argument.\n  if (!Arg->isTypeDependent() && !Arg->isValueDependent()) {\n    llvm::APSInt Result;\n    if (SemaBuiltinConstantArg(TheCall, 1, Result))\n      return true;\n\n    if (!Result.isPowerOf2())\n      return Diag(TheCall->getBeginLoc(), diag::err_alignment_not_power_of_two)\n             << Arg->getSourceRange();\n\n    if (Result > Sema::MaximumAlignment)\n      Diag(TheCall->getBeginLoc(), diag::warn_assume_aligned_too_great)\n          << Arg->getSourceRange() << Sema::MaximumAlignment;\n  }\n\n  if (NumArgs > 2) {\n    ExprResult Arg(TheCall->getArg(2));\n    InitializedEntity Entity = InitializedEntity::InitializeParameter(Context,\n      Context.getSizeType(), false);\n    Arg = PerformCopyInitialization(Entity, SourceLocation(), Arg);\n    if (Arg.isInvalid()) return true;\n    TheCall->setArg(2, Arg.get());\n  }\n\n  return false;\n}\n\nbool Sema::SemaBuiltinOSLogFormat(CallExpr *TheCall) {\n  unsigned BuiltinID =\n      cast<FunctionDecl>(TheCall->getCalleeDecl())->getBuiltinID();\n  bool IsSizeCall = BuiltinID == Builtin::BI__builtin_os_log_format_buffer_size;\n\n  unsigned NumArgs = TheCall->getNumArgs();\n  unsigned NumRequiredArgs = IsSizeCall ? 1 : 2;\n  if (NumArgs < NumRequiredArgs) {\n    return Diag(TheCall->getEndLoc(), diag::err_typecheck_call_too_few_args)\n           << 0 /* function call */ << NumRequiredArgs << NumArgs\n           << TheCall->getSourceRange();\n  }\n  if (NumArgs >= NumRequiredArgs + 0x100) {\n    return Diag(TheCall->getEndLoc(),\n                diag::err_typecheck_call_too_many_args_at_most)\n           << 0 /* function call */ << (NumRequiredArgs + 0xff) << NumArgs\n           << TheCall->getSourceRange();\n  }\n  unsigned i = 0;\n\n  // For formatting call, check buffer arg.\n  if (!IsSizeCall) {\n    ExprResult Arg(TheCall->getArg(i));\n    InitializedEntity Entity = InitializedEntity::InitializeParameter(\n        Context, Context.VoidPtrTy, false);\n    Arg = PerformCopyInitialization(Entity, SourceLocation(), Arg);\n    if (Arg.isInvalid())\n      return true;\n    TheCall->setArg(i, Arg.get());\n    i++;\n  }\n\n  // Check string literal arg.\n  unsigned FormatIdx = i;\n  {\n    ExprResult Arg = CheckOSLogFormatStringArg(TheCall->getArg(i));\n    if (Arg.isInvalid())\n      return true;\n    TheCall->setArg(i, Arg.get());\n    i++;\n  }\n\n  // Make sure variadic args are scalar.\n  unsigned FirstDataArg = i;\n  while (i < NumArgs) {\n    ExprResult Arg = DefaultVariadicArgumentPromotion(\n        TheCall->getArg(i), VariadicFunction, nullptr);\n    if (Arg.isInvalid())\n      return true;\n    CharUnits ArgSize = Context.getTypeSizeInChars(Arg.get()->getType());\n    if (ArgSize.getQuantity() >= 0x100) {\n      return Diag(Arg.get()->getEndLoc(), diag::err_os_log_argument_too_big)\n             << i << (int)ArgSize.getQuantity() << 0xff\n             << TheCall->getSourceRange();\n    }\n    TheCall->setArg(i, Arg.get());\n    i++;\n  }\n\n  // Check formatting specifiers. NOTE: We're only doing this for the non-size\n  // call to avoid duplicate diagnostics.\n  if (!IsSizeCall) {\n    llvm::SmallBitVector CheckedVarArgs(NumArgs, false);\n    ArrayRef<const Expr *> Args(TheCall->getArgs(), TheCall->getNumArgs());\n    bool Success = CheckFormatArguments(\n        Args, /*HasVAListArg*/ false, FormatIdx, FirstDataArg, FST_OSLog,\n        VariadicFunction, TheCall->getBeginLoc(), SourceRange(),\n        CheckedVarArgs);\n    if (!Success)\n      return true;\n  }\n\n  if (IsSizeCall) {\n    TheCall->setType(Context.getSizeType());\n  } else {\n    TheCall->setType(Context.VoidPtrTy);\n  }\n  return false;\n}\n\n/// SemaBuiltinConstantArg - Handle a check if argument ArgNum of CallExpr\n/// TheCall is a constant expression.\nbool Sema::SemaBuiltinConstantArg(CallExpr *TheCall, int ArgNum,\n                                  llvm::APSInt &Result) {\n  Expr *Arg = TheCall->getArg(ArgNum);\n  DeclRefExpr *DRE =cast<DeclRefExpr>(TheCall->getCallee()->IgnoreParenCasts());\n  FunctionDecl *FDecl = cast<FunctionDecl>(DRE->getDecl());\n\n  if (Arg->isTypeDependent() || Arg->isValueDependent()) return false;\n\n  Optional<llvm::APSInt> R;\n  if (!(R = Arg->getIntegerConstantExpr(Context)))\n    return Diag(TheCall->getBeginLoc(), diag::err_constant_integer_arg_type)\n           << FDecl->getDeclName() << Arg->getSourceRange();\n  Result = *R;\n  return false;\n}\n\n/// SemaBuiltinConstantArgRange - Handle a check if argument ArgNum of CallExpr\n/// TheCall is a constant expression in the range [Low, High].\nbool Sema::SemaBuiltinConstantArgRange(CallExpr *TheCall, int ArgNum,\n                                       int Low, int High, bool RangeIsError) {\n  if (isConstantEvaluated())\n    return false;\n  llvm::APSInt Result;\n\n  // We can't check the value of a dependent argument.\n  Expr *Arg = TheCall->getArg(ArgNum);\n  if (Arg->isTypeDependent() || Arg->isValueDependent())\n    return false;\n\n  // Check constant-ness first.\n  if (SemaBuiltinConstantArg(TheCall, ArgNum, Result))\n    return true;\n\n  if (Result.getSExtValue() < Low || Result.getSExtValue() > High) {\n    if (RangeIsError)\n      return Diag(TheCall->getBeginLoc(), diag::err_argument_invalid_range)\n             << Result.toString(10) << Low << High << Arg->getSourceRange();\n    else\n      // Defer the warning until we know if the code will be emitted so that\n      // dead code can ignore this.\n      DiagRuntimeBehavior(TheCall->getBeginLoc(), TheCall,\n                          PDiag(diag::warn_argument_invalid_range)\n                              << Result.toString(10) << Low << High\n                              << Arg->getSourceRange());\n  }\n\n  return false;\n}\n\n/// SemaBuiltinConstantArgMultiple - Handle a check if argument ArgNum of CallExpr\n/// TheCall is a constant expression is a multiple of Num..\nbool Sema::SemaBuiltinConstantArgMultiple(CallExpr *TheCall, int ArgNum,\n                                          unsigned Num) {\n  llvm::APSInt Result;\n\n  // We can't check the value of a dependent argument.\n  Expr *Arg = TheCall->getArg(ArgNum);\n  if (Arg->isTypeDependent() || Arg->isValueDependent())\n    return false;\n\n  // Check constant-ness first.\n  if (SemaBuiltinConstantArg(TheCall, ArgNum, Result))\n    return true;\n\n  if (Result.getSExtValue() % Num != 0)\n    return Diag(TheCall->getBeginLoc(), diag::err_argument_not_multiple)\n           << Num << Arg->getSourceRange();\n\n  return false;\n}\n\n/// SemaBuiltinConstantArgPower2 - Check if argument ArgNum of TheCall is a\n/// constant expression representing a power of 2.\nbool Sema::SemaBuiltinConstantArgPower2(CallExpr *TheCall, int ArgNum) {\n  llvm::APSInt Result;\n\n  // We can't check the value of a dependent argument.\n  Expr *Arg = TheCall->getArg(ArgNum);\n  if (Arg->isTypeDependent() || Arg->isValueDependent())\n    return false;\n\n  // Check constant-ness first.\n  if (SemaBuiltinConstantArg(TheCall, ArgNum, Result))\n    return true;\n\n  // Bit-twiddling to test for a power of 2: for x > 0, x & (x-1) is zero if\n  // and only if x is a power of 2.\n  if (Result.isStrictlyPositive() && (Result & (Result - 1)) == 0)\n    return false;\n\n  return Diag(TheCall->getBeginLoc(), diag::err_argument_not_power_of_2)\n         << Arg->getSourceRange();\n}\n\nstatic bool IsShiftedByte(llvm::APSInt Value) {\n  if (Value.isNegative())\n    return false;\n\n  // Check if it's a shifted byte, by shifting it down\n  while (true) {\n    // If the value fits in the bottom byte, the check passes.\n    if (Value < 0x100)\n      return true;\n\n    // Otherwise, if the value has _any_ bits in the bottom byte, the check\n    // fails.\n    if ((Value & 0xFF) != 0)\n      return false;\n\n    // If the bottom 8 bits are all 0, but something above that is nonzero,\n    // then shifting the value right by 8 bits won't affect whether it's a\n    // shifted byte or not. So do that, and go round again.\n    Value >>= 8;\n  }\n}\n\n/// SemaBuiltinConstantArgShiftedByte - Check if argument ArgNum of TheCall is\n/// a constant expression representing an arbitrary byte value shifted left by\n/// a multiple of 8 bits.\nbool Sema::SemaBuiltinConstantArgShiftedByte(CallExpr *TheCall, int ArgNum,\n                                             unsigned ArgBits) {\n  llvm::APSInt Result;\n\n  // We can't check the value of a dependent argument.\n  Expr *Arg = TheCall->getArg(ArgNum);\n  if (Arg->isTypeDependent() || Arg->isValueDependent())\n    return false;\n\n  // Check constant-ness first.\n  if (SemaBuiltinConstantArg(TheCall, ArgNum, Result))\n    return true;\n\n  // Truncate to the given size.\n  Result = Result.getLoBits(ArgBits);\n  Result.setIsUnsigned(true);\n\n  if (IsShiftedByte(Result))\n    return false;\n\n  return Diag(TheCall->getBeginLoc(), diag::err_argument_not_shifted_byte)\n         << Arg->getSourceRange();\n}\n\n/// SemaBuiltinConstantArgShiftedByteOr0xFF - Check if argument ArgNum of\n/// TheCall is a constant expression representing either a shifted byte value,\n/// or a value of the form 0x??FF (i.e. a member of the arithmetic progression\n/// 0x00FF, 0x01FF, ..., 0xFFFF). This strange range check is needed for some\n/// Arm MVE intrinsics.\nbool Sema::SemaBuiltinConstantArgShiftedByteOrXXFF(CallExpr *TheCall,\n                                                   int ArgNum,\n                                                   unsigned ArgBits) {\n  llvm::APSInt Result;\n\n  // We can't check the value of a dependent argument.\n  Expr *Arg = TheCall->getArg(ArgNum);\n  if (Arg->isTypeDependent() || Arg->isValueDependent())\n    return false;\n\n  // Check constant-ness first.\n  if (SemaBuiltinConstantArg(TheCall, ArgNum, Result))\n    return true;\n\n  // Truncate to the given size.\n  Result = Result.getLoBits(ArgBits);\n  Result.setIsUnsigned(true);\n\n  // Check to see if it's in either of the required forms.\n  if (IsShiftedByte(Result) ||\n      (Result > 0 && Result < 0x10000 && (Result & 0xFF) == 0xFF))\n    return false;\n\n  return Diag(TheCall->getBeginLoc(),\n              diag::err_argument_not_shifted_byte_or_xxff)\n         << Arg->getSourceRange();\n}\n\n/// SemaBuiltinARMMemoryTaggingCall - Handle calls of memory tagging extensions\nbool Sema::SemaBuiltinARMMemoryTaggingCall(unsigned BuiltinID, CallExpr *TheCall) {\n  if (BuiltinID == AArch64::BI__builtin_arm_irg) {\n    if (checkArgCount(*this, TheCall, 2))\n      return true;\n    Expr *Arg0 = TheCall->getArg(0);\n    Expr *Arg1 = TheCall->getArg(1);\n\n    ExprResult FirstArg = DefaultFunctionArrayLvalueConversion(Arg0);\n    if (FirstArg.isInvalid())\n      return true;\n    QualType FirstArgType = FirstArg.get()->getType();\n    if (!FirstArgType->isAnyPointerType())\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_arg_must_be_pointer)\n               << \"first\" << FirstArgType << Arg0->getSourceRange();\n    TheCall->setArg(0, FirstArg.get());\n\n    ExprResult SecArg = DefaultLvalueConversion(Arg1);\n    if (SecArg.isInvalid())\n      return true;\n    QualType SecArgType = SecArg.get()->getType();\n    if (!SecArgType->isIntegerType())\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_arg_must_be_integer)\n               << \"second\" << SecArgType << Arg1->getSourceRange();\n\n    // Derive the return type from the pointer argument.\n    TheCall->setType(FirstArgType);\n    return false;\n  }\n\n  if (BuiltinID == AArch64::BI__builtin_arm_addg) {\n    if (checkArgCount(*this, TheCall, 2))\n      return true;\n\n    Expr *Arg0 = TheCall->getArg(0);\n    ExprResult FirstArg = DefaultFunctionArrayLvalueConversion(Arg0);\n    if (FirstArg.isInvalid())\n      return true;\n    QualType FirstArgType = FirstArg.get()->getType();\n    if (!FirstArgType->isAnyPointerType())\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_arg_must_be_pointer)\n               << \"first\" << FirstArgType << Arg0->getSourceRange();\n    TheCall->setArg(0, FirstArg.get());\n\n    // Derive the return type from the pointer argument.\n    TheCall->setType(FirstArgType);\n\n    // Second arg must be an constant in range [0,15]\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 15);\n  }\n\n  if (BuiltinID == AArch64::BI__builtin_arm_gmi) {\n    if (checkArgCount(*this, TheCall, 2))\n      return true;\n    Expr *Arg0 = TheCall->getArg(0);\n    Expr *Arg1 = TheCall->getArg(1);\n\n    ExprResult FirstArg = DefaultFunctionArrayLvalueConversion(Arg0);\n    if (FirstArg.isInvalid())\n      return true;\n    QualType FirstArgType = FirstArg.get()->getType();\n    if (!FirstArgType->isAnyPointerType())\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_arg_must_be_pointer)\n               << \"first\" << FirstArgType << Arg0->getSourceRange();\n\n    QualType SecArgType = Arg1->getType();\n    if (!SecArgType->isIntegerType())\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_arg_must_be_integer)\n               << \"second\" << SecArgType << Arg1->getSourceRange();\n    TheCall->setType(Context.IntTy);\n    return false;\n  }\n\n  if (BuiltinID == AArch64::BI__builtin_arm_ldg ||\n      BuiltinID == AArch64::BI__builtin_arm_stg) {\n    if (checkArgCount(*this, TheCall, 1))\n      return true;\n    Expr *Arg0 = TheCall->getArg(0);\n    ExprResult FirstArg = DefaultFunctionArrayLvalueConversion(Arg0);\n    if (FirstArg.isInvalid())\n      return true;\n\n    QualType FirstArgType = FirstArg.get()->getType();\n    if (!FirstArgType->isAnyPointerType())\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_arg_must_be_pointer)\n               << \"first\" << FirstArgType << Arg0->getSourceRange();\n    TheCall->setArg(0, FirstArg.get());\n\n    // Derive the return type from the pointer argument.\n    if (BuiltinID == AArch64::BI__builtin_arm_ldg)\n      TheCall->setType(FirstArgType);\n    return false;\n  }\n\n  if (BuiltinID == AArch64::BI__builtin_arm_subp) {\n    Expr *ArgA = TheCall->getArg(0);\n    Expr *ArgB = TheCall->getArg(1);\n\n    ExprResult ArgExprA = DefaultFunctionArrayLvalueConversion(ArgA);\n    ExprResult ArgExprB = DefaultFunctionArrayLvalueConversion(ArgB);\n\n    if (ArgExprA.isInvalid() || ArgExprB.isInvalid())\n      return true;\n\n    QualType ArgTypeA = ArgExprA.get()->getType();\n    QualType ArgTypeB = ArgExprB.get()->getType();\n\n    auto isNull = [&] (Expr *E) -> bool {\n      return E->isNullPointerConstant(\n                        Context, Expr::NPC_ValueDependentIsNotNull); };\n\n    // argument should be either a pointer or null\n    if (!ArgTypeA->isAnyPointerType() && !isNull(ArgA))\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_arg_null_or_pointer)\n        << \"first\" << ArgTypeA << ArgA->getSourceRange();\n\n    if (!ArgTypeB->isAnyPointerType() && !isNull(ArgB))\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_arg_null_or_pointer)\n        << \"second\" << ArgTypeB << ArgB->getSourceRange();\n\n    // Ensure Pointee types are compatible\n    if (ArgTypeA->isAnyPointerType() && !isNull(ArgA) &&\n        ArgTypeB->isAnyPointerType() && !isNull(ArgB)) {\n      QualType pointeeA = ArgTypeA->getPointeeType();\n      QualType pointeeB = ArgTypeB->getPointeeType();\n      if (!Context.typesAreCompatible(\n             Context.getCanonicalType(pointeeA).getUnqualifiedType(),\n             Context.getCanonicalType(pointeeB).getUnqualifiedType())) {\n        return Diag(TheCall->getBeginLoc(), diag::err_typecheck_sub_ptr_compatible)\n          << ArgTypeA <<  ArgTypeB << ArgA->getSourceRange()\n          << ArgB->getSourceRange();\n      }\n    }\n\n    // at least one argument should be pointer type\n    if (!ArgTypeA->isAnyPointerType() && !ArgTypeB->isAnyPointerType())\n      return Diag(TheCall->getBeginLoc(), diag::err_memtag_any2arg_pointer)\n        <<  ArgTypeA << ArgTypeB << ArgA->getSourceRange();\n\n    if (isNull(ArgA)) // adopt type of the other pointer\n      ArgExprA = ImpCastExprToType(ArgExprA.get(), ArgTypeB, CK_NullToPointer);\n\n    if (isNull(ArgB))\n      ArgExprB = ImpCastExprToType(ArgExprB.get(), ArgTypeA, CK_NullToPointer);\n\n    TheCall->setArg(0, ArgExprA.get());\n    TheCall->setArg(1, ArgExprB.get());\n    TheCall->setType(Context.LongLongTy);\n    return false;\n  }\n  assert(false && \"Unhandled ARM MTE intrinsic\");\n  return true;\n}\n\n/// SemaBuiltinARMSpecialReg - Handle a check if argument ArgNum of CallExpr\n/// TheCall is an ARM/AArch64 special register string literal.\nbool Sema::SemaBuiltinARMSpecialReg(unsigned BuiltinID, CallExpr *TheCall,\n                                    int ArgNum, unsigned ExpectedFieldNum,\n                                    bool AllowName) {\n  bool IsARMBuiltin = BuiltinID == ARM::BI__builtin_arm_rsr64 ||\n                      BuiltinID == ARM::BI__builtin_arm_wsr64 ||\n                      BuiltinID == ARM::BI__builtin_arm_rsr ||\n                      BuiltinID == ARM::BI__builtin_arm_rsrp ||\n                      BuiltinID == ARM::BI__builtin_arm_wsr ||\n                      BuiltinID == ARM::BI__builtin_arm_wsrp;\n  bool IsAArch64Builtin = BuiltinID == AArch64::BI__builtin_arm_rsr64 ||\n                          BuiltinID == AArch64::BI__builtin_arm_wsr64 ||\n                          BuiltinID == AArch64::BI__builtin_arm_rsr ||\n                          BuiltinID == AArch64::BI__builtin_arm_rsrp ||\n                          BuiltinID == AArch64::BI__builtin_arm_wsr ||\n                          BuiltinID == AArch64::BI__builtin_arm_wsrp;\n  assert((IsARMBuiltin || IsAArch64Builtin) && \"Unexpected ARM builtin.\");\n\n  // We can't check the value of a dependent argument.\n  Expr *Arg = TheCall->getArg(ArgNum);\n  if (Arg->isTypeDependent() || Arg->isValueDependent())\n    return false;\n\n  // Check if the argument is a string literal.\n  if (!isa<StringLiteral>(Arg->IgnoreParenImpCasts()))\n    return Diag(TheCall->getBeginLoc(), diag::err_expr_not_string_literal)\n           << Arg->getSourceRange();\n\n  // Check the type of special register given.\n  StringRef Reg = cast<StringLiteral>(Arg->IgnoreParenImpCasts())->getString();\n  SmallVector<StringRef, 6> Fields;\n  Reg.split(Fields, \":\");\n\n  if (Fields.size() != ExpectedFieldNum && !(AllowName && Fields.size() == 1))\n    return Diag(TheCall->getBeginLoc(), diag::err_arm_invalid_specialreg)\n           << Arg->getSourceRange();\n\n  // If the string is the name of a register then we cannot check that it is\n  // valid here but if the string is of one the forms described in ACLE then we\n  // can check that the supplied fields are integers and within the valid\n  // ranges.\n  if (Fields.size() > 1) {\n    bool FiveFields = Fields.size() == 5;\n\n    bool ValidString = true;\n    if (IsARMBuiltin) {\n      ValidString &= Fields[0].startswith_lower(\"cp\") ||\n                     Fields[0].startswith_lower(\"p\");\n      if (ValidString)\n        Fields[0] =\n          Fields[0].drop_front(Fields[0].startswith_lower(\"cp\") ? 2 : 1);\n\n      ValidString &= Fields[2].startswith_lower(\"c\");\n      if (ValidString)\n        Fields[2] = Fields[2].drop_front(1);\n\n      if (FiveFields) {\n        ValidString &= Fields[3].startswith_lower(\"c\");\n        if (ValidString)\n          Fields[3] = Fields[3].drop_front(1);\n      }\n    }\n\n    SmallVector<int, 5> Ranges;\n    if (FiveFields)\n      Ranges.append({IsAArch64Builtin ? 1 : 15, 7, 15, 15, 7});\n    else\n      Ranges.append({15, 7, 15});\n\n    for (unsigned i=0; i<Fields.size(); ++i) {\n      int IntField;\n      ValidString &= !Fields[i].getAsInteger(10, IntField);\n      ValidString &= (IntField >= 0 && IntField <= Ranges[i]);\n    }\n\n    if (!ValidString)\n      return Diag(TheCall->getBeginLoc(), diag::err_arm_invalid_specialreg)\n             << Arg->getSourceRange();\n  } else if (IsAArch64Builtin && Fields.size() == 1) {\n    // If the register name is one of those that appear in the condition below\n    // and the special register builtin being used is one of the write builtins,\n    // then we require that the argument provided for writing to the register\n    // is an integer constant expression. This is because it will be lowered to\n    // an MSR (immediate) instruction, so we need to know the immediate at\n    // compile time.\n    if (TheCall->getNumArgs() != 2)\n      return false;\n\n    std::string RegLower = Reg.lower();\n    if (RegLower != \"spsel\" && RegLower != \"daifset\" && RegLower != \"daifclr\" &&\n        RegLower != \"pan\" && RegLower != \"uao\")\n      return false;\n\n    return SemaBuiltinConstantArgRange(TheCall, 1, 0, 15);\n  }\n\n  return false;\n}\n\n/// SemaBuiltinPPCMMACall - Check the call to a PPC MMA builtin for validity.\n/// Emit an error and return true on failure; return false on success.\n/// TypeStr is a string containing the type descriptor of the value returned by\n/// the builtin and the descriptors of the expected type of the arguments.\nbool Sema::SemaBuiltinPPCMMACall(CallExpr *TheCall, const char *TypeStr) {\n\n  assert((TypeStr[0] != '\\0') &&\n         \"Invalid types in PPC MMA builtin declaration\");\n\n  unsigned Mask = 0;\n  unsigned ArgNum = 0;\n\n  // The first type in TypeStr is the type of the value returned by the\n  // builtin. So we first read that type and change the type of TheCall.\n  QualType type = DecodePPCMMATypeFromStr(Context, TypeStr, Mask);\n  TheCall->setType(type);\n\n  while (*TypeStr != '\\0') {\n    Mask = 0;\n    QualType ExpectedType = DecodePPCMMATypeFromStr(Context, TypeStr, Mask);\n    if (ArgNum >= TheCall->getNumArgs()) {\n      ArgNum++;\n      break;\n    }\n\n    Expr *Arg = TheCall->getArg(ArgNum);\n    QualType ArgType = Arg->getType();\n\n    if ((ExpectedType->isVoidPointerType() && !ArgType->isPointerType()) ||\n        (!ExpectedType->isVoidPointerType() &&\n           ArgType.getCanonicalType() != ExpectedType))\n      return Diag(Arg->getBeginLoc(), diag::err_typecheck_convert_incompatible)\n             << ArgType << ExpectedType << 1 << 0 << 0;\n\n    // If the value of the Mask is not 0, we have a constraint in the size of\n    // the integer argument so here we ensure the argument is a constant that\n    // is in the valid range.\n    if (Mask != 0 &&\n        SemaBuiltinConstantArgRange(TheCall, ArgNum, 0, Mask, true))\n      return true;\n\n    ArgNum++;\n  }\n\n  // In case we exited early from the previous loop, there are other types to\n  // read from TypeStr. So we need to read them all to ensure we have the right\n  // number of arguments in TheCall and if it is not the case, to display a\n  // better error message.\n  while (*TypeStr != '\\0') {\n    (void) DecodePPCMMATypeFromStr(Context, TypeStr, Mask);\n    ArgNum++;\n  }\n  if (checkArgCount(*this, TheCall, ArgNum))\n    return true;\n\n  return false;\n}\n\n/// SemaBuiltinLongjmp - Handle __builtin_longjmp(void *env[5], int val).\n/// This checks that the target supports __builtin_longjmp and\n/// that val is a constant 1.\nbool Sema::SemaBuiltinLongjmp(CallExpr *TheCall) {\n  if (!Context.getTargetInfo().hasSjLjLowering())\n    return Diag(TheCall->getBeginLoc(), diag::err_builtin_longjmp_unsupported)\n           << SourceRange(TheCall->getBeginLoc(), TheCall->getEndLoc());\n\n  Expr *Arg = TheCall->getArg(1);\n  llvm::APSInt Result;\n\n  // TODO: This is less than ideal. Overload this to take a value.\n  if (SemaBuiltinConstantArg(TheCall, 1, Result))\n    return true;\n\n  if (Result != 1)\n    return Diag(TheCall->getBeginLoc(), diag::err_builtin_longjmp_invalid_val)\n           << SourceRange(Arg->getBeginLoc(), Arg->getEndLoc());\n\n  return false;\n}\n\n/// SemaBuiltinSetjmp - Handle __builtin_setjmp(void *env[5]).\n/// This checks that the target supports __builtin_setjmp.\nbool Sema::SemaBuiltinSetjmp(CallExpr *TheCall) {\n  if (!Context.getTargetInfo().hasSjLjLowering())\n    return Diag(TheCall->getBeginLoc(), diag::err_builtin_setjmp_unsupported)\n           << SourceRange(TheCall->getBeginLoc(), TheCall->getEndLoc());\n  return false;\n}\n\nnamespace {\n\nclass UncoveredArgHandler {\n  enum { Unknown = -1, AllCovered = -2 };\n\n  signed FirstUncoveredArg = Unknown;\n  SmallVector<const Expr *, 4> DiagnosticExprs;\n\npublic:\n  UncoveredArgHandler() = default;\n\n  bool hasUncoveredArg() const {\n    return (FirstUncoveredArg >= 0);\n  }\n\n  unsigned getUncoveredArg() const {\n    assert(hasUncoveredArg() && \"no uncovered argument\");\n    return FirstUncoveredArg;\n  }\n\n  void setAllCovered() {\n    // A string has been found with all arguments covered, so clear out\n    // the diagnostics.\n    DiagnosticExprs.clear();\n    FirstUncoveredArg = AllCovered;\n  }\n\n  void Update(signed NewFirstUncoveredArg, const Expr *StrExpr) {\n    assert(NewFirstUncoveredArg >= 0 && \"Outside range\");\n\n    // Don't update if a previous string covers all arguments.\n    if (FirstUncoveredArg == AllCovered)\n      return;\n\n    // UncoveredArgHandler tracks the highest uncovered argument index\n    // and with it all the strings that match this index.\n    if (NewFirstUncoveredArg == FirstUncoveredArg)\n      DiagnosticExprs.push_back(StrExpr);\n    else if (NewFirstUncoveredArg > FirstUncoveredArg) {\n      DiagnosticExprs.clear();\n      DiagnosticExprs.push_back(StrExpr);\n      FirstUncoveredArg = NewFirstUncoveredArg;\n    }\n  }\n\n  void Diagnose(Sema &S, bool IsFunctionCall, const Expr *ArgExpr);\n};\n\nenum StringLiteralCheckType {\n  SLCT_NotALiteral,\n  SLCT_UncheckedLiteral,\n  SLCT_CheckedLiteral\n};\n\n} // namespace\n\nstatic void sumOffsets(llvm::APSInt &Offset, llvm::APSInt Addend,\n                                     BinaryOperatorKind BinOpKind,\n                                     bool AddendIsRight) {\n  unsigned BitWidth = Offset.getBitWidth();\n  unsigned AddendBitWidth = Addend.getBitWidth();\n  // There might be negative interim results.\n  if (Addend.isUnsigned()) {\n    Addend = Addend.zext(++AddendBitWidth);\n    Addend.setIsSigned(true);\n  }\n  // Adjust the bit width of the APSInts.\n  if (AddendBitWidth > BitWidth) {\n    Offset = Offset.sext(AddendBitWidth);\n    BitWidth = AddendBitWidth;\n  } else if (BitWidth > AddendBitWidth) {\n    Addend = Addend.sext(BitWidth);\n  }\n\n  bool Ov = false;\n  llvm::APSInt ResOffset = Offset;\n  if (BinOpKind == BO_Add)\n    ResOffset = Offset.sadd_ov(Addend, Ov);\n  else {\n    assert(AddendIsRight && BinOpKind == BO_Sub &&\n           \"operator must be add or sub with addend on the right\");\n    ResOffset = Offset.ssub_ov(Addend, Ov);\n  }\n\n  // We add an offset to a pointer here so we should support an offset as big as\n  // possible.\n  if (Ov) {\n    assert(BitWidth <= std::numeric_limits<unsigned>::max() / 2 &&\n           \"index (intermediate) result too big\");\n    Offset = Offset.sext(2 * BitWidth);\n    sumOffsets(Offset, Addend, BinOpKind, AddendIsRight);\n    return;\n  }\n\n  Offset = ResOffset;\n}\n\nnamespace {\n\n// This is a wrapper class around StringLiteral to support offsetted string\n// literals as format strings. It takes the offset into account when returning\n// the string and its length or the source locations to display notes correctly.\nclass FormatStringLiteral {\n  const StringLiteral *FExpr;\n  int64_t Offset;\n\n public:\n  FormatStringLiteral(const StringLiteral *fexpr, int64_t Offset = 0)\n      : FExpr(fexpr), Offset(Offset) {}\n\n  StringRef getString() const {\n    return FExpr->getString().drop_front(Offset);\n  }\n\n  unsigned getByteLength() const {\n    return FExpr->getByteLength() - getCharByteWidth() * Offset;\n  }\n\n  unsigned getLength() const { return FExpr->getLength() - Offset; }\n  unsigned getCharByteWidth() const { return FExpr->getCharByteWidth(); }\n\n  StringLiteral::StringKind getKind() const { return FExpr->getKind(); }\n\n  QualType getType() const { return FExpr->getType(); }\n\n  bool isAscii() const { return FExpr->isAscii(); }\n  bool isWide() const { return FExpr->isWide(); }\n  bool isUTF8() const { return FExpr->isUTF8(); }\n  bool isUTF16() const { return FExpr->isUTF16(); }\n  bool isUTF32() const { return FExpr->isUTF32(); }\n  bool isPascal() const { return FExpr->isPascal(); }\n\n  SourceLocation getLocationOfByte(\n      unsigned ByteNo, const SourceManager &SM, const LangOptions &Features,\n      const TargetInfo &Target, unsigned *StartToken = nullptr,\n      unsigned *StartTokenByteOffset = nullptr) const {\n    return FExpr->getLocationOfByte(ByteNo + Offset, SM, Features, Target,\n                                    StartToken, StartTokenByteOffset);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return FExpr->getBeginLoc().getLocWithOffset(Offset);\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return FExpr->getEndLoc(); }\n};\n\n}  // namespace\n\nstatic void CheckFormatString(Sema &S, const FormatStringLiteral *FExpr,\n                              const Expr *OrigFormatExpr,\n                              ArrayRef<const Expr *> Args,\n                              bool HasVAListArg, unsigned format_idx,\n                              unsigned firstDataArg,\n                              Sema::FormatStringType Type,\n                              bool inFunctionCall,\n                              Sema::VariadicCallType CallType,\n                              llvm::SmallBitVector &CheckedVarArgs,\n                              UncoveredArgHandler &UncoveredArg,\n                              bool IgnoreStringsWithoutSpecifiers);\n\n// Determine if an expression is a string literal or constant string.\n// If this function returns false on the arguments to a function expecting a\n// format string, we will usually need to emit a warning.\n// True string literals are then checked by CheckFormatString.\nstatic StringLiteralCheckType\ncheckFormatStringExpr(Sema &S, const Expr *E, ArrayRef<const Expr *> Args,\n                      bool HasVAListArg, unsigned format_idx,\n                      unsigned firstDataArg, Sema::FormatStringType Type,\n                      Sema::VariadicCallType CallType, bool InFunctionCall,\n                      llvm::SmallBitVector &CheckedVarArgs,\n                      UncoveredArgHandler &UncoveredArg,\n                      llvm::APSInt Offset,\n                      bool IgnoreStringsWithoutSpecifiers = false) {\n  if (S.isConstantEvaluated())\n    return SLCT_NotALiteral;\n tryAgain:\n  assert(Offset.isSigned() && \"invalid offset\");\n\n  if (E->isTypeDependent() || E->isValueDependent())\n    return SLCT_NotALiteral;\n\n  E = E->IgnoreParenCasts();\n\n  if (E->isNullPointerConstant(S.Context, Expr::NPC_ValueDependentIsNotNull))\n    // Technically -Wformat-nonliteral does not warn about this case.\n    // The behavior of printf and friends in this case is implementation\n    // dependent.  Ideally if the format string cannot be null then\n    // it should have a 'nonnull' attribute in the function prototype.\n    return SLCT_UncheckedLiteral;\n\n  switch (E->getStmtClass()) {\n  case Stmt::BinaryConditionalOperatorClass:\n  case Stmt::ConditionalOperatorClass: {\n    // The expression is a literal if both sub-expressions were, and it was\n    // completely checked only if both sub-expressions were checked.\n    const AbstractConditionalOperator *C =\n        cast<AbstractConditionalOperator>(E);\n\n    // Determine whether it is necessary to check both sub-expressions, for\n    // example, because the condition expression is a constant that can be\n    // evaluated at compile time.\n    bool CheckLeft = true, CheckRight = true;\n\n    bool Cond;\n    if (C->getCond()->EvaluateAsBooleanCondition(Cond, S.getASTContext(),\n                                                 S.isConstantEvaluated())) {\n      if (Cond)\n        CheckRight = false;\n      else\n        CheckLeft = false;\n    }\n\n    // We need to maintain the offsets for the right and the left hand side\n    // separately to check if every possible indexed expression is a valid\n    // string literal. They might have different offsets for different string\n    // literals in the end.\n    StringLiteralCheckType Left;\n    if (!CheckLeft)\n      Left = SLCT_UncheckedLiteral;\n    else {\n      Left = checkFormatStringExpr(S, C->getTrueExpr(), Args,\n                                   HasVAListArg, format_idx, firstDataArg,\n                                   Type, CallType, InFunctionCall,\n                                   CheckedVarArgs, UncoveredArg, Offset,\n                                   IgnoreStringsWithoutSpecifiers);\n      if (Left == SLCT_NotALiteral || !CheckRight) {\n        return Left;\n      }\n    }\n\n    StringLiteralCheckType Right = checkFormatStringExpr(\n        S, C->getFalseExpr(), Args, HasVAListArg, format_idx, firstDataArg,\n        Type, CallType, InFunctionCall, CheckedVarArgs, UncoveredArg, Offset,\n        IgnoreStringsWithoutSpecifiers);\n\n    return (CheckLeft && Left < Right) ? Left : Right;\n  }\n\n  case Stmt::ImplicitCastExprClass:\n    E = cast<ImplicitCastExpr>(E)->getSubExpr();\n    goto tryAgain;\n\n  case Stmt::OpaqueValueExprClass:\n    if (const Expr *src = cast<OpaqueValueExpr>(E)->getSourceExpr()) {\n      E = src;\n      goto tryAgain;\n    }\n    return SLCT_NotALiteral;\n\n  case Stmt::PredefinedExprClass:\n    // While __func__, etc., are technically not string literals, they\n    // cannot contain format specifiers and thus are not a security\n    // liability.\n    return SLCT_UncheckedLiteral;\n\n  case Stmt::DeclRefExprClass: {\n    const DeclRefExpr *DR = cast<DeclRefExpr>(E);\n\n    // As an exception, do not flag errors for variables binding to\n    // const string literals.\n    if (const VarDecl *VD = dyn_cast<VarDecl>(DR->getDecl())) {\n      bool isConstant = false;\n      QualType T = DR->getType();\n\n      if (const ArrayType *AT = S.Context.getAsArrayType(T)) {\n        isConstant = AT->getElementType().isConstant(S.Context);\n      } else if (const PointerType *PT = T->getAs<PointerType>()) {\n        isConstant = T.isConstant(S.Context) &&\n                     PT->getPointeeType().isConstant(S.Context);\n      } else if (T->isObjCObjectPointerType()) {\n        // In ObjC, there is usually no \"const ObjectPointer\" type,\n        // so don't check if the pointee type is constant.\n        isConstant = T.isConstant(S.Context);\n      }\n\n      if (isConstant) {\n        if (const Expr *Init = VD->getAnyInitializer()) {\n          // Look through initializers like const char c[] = { \"foo\" }\n          if (const InitListExpr *InitList = dyn_cast<InitListExpr>(Init)) {\n            if (InitList->isStringLiteralInit())\n              Init = InitList->getInit(0)->IgnoreParenImpCasts();\n          }\n          return checkFormatStringExpr(S, Init, Args,\n                                       HasVAListArg, format_idx,\n                                       firstDataArg, Type, CallType,\n                                       /*InFunctionCall*/ false, CheckedVarArgs,\n                                       UncoveredArg, Offset);\n        }\n      }\n\n      // For vprintf* functions (i.e., HasVAListArg==true), we add a\n      // special check to see if the format string is a function parameter\n      // of the function calling the printf function.  If the function\n      // has an attribute indicating it is a printf-like function, then we\n      // should suppress warnings concerning non-literals being used in a call\n      // to a vprintf function.  For example:\n      //\n      // void\n      // logmessage(char const *fmt __attribute__ (format (printf, 1, 2)), ...){\n      //      va_list ap;\n      //      va_start(ap, fmt);\n      //      vprintf(fmt, ap);  // Do NOT emit a warning about \"fmt\".\n      //      ...\n      // }\n      if (HasVAListArg) {\n        if (const ParmVarDecl *PV = dyn_cast<ParmVarDecl>(VD)) {\n          if (const NamedDecl *ND = dyn_cast<NamedDecl>(PV->getDeclContext())) {\n            int PVIndex = PV->getFunctionScopeIndex() + 1;\n            for (const auto *PVFormat : ND->specific_attrs<FormatAttr>()) {\n              // adjust for implicit parameter\n              if (const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(ND))\n                if (MD->isInstance())\n                  ++PVIndex;\n              // We also check if the formats are compatible.\n              // We can't pass a 'scanf' string to a 'printf' function.\n              if (PVIndex == PVFormat->getFormatIdx() &&\n                  Type == S.GetFormatStringType(PVFormat))\n                return SLCT_UncheckedLiteral;\n            }\n          }\n        }\n      }\n    }\n\n    return SLCT_NotALiteral;\n  }\n\n  case Stmt::CallExprClass:\n  case Stmt::CXXMemberCallExprClass: {\n    const CallExpr *CE = cast<CallExpr>(E);\n    if (const NamedDecl *ND = dyn_cast_or_null<NamedDecl>(CE->getCalleeDecl())) {\n      bool IsFirst = true;\n      StringLiteralCheckType CommonResult;\n      for (const auto *FA : ND->specific_attrs<FormatArgAttr>()) {\n        const Expr *Arg = CE->getArg(FA->getFormatIdx().getASTIndex());\n        StringLiteralCheckType Result = checkFormatStringExpr(\n            S, Arg, Args, HasVAListArg, format_idx, firstDataArg, Type,\n            CallType, InFunctionCall, CheckedVarArgs, UncoveredArg, Offset,\n            IgnoreStringsWithoutSpecifiers);\n        if (IsFirst) {\n          CommonResult = Result;\n          IsFirst = false;\n        }\n      }\n      if (!IsFirst)\n        return CommonResult;\n\n      if (const auto *FD = dyn_cast<FunctionDecl>(ND)) {\n        unsigned BuiltinID = FD->getBuiltinID();\n        if (BuiltinID == Builtin::BI__builtin___CFStringMakeConstantString ||\n            BuiltinID == Builtin::BI__builtin___NSStringMakeConstantString) {\n          const Expr *Arg = CE->getArg(0);\n          return checkFormatStringExpr(S, Arg, Args,\n                                       HasVAListArg, format_idx,\n                                       firstDataArg, Type, CallType,\n                                       InFunctionCall, CheckedVarArgs,\n                                       UncoveredArg, Offset,\n                                       IgnoreStringsWithoutSpecifiers);\n        }\n      }\n    }\n\n    return SLCT_NotALiteral;\n  }\n  case Stmt::ObjCMessageExprClass: {\n    const auto *ME = cast<ObjCMessageExpr>(E);\n    if (const auto *MD = ME->getMethodDecl()) {\n      if (const auto *FA = MD->getAttr<FormatArgAttr>()) {\n        // As a special case heuristic, if we're using the method -[NSBundle\n        // localizedStringForKey:value:table:], ignore any key strings that lack\n        // format specifiers. The idea is that if the key doesn't have any\n        // format specifiers then its probably just a key to map to the\n        // localized strings. If it does have format specifiers though, then its\n        // likely that the text of the key is the format string in the\n        // programmer's language, and should be checked.\n        const ObjCInterfaceDecl *IFace;\n        if (MD->isInstanceMethod() && (IFace = MD->getClassInterface()) &&\n            IFace->getIdentifier()->isStr(\"NSBundle\") &&\n            MD->getSelector().isKeywordSelector(\n                {\"localizedStringForKey\", \"value\", \"table\"})) {\n          IgnoreStringsWithoutSpecifiers = true;\n        }\n\n        const Expr *Arg = ME->getArg(FA->getFormatIdx().getASTIndex());\n        return checkFormatStringExpr(\n            S, Arg, Args, HasVAListArg, format_idx, firstDataArg, Type,\n            CallType, InFunctionCall, CheckedVarArgs, UncoveredArg, Offset,\n            IgnoreStringsWithoutSpecifiers);\n      }\n    }\n\n    return SLCT_NotALiteral;\n  }\n  case Stmt::ObjCStringLiteralClass:\n  case Stmt::StringLiteralClass: {\n    const StringLiteral *StrE = nullptr;\n\n    if (const ObjCStringLiteral *ObjCFExpr = dyn_cast<ObjCStringLiteral>(E))\n      StrE = ObjCFExpr->getString();\n    else\n      StrE = cast<StringLiteral>(E);\n\n    if (StrE) {\n      if (Offset.isNegative() || Offset > StrE->getLength()) {\n        // TODO: It would be better to have an explicit warning for out of\n        // bounds literals.\n        return SLCT_NotALiteral;\n      }\n      FormatStringLiteral FStr(StrE, Offset.sextOrTrunc(64).getSExtValue());\n      CheckFormatString(S, &FStr, E, Args, HasVAListArg, format_idx,\n                        firstDataArg, Type, InFunctionCall, CallType,\n                        CheckedVarArgs, UncoveredArg,\n                        IgnoreStringsWithoutSpecifiers);\n      return SLCT_CheckedLiteral;\n    }\n\n    return SLCT_NotALiteral;\n  }\n  case Stmt::BinaryOperatorClass: {\n    const BinaryOperator *BinOp = cast<BinaryOperator>(E);\n\n    // A string literal + an int offset is still a string literal.\n    if (BinOp->isAdditiveOp()) {\n      Expr::EvalResult LResult, RResult;\n\n      bool LIsInt = BinOp->getLHS()->EvaluateAsInt(\n          LResult, S.Context, Expr::SE_NoSideEffects, S.isConstantEvaluated());\n      bool RIsInt = BinOp->getRHS()->EvaluateAsInt(\n          RResult, S.Context, Expr::SE_NoSideEffects, S.isConstantEvaluated());\n\n      if (LIsInt != RIsInt) {\n        BinaryOperatorKind BinOpKind = BinOp->getOpcode();\n\n        if (LIsInt) {\n          if (BinOpKind == BO_Add) {\n            sumOffsets(Offset, LResult.Val.getInt(), BinOpKind, RIsInt);\n            E = BinOp->getRHS();\n            goto tryAgain;\n          }\n        } else {\n          sumOffsets(Offset, RResult.Val.getInt(), BinOpKind, RIsInt);\n          E = BinOp->getLHS();\n          goto tryAgain;\n        }\n      }\n    }\n\n    return SLCT_NotALiteral;\n  }\n  case Stmt::UnaryOperatorClass: {\n    const UnaryOperator *UnaOp = cast<UnaryOperator>(E);\n    auto ASE = dyn_cast<ArraySubscriptExpr>(UnaOp->getSubExpr());\n    if (UnaOp->getOpcode() == UO_AddrOf && ASE) {\n      Expr::EvalResult IndexResult;\n      if (ASE->getRHS()->EvaluateAsInt(IndexResult, S.Context,\n                                       Expr::SE_NoSideEffects,\n                                       S.isConstantEvaluated())) {\n        sumOffsets(Offset, IndexResult.Val.getInt(), BO_Add,\n                   /*RHS is int*/ true);\n        E = ASE->getBase();\n        goto tryAgain;\n      }\n    }\n\n    return SLCT_NotALiteral;\n  }\n\n  default:\n    return SLCT_NotALiteral;\n  }\n}\n\nSema::FormatStringType Sema::GetFormatStringType(const FormatAttr *Format) {\n  return llvm::StringSwitch<FormatStringType>(Format->getType()->getName())\n      .Case(\"scanf\", FST_Scanf)\n      .Cases(\"printf\", \"printf0\", FST_Printf)\n      .Cases(\"NSString\", \"CFString\", FST_NSString)\n      .Case(\"strftime\", FST_Strftime)\n      .Case(\"strfmon\", FST_Strfmon)\n      .Cases(\"kprintf\", \"cmn_err\", \"vcmn_err\", \"zcmn_err\", FST_Kprintf)\n      .Case(\"freebsd_kprintf\", FST_FreeBSDKPrintf)\n      .Case(\"os_trace\", FST_OSLog)\n      .Case(\"os_log\", FST_OSLog)\n      .Default(FST_Unknown);\n}\n\n/// CheckFormatArguments - Check calls to printf and scanf (and similar\n/// functions) for correct use of format strings.\n/// Returns true if a format string has been fully checked.\nbool Sema::CheckFormatArguments(const FormatAttr *Format,\n                                ArrayRef<const Expr *> Args,\n                                bool IsCXXMember,\n                                VariadicCallType CallType,\n                                SourceLocation Loc, SourceRange Range,\n                                llvm::SmallBitVector &CheckedVarArgs) {\n  FormatStringInfo FSI;\n  if (getFormatStringInfo(Format, IsCXXMember, &FSI))\n    return CheckFormatArguments(Args, FSI.HasVAListArg, FSI.FormatIdx,\n                                FSI.FirstDataArg, GetFormatStringType(Format),\n                                CallType, Loc, Range, CheckedVarArgs);\n  return false;\n}\n\nbool Sema::CheckFormatArguments(ArrayRef<const Expr *> Args,\n                                bool HasVAListArg, unsigned format_idx,\n                                unsigned firstDataArg, FormatStringType Type,\n                                VariadicCallType CallType,\n                                SourceLocation Loc, SourceRange Range,\n                                llvm::SmallBitVector &CheckedVarArgs) {\n  // CHECK: printf/scanf-like function is called with no format string.\n  if (format_idx >= Args.size()) {\n    Diag(Loc, diag::warn_missing_format_string) << Range;\n    return false;\n  }\n\n  const Expr *OrigFormatExpr = Args[format_idx]->IgnoreParenCasts();\n\n  // CHECK: format string is not a string literal.\n  //\n  // Dynamically generated format strings are difficult to\n  // automatically vet at compile time.  Requiring that format strings\n  // are string literals: (1) permits the checking of format strings by\n  // the compiler and thereby (2) can practically remove the source of\n  // many format string exploits.\n\n  // Format string can be either ObjC string (e.g. @\"%d\") or\n  // C string (e.g. \"%d\")\n  // ObjC string uses the same format specifiers as C string, so we can use\n  // the same format string checking logic for both ObjC and C strings.\n  UncoveredArgHandler UncoveredArg;\n  StringLiteralCheckType CT =\n      checkFormatStringExpr(*this, OrigFormatExpr, Args, HasVAListArg,\n                            format_idx, firstDataArg, Type, CallType,\n                            /*IsFunctionCall*/ true, CheckedVarArgs,\n                            UncoveredArg,\n                            /*no string offset*/ llvm::APSInt(64, false) = 0);\n\n  // Generate a diagnostic where an uncovered argument is detected.\n  if (UncoveredArg.hasUncoveredArg()) {\n    unsigned ArgIdx = UncoveredArg.getUncoveredArg() + firstDataArg;\n    assert(ArgIdx < Args.size() && \"ArgIdx outside bounds\");\n    UncoveredArg.Diagnose(*this, /*IsFunctionCall*/true, Args[ArgIdx]);\n  }\n\n  if (CT != SLCT_NotALiteral)\n    // Literal format string found, check done!\n    return CT == SLCT_CheckedLiteral;\n\n  // Strftime is particular as it always uses a single 'time' argument,\n  // so it is safe to pass a non-literal string.\n  if (Type == FST_Strftime)\n    return false;\n\n  // Do not emit diag when the string param is a macro expansion and the\n  // format is either NSString or CFString. This is a hack to prevent\n  // diag when using the NSLocalizedString and CFCopyLocalizedString macros\n  // which are usually used in place of NS and CF string literals.\n  SourceLocation FormatLoc = Args[format_idx]->getBeginLoc();\n  if (Type == FST_NSString && SourceMgr.isInSystemMacro(FormatLoc))\n    return false;\n\n  // If there are no arguments specified, warn with -Wformat-security, otherwise\n  // warn only with -Wformat-nonliteral.\n  if (Args.size() == firstDataArg) {\n    Diag(FormatLoc, diag::warn_format_nonliteral_noargs)\n      << OrigFormatExpr->getSourceRange();\n    switch (Type) {\n    default:\n      break;\n    case FST_Kprintf:\n    case FST_FreeBSDKPrintf:\n    case FST_Printf:\n      Diag(FormatLoc, diag::note_format_security_fixit)\n        << FixItHint::CreateInsertion(FormatLoc, \"\\\"%s\\\", \");\n      break;\n    case FST_NSString:\n      Diag(FormatLoc, diag::note_format_security_fixit)\n        << FixItHint::CreateInsertion(FormatLoc, \"@\\\"%@\\\", \");\n      break;\n    }\n  } else {\n    Diag(FormatLoc, diag::warn_format_nonliteral)\n      << OrigFormatExpr->getSourceRange();\n  }\n  return false;\n}\n\nnamespace {\n\nclass CheckFormatHandler : public analyze_format_string::FormatStringHandler {\nprotected:\n  Sema &S;\n  const FormatStringLiteral *FExpr;\n  const Expr *OrigFormatExpr;\n  const Sema::FormatStringType FSType;\n  const unsigned FirstDataArg;\n  const unsigned NumDataArgs;\n  const char *Beg; // Start of format string.\n  const bool HasVAListArg;\n  ArrayRef<const Expr *> Args;\n  unsigned FormatIdx;\n  llvm::SmallBitVector CoveredArgs;\n  bool usesPositionalArgs = false;\n  bool atFirstArg = true;\n  bool inFunctionCall;\n  Sema::VariadicCallType CallType;\n  llvm::SmallBitVector &CheckedVarArgs;\n  UncoveredArgHandler &UncoveredArg;\n\npublic:\n  CheckFormatHandler(Sema &s, const FormatStringLiteral *fexpr,\n                     const Expr *origFormatExpr,\n                     const Sema::FormatStringType type, unsigned firstDataArg,\n                     unsigned numDataArgs, const char *beg, bool hasVAListArg,\n                     ArrayRef<const Expr *> Args, unsigned formatIdx,\n                     bool inFunctionCall, Sema::VariadicCallType callType,\n                     llvm::SmallBitVector &CheckedVarArgs,\n                     UncoveredArgHandler &UncoveredArg)\n      : S(s), FExpr(fexpr), OrigFormatExpr(origFormatExpr), FSType(type),\n        FirstDataArg(firstDataArg), NumDataArgs(numDataArgs), Beg(beg),\n        HasVAListArg(hasVAListArg), Args(Args), FormatIdx(formatIdx),\n        inFunctionCall(inFunctionCall), CallType(callType),\n        CheckedVarArgs(CheckedVarArgs), UncoveredArg(UncoveredArg) {\n    CoveredArgs.resize(numDataArgs);\n    CoveredArgs.reset();\n  }\n\n  void DoneProcessing();\n\n  void HandleIncompleteSpecifier(const char *startSpecifier,\n                                 unsigned specifierLen) override;\n\n  void HandleInvalidLengthModifier(\n                           const analyze_format_string::FormatSpecifier &FS,\n                           const analyze_format_string::ConversionSpecifier &CS,\n                           const char *startSpecifier, unsigned specifierLen,\n                           unsigned DiagID);\n\n  void HandleNonStandardLengthModifier(\n                    const analyze_format_string::FormatSpecifier &FS,\n                    const char *startSpecifier, unsigned specifierLen);\n\n  void HandleNonStandardConversionSpecifier(\n                    const analyze_format_string::ConversionSpecifier &CS,\n                    const char *startSpecifier, unsigned specifierLen);\n\n  void HandlePosition(const char *startPos, unsigned posLen) override;\n\n  void HandleInvalidPosition(const char *startSpecifier,\n                             unsigned specifierLen,\n                             analyze_format_string::PositionContext p) override;\n\n  void HandleZeroPosition(const char *startPos, unsigned posLen) override;\n\n  void HandleNullChar(const char *nullCharacter) override;\n\n  template <typename Range>\n  static void\n  EmitFormatDiagnostic(Sema &S, bool inFunctionCall, const Expr *ArgumentExpr,\n                       const PartialDiagnostic &PDiag, SourceLocation StringLoc,\n                       bool IsStringLocation, Range StringRange,\n                       ArrayRef<FixItHint> Fixit = None);\n\nprotected:\n  bool HandleInvalidConversionSpecifier(unsigned argIndex, SourceLocation Loc,\n                                        const char *startSpec,\n                                        unsigned specifierLen,\n                                        const char *csStart, unsigned csLen);\n\n  void HandlePositionalNonpositionalArgs(SourceLocation Loc,\n                                         const char *startSpec,\n                                         unsigned specifierLen);\n\n  SourceRange getFormatStringRange();\n  CharSourceRange getSpecifierRange(const char *startSpecifier,\n                                    unsigned specifierLen);\n  SourceLocation getLocationOfByte(const char *x);\n\n  const Expr *getDataArg(unsigned i) const;\n\n  bool CheckNumArgs(const analyze_format_string::FormatSpecifier &FS,\n                    const analyze_format_string::ConversionSpecifier &CS,\n                    const char *startSpecifier, unsigned specifierLen,\n                    unsigned argIndex);\n\n  template <typename Range>\n  void EmitFormatDiagnostic(PartialDiagnostic PDiag, SourceLocation StringLoc,\n                            bool IsStringLocation, Range StringRange,\n                            ArrayRef<FixItHint> Fixit = None);\n};\n\n} // namespace\n\nSourceRange CheckFormatHandler::getFormatStringRange() {\n  return OrigFormatExpr->getSourceRange();\n}\n\nCharSourceRange CheckFormatHandler::\ngetSpecifierRange(const char *startSpecifier, unsigned specifierLen) {\n  SourceLocation Start = getLocationOfByte(startSpecifier);\n  SourceLocation End   = getLocationOfByte(startSpecifier + specifierLen - 1);\n\n  // Advance the end SourceLocation by one due to half-open ranges.\n  End = End.getLocWithOffset(1);\n\n  return CharSourceRange::getCharRange(Start, End);\n}\n\nSourceLocation CheckFormatHandler::getLocationOfByte(const char *x) {\n  return FExpr->getLocationOfByte(x - Beg, S.getSourceManager(),\n                                  S.getLangOpts(), S.Context.getTargetInfo());\n}\n\nvoid CheckFormatHandler::HandleIncompleteSpecifier(const char *startSpecifier,\n                                                   unsigned specifierLen){\n  EmitFormatDiagnostic(S.PDiag(diag::warn_printf_incomplete_specifier),\n                       getLocationOfByte(startSpecifier),\n                       /*IsStringLocation*/true,\n                       getSpecifierRange(startSpecifier, specifierLen));\n}\n\nvoid CheckFormatHandler::HandleInvalidLengthModifier(\n    const analyze_format_string::FormatSpecifier &FS,\n    const analyze_format_string::ConversionSpecifier &CS,\n    const char *startSpecifier, unsigned specifierLen, unsigned DiagID) {\n  using namespace analyze_format_string;\n\n  const LengthModifier &LM = FS.getLengthModifier();\n  CharSourceRange LMRange = getSpecifierRange(LM.getStart(), LM.getLength());\n\n  // See if we know how to fix this length modifier.\n  Optional<LengthModifier> FixedLM = FS.getCorrectedLengthModifier();\n  if (FixedLM) {\n    EmitFormatDiagnostic(S.PDiag(DiagID) << LM.toString() << CS.toString(),\n                         getLocationOfByte(LM.getStart()),\n                         /*IsStringLocation*/true,\n                         getSpecifierRange(startSpecifier, specifierLen));\n\n    S.Diag(getLocationOfByte(LM.getStart()), diag::note_format_fix_specifier)\n      << FixedLM->toString()\n      << FixItHint::CreateReplacement(LMRange, FixedLM->toString());\n\n  } else {\n    FixItHint Hint;\n    if (DiagID == diag::warn_format_nonsensical_length)\n      Hint = FixItHint::CreateRemoval(LMRange);\n\n    EmitFormatDiagnostic(S.PDiag(DiagID) << LM.toString() << CS.toString(),\n                         getLocationOfByte(LM.getStart()),\n                         /*IsStringLocation*/true,\n                         getSpecifierRange(startSpecifier, specifierLen),\n                         Hint);\n  }\n}\n\nvoid CheckFormatHandler::HandleNonStandardLengthModifier(\n    const analyze_format_string::FormatSpecifier &FS,\n    const char *startSpecifier, unsigned specifierLen) {\n  using namespace analyze_format_string;\n\n  const LengthModifier &LM = FS.getLengthModifier();\n  CharSourceRange LMRange = getSpecifierRange(LM.getStart(), LM.getLength());\n\n  // See if we know how to fix this length modifier.\n  Optional<LengthModifier> FixedLM = FS.getCorrectedLengthModifier();\n  if (FixedLM) {\n    EmitFormatDiagnostic(S.PDiag(diag::warn_format_non_standard)\n                           << LM.toString() << 0,\n                         getLocationOfByte(LM.getStart()),\n                         /*IsStringLocation*/true,\n                         getSpecifierRange(startSpecifier, specifierLen));\n\n    S.Diag(getLocationOfByte(LM.getStart()), diag::note_format_fix_specifier)\n      << FixedLM->toString()\n      << FixItHint::CreateReplacement(LMRange, FixedLM->toString());\n\n  } else {\n    EmitFormatDiagnostic(S.PDiag(diag::warn_format_non_standard)\n                           << LM.toString() << 0,\n                         getLocationOfByte(LM.getStart()),\n                         /*IsStringLocation*/true,\n                         getSpecifierRange(startSpecifier, specifierLen));\n  }\n}\n\nvoid CheckFormatHandler::HandleNonStandardConversionSpecifier(\n    const analyze_format_string::ConversionSpecifier &CS,\n    const char *startSpecifier, unsigned specifierLen) {\n  using namespace analyze_format_string;\n\n  // See if we know how to fix this conversion specifier.\n  Optional<ConversionSpecifier> FixedCS = CS.getStandardSpecifier();\n  if (FixedCS) {\n    EmitFormatDiagnostic(S.PDiag(diag::warn_format_non_standard)\n                          << CS.toString() << /*conversion specifier*/1,\n                         getLocationOfByte(CS.getStart()),\n                         /*IsStringLocation*/true,\n                         getSpecifierRange(startSpecifier, specifierLen));\n\n    CharSourceRange CSRange = getSpecifierRange(CS.getStart(), CS.getLength());\n    S.Diag(getLocationOfByte(CS.getStart()), diag::note_format_fix_specifier)\n      << FixedCS->toString()\n      << FixItHint::CreateReplacement(CSRange, FixedCS->toString());\n  } else {\n    EmitFormatDiagnostic(S.PDiag(diag::warn_format_non_standard)\n                          << CS.toString() << /*conversion specifier*/1,\n                         getLocationOfByte(CS.getStart()),\n                         /*IsStringLocation*/true,\n                         getSpecifierRange(startSpecifier, specifierLen));\n  }\n}\n\nvoid CheckFormatHandler::HandlePosition(const char *startPos,\n                                        unsigned posLen) {\n  EmitFormatDiagnostic(S.PDiag(diag::warn_format_non_standard_positional_arg),\n                               getLocationOfByte(startPos),\n                               /*IsStringLocation*/true,\n                               getSpecifierRange(startPos, posLen));\n}\n\nvoid\nCheckFormatHandler::HandleInvalidPosition(const char *startPos, unsigned posLen,\n                                     analyze_format_string::PositionContext p) {\n  EmitFormatDiagnostic(S.PDiag(diag::warn_format_invalid_positional_specifier)\n                         << (unsigned) p,\n                       getLocationOfByte(startPos), /*IsStringLocation*/true,\n                       getSpecifierRange(startPos, posLen));\n}\n\nvoid CheckFormatHandler::HandleZeroPosition(const char *startPos,\n                                            unsigned posLen) {\n  EmitFormatDiagnostic(S.PDiag(diag::warn_format_zero_positional_specifier),\n                               getLocationOfByte(startPos),\n                               /*IsStringLocation*/true,\n                               getSpecifierRange(startPos, posLen));\n}\n\nvoid CheckFormatHandler::HandleNullChar(const char *nullCharacter) {\n  if (!isa<ObjCStringLiteral>(OrigFormatExpr)) {\n    // The presence of a null character is likely an error.\n    EmitFormatDiagnostic(\n      S.PDiag(diag::warn_printf_format_string_contains_null_char),\n      getLocationOfByte(nullCharacter), /*IsStringLocation*/true,\n      getFormatStringRange());\n  }\n}\n\n// Note that this may return NULL if there was an error parsing or building\n// one of the argument expressions.\nconst Expr *CheckFormatHandler::getDataArg(unsigned i) const {\n  return Args[FirstDataArg + i];\n}\n\nvoid CheckFormatHandler::DoneProcessing() {\n  // Does the number of data arguments exceed the number of\n  // format conversions in the format string?\n  if (!HasVAListArg) {\n      // Find any arguments that weren't covered.\n    CoveredArgs.flip();\n    signed notCoveredArg = CoveredArgs.find_first();\n    if (notCoveredArg >= 0) {\n      assert((unsigned)notCoveredArg < NumDataArgs);\n      UncoveredArg.Update(notCoveredArg, OrigFormatExpr);\n    } else {\n      UncoveredArg.setAllCovered();\n    }\n  }\n}\n\nvoid UncoveredArgHandler::Diagnose(Sema &S, bool IsFunctionCall,\n                                   const Expr *ArgExpr) {\n  assert(hasUncoveredArg() && DiagnosticExprs.size() > 0 &&\n         \"Invalid state\");\n\n  if (!ArgExpr)\n    return;\n\n  SourceLocation Loc = ArgExpr->getBeginLoc();\n\n  if (S.getSourceManager().isInSystemMacro(Loc))\n    return;\n\n  PartialDiagnostic PDiag = S.PDiag(diag::warn_printf_data_arg_not_used);\n  for (auto E : DiagnosticExprs)\n    PDiag << E->getSourceRange();\n\n  CheckFormatHandler::EmitFormatDiagnostic(\n                                  S, IsFunctionCall, DiagnosticExprs[0],\n                                  PDiag, Loc, /*IsStringLocation*/false,\n                                  DiagnosticExprs[0]->getSourceRange());\n}\n\nbool\nCheckFormatHandler::HandleInvalidConversionSpecifier(unsigned argIndex,\n                                                     SourceLocation Loc,\n                                                     const char *startSpec,\n                                                     unsigned specifierLen,\n                                                     const char *csStart,\n                                                     unsigned csLen) {\n  bool keepGoing = true;\n  if (argIndex < NumDataArgs) {\n    // Consider the argument coverered, even though the specifier doesn't\n    // make sense.\n    CoveredArgs.set(argIndex);\n  }\n  else {\n    // If argIndex exceeds the number of data arguments we\n    // don't issue a warning because that is just a cascade of warnings (and\n    // they may have intended '%%' anyway). We don't want to continue processing\n    // the format string after this point, however, as we will like just get\n    // gibberish when trying to match arguments.\n    keepGoing = false;\n  }\n\n  StringRef Specifier(csStart, csLen);\n\n  // If the specifier in non-printable, it could be the first byte of a UTF-8\n  // sequence. In that case, print the UTF-8 code point. If not, print the byte\n  // hex value.\n  std::string CodePointStr;\n  if (!llvm::sys::locale::isPrint(*csStart)) {\n    llvm::UTF32 CodePoint;\n    const llvm::UTF8 **B = reinterpret_cast<const llvm::UTF8 **>(&csStart);\n    const llvm::UTF8 *E =\n        reinterpret_cast<const llvm::UTF8 *>(csStart + csLen);\n    llvm::ConversionResult Result =\n        llvm::convertUTF8Sequence(B, E, &CodePoint, llvm::strictConversion);\n\n    if (Result != llvm::conversionOK) {\n      unsigned char FirstChar = *csStart;\n      CodePoint = (llvm::UTF32)FirstChar;\n    }\n\n    llvm::raw_string_ostream OS(CodePointStr);\n    if (CodePoint < 256)\n      OS << \"\\\\x\" << llvm::format(\"%02x\", CodePoint);\n    else if (CodePoint <= 0xFFFF)\n      OS << \"\\\\u\" << llvm::format(\"%04x\", CodePoint);\n    else\n      OS << \"\\\\U\" << llvm::format(\"%08x\", CodePoint);\n    OS.flush();\n    Specifier = CodePointStr;\n  }\n\n  EmitFormatDiagnostic(\n      S.PDiag(diag::warn_format_invalid_conversion) << Specifier, Loc,\n      /*IsStringLocation*/ true, getSpecifierRange(startSpec, specifierLen));\n\n  return keepGoing;\n}\n\nvoid\nCheckFormatHandler::HandlePositionalNonpositionalArgs(SourceLocation Loc,\n                                                      const char *startSpec,\n                                                      unsigned specifierLen) {\n  EmitFormatDiagnostic(\n    S.PDiag(diag::warn_format_mix_positional_nonpositional_args),\n    Loc, /*isStringLoc*/true, getSpecifierRange(startSpec, specifierLen));\n}\n\nbool\nCheckFormatHandler::CheckNumArgs(\n  const analyze_format_string::FormatSpecifier &FS,\n  const analyze_format_string::ConversionSpecifier &CS,\n  const char *startSpecifier, unsigned specifierLen, unsigned argIndex) {\n\n  if (argIndex >= NumDataArgs) {\n    PartialDiagnostic PDiag = FS.usesPositionalArg()\n      ? (S.PDiag(diag::warn_printf_positional_arg_exceeds_data_args)\n           << (argIndex+1) << NumDataArgs)\n      : S.PDiag(diag::warn_printf_insufficient_data_args);\n    EmitFormatDiagnostic(\n      PDiag, getLocationOfByte(CS.getStart()), /*IsStringLocation*/true,\n      getSpecifierRange(startSpecifier, specifierLen));\n\n    // Since more arguments than conversion tokens are given, by extension\n    // all arguments are covered, so mark this as so.\n    UncoveredArg.setAllCovered();\n    return false;\n  }\n  return true;\n}\n\ntemplate<typename Range>\nvoid CheckFormatHandler::EmitFormatDiagnostic(PartialDiagnostic PDiag,\n                                              SourceLocation Loc,\n                                              bool IsStringLocation,\n                                              Range StringRange,\n                                              ArrayRef<FixItHint> FixIt) {\n  EmitFormatDiagnostic(S, inFunctionCall, Args[FormatIdx], PDiag,\n                       Loc, IsStringLocation, StringRange, FixIt);\n}\n\n/// If the format string is not within the function call, emit a note\n/// so that the function call and string are in diagnostic messages.\n///\n/// \\param InFunctionCall if true, the format string is within the function\n/// call and only one diagnostic message will be produced.  Otherwise, an\n/// extra note will be emitted pointing to location of the format string.\n///\n/// \\param ArgumentExpr the expression that is passed as the format string\n/// argument in the function call.  Used for getting locations when two\n/// diagnostics are emitted.\n///\n/// \\param PDiag the callee should already have provided any strings for the\n/// diagnostic message.  This function only adds locations and fixits\n/// to diagnostics.\n///\n/// \\param Loc primary location for diagnostic.  If two diagnostics are\n/// required, one will be at Loc and a new SourceLocation will be created for\n/// the other one.\n///\n/// \\param IsStringLocation if true, Loc points to the format string should be\n/// used for the note.  Otherwise, Loc points to the argument list and will\n/// be used with PDiag.\n///\n/// \\param StringRange some or all of the string to highlight.  This is\n/// templated so it can accept either a CharSourceRange or a SourceRange.\n///\n/// \\param FixIt optional fix it hint for the format string.\ntemplate <typename Range>\nvoid CheckFormatHandler::EmitFormatDiagnostic(\n    Sema &S, bool InFunctionCall, const Expr *ArgumentExpr,\n    const PartialDiagnostic &PDiag, SourceLocation Loc, bool IsStringLocation,\n    Range StringRange, ArrayRef<FixItHint> FixIt) {\n  if (InFunctionCall) {\n    const Sema::SemaDiagnosticBuilder &D = S.Diag(Loc, PDiag);\n    D << StringRange;\n    D << FixIt;\n  } else {\n    S.Diag(IsStringLocation ? ArgumentExpr->getExprLoc() : Loc, PDiag)\n      << ArgumentExpr->getSourceRange();\n\n    const Sema::SemaDiagnosticBuilder &Note =\n      S.Diag(IsStringLocation ? Loc : StringRange.getBegin(),\n             diag::note_format_string_defined);\n\n    Note << StringRange;\n    Note << FixIt;\n  }\n}\n\n//===--- CHECK: Printf format string checking ------------------------------===//\n\nnamespace {\n\nclass CheckPrintfHandler : public CheckFormatHandler {\npublic:\n  CheckPrintfHandler(Sema &s, const FormatStringLiteral *fexpr,\n                     const Expr *origFormatExpr,\n                     const Sema::FormatStringType type, unsigned firstDataArg,\n                     unsigned numDataArgs, bool isObjC, const char *beg,\n                     bool hasVAListArg, ArrayRef<const Expr *> Args,\n                     unsigned formatIdx, bool inFunctionCall,\n                     Sema::VariadicCallType CallType,\n                     llvm::SmallBitVector &CheckedVarArgs,\n                     UncoveredArgHandler &UncoveredArg)\n      : CheckFormatHandler(s, fexpr, origFormatExpr, type, firstDataArg,\n                           numDataArgs, beg, hasVAListArg, Args, formatIdx,\n                           inFunctionCall, CallType, CheckedVarArgs,\n                           UncoveredArg) {}\n\n  bool isObjCContext() const { return FSType == Sema::FST_NSString; }\n\n  /// Returns true if '%@' specifiers are allowed in the format string.\n  bool allowsObjCArg() const {\n    return FSType == Sema::FST_NSString || FSType == Sema::FST_OSLog ||\n           FSType == Sema::FST_OSTrace;\n  }\n\n  bool HandleInvalidPrintfConversionSpecifier(\n                                      const analyze_printf::PrintfSpecifier &FS,\n                                      const char *startSpecifier,\n                                      unsigned specifierLen) override;\n\n  void handleInvalidMaskType(StringRef MaskType) override;\n\n  bool HandlePrintfSpecifier(const analyze_printf::PrintfSpecifier &FS,\n                             const char *startSpecifier,\n                             unsigned specifierLen) override;\n  bool checkFormatExpr(const analyze_printf::PrintfSpecifier &FS,\n                       const char *StartSpecifier,\n                       unsigned SpecifierLen,\n                       const Expr *E);\n\n  bool HandleAmount(const analyze_format_string::OptionalAmount &Amt, unsigned k,\n                    const char *startSpecifier, unsigned specifierLen);\n  void HandleInvalidAmount(const analyze_printf::PrintfSpecifier &FS,\n                           const analyze_printf::OptionalAmount &Amt,\n                           unsigned type,\n                           const char *startSpecifier, unsigned specifierLen);\n  void HandleFlag(const analyze_printf::PrintfSpecifier &FS,\n                  const analyze_printf::OptionalFlag &flag,\n                  const char *startSpecifier, unsigned specifierLen);\n  void HandleIgnoredFlag(const analyze_printf::PrintfSpecifier &FS,\n                         const analyze_printf::OptionalFlag &ignoredFlag,\n                         const analyze_printf::OptionalFlag &flag,\n                         const char *startSpecifier, unsigned specifierLen);\n  bool checkForCStrMembers(const analyze_printf::ArgType &AT,\n                           const Expr *E);\n\n  void HandleEmptyObjCModifierFlag(const char *startFlag,\n                                   unsigned flagLen) override;\n\n  void HandleInvalidObjCModifierFlag(const char *startFlag,\n                                            unsigned flagLen) override;\n\n  void HandleObjCFlagsWithNonObjCConversion(const char *flagsStart,\n                                           const char *flagsEnd,\n                                           const char *conversionPosition)\n                                             override;\n};\n\n} // namespace\n\nbool CheckPrintfHandler::HandleInvalidPrintfConversionSpecifier(\n                                      const analyze_printf::PrintfSpecifier &FS,\n                                      const char *startSpecifier,\n                                      unsigned specifierLen) {\n  const analyze_printf::PrintfConversionSpecifier &CS =\n    FS.getConversionSpecifier();\n\n  return HandleInvalidConversionSpecifier(FS.getArgIndex(),\n                                          getLocationOfByte(CS.getStart()),\n                                          startSpecifier, specifierLen,\n                                          CS.getStart(), CS.getLength());\n}\n\nvoid CheckPrintfHandler::handleInvalidMaskType(StringRef MaskType) {\n  S.Diag(getLocationOfByte(MaskType.data()), diag::err_invalid_mask_type_size);\n}\n\nbool CheckPrintfHandler::HandleAmount(\n                               const analyze_format_string::OptionalAmount &Amt,\n                               unsigned k, const char *startSpecifier,\n                               unsigned specifierLen) {\n  if (Amt.hasDataArgument()) {\n    if (!HasVAListArg) {\n      unsigned argIndex = Amt.getArgIndex();\n      if (argIndex >= NumDataArgs) {\n        EmitFormatDiagnostic(S.PDiag(diag::warn_printf_asterisk_missing_arg)\n                               << k,\n                             getLocationOfByte(Amt.getStart()),\n                             /*IsStringLocation*/true,\n                             getSpecifierRange(startSpecifier, specifierLen));\n        // Don't do any more checking.  We will just emit\n        // spurious errors.\n        return false;\n      }\n\n      // Type check the data argument.  It should be an 'int'.\n      // Although not in conformance with C99, we also allow the argument to be\n      // an 'unsigned int' as that is a reasonably safe case.  GCC also\n      // doesn't emit a warning for that case.\n      CoveredArgs.set(argIndex);\n      const Expr *Arg = getDataArg(argIndex);\n      if (!Arg)\n        return false;\n\n      QualType T = Arg->getType();\n\n      const analyze_printf::ArgType &AT = Amt.getArgType(S.Context);\n      assert(AT.isValid());\n\n      if (!AT.matchesType(S.Context, T)) {\n        EmitFormatDiagnostic(S.PDiag(diag::warn_printf_asterisk_wrong_type)\n                               << k << AT.getRepresentativeTypeName(S.Context)\n                               << T << Arg->getSourceRange(),\n                             getLocationOfByte(Amt.getStart()),\n                             /*IsStringLocation*/true,\n                             getSpecifierRange(startSpecifier, specifierLen));\n        // Don't do any more checking.  We will just emit\n        // spurious errors.\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid CheckPrintfHandler::HandleInvalidAmount(\n                                      const analyze_printf::PrintfSpecifier &FS,\n                                      const analyze_printf::OptionalAmount &Amt,\n                                      unsigned type,\n                                      const char *startSpecifier,\n                                      unsigned specifierLen) {\n  const analyze_printf::PrintfConversionSpecifier &CS =\n    FS.getConversionSpecifier();\n\n  FixItHint fixit =\n    Amt.getHowSpecified() == analyze_printf::OptionalAmount::Constant\n      ? FixItHint::CreateRemoval(getSpecifierRange(Amt.getStart(),\n                                 Amt.getConstantLength()))\n      : FixItHint();\n\n  EmitFormatDiagnostic(S.PDiag(diag::warn_printf_nonsensical_optional_amount)\n                         << type << CS.toString(),\n                       getLocationOfByte(Amt.getStart()),\n                       /*IsStringLocation*/true,\n                       getSpecifierRange(startSpecifier, specifierLen),\n                       fixit);\n}\n\nvoid CheckPrintfHandler::HandleFlag(const analyze_printf::PrintfSpecifier &FS,\n                                    const analyze_printf::OptionalFlag &flag,\n                                    const char *startSpecifier,\n                                    unsigned specifierLen) {\n  // Warn about pointless flag with a fixit removal.\n  const analyze_printf::PrintfConversionSpecifier &CS =\n    FS.getConversionSpecifier();\n  EmitFormatDiagnostic(S.PDiag(diag::warn_printf_nonsensical_flag)\n                         << flag.toString() << CS.toString(),\n                       getLocationOfByte(flag.getPosition()),\n                       /*IsStringLocation*/true,\n                       getSpecifierRange(startSpecifier, specifierLen),\n                       FixItHint::CreateRemoval(\n                         getSpecifierRange(flag.getPosition(), 1)));\n}\n\nvoid CheckPrintfHandler::HandleIgnoredFlag(\n                                const analyze_printf::PrintfSpecifier &FS,\n                                const analyze_printf::OptionalFlag &ignoredFlag,\n                                const analyze_printf::OptionalFlag &flag,\n                                const char *startSpecifier,\n                                unsigned specifierLen) {\n  // Warn about ignored flag with a fixit removal.\n  EmitFormatDiagnostic(S.PDiag(diag::warn_printf_ignored_flag)\n                         << ignoredFlag.toString() << flag.toString(),\n                       getLocationOfByte(ignoredFlag.getPosition()),\n                       /*IsStringLocation*/true,\n                       getSpecifierRange(startSpecifier, specifierLen),\n                       FixItHint::CreateRemoval(\n                         getSpecifierRange(ignoredFlag.getPosition(), 1)));\n}\n\nvoid CheckPrintfHandler::HandleEmptyObjCModifierFlag(const char *startFlag,\n                                                     unsigned flagLen) {\n  // Warn about an empty flag.\n  EmitFormatDiagnostic(S.PDiag(diag::warn_printf_empty_objc_flag),\n                       getLocationOfByte(startFlag),\n                       /*IsStringLocation*/true,\n                       getSpecifierRange(startFlag, flagLen));\n}\n\nvoid CheckPrintfHandler::HandleInvalidObjCModifierFlag(const char *startFlag,\n                                                       unsigned flagLen) {\n  // Warn about an invalid flag.\n  auto Range = getSpecifierRange(startFlag, flagLen);\n  StringRef flag(startFlag, flagLen);\n  EmitFormatDiagnostic(S.PDiag(diag::warn_printf_invalid_objc_flag) << flag,\n                      getLocationOfByte(startFlag),\n                      /*IsStringLocation*/true,\n                      Range, FixItHint::CreateRemoval(Range));\n}\n\nvoid CheckPrintfHandler::HandleObjCFlagsWithNonObjCConversion(\n    const char *flagsStart, const char *flagsEnd, const char *conversionPosition) {\n    // Warn about using '[...]' without a '@' conversion.\n    auto Range = getSpecifierRange(flagsStart, flagsEnd - flagsStart + 1);\n    auto diag = diag::warn_printf_ObjCflags_without_ObjCConversion;\n    EmitFormatDiagnostic(S.PDiag(diag) << StringRef(conversionPosition, 1),\n                         getLocationOfByte(conversionPosition),\n                         /*IsStringLocation*/true,\n                         Range, FixItHint::CreateRemoval(Range));\n}\n\n// Determines if the specified is a C++ class or struct containing\n// a member with the specified name and kind (e.g. a CXXMethodDecl named\n// \"c_str()\").\ntemplate<typename MemberKind>\nstatic llvm::SmallPtrSet<MemberKind*, 1>\nCXXRecordMembersNamed(StringRef Name, Sema &S, QualType Ty) {\n  const RecordType *RT = Ty->getAs<RecordType>();\n  llvm::SmallPtrSet<MemberKind*, 1> Results;\n\n  if (!RT)\n    return Results;\n  const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(RT->getDecl());\n  if (!RD || !RD->getDefinition())\n    return Results;\n\n  LookupResult R(S, &S.Context.Idents.get(Name), SourceLocation(),\n                 Sema::LookupMemberName);\n  R.suppressDiagnostics();\n\n  // We just need to include all members of the right kind turned up by the\n  // filter, at this point.\n  if (S.LookupQualifiedName(R, RT->getDecl()))\n    for (LookupResult::iterator I = R.begin(), E = R.end(); I != E; ++I) {\n      NamedDecl *decl = (*I)->getUnderlyingDecl();\n      if (MemberKind *FK = dyn_cast<MemberKind>(decl))\n        Results.insert(FK);\n    }\n  return Results;\n}\n\n/// Check if we could call '.c_str()' on an object.\n///\n/// FIXME: This returns the wrong results in some cases (if cv-qualifiers don't\n/// allow the call, or if it would be ambiguous).\nbool Sema::hasCStrMethod(const Expr *E) {\n  using MethodSet = llvm::SmallPtrSet<CXXMethodDecl *, 1>;\n\n  MethodSet Results =\n      CXXRecordMembersNamed<CXXMethodDecl>(\"c_str\", *this, E->getType());\n  for (MethodSet::iterator MI = Results.begin(), ME = Results.end();\n       MI != ME; ++MI)\n    if ((*MI)->getMinRequiredArguments() == 0)\n      return true;\n  return false;\n}\n\n// Check if a (w)string was passed when a (w)char* was needed, and offer a\n// better diagnostic if so. AT is assumed to be valid.\n// Returns true when a c_str() conversion method is found.\nbool CheckPrintfHandler::checkForCStrMembers(\n    const analyze_printf::ArgType &AT, const Expr *E) {\n  using MethodSet = llvm::SmallPtrSet<CXXMethodDecl *, 1>;\n\n  MethodSet Results =\n      CXXRecordMembersNamed<CXXMethodDecl>(\"c_str\", S, E->getType());\n\n  for (MethodSet::iterator MI = Results.begin(), ME = Results.end();\n       MI != ME; ++MI) {\n    const CXXMethodDecl *Method = *MI;\n    if (Method->getMinRequiredArguments() == 0 &&\n        AT.matchesType(S.Context, Method->getReturnType())) {\n      // FIXME: Suggest parens if the expression needs them.\n      SourceLocation EndLoc = S.getLocForEndOfToken(E->getEndLoc());\n      S.Diag(E->getBeginLoc(), diag::note_printf_c_str)\n          << \"c_str()\" << FixItHint::CreateInsertion(EndLoc, \".c_str()\");\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool\nCheckPrintfHandler::HandlePrintfSpecifier(const analyze_printf::PrintfSpecifier\n                                            &FS,\n                                          const char *startSpecifier,\n                                          unsigned specifierLen) {\n  using namespace analyze_format_string;\n  using namespace analyze_printf;\n\n  const PrintfConversionSpecifier &CS = FS.getConversionSpecifier();\n\n  if (FS.consumesDataArgument()) {\n    if (atFirstArg) {\n        atFirstArg = false;\n        usesPositionalArgs = FS.usesPositionalArg();\n    }\n    else if (usesPositionalArgs != FS.usesPositionalArg()) {\n      HandlePositionalNonpositionalArgs(getLocationOfByte(CS.getStart()),\n                                        startSpecifier, specifierLen);\n      return false;\n    }\n  }\n\n  // First check if the field width, precision, and conversion specifier\n  // have matching data arguments.\n  if (!HandleAmount(FS.getFieldWidth(), /* field width */ 0,\n                    startSpecifier, specifierLen)) {\n    return false;\n  }\n\n  if (!HandleAmount(FS.getPrecision(), /* precision */ 1,\n                    startSpecifier, specifierLen)) {\n    return false;\n  }\n\n  if (!CS.consumesDataArgument()) {\n    // FIXME: Technically specifying a precision or field width here\n    // makes no sense.  Worth issuing a warning at some point.\n    return true;\n  }\n\n  // Consume the argument.\n  unsigned argIndex = FS.getArgIndex();\n  if (argIndex < NumDataArgs) {\n    // The check to see if the argIndex is valid will come later.\n    // We set the bit here because we may exit early from this\n    // function if we encounter some other error.\n    CoveredArgs.set(argIndex);\n  }\n\n  // FreeBSD kernel extensions.\n  if (CS.getKind() == ConversionSpecifier::FreeBSDbArg ||\n      CS.getKind() == ConversionSpecifier::FreeBSDDArg) {\n    // We need at least two arguments.\n    if (!CheckNumArgs(FS, CS, startSpecifier, specifierLen, argIndex + 1))\n      return false;\n\n    // Claim the second argument.\n    CoveredArgs.set(argIndex + 1);\n\n    // Type check the first argument (int for %b, pointer for %D)\n    const Expr *Ex = getDataArg(argIndex);\n    const analyze_printf::ArgType &AT =\n      (CS.getKind() == ConversionSpecifier::FreeBSDbArg) ?\n        ArgType(S.Context.IntTy) : ArgType::CPointerTy;\n    if (AT.isValid() && !AT.matchesType(S.Context, Ex->getType()))\n      EmitFormatDiagnostic(\n          S.PDiag(diag::warn_format_conversion_argument_type_mismatch)\n              << AT.getRepresentativeTypeName(S.Context) << Ex->getType()\n              << false << Ex->getSourceRange(),\n          Ex->getBeginLoc(), /*IsStringLocation*/ false,\n          getSpecifierRange(startSpecifier, specifierLen));\n\n    // Type check the second argument (char * for both %b and %D)\n    Ex = getDataArg(argIndex + 1);\n    const analyze_printf::ArgType &AT2 = ArgType::CStrTy;\n    if (AT2.isValid() && !AT2.matchesType(S.Context, Ex->getType()))\n      EmitFormatDiagnostic(\n          S.PDiag(diag::warn_format_conversion_argument_type_mismatch)\n              << AT2.getRepresentativeTypeName(S.Context) << Ex->getType()\n              << false << Ex->getSourceRange(),\n          Ex->getBeginLoc(), /*IsStringLocation*/ false,\n          getSpecifierRange(startSpecifier, specifierLen));\n\n     return true;\n  }\n\n  // Check for using an Objective-C specific conversion specifier\n  // in a non-ObjC literal.\n  if (!allowsObjCArg() && CS.isObjCArg()) {\n    return HandleInvalidPrintfConversionSpecifier(FS, startSpecifier,\n                                                  specifierLen);\n  }\n\n  // %P can only be used with os_log.\n  if (FSType != Sema::FST_OSLog && CS.getKind() == ConversionSpecifier::PArg) {\n    return HandleInvalidPrintfConversionSpecifier(FS, startSpecifier,\n                                                  specifierLen);\n  }\n\n  // %n is not allowed with os_log.\n  if (FSType == Sema::FST_OSLog && CS.getKind() == ConversionSpecifier::nArg) {\n    EmitFormatDiagnostic(S.PDiag(diag::warn_os_log_format_narg),\n                         getLocationOfByte(CS.getStart()),\n                         /*IsStringLocation*/ false,\n                         getSpecifierRange(startSpecifier, specifierLen));\n\n    return true;\n  }\n\n  // Only scalars are allowed for os_trace.\n  if (FSType == Sema::FST_OSTrace &&\n      (CS.getKind() == ConversionSpecifier::PArg ||\n       CS.getKind() == ConversionSpecifier::sArg ||\n       CS.getKind() == ConversionSpecifier::ObjCObjArg)) {\n    return HandleInvalidPrintfConversionSpecifier(FS, startSpecifier,\n                                                  specifierLen);\n  }\n\n  // Check for use of public/private annotation outside of os_log().\n  if (FSType != Sema::FST_OSLog) {\n    if (FS.isPublic().isSet()) {\n      EmitFormatDiagnostic(S.PDiag(diag::warn_format_invalid_annotation)\n                               << \"public\",\n                           getLocationOfByte(FS.isPublic().getPosition()),\n                           /*IsStringLocation*/ false,\n                           getSpecifierRange(startSpecifier, specifierLen));\n    }\n    if (FS.isPrivate().isSet()) {\n      EmitFormatDiagnostic(S.PDiag(diag::warn_format_invalid_annotation)\n                               << \"private\",\n                           getLocationOfByte(FS.isPrivate().getPosition()),\n                           /*IsStringLocation*/ false,\n                           getSpecifierRange(startSpecifier, specifierLen));\n    }\n  }\n\n  // Check for invalid use of field width\n  if (!FS.hasValidFieldWidth()) {\n    HandleInvalidAmount(FS, FS.getFieldWidth(), /* field width */ 0,\n        startSpecifier, specifierLen);\n  }\n\n  // Check for invalid use of precision\n  if (!FS.hasValidPrecision()) {\n    HandleInvalidAmount(FS, FS.getPrecision(), /* precision */ 1,\n        startSpecifier, specifierLen);\n  }\n\n  // Precision is mandatory for %P specifier.\n  if (CS.getKind() == ConversionSpecifier::PArg &&\n      FS.getPrecision().getHowSpecified() == OptionalAmount::NotSpecified) {\n    EmitFormatDiagnostic(S.PDiag(diag::warn_format_P_no_precision),\n                         getLocationOfByte(startSpecifier),\n                         /*IsStringLocation*/ false,\n                         getSpecifierRange(startSpecifier, specifierLen));\n  }\n\n  // Check each flag does not conflict with any other component.\n  if (!FS.hasValidThousandsGroupingPrefix())\n    HandleFlag(FS, FS.hasThousandsGrouping(), startSpecifier, specifierLen);\n  if (!FS.hasValidLeadingZeros())\n    HandleFlag(FS, FS.hasLeadingZeros(), startSpecifier, specifierLen);\n  if (!FS.hasValidPlusPrefix())\n    HandleFlag(FS, FS.hasPlusPrefix(), startSpecifier, specifierLen);\n  if (!FS.hasValidSpacePrefix())\n    HandleFlag(FS, FS.hasSpacePrefix(), startSpecifier, specifierLen);\n  if (!FS.hasValidAlternativeForm())\n    HandleFlag(FS, FS.hasAlternativeForm(), startSpecifier, specifierLen);\n  if (!FS.hasValidLeftJustified())\n    HandleFlag(FS, FS.isLeftJustified(), startSpecifier, specifierLen);\n\n  // Check that flags are not ignored by another flag\n  if (FS.hasSpacePrefix() && FS.hasPlusPrefix()) // ' ' ignored by '+'\n    HandleIgnoredFlag(FS, FS.hasSpacePrefix(), FS.hasPlusPrefix(),\n        startSpecifier, specifierLen);\n  if (FS.hasLeadingZeros() && FS.isLeftJustified()) // '0' ignored by '-'\n    HandleIgnoredFlag(FS, FS.hasLeadingZeros(), FS.isLeftJustified(),\n            startSpecifier, specifierLen);\n\n  // Check the length modifier is valid with the given conversion specifier.\n  if (!FS.hasValidLengthModifier(S.getASTContext().getTargetInfo(),\n                                 S.getLangOpts()))\n    HandleInvalidLengthModifier(FS, CS, startSpecifier, specifierLen,\n                                diag::warn_format_nonsensical_length);\n  else if (!FS.hasStandardLengthModifier())\n    HandleNonStandardLengthModifier(FS, startSpecifier, specifierLen);\n  else if (!FS.hasStandardLengthConversionCombination())\n    HandleInvalidLengthModifier(FS, CS, startSpecifier, specifierLen,\n                                diag::warn_format_non_standard_conversion_spec);\n\n  if (!FS.hasStandardConversionSpecifier(S.getLangOpts()))\n    HandleNonStandardConversionSpecifier(CS, startSpecifier, specifierLen);\n\n  // The remaining checks depend on the data arguments.\n  if (HasVAListArg)\n    return true;\n\n  if (!CheckNumArgs(FS, CS, startSpecifier, specifierLen, argIndex))\n    return false;\n\n  const Expr *Arg = getDataArg(argIndex);\n  if (!Arg)\n    return true;\n\n  return checkFormatExpr(FS, startSpecifier, specifierLen, Arg);\n}\n\nstatic bool requiresParensToAddCast(const Expr *E) {\n  // FIXME: We should have a general way to reason about operator\n  // precedence and whether parens are actually needed here.\n  // Take care of a few common cases where they aren't.\n  const Expr *Inside = E->IgnoreImpCasts();\n  if (const PseudoObjectExpr *POE = dyn_cast<PseudoObjectExpr>(Inside))\n    Inside = POE->getSyntacticForm()->IgnoreImpCasts();\n\n  switch (Inside->getStmtClass()) {\n  case Stmt::ArraySubscriptExprClass:\n  case Stmt::CallExprClass:\n  case Stmt::CharacterLiteralClass:\n  case Stmt::CXXBoolLiteralExprClass:\n  case Stmt::DeclRefExprClass:\n  case Stmt::FloatingLiteralClass:\n  case Stmt::IntegerLiteralClass:\n  case Stmt::MemberExprClass:\n  case Stmt::ObjCArrayLiteralClass:\n  case Stmt::ObjCBoolLiteralExprClass:\n  case Stmt::ObjCBoxedExprClass:\n  case Stmt::ObjCDictionaryLiteralClass:\n  case Stmt::ObjCEncodeExprClass:\n  case Stmt::ObjCIvarRefExprClass:\n  case Stmt::ObjCMessageExprClass:\n  case Stmt::ObjCPropertyRefExprClass:\n  case Stmt::ObjCStringLiteralClass:\n  case Stmt::ObjCSubscriptRefExprClass:\n  case Stmt::ParenExprClass:\n  case Stmt::StringLiteralClass:\n  case Stmt::UnaryOperatorClass:\n    return false;\n  default:\n    return true;\n  }\n}\n\nstatic std::pair<QualType, StringRef>\nshouldNotPrintDirectly(const ASTContext &Context,\n                       QualType IntendedTy,\n                       const Expr *E) {\n  // Use a 'while' to peel off layers of typedefs.\n  QualType TyTy = IntendedTy;\n  while (const TypedefType *UserTy = TyTy->getAs<TypedefType>()) {\n    StringRef Name = UserTy->getDecl()->getName();\n    QualType CastTy = llvm::StringSwitch<QualType>(Name)\n      .Case(\"CFIndex\", Context.getNSIntegerType())\n      .Case(\"NSInteger\", Context.getNSIntegerType())\n      .Case(\"NSUInteger\", Context.getNSUIntegerType())\n      .Case(\"SInt32\", Context.IntTy)\n      .Case(\"UInt32\", Context.UnsignedIntTy)\n      .Default(QualType());\n\n    if (!CastTy.isNull())\n      return std::make_pair(CastTy, Name);\n\n    TyTy = UserTy->desugar();\n  }\n\n  // Strip parens if necessary.\n  if (const ParenExpr *PE = dyn_cast<ParenExpr>(E))\n    return shouldNotPrintDirectly(Context,\n                                  PE->getSubExpr()->getType(),\n                                  PE->getSubExpr());\n\n  // If this is a conditional expression, then its result type is constructed\n  // via usual arithmetic conversions and thus there might be no necessary\n  // typedef sugar there.  Recurse to operands to check for NSInteger &\n  // Co. usage condition.\n  if (const ConditionalOperator *CO = dyn_cast<ConditionalOperator>(E)) {\n    QualType TrueTy, FalseTy;\n    StringRef TrueName, FalseName;\n\n    std::tie(TrueTy, TrueName) =\n      shouldNotPrintDirectly(Context,\n                             CO->getTrueExpr()->getType(),\n                             CO->getTrueExpr());\n    std::tie(FalseTy, FalseName) =\n      shouldNotPrintDirectly(Context,\n                             CO->getFalseExpr()->getType(),\n                             CO->getFalseExpr());\n\n    if (TrueTy == FalseTy)\n      return std::make_pair(TrueTy, TrueName);\n    else if (TrueTy.isNull())\n      return std::make_pair(FalseTy, FalseName);\n    else if (FalseTy.isNull())\n      return std::make_pair(TrueTy, TrueName);\n  }\n\n  return std::make_pair(QualType(), StringRef());\n}\n\n/// Return true if \\p ICE is an implicit argument promotion of an arithmetic\n/// type. Bit-field 'promotions' from a higher ranked type to a lower ranked\n/// type do not count.\nstatic bool\nisArithmeticArgumentPromotion(Sema &S, const ImplicitCastExpr *ICE) {\n  QualType From = ICE->getSubExpr()->getType();\n  QualType To = ICE->getType();\n  // It's an integer promotion if the destination type is the promoted\n  // source type.\n  if (ICE->getCastKind() == CK_IntegralCast &&\n      From->isPromotableIntegerType() &&\n      S.Context.getPromotedIntegerType(From) == To)\n    return true;\n  // Look through vector types, since we do default argument promotion for\n  // those in OpenCL.\n  if (const auto *VecTy = From->getAs<ExtVectorType>())\n    From = VecTy->getElementType();\n  if (const auto *VecTy = To->getAs<ExtVectorType>())\n    To = VecTy->getElementType();\n  // It's a floating promotion if the source type is a lower rank.\n  return ICE->getCastKind() == CK_FloatingCast &&\n         S.Context.getFloatingTypeOrder(From, To) < 0;\n}\n\nbool\nCheckPrintfHandler::checkFormatExpr(const analyze_printf::PrintfSpecifier &FS,\n                                    const char *StartSpecifier,\n                                    unsigned SpecifierLen,\n                                    const Expr *E) {\n  using namespace analyze_format_string;\n  using namespace analyze_printf;\n\n  // Now type check the data expression that matches the\n  // format specifier.\n  const analyze_printf::ArgType &AT = FS.getArgType(S.Context, isObjCContext());\n  if (!AT.isValid())\n    return true;\n\n  QualType ExprTy = E->getType();\n  while (const TypeOfExprType *TET = dyn_cast<TypeOfExprType>(ExprTy)) {\n    ExprTy = TET->getUnderlyingExpr()->getType();\n  }\n\n  // Diagnose attempts to print a boolean value as a character. Unlike other\n  // -Wformat diagnostics, this is fine from a type perspective, but it still\n  // doesn't make sense.\n  if (FS.getConversionSpecifier().getKind() == ConversionSpecifier::cArg &&\n      E->isKnownToHaveBooleanValue()) {\n    const CharSourceRange &CSR =\n        getSpecifierRange(StartSpecifier, SpecifierLen);\n    SmallString<4> FSString;\n    llvm::raw_svector_ostream os(FSString);\n    FS.toString(os);\n    EmitFormatDiagnostic(S.PDiag(diag::warn_format_bool_as_character)\n                             << FSString,\n                         E->getExprLoc(), false, CSR);\n    return true;\n  }\n\n  analyze_printf::ArgType::MatchKind Match = AT.matchesType(S.Context, ExprTy);\n  if (Match == analyze_printf::ArgType::Match)\n    return true;\n\n  // Look through argument promotions for our error message's reported type.\n  // This includes the integral and floating promotions, but excludes array\n  // and function pointer decay (seeing that an argument intended to be a\n  // string has type 'char [6]' is probably more confusing than 'char *') and\n  // certain bitfield promotions (bitfields can be 'demoted' to a lesser type).\n  if (const ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(E)) {\n    if (isArithmeticArgumentPromotion(S, ICE)) {\n      E = ICE->getSubExpr();\n      ExprTy = E->getType();\n\n      // Check if we didn't match because of an implicit cast from a 'char'\n      // or 'short' to an 'int'.  This is done because printf is a varargs\n      // function.\n      if (ICE->getType() == S.Context.IntTy ||\n          ICE->getType() == S.Context.UnsignedIntTy) {\n        // All further checking is done on the subexpression\n        const analyze_printf::ArgType::MatchKind ImplicitMatch =\n            AT.matchesType(S.Context, ExprTy);\n        if (ImplicitMatch == analyze_printf::ArgType::Match)\n          return true;\n        if (ImplicitMatch == ArgType::NoMatchPedantic ||\n            ImplicitMatch == ArgType::NoMatchTypeConfusion)\n          Match = ImplicitMatch;\n      }\n    }\n  } else if (const CharacterLiteral *CL = dyn_cast<CharacterLiteral>(E)) {\n    // Special case for 'a', which has type 'int' in C.\n    // Note, however, that we do /not/ want to treat multibyte constants like\n    // 'MooV' as characters! This form is deprecated but still exists. In\n    // addition, don't treat expressions as of type 'char' if one byte length\n    // modifier is provided.\n    if (ExprTy == S.Context.IntTy &&\n        FS.getLengthModifier().getKind() != LengthModifier::AsChar)\n      if (llvm::isUIntN(S.Context.getCharWidth(), CL->getValue()))\n        ExprTy = S.Context.CharTy;\n  }\n\n  // Look through enums to their underlying type.\n  bool IsEnum = false;\n  if (auto EnumTy = ExprTy->getAs<EnumType>()) {\n    ExprTy = EnumTy->getDecl()->getIntegerType();\n    IsEnum = true;\n  }\n\n  // %C in an Objective-C context prints a unichar, not a wchar_t.\n  // If the argument is an integer of some kind, believe the %C and suggest\n  // a cast instead of changing the conversion specifier.\n  QualType IntendedTy = ExprTy;\n  if (isObjCContext() &&\n      FS.getConversionSpecifier().getKind() == ConversionSpecifier::CArg) {\n    if (ExprTy->isIntegralOrUnscopedEnumerationType() &&\n        !ExprTy->isCharType()) {\n      // 'unichar' is defined as a typedef of unsigned short, but we should\n      // prefer using the typedef if it is visible.\n      IntendedTy = S.Context.UnsignedShortTy;\n\n      // While we are here, check if the value is an IntegerLiteral that happens\n      // to be within the valid range.\n      if (const IntegerLiteral *IL = dyn_cast<IntegerLiteral>(E)) {\n        const llvm::APInt &V = IL->getValue();\n        if (V.getActiveBits() <= S.Context.getTypeSize(IntendedTy))\n          return true;\n      }\n\n      LookupResult Result(S, &S.Context.Idents.get(\"unichar\"), E->getBeginLoc(),\n                          Sema::LookupOrdinaryName);\n      if (S.LookupName(Result, S.getCurScope())) {\n        NamedDecl *ND = Result.getFoundDecl();\n        if (TypedefNameDecl *TD = dyn_cast<TypedefNameDecl>(ND))\n          if (TD->getUnderlyingType() == IntendedTy)\n            IntendedTy = S.Context.getTypedefType(TD);\n      }\n    }\n  }\n\n  // Special-case some of Darwin's platform-independence types by suggesting\n  // casts to primitive types that are known to be large enough.\n  bool ShouldNotPrintDirectly = false; StringRef CastTyName;\n  if (S.Context.getTargetInfo().getTriple().isOSDarwin()) {\n    QualType CastTy;\n    std::tie(CastTy, CastTyName) = shouldNotPrintDirectly(S.Context, IntendedTy, E);\n    if (!CastTy.isNull()) {\n      // %zi/%zu and %td/%tu are OK to use for NSInteger/NSUInteger of type int\n      // (long in ASTContext). Only complain to pedants.\n      if ((CastTyName == \"NSInteger\" || CastTyName == \"NSUInteger\") &&\n          (AT.isSizeT() || AT.isPtrdiffT()) &&\n          AT.matchesType(S.Context, CastTy))\n        Match = ArgType::NoMatchPedantic;\n      IntendedTy = CastTy;\n      ShouldNotPrintDirectly = true;\n    }\n  }\n\n  // We may be able to offer a FixItHint if it is a supported type.\n  PrintfSpecifier fixedFS = FS;\n  bool Success =\n      fixedFS.fixType(IntendedTy, S.getLangOpts(), S.Context, isObjCContext());\n\n  if (Success) {\n    // Get the fix string from the fixed format specifier\n    SmallString<16> buf;\n    llvm::raw_svector_ostream os(buf);\n    fixedFS.toString(os);\n\n    CharSourceRange SpecRange = getSpecifierRange(StartSpecifier, SpecifierLen);\n\n    if (IntendedTy == ExprTy && !ShouldNotPrintDirectly) {\n      unsigned Diag;\n      switch (Match) {\n      case ArgType::Match: llvm_unreachable(\"expected non-matching\");\n      case ArgType::NoMatchPedantic:\n        Diag = diag::warn_format_conversion_argument_type_mismatch_pedantic;\n        break;\n      case ArgType::NoMatchTypeConfusion:\n        Diag = diag::warn_format_conversion_argument_type_mismatch_confusion;\n        break;\n      case ArgType::NoMatch:\n        Diag = diag::warn_format_conversion_argument_type_mismatch;\n        break;\n      }\n\n      // In this case, the specifier is wrong and should be changed to match\n      // the argument.\n      EmitFormatDiagnostic(S.PDiag(Diag)\n                               << AT.getRepresentativeTypeName(S.Context)\n                               << IntendedTy << IsEnum << E->getSourceRange(),\n                           E->getBeginLoc(),\n                           /*IsStringLocation*/ false, SpecRange,\n                           FixItHint::CreateReplacement(SpecRange, os.str()));\n    } else {\n      // The canonical type for formatting this value is different from the\n      // actual type of the expression. (This occurs, for example, with Darwin's\n      // NSInteger on 32-bit platforms, where it is typedef'd as 'int', but\n      // should be printed as 'long' for 64-bit compatibility.)\n      // Rather than emitting a normal format/argument mismatch, we want to\n      // add a cast to the recommended type (and correct the format string\n      // if necessary).\n      SmallString<16> CastBuf;\n      llvm::raw_svector_ostream CastFix(CastBuf);\n      CastFix << \"(\";\n      IntendedTy.print(CastFix, S.Context.getPrintingPolicy());\n      CastFix << \")\";\n\n      SmallVector<FixItHint,4> Hints;\n      if (!AT.matchesType(S.Context, IntendedTy) || ShouldNotPrintDirectly)\n        Hints.push_back(FixItHint::CreateReplacement(SpecRange, os.str()));\n\n      if (const CStyleCastExpr *CCast = dyn_cast<CStyleCastExpr>(E)) {\n        // If there's already a cast present, just replace it.\n        SourceRange CastRange(CCast->getLParenLoc(), CCast->getRParenLoc());\n        Hints.push_back(FixItHint::CreateReplacement(CastRange, CastFix.str()));\n\n      } else if (!requiresParensToAddCast(E)) {\n        // If the expression has high enough precedence,\n        // just write the C-style cast.\n        Hints.push_back(\n            FixItHint::CreateInsertion(E->getBeginLoc(), CastFix.str()));\n      } else {\n        // Otherwise, add parens around the expression as well as the cast.\n        CastFix << \"(\";\n        Hints.push_back(\n            FixItHint::CreateInsertion(E->getBeginLoc(), CastFix.str()));\n\n        SourceLocation After = S.getLocForEndOfToken(E->getEndLoc());\n        Hints.push_back(FixItHint::CreateInsertion(After, \")\"));\n      }\n\n      if (ShouldNotPrintDirectly) {\n        // The expression has a type that should not be printed directly.\n        // We extract the name from the typedef because we don't want to show\n        // the underlying type in the diagnostic.\n        StringRef Name;\n        if (const TypedefType *TypedefTy = dyn_cast<TypedefType>(ExprTy))\n          Name = TypedefTy->getDecl()->getName();\n        else\n          Name = CastTyName;\n        unsigned Diag = Match == ArgType::NoMatchPedantic\n                            ? diag::warn_format_argument_needs_cast_pedantic\n                            : diag::warn_format_argument_needs_cast;\n        EmitFormatDiagnostic(S.PDiag(Diag) << Name << IntendedTy << IsEnum\n                                           << E->getSourceRange(),\n                             E->getBeginLoc(), /*IsStringLocation=*/false,\n                             SpecRange, Hints);\n      } else {\n        // In this case, the expression could be printed using a different\n        // specifier, but we've decided that the specifier is probably correct\n        // and we should cast instead. Just use the normal warning message.\n        EmitFormatDiagnostic(\n            S.PDiag(diag::warn_format_conversion_argument_type_mismatch)\n                << AT.getRepresentativeTypeName(S.Context) << ExprTy << IsEnum\n                << E->getSourceRange(),\n            E->getBeginLoc(), /*IsStringLocation*/ false, SpecRange, Hints);\n      }\n    }\n  } else {\n    const CharSourceRange &CSR = getSpecifierRange(StartSpecifier,\n                                                   SpecifierLen);\n    // Since the warning for passing non-POD types to variadic functions\n    // was deferred until now, we emit a warning for non-POD\n    // arguments here.\n    switch (S.isValidVarArgType(ExprTy)) {\n    case Sema::VAK_Valid:\n    case Sema::VAK_ValidInCXX11: {\n      unsigned Diag;\n      switch (Match) {\n      case ArgType::Match: llvm_unreachable(\"expected non-matching\");\n      case ArgType::NoMatchPedantic:\n        Diag = diag::warn_format_conversion_argument_type_mismatch_pedantic;\n        break;\n      case ArgType::NoMatchTypeConfusion:\n        Diag = diag::warn_format_conversion_argument_type_mismatch_confusion;\n        break;\n      case ArgType::NoMatch:\n        Diag = diag::warn_format_conversion_argument_type_mismatch;\n        break;\n      }\n\n      EmitFormatDiagnostic(\n          S.PDiag(Diag) << AT.getRepresentativeTypeName(S.Context) << ExprTy\n                        << IsEnum << CSR << E->getSourceRange(),\n          E->getBeginLoc(), /*IsStringLocation*/ false, CSR);\n      break;\n    }\n    case Sema::VAK_Undefined:\n    case Sema::VAK_MSVCUndefined:\n      EmitFormatDiagnostic(S.PDiag(diag::warn_non_pod_vararg_with_format_string)\n                               << S.getLangOpts().CPlusPlus11 << ExprTy\n                               << CallType\n                               << AT.getRepresentativeTypeName(S.Context) << CSR\n                               << E->getSourceRange(),\n                           E->getBeginLoc(), /*IsStringLocation*/ false, CSR);\n      checkForCStrMembers(AT, E);\n      break;\n\n    case Sema::VAK_Invalid:\n      if (ExprTy->isObjCObjectType())\n        EmitFormatDiagnostic(\n            S.PDiag(diag::err_cannot_pass_objc_interface_to_vararg_format)\n                << S.getLangOpts().CPlusPlus11 << ExprTy << CallType\n                << AT.getRepresentativeTypeName(S.Context) << CSR\n                << E->getSourceRange(),\n            E->getBeginLoc(), /*IsStringLocation*/ false, CSR);\n      else\n        // FIXME: If this is an initializer list, suggest removing the braces\n        // or inserting a cast to the target type.\n        S.Diag(E->getBeginLoc(), diag::err_cannot_pass_to_vararg_format)\n            << isa<InitListExpr>(E) << ExprTy << CallType\n            << AT.getRepresentativeTypeName(S.Context) << E->getSourceRange();\n      break;\n    }\n\n    assert(FirstDataArg + FS.getArgIndex() < CheckedVarArgs.size() &&\n           \"format string specifier index out of range\");\n    CheckedVarArgs[FirstDataArg + FS.getArgIndex()] = true;\n  }\n\n  return true;\n}\n\n//===--- CHECK: Scanf format string checking ------------------------------===//\n\nnamespace {\n\nclass CheckScanfHandler : public CheckFormatHandler {\npublic:\n  CheckScanfHandler(Sema &s, const FormatStringLiteral *fexpr,\n                    const Expr *origFormatExpr, Sema::FormatStringType type,\n                    unsigned firstDataArg, unsigned numDataArgs,\n                    const char *beg, bool hasVAListArg,\n                    ArrayRef<const Expr *> Args, unsigned formatIdx,\n                    bool inFunctionCall, Sema::VariadicCallType CallType,\n                    llvm::SmallBitVector &CheckedVarArgs,\n                    UncoveredArgHandler &UncoveredArg)\n      : CheckFormatHandler(s, fexpr, origFormatExpr, type, firstDataArg,\n                           numDataArgs, beg, hasVAListArg, Args, formatIdx,\n                           inFunctionCall, CallType, CheckedVarArgs,\n                           UncoveredArg) {}\n\n  bool HandleScanfSpecifier(const analyze_scanf::ScanfSpecifier &FS,\n                            const char *startSpecifier,\n                            unsigned specifierLen) override;\n\n  bool HandleInvalidScanfConversionSpecifier(\n          const analyze_scanf::ScanfSpecifier &FS,\n          const char *startSpecifier,\n          unsigned specifierLen) override;\n\n  void HandleIncompleteScanList(const char *start, const char *end) override;\n};\n\n} // namespace\n\nvoid CheckScanfHandler::HandleIncompleteScanList(const char *start,\n                                                 const char *end) {\n  EmitFormatDiagnostic(S.PDiag(diag::warn_scanf_scanlist_incomplete),\n                       getLocationOfByte(end), /*IsStringLocation*/true,\n                       getSpecifierRange(start, end - start));\n}\n\nbool CheckScanfHandler::HandleInvalidScanfConversionSpecifier(\n                                        const analyze_scanf::ScanfSpecifier &FS,\n                                        const char *startSpecifier,\n                                        unsigned specifierLen) {\n  const analyze_scanf::ScanfConversionSpecifier &CS =\n    FS.getConversionSpecifier();\n\n  return HandleInvalidConversionSpecifier(FS.getArgIndex(),\n                                          getLocationOfByte(CS.getStart()),\n                                          startSpecifier, specifierLen,\n                                          CS.getStart(), CS.getLength());\n}\n\nbool CheckScanfHandler::HandleScanfSpecifier(\n                                       const analyze_scanf::ScanfSpecifier &FS,\n                                       const char *startSpecifier,\n                                       unsigned specifierLen) {\n  using namespace analyze_scanf;\n  using namespace analyze_format_string;\n\n  const ScanfConversionSpecifier &CS = FS.getConversionSpecifier();\n\n  // Handle case where '%' and '*' don't consume an argument.  These shouldn't\n  // be used to decide if we are using positional arguments consistently.\n  if (FS.consumesDataArgument()) {\n    if (atFirstArg) {\n      atFirstArg = false;\n      usesPositionalArgs = FS.usesPositionalArg();\n    }\n    else if (usesPositionalArgs != FS.usesPositionalArg()) {\n      HandlePositionalNonpositionalArgs(getLocationOfByte(CS.getStart()),\n                                        startSpecifier, specifierLen);\n      return false;\n    }\n  }\n\n  // Check if the field with is non-zero.\n  const OptionalAmount &Amt = FS.getFieldWidth();\n  if (Amt.getHowSpecified() == OptionalAmount::Constant) {\n    if (Amt.getConstantAmount() == 0) {\n      const CharSourceRange &R = getSpecifierRange(Amt.getStart(),\n                                                   Amt.getConstantLength());\n      EmitFormatDiagnostic(S.PDiag(diag::warn_scanf_nonzero_width),\n                           getLocationOfByte(Amt.getStart()),\n                           /*IsStringLocation*/true, R,\n                           FixItHint::CreateRemoval(R));\n    }\n  }\n\n  if (!FS.consumesDataArgument()) {\n    // FIXME: Technically specifying a precision or field width here\n    // makes no sense.  Worth issuing a warning at some point.\n    return true;\n  }\n\n  // Consume the argument.\n  unsigned argIndex = FS.getArgIndex();\n  if (argIndex < NumDataArgs) {\n      // The check to see if the argIndex is valid will come later.\n      // We set the bit here because we may exit early from this\n      // function if we encounter some other error.\n    CoveredArgs.set(argIndex);\n  }\n\n  // Check the length modifier is valid with the given conversion specifier.\n  if (!FS.hasValidLengthModifier(S.getASTContext().getTargetInfo(),\n                                 S.getLangOpts()))\n    HandleInvalidLengthModifier(FS, CS, startSpecifier, specifierLen,\n                                diag::warn_format_nonsensical_length);\n  else if (!FS.hasStandardLengthModifier())\n    HandleNonStandardLengthModifier(FS, startSpecifier, specifierLen);\n  else if (!FS.hasStandardLengthConversionCombination())\n    HandleInvalidLengthModifier(FS, CS, startSpecifier, specifierLen,\n                                diag::warn_format_non_standard_conversion_spec);\n\n  if (!FS.hasStandardConversionSpecifier(S.getLangOpts()))\n    HandleNonStandardConversionSpecifier(CS, startSpecifier, specifierLen);\n\n  // The remaining checks depend on the data arguments.\n  if (HasVAListArg)\n    return true;\n\n  if (!CheckNumArgs(FS, CS, startSpecifier, specifierLen, argIndex))\n    return false;\n\n  // Check that the argument type matches the format specifier.\n  const Expr *Ex = getDataArg(argIndex);\n  if (!Ex)\n    return true;\n\n  const analyze_format_string::ArgType &AT = FS.getArgType(S.Context);\n\n  if (!AT.isValid()) {\n    return true;\n  }\n\n  analyze_format_string::ArgType::MatchKind Match =\n      AT.matchesType(S.Context, Ex->getType());\n  bool Pedantic = Match == analyze_format_string::ArgType::NoMatchPedantic;\n  if (Match == analyze_format_string::ArgType::Match)\n    return true;\n\n  ScanfSpecifier fixedFS = FS;\n  bool Success = fixedFS.fixType(Ex->getType(), Ex->IgnoreImpCasts()->getType(),\n                                 S.getLangOpts(), S.Context);\n\n  unsigned Diag =\n      Pedantic ? diag::warn_format_conversion_argument_type_mismatch_pedantic\n               : diag::warn_format_conversion_argument_type_mismatch;\n\n  if (Success) {\n    // Get the fix string from the fixed format specifier.\n    SmallString<128> buf;\n    llvm::raw_svector_ostream os(buf);\n    fixedFS.toString(os);\n\n    EmitFormatDiagnostic(\n        S.PDiag(Diag) << AT.getRepresentativeTypeName(S.Context)\n                      << Ex->getType() << false << Ex->getSourceRange(),\n        Ex->getBeginLoc(),\n        /*IsStringLocation*/ false,\n        getSpecifierRange(startSpecifier, specifierLen),\n        FixItHint::CreateReplacement(\n            getSpecifierRange(startSpecifier, specifierLen), os.str()));\n  } else {\n    EmitFormatDiagnostic(S.PDiag(Diag)\n                             << AT.getRepresentativeTypeName(S.Context)\n                             << Ex->getType() << false << Ex->getSourceRange(),\n                         Ex->getBeginLoc(),\n                         /*IsStringLocation*/ false,\n                         getSpecifierRange(startSpecifier, specifierLen));\n  }\n\n  return true;\n}\n\nstatic void CheckFormatString(Sema &S, const FormatStringLiteral *FExpr,\n                              const Expr *OrigFormatExpr,\n                              ArrayRef<const Expr *> Args,\n                              bool HasVAListArg, unsigned format_idx,\n                              unsigned firstDataArg,\n                              Sema::FormatStringType Type,\n                              bool inFunctionCall,\n                              Sema::VariadicCallType CallType,\n                              llvm::SmallBitVector &CheckedVarArgs,\n                              UncoveredArgHandler &UncoveredArg,\n                              bool IgnoreStringsWithoutSpecifiers) {\n  // CHECK: is the format string a wide literal?\n  if (!FExpr->isAscii() && !FExpr->isUTF8()) {\n    CheckFormatHandler::EmitFormatDiagnostic(\n        S, inFunctionCall, Args[format_idx],\n        S.PDiag(diag::warn_format_string_is_wide_literal), FExpr->getBeginLoc(),\n        /*IsStringLocation*/ true, OrigFormatExpr->getSourceRange());\n    return;\n  }\n\n  // Str - The format string.  NOTE: this is NOT null-terminated!\n  StringRef StrRef = FExpr->getString();\n  const char *Str = StrRef.data();\n  // Account for cases where the string literal is truncated in a declaration.\n  const ConstantArrayType *T =\n    S.Context.getAsConstantArrayType(FExpr->getType());\n  assert(T && \"String literal not of constant array type!\");\n  size_t TypeSize = T->getSize().getZExtValue();\n  size_t StrLen = std::min(std::max(TypeSize, size_t(1)) - 1, StrRef.size());\n  const unsigned numDataArgs = Args.size() - firstDataArg;\n\n  if (IgnoreStringsWithoutSpecifiers &&\n      !analyze_format_string::parseFormatStringHasFormattingSpecifiers(\n          Str, Str + StrLen, S.getLangOpts(), S.Context.getTargetInfo()))\n    return;\n\n  // Emit a warning if the string literal is truncated and does not contain an\n  // embedded null character.\n  if (TypeSize <= StrRef.size() &&\n      StrRef.substr(0, TypeSize).find('\\0') == StringRef::npos) {\n    CheckFormatHandler::EmitFormatDiagnostic(\n        S, inFunctionCall, Args[format_idx],\n        S.PDiag(diag::warn_printf_format_string_not_null_terminated),\n        FExpr->getBeginLoc(),\n        /*IsStringLocation=*/true, OrigFormatExpr->getSourceRange());\n    return;\n  }\n\n  // CHECK: empty format string?\n  if (StrLen == 0 && numDataArgs > 0) {\n    CheckFormatHandler::EmitFormatDiagnostic(\n        S, inFunctionCall, Args[format_idx],\n        S.PDiag(diag::warn_empty_format_string), FExpr->getBeginLoc(),\n        /*IsStringLocation*/ true, OrigFormatExpr->getSourceRange());\n    return;\n  }\n\n  if (Type == Sema::FST_Printf || Type == Sema::FST_NSString ||\n      Type == Sema::FST_FreeBSDKPrintf || Type == Sema::FST_OSLog ||\n      Type == Sema::FST_OSTrace) {\n    CheckPrintfHandler H(\n        S, FExpr, OrigFormatExpr, Type, firstDataArg, numDataArgs,\n        (Type == Sema::FST_NSString || Type == Sema::FST_OSTrace), Str,\n        HasVAListArg, Args, format_idx, inFunctionCall, CallType,\n        CheckedVarArgs, UncoveredArg);\n\n    if (!analyze_format_string::ParsePrintfString(H, Str, Str + StrLen,\n                                                  S.getLangOpts(),\n                                                  S.Context.getTargetInfo(),\n                                            Type == Sema::FST_FreeBSDKPrintf))\n      H.DoneProcessing();\n  } else if (Type == Sema::FST_Scanf) {\n    CheckScanfHandler H(S, FExpr, OrigFormatExpr, Type, firstDataArg,\n                        numDataArgs, Str, HasVAListArg, Args, format_idx,\n                        inFunctionCall, CallType, CheckedVarArgs, UncoveredArg);\n\n    if (!analyze_format_string::ParseScanfString(H, Str, Str + StrLen,\n                                                 S.getLangOpts(),\n                                                 S.Context.getTargetInfo()))\n      H.DoneProcessing();\n  } // TODO: handle other formats\n}\n\nbool Sema::FormatStringHasSArg(const StringLiteral *FExpr) {\n  // Str - The format string.  NOTE: this is NOT null-terminated!\n  StringRef StrRef = FExpr->getString();\n  const char *Str = StrRef.data();\n  // Account for cases where the string literal is truncated in a declaration.\n  const ConstantArrayType *T = Context.getAsConstantArrayType(FExpr->getType());\n  assert(T && \"String literal not of constant array type!\");\n  size_t TypeSize = T->getSize().getZExtValue();\n  size_t StrLen = std::min(std::max(TypeSize, size_t(1)) - 1, StrRef.size());\n  return analyze_format_string::ParseFormatStringHasSArg(Str, Str + StrLen,\n                                                         getLangOpts(),\n                                                         Context.getTargetInfo());\n}\n\n//===--- CHECK: Warn on use of wrong absolute value function. -------------===//\n\n// Returns the related absolute value function that is larger, of 0 if one\n// does not exist.\nstatic unsigned getLargerAbsoluteValueFunction(unsigned AbsFunction) {\n  switch (AbsFunction) {\n  default:\n    return 0;\n\n  case Builtin::BI__builtin_abs:\n    return Builtin::BI__builtin_labs;\n  case Builtin::BI__builtin_labs:\n    return Builtin::BI__builtin_llabs;\n  case Builtin::BI__builtin_llabs:\n    return 0;\n\n  case Builtin::BI__builtin_fabsf:\n    return Builtin::BI__builtin_fabs;\n  case Builtin::BI__builtin_fabs:\n    return Builtin::BI__builtin_fabsl;\n  case Builtin::BI__builtin_fabsl:\n    return 0;\n\n  case Builtin::BI__builtin_cabsf:\n    return Builtin::BI__builtin_cabs;\n  case Builtin::BI__builtin_cabs:\n    return Builtin::BI__builtin_cabsl;\n  case Builtin::BI__builtin_cabsl:\n    return 0;\n\n  case Builtin::BIabs:\n    return Builtin::BIlabs;\n  case Builtin::BIlabs:\n    return Builtin::BIllabs;\n  case Builtin::BIllabs:\n    return 0;\n\n  case Builtin::BIfabsf:\n    return Builtin::BIfabs;\n  case Builtin::BIfabs:\n    return Builtin::BIfabsl;\n  case Builtin::BIfabsl:\n    return 0;\n\n  case Builtin::BIcabsf:\n   return Builtin::BIcabs;\n  case Builtin::BIcabs:\n    return Builtin::BIcabsl;\n  case Builtin::BIcabsl:\n    return 0;\n  }\n}\n\n// Returns the argument type of the absolute value function.\nstatic QualType getAbsoluteValueArgumentType(ASTContext &Context,\n                                             unsigned AbsType) {\n  if (AbsType == 0)\n    return QualType();\n\n  ASTContext::GetBuiltinTypeError Error = ASTContext::GE_None;\n  QualType BuiltinType = Context.GetBuiltinType(AbsType, Error);\n  if (Error != ASTContext::GE_None)\n    return QualType();\n\n  const FunctionProtoType *FT = BuiltinType->getAs<FunctionProtoType>();\n  if (!FT)\n    return QualType();\n\n  if (FT->getNumParams() != 1)\n    return QualType();\n\n  return FT->getParamType(0);\n}\n\n// Returns the best absolute value function, or zero, based on type and\n// current absolute value function.\nstatic unsigned getBestAbsFunction(ASTContext &Context, QualType ArgType,\n                                   unsigned AbsFunctionKind) {\n  unsigned BestKind = 0;\n  uint64_t ArgSize = Context.getTypeSize(ArgType);\n  for (unsigned Kind = AbsFunctionKind; Kind != 0;\n       Kind = getLargerAbsoluteValueFunction(Kind)) {\n    QualType ParamType = getAbsoluteValueArgumentType(Context, Kind);\n    if (Context.getTypeSize(ParamType) >= ArgSize) {\n      if (BestKind == 0)\n        BestKind = Kind;\n      else if (Context.hasSameType(ParamType, ArgType)) {\n        BestKind = Kind;\n        break;\n      }\n    }\n  }\n  return BestKind;\n}\n\nenum AbsoluteValueKind {\n  AVK_Integer,\n  AVK_Floating,\n  AVK_Complex\n};\n\nstatic AbsoluteValueKind getAbsoluteValueKind(QualType T) {\n  if (T->isIntegralOrEnumerationType())\n    return AVK_Integer;\n  if (T->isRealFloatingType())\n    return AVK_Floating;\n  if (T->isAnyComplexType())\n    return AVK_Complex;\n\n  llvm_unreachable(\"Type not integer, floating, or complex\");\n}\n\n// Changes the absolute value function to a different type.  Preserves whether\n// the function is a builtin.\nstatic unsigned changeAbsFunction(unsigned AbsKind,\n                                  AbsoluteValueKind ValueKind) {\n  switch (ValueKind) {\n  case AVK_Integer:\n    switch (AbsKind) {\n    default:\n      return 0;\n    case Builtin::BI__builtin_fabsf:\n    case Builtin::BI__builtin_fabs:\n    case Builtin::BI__builtin_fabsl:\n    case Builtin::BI__builtin_cabsf:\n    case Builtin::BI__builtin_cabs:\n    case Builtin::BI__builtin_cabsl:\n      return Builtin::BI__builtin_abs;\n    case Builtin::BIfabsf:\n    case Builtin::BIfabs:\n    case Builtin::BIfabsl:\n    case Builtin::BIcabsf:\n    case Builtin::BIcabs:\n    case Builtin::BIcabsl:\n      return Builtin::BIabs;\n    }\n  case AVK_Floating:\n    switch (AbsKind) {\n    default:\n      return 0;\n    case Builtin::BI__builtin_abs:\n    case Builtin::BI__builtin_labs:\n    case Builtin::BI__builtin_llabs:\n    case Builtin::BI__builtin_cabsf:\n    case Builtin::BI__builtin_cabs:\n    case Builtin::BI__builtin_cabsl:\n      return Builtin::BI__builtin_fabsf;\n    case Builtin::BIabs:\n    case Builtin::BIlabs:\n    case Builtin::BIllabs:\n    case Builtin::BIcabsf:\n    case Builtin::BIcabs:\n    case Builtin::BIcabsl:\n      return Builtin::BIfabsf;\n    }\n  case AVK_Complex:\n    switch (AbsKind) {\n    default:\n      return 0;\n    case Builtin::BI__builtin_abs:\n    case Builtin::BI__builtin_labs:\n    case Builtin::BI__builtin_llabs:\n    case Builtin::BI__builtin_fabsf:\n    case Builtin::BI__builtin_fabs:\n    case Builtin::BI__builtin_fabsl:\n      return Builtin::BI__builtin_cabsf;\n    case Builtin::BIabs:\n    case Builtin::BIlabs:\n    case Builtin::BIllabs:\n    case Builtin::BIfabsf:\n    case Builtin::BIfabs:\n    case Builtin::BIfabsl:\n      return Builtin::BIcabsf;\n    }\n  }\n  llvm_unreachable(\"Unable to convert function\");\n}\n\nstatic unsigned getAbsoluteValueFunctionKind(const FunctionDecl *FDecl) {\n  const IdentifierInfo *FnInfo = FDecl->getIdentifier();\n  if (!FnInfo)\n    return 0;\n\n  switch (FDecl->getBuiltinID()) {\n  default:\n    return 0;\n  case Builtin::BI__builtin_abs:\n  case Builtin::BI__builtin_fabs:\n  case Builtin::BI__builtin_fabsf:\n  case Builtin::BI__builtin_fabsl:\n  case Builtin::BI__builtin_labs:\n  case Builtin::BI__builtin_llabs:\n  case Builtin::BI__builtin_cabs:\n  case Builtin::BI__builtin_cabsf:\n  case Builtin::BI__builtin_cabsl:\n  case Builtin::BIabs:\n  case Builtin::BIlabs:\n  case Builtin::BIllabs:\n  case Builtin::BIfabs:\n  case Builtin::BIfabsf:\n  case Builtin::BIfabsl:\n  case Builtin::BIcabs:\n  case Builtin::BIcabsf:\n  case Builtin::BIcabsl:\n    return FDecl->getBuiltinID();\n  }\n  llvm_unreachable(\"Unknown Builtin type\");\n}\n\n// If the replacement is valid, emit a note with replacement function.\n// Additionally, suggest including the proper header if not already included.\nstatic void emitReplacement(Sema &S, SourceLocation Loc, SourceRange Range,\n                            unsigned AbsKind, QualType ArgType) {\n  bool EmitHeaderHint = true;\n  const char *HeaderName = nullptr;\n  const char *FunctionName = nullptr;\n  if (S.getLangOpts().CPlusPlus && !ArgType->isAnyComplexType()) {\n    FunctionName = \"std::abs\";\n    if (ArgType->isIntegralOrEnumerationType()) {\n      HeaderName = \"cstdlib\";\n    } else if (ArgType->isRealFloatingType()) {\n      HeaderName = \"cmath\";\n    } else {\n      llvm_unreachable(\"Invalid Type\");\n    }\n\n    // Lookup all std::abs\n    if (NamespaceDecl *Std = S.getStdNamespace()) {\n      LookupResult R(S, &S.Context.Idents.get(\"abs\"), Loc, Sema::LookupAnyName);\n      R.suppressDiagnostics();\n      S.LookupQualifiedName(R, Std);\n\n      for (const auto *I : R) {\n        const FunctionDecl *FDecl = nullptr;\n        if (const UsingShadowDecl *UsingD = dyn_cast<UsingShadowDecl>(I)) {\n          FDecl = dyn_cast<FunctionDecl>(UsingD->getTargetDecl());\n        } else {\n          FDecl = dyn_cast<FunctionDecl>(I);\n        }\n        if (!FDecl)\n          continue;\n\n        // Found std::abs(), check that they are the right ones.\n        if (FDecl->getNumParams() != 1)\n          continue;\n\n        // Check that the parameter type can handle the argument.\n        QualType ParamType = FDecl->getParamDecl(0)->getType();\n        if (getAbsoluteValueKind(ArgType) == getAbsoluteValueKind(ParamType) &&\n            S.Context.getTypeSize(ArgType) <=\n                S.Context.getTypeSize(ParamType)) {\n          // Found a function, don't need the header hint.\n          EmitHeaderHint = false;\n          break;\n        }\n      }\n    }\n  } else {\n    FunctionName = S.Context.BuiltinInfo.getName(AbsKind);\n    HeaderName = S.Context.BuiltinInfo.getHeaderName(AbsKind);\n\n    if (HeaderName) {\n      DeclarationName DN(&S.Context.Idents.get(FunctionName));\n      LookupResult R(S, DN, Loc, Sema::LookupAnyName);\n      R.suppressDiagnostics();\n      S.LookupName(R, S.getCurScope());\n\n      if (R.isSingleResult()) {\n        FunctionDecl *FD = dyn_cast<FunctionDecl>(R.getFoundDecl());\n        if (FD && FD->getBuiltinID() == AbsKind) {\n          EmitHeaderHint = false;\n        } else {\n          return;\n        }\n      } else if (!R.empty()) {\n        return;\n      }\n    }\n  }\n\n  S.Diag(Loc, diag::note_replace_abs_function)\n      << FunctionName << FixItHint::CreateReplacement(Range, FunctionName);\n\n  if (!HeaderName)\n    return;\n\n  if (!EmitHeaderHint)\n    return;\n\n  S.Diag(Loc, diag::note_include_header_or_declare) << HeaderName\n                                                    << FunctionName;\n}\n\ntemplate <std::size_t StrLen>\nstatic bool IsStdFunction(const FunctionDecl *FDecl,\n                          const char (&Str)[StrLen]) {\n  if (!FDecl)\n    return false;\n  if (!FDecl->getIdentifier() || !FDecl->getIdentifier()->isStr(Str))\n    return false;\n  if (!FDecl->isInStdNamespace())\n    return false;\n\n  return true;\n}\n\n// Warn when using the wrong abs() function.\nvoid Sema::CheckAbsoluteValueFunction(const CallExpr *Call,\n                                      const FunctionDecl *FDecl) {\n  if (Call->getNumArgs() != 1)\n    return;\n\n  unsigned AbsKind = getAbsoluteValueFunctionKind(FDecl);\n  bool IsStdAbs = IsStdFunction(FDecl, \"abs\");\n  if (AbsKind == 0 && !IsStdAbs)\n    return;\n\n  QualType ArgType = Call->getArg(0)->IgnoreParenImpCasts()->getType();\n  QualType ParamType = Call->getArg(0)->getType();\n\n  // Unsigned types cannot be negative.  Suggest removing the absolute value\n  // function call.\n  if (ArgType->isUnsignedIntegerType()) {\n    const char *FunctionName =\n        IsStdAbs ? \"std::abs\" : Context.BuiltinInfo.getName(AbsKind);\n    Diag(Call->getExprLoc(), diag::warn_unsigned_abs) << ArgType << ParamType;\n    Diag(Call->getExprLoc(), diag::note_remove_abs)\n        << FunctionName\n        << FixItHint::CreateRemoval(Call->getCallee()->getSourceRange());\n    return;\n  }\n\n  // Taking the absolute value of a pointer is very suspicious, they probably\n  // wanted to index into an array, dereference a pointer, call a function, etc.\n  if (ArgType->isPointerType() || ArgType->canDecayToPointerType()) {\n    unsigned DiagType = 0;\n    if (ArgType->isFunctionType())\n      DiagType = 1;\n    else if (ArgType->isArrayType())\n      DiagType = 2;\n\n    Diag(Call->getExprLoc(), diag::warn_pointer_abs) << DiagType << ArgType;\n    return;\n  }\n\n  // std::abs has overloads which prevent most of the absolute value problems\n  // from occurring.\n  if (IsStdAbs)\n    return;\n\n  AbsoluteValueKind ArgValueKind = getAbsoluteValueKind(ArgType);\n  AbsoluteValueKind ParamValueKind = getAbsoluteValueKind(ParamType);\n\n  // The argument and parameter are the same kind.  Check if they are the right\n  // size.\n  if (ArgValueKind == ParamValueKind) {\n    if (Context.getTypeSize(ArgType) <= Context.getTypeSize(ParamType))\n      return;\n\n    unsigned NewAbsKind = getBestAbsFunction(Context, ArgType, AbsKind);\n    Diag(Call->getExprLoc(), diag::warn_abs_too_small)\n        << FDecl << ArgType << ParamType;\n\n    if (NewAbsKind == 0)\n      return;\n\n    emitReplacement(*this, Call->getExprLoc(),\n                    Call->getCallee()->getSourceRange(), NewAbsKind, ArgType);\n    return;\n  }\n\n  // ArgValueKind != ParamValueKind\n  // The wrong type of absolute value function was used.  Attempt to find the\n  // proper one.\n  unsigned NewAbsKind = changeAbsFunction(AbsKind, ArgValueKind);\n  NewAbsKind = getBestAbsFunction(Context, ArgType, NewAbsKind);\n  if (NewAbsKind == 0)\n    return;\n\n  Diag(Call->getExprLoc(), diag::warn_wrong_absolute_value_type)\n      << FDecl << ParamValueKind << ArgValueKind;\n\n  emitReplacement(*this, Call->getExprLoc(),\n                  Call->getCallee()->getSourceRange(), NewAbsKind, ArgType);\n}\n\n//===--- CHECK: Warn on use of std::max and unsigned zero. r---------------===//\nvoid Sema::CheckMaxUnsignedZero(const CallExpr *Call,\n                                const FunctionDecl *FDecl) {\n  if (!Call || !FDecl) return;\n\n  // Ignore template specializations and macros.\n  if (inTemplateInstantiation()) return;\n  if (Call->getExprLoc().isMacroID()) return;\n\n  // Only care about the one template argument, two function parameter std::max\n  if (Call->getNumArgs() != 2) return;\n  if (!IsStdFunction(FDecl, \"max\")) return;\n  const auto * ArgList = FDecl->getTemplateSpecializationArgs();\n  if (!ArgList) return;\n  if (ArgList->size() != 1) return;\n\n  // Check that template type argument is unsigned integer.\n  const auto& TA = ArgList->get(0);\n  if (TA.getKind() != TemplateArgument::Type) return;\n  QualType ArgType = TA.getAsType();\n  if (!ArgType->isUnsignedIntegerType()) return;\n\n  // See if either argument is a literal zero.\n  auto IsLiteralZeroArg = [](const Expr* E) -> bool {\n    const auto *MTE = dyn_cast<MaterializeTemporaryExpr>(E);\n    if (!MTE) return false;\n    const auto *Num = dyn_cast<IntegerLiteral>(MTE->getSubExpr());\n    if (!Num) return false;\n    if (Num->getValue() != 0) return false;\n    return true;\n  };\n\n  const Expr *FirstArg = Call->getArg(0);\n  const Expr *SecondArg = Call->getArg(1);\n  const bool IsFirstArgZero = IsLiteralZeroArg(FirstArg);\n  const bool IsSecondArgZero = IsLiteralZeroArg(SecondArg);\n\n  // Only warn when exactly one argument is zero.\n  if (IsFirstArgZero == IsSecondArgZero) return;\n\n  SourceRange FirstRange = FirstArg->getSourceRange();\n  SourceRange SecondRange = SecondArg->getSourceRange();\n\n  SourceRange ZeroRange = IsFirstArgZero ? FirstRange : SecondRange;\n\n  Diag(Call->getExprLoc(), diag::warn_max_unsigned_zero)\n      << IsFirstArgZero << Call->getCallee()->getSourceRange() << ZeroRange;\n\n  // Deduce what parts to remove so that \"std::max(0u, foo)\" becomes \"(foo)\".\n  SourceRange RemovalRange;\n  if (IsFirstArgZero) {\n    RemovalRange = SourceRange(FirstRange.getBegin(),\n                               SecondRange.getBegin().getLocWithOffset(-1));\n  } else {\n    RemovalRange = SourceRange(getLocForEndOfToken(FirstRange.getEnd()),\n                               SecondRange.getEnd());\n  }\n\n  Diag(Call->getExprLoc(), diag::note_remove_max_call)\n        << FixItHint::CreateRemoval(Call->getCallee()->getSourceRange())\n        << FixItHint::CreateRemoval(RemovalRange);\n}\n\n//===--- CHECK: Standard memory functions ---------------------------------===//\n\n/// Takes the expression passed to the size_t parameter of functions\n/// such as memcmp, strncat, etc and warns if it's a comparison.\n///\n/// This is to catch typos like `if (memcmp(&a, &b, sizeof(a) > 0))`.\nstatic bool CheckMemorySizeofForComparison(Sema &S, const Expr *E,\n                                           IdentifierInfo *FnName,\n                                           SourceLocation FnLoc,\n                                           SourceLocation RParenLoc) {\n  const BinaryOperator *Size = dyn_cast<BinaryOperator>(E);\n  if (!Size)\n    return false;\n\n  // if E is binop and op is <=>, >, <, >=, <=, ==, &&, ||:\n  if (!Size->isComparisonOp() && !Size->isLogicalOp())\n    return false;\n\n  SourceRange SizeRange = Size->getSourceRange();\n  S.Diag(Size->getOperatorLoc(), diag::warn_memsize_comparison)\n      << SizeRange << FnName;\n  S.Diag(FnLoc, diag::note_memsize_comparison_paren)\n      << FnName\n      << FixItHint::CreateInsertion(\n             S.getLocForEndOfToken(Size->getLHS()->getEndLoc()), \")\")\n      << FixItHint::CreateRemoval(RParenLoc);\n  S.Diag(SizeRange.getBegin(), diag::note_memsize_comparison_cast_silence)\n      << FixItHint::CreateInsertion(SizeRange.getBegin(), \"(size_t)(\")\n      << FixItHint::CreateInsertion(S.getLocForEndOfToken(SizeRange.getEnd()),\n                                    \")\");\n\n  return true;\n}\n\n/// Determine whether the given type is or contains a dynamic class type\n/// (e.g., whether it has a vtable).\nstatic const CXXRecordDecl *getContainedDynamicClass(QualType T,\n                                                     bool &IsContained) {\n  // Look through array types while ignoring qualifiers.\n  const Type *Ty = T->getBaseElementTypeUnsafe();\n  IsContained = false;\n\n  const CXXRecordDecl *RD = Ty->getAsCXXRecordDecl();\n  RD = RD ? RD->getDefinition() : nullptr;\n  if (!RD || RD->isInvalidDecl())\n    return nullptr;\n\n  if (RD->isDynamicClass())\n    return RD;\n\n  // Check all the fields.  If any bases were dynamic, the class is dynamic.\n  // It's impossible for a class to transitively contain itself by value, so\n  // infinite recursion is impossible.\n  for (auto *FD : RD->fields()) {\n    bool SubContained;\n    if (const CXXRecordDecl *ContainedRD =\n            getContainedDynamicClass(FD->getType(), SubContained)) {\n      IsContained = true;\n      return ContainedRD;\n    }\n  }\n\n  return nullptr;\n}\n\nstatic const UnaryExprOrTypeTraitExpr *getAsSizeOfExpr(const Expr *E) {\n  if (const auto *Unary = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\n    if (Unary->getKind() == UETT_SizeOf)\n      return Unary;\n  return nullptr;\n}\n\n/// If E is a sizeof expression, returns its argument expression,\n/// otherwise returns NULL.\nstatic const Expr *getSizeOfExprArg(const Expr *E) {\n  if (const UnaryExprOrTypeTraitExpr *SizeOf = getAsSizeOfExpr(E))\n    if (!SizeOf->isArgumentType())\n      return SizeOf->getArgumentExpr()->IgnoreParenImpCasts();\n  return nullptr;\n}\n\n/// If E is a sizeof expression, returns its argument type.\nstatic QualType getSizeOfArgType(const Expr *E) {\n  if (const UnaryExprOrTypeTraitExpr *SizeOf = getAsSizeOfExpr(E))\n    return SizeOf->getTypeOfArgument();\n  return QualType();\n}\n\nnamespace {\n\nstruct SearchNonTrivialToInitializeField\n    : DefaultInitializedTypeVisitor<SearchNonTrivialToInitializeField> {\n  using Super =\n      DefaultInitializedTypeVisitor<SearchNonTrivialToInitializeField>;\n\n  SearchNonTrivialToInitializeField(const Expr *E, Sema &S) : E(E), S(S) {}\n\n  void visitWithKind(QualType::PrimitiveDefaultInitializeKind PDIK, QualType FT,\n                     SourceLocation SL) {\n    if (const auto *AT = asDerived().getContext().getAsArrayType(FT)) {\n      asDerived().visitArray(PDIK, AT, SL);\n      return;\n    }\n\n    Super::visitWithKind(PDIK, FT, SL);\n  }\n\n  void visitARCStrong(QualType FT, SourceLocation SL) {\n    S.DiagRuntimeBehavior(SL, E, S.PDiag(diag::note_nontrivial_field) << 1);\n  }\n  void visitARCWeak(QualType FT, SourceLocation SL) {\n    S.DiagRuntimeBehavior(SL, E, S.PDiag(diag::note_nontrivial_field) << 1);\n  }\n  void visitStruct(QualType FT, SourceLocation SL) {\n    for (const FieldDecl *FD : FT->castAs<RecordType>()->getDecl()->fields())\n      visit(FD->getType(), FD->getLocation());\n  }\n  void visitArray(QualType::PrimitiveDefaultInitializeKind PDIK,\n                  const ArrayType *AT, SourceLocation SL) {\n    visit(getContext().getBaseElementType(AT), SL);\n  }\n  void visitTrivial(QualType FT, SourceLocation SL) {}\n\n  static void diag(QualType RT, const Expr *E, Sema &S) {\n    SearchNonTrivialToInitializeField(E, S).visitStruct(RT, SourceLocation());\n  }\n\n  ASTContext &getContext() { return S.getASTContext(); }\n\n  const Expr *E;\n  Sema &S;\n};\n\nstruct SearchNonTrivialToCopyField\n    : CopiedTypeVisitor<SearchNonTrivialToCopyField, false> {\n  using Super = CopiedTypeVisitor<SearchNonTrivialToCopyField, false>;\n\n  SearchNonTrivialToCopyField(const Expr *E, Sema &S) : E(E), S(S) {}\n\n  void visitWithKind(QualType::PrimitiveCopyKind PCK, QualType FT,\n                     SourceLocation SL) {\n    if (const auto *AT = asDerived().getContext().getAsArrayType(FT)) {\n      asDerived().visitArray(PCK, AT, SL);\n      return;\n    }\n\n    Super::visitWithKind(PCK, FT, SL);\n  }\n\n  void visitARCStrong(QualType FT, SourceLocation SL) {\n    S.DiagRuntimeBehavior(SL, E, S.PDiag(diag::note_nontrivial_field) << 0);\n  }\n  void visitARCWeak(QualType FT, SourceLocation SL) {\n    S.DiagRuntimeBehavior(SL, E, S.PDiag(diag::note_nontrivial_field) << 0);\n  }\n  void visitStruct(QualType FT, SourceLocation SL) {\n    for (const FieldDecl *FD : FT->castAs<RecordType>()->getDecl()->fields())\n      visit(FD->getType(), FD->getLocation());\n  }\n  void visitArray(QualType::PrimitiveCopyKind PCK, const ArrayType *AT,\n                  SourceLocation SL) {\n    visit(getContext().getBaseElementType(AT), SL);\n  }\n  void preVisit(QualType::PrimitiveCopyKind PCK, QualType FT,\n                SourceLocation SL) {}\n  void visitTrivial(QualType FT, SourceLocation SL) {}\n  void visitVolatileTrivial(QualType FT, SourceLocation SL) {}\n\n  static void diag(QualType RT, const Expr *E, Sema &S) {\n    SearchNonTrivialToCopyField(E, S).visitStruct(RT, SourceLocation());\n  }\n\n  ASTContext &getContext() { return S.getASTContext(); }\n\n  const Expr *E;\n  Sema &S;\n};\n\n}\n\n/// Detect if \\c SizeofExpr is likely to calculate the sizeof an object.\nstatic bool doesExprLikelyComputeSize(const Expr *SizeofExpr) {\n  SizeofExpr = SizeofExpr->IgnoreParenImpCasts();\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(SizeofExpr)) {\n    if (BO->getOpcode() != BO_Mul && BO->getOpcode() != BO_Add)\n      return false;\n\n    return doesExprLikelyComputeSize(BO->getLHS()) ||\n           doesExprLikelyComputeSize(BO->getRHS());\n  }\n\n  return getAsSizeOfExpr(SizeofExpr) != nullptr;\n}\n\n/// Check if the ArgLoc originated from a macro passed to the call at CallLoc.\n///\n/// \\code\n///   #define MACRO 0\n///   foo(MACRO);\n///   foo(0);\n/// \\endcode\n///\n/// This should return true for the first call to foo, but not for the second\n/// (regardless of whether foo is a macro or function).\nstatic bool isArgumentExpandedFromMacro(SourceManager &SM,\n                                        SourceLocation CallLoc,\n                                        SourceLocation ArgLoc) {\n  if (!CallLoc.isMacroID())\n    return SM.getFileID(CallLoc) != SM.getFileID(ArgLoc);\n\n  return SM.getFileID(SM.getImmediateMacroCallerLoc(CallLoc)) !=\n         SM.getFileID(SM.getImmediateMacroCallerLoc(ArgLoc));\n}\n\n/// Diagnose cases like 'memset(buf, sizeof(buf), 0)', which should have the\n/// last two arguments transposed.\nstatic void CheckMemaccessSize(Sema &S, unsigned BId, const CallExpr *Call) {\n  if (BId != Builtin::BImemset && BId != Builtin::BIbzero)\n    return;\n\n  const Expr *SizeArg =\n    Call->getArg(BId == Builtin::BImemset ? 2 : 1)->IgnoreImpCasts();\n\n  auto isLiteralZero = [](const Expr *E) {\n    return isa<IntegerLiteral>(E) && cast<IntegerLiteral>(E)->getValue() == 0;\n  };\n\n  // If we're memsetting or bzeroing 0 bytes, then this is likely an error.\n  SourceLocation CallLoc = Call->getRParenLoc();\n  SourceManager &SM = S.getSourceManager();\n  if (isLiteralZero(SizeArg) &&\n      !isArgumentExpandedFromMacro(SM, CallLoc, SizeArg->getExprLoc())) {\n\n    SourceLocation DiagLoc = SizeArg->getExprLoc();\n\n    // Some platforms #define bzero to __builtin_memset. See if this is the\n    // case, and if so, emit a better diagnostic.\n    if (BId == Builtin::BIbzero ||\n        (CallLoc.isMacroID() && Lexer::getImmediateMacroName(\n                                    CallLoc, SM, S.getLangOpts()) == \"bzero\")) {\n      S.Diag(DiagLoc, diag::warn_suspicious_bzero_size);\n      S.Diag(DiagLoc, diag::note_suspicious_bzero_size_silence);\n    } else if (!isLiteralZero(Call->getArg(1)->IgnoreImpCasts())) {\n      S.Diag(DiagLoc, diag::warn_suspicious_sizeof_memset) << 0;\n      S.Diag(DiagLoc, diag::note_suspicious_sizeof_memset_silence) << 0;\n    }\n    return;\n  }\n\n  // If the second argument to a memset is a sizeof expression and the third\n  // isn't, this is also likely an error. This should catch\n  // 'memset(buf, sizeof(buf), 0xff)'.\n  if (BId == Builtin::BImemset &&\n      doesExprLikelyComputeSize(Call->getArg(1)) &&\n      !doesExprLikelyComputeSize(Call->getArg(2))) {\n    SourceLocation DiagLoc = Call->getArg(1)->getExprLoc();\n    S.Diag(DiagLoc, diag::warn_suspicious_sizeof_memset) << 1;\n    S.Diag(DiagLoc, diag::note_suspicious_sizeof_memset_silence) << 1;\n    return;\n  }\n}\n\n/// Check for dangerous or invalid arguments to memset().\n///\n/// This issues warnings on known problematic, dangerous or unspecified\n/// arguments to the standard 'memset', 'memcpy', 'memmove', and 'memcmp'\n/// function calls.\n///\n/// \\param Call The call expression to diagnose.\nvoid Sema::CheckMemaccessArguments(const CallExpr *Call,\n                                   unsigned BId,\n                                   IdentifierInfo *FnName) {\n  assert(BId != 0);\n\n  // It is possible to have a non-standard definition of memset.  Validate\n  // we have enough arguments, and if not, abort further checking.\n  unsigned ExpectedNumArgs =\n      (BId == Builtin::BIstrndup || BId == Builtin::BIbzero ? 2 : 3);\n  if (Call->getNumArgs() < ExpectedNumArgs)\n    return;\n\n  unsigned LastArg = (BId == Builtin::BImemset || BId == Builtin::BIbzero ||\n                      BId == Builtin::BIstrndup ? 1 : 2);\n  unsigned LenArg =\n      (BId == Builtin::BIbzero || BId == Builtin::BIstrndup ? 1 : 2);\n  const Expr *LenExpr = Call->getArg(LenArg)->IgnoreParenImpCasts();\n\n  if (CheckMemorySizeofForComparison(*this, LenExpr, FnName,\n                                     Call->getBeginLoc(), Call->getRParenLoc()))\n    return;\n\n  // Catch cases like 'memset(buf, sizeof(buf), 0)'.\n  CheckMemaccessSize(*this, BId, Call);\n\n  // We have special checking when the length is a sizeof expression.\n  QualType SizeOfArgTy = getSizeOfArgType(LenExpr);\n  const Expr *SizeOfArg = getSizeOfExprArg(LenExpr);\n  llvm::FoldingSetNodeID SizeOfArgID;\n\n  // Although widely used, 'bzero' is not a standard function. Be more strict\n  // with the argument types before allowing diagnostics and only allow the\n  // form bzero(ptr, sizeof(...)).\n  QualType FirstArgTy = Call->getArg(0)->IgnoreParenImpCasts()->getType();\n  if (BId == Builtin::BIbzero && !FirstArgTy->getAs<PointerType>())\n    return;\n\n  for (unsigned ArgIdx = 0; ArgIdx != LastArg; ++ArgIdx) {\n    const Expr *Dest = Call->getArg(ArgIdx)->IgnoreParenImpCasts();\n    SourceRange ArgRange = Call->getArg(ArgIdx)->getSourceRange();\n\n    QualType DestTy = Dest->getType();\n    QualType PointeeTy;\n    if (const PointerType *DestPtrTy = DestTy->getAs<PointerType>()) {\n      PointeeTy = DestPtrTy->getPointeeType();\n\n      // Never warn about void type pointers. This can be used to suppress\n      // false positives.\n      if (PointeeTy->isVoidType())\n        continue;\n\n      // Catch \"memset(p, 0, sizeof(p))\" -- needs to be sizeof(*p). Do this by\n      // actually comparing the expressions for equality. Because computing the\n      // expression IDs can be expensive, we only do this if the diagnostic is\n      // enabled.\n      if (SizeOfArg &&\n          !Diags.isIgnored(diag::warn_sizeof_pointer_expr_memaccess,\n                           SizeOfArg->getExprLoc())) {\n        // We only compute IDs for expressions if the warning is enabled, and\n        // cache the sizeof arg's ID.\n        if (SizeOfArgID == llvm::FoldingSetNodeID())\n          SizeOfArg->Profile(SizeOfArgID, Context, true);\n        llvm::FoldingSetNodeID DestID;\n        Dest->Profile(DestID, Context, true);\n        if (DestID == SizeOfArgID) {\n          // TODO: For strncpy() and friends, this could suggest sizeof(dst)\n          //       over sizeof(src) as well.\n          unsigned ActionIdx = 0; // Default is to suggest dereferencing.\n          StringRef ReadableName = FnName->getName();\n\n          if (const UnaryOperator *UnaryOp = dyn_cast<UnaryOperator>(Dest))\n            if (UnaryOp->getOpcode() == UO_AddrOf)\n              ActionIdx = 1; // If its an address-of operator, just remove it.\n          if (!PointeeTy->isIncompleteType() &&\n              (Context.getTypeSize(PointeeTy) == Context.getCharWidth()))\n            ActionIdx = 2; // If the pointee's size is sizeof(char),\n                           // suggest an explicit length.\n\n          // If the function is defined as a builtin macro, do not show macro\n          // expansion.\n          SourceLocation SL = SizeOfArg->getExprLoc();\n          SourceRange DSR = Dest->getSourceRange();\n          SourceRange SSR = SizeOfArg->getSourceRange();\n          SourceManager &SM = getSourceManager();\n\n          if (SM.isMacroArgExpansion(SL)) {\n            ReadableName = Lexer::getImmediateMacroName(SL, SM, LangOpts);\n            SL = SM.getSpellingLoc(SL);\n            DSR = SourceRange(SM.getSpellingLoc(DSR.getBegin()),\n                             SM.getSpellingLoc(DSR.getEnd()));\n            SSR = SourceRange(SM.getSpellingLoc(SSR.getBegin()),\n                             SM.getSpellingLoc(SSR.getEnd()));\n          }\n\n          DiagRuntimeBehavior(SL, SizeOfArg,\n                              PDiag(diag::warn_sizeof_pointer_expr_memaccess)\n                                << ReadableName\n                                << PointeeTy\n                                << DestTy\n                                << DSR\n                                << SSR);\n          DiagRuntimeBehavior(SL, SizeOfArg,\n                         PDiag(diag::warn_sizeof_pointer_expr_memaccess_note)\n                                << ActionIdx\n                                << SSR);\n\n          break;\n        }\n      }\n\n      // Also check for cases where the sizeof argument is the exact same\n      // type as the memory argument, and where it points to a user-defined\n      // record type.\n      if (SizeOfArgTy != QualType()) {\n        if (PointeeTy->isRecordType() &&\n            Context.typesAreCompatible(SizeOfArgTy, DestTy)) {\n          DiagRuntimeBehavior(LenExpr->getExprLoc(), Dest,\n                              PDiag(diag::warn_sizeof_pointer_type_memaccess)\n                                << FnName << SizeOfArgTy << ArgIdx\n                                << PointeeTy << Dest->getSourceRange()\n                                << LenExpr->getSourceRange());\n          break;\n        }\n      }\n    } else if (DestTy->isArrayType()) {\n      PointeeTy = DestTy;\n    }\n\n    if (PointeeTy == QualType())\n      continue;\n\n    // Always complain about dynamic classes.\n    bool IsContained;\n    if (const CXXRecordDecl *ContainedRD =\n            getContainedDynamicClass(PointeeTy, IsContained)) {\n\n      unsigned OperationType = 0;\n      const bool IsCmp = BId == Builtin::BImemcmp || BId == Builtin::BIbcmp;\n      // \"overwritten\" if we're warning about the destination for any call\n      // but memcmp; otherwise a verb appropriate to the call.\n      if (ArgIdx != 0 || IsCmp) {\n        if (BId == Builtin::BImemcpy)\n          OperationType = 1;\n        else if(BId == Builtin::BImemmove)\n          OperationType = 2;\n        else if (IsCmp)\n          OperationType = 3;\n      }\n\n      DiagRuntimeBehavior(Dest->getExprLoc(), Dest,\n                          PDiag(diag::warn_dyn_class_memaccess)\n                              << (IsCmp ? ArgIdx + 2 : ArgIdx) << FnName\n                              << IsContained << ContainedRD << OperationType\n                              << Call->getCallee()->getSourceRange());\n    } else if (PointeeTy.hasNonTrivialObjCLifetime() &&\n             BId != Builtin::BImemset)\n      DiagRuntimeBehavior(\n        Dest->getExprLoc(), Dest,\n        PDiag(diag::warn_arc_object_memaccess)\n          << ArgIdx << FnName << PointeeTy\n          << Call->getCallee()->getSourceRange());\n    else if (const auto *RT = PointeeTy->getAs<RecordType>()) {\n      if ((BId == Builtin::BImemset || BId == Builtin::BIbzero) &&\n          RT->getDecl()->isNonTrivialToPrimitiveDefaultInitialize()) {\n        DiagRuntimeBehavior(Dest->getExprLoc(), Dest,\n                            PDiag(diag::warn_cstruct_memaccess)\n                                << ArgIdx << FnName << PointeeTy << 0);\n        SearchNonTrivialToInitializeField::diag(PointeeTy, Dest, *this);\n      } else if ((BId == Builtin::BImemcpy || BId == Builtin::BImemmove) &&\n                 RT->getDecl()->isNonTrivialToPrimitiveCopy()) {\n        DiagRuntimeBehavior(Dest->getExprLoc(), Dest,\n                            PDiag(diag::warn_cstruct_memaccess)\n                                << ArgIdx << FnName << PointeeTy << 1);\n        SearchNonTrivialToCopyField::diag(PointeeTy, Dest, *this);\n      } else {\n        continue;\n      }\n    } else\n      continue;\n\n    DiagRuntimeBehavior(\n      Dest->getExprLoc(), Dest,\n      PDiag(diag::note_bad_memaccess_silence)\n        << FixItHint::CreateInsertion(ArgRange.getBegin(), \"(void*)\"));\n    break;\n  }\n}\n\n// A little helper routine: ignore addition and subtraction of integer literals.\n// This intentionally does not ignore all integer constant expressions because\n// we don't want to remove sizeof().\nstatic const Expr *ignoreLiteralAdditions(const Expr *Ex, ASTContext &Ctx) {\n  Ex = Ex->IgnoreParenCasts();\n\n  while (true) {\n    const BinaryOperator * BO = dyn_cast<BinaryOperator>(Ex);\n    if (!BO || !BO->isAdditiveOp())\n      break;\n\n    const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n    const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\n    if (isa<IntegerLiteral>(RHS))\n      Ex = LHS;\n    else if (isa<IntegerLiteral>(LHS))\n      Ex = RHS;\n    else\n      break;\n  }\n\n  return Ex;\n}\n\nstatic bool isConstantSizeArrayWithMoreThanOneElement(QualType Ty,\n                                                      ASTContext &Context) {\n  // Only handle constant-sized or VLAs, but not flexible members.\n  if (const ConstantArrayType *CAT = Context.getAsConstantArrayType(Ty)) {\n    // Only issue the FIXIT for arrays of size > 1.\n    if (CAT->getSize().getSExtValue() <= 1)\n      return false;\n  } else if (!Ty->isVariableArrayType()) {\n    return false;\n  }\n  return true;\n}\n\n// Warn if the user has made the 'size' argument to strlcpy or strlcat\n// be the size of the source, instead of the destination.\nvoid Sema::CheckStrlcpycatArguments(const CallExpr *Call,\n                                    IdentifierInfo *FnName) {\n\n  // Don't crash if the user has the wrong number of arguments\n  unsigned NumArgs = Call->getNumArgs();\n  if ((NumArgs != 3) && (NumArgs != 4))\n    return;\n\n  const Expr *SrcArg = ignoreLiteralAdditions(Call->getArg(1), Context);\n  const Expr *SizeArg = ignoreLiteralAdditions(Call->getArg(2), Context);\n  const Expr *CompareWithSrc = nullptr;\n\n  if (CheckMemorySizeofForComparison(*this, SizeArg, FnName,\n                                     Call->getBeginLoc(), Call->getRParenLoc()))\n    return;\n\n  // Look for 'strlcpy(dst, x, sizeof(x))'\n  if (const Expr *Ex = getSizeOfExprArg(SizeArg))\n    CompareWithSrc = Ex;\n  else {\n    // Look for 'strlcpy(dst, x, strlen(x))'\n    if (const CallExpr *SizeCall = dyn_cast<CallExpr>(SizeArg)) {\n      if (SizeCall->getBuiltinCallee() == Builtin::BIstrlen &&\n          SizeCall->getNumArgs() == 1)\n        CompareWithSrc = ignoreLiteralAdditions(SizeCall->getArg(0), Context);\n    }\n  }\n\n  if (!CompareWithSrc)\n    return;\n\n  // Determine if the argument to sizeof/strlen is equal to the source\n  // argument.  In principle there's all kinds of things you could do\n  // here, for instance creating an == expression and evaluating it with\n  // EvaluateAsBooleanCondition, but this uses a more direct technique:\n  const DeclRefExpr *SrcArgDRE = dyn_cast<DeclRefExpr>(SrcArg);\n  if (!SrcArgDRE)\n    return;\n\n  const DeclRefExpr *CompareWithSrcDRE = dyn_cast<DeclRefExpr>(CompareWithSrc);\n  if (!CompareWithSrcDRE ||\n      SrcArgDRE->getDecl() != CompareWithSrcDRE->getDecl())\n    return;\n\n  const Expr *OriginalSizeArg = Call->getArg(2);\n  Diag(CompareWithSrcDRE->getBeginLoc(), diag::warn_strlcpycat_wrong_size)\n      << OriginalSizeArg->getSourceRange() << FnName;\n\n  // Output a FIXIT hint if the destination is an array (rather than a\n  // pointer to an array).  This could be enhanced to handle some\n  // pointers if we know the actual size, like if DstArg is 'array+2'\n  // we could say 'sizeof(array)-2'.\n  const Expr *DstArg = Call->getArg(0)->IgnoreParenImpCasts();\n  if (!isConstantSizeArrayWithMoreThanOneElement(DstArg->getType(), Context))\n    return;\n\n  SmallString<128> sizeString;\n  llvm::raw_svector_ostream OS(sizeString);\n  OS << \"sizeof(\";\n  DstArg->printPretty(OS, nullptr, getPrintingPolicy());\n  OS << \")\";\n\n  Diag(OriginalSizeArg->getBeginLoc(), diag::note_strlcpycat_wrong_size)\n      << FixItHint::CreateReplacement(OriginalSizeArg->getSourceRange(),\n                                      OS.str());\n}\n\n/// Check if two expressions refer to the same declaration.\nstatic bool referToTheSameDecl(const Expr *E1, const Expr *E2) {\n  if (const DeclRefExpr *D1 = dyn_cast_or_null<DeclRefExpr>(E1))\n    if (const DeclRefExpr *D2 = dyn_cast_or_null<DeclRefExpr>(E2))\n      return D1->getDecl() == D2->getDecl();\n  return false;\n}\n\nstatic const Expr *getStrlenExprArg(const Expr *E) {\n  if (const CallExpr *CE = dyn_cast<CallExpr>(E)) {\n    const FunctionDecl *FD = CE->getDirectCallee();\n    if (!FD || FD->getMemoryFunctionKind() != Builtin::BIstrlen)\n      return nullptr;\n    return CE->getArg(0)->IgnoreParenCasts();\n  }\n  return nullptr;\n}\n\n// Warn on anti-patterns as the 'size' argument to strncat.\n// The correct size argument should look like following:\n//   strncat(dst, src, sizeof(dst) - strlen(dest) - 1);\nvoid Sema::CheckStrncatArguments(const CallExpr *CE,\n                                 IdentifierInfo *FnName) {\n  // Don't crash if the user has the wrong number of arguments.\n  if (CE->getNumArgs() < 3)\n    return;\n  const Expr *DstArg = CE->getArg(0)->IgnoreParenCasts();\n  const Expr *SrcArg = CE->getArg(1)->IgnoreParenCasts();\n  const Expr *LenArg = CE->getArg(2)->IgnoreParenCasts();\n\n  if (CheckMemorySizeofForComparison(*this, LenArg, FnName, CE->getBeginLoc(),\n                                     CE->getRParenLoc()))\n    return;\n\n  // Identify common expressions, which are wrongly used as the size argument\n  // to strncat and may lead to buffer overflows.\n  unsigned PatternType = 0;\n  if (const Expr *SizeOfArg = getSizeOfExprArg(LenArg)) {\n    // - sizeof(dst)\n    if (referToTheSameDecl(SizeOfArg, DstArg))\n      PatternType = 1;\n    // - sizeof(src)\n    else if (referToTheSameDecl(SizeOfArg, SrcArg))\n      PatternType = 2;\n  } else if (const BinaryOperator *BE = dyn_cast<BinaryOperator>(LenArg)) {\n    if (BE->getOpcode() == BO_Sub) {\n      const Expr *L = BE->getLHS()->IgnoreParenCasts();\n      const Expr *R = BE->getRHS()->IgnoreParenCasts();\n      // - sizeof(dst) - strlen(dst)\n      if (referToTheSameDecl(DstArg, getSizeOfExprArg(L)) &&\n          referToTheSameDecl(DstArg, getStrlenExprArg(R)))\n        PatternType = 1;\n      // - sizeof(src) - (anything)\n      else if (referToTheSameDecl(SrcArg, getSizeOfExprArg(L)))\n        PatternType = 2;\n    }\n  }\n\n  if (PatternType == 0)\n    return;\n\n  // Generate the diagnostic.\n  SourceLocation SL = LenArg->getBeginLoc();\n  SourceRange SR = LenArg->getSourceRange();\n  SourceManager &SM = getSourceManager();\n\n  // If the function is defined as a builtin macro, do not show macro expansion.\n  if (SM.isMacroArgExpansion(SL)) {\n    SL = SM.getSpellingLoc(SL);\n    SR = SourceRange(SM.getSpellingLoc(SR.getBegin()),\n                     SM.getSpellingLoc(SR.getEnd()));\n  }\n\n  // Check if the destination is an array (rather than a pointer to an array).\n  QualType DstTy = DstArg->getType();\n  bool isKnownSizeArray = isConstantSizeArrayWithMoreThanOneElement(DstTy,\n                                                                    Context);\n  if (!isKnownSizeArray) {\n    if (PatternType == 1)\n      Diag(SL, diag::warn_strncat_wrong_size) << SR;\n    else\n      Diag(SL, diag::warn_strncat_src_size) << SR;\n    return;\n  }\n\n  if (PatternType == 1)\n    Diag(SL, diag::warn_strncat_large_size) << SR;\n  else\n    Diag(SL, diag::warn_strncat_src_size) << SR;\n\n  SmallString<128> sizeString;\n  llvm::raw_svector_ostream OS(sizeString);\n  OS << \"sizeof(\";\n  DstArg->printPretty(OS, nullptr, getPrintingPolicy());\n  OS << \") - \";\n  OS << \"strlen(\";\n  DstArg->printPretty(OS, nullptr, getPrintingPolicy());\n  OS << \") - 1\";\n\n  Diag(SL, diag::note_strncat_wrong_size)\n    << FixItHint::CreateReplacement(SR, OS.str());\n}\n\nnamespace {\nvoid CheckFreeArgumentsOnLvalue(Sema &S, const std::string &CalleeName,\n                                const UnaryOperator *UnaryExpr, const Decl *D) {\n  if (isa<FieldDecl, FunctionDecl, VarDecl>(D)) {\n    S.Diag(UnaryExpr->getBeginLoc(), diag::warn_free_nonheap_object)\n        << CalleeName << 0 /*object: */ << cast<NamedDecl>(D);\n    return;\n  }\n}\n\nvoid CheckFreeArgumentsAddressof(Sema &S, const std::string &CalleeName,\n                                 const UnaryOperator *UnaryExpr) {\n  if (const auto *Lvalue = dyn_cast<DeclRefExpr>(UnaryExpr->getSubExpr())) {\n    const Decl *D = Lvalue->getDecl();\n    if (isa<VarDecl, FunctionDecl>(D))\n      return CheckFreeArgumentsOnLvalue(S, CalleeName, UnaryExpr, D);\n  }\n\n  if (const auto *Lvalue = dyn_cast<MemberExpr>(UnaryExpr->getSubExpr()))\n    return CheckFreeArgumentsOnLvalue(S, CalleeName, UnaryExpr,\n                                      Lvalue->getMemberDecl());\n}\n\nvoid CheckFreeArgumentsPlus(Sema &S, const std::string &CalleeName,\n                            const UnaryOperator *UnaryExpr) {\n  const auto *Lambda = dyn_cast<LambdaExpr>(\n      UnaryExpr->getSubExpr()->IgnoreImplicitAsWritten()->IgnoreParens());\n  if (!Lambda)\n    return;\n\n  S.Diag(Lambda->getBeginLoc(), diag::warn_free_nonheap_object)\n      << CalleeName << 2 /*object: lambda expression*/;\n}\n\nvoid CheckFreeArgumentsStackArray(Sema &S, const std::string &CalleeName,\n                                  const DeclRefExpr *Lvalue) {\n  const auto *Var = dyn_cast<VarDecl>(Lvalue->getDecl());\n  if (Var == nullptr)\n    return;\n\n  S.Diag(Lvalue->getBeginLoc(), diag::warn_free_nonheap_object)\n      << CalleeName << 0 /*object: */ << Var;\n}\n\nvoid CheckFreeArgumentsCast(Sema &S, const std::string &CalleeName,\n                            const CastExpr *Cast) {\n  SmallString<128> SizeString;\n  llvm::raw_svector_ostream OS(SizeString);\n\n  clang::CastKind Kind = Cast->getCastKind();\n  if (Kind == clang::CK_BitCast &&\n      !Cast->getSubExpr()->getType()->isFunctionPointerType())\n    return;\n  if (Kind == clang::CK_IntegralToPointer &&\n      !isa<IntegerLiteral>(\n          Cast->getSubExpr()->IgnoreParenImpCasts()->IgnoreParens()))\n    return;\n\n  switch (Cast->getCastKind()) {\n  case clang::CK_BitCast:\n  case clang::CK_IntegralToPointer:\n  case clang::CK_FunctionToPointerDecay:\n    OS << '\\'';\n    Cast->printPretty(OS, nullptr, S.getPrintingPolicy());\n    OS << '\\'';\n    break;\n  default:\n    return;\n  }\n\n  S.Diag(Cast->getBeginLoc(), diag::warn_free_nonheap_object)\n      << CalleeName << 0 /*object: */ << OS.str();\n}\n} // namespace\n\n/// Alerts the user that they are attempting to free a non-malloc'd object.\nvoid Sema::CheckFreeArguments(const CallExpr *E) {\n  const std::string CalleeName =\n      dyn_cast<FunctionDecl>(E->getCalleeDecl())->getQualifiedNameAsString();\n\n  { // Prefer something that doesn't involve a cast to make things simpler.\n    const Expr *Arg = E->getArg(0)->IgnoreParenCasts();\n    if (const auto *UnaryExpr = dyn_cast<UnaryOperator>(Arg))\n      switch (UnaryExpr->getOpcode()) {\n      case UnaryOperator::Opcode::UO_AddrOf:\n        return CheckFreeArgumentsAddressof(*this, CalleeName, UnaryExpr);\n      case UnaryOperator::Opcode::UO_Plus:\n        return CheckFreeArgumentsPlus(*this, CalleeName, UnaryExpr);\n      default:\n        break;\n      }\n\n    if (const auto *Lvalue = dyn_cast<DeclRefExpr>(Arg))\n      if (Lvalue->getType()->isArrayType())\n        return CheckFreeArgumentsStackArray(*this, CalleeName, Lvalue);\n\n    if (const auto *Label = dyn_cast<AddrLabelExpr>(Arg)) {\n      Diag(Label->getBeginLoc(), diag::warn_free_nonheap_object)\n          << CalleeName << 0 /*object: */ << Label->getLabel()->getIdentifier();\n      return;\n    }\n\n    if (isa<BlockExpr>(Arg)) {\n      Diag(Arg->getBeginLoc(), diag::warn_free_nonheap_object)\n          << CalleeName << 1 /*object: block*/;\n      return;\n    }\n  }\n  // Maybe the cast was important, check after the other cases.\n  if (const auto *Cast = dyn_cast<CastExpr>(E->getArg(0)))\n    return CheckFreeArgumentsCast(*this, CalleeName, Cast);\n}\n\nvoid\nSema::CheckReturnValExpr(Expr *RetValExp, QualType lhsType,\n                         SourceLocation ReturnLoc,\n                         bool isObjCMethod,\n                         const AttrVec *Attrs,\n                         const FunctionDecl *FD) {\n  // Check if the return value is null but should not be.\n  if (((Attrs && hasSpecificAttr<ReturnsNonNullAttr>(*Attrs)) ||\n       (!isObjCMethod && isNonNullType(Context, lhsType))) &&\n      CheckNonNullExpr(*this, RetValExp))\n    Diag(ReturnLoc, diag::warn_null_ret)\n      << (isObjCMethod ? 1 : 0) << RetValExp->getSourceRange();\n\n  // C++11 [basic.stc.dynamic.allocation]p4:\n  //   If an allocation function declared with a non-throwing\n  //   exception-specification fails to allocate storage, it shall return\n  //   a null pointer. Any other allocation function that fails to allocate\n  //   storage shall indicate failure only by throwing an exception [...]\n  if (FD) {\n    OverloadedOperatorKind Op = FD->getOverloadedOperator();\n    if (Op == OO_New || Op == OO_Array_New) {\n      const FunctionProtoType *Proto\n        = FD->getType()->castAs<FunctionProtoType>();\n      if (!Proto->isNothrow(/*ResultIfDependent*/true) &&\n          CheckNonNullExpr(*this, RetValExp))\n        Diag(ReturnLoc, diag::warn_operator_new_returns_null)\n          << FD << getLangOpts().CPlusPlus11;\n    }\n  }\n\n  // PPC MMA non-pointer types are not allowed as return type. Checking the type\n  // here prevent the user from using a PPC MMA type as trailing return type.\n  if (Context.getTargetInfo().getTriple().isPPC64())\n    CheckPPCMMAType(RetValExp->getType(), ReturnLoc);\n}\n\n//===--- CHECK: Floating-Point comparisons (-Wfloat-equal) ---------------===//\n\n/// Check for comparisons of floating point operands using != and ==.\n/// Issue a warning if these are no self-comparisons, as they are not likely\n/// to do what the programmer intended.\nvoid Sema::CheckFloatComparison(SourceLocation Loc, Expr* LHS, Expr *RHS) {\n  Expr* LeftExprSansParen = LHS->IgnoreParenImpCasts();\n  Expr* RightExprSansParen = RHS->IgnoreParenImpCasts();\n\n  // Special case: check for x == x (which is OK).\n  // Do not emit warnings for such cases.\n  if (DeclRefExpr* DRL = dyn_cast<DeclRefExpr>(LeftExprSansParen))\n    if (DeclRefExpr* DRR = dyn_cast<DeclRefExpr>(RightExprSansParen))\n      if (DRL->getDecl() == DRR->getDecl())\n        return;\n\n  // Special case: check for comparisons against literals that can be exactly\n  //  represented by APFloat.  In such cases, do not emit a warning.  This\n  //  is a heuristic: often comparison against such literals are used to\n  //  detect if a value in a variable has not changed.  This clearly can\n  //  lead to false negatives.\n  if (FloatingLiteral* FLL = dyn_cast<FloatingLiteral>(LeftExprSansParen)) {\n    if (FLL->isExact())\n      return;\n  } else\n    if (FloatingLiteral* FLR = dyn_cast<FloatingLiteral>(RightExprSansParen))\n      if (FLR->isExact())\n        return;\n\n  // Check for comparisons with builtin types.\n  if (CallExpr* CL = dyn_cast<CallExpr>(LeftExprSansParen))\n    if (CL->getBuiltinCallee())\n      return;\n\n  if (CallExpr* CR = dyn_cast<CallExpr>(RightExprSansParen))\n    if (CR->getBuiltinCallee())\n      return;\n\n  // Emit the diagnostic.\n  Diag(Loc, diag::warn_floatingpoint_eq)\n    << LHS->getSourceRange() << RHS->getSourceRange();\n}\n\n//===--- CHECK: Integer mixed-sign comparisons (-Wsign-compare) --------===//\n//===--- CHECK: Lossy implicit conversions (-Wconversion) --------------===//\n\nnamespace {\n\n/// Structure recording the 'active' range of an integer-valued\n/// expression.\nstruct IntRange {\n  /// The number of bits active in the int. Note that this includes exactly one\n  /// sign bit if !NonNegative.\n  unsigned Width;\n\n  /// True if the int is known not to have negative values. If so, all leading\n  /// bits before Width are known zero, otherwise they are known to be the\n  /// same as the MSB within Width.\n  bool NonNegative;\n\n  IntRange(unsigned Width, bool NonNegative)\n      : Width(Width), NonNegative(NonNegative) {}\n\n  /// Number of bits excluding the sign bit.\n  unsigned valueBits() const {\n    return NonNegative ? Width : Width - 1;\n  }\n\n  /// Returns the range of the bool type.\n  static IntRange forBoolType() {\n    return IntRange(1, true);\n  }\n\n  /// Returns the range of an opaque value of the given integral type.\n  static IntRange forValueOfType(ASTContext &C, QualType T) {\n    return forValueOfCanonicalType(C,\n                          T->getCanonicalTypeInternal().getTypePtr());\n  }\n\n  /// Returns the range of an opaque value of a canonical integral type.\n  static IntRange forValueOfCanonicalType(ASTContext &C, const Type *T) {\n    assert(T->isCanonicalUnqualified());\n\n    if (const VectorType *VT = dyn_cast<VectorType>(T))\n      T = VT->getElementType().getTypePtr();\n    if (const ComplexType *CT = dyn_cast<ComplexType>(T))\n      T = CT->getElementType().getTypePtr();\n    if (const AtomicType *AT = dyn_cast<AtomicType>(T))\n      T = AT->getValueType().getTypePtr();\n\n    if (!C.getLangOpts().CPlusPlus) {\n      // For enum types in C code, use the underlying datatype.\n      if (const EnumType *ET = dyn_cast<EnumType>(T))\n        T = ET->getDecl()->getIntegerType().getDesugaredType(C).getTypePtr();\n    } else if (const EnumType *ET = dyn_cast<EnumType>(T)) {\n      // For enum types in C++, use the known bit width of the enumerators.\n      EnumDecl *Enum = ET->getDecl();\n      // In C++11, enums can have a fixed underlying type. Use this type to\n      // compute the range.\n      if (Enum->isFixed()) {\n        return IntRange(C.getIntWidth(QualType(T, 0)),\n                        !ET->isSignedIntegerOrEnumerationType());\n      }\n\n      unsigned NumPositive = Enum->getNumPositiveBits();\n      unsigned NumNegative = Enum->getNumNegativeBits();\n\n      if (NumNegative == 0)\n        return IntRange(NumPositive, true/*NonNegative*/);\n      else\n        return IntRange(std::max(NumPositive + 1, NumNegative),\n                        false/*NonNegative*/);\n    }\n\n    if (const auto *EIT = dyn_cast<ExtIntType>(T))\n      return IntRange(EIT->getNumBits(), EIT->isUnsigned());\n\n    const BuiltinType *BT = cast<BuiltinType>(T);\n    assert(BT->isInteger());\n\n    return IntRange(C.getIntWidth(QualType(T, 0)), BT->isUnsignedInteger());\n  }\n\n  /// Returns the \"target\" range of a canonical integral type, i.e.\n  /// the range of values expressible in the type.\n  ///\n  /// This matches forValueOfCanonicalType except that enums have the\n  /// full range of their type, not the range of their enumerators.\n  static IntRange forTargetOfCanonicalType(ASTContext &C, const Type *T) {\n    assert(T->isCanonicalUnqualified());\n\n    if (const VectorType *VT = dyn_cast<VectorType>(T))\n      T = VT->getElementType().getTypePtr();\n    if (const ComplexType *CT = dyn_cast<ComplexType>(T))\n      T = CT->getElementType().getTypePtr();\n    if (const AtomicType *AT = dyn_cast<AtomicType>(T))\n      T = AT->getValueType().getTypePtr();\n    if (const EnumType *ET = dyn_cast<EnumType>(T))\n      T = C.getCanonicalType(ET->getDecl()->getIntegerType()).getTypePtr();\n\n    if (const auto *EIT = dyn_cast<ExtIntType>(T))\n      return IntRange(EIT->getNumBits(), EIT->isUnsigned());\n\n    const BuiltinType *BT = cast<BuiltinType>(T);\n    assert(BT->isInteger());\n\n    return IntRange(C.getIntWidth(QualType(T, 0)), BT->isUnsignedInteger());\n  }\n\n  /// Returns the supremum of two ranges: i.e. their conservative merge.\n  static IntRange join(IntRange L, IntRange R) {\n    bool Unsigned = L.NonNegative && R.NonNegative;\n    return IntRange(std::max(L.valueBits(), R.valueBits()) + !Unsigned,\n                    L.NonNegative && R.NonNegative);\n  }\n\n  /// Return the range of a bitwise-AND of the two ranges.\n  static IntRange bit_and(IntRange L, IntRange R) {\n    unsigned Bits = std::max(L.Width, R.Width);\n    bool NonNegative = false;\n    if (L.NonNegative) {\n      Bits = std::min(Bits, L.Width);\n      NonNegative = true;\n    }\n    if (R.NonNegative) {\n      Bits = std::min(Bits, R.Width);\n      NonNegative = true;\n    }\n    return IntRange(Bits, NonNegative);\n  }\n\n  /// Return the range of a sum of the two ranges.\n  static IntRange sum(IntRange L, IntRange R) {\n    bool Unsigned = L.NonNegative && R.NonNegative;\n    return IntRange(std::max(L.valueBits(), R.valueBits()) + 1 + !Unsigned,\n                    Unsigned);\n  }\n\n  /// Return the range of a difference of the two ranges.\n  static IntRange difference(IntRange L, IntRange R) {\n    // We need a 1-bit-wider range if:\n    //   1) LHS can be negative: least value can be reduced.\n    //   2) RHS can be negative: greatest value can be increased.\n    bool CanWiden = !L.NonNegative || !R.NonNegative;\n    bool Unsigned = L.NonNegative && R.Width == 0;\n    return IntRange(std::max(L.valueBits(), R.valueBits()) + CanWiden +\n                        !Unsigned,\n                    Unsigned);\n  }\n\n  /// Return the range of a product of the two ranges.\n  static IntRange product(IntRange L, IntRange R) {\n    // If both LHS and RHS can be negative, we can form\n    //   -2^L * -2^R = 2^(L + R)\n    // which requires L + R + 1 value bits to represent.\n    bool CanWiden = !L.NonNegative && !R.NonNegative;\n    bool Unsigned = L.NonNegative && R.NonNegative;\n    return IntRange(L.valueBits() + R.valueBits() + CanWiden + !Unsigned,\n                    Unsigned);\n  }\n\n  /// Return the range of a remainder operation between the two ranges.\n  static IntRange rem(IntRange L, IntRange R) {\n    // The result of a remainder can't be larger than the result of\n    // either side. The sign of the result is the sign of the LHS.\n    bool Unsigned = L.NonNegative;\n    return IntRange(std::min(L.valueBits(), R.valueBits()) + !Unsigned,\n                    Unsigned);\n  }\n};\n\n} // namespace\n\nstatic IntRange GetValueRange(ASTContext &C, llvm::APSInt &value,\n                              unsigned MaxWidth) {\n  if (value.isSigned() && value.isNegative())\n    return IntRange(value.getMinSignedBits(), false);\n\n  if (value.getBitWidth() > MaxWidth)\n    value = value.trunc(MaxWidth);\n\n  // isNonNegative() just checks the sign bit without considering\n  // signedness.\n  return IntRange(value.getActiveBits(), true);\n}\n\nstatic IntRange GetValueRange(ASTContext &C, APValue &result, QualType Ty,\n                              unsigned MaxWidth) {\n  if (result.isInt())\n    return GetValueRange(C, result.getInt(), MaxWidth);\n\n  if (result.isVector()) {\n    IntRange R = GetValueRange(C, result.getVectorElt(0), Ty, MaxWidth);\n    for (unsigned i = 1, e = result.getVectorLength(); i != e; ++i) {\n      IntRange El = GetValueRange(C, result.getVectorElt(i), Ty, MaxWidth);\n      R = IntRange::join(R, El);\n    }\n    return R;\n  }\n\n  if (result.isComplexInt()) {\n    IntRange R = GetValueRange(C, result.getComplexIntReal(), MaxWidth);\n    IntRange I = GetValueRange(C, result.getComplexIntImag(), MaxWidth);\n    return IntRange::join(R, I);\n  }\n\n  // This can happen with lossless casts to intptr_t of \"based\" lvalues.\n  // Assume it might use arbitrary bits.\n  // FIXME: The only reason we need to pass the type in here is to get\n  // the sign right on this one case.  It would be nice if APValue\n  // preserved this.\n  assert(result.isLValue() || result.isAddrLabelDiff());\n  return IntRange(MaxWidth, Ty->isUnsignedIntegerOrEnumerationType());\n}\n\nstatic QualType GetExprType(const Expr *E) {\n  QualType Ty = E->getType();\n  if (const AtomicType *AtomicRHS = Ty->getAs<AtomicType>())\n    Ty = AtomicRHS->getValueType();\n  return Ty;\n}\n\n/// Pseudo-evaluate the given integer expression, estimating the\n/// range of values it might take.\n///\n/// \\param MaxWidth The width to which the value will be truncated.\n/// \\param Approximate If \\c true, return a likely range for the result: in\n///        particular, assume that aritmetic on narrower types doesn't leave\n///        those types. If \\c false, return a range including all possible\n///        result values.\nstatic IntRange GetExprRange(ASTContext &C, const Expr *E, unsigned MaxWidth,\n                             bool InConstantContext, bool Approximate) {\n  E = E->IgnoreParens();\n\n  // Try a full evaluation first.\n  Expr::EvalResult result;\n  if (E->EvaluateAsRValue(result, C, InConstantContext))\n    return GetValueRange(C, result.Val, GetExprType(E), MaxWidth);\n\n  // I think we only want to look through implicit casts here; if the\n  // user has an explicit widening cast, we should treat the value as\n  // being of the new, wider type.\n  if (const auto *CE = dyn_cast<ImplicitCastExpr>(E)) {\n    if (CE->getCastKind() == CK_NoOp || CE->getCastKind() == CK_LValueToRValue)\n      return GetExprRange(C, CE->getSubExpr(), MaxWidth, InConstantContext,\n                          Approximate);\n\n    IntRange OutputTypeRange = IntRange::forValueOfType(C, GetExprType(CE));\n\n    bool isIntegerCast = CE->getCastKind() == CK_IntegralCast ||\n                         CE->getCastKind() == CK_BooleanToSignedIntegral;\n\n    // Assume that non-integer casts can span the full range of the type.\n    if (!isIntegerCast)\n      return OutputTypeRange;\n\n    IntRange SubRange = GetExprRange(C, CE->getSubExpr(),\n                                     std::min(MaxWidth, OutputTypeRange.Width),\n                                     InConstantContext, Approximate);\n\n    // Bail out if the subexpr's range is as wide as the cast type.\n    if (SubRange.Width >= OutputTypeRange.Width)\n      return OutputTypeRange;\n\n    // Otherwise, we take the smaller width, and we're non-negative if\n    // either the output type or the subexpr is.\n    return IntRange(SubRange.Width,\n                    SubRange.NonNegative || OutputTypeRange.NonNegative);\n  }\n\n  if (const auto *CO = dyn_cast<ConditionalOperator>(E)) {\n    // If we can fold the condition, just take that operand.\n    bool CondResult;\n    if (CO->getCond()->EvaluateAsBooleanCondition(CondResult, C))\n      return GetExprRange(C,\n                          CondResult ? CO->getTrueExpr() : CO->getFalseExpr(),\n                          MaxWidth, InConstantContext, Approximate);\n\n    // Otherwise, conservatively merge.\n    // GetExprRange requires an integer expression, but a throw expression\n    // results in a void type.\n    Expr *E = CO->getTrueExpr();\n    IntRange L = E->getType()->isVoidType()\n                     ? IntRange{0, true}\n                     : GetExprRange(C, E, MaxWidth, InConstantContext, Approximate);\n    E = CO->getFalseExpr();\n    IntRange R = E->getType()->isVoidType()\n                     ? IntRange{0, true}\n                     : GetExprRange(C, E, MaxWidth, InConstantContext, Approximate);\n    return IntRange::join(L, R);\n  }\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n    IntRange (*Combine)(IntRange, IntRange) = IntRange::join;\n\n    switch (BO->getOpcode()) {\n    case BO_Cmp:\n      llvm_unreachable(\"builtin <=> should have class type\");\n\n    // Boolean-valued operations are single-bit and positive.\n    case BO_LAnd:\n    case BO_LOr:\n    case BO_LT:\n    case BO_GT:\n    case BO_LE:\n    case BO_GE:\n    case BO_EQ:\n    case BO_NE:\n      return IntRange::forBoolType();\n\n    // The type of the assignments is the type of the LHS, so the RHS\n    // is not necessarily the same type.\n    case BO_MulAssign:\n    case BO_DivAssign:\n    case BO_RemAssign:\n    case BO_AddAssign:\n    case BO_SubAssign:\n    case BO_XorAssign:\n    case BO_OrAssign:\n      // TODO: bitfields?\n      return IntRange::forValueOfType(C, GetExprType(E));\n\n    // Simple assignments just pass through the RHS, which will have\n    // been coerced to the LHS type.\n    case BO_Assign:\n      // TODO: bitfields?\n      return GetExprRange(C, BO->getRHS(), MaxWidth, InConstantContext,\n                          Approximate);\n\n    // Operations with opaque sources are black-listed.\n    case BO_PtrMemD:\n    case BO_PtrMemI:\n      return IntRange::forValueOfType(C, GetExprType(E));\n\n    // Bitwise-and uses the *infinum* of the two source ranges.\n    case BO_And:\n    case BO_AndAssign:\n      Combine = IntRange::bit_and;\n      break;\n\n    // Left shift gets black-listed based on a judgement call.\n    case BO_Shl:\n      // ...except that we want to treat '1 << (blah)' as logically\n      // positive.  It's an important idiom.\n      if (IntegerLiteral *I\n            = dyn_cast<IntegerLiteral>(BO->getLHS()->IgnoreParenCasts())) {\n        if (I->getValue() == 1) {\n          IntRange R = IntRange::forValueOfType(C, GetExprType(E));\n          return IntRange(R.Width, /*NonNegative*/ true);\n        }\n      }\n      LLVM_FALLTHROUGH;\n\n    case BO_ShlAssign:\n      return IntRange::forValueOfType(C, GetExprType(E));\n\n    // Right shift by a constant can narrow its left argument.\n    case BO_Shr:\n    case BO_ShrAssign: {\n      IntRange L = GetExprRange(C, BO->getLHS(), MaxWidth, InConstantContext,\n                                Approximate);\n\n      // If the shift amount is a positive constant, drop the width by\n      // that much.\n      if (Optional<llvm::APSInt> shift =\n              BO->getRHS()->getIntegerConstantExpr(C)) {\n        if (shift->isNonNegative()) {\n          unsigned zext = shift->getZExtValue();\n          if (zext >= L.Width)\n            L.Width = (L.NonNegative ? 0 : 1);\n          else\n            L.Width -= zext;\n        }\n      }\n\n      return L;\n    }\n\n    // Comma acts as its right operand.\n    case BO_Comma:\n      return GetExprRange(C, BO->getRHS(), MaxWidth, InConstantContext,\n                          Approximate);\n\n    case BO_Add:\n      if (!Approximate)\n        Combine = IntRange::sum;\n      break;\n\n    case BO_Sub:\n      if (BO->getLHS()->getType()->isPointerType())\n        return IntRange::forValueOfType(C, GetExprType(E));\n      if (!Approximate)\n        Combine = IntRange::difference;\n      break;\n\n    case BO_Mul:\n      if (!Approximate)\n        Combine = IntRange::product;\n      break;\n\n    // The width of a division result is mostly determined by the size\n    // of the LHS.\n    case BO_Div: {\n      // Don't 'pre-truncate' the operands.\n      unsigned opWidth = C.getIntWidth(GetExprType(E));\n      IntRange L = GetExprRange(C, BO->getLHS(), opWidth, InConstantContext,\n                                Approximate);\n\n      // If the divisor is constant, use that.\n      if (Optional<llvm::APSInt> divisor =\n              BO->getRHS()->getIntegerConstantExpr(C)) {\n        unsigned log2 = divisor->logBase2(); // floor(log_2(divisor))\n        if (log2 >= L.Width)\n          L.Width = (L.NonNegative ? 0 : 1);\n        else\n          L.Width = std::min(L.Width - log2, MaxWidth);\n        return L;\n      }\n\n      // Otherwise, just use the LHS's width.\n      // FIXME: This is wrong if the LHS could be its minimal value and the RHS\n      // could be -1.\n      IntRange R = GetExprRange(C, BO->getRHS(), opWidth, InConstantContext,\n                                Approximate);\n      return IntRange(L.Width, L.NonNegative && R.NonNegative);\n    }\n\n    case BO_Rem:\n      Combine = IntRange::rem;\n      break;\n\n    // The default behavior is okay for these.\n    case BO_Xor:\n    case BO_Or:\n      break;\n    }\n\n    // Combine the two ranges, but limit the result to the type in which we\n    // performed the computation.\n    QualType T = GetExprType(E);\n    unsigned opWidth = C.getIntWidth(T);\n    IntRange L =\n        GetExprRange(C, BO->getLHS(), opWidth, InConstantContext, Approximate);\n    IntRange R =\n        GetExprRange(C, BO->getRHS(), opWidth, InConstantContext, Approximate);\n    IntRange C = Combine(L, R);\n    C.NonNegative |= T->isUnsignedIntegerOrEnumerationType();\n    C.Width = std::min(C.Width, MaxWidth);\n    return C;\n  }\n\n  if (const auto *UO = dyn_cast<UnaryOperator>(E)) {\n    switch (UO->getOpcode()) {\n    // Boolean-valued operations are white-listed.\n    case UO_LNot:\n      return IntRange::forBoolType();\n\n    // Operations with opaque sources are black-listed.\n    case UO_Deref:\n    case UO_AddrOf: // should be impossible\n      return IntRange::forValueOfType(C, GetExprType(E));\n\n    default:\n      return GetExprRange(C, UO->getSubExpr(), MaxWidth, InConstantContext,\n                          Approximate);\n    }\n  }\n\n  if (const auto *OVE = dyn_cast<OpaqueValueExpr>(E))\n    return GetExprRange(C, OVE->getSourceExpr(), MaxWidth, InConstantContext,\n                        Approximate);\n\n  if (const auto *BitField = E->getSourceBitField())\n    return IntRange(BitField->getBitWidthValue(C),\n                    BitField->getType()->isUnsignedIntegerOrEnumerationType());\n\n  return IntRange::forValueOfType(C, GetExprType(E));\n}\n\nstatic IntRange GetExprRange(ASTContext &C, const Expr *E,\n                             bool InConstantContext, bool Approximate) {\n  return GetExprRange(C, E, C.getIntWidth(GetExprType(E)), InConstantContext,\n                      Approximate);\n}\n\n/// Checks whether the given value, which currently has the given\n/// source semantics, has the same value when coerced through the\n/// target semantics.\nstatic bool IsSameFloatAfterCast(const llvm::APFloat &value,\n                                 const llvm::fltSemantics &Src,\n                                 const llvm::fltSemantics &Tgt) {\n  llvm::APFloat truncated = value;\n\n  bool ignored;\n  truncated.convert(Src, llvm::APFloat::rmNearestTiesToEven, &ignored);\n  truncated.convert(Tgt, llvm::APFloat::rmNearestTiesToEven, &ignored);\n\n  return truncated.bitwiseIsEqual(value);\n}\n\n/// Checks whether the given value, which currently has the given\n/// source semantics, has the same value when coerced through the\n/// target semantics.\n///\n/// The value might be a vector of floats (or a complex number).\nstatic bool IsSameFloatAfterCast(const APValue &value,\n                                 const llvm::fltSemantics &Src,\n                                 const llvm::fltSemantics &Tgt) {\n  if (value.isFloat())\n    return IsSameFloatAfterCast(value.getFloat(), Src, Tgt);\n\n  if (value.isVector()) {\n    for (unsigned i = 0, e = value.getVectorLength(); i != e; ++i)\n      if (!IsSameFloatAfterCast(value.getVectorElt(i), Src, Tgt))\n        return false;\n    return true;\n  }\n\n  assert(value.isComplexFloat());\n  return (IsSameFloatAfterCast(value.getComplexFloatReal(), Src, Tgt) &&\n          IsSameFloatAfterCast(value.getComplexFloatImag(), Src, Tgt));\n}\n\nstatic void AnalyzeImplicitConversions(Sema &S, Expr *E, SourceLocation CC,\n                                       bool IsListInit = false);\n\nstatic bool IsEnumConstOrFromMacro(Sema &S, Expr *E) {\n  // Suppress cases where we are comparing against an enum constant.\n  if (const DeclRefExpr *DR =\n      dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts()))\n    if (isa<EnumConstantDecl>(DR->getDecl()))\n      return true;\n\n  // Suppress cases where the value is expanded from a macro, unless that macro\n  // is how a language represents a boolean literal. This is the case in both C\n  // and Objective-C.\n  SourceLocation BeginLoc = E->getBeginLoc();\n  if (BeginLoc.isMacroID()) {\n    StringRef MacroName = Lexer::getImmediateMacroName(\n        BeginLoc, S.getSourceManager(), S.getLangOpts());\n    return MacroName != \"YES\" && MacroName != \"NO\" &&\n           MacroName != \"true\" && MacroName != \"false\";\n  }\n\n  return false;\n}\n\nstatic bool isKnownToHaveUnsignedValue(Expr *E) {\n  return E->getType()->isIntegerType() &&\n         (!E->getType()->isSignedIntegerType() ||\n          !E->IgnoreParenImpCasts()->getType()->isSignedIntegerType());\n}\n\nnamespace {\n/// The promoted range of values of a type. In general this has the\n/// following structure:\n///\n///     |-----------| . . . |-----------|\n///     ^           ^       ^           ^\n///    Min       HoleMin  HoleMax      Max\n///\n/// ... where there is only a hole if a signed type is promoted to unsigned\n/// (in which case Min and Max are the smallest and largest representable\n/// values).\nstruct PromotedRange {\n  // Min, or HoleMax if there is a hole.\n  llvm::APSInt PromotedMin;\n  // Max, or HoleMin if there is a hole.\n  llvm::APSInt PromotedMax;\n\n  PromotedRange(IntRange R, unsigned BitWidth, bool Unsigned) {\n    if (R.Width == 0)\n      PromotedMin = PromotedMax = llvm::APSInt(BitWidth, Unsigned);\n    else if (R.Width >= BitWidth && !Unsigned) {\n      // Promotion made the type *narrower*. This happens when promoting\n      // a < 32-bit unsigned / <= 32-bit signed bit-field to 'signed int'.\n      // Treat all values of 'signed int' as being in range for now.\n      PromotedMin = llvm::APSInt::getMinValue(BitWidth, Unsigned);\n      PromotedMax = llvm::APSInt::getMaxValue(BitWidth, Unsigned);\n    } else {\n      PromotedMin = llvm::APSInt::getMinValue(R.Width, R.NonNegative)\n                        .extOrTrunc(BitWidth);\n      PromotedMin.setIsUnsigned(Unsigned);\n\n      PromotedMax = llvm::APSInt::getMaxValue(R.Width, R.NonNegative)\n                        .extOrTrunc(BitWidth);\n      PromotedMax.setIsUnsigned(Unsigned);\n    }\n  }\n\n  // Determine whether this range is contiguous (has no hole).\n  bool isContiguous() const { return PromotedMin <= PromotedMax; }\n\n  // Where a constant value is within the range.\n  enum ComparisonResult {\n    LT = 0x1,\n    LE = 0x2,\n    GT = 0x4,\n    GE = 0x8,\n    EQ = 0x10,\n    NE = 0x20,\n    InRangeFlag = 0x40,\n\n    Less = LE | LT | NE,\n    Min = LE | InRangeFlag,\n    InRange = InRangeFlag,\n    Max = GE | InRangeFlag,\n    Greater = GE | GT | NE,\n\n    OnlyValue = LE | GE | EQ | InRangeFlag,\n    InHole = NE\n  };\n\n  ComparisonResult compare(const llvm::APSInt &Value) const {\n    assert(Value.getBitWidth() == PromotedMin.getBitWidth() &&\n           Value.isUnsigned() == PromotedMin.isUnsigned());\n    if (!isContiguous()) {\n      assert(Value.isUnsigned() && \"discontiguous range for signed compare\");\n      if (Value.isMinValue()) return Min;\n      if (Value.isMaxValue()) return Max;\n      if (Value >= PromotedMin) return InRange;\n      if (Value <= PromotedMax) return InRange;\n      return InHole;\n    }\n\n    switch (llvm::APSInt::compareValues(Value, PromotedMin)) {\n    case -1: return Less;\n    case 0: return PromotedMin == PromotedMax ? OnlyValue : Min;\n    case 1:\n      switch (llvm::APSInt::compareValues(Value, PromotedMax)) {\n      case -1: return InRange;\n      case 0: return Max;\n      case 1: return Greater;\n      }\n    }\n\n    llvm_unreachable(\"impossible compare result\");\n  }\n\n  static llvm::Optional<StringRef>\n  constantValue(BinaryOperatorKind Op, ComparisonResult R, bool ConstantOnRHS) {\n    if (Op == BO_Cmp) {\n      ComparisonResult LTFlag = LT, GTFlag = GT;\n      if (ConstantOnRHS) std::swap(LTFlag, GTFlag);\n\n      if (R & EQ) return StringRef(\"'std::strong_ordering::equal'\");\n      if (R & LTFlag) return StringRef(\"'std::strong_ordering::less'\");\n      if (R & GTFlag) return StringRef(\"'std::strong_ordering::greater'\");\n      return llvm::None;\n    }\n\n    ComparisonResult TrueFlag, FalseFlag;\n    if (Op == BO_EQ) {\n      TrueFlag = EQ;\n      FalseFlag = NE;\n    } else if (Op == BO_NE) {\n      TrueFlag = NE;\n      FalseFlag = EQ;\n    } else {\n      if ((Op == BO_LT || Op == BO_GE) ^ ConstantOnRHS) {\n        TrueFlag = LT;\n        FalseFlag = GE;\n      } else {\n        TrueFlag = GT;\n        FalseFlag = LE;\n      }\n      if (Op == BO_GE || Op == BO_LE)\n        std::swap(TrueFlag, FalseFlag);\n    }\n    if (R & TrueFlag)\n      return StringRef(\"true\");\n    if (R & FalseFlag)\n      return StringRef(\"false\");\n    return llvm::None;\n  }\n};\n}\n\nstatic bool HasEnumType(Expr *E) {\n  // Strip off implicit integral promotions.\n  while (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(E)) {\n    if (ICE->getCastKind() != CK_IntegralCast &&\n        ICE->getCastKind() != CK_NoOp)\n      break;\n    E = ICE->getSubExpr();\n  }\n\n  return E->getType()->isEnumeralType();\n}\n\nstatic int classifyConstantValue(Expr *Constant) {\n  // The values of this enumeration are used in the diagnostics\n  // diag::warn_out_of_range_compare and diag::warn_tautological_bool_compare.\n  enum ConstantValueKind {\n    Miscellaneous = 0,\n    LiteralTrue,\n    LiteralFalse\n  };\n  if (auto *BL = dyn_cast<CXXBoolLiteralExpr>(Constant))\n    return BL->getValue() ? ConstantValueKind::LiteralTrue\n                          : ConstantValueKind::LiteralFalse;\n  return ConstantValueKind::Miscellaneous;\n}\n\nstatic bool CheckTautologicalComparison(Sema &S, BinaryOperator *E,\n                                        Expr *Constant, Expr *Other,\n                                        const llvm::APSInt &Value,\n                                        bool RhsConstant) {\n  if (S.inTemplateInstantiation())\n    return false;\n\n  Expr *OriginalOther = Other;\n\n  Constant = Constant->IgnoreParenImpCasts();\n  Other = Other->IgnoreParenImpCasts();\n\n  // Suppress warnings on tautological comparisons between values of the same\n  // enumeration type. There are only two ways we could warn on this:\n  //  - If the constant is outside the range of representable values of\n  //    the enumeration. In such a case, we should warn about the cast\n  //    to enumeration type, not about the comparison.\n  //  - If the constant is the maximum / minimum in-range value. For an\n  //    enumeratin type, such comparisons can be meaningful and useful.\n  if (Constant->getType()->isEnumeralType() &&\n      S.Context.hasSameUnqualifiedType(Constant->getType(), Other->getType()))\n    return false;\n\n  IntRange OtherValueRange = GetExprRange(\n      S.Context, Other, S.isConstantEvaluated(), /*Approximate*/ false);\n\n  QualType OtherT = Other->getType();\n  if (const auto *AT = OtherT->getAs<AtomicType>())\n    OtherT = AT->getValueType();\n  IntRange OtherTypeRange = IntRange::forValueOfType(S.Context, OtherT);\n\n  // Special case for ObjC BOOL on targets where its a typedef for a signed char\n  // (Namely, macOS). FIXME: IntRange::forValueOfType should do this.\n  bool IsObjCSignedCharBool = S.getLangOpts().ObjC &&\n                              S.NSAPIObj->isObjCBOOLType(OtherT) &&\n                              OtherT->isSpecificBuiltinType(BuiltinType::SChar);\n\n  // Whether we're treating Other as being a bool because of the form of\n  // expression despite it having another type (typically 'int' in C).\n  bool OtherIsBooleanDespiteType =\n      !OtherT->isBooleanType() && Other->isKnownToHaveBooleanValue();\n  if (OtherIsBooleanDespiteType || IsObjCSignedCharBool)\n    OtherTypeRange = OtherValueRange = IntRange::forBoolType();\n\n  // Check if all values in the range of possible values of this expression\n  // lead to the same comparison outcome.\n  PromotedRange OtherPromotedValueRange(OtherValueRange, Value.getBitWidth(),\n                                        Value.isUnsigned());\n  auto Cmp = OtherPromotedValueRange.compare(Value);\n  auto Result = PromotedRange::constantValue(E->getOpcode(), Cmp, RhsConstant);\n  if (!Result)\n    return false;\n\n  // Also consider the range determined by the type alone. This allows us to\n  // classify the warning under the proper diagnostic group.\n  bool TautologicalTypeCompare = false;\n  {\n    PromotedRange OtherPromotedTypeRange(OtherTypeRange, Value.getBitWidth(),\n                                         Value.isUnsigned());\n    auto TypeCmp = OtherPromotedTypeRange.compare(Value);\n    if (auto TypeResult = PromotedRange::constantValue(E->getOpcode(), TypeCmp,\n                                                       RhsConstant)) {\n      TautologicalTypeCompare = true;\n      Cmp = TypeCmp;\n      Result = TypeResult;\n    }\n  }\n\n  // Don't warn if the non-constant operand actually always evaluates to the\n  // same value.\n  if (!TautologicalTypeCompare && OtherValueRange.Width == 0)\n    return false;\n\n  // Suppress the diagnostic for an in-range comparison if the constant comes\n  // from a macro or enumerator. We don't want to diagnose\n  //\n  //   some_long_value <= INT_MAX\n  //\n  // when sizeof(int) == sizeof(long).\n  bool InRange = Cmp & PromotedRange::InRangeFlag;\n  if (InRange && IsEnumConstOrFromMacro(S, Constant))\n    return false;\n\n  // A comparison of an unsigned bit-field against 0 is really a type problem,\n  // even though at the type level the bit-field might promote to 'signed int'.\n  if (Other->refersToBitField() && InRange && Value == 0 &&\n      Other->getType()->isUnsignedIntegerOrEnumerationType())\n    TautologicalTypeCompare = true;\n\n  // If this is a comparison to an enum constant, include that\n  // constant in the diagnostic.\n  const EnumConstantDecl *ED = nullptr;\n  if (const DeclRefExpr *DR = dyn_cast<DeclRefExpr>(Constant))\n    ED = dyn_cast<EnumConstantDecl>(DR->getDecl());\n\n  // Should be enough for uint128 (39 decimal digits)\n  SmallString<64> PrettySourceValue;\n  llvm::raw_svector_ostream OS(PrettySourceValue);\n  if (ED) {\n    OS << '\\'' << *ED << \"' (\" << Value << \")\";\n  } else if (auto *BL = dyn_cast<ObjCBoolLiteralExpr>(\n               Constant->IgnoreParenImpCasts())) {\n    OS << (BL->getValue() ? \"YES\" : \"NO\");\n  } else {\n    OS << Value;\n  }\n\n  if (!TautologicalTypeCompare) {\n    S.Diag(E->getOperatorLoc(), diag::warn_tautological_compare_value_range)\n        << RhsConstant << OtherValueRange.Width << OtherValueRange.NonNegative\n        << E->getOpcodeStr() << OS.str() << *Result\n        << E->getLHS()->getSourceRange() << E->getRHS()->getSourceRange();\n    return true;\n  }\n\n  if (IsObjCSignedCharBool) {\n    S.DiagRuntimeBehavior(E->getOperatorLoc(), E,\n                          S.PDiag(diag::warn_tautological_compare_objc_bool)\n                              << OS.str() << *Result);\n    return true;\n  }\n\n  // FIXME: We use a somewhat different formatting for the in-range cases and\n  // cases involving boolean values for historical reasons. We should pick a\n  // consistent way of presenting these diagnostics.\n  if (!InRange || Other->isKnownToHaveBooleanValue()) {\n\n    S.DiagRuntimeBehavior(\n        E->getOperatorLoc(), E,\n        S.PDiag(!InRange ? diag::warn_out_of_range_compare\n                         : diag::warn_tautological_bool_compare)\n            << OS.str() << classifyConstantValue(Constant) << OtherT\n            << OtherIsBooleanDespiteType << *Result\n            << E->getLHS()->getSourceRange() << E->getRHS()->getSourceRange());\n  } else {\n    unsigned Diag = (isKnownToHaveUnsignedValue(OriginalOther) && Value == 0)\n                        ? (HasEnumType(OriginalOther)\n                               ? diag::warn_unsigned_enum_always_true_comparison\n                               : diag::warn_unsigned_always_true_comparison)\n                        : diag::warn_tautological_constant_compare;\n\n    S.Diag(E->getOperatorLoc(), Diag)\n        << RhsConstant << OtherT << E->getOpcodeStr() << OS.str() << *Result\n        << E->getLHS()->getSourceRange() << E->getRHS()->getSourceRange();\n  }\n\n  return true;\n}\n\n/// Analyze the operands of the given comparison.  Implements the\n/// fallback case from AnalyzeComparison.\nstatic void AnalyzeImpConvsInComparison(Sema &S, BinaryOperator *E) {\n  AnalyzeImplicitConversions(S, E->getLHS(), E->getOperatorLoc());\n  AnalyzeImplicitConversions(S, E->getRHS(), E->getOperatorLoc());\n}\n\n/// Implements -Wsign-compare.\n///\n/// \\param E the binary operator to check for warnings\nstatic void AnalyzeComparison(Sema &S, BinaryOperator *E) {\n  // The type the comparison is being performed in.\n  QualType T = E->getLHS()->getType();\n\n  // Only analyze comparison operators where both sides have been converted to\n  // the same type.\n  if (!S.Context.hasSameUnqualifiedType(T, E->getRHS()->getType()))\n    return AnalyzeImpConvsInComparison(S, E);\n\n  // Don't analyze value-dependent comparisons directly.\n  if (E->isValueDependent())\n    return AnalyzeImpConvsInComparison(S, E);\n\n  Expr *LHS = E->getLHS();\n  Expr *RHS = E->getRHS();\n\n  if (T->isIntegralType(S.Context)) {\n    Optional<llvm::APSInt> RHSValue = RHS->getIntegerConstantExpr(S.Context);\n    Optional<llvm::APSInt> LHSValue = LHS->getIntegerConstantExpr(S.Context);\n\n    // We don't care about expressions whose result is a constant.\n    if (RHSValue && LHSValue)\n      return AnalyzeImpConvsInComparison(S, E);\n\n    // We only care about expressions where just one side is literal\n    if ((bool)RHSValue ^ (bool)LHSValue) {\n      // Is the constant on the RHS or LHS?\n      const bool RhsConstant = (bool)RHSValue;\n      Expr *Const = RhsConstant ? RHS : LHS;\n      Expr *Other = RhsConstant ? LHS : RHS;\n      const llvm::APSInt &Value = RhsConstant ? *RHSValue : *LHSValue;\n\n      // Check whether an integer constant comparison results in a value\n      // of 'true' or 'false'.\n      if (CheckTautologicalComparison(S, E, Const, Other, Value, RhsConstant))\n        return AnalyzeImpConvsInComparison(S, E);\n    }\n  }\n\n  if (!T->hasUnsignedIntegerRepresentation()) {\n    // We don't do anything special if this isn't an unsigned integral\n    // comparison:  we're only interested in integral comparisons, and\n    // signed comparisons only happen in cases we don't care to warn about.\n    return AnalyzeImpConvsInComparison(S, E);\n  }\n\n  LHS = LHS->IgnoreParenImpCasts();\n  RHS = RHS->IgnoreParenImpCasts();\n\n  if (!S.getLangOpts().CPlusPlus) {\n    // Avoid warning about comparison of integers with different signs when\n    // RHS/LHS has a `typeof(E)` type whose sign is different from the sign of\n    // the type of `E`.\n    if (const auto *TET = dyn_cast<TypeOfExprType>(LHS->getType()))\n      LHS = TET->getUnderlyingExpr()->IgnoreParenImpCasts();\n    if (const auto *TET = dyn_cast<TypeOfExprType>(RHS->getType()))\n      RHS = TET->getUnderlyingExpr()->IgnoreParenImpCasts();\n  }\n\n  // Check to see if one of the (unmodified) operands is of different\n  // signedness.\n  Expr *signedOperand, *unsignedOperand;\n  if (LHS->getType()->hasSignedIntegerRepresentation()) {\n    assert(!RHS->getType()->hasSignedIntegerRepresentation() &&\n           \"unsigned comparison between two signed integer expressions?\");\n    signedOperand = LHS;\n    unsignedOperand = RHS;\n  } else if (RHS->getType()->hasSignedIntegerRepresentation()) {\n    signedOperand = RHS;\n    unsignedOperand = LHS;\n  } else {\n    return AnalyzeImpConvsInComparison(S, E);\n  }\n\n  // Otherwise, calculate the effective range of the signed operand.\n  IntRange signedRange = GetExprRange(\n      S.Context, signedOperand, S.isConstantEvaluated(), /*Approximate*/ true);\n\n  // Go ahead and analyze implicit conversions in the operands.  Note\n  // that we skip the implicit conversions on both sides.\n  AnalyzeImplicitConversions(S, LHS, E->getOperatorLoc());\n  AnalyzeImplicitConversions(S, RHS, E->getOperatorLoc());\n\n  // If the signed range is non-negative, -Wsign-compare won't fire.\n  if (signedRange.NonNegative)\n    return;\n\n  // For (in)equality comparisons, if the unsigned operand is a\n  // constant which cannot collide with a overflowed signed operand,\n  // then reinterpreting the signed operand as unsigned will not\n  // change the result of the comparison.\n  if (E->isEqualityOp()) {\n    unsigned comparisonWidth = S.Context.getIntWidth(T);\n    IntRange unsignedRange =\n        GetExprRange(S.Context, unsignedOperand, S.isConstantEvaluated(),\n                     /*Approximate*/ true);\n\n    // We should never be unable to prove that the unsigned operand is\n    // non-negative.\n    assert(unsignedRange.NonNegative && \"unsigned range includes negative?\");\n\n    if (unsignedRange.Width < comparisonWidth)\n      return;\n  }\n\n  S.DiagRuntimeBehavior(E->getOperatorLoc(), E,\n                        S.PDiag(diag::warn_mixed_sign_comparison)\n                            << LHS->getType() << RHS->getType()\n                            << LHS->getSourceRange() << RHS->getSourceRange());\n}\n\n/// Analyzes an attempt to assign the given value to a bitfield.\n///\n/// Returns true if there was something fishy about the attempt.\nstatic bool AnalyzeBitFieldAssignment(Sema &S, FieldDecl *Bitfield, Expr *Init,\n                                      SourceLocation InitLoc) {\n  assert(Bitfield->isBitField());\n  if (Bitfield->isInvalidDecl())\n    return false;\n\n  // White-list bool bitfields.\n  QualType BitfieldType = Bitfield->getType();\n  if (BitfieldType->isBooleanType())\n     return false;\n\n  if (BitfieldType->isEnumeralType()) {\n    EnumDecl *BitfieldEnumDecl = BitfieldType->castAs<EnumType>()->getDecl();\n    // If the underlying enum type was not explicitly specified as an unsigned\n    // type and the enum contain only positive values, MSVC++ will cause an\n    // inconsistency by storing this as a signed type.\n    if (S.getLangOpts().CPlusPlus11 &&\n        !BitfieldEnumDecl->getIntegerTypeSourceInfo() &&\n        BitfieldEnumDecl->getNumPositiveBits() > 0 &&\n        BitfieldEnumDecl->getNumNegativeBits() == 0) {\n      S.Diag(InitLoc, diag::warn_no_underlying_type_specified_for_enum_bitfield)\n          << BitfieldEnumDecl;\n    }\n  }\n\n  if (Bitfield->getType()->isBooleanType())\n    return false;\n\n  // Ignore value- or type-dependent expressions.\n  if (Bitfield->getBitWidth()->isValueDependent() ||\n      Bitfield->getBitWidth()->isTypeDependent() ||\n      Init->isValueDependent() ||\n      Init->isTypeDependent())\n    return false;\n\n  Expr *OriginalInit = Init->IgnoreParenImpCasts();\n  unsigned FieldWidth = Bitfield->getBitWidthValue(S.Context);\n\n  Expr::EvalResult Result;\n  if (!OriginalInit->EvaluateAsInt(Result, S.Context,\n                                   Expr::SE_AllowSideEffects)) {\n    // The RHS is not constant.  If the RHS has an enum type, make sure the\n    // bitfield is wide enough to hold all the values of the enum without\n    // truncation.\n    if (const auto *EnumTy = OriginalInit->getType()->getAs<EnumType>()) {\n      EnumDecl *ED = EnumTy->getDecl();\n      bool SignedBitfield = BitfieldType->isSignedIntegerType();\n\n      // Enum types are implicitly signed on Windows, so check if there are any\n      // negative enumerators to see if the enum was intended to be signed or\n      // not.\n      bool SignedEnum = ED->getNumNegativeBits() > 0;\n\n      // Check for surprising sign changes when assigning enum values to a\n      // bitfield of different signedness.  If the bitfield is signed and we\n      // have exactly the right number of bits to store this unsigned enum,\n      // suggest changing the enum to an unsigned type. This typically happens\n      // on Windows where unfixed enums always use an underlying type of 'int'.\n      unsigned DiagID = 0;\n      if (SignedEnum && !SignedBitfield) {\n        DiagID = diag::warn_unsigned_bitfield_assigned_signed_enum;\n      } else if (SignedBitfield && !SignedEnum &&\n                 ED->getNumPositiveBits() == FieldWidth) {\n        DiagID = diag::warn_signed_bitfield_enum_conversion;\n      }\n\n      if (DiagID) {\n        S.Diag(InitLoc, DiagID) << Bitfield << ED;\n        TypeSourceInfo *TSI = Bitfield->getTypeSourceInfo();\n        SourceRange TypeRange =\n            TSI ? TSI->getTypeLoc().getSourceRange() : SourceRange();\n        S.Diag(Bitfield->getTypeSpecStartLoc(), diag::note_change_bitfield_sign)\n            << SignedEnum << TypeRange;\n      }\n\n      // Compute the required bitwidth. If the enum has negative values, we need\n      // one more bit than the normal number of positive bits to represent the\n      // sign bit.\n      unsigned BitsNeeded = SignedEnum ? std::max(ED->getNumPositiveBits() + 1,\n                                                  ED->getNumNegativeBits())\n                                       : ED->getNumPositiveBits();\n\n      // Check the bitwidth.\n      if (BitsNeeded > FieldWidth) {\n        Expr *WidthExpr = Bitfield->getBitWidth();\n        S.Diag(InitLoc, diag::warn_bitfield_too_small_for_enum)\n            << Bitfield << ED;\n        S.Diag(WidthExpr->getExprLoc(), diag::note_widen_bitfield)\n            << BitsNeeded << ED << WidthExpr->getSourceRange();\n      }\n    }\n\n    return false;\n  }\n\n  llvm::APSInt Value = Result.Val.getInt();\n\n  unsigned OriginalWidth = Value.getBitWidth();\n\n  if (!Value.isSigned() || Value.isNegative())\n    if (UnaryOperator *UO = dyn_cast<UnaryOperator>(OriginalInit))\n      if (UO->getOpcode() == UO_Minus || UO->getOpcode() == UO_Not)\n        OriginalWidth = Value.getMinSignedBits();\n\n  if (OriginalWidth <= FieldWidth)\n    return false;\n\n  // Compute the value which the bitfield will contain.\n  llvm::APSInt TruncatedValue = Value.trunc(FieldWidth);\n  TruncatedValue.setIsSigned(BitfieldType->isSignedIntegerType());\n\n  // Check whether the stored value is equal to the original value.\n  TruncatedValue = TruncatedValue.extend(OriginalWidth);\n  if (llvm::APSInt::isSameValue(Value, TruncatedValue))\n    return false;\n\n  // Special-case bitfields of width 1: booleans are naturally 0/1, and\n  // therefore don't strictly fit into a signed bitfield of width 1.\n  if (FieldWidth == 1 && Value == 1)\n    return false;\n\n  std::string PrettyValue = Value.toString(10);\n  std::string PrettyTrunc = TruncatedValue.toString(10);\n\n  S.Diag(InitLoc, diag::warn_impcast_bitfield_precision_constant)\n    << PrettyValue << PrettyTrunc << OriginalInit->getType()\n    << Init->getSourceRange();\n\n  return true;\n}\n\n/// Analyze the given simple or compound assignment for warning-worthy\n/// operations.\nstatic void AnalyzeAssignment(Sema &S, BinaryOperator *E) {\n  // Just recurse on the LHS.\n  AnalyzeImplicitConversions(S, E->getLHS(), E->getOperatorLoc());\n\n  // We want to recurse on the RHS as normal unless we're assigning to\n  // a bitfield.\n  if (FieldDecl *Bitfield = E->getLHS()->getSourceBitField()) {\n    if (AnalyzeBitFieldAssignment(S, Bitfield, E->getRHS(),\n                                  E->getOperatorLoc())) {\n      // Recurse, ignoring any implicit conversions on the RHS.\n      return AnalyzeImplicitConversions(S, E->getRHS()->IgnoreParenImpCasts(),\n                                        E->getOperatorLoc());\n    }\n  }\n\n  AnalyzeImplicitConversions(S, E->getRHS(), E->getOperatorLoc());\n\n  // Diagnose implicitly sequentially-consistent atomic assignment.\n  if (E->getLHS()->getType()->isAtomicType())\n    S.Diag(E->getRHS()->getBeginLoc(), diag::warn_atomic_implicit_seq_cst);\n}\n\n/// Diagnose an implicit cast;  purely a helper for CheckImplicitConversion.\nstatic void DiagnoseImpCast(Sema &S, Expr *E, QualType SourceType, QualType T,\n                            SourceLocation CContext, unsigned diag,\n                            bool pruneControlFlow = false) {\n  if (pruneControlFlow) {\n    S.DiagRuntimeBehavior(E->getExprLoc(), E,\n                          S.PDiag(diag)\n                              << SourceType << T << E->getSourceRange()\n                              << SourceRange(CContext));\n    return;\n  }\n  S.Diag(E->getExprLoc(), diag)\n    << SourceType << T << E->getSourceRange() << SourceRange(CContext);\n}\n\n/// Diagnose an implicit cast;  purely a helper for CheckImplicitConversion.\nstatic void DiagnoseImpCast(Sema &S, Expr *E, QualType T,\n                            SourceLocation CContext,\n                            unsigned diag, bool pruneControlFlow = false) {\n  DiagnoseImpCast(S, E, E->getType(), T, CContext, diag, pruneControlFlow);\n}\n\nstatic bool isObjCSignedCharBool(Sema &S, QualType Ty) {\n  return Ty->isSpecificBuiltinType(BuiltinType::SChar) &&\n      S.getLangOpts().ObjC && S.NSAPIObj->isObjCBOOLType(Ty);\n}\n\nstatic void adornObjCBoolConversionDiagWithTernaryFixit(\n    Sema &S, Expr *SourceExpr, const Sema::SemaDiagnosticBuilder &Builder) {\n  Expr *Ignored = SourceExpr->IgnoreImplicit();\n  if (const auto *OVE = dyn_cast<OpaqueValueExpr>(Ignored))\n    Ignored = OVE->getSourceExpr();\n  bool NeedsParens = isa<AbstractConditionalOperator>(Ignored) ||\n                     isa<BinaryOperator>(Ignored) ||\n                     isa<CXXOperatorCallExpr>(Ignored);\n  SourceLocation EndLoc = S.getLocForEndOfToken(SourceExpr->getEndLoc());\n  if (NeedsParens)\n    Builder << FixItHint::CreateInsertion(SourceExpr->getBeginLoc(), \"(\")\n            << FixItHint::CreateInsertion(EndLoc, \")\");\n  Builder << FixItHint::CreateInsertion(EndLoc, \" ? YES : NO\");\n}\n\n/// Diagnose an implicit cast from a floating point value to an integer value.\nstatic void DiagnoseFloatingImpCast(Sema &S, Expr *E, QualType T,\n                                    SourceLocation CContext) {\n  const bool IsBool = T->isSpecificBuiltinType(BuiltinType::Bool);\n  const bool PruneWarnings = S.inTemplateInstantiation();\n\n  Expr *InnerE = E->IgnoreParenImpCasts();\n  // We also want to warn on, e.g., \"int i = -1.234\"\n  if (UnaryOperator *UOp = dyn_cast<UnaryOperator>(InnerE))\n    if (UOp->getOpcode() == UO_Minus || UOp->getOpcode() == UO_Plus)\n      InnerE = UOp->getSubExpr()->IgnoreParenImpCasts();\n\n  const bool IsLiteral =\n      isa<FloatingLiteral>(E) || isa<FloatingLiteral>(InnerE);\n\n  llvm::APFloat Value(0.0);\n  bool IsConstant =\n    E->EvaluateAsFloat(Value, S.Context, Expr::SE_AllowSideEffects);\n  if (!IsConstant) {\n    if (isObjCSignedCharBool(S, T)) {\n      return adornObjCBoolConversionDiagWithTernaryFixit(\n          S, E,\n          S.Diag(CContext, diag::warn_impcast_float_to_objc_signed_char_bool)\n              << E->getType());\n    }\n\n    return DiagnoseImpCast(S, E, T, CContext,\n                           diag::warn_impcast_float_integer, PruneWarnings);\n  }\n\n  bool isExact = false;\n\n  llvm::APSInt IntegerValue(S.Context.getIntWidth(T),\n                            T->hasUnsignedIntegerRepresentation());\n  llvm::APFloat::opStatus Result = Value.convertToInteger(\n      IntegerValue, llvm::APFloat::rmTowardZero, &isExact);\n\n  // FIXME: Force the precision of the source value down so we don't print\n  // digits which are usually useless (we don't really care here if we\n  // truncate a digit by accident in edge cases).  Ideally, APFloat::toString\n  // would automatically print the shortest representation, but it's a bit\n  // tricky to implement.\n  SmallString<16> PrettySourceValue;\n  unsigned precision = llvm::APFloat::semanticsPrecision(Value.getSemantics());\n  precision = (precision * 59 + 195) / 196;\n  Value.toString(PrettySourceValue, precision);\n\n  if (isObjCSignedCharBool(S, T) && IntegerValue != 0 && IntegerValue != 1) {\n    return adornObjCBoolConversionDiagWithTernaryFixit(\n        S, E,\n        S.Diag(CContext, diag::warn_impcast_constant_value_to_objc_bool)\n            << PrettySourceValue);\n  }\n\n  if (Result == llvm::APFloat::opOK && isExact) {\n    if (IsLiteral) return;\n    return DiagnoseImpCast(S, E, T, CContext, diag::warn_impcast_float_integer,\n                           PruneWarnings);\n  }\n\n  // Conversion of a floating-point value to a non-bool integer where the\n  // integral part cannot be represented by the integer type is undefined.\n  if (!IsBool && Result == llvm::APFloat::opInvalidOp)\n    return DiagnoseImpCast(\n        S, E, T, CContext,\n        IsLiteral ? diag::warn_impcast_literal_float_to_integer_out_of_range\n                  : diag::warn_impcast_float_to_integer_out_of_range,\n        PruneWarnings);\n\n  unsigned DiagID = 0;\n  if (IsLiteral) {\n    // Warn on floating point literal to integer.\n    DiagID = diag::warn_impcast_literal_float_to_integer;\n  } else if (IntegerValue == 0) {\n    if (Value.isZero()) {  // Skip -0.0 to 0 conversion.\n      return DiagnoseImpCast(S, E, T, CContext,\n                             diag::warn_impcast_float_integer, PruneWarnings);\n    }\n    // Warn on non-zero to zero conversion.\n    DiagID = diag::warn_impcast_float_to_integer_zero;\n  } else {\n    if (IntegerValue.isUnsigned()) {\n      if (!IntegerValue.isMaxValue()) {\n        return DiagnoseImpCast(S, E, T, CContext,\n                               diag::warn_impcast_float_integer, PruneWarnings);\n      }\n    } else {  // IntegerValue.isSigned()\n      if (!IntegerValue.isMaxSignedValue() &&\n          !IntegerValue.isMinSignedValue()) {\n        return DiagnoseImpCast(S, E, T, CContext,\n                               diag::warn_impcast_float_integer, PruneWarnings);\n      }\n    }\n    // Warn on evaluatable floating point expression to integer conversion.\n    DiagID = diag::warn_impcast_float_to_integer;\n  }\n\n  SmallString<16> PrettyTargetValue;\n  if (IsBool)\n    PrettyTargetValue = Value.isZero() ? \"false\" : \"true\";\n  else\n    IntegerValue.toString(PrettyTargetValue);\n\n  if (PruneWarnings) {\n    S.DiagRuntimeBehavior(E->getExprLoc(), E,\n                          S.PDiag(DiagID)\n                              << E->getType() << T.getUnqualifiedType()\n                              << PrettySourceValue << PrettyTargetValue\n                              << E->getSourceRange() << SourceRange(CContext));\n  } else {\n    S.Diag(E->getExprLoc(), DiagID)\n        << E->getType() << T.getUnqualifiedType() << PrettySourceValue\n        << PrettyTargetValue << E->getSourceRange() << SourceRange(CContext);\n  }\n}\n\n/// Analyze the given compound assignment for the possible losing of\n/// floating-point precision.\nstatic void AnalyzeCompoundAssignment(Sema &S, BinaryOperator *E) {\n  assert(isa<CompoundAssignOperator>(E) &&\n         \"Must be compound assignment operation\");\n  // Recurse on the LHS and RHS in here\n  AnalyzeImplicitConversions(S, E->getLHS(), E->getOperatorLoc());\n  AnalyzeImplicitConversions(S, E->getRHS(), E->getOperatorLoc());\n\n  if (E->getLHS()->getType()->isAtomicType())\n    S.Diag(E->getOperatorLoc(), diag::warn_atomic_implicit_seq_cst);\n\n  // Now check the outermost expression\n  const auto *ResultBT = E->getLHS()->getType()->getAs<BuiltinType>();\n  const auto *RBT = cast<CompoundAssignOperator>(E)\n                        ->getComputationResultType()\n                        ->getAs<BuiltinType>();\n\n  // The below checks assume source is floating point.\n  if (!ResultBT || !RBT || !RBT->isFloatingPoint()) return;\n\n  // If source is floating point but target is an integer.\n  if (ResultBT->isInteger())\n    return DiagnoseImpCast(S, E, E->getRHS()->getType(), E->getLHS()->getType(),\n                           E->getExprLoc(), diag::warn_impcast_float_integer);\n\n  if (!ResultBT->isFloatingPoint())\n    return;\n\n  // If both source and target are floating points, warn about losing precision.\n  int Order = S.getASTContext().getFloatingTypeSemanticOrder(\n      QualType(ResultBT, 0), QualType(RBT, 0));\n  if (Order < 0 && !S.SourceMgr.isInSystemMacro(E->getOperatorLoc()))\n    // warn about dropping FP rank.\n    DiagnoseImpCast(S, E->getRHS(), E->getLHS()->getType(), E->getOperatorLoc(),\n                    diag::warn_impcast_float_result_precision);\n}\n\nstatic std::string PrettyPrintInRange(const llvm::APSInt &Value,\n                                      IntRange Range) {\n  if (!Range.Width) return \"0\";\n\n  llvm::APSInt ValueInRange = Value;\n  ValueInRange.setIsSigned(!Range.NonNegative);\n  ValueInRange = ValueInRange.trunc(Range.Width);\n  return ValueInRange.toString(10);\n}\n\nstatic bool IsImplicitBoolFloatConversion(Sema &S, Expr *Ex, bool ToBool) {\n  if (!isa<ImplicitCastExpr>(Ex))\n    return false;\n\n  Expr *InnerE = Ex->IgnoreParenImpCasts();\n  const Type *Target = S.Context.getCanonicalType(Ex->getType()).getTypePtr();\n  const Type *Source =\n    S.Context.getCanonicalType(InnerE->getType()).getTypePtr();\n  if (Target->isDependentType())\n    return false;\n\n  const BuiltinType *FloatCandidateBT =\n    dyn_cast<BuiltinType>(ToBool ? Source : Target);\n  const Type *BoolCandidateType = ToBool ? Target : Source;\n\n  return (BoolCandidateType->isSpecificBuiltinType(BuiltinType::Bool) &&\n          FloatCandidateBT && (FloatCandidateBT->isFloatingPoint()));\n}\n\nstatic void CheckImplicitArgumentConversions(Sema &S, CallExpr *TheCall,\n                                             SourceLocation CC) {\n  unsigned NumArgs = TheCall->getNumArgs();\n  for (unsigned i = 0; i < NumArgs; ++i) {\n    Expr *CurrA = TheCall->getArg(i);\n    if (!IsImplicitBoolFloatConversion(S, CurrA, true))\n      continue;\n\n    bool IsSwapped = ((i > 0) &&\n        IsImplicitBoolFloatConversion(S, TheCall->getArg(i - 1), false));\n    IsSwapped |= ((i < (NumArgs - 1)) &&\n        IsImplicitBoolFloatConversion(S, TheCall->getArg(i + 1), false));\n    if (IsSwapped) {\n      // Warn on this floating-point to bool conversion.\n      DiagnoseImpCast(S, CurrA->IgnoreParenImpCasts(),\n                      CurrA->getType(), CC,\n                      diag::warn_impcast_floating_point_to_bool);\n    }\n  }\n}\n\nstatic void DiagnoseNullConversion(Sema &S, Expr *E, QualType T,\n                                   SourceLocation CC) {\n  if (S.Diags.isIgnored(diag::warn_impcast_null_pointer_to_integer,\n                        E->getExprLoc()))\n    return;\n\n  // Don't warn on functions which have return type nullptr_t.\n  if (isa<CallExpr>(E))\n    return;\n\n  // Check for NULL (GNUNull) or nullptr (CXX11_nullptr).\n  const Expr::NullPointerConstantKind NullKind =\n      E->isNullPointerConstant(S.Context, Expr::NPC_ValueDependentIsNotNull);\n  if (NullKind != Expr::NPCK_GNUNull && NullKind != Expr::NPCK_CXX11_nullptr)\n    return;\n\n  // Return if target type is a safe conversion.\n  if (T->isAnyPointerType() || T->isBlockPointerType() ||\n      T->isMemberPointerType() || !T->isScalarType() || T->isNullPtrType())\n    return;\n\n  SourceLocation Loc = E->getSourceRange().getBegin();\n\n  // Venture through the macro stacks to get to the source of macro arguments.\n  // The new location is a better location than the complete location that was\n  // passed in.\n  Loc = S.SourceMgr.getTopMacroCallerLoc(Loc);\n  CC = S.SourceMgr.getTopMacroCallerLoc(CC);\n\n  // __null is usually wrapped in a macro.  Go up a macro if that is the case.\n  if (NullKind == Expr::NPCK_GNUNull && Loc.isMacroID()) {\n    StringRef MacroName = Lexer::getImmediateMacroNameForDiagnostics(\n        Loc, S.SourceMgr, S.getLangOpts());\n    if (MacroName == \"NULL\")\n      Loc = S.SourceMgr.getImmediateExpansionRange(Loc).getBegin();\n  }\n\n  // Only warn if the null and context location are in the same macro expansion.\n  if (S.SourceMgr.getFileID(Loc) != S.SourceMgr.getFileID(CC))\n    return;\n\n  S.Diag(Loc, diag::warn_impcast_null_pointer_to_integer)\n      << (NullKind == Expr::NPCK_CXX11_nullptr) << T << SourceRange(CC)\n      << FixItHint::CreateReplacement(Loc,\n                                      S.getFixItZeroLiteralForType(T, Loc));\n}\n\nstatic void checkObjCArrayLiteral(Sema &S, QualType TargetType,\n                                  ObjCArrayLiteral *ArrayLiteral);\n\nstatic void\ncheckObjCDictionaryLiteral(Sema &S, QualType TargetType,\n                           ObjCDictionaryLiteral *DictionaryLiteral);\n\n/// Check a single element within a collection literal against the\n/// target element type.\nstatic void checkObjCCollectionLiteralElement(Sema &S,\n                                              QualType TargetElementType,\n                                              Expr *Element,\n                                              unsigned ElementKind) {\n  // Skip a bitcast to 'id' or qualified 'id'.\n  if (auto ICE = dyn_cast<ImplicitCastExpr>(Element)) {\n    if (ICE->getCastKind() == CK_BitCast &&\n        ICE->getSubExpr()->getType()->getAs<ObjCObjectPointerType>())\n      Element = ICE->getSubExpr();\n  }\n\n  QualType ElementType = Element->getType();\n  ExprResult ElementResult(Element);\n  if (ElementType->getAs<ObjCObjectPointerType>() &&\n      S.CheckSingleAssignmentConstraints(TargetElementType,\n                                         ElementResult,\n                                         false, false)\n        != Sema::Compatible) {\n    S.Diag(Element->getBeginLoc(), diag::warn_objc_collection_literal_element)\n        << ElementType << ElementKind << TargetElementType\n        << Element->getSourceRange();\n  }\n\n  if (auto ArrayLiteral = dyn_cast<ObjCArrayLiteral>(Element))\n    checkObjCArrayLiteral(S, TargetElementType, ArrayLiteral);\n  else if (auto DictionaryLiteral = dyn_cast<ObjCDictionaryLiteral>(Element))\n    checkObjCDictionaryLiteral(S, TargetElementType, DictionaryLiteral);\n}\n\n/// Check an Objective-C array literal being converted to the given\n/// target type.\nstatic void checkObjCArrayLiteral(Sema &S, QualType TargetType,\n                                  ObjCArrayLiteral *ArrayLiteral) {\n  if (!S.NSArrayDecl)\n    return;\n\n  const auto *TargetObjCPtr = TargetType->getAs<ObjCObjectPointerType>();\n  if (!TargetObjCPtr)\n    return;\n\n  if (TargetObjCPtr->isUnspecialized() ||\n      TargetObjCPtr->getInterfaceDecl()->getCanonicalDecl()\n        != S.NSArrayDecl->getCanonicalDecl())\n    return;\n\n  auto TypeArgs = TargetObjCPtr->getTypeArgs();\n  if (TypeArgs.size() != 1)\n    return;\n\n  QualType TargetElementType = TypeArgs[0];\n  for (unsigned I = 0, N = ArrayLiteral->getNumElements(); I != N; ++I) {\n    checkObjCCollectionLiteralElement(S, TargetElementType,\n                                      ArrayLiteral->getElement(I),\n                                      0);\n  }\n}\n\n/// Check an Objective-C dictionary literal being converted to the given\n/// target type.\nstatic void\ncheckObjCDictionaryLiteral(Sema &S, QualType TargetType,\n                           ObjCDictionaryLiteral *DictionaryLiteral) {\n  if (!S.NSDictionaryDecl)\n    return;\n\n  const auto *TargetObjCPtr = TargetType->getAs<ObjCObjectPointerType>();\n  if (!TargetObjCPtr)\n    return;\n\n  if (TargetObjCPtr->isUnspecialized() ||\n      TargetObjCPtr->getInterfaceDecl()->getCanonicalDecl()\n        != S.NSDictionaryDecl->getCanonicalDecl())\n    return;\n\n  auto TypeArgs = TargetObjCPtr->getTypeArgs();\n  if (TypeArgs.size() != 2)\n    return;\n\n  QualType TargetKeyType = TypeArgs[0];\n  QualType TargetObjectType = TypeArgs[1];\n  for (unsigned I = 0, N = DictionaryLiteral->getNumElements(); I != N; ++I) {\n    auto Element = DictionaryLiteral->getKeyValueElement(I);\n    checkObjCCollectionLiteralElement(S, TargetKeyType, Element.Key, 1);\n    checkObjCCollectionLiteralElement(S, TargetObjectType, Element.Value, 2);\n  }\n}\n\n// Helper function to filter out cases for constant width constant conversion.\n// Don't warn on char array initialization or for non-decimal values.\nstatic bool isSameWidthConstantConversion(Sema &S, Expr *E, QualType T,\n                                          SourceLocation CC) {\n  // If initializing from a constant, and the constant starts with '0',\n  // then it is a binary, octal, or hexadecimal.  Allow these constants\n  // to fill all the bits, even if there is a sign change.\n  if (auto *IntLit = dyn_cast<IntegerLiteral>(E->IgnoreParenImpCasts())) {\n    const char FirstLiteralCharacter =\n        S.getSourceManager().getCharacterData(IntLit->getBeginLoc())[0];\n    if (FirstLiteralCharacter == '0')\n      return false;\n  }\n\n  // If the CC location points to a '{', and the type is char, then assume\n  // assume it is an array initialization.\n  if (CC.isValid() && T->isCharType()) {\n    const char FirstContextCharacter =\n        S.getSourceManager().getCharacterData(CC)[0];\n    if (FirstContextCharacter == '{')\n      return false;\n  }\n\n  return true;\n}\n\nstatic const IntegerLiteral *getIntegerLiteral(Expr *E) {\n  const auto *IL = dyn_cast<IntegerLiteral>(E);\n  if (!IL) {\n    if (auto *UO = dyn_cast<UnaryOperator>(E)) {\n      if (UO->getOpcode() == UO_Minus)\n        return dyn_cast<IntegerLiteral>(UO->getSubExpr());\n    }\n  }\n\n  return IL;\n}\n\nstatic void DiagnoseIntInBoolContext(Sema &S, Expr *E) {\n  E = E->IgnoreParenImpCasts();\n  SourceLocation ExprLoc = E->getExprLoc();\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n    BinaryOperator::Opcode Opc = BO->getOpcode();\n    Expr::EvalResult Result;\n    // Do not diagnose unsigned shifts.\n    if (Opc == BO_Shl) {\n      const auto *LHS = getIntegerLiteral(BO->getLHS());\n      const auto *RHS = getIntegerLiteral(BO->getRHS());\n      if (LHS && LHS->getValue() == 0)\n        S.Diag(ExprLoc, diag::warn_left_shift_always) << 0;\n      else if (!E->isValueDependent() && LHS && RHS &&\n               RHS->getValue().isNonNegative() &&\n               E->EvaluateAsInt(Result, S.Context, Expr::SE_AllowSideEffects))\n        S.Diag(ExprLoc, diag::warn_left_shift_always)\n            << (Result.Val.getInt() != 0);\n      else if (E->getType()->isSignedIntegerType())\n        S.Diag(ExprLoc, diag::warn_left_shift_in_bool_context) << E;\n    }\n  }\n\n  if (const auto *CO = dyn_cast<ConditionalOperator>(E)) {\n    const auto *LHS = getIntegerLiteral(CO->getTrueExpr());\n    const auto *RHS = getIntegerLiteral(CO->getFalseExpr());\n    if (!LHS || !RHS)\n      return;\n    if ((LHS->getValue() == 0 || LHS->getValue() == 1) &&\n        (RHS->getValue() == 0 || RHS->getValue() == 1))\n      // Do not diagnose common idioms.\n      return;\n    if (LHS->getValue() != 0 && RHS->getValue() != 0)\n      S.Diag(ExprLoc, diag::warn_integer_constants_in_conditional_always_true);\n  }\n}\n\nstatic void CheckImplicitConversion(Sema &S, Expr *E, QualType T,\n                                    SourceLocation CC,\n                                    bool *ICContext = nullptr,\n                                    bool IsListInit = false) {\n  if (E->isTypeDependent() || E->isValueDependent()) return;\n\n  const Type *Source = S.Context.getCanonicalType(E->getType()).getTypePtr();\n  const Type *Target = S.Context.getCanonicalType(T).getTypePtr();\n  if (Source == Target) return;\n  if (Target->isDependentType()) return;\n\n  // If the conversion context location is invalid don't complain. We also\n  // don't want to emit a warning if the issue occurs from the expansion of\n  // a system macro. The problem is that 'getSpellingLoc()' is slow, so we\n  // delay this check as long as possible. Once we detect we are in that\n  // scenario, we just return.\n  if (CC.isInvalid())\n    return;\n\n  if (Source->isAtomicType())\n    S.Diag(E->getExprLoc(), diag::warn_atomic_implicit_seq_cst);\n\n  // Diagnose implicit casts to bool.\n  if (Target->isSpecificBuiltinType(BuiltinType::Bool)) {\n    if (isa<StringLiteral>(E))\n      // Warn on string literal to bool.  Checks for string literals in logical\n      // and expressions, for instance, assert(0 && \"error here\"), are\n      // prevented by a check in AnalyzeImplicitConversions().\n      return DiagnoseImpCast(S, E, T, CC,\n                             diag::warn_impcast_string_literal_to_bool);\n    if (isa<ObjCStringLiteral>(E) || isa<ObjCArrayLiteral>(E) ||\n        isa<ObjCDictionaryLiteral>(E) || isa<ObjCBoxedExpr>(E)) {\n      // This covers the literal expressions that evaluate to Objective-C\n      // objects.\n      return DiagnoseImpCast(S, E, T, CC,\n                             diag::warn_impcast_objective_c_literal_to_bool);\n    }\n    if (Source->isPointerType() || Source->canDecayToPointerType()) {\n      // Warn on pointer to bool conversion that is always true.\n      S.DiagnoseAlwaysNonNullPointer(E, Expr::NPCK_NotNull, /*IsEqual*/ false,\n                                     SourceRange(CC));\n    }\n  }\n\n  // If the we're converting a constant to an ObjC BOOL on a platform where BOOL\n  // is a typedef for signed char (macOS), then that constant value has to be 1\n  // or 0.\n  if (isObjCSignedCharBool(S, T) && Source->isIntegralType(S.Context)) {\n    Expr::EvalResult Result;\n    if (E->EvaluateAsInt(Result, S.getASTContext(),\n                         Expr::SE_AllowSideEffects)) {\n      if (Result.Val.getInt() != 1 && Result.Val.getInt() != 0) {\n        adornObjCBoolConversionDiagWithTernaryFixit(\n            S, E,\n            S.Diag(CC, diag::warn_impcast_constant_value_to_objc_bool)\n                << Result.Val.getInt().toString(10));\n      }\n      return;\n    }\n  }\n\n  // Check implicit casts from Objective-C collection literals to specialized\n  // collection types, e.g., NSArray<NSString *> *.\n  if (auto *ArrayLiteral = dyn_cast<ObjCArrayLiteral>(E))\n    checkObjCArrayLiteral(S, QualType(Target, 0), ArrayLiteral);\n  else if (auto *DictionaryLiteral = dyn_cast<ObjCDictionaryLiteral>(E))\n    checkObjCDictionaryLiteral(S, QualType(Target, 0), DictionaryLiteral);\n\n  // Strip vector types.\n  if (const auto *SourceVT = dyn_cast<VectorType>(Source)) {\n    if (Target->isVLSTBuiltinType()) {\n      auto SourceVectorKind = SourceVT->getVectorKind();\n      if (SourceVectorKind == VectorType::SveFixedLengthDataVector ||\n          SourceVectorKind == VectorType::SveFixedLengthPredicateVector ||\n          (SourceVectorKind == VectorType::GenericVector &&\n           S.Context.getTypeSize(Source) == S.getLangOpts().ArmSveVectorBits))\n        return;\n    }\n\n    if (!isa<VectorType>(Target)) {\n      if (S.SourceMgr.isInSystemMacro(CC))\n        return;\n      return DiagnoseImpCast(S, E, T, CC, diag::warn_impcast_vector_scalar);\n    }\n\n    // If the vector cast is cast between two vectors of the same size, it is\n    // a bitcast, not a conversion.\n    if (S.Context.getTypeSize(Source) == S.Context.getTypeSize(Target))\n      return;\n\n    Source = cast<VectorType>(Source)->getElementType().getTypePtr();\n    Target = cast<VectorType>(Target)->getElementType().getTypePtr();\n  }\n  if (auto VecTy = dyn_cast<VectorType>(Target))\n    Target = VecTy->getElementType().getTypePtr();\n\n  // Strip complex types.\n  if (isa<ComplexType>(Source)) {\n    if (!isa<ComplexType>(Target)) {\n      if (S.SourceMgr.isInSystemMacro(CC) || Target->isBooleanType())\n        return;\n\n      return DiagnoseImpCast(S, E, T, CC,\n                             S.getLangOpts().CPlusPlus\n                                 ? diag::err_impcast_complex_scalar\n                                 : diag::warn_impcast_complex_scalar);\n    }\n\n    Source = cast<ComplexType>(Source)->getElementType().getTypePtr();\n    Target = cast<ComplexType>(Target)->getElementType().getTypePtr();\n  }\n\n  const BuiltinType *SourceBT = dyn_cast<BuiltinType>(Source);\n  const BuiltinType *TargetBT = dyn_cast<BuiltinType>(Target);\n\n  // If the source is floating point...\n  if (SourceBT && SourceBT->isFloatingPoint()) {\n    // ...and the target is floating point...\n    if (TargetBT && TargetBT->isFloatingPoint()) {\n      // ...then warn if we're dropping FP rank.\n\n      int Order = S.getASTContext().getFloatingTypeSemanticOrder(\n          QualType(SourceBT, 0), QualType(TargetBT, 0));\n      if (Order > 0) {\n        // Don't warn about float constants that are precisely\n        // representable in the target type.\n        Expr::EvalResult result;\n        if (E->EvaluateAsRValue(result, S.Context)) {\n          // Value might be a float, a float vector, or a float complex.\n          if (IsSameFloatAfterCast(result.Val,\n                   S.Context.getFloatTypeSemantics(QualType(TargetBT, 0)),\n                   S.Context.getFloatTypeSemantics(QualType(SourceBT, 0))))\n            return;\n        }\n\n        if (S.SourceMgr.isInSystemMacro(CC))\n          return;\n\n        DiagnoseImpCast(S, E, T, CC, diag::warn_impcast_float_precision);\n      }\n      // ... or possibly if we're increasing rank, too\n      else if (Order < 0) {\n        if (S.SourceMgr.isInSystemMacro(CC))\n          return;\n\n        DiagnoseImpCast(S, E, T, CC, diag::warn_impcast_double_promotion);\n      }\n      return;\n    }\n\n    // If the target is integral, always warn.\n    if (TargetBT && TargetBT->isInteger()) {\n      if (S.SourceMgr.isInSystemMacro(CC))\n        return;\n\n      DiagnoseFloatingImpCast(S, E, T, CC);\n    }\n\n    // Detect the case where a call result is converted from floating-point to\n    // to bool, and the final argument to the call is converted from bool, to\n    // discover this typo:\n    //\n    //    bool b = fabs(x < 1.0);  // should be \"bool b = fabs(x) < 1.0;\"\n    //\n    // FIXME: This is an incredibly special case; is there some more general\n    // way to detect this class of misplaced-parentheses bug?\n    if (Target->isBooleanType() && isa<CallExpr>(E)) {\n      // Check last argument of function call to see if it is an\n      // implicit cast from a type matching the type the result\n      // is being cast to.\n      CallExpr *CEx = cast<CallExpr>(E);\n      if (unsigned NumArgs = CEx->getNumArgs()) {\n        Expr *LastA = CEx->getArg(NumArgs - 1);\n        Expr *InnerE = LastA->IgnoreParenImpCasts();\n        if (isa<ImplicitCastExpr>(LastA) &&\n            InnerE->getType()->isBooleanType()) {\n          // Warn on this floating-point to bool conversion\n          DiagnoseImpCast(S, E, T, CC,\n                          diag::warn_impcast_floating_point_to_bool);\n        }\n      }\n    }\n    return;\n  }\n\n  // Valid casts involving fixed point types should be accounted for here.\n  if (Source->isFixedPointType()) {\n    if (Target->isUnsaturatedFixedPointType()) {\n      Expr::EvalResult Result;\n      if (E->EvaluateAsFixedPoint(Result, S.Context, Expr::SE_AllowSideEffects,\n                                  S.isConstantEvaluated())) {\n        llvm::APFixedPoint Value = Result.Val.getFixedPoint();\n        llvm::APFixedPoint MaxVal = S.Context.getFixedPointMax(T);\n        llvm::APFixedPoint MinVal = S.Context.getFixedPointMin(T);\n        if (Value > MaxVal || Value < MinVal) {\n          S.DiagRuntimeBehavior(E->getExprLoc(), E,\n                                S.PDiag(diag::warn_impcast_fixed_point_range)\n                                    << Value.toString() << T\n                                    << E->getSourceRange()\n                                    << clang::SourceRange(CC));\n          return;\n        }\n      }\n    } else if (Target->isIntegerType()) {\n      Expr::EvalResult Result;\n      if (!S.isConstantEvaluated() &&\n          E->EvaluateAsFixedPoint(Result, S.Context,\n                                  Expr::SE_AllowSideEffects)) {\n        llvm::APFixedPoint FXResult = Result.Val.getFixedPoint();\n\n        bool Overflowed;\n        llvm::APSInt IntResult = FXResult.convertToInt(\n            S.Context.getIntWidth(T),\n            Target->isSignedIntegerOrEnumerationType(), &Overflowed);\n\n        if (Overflowed) {\n          S.DiagRuntimeBehavior(E->getExprLoc(), E,\n                                S.PDiag(diag::warn_impcast_fixed_point_range)\n                                    << FXResult.toString() << T\n                                    << E->getSourceRange()\n                                    << clang::SourceRange(CC));\n          return;\n        }\n      }\n    }\n  } else if (Target->isUnsaturatedFixedPointType()) {\n    if (Source->isIntegerType()) {\n      Expr::EvalResult Result;\n      if (!S.isConstantEvaluated() &&\n          E->EvaluateAsInt(Result, S.Context, Expr::SE_AllowSideEffects)) {\n        llvm::APSInt Value = Result.Val.getInt();\n\n        bool Overflowed;\n        llvm::APFixedPoint IntResult = llvm::APFixedPoint::getFromIntValue(\n            Value, S.Context.getFixedPointSemantics(T), &Overflowed);\n\n        if (Overflowed) {\n          S.DiagRuntimeBehavior(E->getExprLoc(), E,\n                                S.PDiag(diag::warn_impcast_fixed_point_range)\n                                    << Value.toString(/*Radix=*/10) << T\n                                    << E->getSourceRange()\n                                    << clang::SourceRange(CC));\n          return;\n        }\n      }\n    }\n  }\n\n  // If we are casting an integer type to a floating point type without\n  // initialization-list syntax, we might lose accuracy if the floating\n  // point type has a narrower significand than the integer type.\n  if (SourceBT && TargetBT && SourceBT->isIntegerType() &&\n      TargetBT->isFloatingType() && !IsListInit) {\n    // Determine the number of precision bits in the source integer type.\n    IntRange SourceRange = GetExprRange(S.Context, E, S.isConstantEvaluated(),\n                                        /*Approximate*/ true);\n    unsigned int SourcePrecision = SourceRange.Width;\n\n    // Determine the number of precision bits in the\n    // target floating point type.\n    unsigned int TargetPrecision = llvm::APFloatBase::semanticsPrecision(\n        S.Context.getFloatTypeSemantics(QualType(TargetBT, 0)));\n\n    if (SourcePrecision > 0 && TargetPrecision > 0 &&\n        SourcePrecision > TargetPrecision) {\n\n      if (Optional<llvm::APSInt> SourceInt =\n              E->getIntegerConstantExpr(S.Context)) {\n        // If the source integer is a constant, convert it to the target\n        // floating point type. Issue a warning if the value changes\n        // during the whole conversion.\n        llvm::APFloat TargetFloatValue(\n            S.Context.getFloatTypeSemantics(QualType(TargetBT, 0)));\n        llvm::APFloat::opStatus ConversionStatus =\n            TargetFloatValue.convertFromAPInt(\n                *SourceInt, SourceBT->isSignedInteger(),\n                llvm::APFloat::rmNearestTiesToEven);\n\n        if (ConversionStatus != llvm::APFloat::opOK) {\n          std::string PrettySourceValue = SourceInt->toString(10);\n          SmallString<32> PrettyTargetValue;\n          TargetFloatValue.toString(PrettyTargetValue, TargetPrecision);\n\n          S.DiagRuntimeBehavior(\n              E->getExprLoc(), E,\n              S.PDiag(diag::warn_impcast_integer_float_precision_constant)\n                  << PrettySourceValue << PrettyTargetValue << E->getType() << T\n                  << E->getSourceRange() << clang::SourceRange(CC));\n        }\n      } else {\n        // Otherwise, the implicit conversion may lose precision.\n        DiagnoseImpCast(S, E, T, CC,\n                        diag::warn_impcast_integer_float_precision);\n      }\n    }\n  }\n\n  DiagnoseNullConversion(S, E, T, CC);\n\n  S.DiscardMisalignedMemberAddress(Target, E);\n\n  if (Target->isBooleanType())\n    DiagnoseIntInBoolContext(S, E);\n\n  if (!Source->isIntegerType() || !Target->isIntegerType())\n    return;\n\n  // TODO: remove this early return once the false positives for constant->bool\n  // in templates, macros, etc, are reduced or removed.\n  if (Target->isSpecificBuiltinType(BuiltinType::Bool))\n    return;\n\n  if (isObjCSignedCharBool(S, T) && !Source->isCharType() &&\n      !E->isKnownToHaveBooleanValue(/*Semantic=*/false)) {\n    return adornObjCBoolConversionDiagWithTernaryFixit(\n        S, E,\n        S.Diag(CC, diag::warn_impcast_int_to_objc_signed_char_bool)\n            << E->getType());\n  }\n\n  IntRange SourceTypeRange =\n      IntRange::forTargetOfCanonicalType(S.Context, Source);\n  IntRange LikelySourceRange =\n      GetExprRange(S.Context, E, S.isConstantEvaluated(), /*Approximate*/ true);\n  IntRange TargetRange = IntRange::forTargetOfCanonicalType(S.Context, Target);\n\n  if (LikelySourceRange.Width > TargetRange.Width) {\n    // If the source is a constant, use a default-on diagnostic.\n    // TODO: this should happen for bitfield stores, too.\n    Expr::EvalResult Result;\n    if (E->EvaluateAsInt(Result, S.Context, Expr::SE_AllowSideEffects,\n                         S.isConstantEvaluated())) {\n      llvm::APSInt Value(32);\n      Value = Result.Val.getInt();\n\n      if (S.SourceMgr.isInSystemMacro(CC))\n        return;\n\n      std::string PrettySourceValue = Value.toString(10);\n      std::string PrettyTargetValue = PrettyPrintInRange(Value, TargetRange);\n\n      S.DiagRuntimeBehavior(\n          E->getExprLoc(), E,\n          S.PDiag(diag::warn_impcast_integer_precision_constant)\n              << PrettySourceValue << PrettyTargetValue << E->getType() << T\n              << E->getSourceRange() << SourceRange(CC));\n      return;\n    }\n\n    // People want to build with -Wshorten-64-to-32 and not -Wconversion.\n    if (S.SourceMgr.isInSystemMacro(CC))\n      return;\n\n    if (TargetRange.Width == 32 && S.Context.getIntWidth(E->getType()) == 64)\n      return DiagnoseImpCast(S, E, T, CC, diag::warn_impcast_integer_64_32,\n                             /* pruneControlFlow */ true);\n    return DiagnoseImpCast(S, E, T, CC, diag::warn_impcast_integer_precision);\n  }\n\n  if (TargetRange.Width > SourceTypeRange.Width) {\n    if (auto *UO = dyn_cast<UnaryOperator>(E))\n      if (UO->getOpcode() == UO_Minus)\n        if (Source->isUnsignedIntegerType()) {\n          if (Target->isUnsignedIntegerType())\n            return DiagnoseImpCast(S, E, T, CC,\n                                   diag::warn_impcast_high_order_zero_bits);\n          if (Target->isSignedIntegerType())\n            return DiagnoseImpCast(S, E, T, CC,\n                                   diag::warn_impcast_nonnegative_result);\n        }\n  }\n\n  if (TargetRange.Width == LikelySourceRange.Width &&\n      !TargetRange.NonNegative && LikelySourceRange.NonNegative &&\n      Source->isSignedIntegerType()) {\n    // Warn when doing a signed to signed conversion, warn if the positive\n    // source value is exactly the width of the target type, which will\n    // cause a negative value to be stored.\n\n    Expr::EvalResult Result;\n    if (E->EvaluateAsInt(Result, S.Context, Expr::SE_AllowSideEffects) &&\n        !S.SourceMgr.isInSystemMacro(CC)) {\n      llvm::APSInt Value = Result.Val.getInt();\n      if (isSameWidthConstantConversion(S, E, T, CC)) {\n        std::string PrettySourceValue = Value.toString(10);\n        std::string PrettyTargetValue = PrettyPrintInRange(Value, TargetRange);\n\n        S.DiagRuntimeBehavior(\n            E->getExprLoc(), E,\n            S.PDiag(diag::warn_impcast_integer_precision_constant)\n                << PrettySourceValue << PrettyTargetValue << E->getType() << T\n                << E->getSourceRange() << SourceRange(CC));\n        return;\n      }\n    }\n\n    // Fall through for non-constants to give a sign conversion warning.\n  }\n\n  if ((TargetRange.NonNegative && !LikelySourceRange.NonNegative) ||\n      (!TargetRange.NonNegative && LikelySourceRange.NonNegative &&\n       LikelySourceRange.Width == TargetRange.Width)) {\n    if (S.SourceMgr.isInSystemMacro(CC))\n      return;\n\n    unsigned DiagID = diag::warn_impcast_integer_sign;\n\n    // Traditionally, gcc has warned about this under -Wsign-compare.\n    // We also want to warn about it in -Wconversion.\n    // So if -Wconversion is off, use a completely identical diagnostic\n    // in the sign-compare group.\n    // The conditional-checking code will\n    if (ICContext) {\n      DiagID = diag::warn_impcast_integer_sign_conditional;\n      *ICContext = true;\n    }\n\n    return DiagnoseImpCast(S, E, T, CC, DiagID);\n  }\n\n  // Diagnose conversions between different enumeration types.\n  // In C, we pretend that the type of an EnumConstantDecl is its enumeration\n  // type, to give us better diagnostics.\n  QualType SourceType = E->getType();\n  if (!S.getLangOpts().CPlusPlus) {\n    if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E))\n      if (EnumConstantDecl *ECD = dyn_cast<EnumConstantDecl>(DRE->getDecl())) {\n        EnumDecl *Enum = cast<EnumDecl>(ECD->getDeclContext());\n        SourceType = S.Context.getTypeDeclType(Enum);\n        Source = S.Context.getCanonicalType(SourceType).getTypePtr();\n      }\n  }\n\n  if (const EnumType *SourceEnum = Source->getAs<EnumType>())\n    if (const EnumType *TargetEnum = Target->getAs<EnumType>())\n      if (SourceEnum->getDecl()->hasNameForLinkage() &&\n          TargetEnum->getDecl()->hasNameForLinkage() &&\n          SourceEnum != TargetEnum) {\n        if (S.SourceMgr.isInSystemMacro(CC))\n          return;\n\n        return DiagnoseImpCast(S, E, SourceType, T, CC,\n                               diag::warn_impcast_different_enum_types);\n      }\n}\n\nstatic void CheckConditionalOperator(Sema &S, AbstractConditionalOperator *E,\n                                     SourceLocation CC, QualType T);\n\nstatic void CheckConditionalOperand(Sema &S, Expr *E, QualType T,\n                                    SourceLocation CC, bool &ICContext) {\n  E = E->IgnoreParenImpCasts();\n\n  if (auto *CO = dyn_cast<AbstractConditionalOperator>(E))\n    return CheckConditionalOperator(S, CO, CC, T);\n\n  AnalyzeImplicitConversions(S, E, CC);\n  if (E->getType() != T)\n    return CheckImplicitConversion(S, E, T, CC, &ICContext);\n}\n\nstatic void CheckConditionalOperator(Sema &S, AbstractConditionalOperator *E,\n                                     SourceLocation CC, QualType T) {\n  AnalyzeImplicitConversions(S, E->getCond(), E->getQuestionLoc());\n\n  Expr *TrueExpr = E->getTrueExpr();\n  if (auto *BCO = dyn_cast<BinaryConditionalOperator>(E))\n    TrueExpr = BCO->getCommon();\n\n  bool Suspicious = false;\n  CheckConditionalOperand(S, TrueExpr, T, CC, Suspicious);\n  CheckConditionalOperand(S, E->getFalseExpr(), T, CC, Suspicious);\n\n  if (T->isBooleanType())\n    DiagnoseIntInBoolContext(S, E);\n\n  // If -Wconversion would have warned about either of the candidates\n  // for a signedness conversion to the context type...\n  if (!Suspicious) return;\n\n  // ...but it's currently ignored...\n  if (!S.Diags.isIgnored(diag::warn_impcast_integer_sign_conditional, CC))\n    return;\n\n  // ...then check whether it would have warned about either of the\n  // candidates for a signedness conversion to the condition type.\n  if (E->getType() == T) return;\n\n  Suspicious = false;\n  CheckImplicitConversion(S, TrueExpr->IgnoreParenImpCasts(),\n                          E->getType(), CC, &Suspicious);\n  if (!Suspicious)\n    CheckImplicitConversion(S, E->getFalseExpr()->IgnoreParenImpCasts(),\n                            E->getType(), CC, &Suspicious);\n}\n\n/// Check conversion of given expression to boolean.\n/// Input argument E is a logical expression.\nstatic void CheckBoolLikeConversion(Sema &S, Expr *E, SourceLocation CC) {\n  if (S.getLangOpts().Bool)\n    return;\n  if (E->IgnoreParenImpCasts()->getType()->isAtomicType())\n    return;\n  CheckImplicitConversion(S, E->IgnoreParenImpCasts(), S.Context.BoolTy, CC);\n}\n\nnamespace {\nstruct AnalyzeImplicitConversionsWorkItem {\n  Expr *E;\n  SourceLocation CC;\n  bool IsListInit;\n};\n}\n\n/// Data recursive variant of AnalyzeImplicitConversions. Subexpressions\n/// that should be visited are added to WorkList.\nstatic void AnalyzeImplicitConversions(\n    Sema &S, AnalyzeImplicitConversionsWorkItem Item,\n    llvm::SmallVectorImpl<AnalyzeImplicitConversionsWorkItem> &WorkList) {\n  Expr *OrigE = Item.E;\n  SourceLocation CC = Item.CC;\n\n  QualType T = OrigE->getType();\n  Expr *E = OrigE->IgnoreParenImpCasts();\n\n  // Propagate whether we are in a C++ list initialization expression.\n  // If so, we do not issue warnings for implicit int-float conversion\n  // precision loss, because C++11 narrowing already handles it.\n  bool IsListInit = Item.IsListInit ||\n                    (isa<InitListExpr>(OrigE) && S.getLangOpts().CPlusPlus);\n\n  if (E->isTypeDependent() || E->isValueDependent())\n    return;\n\n  Expr *SourceExpr = E;\n  // Examine, but don't traverse into the source expression of an\n  // OpaqueValueExpr, since it may have multiple parents and we don't want to\n  // emit duplicate diagnostics. Its fine to examine the form or attempt to\n  // evaluate it in the context of checking the specific conversion to T though.\n  if (auto *OVE = dyn_cast<OpaqueValueExpr>(E))\n    if (auto *Src = OVE->getSourceExpr())\n      SourceExpr = Src;\n\n  if (const auto *UO = dyn_cast<UnaryOperator>(SourceExpr))\n    if (UO->getOpcode() == UO_Not &&\n        UO->getSubExpr()->isKnownToHaveBooleanValue())\n      S.Diag(UO->getBeginLoc(), diag::warn_bitwise_negation_bool)\n          << OrigE->getSourceRange() << T->isBooleanType()\n          << FixItHint::CreateReplacement(UO->getBeginLoc(), \"!\");\n\n  // For conditional operators, we analyze the arguments as if they\n  // were being fed directly into the output.\n  if (auto *CO = dyn_cast<AbstractConditionalOperator>(SourceExpr)) {\n    CheckConditionalOperator(S, CO, CC, T);\n    return;\n  }\n\n  // Check implicit argument conversions for function calls.\n  if (CallExpr *Call = dyn_cast<CallExpr>(SourceExpr))\n    CheckImplicitArgumentConversions(S, Call, CC);\n\n  // Go ahead and check any implicit conversions we might have skipped.\n  // The non-canonical typecheck is just an optimization;\n  // CheckImplicitConversion will filter out dead implicit conversions.\n  if (SourceExpr->getType() != T)\n    CheckImplicitConversion(S, SourceExpr, T, CC, nullptr, IsListInit);\n\n  // Now continue drilling into this expression.\n\n  if (PseudoObjectExpr *POE = dyn_cast<PseudoObjectExpr>(E)) {\n    // The bound subexpressions in a PseudoObjectExpr are not reachable\n    // as transitive children.\n    // FIXME: Use a more uniform representation for this.\n    for (auto *SE : POE->semantics())\n      if (auto *OVE = dyn_cast<OpaqueValueExpr>(SE))\n        WorkList.push_back({OVE->getSourceExpr(), CC, IsListInit});\n  }\n\n  // Skip past explicit casts.\n  if (auto *CE = dyn_cast<ExplicitCastExpr>(E)) {\n    E = CE->getSubExpr()->IgnoreParenImpCasts();\n    if (!CE->getType()->isVoidType() && E->getType()->isAtomicType())\n      S.Diag(E->getBeginLoc(), diag::warn_atomic_implicit_seq_cst);\n    WorkList.push_back({E, CC, IsListInit});\n    return;\n  }\n\n  if (BinaryOperator *BO = dyn_cast<BinaryOperator>(E)) {\n    // Do a somewhat different check with comparison operators.\n    if (BO->isComparisonOp())\n      return AnalyzeComparison(S, BO);\n\n    // And with simple assignments.\n    if (BO->getOpcode() == BO_Assign)\n      return AnalyzeAssignment(S, BO);\n    // And with compound assignments.\n    if (BO->isAssignmentOp())\n      return AnalyzeCompoundAssignment(S, BO);\n  }\n\n  // These break the otherwise-useful invariant below.  Fortunately,\n  // we don't really need to recurse into them, because any internal\n  // expressions should have been analyzed already when they were\n  // built into statements.\n  if (isa<StmtExpr>(E)) return;\n\n  // Don't descend into unevaluated contexts.\n  if (isa<UnaryExprOrTypeTraitExpr>(E)) return;\n\n  // Now just recurse over the expression's children.\n  CC = E->getExprLoc();\n  BinaryOperator *BO = dyn_cast<BinaryOperator>(E);\n  bool IsLogicalAndOperator = BO && BO->getOpcode() == BO_LAnd;\n  for (Stmt *SubStmt : E->children()) {\n    Expr *ChildExpr = dyn_cast_or_null<Expr>(SubStmt);\n    if (!ChildExpr)\n      continue;\n\n    if (IsLogicalAndOperator &&\n        isa<StringLiteral>(ChildExpr->IgnoreParenImpCasts()))\n      // Ignore checking string literals that are in logical and operators.\n      // This is a common pattern for asserts.\n      continue;\n    WorkList.push_back({ChildExpr, CC, IsListInit});\n  }\n\n  if (BO && BO->isLogicalOp()) {\n    Expr *SubExpr = BO->getLHS()->IgnoreParenImpCasts();\n    if (!IsLogicalAndOperator || !isa<StringLiteral>(SubExpr))\n      ::CheckBoolLikeConversion(S, SubExpr, BO->getExprLoc());\n\n    SubExpr = BO->getRHS()->IgnoreParenImpCasts();\n    if (!IsLogicalAndOperator || !isa<StringLiteral>(SubExpr))\n      ::CheckBoolLikeConversion(S, SubExpr, BO->getExprLoc());\n  }\n\n  if (const UnaryOperator *U = dyn_cast<UnaryOperator>(E)) {\n    if (U->getOpcode() == UO_LNot) {\n      ::CheckBoolLikeConversion(S, U->getSubExpr(), CC);\n    } else if (U->getOpcode() != UO_AddrOf) {\n      if (U->getSubExpr()->getType()->isAtomicType())\n        S.Diag(U->getSubExpr()->getBeginLoc(),\n               diag::warn_atomic_implicit_seq_cst);\n    }\n  }\n}\n\n/// AnalyzeImplicitConversions - Find and report any interesting\n/// implicit conversions in the given expression.  There are a couple\n/// of competing diagnostics here, -Wconversion and -Wsign-compare.\nstatic void AnalyzeImplicitConversions(Sema &S, Expr *OrigE, SourceLocation CC,\n                                       bool IsListInit/*= false*/) {\n  llvm::SmallVector<AnalyzeImplicitConversionsWorkItem, 16> WorkList;\n  WorkList.push_back({OrigE, CC, IsListInit});\n  while (!WorkList.empty())\n    AnalyzeImplicitConversions(S, WorkList.pop_back_val(), WorkList);\n}\n\n/// Diagnose integer type and any valid implicit conversion to it.\nstatic bool checkOpenCLEnqueueIntType(Sema &S, Expr *E, const QualType &IntT) {\n  // Taking into account implicit conversions,\n  // allow any integer.\n  if (!E->getType()->isIntegerType()) {\n    S.Diag(E->getBeginLoc(),\n           diag::err_opencl_enqueue_kernel_invalid_local_size_type);\n    return true;\n  }\n  // Potentially emit standard warnings for implicit conversions if enabled\n  // using -Wconversion.\n  CheckImplicitConversion(S, E, IntT, E->getBeginLoc());\n  return false;\n}\n\n// Helper function for Sema::DiagnoseAlwaysNonNullPointer.\n// Returns true when emitting a warning about taking the address of a reference.\nstatic bool CheckForReference(Sema &SemaRef, const Expr *E,\n                              const PartialDiagnostic &PD) {\n  E = E->IgnoreParenImpCasts();\n\n  const FunctionDecl *FD = nullptr;\n\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E)) {\n    if (!DRE->getDecl()->getType()->isReferenceType())\n      return false;\n  } else if (const MemberExpr *M = dyn_cast<MemberExpr>(E)) {\n    if (!M->getMemberDecl()->getType()->isReferenceType())\n      return false;\n  } else if (const CallExpr *Call = dyn_cast<CallExpr>(E)) {\n    if (!Call->getCallReturnType(SemaRef.Context)->isReferenceType())\n      return false;\n    FD = Call->getDirectCallee();\n  } else {\n    return false;\n  }\n\n  SemaRef.Diag(E->getExprLoc(), PD);\n\n  // If possible, point to location of function.\n  if (FD) {\n    SemaRef.Diag(FD->getLocation(), diag::note_reference_is_return_value) << FD;\n  }\n\n  return true;\n}\n\n// Returns true if the SourceLocation is expanded from any macro body.\n// Returns false if the SourceLocation is invalid, is from not in a macro\n// expansion, or is from expanded from a top-level macro argument.\nstatic bool IsInAnyMacroBody(const SourceManager &SM, SourceLocation Loc) {\n  if (Loc.isInvalid())\n    return false;\n\n  while (Loc.isMacroID()) {\n    if (SM.isMacroBodyExpansion(Loc))\n      return true;\n    Loc = SM.getImmediateMacroCallerLoc(Loc);\n  }\n\n  return false;\n}\n\n/// Diagnose pointers that are always non-null.\n/// \\param E the expression containing the pointer\n/// \\param NullKind NPCK_NotNull if E is a cast to bool, otherwise, E is\n/// compared to a null pointer\n/// \\param IsEqual True when the comparison is equal to a null pointer\n/// \\param Range Extra SourceRange to highlight in the diagnostic\nvoid Sema::DiagnoseAlwaysNonNullPointer(Expr *E,\n                                        Expr::NullPointerConstantKind NullKind,\n                                        bool IsEqual, SourceRange Range) {\n  if (!E)\n    return;\n\n  // Don't warn inside macros.\n  if (E->getExprLoc().isMacroID()) {\n    const SourceManager &SM = getSourceManager();\n    if (IsInAnyMacroBody(SM, E->getExprLoc()) ||\n        IsInAnyMacroBody(SM, Range.getBegin()))\n      return;\n  }\n  E = E->IgnoreImpCasts();\n\n  const bool IsCompare = NullKind != Expr::NPCK_NotNull;\n\n  if (isa<CXXThisExpr>(E)) {\n    unsigned DiagID = IsCompare ? diag::warn_this_null_compare\n                                : diag::warn_this_bool_conversion;\n    Diag(E->getExprLoc(), DiagID) << E->getSourceRange() << Range << IsEqual;\n    return;\n  }\n\n  bool IsAddressOf = false;\n\n  if (UnaryOperator *UO = dyn_cast<UnaryOperator>(E)) {\n    if (UO->getOpcode() != UO_AddrOf)\n      return;\n    IsAddressOf = true;\n    E = UO->getSubExpr();\n  }\n\n  if (IsAddressOf) {\n    unsigned DiagID = IsCompare\n                          ? diag::warn_address_of_reference_null_compare\n                          : diag::warn_address_of_reference_bool_conversion;\n    PartialDiagnostic PD = PDiag(DiagID) << E->getSourceRange() << Range\n                                         << IsEqual;\n    if (CheckForReference(*this, E, PD)) {\n      return;\n    }\n  }\n\n  auto ComplainAboutNonnullParamOrCall = [&](const Attr *NonnullAttr) {\n    bool IsParam = isa<NonNullAttr>(NonnullAttr);\n    std::string Str;\n    llvm::raw_string_ostream S(Str);\n    E->printPretty(S, nullptr, getPrintingPolicy());\n    unsigned DiagID = IsCompare ? diag::warn_nonnull_expr_compare\n                                : diag::warn_cast_nonnull_to_bool;\n    Diag(E->getExprLoc(), DiagID) << IsParam << S.str()\n      << E->getSourceRange() << Range << IsEqual;\n    Diag(NonnullAttr->getLocation(), diag::note_declared_nonnull) << IsParam;\n  };\n\n  // If we have a CallExpr that is tagged with returns_nonnull, we can complain.\n  if (auto *Call = dyn_cast<CallExpr>(E->IgnoreParenImpCasts())) {\n    if (auto *Callee = Call->getDirectCallee()) {\n      if (const Attr *A = Callee->getAttr<ReturnsNonNullAttr>()) {\n        ComplainAboutNonnullParamOrCall(A);\n        return;\n      }\n    }\n  }\n\n  // Expect to find a single Decl.  Skip anything more complicated.\n  ValueDecl *D = nullptr;\n  if (DeclRefExpr *R = dyn_cast<DeclRefExpr>(E)) {\n    D = R->getDecl();\n  } else if (MemberExpr *M = dyn_cast<MemberExpr>(E)) {\n    D = M->getMemberDecl();\n  }\n\n  // Weak Decls can be null.\n  if (!D || D->isWeak())\n    return;\n\n  // Check for parameter decl with nonnull attribute\n  if (const auto* PV = dyn_cast<ParmVarDecl>(D)) {\n    if (getCurFunction() &&\n        !getCurFunction()->ModifiedNonNullParams.count(PV)) {\n      if (const Attr *A = PV->getAttr<NonNullAttr>()) {\n        ComplainAboutNonnullParamOrCall(A);\n        return;\n      }\n\n      if (const auto *FD = dyn_cast<FunctionDecl>(PV->getDeclContext())) {\n        // Skip function template not specialized yet.\n        if (FD->getTemplatedKind() == FunctionDecl::TK_FunctionTemplate)\n          return;\n        auto ParamIter = llvm::find(FD->parameters(), PV);\n        assert(ParamIter != FD->param_end());\n        unsigned ParamNo = std::distance(FD->param_begin(), ParamIter);\n\n        for (const auto *NonNull : FD->specific_attrs<NonNullAttr>()) {\n          if (!NonNull->args_size()) {\n              ComplainAboutNonnullParamOrCall(NonNull);\n              return;\n          }\n\n          for (const ParamIdx &ArgNo : NonNull->args()) {\n            if (ArgNo.getASTIndex() == ParamNo) {\n              ComplainAboutNonnullParamOrCall(NonNull);\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  QualType T = D->getType();\n  const bool IsArray = T->isArrayType();\n  const bool IsFunction = T->isFunctionType();\n\n  // Address of function is used to silence the function warning.\n  if (IsAddressOf && IsFunction) {\n    return;\n  }\n\n  // Found nothing.\n  if (!IsAddressOf && !IsFunction && !IsArray)\n    return;\n\n  // Pretty print the expression for the diagnostic.\n  std::string Str;\n  llvm::raw_string_ostream S(Str);\n  E->printPretty(S, nullptr, getPrintingPolicy());\n\n  unsigned DiagID = IsCompare ? diag::warn_null_pointer_compare\n                              : diag::warn_impcast_pointer_to_bool;\n  enum {\n    AddressOf,\n    FunctionPointer,\n    ArrayPointer\n  } DiagType;\n  if (IsAddressOf)\n    DiagType = AddressOf;\n  else if (IsFunction)\n    DiagType = FunctionPointer;\n  else if (IsArray)\n    DiagType = ArrayPointer;\n  else\n    llvm_unreachable(\"Could not determine diagnostic.\");\n  Diag(E->getExprLoc(), DiagID) << DiagType << S.str() << E->getSourceRange()\n                                << Range << IsEqual;\n\n  if (!IsFunction)\n    return;\n\n  // Suggest '&' to silence the function warning.\n  Diag(E->getExprLoc(), diag::note_function_warning_silence)\n      << FixItHint::CreateInsertion(E->getBeginLoc(), \"&\");\n\n  // Check to see if '()' fixit should be emitted.\n  QualType ReturnType;\n  UnresolvedSet<4> NonTemplateOverloads;\n  tryExprAsCall(*E, ReturnType, NonTemplateOverloads);\n  if (ReturnType.isNull())\n    return;\n\n  if (IsCompare) {\n    // There are two cases here.  If there is null constant, the only suggest\n    // for a pointer return type.  If the null is 0, then suggest if the return\n    // type is a pointer or an integer type.\n    if (!ReturnType->isPointerType()) {\n      if (NullKind == Expr::NPCK_ZeroExpression ||\n          NullKind == Expr::NPCK_ZeroLiteral) {\n        if (!ReturnType->isIntegerType())\n          return;\n      } else {\n        return;\n      }\n    }\n  } else { // !IsCompare\n    // For function to bool, only suggest if the function pointer has bool\n    // return type.\n    if (!ReturnType->isSpecificBuiltinType(BuiltinType::Bool))\n      return;\n  }\n  Diag(E->getExprLoc(), diag::note_function_to_function_call)\n      << FixItHint::CreateInsertion(getLocForEndOfToken(E->getEndLoc()), \"()\");\n}\n\n/// Diagnoses \"dangerous\" implicit conversions within the given\n/// expression (which is a full expression).  Implements -Wconversion\n/// and -Wsign-compare.\n///\n/// \\param CC the \"context\" location of the implicit conversion, i.e.\n///   the most location of the syntactic entity requiring the implicit\n///   conversion\nvoid Sema::CheckImplicitConversions(Expr *E, SourceLocation CC) {\n  // Don't diagnose in unevaluated contexts.\n  if (isUnevaluatedContext())\n    return;\n\n  // Don't diagnose for value- or type-dependent expressions.\n  if (E->isTypeDependent() || E->isValueDependent())\n    return;\n\n  // Check for array bounds violations in cases where the check isn't triggered\n  // elsewhere for other Expr types (like BinaryOperators), e.g. when an\n  // ArraySubscriptExpr is on the RHS of a variable initialization.\n  CheckArrayAccess(E);\n\n  // This is not the right CC for (e.g.) a variable initialization.\n  AnalyzeImplicitConversions(*this, E, CC);\n}\n\n/// CheckBoolLikeConversion - Check conversion of given expression to boolean.\n/// Input argument E is a logical expression.\nvoid Sema::CheckBoolLikeConversion(Expr *E, SourceLocation CC) {\n  ::CheckBoolLikeConversion(*this, E, CC);\n}\n\n/// Diagnose when expression is an integer constant expression and its evaluation\n/// results in integer overflow\nvoid Sema::CheckForIntOverflow (Expr *E) {\n  // Use a work list to deal with nested struct initializers.\n  SmallVector<Expr *, 2> Exprs(1, E);\n\n  do {\n    Expr *OriginalE = Exprs.pop_back_val();\n    Expr *E = OriginalE->IgnoreParenCasts();\n\n    if (isa<BinaryOperator>(E)) {\n      E->EvaluateForOverflow(Context);\n      continue;\n    }\n\n    if (auto InitList = dyn_cast<InitListExpr>(OriginalE))\n      Exprs.append(InitList->inits().begin(), InitList->inits().end());\n    else if (isa<ObjCBoxedExpr>(OriginalE))\n      E->EvaluateForOverflow(Context);\n    else if (auto Call = dyn_cast<CallExpr>(E))\n      Exprs.append(Call->arg_begin(), Call->arg_end());\n    else if (auto Message = dyn_cast<ObjCMessageExpr>(E))\n      Exprs.append(Message->arg_begin(), Message->arg_end());\n  } while (!Exprs.empty());\n}\n\nnamespace {\n\n/// Visitor for expressions which looks for unsequenced operations on the\n/// same object.\nclass SequenceChecker : public ConstEvaluatedExprVisitor<SequenceChecker> {\n  using Base = ConstEvaluatedExprVisitor<SequenceChecker>;\n\n  /// A tree of sequenced regions within an expression. Two regions are\n  /// unsequenced if one is an ancestor or a descendent of the other. When we\n  /// finish processing an expression with sequencing, such as a comma\n  /// expression, we fold its tree nodes into its parent, since they are\n  /// unsequenced with respect to nodes we will visit later.\n  class SequenceTree {\n    struct Value {\n      explicit Value(unsigned Parent) : Parent(Parent), Merged(false) {}\n      unsigned Parent : 31;\n      unsigned Merged : 1;\n    };\n    SmallVector<Value, 8> Values;\n\n  public:\n    /// A region within an expression which may be sequenced with respect\n    /// to some other region.\n    class Seq {\n      friend class SequenceTree;\n\n      unsigned Index;\n\n      explicit Seq(unsigned N) : Index(N) {}\n\n    public:\n      Seq() : Index(0) {}\n    };\n\n    SequenceTree() { Values.push_back(Value(0)); }\n    Seq root() const { return Seq(0); }\n\n    /// Create a new sequence of operations, which is an unsequenced\n    /// subset of \\p Parent. This sequence of operations is sequenced with\n    /// respect to other children of \\p Parent.\n    Seq allocate(Seq Parent) {\n      Values.push_back(Value(Parent.Index));\n      return Seq(Values.size() - 1);\n    }\n\n    /// Merge a sequence of operations into its parent.\n    void merge(Seq S) {\n      Values[S.Index].Merged = true;\n    }\n\n    /// Determine whether two operations are unsequenced. This operation\n    /// is asymmetric: \\p Cur should be the more recent sequence, and \\p Old\n    /// should have been merged into its parent as appropriate.\n    bool isUnsequenced(Seq Cur, Seq Old) {\n      unsigned C = representative(Cur.Index);\n      unsigned Target = representative(Old.Index);\n      while (C >= Target) {\n        if (C == Target)\n          return true;\n        C = Values[C].Parent;\n      }\n      return false;\n    }\n\n  private:\n    /// Pick a representative for a sequence.\n    unsigned representative(unsigned K) {\n      if (Values[K].Merged)\n        // Perform path compression as we go.\n        return Values[K].Parent = representative(Values[K].Parent);\n      return K;\n    }\n  };\n\n  /// An object for which we can track unsequenced uses.\n  using Object = const NamedDecl *;\n\n  /// Different flavors of object usage which we track. We only track the\n  /// least-sequenced usage of each kind.\n  enum UsageKind {\n    /// A read of an object. Multiple unsequenced reads are OK.\n    UK_Use,\n\n    /// A modification of an object which is sequenced before the value\n    /// computation of the expression, such as ++n in C++.\n    UK_ModAsValue,\n\n    /// A modification of an object which is not sequenced before the value\n    /// computation of the expression, such as n++.\n    UK_ModAsSideEffect,\n\n    UK_Count = UK_ModAsSideEffect + 1\n  };\n\n  /// Bundle together a sequencing region and the expression corresponding\n  /// to a specific usage. One Usage is stored for each usage kind in UsageInfo.\n  struct Usage {\n    const Expr *UsageExpr;\n    SequenceTree::Seq Seq;\n\n    Usage() : UsageExpr(nullptr), Seq() {}\n  };\n\n  struct UsageInfo {\n    Usage Uses[UK_Count];\n\n    /// Have we issued a diagnostic for this object already?\n    bool Diagnosed;\n\n    UsageInfo() : Uses(), Diagnosed(false) {}\n  };\n  using UsageInfoMap = llvm::SmallDenseMap<Object, UsageInfo, 16>;\n\n  Sema &SemaRef;\n\n  /// Sequenced regions within the expression.\n  SequenceTree Tree;\n\n  /// Declaration modifications and references which we have seen.\n  UsageInfoMap UsageMap;\n\n  /// The region we are currently within.\n  SequenceTree::Seq Region;\n\n  /// Filled in with declarations which were modified as a side-effect\n  /// (that is, post-increment operations).\n  SmallVectorImpl<std::pair<Object, Usage>> *ModAsSideEffect = nullptr;\n\n  /// Expressions to check later. We defer checking these to reduce\n  /// stack usage.\n  SmallVectorImpl<const Expr *> &WorkList;\n\n  /// RAII object wrapping the visitation of a sequenced subexpression of an\n  /// expression. At the end of this process, the side-effects of the evaluation\n  /// become sequenced with respect to the value computation of the result, so\n  /// we downgrade any UK_ModAsSideEffect within the evaluation to\n  /// UK_ModAsValue.\n  struct SequencedSubexpression {\n    SequencedSubexpression(SequenceChecker &Self)\n      : Self(Self), OldModAsSideEffect(Self.ModAsSideEffect) {\n      Self.ModAsSideEffect = &ModAsSideEffect;\n    }\n\n    ~SequencedSubexpression() {\n      for (const std::pair<Object, Usage> &M : llvm::reverse(ModAsSideEffect)) {\n        // Add a new usage with usage kind UK_ModAsValue, and then restore\n        // the previous usage with UK_ModAsSideEffect (thus clearing it if\n        // the previous one was empty).\n        UsageInfo &UI = Self.UsageMap[M.first];\n        auto &SideEffectUsage = UI.Uses[UK_ModAsSideEffect];\n        Self.addUsage(M.first, UI, SideEffectUsage.UsageExpr, UK_ModAsValue);\n        SideEffectUsage = M.second;\n      }\n      Self.ModAsSideEffect = OldModAsSideEffect;\n    }\n\n    SequenceChecker &Self;\n    SmallVector<std::pair<Object, Usage>, 4> ModAsSideEffect;\n    SmallVectorImpl<std::pair<Object, Usage>> *OldModAsSideEffect;\n  };\n\n  /// RAII object wrapping the visitation of a subexpression which we might\n  /// choose to evaluate as a constant. If any subexpression is evaluated and\n  /// found to be non-constant, this allows us to suppress the evaluation of\n  /// the outer expression.\n  class EvaluationTracker {\n  public:\n    EvaluationTracker(SequenceChecker &Self)\n        : Self(Self), Prev(Self.EvalTracker) {\n      Self.EvalTracker = this;\n    }\n\n    ~EvaluationTracker() {\n      Self.EvalTracker = Prev;\n      if (Prev)\n        Prev->EvalOK &= EvalOK;\n    }\n\n    bool evaluate(const Expr *E, bool &Result) {\n      if (!EvalOK || E->isValueDependent())\n        return false;\n      EvalOK = E->EvaluateAsBooleanCondition(\n          Result, Self.SemaRef.Context, Self.SemaRef.isConstantEvaluated());\n      return EvalOK;\n    }\n\n  private:\n    SequenceChecker &Self;\n    EvaluationTracker *Prev;\n    bool EvalOK = true;\n  } *EvalTracker = nullptr;\n\n  /// Find the object which is produced by the specified expression,\n  /// if any.\n  Object getObject(const Expr *E, bool Mod) const {\n    E = E->IgnoreParenCasts();\n    if (const UnaryOperator *UO = dyn_cast<UnaryOperator>(E)) {\n      if (Mod && (UO->getOpcode() == UO_PreInc || UO->getOpcode() == UO_PreDec))\n        return getObject(UO->getSubExpr(), Mod);\n    } else if (const BinaryOperator *BO = dyn_cast<BinaryOperator>(E)) {\n      if (BO->getOpcode() == BO_Comma)\n        return getObject(BO->getRHS(), Mod);\n      if (Mod && BO->isAssignmentOp())\n        return getObject(BO->getLHS(), Mod);\n    } else if (const MemberExpr *ME = dyn_cast<MemberExpr>(E)) {\n      // FIXME: Check for more interesting cases, like \"x.n = ++x.n\".\n      if (isa<CXXThisExpr>(ME->getBase()->IgnoreParenCasts()))\n        return ME->getMemberDecl();\n    } else if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E))\n      // FIXME: If this is a reference, map through to its value.\n      return DRE->getDecl();\n    return nullptr;\n  }\n\n  /// Note that an object \\p O was modified or used by an expression\n  /// \\p UsageExpr with usage kind \\p UK. \\p UI is the \\p UsageInfo for\n  /// the object \\p O as obtained via the \\p UsageMap.\n  void addUsage(Object O, UsageInfo &UI, const Expr *UsageExpr, UsageKind UK) {\n    // Get the old usage for the given object and usage kind.\n    Usage &U = UI.Uses[UK];\n    if (!U.UsageExpr || !Tree.isUnsequenced(Region, U.Seq)) {\n      // If we have a modification as side effect and are in a sequenced\n      // subexpression, save the old Usage so that we can restore it later\n      // in SequencedSubexpression::~SequencedSubexpression.\n      if (UK == UK_ModAsSideEffect && ModAsSideEffect)\n        ModAsSideEffect->push_back(std::make_pair(O, U));\n      // Then record the new usage with the current sequencing region.\n      U.UsageExpr = UsageExpr;\n      U.Seq = Region;\n    }\n  }\n\n  /// Check whether a modification or use of an object \\p O in an expression\n  /// \\p UsageExpr conflicts with a prior usage of kind \\p OtherKind. \\p UI is\n  /// the \\p UsageInfo for the object \\p O as obtained via the \\p UsageMap.\n  /// \\p IsModMod is true when we are checking for a mod-mod unsequenced\n  /// usage and false we are checking for a mod-use unsequenced usage.\n  void checkUsage(Object O, UsageInfo &UI, const Expr *UsageExpr,\n                  UsageKind OtherKind, bool IsModMod) {\n    if (UI.Diagnosed)\n      return;\n\n    const Usage &U = UI.Uses[OtherKind];\n    if (!U.UsageExpr || !Tree.isUnsequenced(Region, U.Seq))\n      return;\n\n    const Expr *Mod = U.UsageExpr;\n    const Expr *ModOrUse = UsageExpr;\n    if (OtherKind == UK_Use)\n      std::swap(Mod, ModOrUse);\n\n    SemaRef.DiagRuntimeBehavior(\n        Mod->getExprLoc(), {Mod, ModOrUse},\n        SemaRef.PDiag(IsModMod ? diag::warn_unsequenced_mod_mod\n                               : diag::warn_unsequenced_mod_use)\n            << O << SourceRange(ModOrUse->getExprLoc()));\n    UI.Diagnosed = true;\n  }\n\n  // A note on note{Pre, Post}{Use, Mod}:\n  //\n  // (It helps to follow the algorithm with an expression such as\n  //  \"((++k)++, k) = k\" or \"k = (k++, k++)\". Both contain unsequenced\n  //  operations before C++17 and both are well-defined in C++17).\n  //\n  // When visiting a node which uses/modify an object we first call notePreUse\n  // or notePreMod before visiting its sub-expression(s). At this point the\n  // children of the current node have not yet been visited and so the eventual\n  // uses/modifications resulting from the children of the current node have not\n  // been recorded yet.\n  //\n  // We then visit the children of the current node. After that notePostUse or\n  // notePostMod is called. These will 1) detect an unsequenced modification\n  // as side effect (as in \"k++ + k\") and 2) add a new usage with the\n  // appropriate usage kind.\n  //\n  // We also have to be careful that some operation sequences modification as\n  // side effect as well (for example: || or ,). To account for this we wrap\n  // the visitation of such a sub-expression (for example: the LHS of || or ,)\n  // with SequencedSubexpression. SequencedSubexpression is an RAII object\n  // which record usages which are modifications as side effect, and then\n  // downgrade them (or more accurately restore the previous usage which was a\n  // modification as side effect) when exiting the scope of the sequenced\n  // subexpression.\n\n  void notePreUse(Object O, const Expr *UseExpr) {\n    UsageInfo &UI = UsageMap[O];\n    // Uses conflict with other modifications.\n    checkUsage(O, UI, UseExpr, /*OtherKind=*/UK_ModAsValue, /*IsModMod=*/false);\n  }\n\n  void notePostUse(Object O, const Expr *UseExpr) {\n    UsageInfo &UI = UsageMap[O];\n    checkUsage(O, UI, UseExpr, /*OtherKind=*/UK_ModAsSideEffect,\n               /*IsModMod=*/false);\n    addUsage(O, UI, UseExpr, /*UsageKind=*/UK_Use);\n  }\n\n  void notePreMod(Object O, const Expr *ModExpr) {\n    UsageInfo &UI = UsageMap[O];\n    // Modifications conflict with other modifications and with uses.\n    checkUsage(O, UI, ModExpr, /*OtherKind=*/UK_ModAsValue, /*IsModMod=*/true);\n    checkUsage(O, UI, ModExpr, /*OtherKind=*/UK_Use, /*IsModMod=*/false);\n  }\n\n  void notePostMod(Object O, const Expr *ModExpr, UsageKind UK) {\n    UsageInfo &UI = UsageMap[O];\n    checkUsage(O, UI, ModExpr, /*OtherKind=*/UK_ModAsSideEffect,\n               /*IsModMod=*/true);\n    addUsage(O, UI, ModExpr, /*UsageKind=*/UK);\n  }\n\npublic:\n  SequenceChecker(Sema &S, const Expr *E,\n                  SmallVectorImpl<const Expr *> &WorkList)\n      : Base(S.Context), SemaRef(S), Region(Tree.root()), WorkList(WorkList) {\n    Visit(E);\n    // Silence a -Wunused-private-field since WorkList is now unused.\n    // TODO: Evaluate if it can be used, and if not remove it.\n    (void)this->WorkList;\n  }\n\n  void VisitStmt(const Stmt *S) {\n    // Skip all statements which aren't expressions for now.\n  }\n\n  void VisitExpr(const Expr *E) {\n    // By default, just recurse to evaluated subexpressions.\n    Base::VisitStmt(E);\n  }\n\n  void VisitCastExpr(const CastExpr *E) {\n    Object O = Object();\n    if (E->getCastKind() == CK_LValueToRValue)\n      O = getObject(E->getSubExpr(), false);\n\n    if (O)\n      notePreUse(O, E);\n    VisitExpr(E);\n    if (O)\n      notePostUse(O, E);\n  }\n\n  void VisitSequencedExpressions(const Expr *SequencedBefore,\n                                 const Expr *SequencedAfter) {\n    SequenceTree::Seq BeforeRegion = Tree.allocate(Region);\n    SequenceTree::Seq AfterRegion = Tree.allocate(Region);\n    SequenceTree::Seq OldRegion = Region;\n\n    {\n      SequencedSubexpression SeqBefore(*this);\n      Region = BeforeRegion;\n      Visit(SequencedBefore);\n    }\n\n    Region = AfterRegion;\n    Visit(SequencedAfter);\n\n    Region = OldRegion;\n\n    Tree.merge(BeforeRegion);\n    Tree.merge(AfterRegion);\n  }\n\n  void VisitArraySubscriptExpr(const ArraySubscriptExpr *ASE) {\n    // C++17 [expr.sub]p1:\n    //   The expression E1[E2] is identical (by definition) to *((E1)+(E2)). The\n    //   expression E1 is sequenced before the expression E2.\n    if (SemaRef.getLangOpts().CPlusPlus17)\n      VisitSequencedExpressions(ASE->getLHS(), ASE->getRHS());\n    else {\n      Visit(ASE->getLHS());\n      Visit(ASE->getRHS());\n    }\n  }\n\n  void VisitBinPtrMemD(const BinaryOperator *BO) { VisitBinPtrMem(BO); }\n  void VisitBinPtrMemI(const BinaryOperator *BO) { VisitBinPtrMem(BO); }\n  void VisitBinPtrMem(const BinaryOperator *BO) {\n    // C++17 [expr.mptr.oper]p4:\n    //  Abbreviating pm-expression.*cast-expression as E1.*E2, [...]\n    //  the expression E1 is sequenced before the expression E2.\n    if (SemaRef.getLangOpts().CPlusPlus17)\n      VisitSequencedExpressions(BO->getLHS(), BO->getRHS());\n    else {\n      Visit(BO->getLHS());\n      Visit(BO->getRHS());\n    }\n  }\n\n  void VisitBinShl(const BinaryOperator *BO) { VisitBinShlShr(BO); }\n  void VisitBinShr(const BinaryOperator *BO) { VisitBinShlShr(BO); }\n  void VisitBinShlShr(const BinaryOperator *BO) {\n    // C++17 [expr.shift]p4:\n    //  The expression E1 is sequenced before the expression E2.\n    if (SemaRef.getLangOpts().CPlusPlus17)\n      VisitSequencedExpressions(BO->getLHS(), BO->getRHS());\n    else {\n      Visit(BO->getLHS());\n      Visit(BO->getRHS());\n    }\n  }\n\n  void VisitBinComma(const BinaryOperator *BO) {\n    // C++11 [expr.comma]p1:\n    //   Every value computation and side effect associated with the left\n    //   expression is sequenced before every value computation and side\n    //   effect associated with the right expression.\n    VisitSequencedExpressions(BO->getLHS(), BO->getRHS());\n  }\n\n  void VisitBinAssign(const BinaryOperator *BO) {\n    SequenceTree::Seq RHSRegion;\n    SequenceTree::Seq LHSRegion;\n    if (SemaRef.getLangOpts().CPlusPlus17) {\n      RHSRegion = Tree.allocate(Region);\n      LHSRegion = Tree.allocate(Region);\n    } else {\n      RHSRegion = Region;\n      LHSRegion = Region;\n    }\n    SequenceTree::Seq OldRegion = Region;\n\n    // C++11 [expr.ass]p1:\n    //  [...] the assignment is sequenced after the value computation\n    //  of the right and left operands, [...]\n    //\n    // so check it before inspecting the operands and update the\n    // map afterwards.\n    Object O = getObject(BO->getLHS(), /*Mod=*/true);\n    if (O)\n      notePreMod(O, BO);\n\n    if (SemaRef.getLangOpts().CPlusPlus17) {\n      // C++17 [expr.ass]p1:\n      //  [...] The right operand is sequenced before the left operand. [...]\n      {\n        SequencedSubexpression SeqBefore(*this);\n        Region = RHSRegion;\n        Visit(BO->getRHS());\n      }\n\n      Region = LHSRegion;\n      Visit(BO->getLHS());\n\n      if (O && isa<CompoundAssignOperator>(BO))\n        notePostUse(O, BO);\n\n    } else {\n      // C++11 does not specify any sequencing between the LHS and RHS.\n      Region = LHSRegion;\n      Visit(BO->getLHS());\n\n      if (O && isa<CompoundAssignOperator>(BO))\n        notePostUse(O, BO);\n\n      Region = RHSRegion;\n      Visit(BO->getRHS());\n    }\n\n    // C++11 [expr.ass]p1:\n    //  the assignment is sequenced [...] before the value computation of the\n    //  assignment expression.\n    // C11 6.5.16/3 has no such rule.\n    Region = OldRegion;\n    if (O)\n      notePostMod(O, BO,\n                  SemaRef.getLangOpts().CPlusPlus ? UK_ModAsValue\n                                                  : UK_ModAsSideEffect);\n    if (SemaRef.getLangOpts().CPlusPlus17) {\n      Tree.merge(RHSRegion);\n      Tree.merge(LHSRegion);\n    }\n  }\n\n  void VisitCompoundAssignOperator(const CompoundAssignOperator *CAO) {\n    VisitBinAssign(CAO);\n  }\n\n  void VisitUnaryPreInc(const UnaryOperator *UO) { VisitUnaryPreIncDec(UO); }\n  void VisitUnaryPreDec(const UnaryOperator *UO) { VisitUnaryPreIncDec(UO); }\n  void VisitUnaryPreIncDec(const UnaryOperator *UO) {\n    Object O = getObject(UO->getSubExpr(), true);\n    if (!O)\n      return VisitExpr(UO);\n\n    notePreMod(O, UO);\n    Visit(UO->getSubExpr());\n    // C++11 [expr.pre.incr]p1:\n    //   the expression ++x is equivalent to x+=1\n    notePostMod(O, UO,\n                SemaRef.getLangOpts().CPlusPlus ? UK_ModAsValue\n                                                : UK_ModAsSideEffect);\n  }\n\n  void VisitUnaryPostInc(const UnaryOperator *UO) { VisitUnaryPostIncDec(UO); }\n  void VisitUnaryPostDec(const UnaryOperator *UO) { VisitUnaryPostIncDec(UO); }\n  void VisitUnaryPostIncDec(const UnaryOperator *UO) {\n    Object O = getObject(UO->getSubExpr(), true);\n    if (!O)\n      return VisitExpr(UO);\n\n    notePreMod(O, UO);\n    Visit(UO->getSubExpr());\n    notePostMod(O, UO, UK_ModAsSideEffect);\n  }\n\n  void VisitBinLOr(const BinaryOperator *BO) {\n    // C++11 [expr.log.or]p2:\n    //  If the second expression is evaluated, every value computation and\n    //  side effect associated with the first expression is sequenced before\n    //  every value computation and side effect associated with the\n    //  second expression.\n    SequenceTree::Seq LHSRegion = Tree.allocate(Region);\n    SequenceTree::Seq RHSRegion = Tree.allocate(Region);\n    SequenceTree::Seq OldRegion = Region;\n\n    EvaluationTracker Eval(*this);\n    {\n      SequencedSubexpression Sequenced(*this);\n      Region = LHSRegion;\n      Visit(BO->getLHS());\n    }\n\n    // C++11 [expr.log.or]p1:\n    //  [...] the second operand is not evaluated if the first operand\n    //  evaluates to true.\n    bool EvalResult = false;\n    bool EvalOK = Eval.evaluate(BO->getLHS(), EvalResult);\n    bool ShouldVisitRHS = !EvalOK || (EvalOK && !EvalResult);\n    if (ShouldVisitRHS) {\n      Region = RHSRegion;\n      Visit(BO->getRHS());\n    }\n\n    Region = OldRegion;\n    Tree.merge(LHSRegion);\n    Tree.merge(RHSRegion);\n  }\n\n  void VisitBinLAnd(const BinaryOperator *BO) {\n    // C++11 [expr.log.and]p2:\n    //  If the second expression is evaluated, every value computation and\n    //  side effect associated with the first expression is sequenced before\n    //  every value computation and side effect associated with the\n    //  second expression.\n    SequenceTree::Seq LHSRegion = Tree.allocate(Region);\n    SequenceTree::Seq RHSRegion = Tree.allocate(Region);\n    SequenceTree::Seq OldRegion = Region;\n\n    EvaluationTracker Eval(*this);\n    {\n      SequencedSubexpression Sequenced(*this);\n      Region = LHSRegion;\n      Visit(BO->getLHS());\n    }\n\n    // C++11 [expr.log.and]p1:\n    //  [...] the second operand is not evaluated if the first operand is false.\n    bool EvalResult = false;\n    bool EvalOK = Eval.evaluate(BO->getLHS(), EvalResult);\n    bool ShouldVisitRHS = !EvalOK || (EvalOK && EvalResult);\n    if (ShouldVisitRHS) {\n      Region = RHSRegion;\n      Visit(BO->getRHS());\n    }\n\n    Region = OldRegion;\n    Tree.merge(LHSRegion);\n    Tree.merge(RHSRegion);\n  }\n\n  void VisitAbstractConditionalOperator(const AbstractConditionalOperator *CO) {\n    // C++11 [expr.cond]p1:\n    //  [...] Every value computation and side effect associated with the first\n    //  expression is sequenced before every value computation and side effect\n    //  associated with the second or third expression.\n    SequenceTree::Seq ConditionRegion = Tree.allocate(Region);\n\n    // No sequencing is specified between the true and false expression.\n    // However since exactly one of both is going to be evaluated we can\n    // consider them to be sequenced. This is needed to avoid warning on\n    // something like \"x ? y+= 1 : y += 2;\" in the case where we will visit\n    // both the true and false expressions because we can't evaluate x.\n    // This will still allow us to detect an expression like (pre C++17)\n    // \"(x ? y += 1 : y += 2) = y\".\n    //\n    // We don't wrap the visitation of the true and false expression with\n    // SequencedSubexpression because we don't want to downgrade modifications\n    // as side effect in the true and false expressions after the visition\n    // is done. (for example in the expression \"(x ? y++ : y++) + y\" we should\n    // not warn between the two \"y++\", but we should warn between the \"y++\"\n    // and the \"y\".\n    SequenceTree::Seq TrueRegion = Tree.allocate(Region);\n    SequenceTree::Seq FalseRegion = Tree.allocate(Region);\n    SequenceTree::Seq OldRegion = Region;\n\n    EvaluationTracker Eval(*this);\n    {\n      SequencedSubexpression Sequenced(*this);\n      Region = ConditionRegion;\n      Visit(CO->getCond());\n    }\n\n    // C++11 [expr.cond]p1:\n    // [...] The first expression is contextually converted to bool (Clause 4).\n    // It is evaluated and if it is true, the result of the conditional\n    // expression is the value of the second expression, otherwise that of the\n    // third expression. Only one of the second and third expressions is\n    // evaluated. [...]\n    bool EvalResult = false;\n    bool EvalOK = Eval.evaluate(CO->getCond(), EvalResult);\n    bool ShouldVisitTrueExpr = !EvalOK || (EvalOK && EvalResult);\n    bool ShouldVisitFalseExpr = !EvalOK || (EvalOK && !EvalResult);\n    if (ShouldVisitTrueExpr) {\n      Region = TrueRegion;\n      Visit(CO->getTrueExpr());\n    }\n    if (ShouldVisitFalseExpr) {\n      Region = FalseRegion;\n      Visit(CO->getFalseExpr());\n    }\n\n    Region = OldRegion;\n    Tree.merge(ConditionRegion);\n    Tree.merge(TrueRegion);\n    Tree.merge(FalseRegion);\n  }\n\n  void VisitCallExpr(const CallExpr *CE) {\n    // FIXME: CXXNewExpr and CXXDeleteExpr implicitly call functions.\n\n    if (CE->isUnevaluatedBuiltinCall(Context))\n      return;\n\n    // C++11 [intro.execution]p15:\n    //   When calling a function [...], every value computation and side effect\n    //   associated with any argument expression, or with the postfix expression\n    //   designating the called function, is sequenced before execution of every\n    //   expression or statement in the body of the function [and thus before\n    //   the value computation of its result].\n    SequencedSubexpression Sequenced(*this);\n    SemaRef.runWithSufficientStackSpace(CE->getExprLoc(), [&] {\n      // C++17 [expr.call]p5\n      //   The postfix-expression is sequenced before each expression in the\n      //   expression-list and any default argument. [...]\n      SequenceTree::Seq CalleeRegion;\n      SequenceTree::Seq OtherRegion;\n      if (SemaRef.getLangOpts().CPlusPlus17) {\n        CalleeRegion = Tree.allocate(Region);\n        OtherRegion = Tree.allocate(Region);\n      } else {\n        CalleeRegion = Region;\n        OtherRegion = Region;\n      }\n      SequenceTree::Seq OldRegion = Region;\n\n      // Visit the callee expression first.\n      Region = CalleeRegion;\n      if (SemaRef.getLangOpts().CPlusPlus17) {\n        SequencedSubexpression Sequenced(*this);\n        Visit(CE->getCallee());\n      } else {\n        Visit(CE->getCallee());\n      }\n\n      // Then visit the argument expressions.\n      Region = OtherRegion;\n      for (const Expr *Argument : CE->arguments())\n        Visit(Argument);\n\n      Region = OldRegion;\n      if (SemaRef.getLangOpts().CPlusPlus17) {\n        Tree.merge(CalleeRegion);\n        Tree.merge(OtherRegion);\n      }\n    });\n  }\n\n  void VisitCXXOperatorCallExpr(const CXXOperatorCallExpr *CXXOCE) {\n    // C++17 [over.match.oper]p2:\n    //   [...] the operator notation is first transformed to the equivalent\n    //   function-call notation as summarized in Table 12 (where @ denotes one\n    //   of the operators covered in the specified subclause). However, the\n    //   operands are sequenced in the order prescribed for the built-in\n    //   operator (Clause 8).\n    //\n    // From the above only overloaded binary operators and overloaded call\n    // operators have sequencing rules in C++17 that we need to handle\n    // separately.\n    if (!SemaRef.getLangOpts().CPlusPlus17 ||\n        (CXXOCE->getNumArgs() != 2 && CXXOCE->getOperator() != OO_Call))\n      return VisitCallExpr(CXXOCE);\n\n    enum {\n      NoSequencing,\n      LHSBeforeRHS,\n      RHSBeforeLHS,\n      LHSBeforeRest\n    } SequencingKind;\n    switch (CXXOCE->getOperator()) {\n    case OO_Equal:\n    case OO_PlusEqual:\n    case OO_MinusEqual:\n    case OO_StarEqual:\n    case OO_SlashEqual:\n    case OO_PercentEqual:\n    case OO_CaretEqual:\n    case OO_AmpEqual:\n    case OO_PipeEqual:\n    case OO_LessLessEqual:\n    case OO_GreaterGreaterEqual:\n      SequencingKind = RHSBeforeLHS;\n      break;\n\n    case OO_LessLess:\n    case OO_GreaterGreater:\n    case OO_AmpAmp:\n    case OO_PipePipe:\n    case OO_Comma:\n    case OO_ArrowStar:\n    case OO_Subscript:\n      SequencingKind = LHSBeforeRHS;\n      break;\n\n    case OO_Call:\n      SequencingKind = LHSBeforeRest;\n      break;\n\n    default:\n      SequencingKind = NoSequencing;\n      break;\n    }\n\n    if (SequencingKind == NoSequencing)\n      return VisitCallExpr(CXXOCE);\n\n    // This is a call, so all subexpressions are sequenced before the result.\n    SequencedSubexpression Sequenced(*this);\n\n    SemaRef.runWithSufficientStackSpace(CXXOCE->getExprLoc(), [&] {\n      assert(SemaRef.getLangOpts().CPlusPlus17 &&\n             \"Should only get there with C++17 and above!\");\n      assert((CXXOCE->getNumArgs() == 2 || CXXOCE->getOperator() == OO_Call) &&\n             \"Should only get there with an overloaded binary operator\"\n             \" or an overloaded call operator!\");\n\n      if (SequencingKind == LHSBeforeRest) {\n        assert(CXXOCE->getOperator() == OO_Call &&\n               \"We should only have an overloaded call operator here!\");\n\n        // This is very similar to VisitCallExpr, except that we only have the\n        // C++17 case. The postfix-expression is the first argument of the\n        // CXXOperatorCallExpr. The expressions in the expression-list, if any,\n        // are in the following arguments.\n        //\n        // Note that we intentionally do not visit the callee expression since\n        // it is just a decayed reference to a function.\n        SequenceTree::Seq PostfixExprRegion = Tree.allocate(Region);\n        SequenceTree::Seq ArgsRegion = Tree.allocate(Region);\n        SequenceTree::Seq OldRegion = Region;\n\n        assert(CXXOCE->getNumArgs() >= 1 &&\n               \"An overloaded call operator must have at least one argument\"\n               \" for the postfix-expression!\");\n        const Expr *PostfixExpr = CXXOCE->getArgs()[0];\n        llvm::ArrayRef<const Expr *> Args(CXXOCE->getArgs() + 1,\n                                          CXXOCE->getNumArgs() - 1);\n\n        // Visit the postfix-expression first.\n        {\n          Region = PostfixExprRegion;\n          SequencedSubexpression Sequenced(*this);\n          Visit(PostfixExpr);\n        }\n\n        // Then visit the argument expressions.\n        Region = ArgsRegion;\n        for (const Expr *Arg : Args)\n          Visit(Arg);\n\n        Region = OldRegion;\n        Tree.merge(PostfixExprRegion);\n        Tree.merge(ArgsRegion);\n      } else {\n        assert(CXXOCE->getNumArgs() == 2 &&\n               \"Should only have two arguments here!\");\n        assert((SequencingKind == LHSBeforeRHS ||\n                SequencingKind == RHSBeforeLHS) &&\n               \"Unexpected sequencing kind!\");\n\n        // We do not visit the callee expression since it is just a decayed\n        // reference to a function.\n        const Expr *E1 = CXXOCE->getArg(0);\n        const Expr *E2 = CXXOCE->getArg(1);\n        if (SequencingKind == RHSBeforeLHS)\n          std::swap(E1, E2);\n\n        return VisitSequencedExpressions(E1, E2);\n      }\n    });\n  }\n\n  void VisitCXXConstructExpr(const CXXConstructExpr *CCE) {\n    // This is a call, so all subexpressions are sequenced before the result.\n    SequencedSubexpression Sequenced(*this);\n\n    if (!CCE->isListInitialization())\n      return VisitExpr(CCE);\n\n    // In C++11, list initializations are sequenced.\n    SmallVector<SequenceTree::Seq, 32> Elts;\n    SequenceTree::Seq Parent = Region;\n    for (CXXConstructExpr::const_arg_iterator I = CCE->arg_begin(),\n                                              E = CCE->arg_end();\n         I != E; ++I) {\n      Region = Tree.allocate(Parent);\n      Elts.push_back(Region);\n      Visit(*I);\n    }\n\n    // Forget that the initializers are sequenced.\n    Region = Parent;\n    for (unsigned I = 0; I < Elts.size(); ++I)\n      Tree.merge(Elts[I]);\n  }\n\n  void VisitInitListExpr(const InitListExpr *ILE) {\n    if (!SemaRef.getLangOpts().CPlusPlus11)\n      return VisitExpr(ILE);\n\n    // In C++11, list initializations are sequenced.\n    SmallVector<SequenceTree::Seq, 32> Elts;\n    SequenceTree::Seq Parent = Region;\n    for (unsigned I = 0; I < ILE->getNumInits(); ++I) {\n      const Expr *E = ILE->getInit(I);\n      if (!E)\n        continue;\n      Region = Tree.allocate(Parent);\n      Elts.push_back(Region);\n      Visit(E);\n    }\n\n    // Forget that the initializers are sequenced.\n    Region = Parent;\n    for (unsigned I = 0; I < Elts.size(); ++I)\n      Tree.merge(Elts[I]);\n  }\n};\n\n} // namespace\n\nvoid Sema::CheckUnsequencedOperations(const Expr *E) {\n  SmallVector<const Expr *, 8> WorkList;\n  WorkList.push_back(E);\n  while (!WorkList.empty()) {\n    const Expr *Item = WorkList.pop_back_val();\n    SequenceChecker(*this, Item, WorkList);\n  }\n}\n\nvoid Sema::CheckCompletedExpr(Expr *E, SourceLocation CheckLoc,\n                              bool IsConstexpr) {\n  llvm::SaveAndRestore<bool> ConstantContext(\n      isConstantEvaluatedOverride, IsConstexpr || isa<ConstantExpr>(E));\n  CheckImplicitConversions(E, CheckLoc);\n  if (!E->isInstantiationDependent())\n    CheckUnsequencedOperations(E);\n  if (!IsConstexpr && !E->isValueDependent())\n    CheckForIntOverflow(E);\n  DiagnoseMisalignedMembers();\n}\n\nvoid Sema::CheckBitFieldInitialization(SourceLocation InitLoc,\n                                       FieldDecl *BitField,\n                                       Expr *Init) {\n  (void) AnalyzeBitFieldAssignment(*this, BitField, Init, InitLoc);\n}\n\nstatic void diagnoseArrayStarInParamType(Sema &S, QualType PType,\n                                         SourceLocation Loc) {\n  if (!PType->isVariablyModifiedType())\n    return;\n  if (const auto *PointerTy = dyn_cast<PointerType>(PType)) {\n    diagnoseArrayStarInParamType(S, PointerTy->getPointeeType(), Loc);\n    return;\n  }\n  if (const auto *ReferenceTy = dyn_cast<ReferenceType>(PType)) {\n    diagnoseArrayStarInParamType(S, ReferenceTy->getPointeeType(), Loc);\n    return;\n  }\n  if (const auto *ParenTy = dyn_cast<ParenType>(PType)) {\n    diagnoseArrayStarInParamType(S, ParenTy->getInnerType(), Loc);\n    return;\n  }\n\n  const ArrayType *AT = S.Context.getAsArrayType(PType);\n  if (!AT)\n    return;\n\n  if (AT->getSizeModifier() != ArrayType::Star) {\n    diagnoseArrayStarInParamType(S, AT->getElementType(), Loc);\n    return;\n  }\n\n  S.Diag(Loc, diag::err_array_star_in_function_definition);\n}\n\n/// CheckParmsForFunctionDef - Check that the parameters of the given\n/// function are appropriate for the definition of a function. This\n/// takes care of any checks that cannot be performed on the\n/// declaration itself, e.g., that the types of each of the function\n/// parameters are complete.\nbool Sema::CheckParmsForFunctionDef(ArrayRef<ParmVarDecl *> Parameters,\n                                    bool CheckParameterNames) {\n  bool HasInvalidParm = false;\n  for (ParmVarDecl *Param : Parameters) {\n    // C99 6.7.5.3p4: the parameters in a parameter type list in a\n    // function declarator that is part of a function definition of\n    // that function shall not have incomplete type.\n    //\n    // This is also C++ [dcl.fct]p6.\n    if (!Param->isInvalidDecl() &&\n        RequireCompleteType(Param->getLocation(), Param->getType(),\n                            diag::err_typecheck_decl_incomplete_type)) {\n      Param->setInvalidDecl();\n      HasInvalidParm = true;\n    }\n\n    // C99 6.9.1p5: If the declarator includes a parameter type list, the\n    // declaration of each parameter shall include an identifier.\n    if (CheckParameterNames && Param->getIdentifier() == nullptr &&\n        !Param->isImplicit() && !getLangOpts().CPlusPlus) {\n      // Diagnose this as an extension in C17 and earlier.\n      if (!getLangOpts().C2x)\n        Diag(Param->getLocation(), diag::ext_parameter_name_omitted_c2x);\n    }\n\n    // C99 6.7.5.3p12:\n    //   If the function declarator is not part of a definition of that\n    //   function, parameters may have incomplete type and may use the [*]\n    //   notation in their sequences of declarator specifiers to specify\n    //   variable length array types.\n    QualType PType = Param->getOriginalType();\n    // FIXME: This diagnostic should point the '[*]' if source-location\n    // information is added for it.\n    diagnoseArrayStarInParamType(*this, PType, Param->getLocation());\n\n    // If the parameter is a c++ class type and it has to be destructed in the\n    // callee function, declare the destructor so that it can be called by the\n    // callee function. Do not perform any direct access check on the dtor here.\n    if (!Param->isInvalidDecl()) {\n      if (CXXRecordDecl *ClassDecl = Param->getType()->getAsCXXRecordDecl()) {\n        if (!ClassDecl->isInvalidDecl() &&\n            !ClassDecl->hasIrrelevantDestructor() &&\n            !ClassDecl->isDependentContext() &&\n            ClassDecl->isParamDestroyedInCallee()) {\n          CXXDestructorDecl *Destructor = LookupDestructor(ClassDecl);\n          MarkFunctionReferenced(Param->getLocation(), Destructor);\n          DiagnoseUseOfDecl(Destructor, Param->getLocation());\n        }\n      }\n    }\n\n    // Parameters with the pass_object_size attribute only need to be marked\n    // constant at function definitions. Because we lack information about\n    // whether we're on a declaration or definition when we're instantiating the\n    // attribute, we need to check for constness here.\n    if (const auto *Attr = Param->getAttr<PassObjectSizeAttr>())\n      if (!Param->getType().isConstQualified())\n        Diag(Param->getLocation(), diag::err_attribute_pointers_only)\n            << Attr->getSpelling() << 1;\n\n    // Check for parameter names shadowing fields from the class.\n    if (LangOpts.CPlusPlus && !Param->isInvalidDecl()) {\n      // The owning context for the parameter should be the function, but we\n      // want to see if this function's declaration context is a record.\n      DeclContext *DC = Param->getDeclContext();\n      if (DC && DC->isFunctionOrMethod()) {\n        if (auto *RD = dyn_cast<CXXRecordDecl>(DC->getParent()))\n          CheckShadowInheritedFields(Param->getLocation(), Param->getDeclName(),\n                                     RD, /*DeclIsField*/ false);\n      }\n    }\n  }\n\n  return HasInvalidParm;\n}\n\nOptional<std::pair<CharUnits, CharUnits>>\nstatic getBaseAlignmentAndOffsetFromPtr(const Expr *E, ASTContext &Ctx);\n\n/// Compute the alignment and offset of the base class object given the\n/// derived-to-base cast expression and the alignment and offset of the derived\n/// class object.\nstatic std::pair<CharUnits, CharUnits>\ngetDerivedToBaseAlignmentAndOffset(const CastExpr *CE, QualType DerivedType,\n                                   CharUnits BaseAlignment, CharUnits Offset,\n                                   ASTContext &Ctx) {\n  for (auto PathI = CE->path_begin(), PathE = CE->path_end(); PathI != PathE;\n       ++PathI) {\n    const CXXBaseSpecifier *Base = *PathI;\n    const CXXRecordDecl *BaseDecl = Base->getType()->getAsCXXRecordDecl();\n    if (Base->isVirtual()) {\n      // The complete object may have a lower alignment than the non-virtual\n      // alignment of the base, in which case the base may be misaligned. Choose\n      // the smaller of the non-virtual alignment and BaseAlignment, which is a\n      // conservative lower bound of the complete object alignment.\n      CharUnits NonVirtualAlignment =\n          Ctx.getASTRecordLayout(BaseDecl).getNonVirtualAlignment();\n      BaseAlignment = std::min(BaseAlignment, NonVirtualAlignment);\n      Offset = CharUnits::Zero();\n    } else {\n      const ASTRecordLayout &RL =\n          Ctx.getASTRecordLayout(DerivedType->getAsCXXRecordDecl());\n      Offset += RL.getBaseClassOffset(BaseDecl);\n    }\n    DerivedType = Base->getType();\n  }\n\n  return std::make_pair(BaseAlignment, Offset);\n}\n\n/// Compute the alignment and offset of a binary additive operator.\nstatic Optional<std::pair<CharUnits, CharUnits>>\ngetAlignmentAndOffsetFromBinAddOrSub(const Expr *PtrE, const Expr *IntE,\n                                     bool IsSub, ASTContext &Ctx) {\n  QualType PointeeType = PtrE->getType()->getPointeeType();\n\n  if (!PointeeType->isConstantSizeType())\n    return llvm::None;\n\n  auto P = getBaseAlignmentAndOffsetFromPtr(PtrE, Ctx);\n\n  if (!P)\n    return llvm::None;\n\n  CharUnits EltSize = Ctx.getTypeSizeInChars(PointeeType);\n  if (Optional<llvm::APSInt> IdxRes = IntE->getIntegerConstantExpr(Ctx)) {\n    CharUnits Offset = EltSize * IdxRes->getExtValue();\n    if (IsSub)\n      Offset = -Offset;\n    return std::make_pair(P->first, P->second + Offset);\n  }\n\n  // If the integer expression isn't a constant expression, compute the lower\n  // bound of the alignment using the alignment and offset of the pointer\n  // expression and the element size.\n  return std::make_pair(\n      P->first.alignmentAtOffset(P->second).alignmentAtOffset(EltSize),\n      CharUnits::Zero());\n}\n\n/// This helper function takes an lvalue expression and returns the alignment of\n/// a VarDecl and a constant offset from the VarDecl.\nOptional<std::pair<CharUnits, CharUnits>>\nstatic getBaseAlignmentAndOffsetFromLValue(const Expr *E, ASTContext &Ctx) {\n  E = E->IgnoreParens();\n  switch (E->getStmtClass()) {\n  default:\n    break;\n  case Stmt::CStyleCastExprClass:\n  case Stmt::CXXStaticCastExprClass:\n  case Stmt::ImplicitCastExprClass: {\n    auto *CE = cast<CastExpr>(E);\n    const Expr *From = CE->getSubExpr();\n    switch (CE->getCastKind()) {\n    default:\n      break;\n    case CK_NoOp:\n      return getBaseAlignmentAndOffsetFromLValue(From, Ctx);\n    case CK_UncheckedDerivedToBase:\n    case CK_DerivedToBase: {\n      auto P = getBaseAlignmentAndOffsetFromLValue(From, Ctx);\n      if (!P)\n        break;\n      return getDerivedToBaseAlignmentAndOffset(CE, From->getType(), P->first,\n                                                P->second, Ctx);\n    }\n    }\n    break;\n  }\n  case Stmt::ArraySubscriptExprClass: {\n    auto *ASE = cast<ArraySubscriptExpr>(E);\n    return getAlignmentAndOffsetFromBinAddOrSub(ASE->getBase(), ASE->getIdx(),\n                                                false, Ctx);\n  }\n  case Stmt::DeclRefExprClass: {\n    if (auto *VD = dyn_cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl())) {\n      // FIXME: If VD is captured by copy or is an escaping __block variable,\n      // use the alignment of VD's type.\n      if (!VD->getType()->isReferenceType())\n        return std::make_pair(Ctx.getDeclAlign(VD), CharUnits::Zero());\n      if (VD->hasInit())\n        return getBaseAlignmentAndOffsetFromLValue(VD->getInit(), Ctx);\n    }\n    break;\n  }\n  case Stmt::MemberExprClass: {\n    auto *ME = cast<MemberExpr>(E);\n    auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n    if (!FD || FD->getType()->isReferenceType())\n      break;\n    Optional<std::pair<CharUnits, CharUnits>> P;\n    if (ME->isArrow())\n      P = getBaseAlignmentAndOffsetFromPtr(ME->getBase(), Ctx);\n    else\n      P = getBaseAlignmentAndOffsetFromLValue(ME->getBase(), Ctx);\n    if (!P)\n      break;\n    const ASTRecordLayout &Layout = Ctx.getASTRecordLayout(FD->getParent());\n    uint64_t Offset = Layout.getFieldOffset(FD->getFieldIndex());\n    return std::make_pair(P->first,\n                          P->second + CharUnits::fromQuantity(Offset));\n  }\n  case Stmt::UnaryOperatorClass: {\n    auto *UO = cast<UnaryOperator>(E);\n    switch (UO->getOpcode()) {\n    default:\n      break;\n    case UO_Deref:\n      return getBaseAlignmentAndOffsetFromPtr(UO->getSubExpr(), Ctx);\n    }\n    break;\n  }\n  case Stmt::BinaryOperatorClass: {\n    auto *BO = cast<BinaryOperator>(E);\n    auto Opcode = BO->getOpcode();\n    switch (Opcode) {\n    default:\n      break;\n    case BO_Comma:\n      return getBaseAlignmentAndOffsetFromLValue(BO->getRHS(), Ctx);\n    }\n    break;\n  }\n  }\n  return llvm::None;\n}\n\n/// This helper function takes a pointer expression and returns the alignment of\n/// a VarDecl and a constant offset from the VarDecl.\nOptional<std::pair<CharUnits, CharUnits>>\nstatic getBaseAlignmentAndOffsetFromPtr(const Expr *E, ASTContext &Ctx) {\n  E = E->IgnoreParens();\n  switch (E->getStmtClass()) {\n  default:\n    break;\n  case Stmt::CStyleCastExprClass:\n  case Stmt::CXXStaticCastExprClass:\n  case Stmt::ImplicitCastExprClass: {\n    auto *CE = cast<CastExpr>(E);\n    const Expr *From = CE->getSubExpr();\n    switch (CE->getCastKind()) {\n    default:\n      break;\n    case CK_NoOp:\n      return getBaseAlignmentAndOffsetFromPtr(From, Ctx);\n    case CK_ArrayToPointerDecay:\n      return getBaseAlignmentAndOffsetFromLValue(From, Ctx);\n    case CK_UncheckedDerivedToBase:\n    case CK_DerivedToBase: {\n      auto P = getBaseAlignmentAndOffsetFromPtr(From, Ctx);\n      if (!P)\n        break;\n      return getDerivedToBaseAlignmentAndOffset(\n          CE, From->getType()->getPointeeType(), P->first, P->second, Ctx);\n    }\n    }\n    break;\n  }\n  case Stmt::CXXThisExprClass: {\n    auto *RD = E->getType()->getPointeeType()->getAsCXXRecordDecl();\n    CharUnits Alignment = Ctx.getASTRecordLayout(RD).getNonVirtualAlignment();\n    return std::make_pair(Alignment, CharUnits::Zero());\n  }\n  case Stmt::UnaryOperatorClass: {\n    auto *UO = cast<UnaryOperator>(E);\n    if (UO->getOpcode() == UO_AddrOf)\n      return getBaseAlignmentAndOffsetFromLValue(UO->getSubExpr(), Ctx);\n    break;\n  }\n  case Stmt::BinaryOperatorClass: {\n    auto *BO = cast<BinaryOperator>(E);\n    auto Opcode = BO->getOpcode();\n    switch (Opcode) {\n    default:\n      break;\n    case BO_Add:\n    case BO_Sub: {\n      const Expr *LHS = BO->getLHS(), *RHS = BO->getRHS();\n      if (Opcode == BO_Add && !RHS->getType()->isIntegralOrEnumerationType())\n        std::swap(LHS, RHS);\n      return getAlignmentAndOffsetFromBinAddOrSub(LHS, RHS, Opcode == BO_Sub,\n                                                  Ctx);\n    }\n    case BO_Comma:\n      return getBaseAlignmentAndOffsetFromPtr(BO->getRHS(), Ctx);\n    }\n    break;\n  }\n  }\n  return llvm::None;\n}\n\nstatic CharUnits getPresumedAlignmentOfPointer(const Expr *E, Sema &S) {\n  // See if we can compute the alignment of a VarDecl and an offset from it.\n  Optional<std::pair<CharUnits, CharUnits>> P =\n      getBaseAlignmentAndOffsetFromPtr(E, S.Context);\n\n  if (P)\n    return P->first.alignmentAtOffset(P->second);\n\n  // If that failed, return the type's alignment.\n  return S.Context.getTypeAlignInChars(E->getType()->getPointeeType());\n}\n\n/// CheckCastAlign - Implements -Wcast-align, which warns when a\n/// pointer cast increases the alignment requirements.\nvoid Sema::CheckCastAlign(Expr *Op, QualType T, SourceRange TRange) {\n  // This is actually a lot of work to potentially be doing on every\n  // cast; don't do it if we're ignoring -Wcast_align (as is the default).\n  if (getDiagnostics().isIgnored(diag::warn_cast_align, TRange.getBegin()))\n    return;\n\n  // Ignore dependent types.\n  if (T->isDependentType() || Op->getType()->isDependentType())\n    return;\n\n  // Require that the destination be a pointer type.\n  const PointerType *DestPtr = T->getAs<PointerType>();\n  if (!DestPtr) return;\n\n  // If the destination has alignment 1, we're done.\n  QualType DestPointee = DestPtr->getPointeeType();\n  if (DestPointee->isIncompleteType()) return;\n  CharUnits DestAlign = Context.getTypeAlignInChars(DestPointee);\n  if (DestAlign.isOne()) return;\n\n  // Require that the source be a pointer type.\n  const PointerType *SrcPtr = Op->getType()->getAs<PointerType>();\n  if (!SrcPtr) return;\n  QualType SrcPointee = SrcPtr->getPointeeType();\n\n  // Explicitly allow casts from cv void*.  We already implicitly\n  // allowed casts to cv void*, since they have alignment 1.\n  // Also allow casts involving incomplete types, which implicitly\n  // includes 'void'.\n  if (SrcPointee->isIncompleteType()) return;\n\n  CharUnits SrcAlign = getPresumedAlignmentOfPointer(Op, *this);\n\n  if (SrcAlign >= DestAlign) return;\n\n  Diag(TRange.getBegin(), diag::warn_cast_align)\n    << Op->getType() << T\n    << static_cast<unsigned>(SrcAlign.getQuantity())\n    << static_cast<unsigned>(DestAlign.getQuantity())\n    << TRange << Op->getSourceRange();\n}\n\n/// Check whether this array fits the idiom of a size-one tail padded\n/// array member of a struct.\n///\n/// We avoid emitting out-of-bounds access warnings for such arrays as they are\n/// commonly used to emulate flexible arrays in C89 code.\nstatic bool IsTailPaddedMemberArray(Sema &S, const llvm::APInt &Size,\n                                    const NamedDecl *ND) {\n  if (Size != 1 || !ND) return false;\n\n  const FieldDecl *FD = dyn_cast<FieldDecl>(ND);\n  if (!FD) return false;\n\n  // Don't consider sizes resulting from macro expansions or template argument\n  // substitution to form C89 tail-padded arrays.\n\n  TypeSourceInfo *TInfo = FD->getTypeSourceInfo();\n  while (TInfo) {\n    TypeLoc TL = TInfo->getTypeLoc();\n    // Look through typedefs.\n    if (TypedefTypeLoc TTL = TL.getAs<TypedefTypeLoc>()) {\n      const TypedefNameDecl *TDL = TTL.getTypedefNameDecl();\n      TInfo = TDL->getTypeSourceInfo();\n      continue;\n    }\n    if (ConstantArrayTypeLoc CTL = TL.getAs<ConstantArrayTypeLoc>()) {\n      const Expr *SizeExpr = dyn_cast<IntegerLiteral>(CTL.getSizeExpr());\n      if (!SizeExpr || SizeExpr->getExprLoc().isMacroID())\n        return false;\n    }\n    break;\n  }\n\n  const RecordDecl *RD = dyn_cast<RecordDecl>(FD->getDeclContext());\n  if (!RD) return false;\n  if (RD->isUnion()) return false;\n  if (const CXXRecordDecl *CRD = dyn_cast<CXXRecordDecl>(RD)) {\n    if (!CRD->isStandardLayout()) return false;\n  }\n\n  // See if this is the last field decl in the record.\n  const Decl *D = FD;\n  while ((D = D->getNextDeclInContext()))\n    if (isa<FieldDecl>(D))\n      return false;\n  return true;\n}\n\nvoid Sema::CheckArrayAccess(const Expr *BaseExpr, const Expr *IndexExpr,\n                            const ArraySubscriptExpr *ASE,\n                            bool AllowOnePastEnd, bool IndexNegated) {\n  // Already diagnosed by the constant evaluator.\n  if (isConstantEvaluated())\n    return;\n\n  IndexExpr = IndexExpr->IgnoreParenImpCasts();\n  if (IndexExpr->isValueDependent())\n    return;\n\n  const Type *EffectiveType =\n      BaseExpr->getType()->getPointeeOrArrayElementType();\n  BaseExpr = BaseExpr->IgnoreParenCasts();\n  const ConstantArrayType *ArrayTy =\n      Context.getAsConstantArrayType(BaseExpr->getType());\n\n  if (!ArrayTy)\n    return;\n\n  const Type *BaseType = ArrayTy->getElementType().getTypePtr();\n  if (EffectiveType->isDependentType() || BaseType->isDependentType())\n    return;\n\n  Expr::EvalResult Result;\n  if (!IndexExpr->EvaluateAsInt(Result, Context, Expr::SE_AllowSideEffects))\n    return;\n\n  llvm::APSInt index = Result.Val.getInt();\n  if (IndexNegated)\n    index = -index;\n\n  const NamedDecl *ND = nullptr;\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(BaseExpr))\n    ND = DRE->getDecl();\n  if (const MemberExpr *ME = dyn_cast<MemberExpr>(BaseExpr))\n    ND = ME->getMemberDecl();\n\n  if (index.isUnsigned() || !index.isNegative()) {\n    // It is possible that the type of the base expression after\n    // IgnoreParenCasts is incomplete, even though the type of the base\n    // expression before IgnoreParenCasts is complete (see PR39746 for an\n    // example). In this case we have no information about whether the array\n    // access exceeds the array bounds. However we can still diagnose an array\n    // access which precedes the array bounds.\n    if (BaseType->isIncompleteType())\n      return;\n\n    llvm::APInt size = ArrayTy->getSize();\n    if (!size.isStrictlyPositive())\n      return;\n\n    if (BaseType != EffectiveType) {\n      // Make sure we're comparing apples to apples when comparing index to size\n      uint64_t ptrarith_typesize = Context.getTypeSize(EffectiveType);\n      uint64_t array_typesize = Context.getTypeSize(BaseType);\n      // Handle ptrarith_typesize being zero, such as when casting to void*\n      if (!ptrarith_typesize) ptrarith_typesize = 1;\n      if (ptrarith_typesize != array_typesize) {\n        // There's a cast to a different size type involved\n        uint64_t ratio = array_typesize / ptrarith_typesize;\n        // TODO: Be smarter about handling cases where array_typesize is not a\n        // multiple of ptrarith_typesize\n        if (ptrarith_typesize * ratio == array_typesize)\n          size *= llvm::APInt(size.getBitWidth(), ratio);\n      }\n    }\n\n    if (size.getBitWidth() > index.getBitWidth())\n      index = index.zext(size.getBitWidth());\n    else if (size.getBitWidth() < index.getBitWidth())\n      size = size.zext(index.getBitWidth());\n\n    // For array subscripting the index must be less than size, but for pointer\n    // arithmetic also allow the index (offset) to be equal to size since\n    // computing the next address after the end of the array is legal and\n    // commonly done e.g. in C++ iterators and range-based for loops.\n    if (AllowOnePastEnd ? index.ule(size) : index.ult(size))\n      return;\n\n    // Also don't warn for arrays of size 1 which are members of some\n    // structure. These are often used to approximate flexible arrays in C89\n    // code.\n    if (IsTailPaddedMemberArray(*this, size, ND))\n      return;\n\n    // Suppress the warning if the subscript expression (as identified by the\n    // ']' location) and the index expression are both from macro expansions\n    // within a system header.\n    if (ASE) {\n      SourceLocation RBracketLoc = SourceMgr.getSpellingLoc(\n          ASE->getRBracketLoc());\n      if (SourceMgr.isInSystemHeader(RBracketLoc)) {\n        SourceLocation IndexLoc =\n            SourceMgr.getSpellingLoc(IndexExpr->getBeginLoc());\n        if (SourceMgr.isWrittenInSameFile(RBracketLoc, IndexLoc))\n          return;\n      }\n    }\n\n    unsigned DiagID = diag::warn_ptr_arith_exceeds_bounds;\n    if (ASE)\n      DiagID = diag::warn_array_index_exceeds_bounds;\n\n    DiagRuntimeBehavior(BaseExpr->getBeginLoc(), BaseExpr,\n                        PDiag(DiagID) << index.toString(10, true)\n                                      << size.toString(10, true)\n                                      << (unsigned)size.getLimitedValue(~0U)\n                                      << IndexExpr->getSourceRange());\n  } else {\n    unsigned DiagID = diag::warn_array_index_precedes_bounds;\n    if (!ASE) {\n      DiagID = diag::warn_ptr_arith_precedes_bounds;\n      if (index.isNegative()) index = -index;\n    }\n\n    DiagRuntimeBehavior(BaseExpr->getBeginLoc(), BaseExpr,\n                        PDiag(DiagID) << index.toString(10, true)\n                                      << IndexExpr->getSourceRange());\n  }\n\n  if (!ND) {\n    // Try harder to find a NamedDecl to point at in the note.\n    while (const ArraySubscriptExpr *ASE =\n           dyn_cast<ArraySubscriptExpr>(BaseExpr))\n      BaseExpr = ASE->getBase()->IgnoreParenCasts();\n    if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(BaseExpr))\n      ND = DRE->getDecl();\n    if (const MemberExpr *ME = dyn_cast<MemberExpr>(BaseExpr))\n      ND = ME->getMemberDecl();\n  }\n\n  if (ND)\n    DiagRuntimeBehavior(ND->getBeginLoc(), BaseExpr,\n                        PDiag(diag::note_array_declared_here) << ND);\n}\n\nvoid Sema::CheckArrayAccess(const Expr *expr) {\n  int AllowOnePastEnd = 0;\n  while (expr) {\n    expr = expr->IgnoreParenImpCasts();\n    switch (expr->getStmtClass()) {\n      case Stmt::ArraySubscriptExprClass: {\n        const ArraySubscriptExpr *ASE = cast<ArraySubscriptExpr>(expr);\n        CheckArrayAccess(ASE->getBase(), ASE->getIdx(), ASE,\n                         AllowOnePastEnd > 0);\n        expr = ASE->getBase();\n        break;\n      }\n      case Stmt::MemberExprClass: {\n        expr = cast<MemberExpr>(expr)->getBase();\n        break;\n      }\n      case Stmt::OMPArraySectionExprClass: {\n        const OMPArraySectionExpr *ASE = cast<OMPArraySectionExpr>(expr);\n        if (ASE->getLowerBound())\n          CheckArrayAccess(ASE->getBase(), ASE->getLowerBound(),\n                           /*ASE=*/nullptr, AllowOnePastEnd > 0);\n        return;\n      }\n      case Stmt::UnaryOperatorClass: {\n        // Only unwrap the * and & unary operators\n        const UnaryOperator *UO = cast<UnaryOperator>(expr);\n        expr = UO->getSubExpr();\n        switch (UO->getOpcode()) {\n          case UO_AddrOf:\n            AllowOnePastEnd++;\n            break;\n          case UO_Deref:\n            AllowOnePastEnd--;\n            break;\n          default:\n            return;\n        }\n        break;\n      }\n      case Stmt::ConditionalOperatorClass: {\n        const ConditionalOperator *cond = cast<ConditionalOperator>(expr);\n        if (const Expr *lhs = cond->getLHS())\n          CheckArrayAccess(lhs);\n        if (const Expr *rhs = cond->getRHS())\n          CheckArrayAccess(rhs);\n        return;\n      }\n      case Stmt::CXXOperatorCallExprClass: {\n        const auto *OCE = cast<CXXOperatorCallExpr>(expr);\n        for (const auto *Arg : OCE->arguments())\n          CheckArrayAccess(Arg);\n        return;\n      }\n      default:\n        return;\n    }\n  }\n}\n\n//===--- CHECK: Objective-C retain cycles ----------------------------------//\n\nnamespace {\n\nstruct RetainCycleOwner {\n  VarDecl *Variable = nullptr;\n  SourceRange Range;\n  SourceLocation Loc;\n  bool Indirect = false;\n\n  RetainCycleOwner() = default;\n\n  void setLocsFrom(Expr *e) {\n    Loc = e->getExprLoc();\n    Range = e->getSourceRange();\n  }\n};\n\n} // namespace\n\n/// Consider whether capturing the given variable can possibly lead to\n/// a retain cycle.\nstatic bool considerVariable(VarDecl *var, Expr *ref, RetainCycleOwner &owner) {\n  // In ARC, it's captured strongly iff the variable has __strong\n  // lifetime.  In MRR, it's captured strongly if the variable is\n  // __block and has an appropriate type.\n  if (var->getType().getObjCLifetime() != Qualifiers::OCL_Strong)\n    return false;\n\n  owner.Variable = var;\n  if (ref)\n    owner.setLocsFrom(ref);\n  return true;\n}\n\nstatic bool findRetainCycleOwner(Sema &S, Expr *e, RetainCycleOwner &owner) {\n  while (true) {\n    e = e->IgnoreParens();\n    if (CastExpr *cast = dyn_cast<CastExpr>(e)) {\n      switch (cast->getCastKind()) {\n      case CK_BitCast:\n      case CK_LValueBitCast:\n      case CK_LValueToRValue:\n      case CK_ARCReclaimReturnedObject:\n        e = cast->getSubExpr();\n        continue;\n\n      default:\n        return false;\n      }\n    }\n\n    if (ObjCIvarRefExpr *ref = dyn_cast<ObjCIvarRefExpr>(e)) {\n      ObjCIvarDecl *ivar = ref->getDecl();\n      if (ivar->getType().getObjCLifetime() != Qualifiers::OCL_Strong)\n        return false;\n\n      // Try to find a retain cycle in the base.\n      if (!findRetainCycleOwner(S, ref->getBase(), owner))\n        return false;\n\n      if (ref->isFreeIvar()) owner.setLocsFrom(ref);\n      owner.Indirect = true;\n      return true;\n    }\n\n    if (DeclRefExpr *ref = dyn_cast<DeclRefExpr>(e)) {\n      VarDecl *var = dyn_cast<VarDecl>(ref->getDecl());\n      if (!var) return false;\n      return considerVariable(var, ref, owner);\n    }\n\n    if (MemberExpr *member = dyn_cast<MemberExpr>(e)) {\n      if (member->isArrow()) return false;\n\n      // Don't count this as an indirect ownership.\n      e = member->getBase();\n      continue;\n    }\n\n    if (PseudoObjectExpr *pseudo = dyn_cast<PseudoObjectExpr>(e)) {\n      // Only pay attention to pseudo-objects on property references.\n      ObjCPropertyRefExpr *pre\n        = dyn_cast<ObjCPropertyRefExpr>(pseudo->getSyntacticForm()\n                                              ->IgnoreParens());\n      if (!pre) return false;\n      if (pre->isImplicitProperty()) return false;\n      ObjCPropertyDecl *property = pre->getExplicitProperty();\n      if (!property->isRetaining() &&\n          !(property->getPropertyIvarDecl() &&\n            property->getPropertyIvarDecl()->getType()\n              .getObjCLifetime() == Qualifiers::OCL_Strong))\n          return false;\n\n      owner.Indirect = true;\n      if (pre->isSuperReceiver()) {\n        owner.Variable = S.getCurMethodDecl()->getSelfDecl();\n        if (!owner.Variable)\n          return false;\n        owner.Loc = pre->getLocation();\n        owner.Range = pre->getSourceRange();\n        return true;\n      }\n      e = const_cast<Expr*>(cast<OpaqueValueExpr>(pre->getBase())\n                              ->getSourceExpr());\n      continue;\n    }\n\n    // Array ivars?\n\n    return false;\n  }\n}\n\nnamespace {\n\n  struct FindCaptureVisitor : EvaluatedExprVisitor<FindCaptureVisitor> {\n    ASTContext &Context;\n    VarDecl *Variable;\n    Expr *Capturer = nullptr;\n    bool VarWillBeReased = false;\n\n    FindCaptureVisitor(ASTContext &Context, VarDecl *variable)\n        : EvaluatedExprVisitor<FindCaptureVisitor>(Context),\n          Context(Context), Variable(variable) {}\n\n    void VisitDeclRefExpr(DeclRefExpr *ref) {\n      if (ref->getDecl() == Variable && !Capturer)\n        Capturer = ref;\n    }\n\n    void VisitObjCIvarRefExpr(ObjCIvarRefExpr *ref) {\n      if (Capturer) return;\n      Visit(ref->getBase());\n      if (Capturer && ref->isFreeIvar())\n        Capturer = ref;\n    }\n\n    void VisitBlockExpr(BlockExpr *block) {\n      // Look inside nested blocks\n      if (block->getBlockDecl()->capturesVariable(Variable))\n        Visit(block->getBlockDecl()->getBody());\n    }\n\n    void VisitOpaqueValueExpr(OpaqueValueExpr *OVE) {\n      if (Capturer) return;\n      if (OVE->getSourceExpr())\n        Visit(OVE->getSourceExpr());\n    }\n\n    void VisitBinaryOperator(BinaryOperator *BinOp) {\n      if (!Variable || VarWillBeReased || BinOp->getOpcode() != BO_Assign)\n        return;\n      Expr *LHS = BinOp->getLHS();\n      if (const DeclRefExpr *DRE = dyn_cast_or_null<DeclRefExpr>(LHS)) {\n        if (DRE->getDecl() != Variable)\n          return;\n        if (Expr *RHS = BinOp->getRHS()) {\n          RHS = RHS->IgnoreParenCasts();\n          Optional<llvm::APSInt> Value;\n          VarWillBeReased =\n              (RHS && (Value = RHS->getIntegerConstantExpr(Context)) &&\n               *Value == 0);\n        }\n      }\n    }\n  };\n\n} // namespace\n\n/// Check whether the given argument is a block which captures a\n/// variable.\nstatic Expr *findCapturingExpr(Sema &S, Expr *e, RetainCycleOwner &owner) {\n  assert(owner.Variable && owner.Loc.isValid());\n\n  e = e->IgnoreParenCasts();\n\n  // Look through [^{...} copy] and Block_copy(^{...}).\n  if (ObjCMessageExpr *ME = dyn_cast<ObjCMessageExpr>(e)) {\n    Selector Cmd = ME->getSelector();\n    if (Cmd.isUnarySelector() && Cmd.getNameForSlot(0) == \"copy\") {\n      e = ME->getInstanceReceiver();\n      if (!e)\n        return nullptr;\n      e = e->IgnoreParenCasts();\n    }\n  } else if (CallExpr *CE = dyn_cast<CallExpr>(e)) {\n    if (CE->getNumArgs() == 1) {\n      FunctionDecl *Fn = dyn_cast_or_null<FunctionDecl>(CE->getCalleeDecl());\n      if (Fn) {\n        const IdentifierInfo *FnI = Fn->getIdentifier();\n        if (FnI && FnI->isStr(\"_Block_copy\")) {\n          e = CE->getArg(0)->IgnoreParenCasts();\n        }\n      }\n    }\n  }\n\n  BlockExpr *block = dyn_cast<BlockExpr>(e);\n  if (!block || !block->getBlockDecl()->capturesVariable(owner.Variable))\n    return nullptr;\n\n  FindCaptureVisitor visitor(S.Context, owner.Variable);\n  visitor.Visit(block->getBlockDecl()->getBody());\n  return visitor.VarWillBeReased ? nullptr : visitor.Capturer;\n}\n\nstatic void diagnoseRetainCycle(Sema &S, Expr *capturer,\n                                RetainCycleOwner &owner) {\n  assert(capturer);\n  assert(owner.Variable && owner.Loc.isValid());\n\n  S.Diag(capturer->getExprLoc(), diag::warn_arc_retain_cycle)\n    << owner.Variable << capturer->getSourceRange();\n  S.Diag(owner.Loc, diag::note_arc_retain_cycle_owner)\n    << owner.Indirect << owner.Range;\n}\n\n/// Check for a keyword selector that starts with the word 'add' or\n/// 'set'.\nstatic bool isSetterLikeSelector(Selector sel) {\n  if (sel.isUnarySelector()) return false;\n\n  StringRef str = sel.getNameForSlot(0);\n  while (!str.empty() && str.front() == '_') str = str.substr(1);\n  if (str.startswith(\"set\"))\n    str = str.substr(3);\n  else if (str.startswith(\"add\")) {\n    // Specially allow 'addOperationWithBlock:'.\n    if (sel.getNumArgs() == 1 && str.startswith(\"addOperationWithBlock\"))\n      return false;\n    str = str.substr(3);\n  }\n  else\n    return false;\n\n  if (str.empty()) return true;\n  return !isLowercase(str.front());\n}\n\nstatic Optional<int> GetNSMutableArrayArgumentIndex(Sema &S,\n                                                    ObjCMessageExpr *Message) {\n  bool IsMutableArray = S.NSAPIObj->isSubclassOfNSClass(\n                                                Message->getReceiverInterface(),\n                                                NSAPI::ClassId_NSMutableArray);\n  if (!IsMutableArray) {\n    return None;\n  }\n\n  Selector Sel = Message->getSelector();\n\n  Optional<NSAPI::NSArrayMethodKind> MKOpt =\n    S.NSAPIObj->getNSArrayMethodKind(Sel);\n  if (!MKOpt) {\n    return None;\n  }\n\n  NSAPI::NSArrayMethodKind MK = *MKOpt;\n\n  switch (MK) {\n    case NSAPI::NSMutableArr_addObject:\n    case NSAPI::NSMutableArr_insertObjectAtIndex:\n    case NSAPI::NSMutableArr_setObjectAtIndexedSubscript:\n      return 0;\n    case NSAPI::NSMutableArr_replaceObjectAtIndex:\n      return 1;\n\n    default:\n      return None;\n  }\n\n  return None;\n}\n\nstatic\nOptional<int> GetNSMutableDictionaryArgumentIndex(Sema &S,\n                                                  ObjCMessageExpr *Message) {\n  bool IsMutableDictionary = S.NSAPIObj->isSubclassOfNSClass(\n                                            Message->getReceiverInterface(),\n                                            NSAPI::ClassId_NSMutableDictionary);\n  if (!IsMutableDictionary) {\n    return None;\n  }\n\n  Selector Sel = Message->getSelector();\n\n  Optional<NSAPI::NSDictionaryMethodKind> MKOpt =\n    S.NSAPIObj->getNSDictionaryMethodKind(Sel);\n  if (!MKOpt) {\n    return None;\n  }\n\n  NSAPI::NSDictionaryMethodKind MK = *MKOpt;\n\n  switch (MK) {\n    case NSAPI::NSMutableDict_setObjectForKey:\n    case NSAPI::NSMutableDict_setValueForKey:\n    case NSAPI::NSMutableDict_setObjectForKeyedSubscript:\n      return 0;\n\n    default:\n      return None;\n  }\n\n  return None;\n}\n\nstatic Optional<int> GetNSSetArgumentIndex(Sema &S, ObjCMessageExpr *Message) {\n  bool IsMutableSet = S.NSAPIObj->isSubclassOfNSClass(\n                                                Message->getReceiverInterface(),\n                                                NSAPI::ClassId_NSMutableSet);\n\n  bool IsMutableOrderedSet = S.NSAPIObj->isSubclassOfNSClass(\n                                            Message->getReceiverInterface(),\n                                            NSAPI::ClassId_NSMutableOrderedSet);\n  if (!IsMutableSet && !IsMutableOrderedSet) {\n    return None;\n  }\n\n  Selector Sel = Message->getSelector();\n\n  Optional<NSAPI::NSSetMethodKind> MKOpt = S.NSAPIObj->getNSSetMethodKind(Sel);\n  if (!MKOpt) {\n    return None;\n  }\n\n  NSAPI::NSSetMethodKind MK = *MKOpt;\n\n  switch (MK) {\n    case NSAPI::NSMutableSet_addObject:\n    case NSAPI::NSOrderedSet_setObjectAtIndex:\n    case NSAPI::NSOrderedSet_setObjectAtIndexedSubscript:\n    case NSAPI::NSOrderedSet_insertObjectAtIndex:\n      return 0;\n    case NSAPI::NSOrderedSet_replaceObjectAtIndexWithObject:\n      return 1;\n  }\n\n  return None;\n}\n\nvoid Sema::CheckObjCCircularContainer(ObjCMessageExpr *Message) {\n  if (!Message->isInstanceMessage()) {\n    return;\n  }\n\n  Optional<int> ArgOpt;\n\n  if (!(ArgOpt = GetNSMutableArrayArgumentIndex(*this, Message)) &&\n      !(ArgOpt = GetNSMutableDictionaryArgumentIndex(*this, Message)) &&\n      !(ArgOpt = GetNSSetArgumentIndex(*this, Message))) {\n    return;\n  }\n\n  int ArgIndex = *ArgOpt;\n\n  Expr *Arg = Message->getArg(ArgIndex)->IgnoreImpCasts();\n  if (OpaqueValueExpr *OE = dyn_cast<OpaqueValueExpr>(Arg)) {\n    Arg = OE->getSourceExpr()->IgnoreImpCasts();\n  }\n\n  if (Message->getReceiverKind() == ObjCMessageExpr::SuperInstance) {\n    if (DeclRefExpr *ArgRE = dyn_cast<DeclRefExpr>(Arg)) {\n      if (ArgRE->isObjCSelfExpr()) {\n        Diag(Message->getSourceRange().getBegin(),\n             diag::warn_objc_circular_container)\n          << ArgRE->getDecl() << StringRef(\"'super'\");\n      }\n    }\n  } else {\n    Expr *Receiver = Message->getInstanceReceiver()->IgnoreImpCasts();\n\n    if (OpaqueValueExpr *OE = dyn_cast<OpaqueValueExpr>(Receiver)) {\n      Receiver = OE->getSourceExpr()->IgnoreImpCasts();\n    }\n\n    if (DeclRefExpr *ReceiverRE = dyn_cast<DeclRefExpr>(Receiver)) {\n      if (DeclRefExpr *ArgRE = dyn_cast<DeclRefExpr>(Arg)) {\n        if (ReceiverRE->getDecl() == ArgRE->getDecl()) {\n          ValueDecl *Decl = ReceiverRE->getDecl();\n          Diag(Message->getSourceRange().getBegin(),\n               diag::warn_objc_circular_container)\n            << Decl << Decl;\n          if (!ArgRE->isObjCSelfExpr()) {\n            Diag(Decl->getLocation(),\n                 diag::note_objc_circular_container_declared_here)\n              << Decl;\n          }\n        }\n      }\n    } else if (ObjCIvarRefExpr *IvarRE = dyn_cast<ObjCIvarRefExpr>(Receiver)) {\n      if (ObjCIvarRefExpr *IvarArgRE = dyn_cast<ObjCIvarRefExpr>(Arg)) {\n        if (IvarRE->getDecl() == IvarArgRE->getDecl()) {\n          ObjCIvarDecl *Decl = IvarRE->getDecl();\n          Diag(Message->getSourceRange().getBegin(),\n               diag::warn_objc_circular_container)\n            << Decl << Decl;\n          Diag(Decl->getLocation(),\n               diag::note_objc_circular_container_declared_here)\n            << Decl;\n        }\n      }\n    }\n  }\n}\n\n/// Check a message send to see if it's likely to cause a retain cycle.\nvoid Sema::checkRetainCycles(ObjCMessageExpr *msg) {\n  // Only check instance methods whose selector looks like a setter.\n  if (!msg->isInstanceMessage() || !isSetterLikeSelector(msg->getSelector()))\n    return;\n\n  // Try to find a variable that the receiver is strongly owned by.\n  RetainCycleOwner owner;\n  if (msg->getReceiverKind() == ObjCMessageExpr::Instance) {\n    if (!findRetainCycleOwner(*this, msg->getInstanceReceiver(), owner))\n      return;\n  } else {\n    assert(msg->getReceiverKind() == ObjCMessageExpr::SuperInstance);\n    owner.Variable = getCurMethodDecl()->getSelfDecl();\n    owner.Loc = msg->getSuperLoc();\n    owner.Range = msg->getSuperLoc();\n  }\n\n  // Check whether the receiver is captured by any of the arguments.\n  const ObjCMethodDecl *MD = msg->getMethodDecl();\n  for (unsigned i = 0, e = msg->getNumArgs(); i != e; ++i) {\n    if (Expr *capturer = findCapturingExpr(*this, msg->getArg(i), owner)) {\n      // noescape blocks should not be retained by the method.\n      if (MD && MD->parameters()[i]->hasAttr<NoEscapeAttr>())\n        continue;\n      return diagnoseRetainCycle(*this, capturer, owner);\n    }\n  }\n}\n\n/// Check a property assign to see if it's likely to cause a retain cycle.\nvoid Sema::checkRetainCycles(Expr *receiver, Expr *argument) {\n  RetainCycleOwner owner;\n  if (!findRetainCycleOwner(*this, receiver, owner))\n    return;\n\n  if (Expr *capturer = findCapturingExpr(*this, argument, owner))\n    diagnoseRetainCycle(*this, capturer, owner);\n}\n\nvoid Sema::checkRetainCycles(VarDecl *Var, Expr *Init) {\n  RetainCycleOwner Owner;\n  if (!considerVariable(Var, /*DeclRefExpr=*/nullptr, Owner))\n    return;\n\n  // Because we don't have an expression for the variable, we have to set the\n  // location explicitly here.\n  Owner.Loc = Var->getLocation();\n  Owner.Range = Var->getSourceRange();\n\n  if (Expr *Capturer = findCapturingExpr(*this, Init, Owner))\n    diagnoseRetainCycle(*this, Capturer, Owner);\n}\n\nstatic bool checkUnsafeAssignLiteral(Sema &S, SourceLocation Loc,\n                                     Expr *RHS, bool isProperty) {\n  // Check if RHS is an Objective-C object literal, which also can get\n  // immediately zapped in a weak reference.  Note that we explicitly\n  // allow ObjCStringLiterals, since those are designed to never really die.\n  RHS = RHS->IgnoreParenImpCasts();\n\n  // This enum needs to match with the 'select' in\n  // warn_objc_arc_literal_assign (off-by-1).\n  Sema::ObjCLiteralKind Kind = S.CheckLiteralKind(RHS);\n  if (Kind == Sema::LK_String || Kind == Sema::LK_None)\n    return false;\n\n  S.Diag(Loc, diag::warn_arc_literal_assign)\n    << (unsigned) Kind\n    << (isProperty ? 0 : 1)\n    << RHS->getSourceRange();\n\n  return true;\n}\n\nstatic bool checkUnsafeAssignObject(Sema &S, SourceLocation Loc,\n                                    Qualifiers::ObjCLifetime LT,\n                                    Expr *RHS, bool isProperty) {\n  // Strip off any implicit cast added to get to the one ARC-specific.\n  while (ImplicitCastExpr *cast = dyn_cast<ImplicitCastExpr>(RHS)) {\n    if (cast->getCastKind() == CK_ARCConsumeObject) {\n      S.Diag(Loc, diag::warn_arc_retained_assign)\n        << (LT == Qualifiers::OCL_ExplicitNone)\n        << (isProperty ? 0 : 1)\n        << RHS->getSourceRange();\n      return true;\n    }\n    RHS = cast->getSubExpr();\n  }\n\n  if (LT == Qualifiers::OCL_Weak &&\n      checkUnsafeAssignLiteral(S, Loc, RHS, isProperty))\n    return true;\n\n  return false;\n}\n\nbool Sema::checkUnsafeAssigns(SourceLocation Loc,\n                              QualType LHS, Expr *RHS) {\n  Qualifiers::ObjCLifetime LT = LHS.getObjCLifetime();\n\n  if (LT != Qualifiers::OCL_Weak && LT != Qualifiers::OCL_ExplicitNone)\n    return false;\n\n  if (checkUnsafeAssignObject(*this, Loc, LT, RHS, false))\n    return true;\n\n  return false;\n}\n\nvoid Sema::checkUnsafeExprAssigns(SourceLocation Loc,\n                              Expr *LHS, Expr *RHS) {\n  QualType LHSType;\n  // PropertyRef on LHS type need be directly obtained from\n  // its declaration as it has a PseudoType.\n  ObjCPropertyRefExpr *PRE\n    = dyn_cast<ObjCPropertyRefExpr>(LHS->IgnoreParens());\n  if (PRE && !PRE->isImplicitProperty()) {\n    const ObjCPropertyDecl *PD = PRE->getExplicitProperty();\n    if (PD)\n      LHSType = PD->getType();\n  }\n\n  if (LHSType.isNull())\n    LHSType = LHS->getType();\n\n  Qualifiers::ObjCLifetime LT = LHSType.getObjCLifetime();\n\n  if (LT == Qualifiers::OCL_Weak) {\n    if (!Diags.isIgnored(diag::warn_arc_repeated_use_of_weak, Loc))\n      getCurFunction()->markSafeWeakUse(LHS);\n  }\n\n  if (checkUnsafeAssigns(Loc, LHSType, RHS))\n    return;\n\n  // FIXME. Check for other life times.\n  if (LT != Qualifiers::OCL_None)\n    return;\n\n  if (PRE) {\n    if (PRE->isImplicitProperty())\n      return;\n    const ObjCPropertyDecl *PD = PRE->getExplicitProperty();\n    if (!PD)\n      return;\n\n    unsigned Attributes = PD->getPropertyAttributes();\n    if (Attributes & ObjCPropertyAttribute::kind_assign) {\n      // when 'assign' attribute was not explicitly specified\n      // by user, ignore it and rely on property type itself\n      // for lifetime info.\n      unsigned AsWrittenAttr = PD->getPropertyAttributesAsWritten();\n      if (!(AsWrittenAttr & ObjCPropertyAttribute::kind_assign) &&\n          LHSType->isObjCRetainableType())\n        return;\n\n      while (ImplicitCastExpr *cast = dyn_cast<ImplicitCastExpr>(RHS)) {\n        if (cast->getCastKind() == CK_ARCConsumeObject) {\n          Diag(Loc, diag::warn_arc_retained_property_assign)\n          << RHS->getSourceRange();\n          return;\n        }\n        RHS = cast->getSubExpr();\n      }\n    } else if (Attributes & ObjCPropertyAttribute::kind_weak) {\n      if (checkUnsafeAssignObject(*this, Loc, Qualifiers::OCL_Weak, RHS, true))\n        return;\n    }\n  }\n}\n\n//===--- CHECK: Empty statement body (-Wempty-body) ---------------------===//\n\nstatic bool ShouldDiagnoseEmptyStmtBody(const SourceManager &SourceMgr,\n                                        SourceLocation StmtLoc,\n                                        const NullStmt *Body) {\n  // Do not warn if the body is a macro that expands to nothing, e.g:\n  //\n  // #define CALL(x)\n  // if (condition)\n  //   CALL(0);\n  if (Body->hasLeadingEmptyMacro())\n    return false;\n\n  // Get line numbers of statement and body.\n  bool StmtLineInvalid;\n  unsigned StmtLine = SourceMgr.getPresumedLineNumber(StmtLoc,\n                                                      &StmtLineInvalid);\n  if (StmtLineInvalid)\n    return false;\n\n  bool BodyLineInvalid;\n  unsigned BodyLine = SourceMgr.getSpellingLineNumber(Body->getSemiLoc(),\n                                                      &BodyLineInvalid);\n  if (BodyLineInvalid)\n    return false;\n\n  // Warn if null statement and body are on the same line.\n  if (StmtLine != BodyLine)\n    return false;\n\n  return true;\n}\n\nvoid Sema::DiagnoseEmptyStmtBody(SourceLocation StmtLoc,\n                                 const Stmt *Body,\n                                 unsigned DiagID) {\n  // Since this is a syntactic check, don't emit diagnostic for template\n  // instantiations, this just adds noise.\n  if (CurrentInstantiationScope)\n    return;\n\n  // The body should be a null statement.\n  const NullStmt *NBody = dyn_cast<NullStmt>(Body);\n  if (!NBody)\n    return;\n\n  // Do the usual checks.\n  if (!ShouldDiagnoseEmptyStmtBody(SourceMgr, StmtLoc, NBody))\n    return;\n\n  Diag(NBody->getSemiLoc(), DiagID);\n  Diag(NBody->getSemiLoc(), diag::note_empty_body_on_separate_line);\n}\n\nvoid Sema::DiagnoseEmptyLoopBody(const Stmt *S,\n                                 const Stmt *PossibleBody) {\n  assert(!CurrentInstantiationScope); // Ensured by caller\n\n  SourceLocation StmtLoc;\n  const Stmt *Body;\n  unsigned DiagID;\n  if (const ForStmt *FS = dyn_cast<ForStmt>(S)) {\n    StmtLoc = FS->getRParenLoc();\n    Body = FS->getBody();\n    DiagID = diag::warn_empty_for_body;\n  } else if (const WhileStmt *WS = dyn_cast<WhileStmt>(S)) {\n    StmtLoc = WS->getCond()->getSourceRange().getEnd();\n    Body = WS->getBody();\n    DiagID = diag::warn_empty_while_body;\n  } else\n    return; // Neither `for' nor `while'.\n\n  // The body should be a null statement.\n  const NullStmt *NBody = dyn_cast<NullStmt>(Body);\n  if (!NBody)\n    return;\n\n  // Skip expensive checks if diagnostic is disabled.\n  if (Diags.isIgnored(DiagID, NBody->getSemiLoc()))\n    return;\n\n  // Do the usual checks.\n  if (!ShouldDiagnoseEmptyStmtBody(SourceMgr, StmtLoc, NBody))\n    return;\n\n  // `for(...);' and `while(...);' are popular idioms, so in order to keep\n  // noise level low, emit diagnostics only if for/while is followed by a\n  // CompoundStmt, e.g.:\n  //    for (int i = 0; i < n; i++);\n  //    {\n  //      a(i);\n  //    }\n  // or if for/while is followed by a statement with more indentation\n  // than for/while itself:\n  //    for (int i = 0; i < n; i++);\n  //      a(i);\n  bool ProbableTypo = isa<CompoundStmt>(PossibleBody);\n  if (!ProbableTypo) {\n    bool BodyColInvalid;\n    unsigned BodyCol = SourceMgr.getPresumedColumnNumber(\n        PossibleBody->getBeginLoc(), &BodyColInvalid);\n    if (BodyColInvalid)\n      return;\n\n    bool StmtColInvalid;\n    unsigned StmtCol =\n        SourceMgr.getPresumedColumnNumber(S->getBeginLoc(), &StmtColInvalid);\n    if (StmtColInvalid)\n      return;\n\n    if (BodyCol > StmtCol)\n      ProbableTypo = true;\n  }\n\n  if (ProbableTypo) {\n    Diag(NBody->getSemiLoc(), DiagID);\n    Diag(NBody->getSemiLoc(), diag::note_empty_body_on_separate_line);\n  }\n}\n\n//===--- CHECK: Warn on self move with std::move. -------------------------===//\n\n/// DiagnoseSelfMove - Emits a warning if a value is moved to itself.\nvoid Sema::DiagnoseSelfMove(const Expr *LHSExpr, const Expr *RHSExpr,\n                             SourceLocation OpLoc) {\n  if (Diags.isIgnored(diag::warn_sizeof_pointer_expr_memaccess, OpLoc))\n    return;\n\n  if (inTemplateInstantiation())\n    return;\n\n  // Strip parens and casts away.\n  LHSExpr = LHSExpr->IgnoreParenImpCasts();\n  RHSExpr = RHSExpr->IgnoreParenImpCasts();\n\n  // Check for a call expression\n  const CallExpr *CE = dyn_cast<CallExpr>(RHSExpr);\n  if (!CE || CE->getNumArgs() != 1)\n    return;\n\n  // Check for a call to std::move\n  if (!CE->isCallToStdMove())\n    return;\n\n  // Get argument from std::move\n  RHSExpr = CE->getArg(0);\n\n  const DeclRefExpr *LHSDeclRef = dyn_cast<DeclRefExpr>(LHSExpr);\n  const DeclRefExpr *RHSDeclRef = dyn_cast<DeclRefExpr>(RHSExpr);\n\n  // Two DeclRefExpr's, check that the decls are the same.\n  if (LHSDeclRef && RHSDeclRef) {\n    if (!LHSDeclRef->getDecl() || !RHSDeclRef->getDecl())\n      return;\n    if (LHSDeclRef->getDecl()->getCanonicalDecl() !=\n        RHSDeclRef->getDecl()->getCanonicalDecl())\n      return;\n\n    Diag(OpLoc, diag::warn_self_move) << LHSExpr->getType()\n                                        << LHSExpr->getSourceRange()\n                                        << RHSExpr->getSourceRange();\n    return;\n  }\n\n  // Member variables require a different approach to check for self moves.\n  // MemberExpr's are the same if every nested MemberExpr refers to the same\n  // Decl and that the base Expr's are DeclRefExpr's with the same Decl or\n  // the base Expr's are CXXThisExpr's.\n  const Expr *LHSBase = LHSExpr;\n  const Expr *RHSBase = RHSExpr;\n  const MemberExpr *LHSME = dyn_cast<MemberExpr>(LHSExpr);\n  const MemberExpr *RHSME = dyn_cast<MemberExpr>(RHSExpr);\n  if (!LHSME || !RHSME)\n    return;\n\n  while (LHSME && RHSME) {\n    if (LHSME->getMemberDecl()->getCanonicalDecl() !=\n        RHSME->getMemberDecl()->getCanonicalDecl())\n      return;\n\n    LHSBase = LHSME->getBase();\n    RHSBase = RHSME->getBase();\n    LHSME = dyn_cast<MemberExpr>(LHSBase);\n    RHSME = dyn_cast<MemberExpr>(RHSBase);\n  }\n\n  LHSDeclRef = dyn_cast<DeclRefExpr>(LHSBase);\n  RHSDeclRef = dyn_cast<DeclRefExpr>(RHSBase);\n  if (LHSDeclRef && RHSDeclRef) {\n    if (!LHSDeclRef->getDecl() || !RHSDeclRef->getDecl())\n      return;\n    if (LHSDeclRef->getDecl()->getCanonicalDecl() !=\n        RHSDeclRef->getDecl()->getCanonicalDecl())\n      return;\n\n    Diag(OpLoc, diag::warn_self_move) << LHSExpr->getType()\n                                        << LHSExpr->getSourceRange()\n                                        << RHSExpr->getSourceRange();\n    return;\n  }\n\n  if (isa<CXXThisExpr>(LHSBase) && isa<CXXThisExpr>(RHSBase))\n    Diag(OpLoc, diag::warn_self_move) << LHSExpr->getType()\n                                        << LHSExpr->getSourceRange()\n                                        << RHSExpr->getSourceRange();\n}\n\n//===--- Layout compatibility ----------------------------------------------//\n\nstatic bool isLayoutCompatible(ASTContext &C, QualType T1, QualType T2);\n\n/// Check if two enumeration types are layout-compatible.\nstatic bool isLayoutCompatible(ASTContext &C, EnumDecl *ED1, EnumDecl *ED2) {\n  // C++11 [dcl.enum] p8:\n  // Two enumeration types are layout-compatible if they have the same\n  // underlying type.\n  return ED1->isComplete() && ED2->isComplete() &&\n         C.hasSameType(ED1->getIntegerType(), ED2->getIntegerType());\n}\n\n/// Check if two fields are layout-compatible.\nstatic bool isLayoutCompatible(ASTContext &C, FieldDecl *Field1,\n                               FieldDecl *Field2) {\n  if (!isLayoutCompatible(C, Field1->getType(), Field2->getType()))\n    return false;\n\n  if (Field1->isBitField() != Field2->isBitField())\n    return false;\n\n  if (Field1->isBitField()) {\n    // Make sure that the bit-fields are the same length.\n    unsigned Bits1 = Field1->getBitWidthValue(C);\n    unsigned Bits2 = Field2->getBitWidthValue(C);\n\n    if (Bits1 != Bits2)\n      return false;\n  }\n\n  return true;\n}\n\n/// Check if two standard-layout structs are layout-compatible.\n/// (C++11 [class.mem] p17)\nstatic bool isLayoutCompatibleStruct(ASTContext &C, RecordDecl *RD1,\n                                     RecordDecl *RD2) {\n  // If both records are C++ classes, check that base classes match.\n  if (const CXXRecordDecl *D1CXX = dyn_cast<CXXRecordDecl>(RD1)) {\n    // If one of records is a CXXRecordDecl we are in C++ mode,\n    // thus the other one is a CXXRecordDecl, too.\n    const CXXRecordDecl *D2CXX = cast<CXXRecordDecl>(RD2);\n    // Check number of base classes.\n    if (D1CXX->getNumBases() != D2CXX->getNumBases())\n      return false;\n\n    // Check the base classes.\n    for (CXXRecordDecl::base_class_const_iterator\n               Base1 = D1CXX->bases_begin(),\n           BaseEnd1 = D1CXX->bases_end(),\n              Base2 = D2CXX->bases_begin();\n         Base1 != BaseEnd1;\n         ++Base1, ++Base2) {\n      if (!isLayoutCompatible(C, Base1->getType(), Base2->getType()))\n        return false;\n    }\n  } else if (const CXXRecordDecl *D2CXX = dyn_cast<CXXRecordDecl>(RD2)) {\n    // If only RD2 is a C++ class, it should have zero base classes.\n    if (D2CXX->getNumBases() > 0)\n      return false;\n  }\n\n  // Check the fields.\n  RecordDecl::field_iterator Field2 = RD2->field_begin(),\n                             Field2End = RD2->field_end(),\n                             Field1 = RD1->field_begin(),\n                             Field1End = RD1->field_end();\n  for ( ; Field1 != Field1End && Field2 != Field2End; ++Field1, ++Field2) {\n    if (!isLayoutCompatible(C, *Field1, *Field2))\n      return false;\n  }\n  if (Field1 != Field1End || Field2 != Field2End)\n    return false;\n\n  return true;\n}\n\n/// Check if two standard-layout unions are layout-compatible.\n/// (C++11 [class.mem] p18)\nstatic bool isLayoutCompatibleUnion(ASTContext &C, RecordDecl *RD1,\n                                    RecordDecl *RD2) {\n  llvm::SmallPtrSet<FieldDecl *, 8> UnmatchedFields;\n  for (auto *Field2 : RD2->fields())\n    UnmatchedFields.insert(Field2);\n\n  for (auto *Field1 : RD1->fields()) {\n    llvm::SmallPtrSet<FieldDecl *, 8>::iterator\n        I = UnmatchedFields.begin(),\n        E = UnmatchedFields.end();\n\n    for ( ; I != E; ++I) {\n      if (isLayoutCompatible(C, Field1, *I)) {\n        bool Result = UnmatchedFields.erase(*I);\n        (void) Result;\n        assert(Result);\n        break;\n      }\n    }\n    if (I == E)\n      return false;\n  }\n\n  return UnmatchedFields.empty();\n}\n\nstatic bool isLayoutCompatible(ASTContext &C, RecordDecl *RD1,\n                               RecordDecl *RD2) {\n  if (RD1->isUnion() != RD2->isUnion())\n    return false;\n\n  if (RD1->isUnion())\n    return isLayoutCompatibleUnion(C, RD1, RD2);\n  else\n    return isLayoutCompatibleStruct(C, RD1, RD2);\n}\n\n/// Check if two types are layout-compatible in C++11 sense.\nstatic bool isLayoutCompatible(ASTContext &C, QualType T1, QualType T2) {\n  if (T1.isNull() || T2.isNull())\n    return false;\n\n  // C++11 [basic.types] p11:\n  // If two types T1 and T2 are the same type, then T1 and T2 are\n  // layout-compatible types.\n  if (C.hasSameType(T1, T2))\n    return true;\n\n  T1 = T1.getCanonicalType().getUnqualifiedType();\n  T2 = T2.getCanonicalType().getUnqualifiedType();\n\n  const Type::TypeClass TC1 = T1->getTypeClass();\n  const Type::TypeClass TC2 = T2->getTypeClass();\n\n  if (TC1 != TC2)\n    return false;\n\n  if (TC1 == Type::Enum) {\n    return isLayoutCompatible(C,\n                              cast<EnumType>(T1)->getDecl(),\n                              cast<EnumType>(T2)->getDecl());\n  } else if (TC1 == Type::Record) {\n    if (!T1->isStandardLayoutType() || !T2->isStandardLayoutType())\n      return false;\n\n    return isLayoutCompatible(C,\n                              cast<RecordType>(T1)->getDecl(),\n                              cast<RecordType>(T2)->getDecl());\n  }\n\n  return false;\n}\n\n//===--- CHECK: pointer_with_type_tag attribute: datatypes should match ----//\n\n/// Given a type tag expression find the type tag itself.\n///\n/// \\param TypeExpr Type tag expression, as it appears in user's code.\n///\n/// \\param VD Declaration of an identifier that appears in a type tag.\n///\n/// \\param MagicValue Type tag magic value.\n///\n/// \\param isConstantEvaluated wether the evalaution should be performed in\n\n/// constant context.\nstatic bool FindTypeTagExpr(const Expr *TypeExpr, const ASTContext &Ctx,\n                            const ValueDecl **VD, uint64_t *MagicValue,\n                            bool isConstantEvaluated) {\n  while(true) {\n    if (!TypeExpr)\n      return false;\n\n    TypeExpr = TypeExpr->IgnoreParenImpCasts()->IgnoreParenCasts();\n\n    switch (TypeExpr->getStmtClass()) {\n    case Stmt::UnaryOperatorClass: {\n      const UnaryOperator *UO = cast<UnaryOperator>(TypeExpr);\n      if (UO->getOpcode() == UO_AddrOf || UO->getOpcode() == UO_Deref) {\n        TypeExpr = UO->getSubExpr();\n        continue;\n      }\n      return false;\n    }\n\n    case Stmt::DeclRefExprClass: {\n      const DeclRefExpr *DRE = cast<DeclRefExpr>(TypeExpr);\n      *VD = DRE->getDecl();\n      return true;\n    }\n\n    case Stmt::IntegerLiteralClass: {\n      const IntegerLiteral *IL = cast<IntegerLiteral>(TypeExpr);\n      llvm::APInt MagicValueAPInt = IL->getValue();\n      if (MagicValueAPInt.getActiveBits() <= 64) {\n        *MagicValue = MagicValueAPInt.getZExtValue();\n        return true;\n      } else\n        return false;\n    }\n\n    case Stmt::BinaryConditionalOperatorClass:\n    case Stmt::ConditionalOperatorClass: {\n      const AbstractConditionalOperator *ACO =\n          cast<AbstractConditionalOperator>(TypeExpr);\n      bool Result;\n      if (ACO->getCond()->EvaluateAsBooleanCondition(Result, Ctx,\n                                                     isConstantEvaluated)) {\n        if (Result)\n          TypeExpr = ACO->getTrueExpr();\n        else\n          TypeExpr = ACO->getFalseExpr();\n        continue;\n      }\n      return false;\n    }\n\n    case Stmt::BinaryOperatorClass: {\n      const BinaryOperator *BO = cast<BinaryOperator>(TypeExpr);\n      if (BO->getOpcode() == BO_Comma) {\n        TypeExpr = BO->getRHS();\n        continue;\n      }\n      return false;\n    }\n\n    default:\n      return false;\n    }\n  }\n}\n\n/// Retrieve the C type corresponding to type tag TypeExpr.\n///\n/// \\param TypeExpr Expression that specifies a type tag.\n///\n/// \\param MagicValues Registered magic values.\n///\n/// \\param FoundWrongKind Set to true if a type tag was found, but of a wrong\n///        kind.\n///\n/// \\param TypeInfo Information about the corresponding C type.\n///\n/// \\param isConstantEvaluated wether the evalaution should be performed in\n/// constant context.\n///\n/// \\returns true if the corresponding C type was found.\nstatic bool GetMatchingCType(\n    const IdentifierInfo *ArgumentKind, const Expr *TypeExpr,\n    const ASTContext &Ctx,\n    const llvm::DenseMap<Sema::TypeTagMagicValue, Sema::TypeTagData>\n        *MagicValues,\n    bool &FoundWrongKind, Sema::TypeTagData &TypeInfo,\n    bool isConstantEvaluated) {\n  FoundWrongKind = false;\n\n  // Variable declaration that has type_tag_for_datatype attribute.\n  const ValueDecl *VD = nullptr;\n\n  uint64_t MagicValue;\n\n  if (!FindTypeTagExpr(TypeExpr, Ctx, &VD, &MagicValue, isConstantEvaluated))\n    return false;\n\n  if (VD) {\n    if (TypeTagForDatatypeAttr *I = VD->getAttr<TypeTagForDatatypeAttr>()) {\n      if (I->getArgumentKind() != ArgumentKind) {\n        FoundWrongKind = true;\n        return false;\n      }\n      TypeInfo.Type = I->getMatchingCType();\n      TypeInfo.LayoutCompatible = I->getLayoutCompatible();\n      TypeInfo.MustBeNull = I->getMustBeNull();\n      return true;\n    }\n    return false;\n  }\n\n  if (!MagicValues)\n    return false;\n\n  llvm::DenseMap<Sema::TypeTagMagicValue,\n                 Sema::TypeTagData>::const_iterator I =\n      MagicValues->find(std::make_pair(ArgumentKind, MagicValue));\n  if (I == MagicValues->end())\n    return false;\n\n  TypeInfo = I->second;\n  return true;\n}\n\nvoid Sema::RegisterTypeTagForDatatype(const IdentifierInfo *ArgumentKind,\n                                      uint64_t MagicValue, QualType Type,\n                                      bool LayoutCompatible,\n                                      bool MustBeNull) {\n  if (!TypeTagForDatatypeMagicValues)\n    TypeTagForDatatypeMagicValues.reset(\n        new llvm::DenseMap<TypeTagMagicValue, TypeTagData>);\n\n  TypeTagMagicValue Magic(ArgumentKind, MagicValue);\n  (*TypeTagForDatatypeMagicValues)[Magic] =\n      TypeTagData(Type, LayoutCompatible, MustBeNull);\n}\n\nstatic bool IsSameCharType(QualType T1, QualType T2) {\n  const BuiltinType *BT1 = T1->getAs<BuiltinType>();\n  if (!BT1)\n    return false;\n\n  const BuiltinType *BT2 = T2->getAs<BuiltinType>();\n  if (!BT2)\n    return false;\n\n  BuiltinType::Kind T1Kind = BT1->getKind();\n  BuiltinType::Kind T2Kind = BT2->getKind();\n\n  return (T1Kind == BuiltinType::SChar  && T2Kind == BuiltinType::Char_S) ||\n         (T1Kind == BuiltinType::UChar  && T2Kind == BuiltinType::Char_U) ||\n         (T1Kind == BuiltinType::Char_U && T2Kind == BuiltinType::UChar) ||\n         (T1Kind == BuiltinType::Char_S && T2Kind == BuiltinType::SChar);\n}\n\nvoid Sema::CheckArgumentWithTypeTag(const ArgumentWithTypeTagAttr *Attr,\n                                    const ArrayRef<const Expr *> ExprArgs,\n                                    SourceLocation CallSiteLoc) {\n  const IdentifierInfo *ArgumentKind = Attr->getArgumentKind();\n  bool IsPointerAttr = Attr->getIsPointer();\n\n  // Retrieve the argument representing the 'type_tag'.\n  unsigned TypeTagIdxAST = Attr->getTypeTagIdx().getASTIndex();\n  if (TypeTagIdxAST >= ExprArgs.size()) {\n    Diag(CallSiteLoc, diag::err_tag_index_out_of_range)\n        << 0 << Attr->getTypeTagIdx().getSourceIndex();\n    return;\n  }\n  const Expr *TypeTagExpr = ExprArgs[TypeTagIdxAST];\n  bool FoundWrongKind;\n  TypeTagData TypeInfo;\n  if (!GetMatchingCType(ArgumentKind, TypeTagExpr, Context,\n                        TypeTagForDatatypeMagicValues.get(), FoundWrongKind,\n                        TypeInfo, isConstantEvaluated())) {\n    if (FoundWrongKind)\n      Diag(TypeTagExpr->getExprLoc(),\n           diag::warn_type_tag_for_datatype_wrong_kind)\n        << TypeTagExpr->getSourceRange();\n    return;\n  }\n\n  // Retrieve the argument representing the 'arg_idx'.\n  unsigned ArgumentIdxAST = Attr->getArgumentIdx().getASTIndex();\n  if (ArgumentIdxAST >= ExprArgs.size()) {\n    Diag(CallSiteLoc, diag::err_tag_index_out_of_range)\n        << 1 << Attr->getArgumentIdx().getSourceIndex();\n    return;\n  }\n  const Expr *ArgumentExpr = ExprArgs[ArgumentIdxAST];\n  if (IsPointerAttr) {\n    // Skip implicit cast of pointer to `void *' (as a function argument).\n    if (const ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(ArgumentExpr))\n      if (ICE->getType()->isVoidPointerType() &&\n          ICE->getCastKind() == CK_BitCast)\n        ArgumentExpr = ICE->getSubExpr();\n  }\n  QualType ArgumentType = ArgumentExpr->getType();\n\n  // Passing a `void*' pointer shouldn't trigger a warning.\n  if (IsPointerAttr && ArgumentType->isVoidPointerType())\n    return;\n\n  if (TypeInfo.MustBeNull) {\n    // Type tag with matching void type requires a null pointer.\n    if (!ArgumentExpr->isNullPointerConstant(Context,\n                                             Expr::NPC_ValueDependentIsNotNull)) {\n      Diag(ArgumentExpr->getExprLoc(),\n           diag::warn_type_safety_null_pointer_required)\n          << ArgumentKind->getName()\n          << ArgumentExpr->getSourceRange()\n          << TypeTagExpr->getSourceRange();\n    }\n    return;\n  }\n\n  QualType RequiredType = TypeInfo.Type;\n  if (IsPointerAttr)\n    RequiredType = Context.getPointerType(RequiredType);\n\n  bool mismatch = false;\n  if (!TypeInfo.LayoutCompatible) {\n    mismatch = !Context.hasSameType(ArgumentType, RequiredType);\n\n    // C++11 [basic.fundamental] p1:\n    // Plain char, signed char, and unsigned char are three distinct types.\n    //\n    // But we treat plain `char' as equivalent to `signed char' or `unsigned\n    // char' depending on the current char signedness mode.\n    if (mismatch)\n      if ((IsPointerAttr && IsSameCharType(ArgumentType->getPointeeType(),\n                                           RequiredType->getPointeeType())) ||\n          (!IsPointerAttr && IsSameCharType(ArgumentType, RequiredType)))\n        mismatch = false;\n  } else\n    if (IsPointerAttr)\n      mismatch = !isLayoutCompatible(Context,\n                                     ArgumentType->getPointeeType(),\n                                     RequiredType->getPointeeType());\n    else\n      mismatch = !isLayoutCompatible(Context, ArgumentType, RequiredType);\n\n  if (mismatch)\n    Diag(ArgumentExpr->getExprLoc(), diag::warn_type_safety_type_mismatch)\n        << ArgumentType << ArgumentKind\n        << TypeInfo.LayoutCompatible << RequiredType\n        << ArgumentExpr->getSourceRange()\n        << TypeTagExpr->getSourceRange();\n}\n\nvoid Sema::AddPotentialMisalignedMembers(Expr *E, RecordDecl *RD, ValueDecl *MD,\n                                         CharUnits Alignment) {\n  MisalignedMembers.emplace_back(E, RD, MD, Alignment);\n}\n\nvoid Sema::DiagnoseMisalignedMembers() {\n  for (MisalignedMember &m : MisalignedMembers) {\n    const NamedDecl *ND = m.RD;\n    if (ND->getName().empty()) {\n      if (const TypedefNameDecl *TD = m.RD->getTypedefNameForAnonDecl())\n        ND = TD;\n    }\n    Diag(m.E->getBeginLoc(), diag::warn_taking_address_of_packed_member)\n        << m.MD << ND << m.E->getSourceRange();\n  }\n  MisalignedMembers.clear();\n}\n\nvoid Sema::DiscardMisalignedMemberAddress(const Type *T, Expr *E) {\n  E = E->IgnoreParens();\n  if (!T->isPointerType() && !T->isIntegerType())\n    return;\n  if (isa<UnaryOperator>(E) &&\n      cast<UnaryOperator>(E)->getOpcode() == UO_AddrOf) {\n    auto *Op = cast<UnaryOperator>(E)->getSubExpr()->IgnoreParens();\n    if (isa<MemberExpr>(Op)) {\n      auto MA = llvm::find(MisalignedMembers, MisalignedMember(Op));\n      if (MA != MisalignedMembers.end() &&\n          (T->isIntegerType() ||\n           (T->isPointerType() && (T->getPointeeType()->isIncompleteType() ||\n                                   Context.getTypeAlignInChars(\n                                       T->getPointeeType()) <= MA->Alignment))))\n        MisalignedMembers.erase(MA);\n    }\n  }\n}\n\nvoid Sema::RefersToMemberWithReducedAlignment(\n    Expr *E,\n    llvm::function_ref<void(Expr *, RecordDecl *, FieldDecl *, CharUnits)>\n        Action) {\n  const auto *ME = dyn_cast<MemberExpr>(E);\n  if (!ME)\n    return;\n\n  // No need to check expressions with an __unaligned-qualified type.\n  if (E->getType().getQualifiers().hasUnaligned())\n    return;\n\n  // For a chain of MemberExpr like \"a.b.c.d\" this list\n  // will keep FieldDecl's like [d, c, b].\n  SmallVector<FieldDecl *, 4> ReverseMemberChain;\n  const MemberExpr *TopME = nullptr;\n  bool AnyIsPacked = false;\n  do {\n    QualType BaseType = ME->getBase()->getType();\n    if (BaseType->isDependentType())\n      return;\n    if (ME->isArrow())\n      BaseType = BaseType->getPointeeType();\n    RecordDecl *RD = BaseType->castAs<RecordType>()->getDecl();\n    if (RD->isInvalidDecl())\n      return;\n\n    ValueDecl *MD = ME->getMemberDecl();\n    auto *FD = dyn_cast<FieldDecl>(MD);\n    // We do not care about non-data members.\n    if (!FD || FD->isInvalidDecl())\n      return;\n\n    AnyIsPacked =\n        AnyIsPacked || (RD->hasAttr<PackedAttr>() || MD->hasAttr<PackedAttr>());\n    ReverseMemberChain.push_back(FD);\n\n    TopME = ME;\n    ME = dyn_cast<MemberExpr>(ME->getBase()->IgnoreParens());\n  } while (ME);\n  assert(TopME && \"We did not compute a topmost MemberExpr!\");\n\n  // Not the scope of this diagnostic.\n  if (!AnyIsPacked)\n    return;\n\n  const Expr *TopBase = TopME->getBase()->IgnoreParenImpCasts();\n  const auto *DRE = dyn_cast<DeclRefExpr>(TopBase);\n  // TODO: The innermost base of the member expression may be too complicated.\n  // For now, just disregard these cases. This is left for future\n  // improvement.\n  if (!DRE && !isa<CXXThisExpr>(TopBase))\n      return;\n\n  // Alignment expected by the whole expression.\n  CharUnits ExpectedAlignment = Context.getTypeAlignInChars(E->getType());\n\n  // No need to do anything else with this case.\n  if (ExpectedAlignment.isOne())\n    return;\n\n  // Synthesize offset of the whole access.\n  CharUnits Offset;\n  for (auto I = ReverseMemberChain.rbegin(); I != ReverseMemberChain.rend();\n       I++) {\n    Offset += Context.toCharUnitsFromBits(Context.getFieldOffset(*I));\n  }\n\n  // Compute the CompleteObjectAlignment as the alignment of the whole chain.\n  CharUnits CompleteObjectAlignment = Context.getTypeAlignInChars(\n      ReverseMemberChain.back()->getParent()->getTypeForDecl());\n\n  // The base expression of the innermost MemberExpr may give\n  // stronger guarantees than the class containing the member.\n  if (DRE && !TopME->isArrow()) {\n    const ValueDecl *VD = DRE->getDecl();\n    if (!VD->getType()->isReferenceType())\n      CompleteObjectAlignment =\n          std::max(CompleteObjectAlignment, Context.getDeclAlign(VD));\n  }\n\n  // Check if the synthesized offset fulfills the alignment.\n  if (Offset % ExpectedAlignment != 0 ||\n      // It may fulfill the offset it but the effective alignment may still be\n      // lower than the expected expression alignment.\n      CompleteObjectAlignment < ExpectedAlignment) {\n    // If this happens, we want to determine a sensible culprit of this.\n    // Intuitively, watching the chain of member expressions from right to\n    // left, we start with the required alignment (as required by the field\n    // type) but some packed attribute in that chain has reduced the alignment.\n    // It may happen that another packed structure increases it again. But if\n    // we are here such increase has not been enough. So pointing the first\n    // FieldDecl that either is packed or else its RecordDecl is,\n    // seems reasonable.\n    FieldDecl *FD = nullptr;\n    CharUnits Alignment;\n    for (FieldDecl *FDI : ReverseMemberChain) {\n      if (FDI->hasAttr<PackedAttr>() ||\n          FDI->getParent()->hasAttr<PackedAttr>()) {\n        FD = FDI;\n        Alignment = std::min(\n            Context.getTypeAlignInChars(FD->getType()),\n            Context.getTypeAlignInChars(FD->getParent()->getTypeForDecl()));\n        break;\n      }\n    }\n    assert(FD && \"We did not find a packed FieldDecl!\");\n    Action(E, FD->getParent(), FD, Alignment);\n  }\n}\n\nvoid Sema::CheckAddressOfPackedMember(Expr *rhs) {\n  using namespace std::placeholders;\n\n  RefersToMemberWithReducedAlignment(\n      rhs, std::bind(&Sema::AddPotentialMisalignedMembers, std::ref(*this), _1,\n                     _2, _3, _4));\n}\n\nExprResult Sema::SemaBuiltinMatrixTranspose(CallExpr *TheCall,\n                                            ExprResult CallResult) {\n  if (checkArgCount(*this, TheCall, 1))\n    return ExprError();\n\n  ExprResult MatrixArg = DefaultLvalueConversion(TheCall->getArg(0));\n  if (MatrixArg.isInvalid())\n    return MatrixArg;\n  Expr *Matrix = MatrixArg.get();\n\n  auto *MType = Matrix->getType()->getAs<ConstantMatrixType>();\n  if (!MType) {\n    Diag(Matrix->getBeginLoc(), diag::err_builtin_matrix_arg);\n    return ExprError();\n  }\n\n  // Create returned matrix type by swapping rows and columns of the argument\n  // matrix type.\n  QualType ResultType = Context.getConstantMatrixType(\n      MType->getElementType(), MType->getNumColumns(), MType->getNumRows());\n\n  // Change the return type to the type of the returned matrix.\n  TheCall->setType(ResultType);\n\n  // Update call argument to use the possibly converted matrix argument.\n  TheCall->setArg(0, Matrix);\n  return CallResult;\n}\n\n// Get and verify the matrix dimensions.\nstatic llvm::Optional<unsigned>\ngetAndVerifyMatrixDimension(Expr *Expr, StringRef Name, Sema &S) {\n  SourceLocation ErrorPos;\n  Optional<llvm::APSInt> Value =\n      Expr->getIntegerConstantExpr(S.Context, &ErrorPos);\n  if (!Value) {\n    S.Diag(Expr->getBeginLoc(), diag::err_builtin_matrix_scalar_unsigned_arg)\n        << Name;\n    return {};\n  }\n  uint64_t Dim = Value->getZExtValue();\n  if (!ConstantMatrixType::isDimensionValid(Dim)) {\n    S.Diag(Expr->getBeginLoc(), diag::err_builtin_matrix_invalid_dimension)\n        << Name << ConstantMatrixType::getMaxElementsPerDimension();\n    return {};\n  }\n  return Dim;\n}\n\nExprResult Sema::SemaBuiltinMatrixColumnMajorLoad(CallExpr *TheCall,\n                                                  ExprResult CallResult) {\n  if (!getLangOpts().MatrixTypes) {\n    Diag(TheCall->getBeginLoc(), diag::err_builtin_matrix_disabled);\n    return ExprError();\n  }\n\n  if (checkArgCount(*this, TheCall, 4))\n    return ExprError();\n\n  unsigned PtrArgIdx = 0;\n  Expr *PtrExpr = TheCall->getArg(PtrArgIdx);\n  Expr *RowsExpr = TheCall->getArg(1);\n  Expr *ColumnsExpr = TheCall->getArg(2);\n  Expr *StrideExpr = TheCall->getArg(3);\n\n  bool ArgError = false;\n\n  // Check pointer argument.\n  {\n    ExprResult PtrConv = DefaultFunctionArrayLvalueConversion(PtrExpr);\n    if (PtrConv.isInvalid())\n      return PtrConv;\n    PtrExpr = PtrConv.get();\n    TheCall->setArg(0, PtrExpr);\n    if (PtrExpr->isTypeDependent()) {\n      TheCall->setType(Context.DependentTy);\n      return TheCall;\n    }\n  }\n\n  auto *PtrTy = PtrExpr->getType()->getAs<PointerType>();\n  QualType ElementTy;\n  if (!PtrTy) {\n    Diag(PtrExpr->getBeginLoc(), diag::err_builtin_matrix_pointer_arg)\n        << PtrArgIdx + 1;\n    ArgError = true;\n  } else {\n    ElementTy = PtrTy->getPointeeType().getUnqualifiedType();\n\n    if (!ConstantMatrixType::isValidElementType(ElementTy)) {\n      Diag(PtrExpr->getBeginLoc(), diag::err_builtin_matrix_pointer_arg)\n          << PtrArgIdx + 1;\n      ArgError = true;\n    }\n  }\n\n  // Apply default Lvalue conversions and convert the expression to size_t.\n  auto ApplyArgumentConversions = [this](Expr *E) {\n    ExprResult Conv = DefaultLvalueConversion(E);\n    if (Conv.isInvalid())\n      return Conv;\n\n    return tryConvertExprToType(Conv.get(), Context.getSizeType());\n  };\n\n  // Apply conversion to row and column expressions.\n  ExprResult RowsConv = ApplyArgumentConversions(RowsExpr);\n  if (!RowsConv.isInvalid()) {\n    RowsExpr = RowsConv.get();\n    TheCall->setArg(1, RowsExpr);\n  } else\n    RowsExpr = nullptr;\n\n  ExprResult ColumnsConv = ApplyArgumentConversions(ColumnsExpr);\n  if (!ColumnsConv.isInvalid()) {\n    ColumnsExpr = ColumnsConv.get();\n    TheCall->setArg(2, ColumnsExpr);\n  } else\n    ColumnsExpr = nullptr;\n\n  // If any any part of the result matrix type is still pending, just use\n  // Context.DependentTy, until all parts are resolved.\n  if ((RowsExpr && RowsExpr->isTypeDependent()) ||\n      (ColumnsExpr && ColumnsExpr->isTypeDependent())) {\n    TheCall->setType(Context.DependentTy);\n    return CallResult;\n  }\n\n  // Check row and column dimenions.\n  llvm::Optional<unsigned> MaybeRows;\n  if (RowsExpr)\n    MaybeRows = getAndVerifyMatrixDimension(RowsExpr, \"row\", *this);\n\n  llvm::Optional<unsigned> MaybeColumns;\n  if (ColumnsExpr)\n    MaybeColumns = getAndVerifyMatrixDimension(ColumnsExpr, \"column\", *this);\n\n  // Check stride argument.\n  ExprResult StrideConv = ApplyArgumentConversions(StrideExpr);\n  if (StrideConv.isInvalid())\n    return ExprError();\n  StrideExpr = StrideConv.get();\n  TheCall->setArg(3, StrideExpr);\n\n  if (MaybeRows) {\n    if (Optional<llvm::APSInt> Value =\n            StrideExpr->getIntegerConstantExpr(Context)) {\n      uint64_t Stride = Value->getZExtValue();\n      if (Stride < *MaybeRows) {\n        Diag(StrideExpr->getBeginLoc(),\n             diag::err_builtin_matrix_stride_too_small);\n        ArgError = true;\n      }\n    }\n  }\n\n  if (ArgError || !MaybeRows || !MaybeColumns)\n    return ExprError();\n\n  TheCall->setType(\n      Context.getConstantMatrixType(ElementTy, *MaybeRows, *MaybeColumns));\n  return CallResult;\n}\n\nExprResult Sema::SemaBuiltinMatrixColumnMajorStore(CallExpr *TheCall,\n                                                   ExprResult CallResult) {\n  if (checkArgCount(*this, TheCall, 3))\n    return ExprError();\n\n  unsigned PtrArgIdx = 1;\n  Expr *MatrixExpr = TheCall->getArg(0);\n  Expr *PtrExpr = TheCall->getArg(PtrArgIdx);\n  Expr *StrideExpr = TheCall->getArg(2);\n\n  bool ArgError = false;\n\n  {\n    ExprResult MatrixConv = DefaultLvalueConversion(MatrixExpr);\n    if (MatrixConv.isInvalid())\n      return MatrixConv;\n    MatrixExpr = MatrixConv.get();\n    TheCall->setArg(0, MatrixExpr);\n  }\n  if (MatrixExpr->isTypeDependent()) {\n    TheCall->setType(Context.DependentTy);\n    return TheCall;\n  }\n\n  auto *MatrixTy = MatrixExpr->getType()->getAs<ConstantMatrixType>();\n  if (!MatrixTy) {\n    Diag(MatrixExpr->getBeginLoc(), diag::err_builtin_matrix_arg) << 0;\n    ArgError = true;\n  }\n\n  {\n    ExprResult PtrConv = DefaultFunctionArrayLvalueConversion(PtrExpr);\n    if (PtrConv.isInvalid())\n      return PtrConv;\n    PtrExpr = PtrConv.get();\n    TheCall->setArg(1, PtrExpr);\n    if (PtrExpr->isTypeDependent()) {\n      TheCall->setType(Context.DependentTy);\n      return TheCall;\n    }\n  }\n\n  // Check pointer argument.\n  auto *PtrTy = PtrExpr->getType()->getAs<PointerType>();\n  if (!PtrTy) {\n    Diag(PtrExpr->getBeginLoc(), diag::err_builtin_matrix_pointer_arg)\n        << PtrArgIdx + 1;\n    ArgError = true;\n  } else {\n    QualType ElementTy = PtrTy->getPointeeType();\n    if (ElementTy.isConstQualified()) {\n      Diag(PtrExpr->getBeginLoc(), diag::err_builtin_matrix_store_to_const);\n      ArgError = true;\n    }\n    ElementTy = ElementTy.getUnqualifiedType().getCanonicalType();\n    if (MatrixTy &&\n        !Context.hasSameType(ElementTy, MatrixTy->getElementType())) {\n      Diag(PtrExpr->getBeginLoc(),\n           diag::err_builtin_matrix_pointer_arg_mismatch)\n          << ElementTy << MatrixTy->getElementType();\n      ArgError = true;\n    }\n  }\n\n  // Apply default Lvalue conversions and convert the stride expression to\n  // size_t.\n  {\n    ExprResult StrideConv = DefaultLvalueConversion(StrideExpr);\n    if (StrideConv.isInvalid())\n      return StrideConv;\n\n    StrideConv = tryConvertExprToType(StrideConv.get(), Context.getSizeType());\n    if (StrideConv.isInvalid())\n      return StrideConv;\n    StrideExpr = StrideConv.get();\n    TheCall->setArg(2, StrideExpr);\n  }\n\n  // Check stride argument.\n  if (MatrixTy) {\n    if (Optional<llvm::APSInt> Value =\n            StrideExpr->getIntegerConstantExpr(Context)) {\n      uint64_t Stride = Value->getZExtValue();\n      if (Stride < MatrixTy->getNumRows()) {\n        Diag(StrideExpr->getBeginLoc(),\n             diag::err_builtin_matrix_stride_too_small);\n        ArgError = true;\n      }\n    }\n  }\n\n  if (ArgError)\n    return ExprError();\n\n  return CallResult;\n}\n\n/// \\brief Enforce the bounds of a TCB\n/// CheckTCBEnforcement - Enforces that every function in a named TCB only\n/// directly calls other functions in the same TCB as marked by the enforce_tcb\n/// and enforce_tcb_leaf attributes.\nvoid Sema::CheckTCBEnforcement(const CallExpr *TheCall,\n                               const FunctionDecl *Callee) {\n  const FunctionDecl *Caller = getCurFunctionDecl();\n\n  // Calls to builtins are not enforced.\n  if (!Caller || !Caller->hasAttr<EnforceTCBAttr>() ||\n      Callee->getBuiltinID() != 0)\n    return;\n\n  // Search through the enforce_tcb and enforce_tcb_leaf attributes to find\n  // all TCBs the callee is a part of.\n  llvm::StringSet<> CalleeTCBs;\n  for_each(Callee->specific_attrs<EnforceTCBAttr>(),\n           [&](const auto *A) { CalleeTCBs.insert(A->getTCBName()); });\n  for_each(Callee->specific_attrs<EnforceTCBLeafAttr>(),\n           [&](const auto *A) { CalleeTCBs.insert(A->getTCBName()); });\n\n  // Go through the TCBs the caller is a part of and emit warnings if Caller\n  // is in a TCB that the Callee is not.\n  for_each(\n      Caller->specific_attrs<EnforceTCBAttr>(),\n      [&](const auto *A) {\n        StringRef CallerTCB = A->getTCBName();\n        if (CalleeTCBs.count(CallerTCB) == 0) {\n          this->Diag(TheCall->getExprLoc(),\n                     diag::warn_tcb_enforcement_violation) << Callee\n                                                           << CallerTCB;\n        }\n      });\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 22, "line": 13139}, "message": "mark 'noexcept'"}, {"location": {"col": 7, "file": 22, "line": 13139}, "message": "default constructor 'Seq' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaChecking.cpp", "reportHash": "113c4ccf5fe9bf276957ada031b9fce1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 22, "line": 13142}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 22, "line": 13142}, "message": "default constructor 'SequenceTree' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaChecking.cpp", "reportHash": "1b00efb9d1a597451ffa2c2440e66801", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 22, "line": 13208}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 22, "line": 13208}, "message": "default constructor 'Usage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaChecking.cpp", "reportHash": "358c733bd49a8c88d0665b12a2fb11a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 22, "line": 13217}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 22, "line": 13217}, "message": "default constructor 'UsageInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaChecking.cpp", "reportHash": "58dd92db1a0ebf034c12dc86126536dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
