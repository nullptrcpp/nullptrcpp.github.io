<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "content": "//===--- Expr.h - Classes for representing expressions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Expr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPR_H\n#define LLVM_CLANG_AST_EXPR_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTVector.h\"\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SyncScope.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n\nnamespace clang {\n  class APValue;\n  class ASTContext;\n  class BlockDecl;\n  class CXXBaseSpecifier;\n  class CXXMemberCallExpr;\n  class CXXOperatorCallExpr;\n  class CastExpr;\n  class Decl;\n  class IdentifierInfo;\n  class MaterializeTemporaryExpr;\n  class NamedDecl;\n  class ObjCPropertyRefExpr;\n  class OpaqueValueExpr;\n  class ParmVarDecl;\n  class StringLiteral;\n  class TargetInfo;\n  class ValueDecl;\n\n/// A simple array of base specifiers.\ntypedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n\n/// An adjustment to be made to the temporary created when emitting a\n/// reference binding, which accesses a particular subobject of that temporary.\nstruct SubobjectAdjustment {\n  enum {\n    DerivedToBaseAdjustment,\n    FieldAdjustment,\n    MemberPointerAdjustment\n  } Kind;\n\n  struct DTB {\n    const CastExpr *BasePath;\n    const CXXRecordDecl *DerivedClass;\n  };\n\n  struct P {\n    const MemberPointerType *MPT;\n    Expr *RHS;\n  };\n\n  union {\n    struct DTB DerivedToBase;\n    FieldDecl *Field;\n    struct P Ptr;\n  };\n\n  SubobjectAdjustment(const CastExpr *BasePath,\n                      const CXXRecordDecl *DerivedClass)\n    : Kind(DerivedToBaseAdjustment) {\n    DerivedToBase.BasePath = BasePath;\n    DerivedToBase.DerivedClass = DerivedClass;\n  }\n\n  SubobjectAdjustment(FieldDecl *Field)\n    : Kind(FieldAdjustment) {\n    this->Field = Field;\n  }\n\n  SubobjectAdjustment(const MemberPointerType *MPT, Expr *RHS)\n    : Kind(MemberPointerAdjustment) {\n    this->Ptr.MPT = MPT;\n    this->Ptr.RHS = RHS;\n  }\n};\n\n/// This represents one expression.  Note that Expr's are subclasses of Stmt.\n/// This allows an expression to be transparently used any place a Stmt is\n/// required.\nclass Expr : public ValueStmt {\n  QualType TR;\n\npublic:\n  Expr() = delete;\n  Expr(const Expr&) = delete;\n  Expr(Expr &&) = delete;\n  Expr &operator=(const Expr&) = delete;\n  Expr &operator=(Expr&&) = delete;\n\nprotected:\n  Expr(StmtClass SC, QualType T, ExprValueKind VK, ExprObjectKind OK)\n      : ValueStmt(SC) {\n    ExprBits.Dependent = 0;\n    ExprBits.ValueKind = VK;\n    ExprBits.ObjectKind = OK;\n    assert(ExprBits.ObjectKind == OK && \"truncated kind\");\n    setType(T);\n  }\n\n  /// Construct an empty expression.\n  explicit Expr(StmtClass SC, EmptyShell) : ValueStmt(SC) { }\n\n  /// Each concrete expr subclass is expected to compute its dependence and call\n  /// this in the constructor.\n  void setDependence(ExprDependence Deps) {\n    ExprBits.Dependent = static_cast<unsigned>(Deps);\n  }\n  friend class ASTImporter; // Sets dependence dircetly.\n  friend class ASTStmtReader; // Sets dependence dircetly.\n\npublic:\n  QualType getType() const { return TR; }\n  void setType(QualType t) {\n    // In C++, the type of an expression is always adjusted so that it\n    // will not have reference type (C++ [expr]p6). Use\n    // QualType::getNonReferenceType() to retrieve the non-reference\n    // type. Additionally, inspect Expr::isLvalue to determine whether\n    // an expression that is adjusted in this manner should be\n    // considered an lvalue.\n    assert((t.isNull() || !t->isReferenceType()) &&\n           \"Expressions can't have reference type\");\n\n    TR = t;\n  }\n\n  ExprDependence getDependence() const {\n    return static_cast<ExprDependence>(ExprBits.Dependent);\n  }\n\n  /// Determines whether the value of this expression depends on\n  ///   - a template parameter (C++ [temp.dep.constexpr])\n  ///   - or an error, whose resolution is unknown\n  ///\n  /// For example, the array bound of \"Chars\" in the following example is\n  /// value-dependent.\n  /// @code\n  /// template<int Size, char (&Chars)[Size]> struct meta_string;\n  /// @endcode\n  bool isValueDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Value);\n  }\n\n  /// Determines whether the type of this expression depends on\n  ///   - a template paramter (C++ [temp.dep.expr], which means that its type\n  ///     could change from one template instantiation to the next)\n  ///   - or an error\n  ///\n  /// For example, the expressions \"x\" and \"x + y\" are type-dependent in\n  /// the following code, but \"y\" is not type-dependent:\n  /// @code\n  /// template<typename T>\n  /// void add(T x, int y) {\n  ///   x + y;\n  /// }\n  /// @endcode\n  bool isTypeDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Type);\n  }\n\n  /// Whether this expression is instantiation-dependent, meaning that\n  /// it depends in some way on\n  ///    - a template parameter (even if neither its type nor (constant) value\n  ///      can change due to the template instantiation)\n  ///    - or an error\n  ///\n  /// In the following example, the expression \\c sizeof(sizeof(T() + T())) is\n  /// instantiation-dependent (since it involves a template parameter \\c T), but\n  /// is neither type- nor value-dependent, since the type of the inner\n  /// \\c sizeof is known (\\c std::size_t) and therefore the size of the outer\n  /// \\c sizeof is known.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// void f(T x, T y) {\n  ///   sizeof(sizeof(T() + T());\n  /// }\n  /// \\endcode\n  ///\n  /// \\code\n  /// void func(int) {\n  ///   func(); // the expression is instantiation-dependent, because it depends\n  ///           // on an error.\n  /// }\n  /// \\endcode\n  bool isInstantiationDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Instantiation);\n  }\n\n  /// Whether this expression contains an unexpanded parameter\n  /// pack (for C++11 variadic templates).\n  ///\n  /// Given the following function template:\n  ///\n  /// \\code\n  /// template<typename F, typename ...Types>\n  /// void forward(const F &f, Types &&...args) {\n  ///   f(static_cast<Types&&>(args)...);\n  /// }\n  /// \\endcode\n  ///\n  /// The expressions \\c args and \\c static_cast<Types&&>(args) both\n  /// contain parameter packs.\n  bool containsUnexpandedParameterPack() const {\n    return static_cast<bool>(getDependence() & ExprDependence::UnexpandedPack);\n  }\n\n  /// Whether this expression contains subexpressions which had errors, e.g. a\n  /// TypoExpr.\n  bool containsErrors() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Error);\n  }\n\n  /// getExprLoc - Return the preferred location for the arrow when diagnosing\n  /// a problem with a generic expression.\n  SourceLocation getExprLoc() const LLVM_READONLY;\n\n  /// Determine whether an lvalue-to-rvalue conversion should implicitly be\n  /// applied to this expression if it appears as a discarded-value expression\n  /// in C++11 onwards. This applies to certain forms of volatile glvalues.\n  bool isReadIfDiscardedInCPlusPlus11() const;\n\n  /// isUnusedResultAWarning - Return true if this immediate expression should\n  /// be warned about if the result is unused.  If so, fill in expr, location,\n  /// and ranges with expr to warn on and source locations/ranges appropriate\n  /// for a warning.\n  bool isUnusedResultAWarning(const Expr *&WarnExpr, SourceLocation &Loc,\n                              SourceRange &R1, SourceRange &R2,\n                              ASTContext &Ctx) const;\n\n  /// isLValue - True if this expression is an \"l-value\" according to\n  /// the rules of the current language.  C and C++ give somewhat\n  /// different rules for this concept, but in general, the result of\n  /// an l-value expression identifies a specific object whereas the\n  /// result of an r-value expression is a value detached from any\n  /// specific storage.\n  ///\n  /// C++11 divides the concept of \"r-value\" into pure r-values\n  /// (\"pr-values\") and so-called expiring values (\"x-values\"), which\n  /// identify specific objects that can be safely cannibalized for\n  /// their resources.  This is an unfortunate abuse of terminology on\n  /// the part of the C++ committee.  In Clang, when we say \"r-value\",\n  /// we generally mean a pr-value.\n  bool isLValue() const { return getValueKind() == VK_LValue; }\n  bool isRValue() const { return getValueKind() == VK_RValue; }\n  bool isXValue() const { return getValueKind() == VK_XValue; }\n  bool isGLValue() const { return getValueKind() != VK_RValue; }\n\n  enum LValueClassification {\n    LV_Valid,\n    LV_NotObjectType,\n    LV_IncompleteVoidType,\n    LV_DuplicateVectorComponents,\n    LV_InvalidExpression,\n    LV_InvalidMessageExpression,\n    LV_MemberFunction,\n    LV_SubObjCPropertySetting,\n    LV_ClassTemporary,\n    LV_ArrayTemporary\n  };\n  /// Reasons why an expression might not be an l-value.\n  LValueClassification ClassifyLValue(ASTContext &Ctx) const;\n\n  enum isModifiableLvalueResult {\n    MLV_Valid,\n    MLV_NotObjectType,\n    MLV_IncompleteVoidType,\n    MLV_DuplicateVectorComponents,\n    MLV_InvalidExpression,\n    MLV_LValueCast,           // Specialized form of MLV_InvalidExpression.\n    MLV_IncompleteType,\n    MLV_ConstQualified,\n    MLV_ConstQualifiedField,\n    MLV_ConstAddrSpace,\n    MLV_ArrayType,\n    MLV_NoSetterProperty,\n    MLV_MemberFunction,\n    MLV_SubObjCPropertySetting,\n    MLV_InvalidMessageExpression,\n    MLV_ClassTemporary,\n    MLV_ArrayTemporary\n  };\n  /// isModifiableLvalue - C99 6.3.2.1: an lvalue that does not have array type,\n  /// does not have an incomplete type, does not have a const-qualified type,\n  /// and if it is a structure or union, does not have any member (including,\n  /// recursively, any member or element of all contained aggregates or unions)\n  /// with a const-qualified type.\n  ///\n  /// \\param Loc [in,out] - A source location which *may* be filled\n  /// in with the location of the expression making this a\n  /// non-modifiable lvalue, if specified.\n  isModifiableLvalueResult\n  isModifiableLvalue(ASTContext &Ctx, SourceLocation *Loc = nullptr) const;\n\n  /// The return type of classify(). Represents the C++11 expression\n  ///        taxonomy.\n  class Classification {\n  public:\n    /// The various classification results. Most of these mean prvalue.\n    enum Kinds {\n      CL_LValue,\n      CL_XValue,\n      CL_Function, // Functions cannot be lvalues in C.\n      CL_Void, // Void cannot be an lvalue in C.\n      CL_AddressableVoid, // Void expression whose address can be taken in C.\n      CL_DuplicateVectorComponents, // A vector shuffle with dupes.\n      CL_MemberFunction, // An expression referring to a member function\n      CL_SubObjCPropertySetting,\n      CL_ClassTemporary, // A temporary of class type, or subobject thereof.\n      CL_ArrayTemporary, // A temporary of array type.\n      CL_ObjCMessageRValue, // ObjC message is an rvalue\n      CL_PRValue // A prvalue for any other reason, of any other type\n    };\n    /// The results of modification testing.\n    enum ModifiableType {\n      CM_Untested, // testModifiable was false.\n      CM_Modifiable,\n      CM_RValue, // Not modifiable because it's an rvalue\n      CM_Function, // Not modifiable because it's a function; C++ only\n      CM_LValueCast, // Same as CM_RValue, but indicates GCC cast-as-lvalue ext\n      CM_NoSetterProperty,// Implicit assignment to ObjC property without setter\n      CM_ConstQualified,\n      CM_ConstQualifiedField,\n      CM_ConstAddrSpace,\n      CM_ArrayType,\n      CM_IncompleteType\n    };\n\n  private:\n    friend class Expr;\n\n    unsigned short Kind;\n    unsigned short Modifiable;\n\n    explicit Classification(Kinds k, ModifiableType m)\n      : Kind(k), Modifiable(m)\n    {}\n\n  public:\n    Classification() {}\n\n    Kinds getKind() const { return static_cast<Kinds>(Kind); }\n    ModifiableType getModifiable() const {\n      assert(Modifiable != CM_Untested && \"Did not test for modifiability.\");\n      return static_cast<ModifiableType>(Modifiable);\n    }\n    bool isLValue() const { return Kind == CL_LValue; }\n    bool isXValue() const { return Kind == CL_XValue; }\n    bool isGLValue() const { return Kind <= CL_XValue; }\n    bool isPRValue() const { return Kind >= CL_Function; }\n    bool isRValue() const { return Kind >= CL_XValue; }\n    bool isModifiable() const { return getModifiable() == CM_Modifiable; }\n\n    /// Create a simple, modifiably lvalue\n    static Classification makeSimpleLValue() {\n      return Classification(CL_LValue, CM_Modifiable);\n    }\n\n  };\n  /// Classify - Classify this expression according to the C++11\n  ///        expression taxonomy.\n  ///\n  /// C++11 defines ([basic.lval]) a new taxonomy of expressions to replace the\n  /// old lvalue vs rvalue. This function determines the type of expression this\n  /// is. There are three expression types:\n  /// - lvalues are classical lvalues as in C++03.\n  /// - prvalues are equivalent to rvalues in C++03.\n  /// - xvalues are expressions yielding unnamed rvalue references, e.g. a\n  ///   function returning an rvalue reference.\n  /// lvalues and xvalues are collectively referred to as glvalues, while\n  /// prvalues and xvalues together form rvalues.\n  Classification Classify(ASTContext &Ctx) const {\n    return ClassifyImpl(Ctx, nullptr);\n  }\n\n  /// ClassifyModifiable - Classify this expression according to the\n  ///        C++11 expression taxonomy, and see if it is valid on the left side\n  ///        of an assignment.\n  ///\n  /// This function extends classify in that it also tests whether the\n  /// expression is modifiable (C99 6.3.2.1p1).\n  /// \\param Loc A source location that might be filled with a relevant location\n  ///            if the expression is not modifiable.\n  Classification ClassifyModifiable(ASTContext &Ctx, SourceLocation &Loc) const{\n    return ClassifyImpl(Ctx, &Loc);\n  }\n\n  /// Returns the set of floating point options that apply to this expression.\n  /// Only meaningful for operations on floating point values.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const;\n\n  /// getValueKindForType - Given a formal return or parameter type,\n  /// give its value kind.\n  static ExprValueKind getValueKindForType(QualType T) {\n    if (const ReferenceType *RT = T->getAs<ReferenceType>())\n      return (isa<LValueReferenceType>(RT)\n                ? VK_LValue\n                : (RT->getPointeeType()->isFunctionType()\n                     ? VK_LValue : VK_XValue));\n    return VK_RValue;\n  }\n\n  /// getValueKind - The value kind that this expression produces.\n  ExprValueKind getValueKind() const {\n    return static_cast<ExprValueKind>(ExprBits.ValueKind);\n  }\n\n  /// getObjectKind - The object kind that this expression produces.\n  /// Object kinds are meaningful only for expressions that yield an\n  /// l-value or x-value.\n  ExprObjectKind getObjectKind() const {\n    return static_cast<ExprObjectKind>(ExprBits.ObjectKind);\n  }\n\n  bool isOrdinaryOrBitFieldObject() const {\n    ExprObjectKind OK = getObjectKind();\n    return (OK == OK_Ordinary || OK == OK_BitField);\n  }\n\n  /// setValueKind - Set the value kind produced by this expression.\n  void setValueKind(ExprValueKind Cat) { ExprBits.ValueKind = Cat; }\n\n  /// setObjectKind - Set the object kind produced by this expression.\n  void setObjectKind(ExprObjectKind Cat) { ExprBits.ObjectKind = Cat; }\n\nprivate:\n  Classification ClassifyImpl(ASTContext &Ctx, SourceLocation *Loc) const;\n\npublic:\n\n  /// Returns true if this expression is a gl-value that\n  /// potentially refers to a bit-field.\n  ///\n  /// In C++, whether a gl-value refers to a bitfield is essentially\n  /// an aspect of the value-kind type system.\n  bool refersToBitField() const { return getObjectKind() == OK_BitField; }\n\n  /// If this expression refers to a bit-field, retrieve the\n  /// declaration of that bit-field.\n  ///\n  /// Note that this returns a non-null pointer in subtly different\n  /// places than refersToBitField returns true.  In particular, this can\n  /// return a non-null pointer even for r-values loaded from\n  /// bit-fields, but it will return null for a conditional bit-field.\n  FieldDecl *getSourceBitField();\n\n  const FieldDecl *getSourceBitField() const {\n    return const_cast<Expr*>(this)->getSourceBitField();\n  }\n\n  Decl *getReferencedDeclOfCallee();\n  const Decl *getReferencedDeclOfCallee() const {\n    return const_cast<Expr*>(this)->getReferencedDeclOfCallee();\n  }\n\n  /// If this expression is an l-value for an Objective C\n  /// property, find the underlying property reference expression.\n  const ObjCPropertyRefExpr *getObjCProperty() const;\n\n  /// Check if this expression is the ObjC 'self' implicit parameter.\n  bool isObjCSelfExpr() const;\n\n  /// Returns whether this expression refers to a vector element.\n  bool refersToVectorElement() const;\n\n  /// Returns whether this expression refers to a matrix element.\n  bool refersToMatrixElement() const {\n    return getObjectKind() == OK_MatrixComponent;\n  }\n\n  /// Returns whether this expression refers to a global register\n  /// variable.\n  bool refersToGlobalRegisterVar() const;\n\n  /// Returns whether this expression has a placeholder type.\n  bool hasPlaceholderType() const {\n    return getType()->isPlaceholderType();\n  }\n\n  /// Returns whether this expression has a specific placeholder type.\n  bool hasPlaceholderType(BuiltinType::Kind K) const {\n    assert(BuiltinType::isPlaceholderTypeKind(K));\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(getType()))\n      return BT->getKind() == K;\n    return false;\n  }\n\n  /// isKnownToHaveBooleanValue - Return true if this is an integer expression\n  /// that is known to return 0 or 1.  This happens for _Bool/bool expressions\n  /// but also int expressions which are produced by things like comparisons in\n  /// C.\n  ///\n  /// \\param Semantic If true, only return true for expressions that are known\n  /// to be semantically boolean, which might not be true even for expressions\n  /// that are known to evaluate to 0/1. For instance, reading an unsigned\n  /// bit-field with width '1' will evaluate to 0/1, but doesn't necessarily\n  /// semantically correspond to a bool.\n  bool isKnownToHaveBooleanValue(bool Semantic = true) const;\n\n  /// isIntegerConstantExpr - Return the value if this expression is a valid\n  /// integer constant expression.  If not a valid i-c-e, return None and fill\n  /// in Loc (if specified) with the location of the invalid expression.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  Optional<llvm::APSInt> getIntegerConstantExpr(const ASTContext &Ctx,\n                                                SourceLocation *Loc = nullptr,\n                                                bool isEvaluated = true) const;\n  bool isIntegerConstantExpr(const ASTContext &Ctx,\n                             SourceLocation *Loc = nullptr) const;\n\n  /// isCXX98IntegralConstantExpr - Return true if this expression is an\n  /// integral constant expression in C++98. Can only be used in C++.\n  bool isCXX98IntegralConstantExpr(const ASTContext &Ctx) const;\n\n  /// isCXX11ConstantExpr - Return true if this expression is a constant\n  /// expression in C++11. Can only be used in C++.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  bool isCXX11ConstantExpr(const ASTContext &Ctx, APValue *Result = nullptr,\n                           SourceLocation *Loc = nullptr) const;\n\n  /// isPotentialConstantExpr - Return true if this function's definition\n  /// might be usable in a constant expression in C++11, if it were marked\n  /// constexpr. Return false if the function can never produce a constant\n  /// expression, along with diagnostics describing why not.\n  static bool isPotentialConstantExpr(const FunctionDecl *FD,\n                                      SmallVectorImpl<\n                                        PartialDiagnosticAt> &Diags);\n\n  /// isPotentialConstantExprUnevaluted - Return true if this expression might\n  /// be usable in a constant expression in C++11 in an unevaluated context, if\n  /// it were in function FD marked constexpr. Return false if the function can\n  /// never produce a constant expression, along with diagnostics describing\n  /// why not.\n  static bool isPotentialConstantExprUnevaluated(Expr *E,\n                                                 const FunctionDecl *FD,\n                                                 SmallVectorImpl<\n                                                   PartialDiagnosticAt> &Diags);\n\n  /// isConstantInitializer - Returns true if this expression can be emitted to\n  /// IR as a constant, and thus can be used as a constant initializer in C.\n  /// If this expression is not constant and Culprit is non-null,\n  /// it is used to store the address of first non constant expr.\n  bool isConstantInitializer(ASTContext &Ctx, bool ForRef,\n                             const Expr **Culprit = nullptr) const;\n\n  /// EvalStatus is a struct with detailed info about an evaluation in progress.\n  struct EvalStatus {\n    /// Whether the evaluated expression has side effects.\n    /// For example, (f() && 0) can be folded, but it still has side effects.\n    bool HasSideEffects;\n\n    /// Whether the evaluation hit undefined behavior.\n    /// For example, 1.0 / 0.0 can be folded to Inf, but has undefined behavior.\n    /// Likewise, INT_MAX + 1 can be folded to INT_MIN, but has UB.\n    bool HasUndefinedBehavior;\n\n    /// Diag - If this is non-null, it will be filled in with a stack of notes\n    /// indicating why evaluation failed (or why it failed to produce a constant\n    /// expression).\n    /// If the expression is unfoldable, the notes will indicate why it's not\n    /// foldable. If the expression is foldable, but not a constant expression,\n    /// the notes will describes why it isn't a constant expression. If the\n    /// expression *is* a constant expression, no notes will be produced.\n    SmallVectorImpl<PartialDiagnosticAt> *Diag;\n\n    EvalStatus()\n        : HasSideEffects(false), HasUndefinedBehavior(false), Diag(nullptr) {}\n\n    // hasSideEffects - Return true if the evaluated expression has\n    // side effects.\n    bool hasSideEffects() const {\n      return HasSideEffects;\n    }\n  };\n\n  /// EvalResult is a struct with detailed info about an evaluated expression.\n  struct EvalResult : EvalStatus {\n    /// Val - This is the value the expression can be folded to.\n    APValue Val;\n\n    // isGlobalLValue - Return true if the evaluated lvalue expression\n    // is global.\n    bool isGlobalLValue() const;\n  };\n\n  /// EvaluateAsRValue - Return true if this is a constant which we can fold to\n  /// an rvalue using any crazy technique (that has nothing to do with language\n  /// standards) that we want to, even if the expression has side-effects. If\n  /// this function returns true, it returns the folded constant in Result. If\n  /// the expression is a glvalue, an lvalue-to-rvalue conversion will be\n  /// applied.\n  bool EvaluateAsRValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsBooleanCondition - Return true if this is a constant\n  /// which we can fold and convert to a boolean condition using\n  /// any crazy technique that we want to, even if the expression has\n  /// side-effects.\n  bool EvaluateAsBooleanCondition(bool &Result, const ASTContext &Ctx,\n                                  bool InConstantContext = false) const;\n\n  enum SideEffectsKind {\n    SE_NoSideEffects,          ///< Strictly evaluate the expression.\n    SE_AllowUndefinedBehavior, ///< Allow UB that we can give a value, but not\n                               ///< arbitrary unmodeled side effects.\n    SE_AllowSideEffects        ///< Allow any unmodeled side effect.\n  };\n\n  /// EvaluateAsInt - Return true if this is a constant which we can fold and\n  /// convert to an integer, using any crazy technique that we want to.\n  bool EvaluateAsInt(EvalResult &Result, const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                     bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a floating point value, using any crazy technique that we\n  /// want to.\n  bool EvaluateAsFloat(llvm::APFloat &Result, const ASTContext &Ctx,\n                       SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                       bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a fixed point value.\n  bool EvaluateAsFixedPoint(EvalResult &Result, const ASTContext &Ctx,\n                            SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                            bool InConstantContext = false) const;\n\n  /// isEvaluatable - Call EvaluateAsRValue to see if this expression can be\n  /// constant folded without side-effects, but discard the result.\n  bool isEvaluatable(const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects) const;\n\n  /// HasSideEffects - This routine returns true for all those expressions\n  /// which have any effect other than producing a value. Example is a function\n  /// call, volatile variable read, or throwing an exception. If\n  /// IncludePossibleEffects is false, this call treats certain expressions with\n  /// potential side effects (such as function call-like expressions,\n  /// instantiation-dependent expressions, or invocations from a macro) as not\n  /// having side effects.\n  bool HasSideEffects(const ASTContext &Ctx,\n                      bool IncludePossibleEffects = true) const;\n\n  /// Determine whether this expression involves a call to any function\n  /// that is not trivial.\n  bool hasNonTrivialCall(const ASTContext &Ctx) const;\n\n  /// EvaluateKnownConstInt - Call EvaluateAsRValue and return the folded\n  /// integer. This must be called on an expression that constant folds to an\n  /// integer.\n  llvm::APSInt EvaluateKnownConstInt(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  llvm::APSInt EvaluateKnownConstIntCheckOverflow(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  void EvaluateForOverflow(const ASTContext &Ctx) const;\n\n  /// EvaluateAsLValue - Evaluate an expression to see if we can fold it to an\n  /// lvalue with link time known address, with no side-effects.\n  bool EvaluateAsLValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsInitializer - Evaluate an expression as if it were the\n  /// initializer of the given declaration. Returns true if the initializer\n  /// can be folded to a constant, and produces any relevant notes. In C++11,\n  /// notes will be produced if the expression is not a constant expression.\n  bool EvaluateAsInitializer(APValue &Result, const ASTContext &Ctx,\n                             const VarDecl *VD,\n                             SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitializer) const;\n\n  /// EvaluateWithSubstitution - Evaluate an expression as if from the context\n  /// of a call to the given function with the given arguments, inside an\n  /// unevaluated context. Returns true if the expression could be folded to a\n  /// constant.\n  bool EvaluateWithSubstitution(APValue &Value, ASTContext &Ctx,\n                                const FunctionDecl *Callee,\n                                ArrayRef<const Expr*> Args,\n                                const Expr *This = nullptr) const;\n\n  enum class ConstantExprKind {\n    /// An integer constant expression (an array bound, enumerator, case value,\n    /// bit-field width, or similar) or similar.\n    Normal,\n    /// A non-class template argument. Such a value is only used for mangling,\n    /// not for code generation, so can refer to dllimported functions.\n    NonClassTemplateArgument,\n    /// A class template argument. Such a value is used for code generation.\n    ClassTemplateArgument,\n    /// An immediate invocation. The destruction of the end result of this\n    /// evaluation is not part of the evaluation, but all other temporaries\n    /// are destroyed.\n    ImmediateInvocation,\n  };\n\n  /// Evaluate an expression that is required to be a constant expression. Does\n  /// not check the syntactic constraints for C and C++98 constant expressions.\n  bool EvaluateAsConstantExpr(\n      EvalResult &Result, const ASTContext &Ctx,\n      ConstantExprKind Kind = ConstantExprKind::Normal) const;\n\n  /// If the current Expr is a pointer, this will try to statically\n  /// determine the number of bytes available where the pointer is pointing.\n  /// Returns true if all of the above holds and we were able to figure out the\n  /// size, false otherwise.\n  ///\n  /// \\param Type - How to evaluate the size of the Expr, as defined by the\n  /// \"type\" parameter of __builtin_object_size\n  bool tryEvaluateObjectSize(uint64_t &Result, ASTContext &Ctx,\n                             unsigned Type) const;\n\n  /// Enumeration used to describe the kind of Null pointer constant\n  /// returned from \\c isNullPointerConstant().\n  enum NullPointerConstantKind {\n    /// Expression is not a Null pointer constant.\n    NPCK_NotNull = 0,\n\n    /// Expression is a Null pointer constant built from a zero integer\n    /// expression that is not a simple, possibly parenthesized, zero literal.\n    /// C++ Core Issue 903 will classify these expressions as \"not pointers\"\n    /// once it is adopted.\n    /// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903\n    NPCK_ZeroExpression,\n\n    /// Expression is a Null pointer constant built from a literal zero.\n    NPCK_ZeroLiteral,\n\n    /// Expression is a C++11 nullptr.\n    NPCK_CXX11_nullptr,\n\n    /// Expression is a GNU-style __null constant.\n    NPCK_GNUNull\n  };\n\n  /// Enumeration used to describe how \\c isNullPointerConstant()\n  /// should cope with value-dependent expressions.\n  enum NullPointerConstantValueDependence {\n    /// Specifies that the expression should never be value-dependent.\n    NPC_NeverValueDependent = 0,\n\n    /// Specifies that a value-dependent expression of integral or\n    /// dependent type should be considered a null pointer constant.\n    NPC_ValueDependentIsNull,\n\n    /// Specifies that a value-dependent expression should be considered\n    /// to never be a null pointer constant.\n    NPC_ValueDependentIsNotNull\n  };\n\n  /// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to\n  /// a Null pointer constant. The return value can further distinguish the\n  /// kind of NULL pointer constant that was detected.\n  NullPointerConstantKind isNullPointerConstant(\n      ASTContext &Ctx,\n      NullPointerConstantValueDependence NPC) const;\n\n  /// isOBJCGCCandidate - Return true if this expression may be used in a read/\n  /// write barrier.\n  bool isOBJCGCCandidate(ASTContext &Ctx) const;\n\n  /// Returns true if this expression is a bound member function.\n  bool isBoundMemberFunction(ASTContext &Ctx) const;\n\n  /// Given an expression of bound-member type, find the type\n  /// of the member.  Returns null if this is an *overloaded* bound\n  /// member expression.\n  static QualType findBoundMemberType(const Expr *expr);\n\n  /// Skip past any invisble AST nodes which might surround this\n  /// statement, such as ExprWithCleanups or ImplicitCastExpr nodes,\n  /// but also injected CXXMemberExpr and CXXConstructExpr which represent\n  /// implicit conversions.\n  Expr *IgnoreUnlessSpelledInSource();\n  const Expr *IgnoreUnlessSpelledInSource() const {\n    return const_cast<Expr *>(this)->IgnoreUnlessSpelledInSource();\n  }\n\n  /// Skip past any implicit casts which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ImplicitCastExpr\n  /// * FullExpr\n  Expr *IgnoreImpCasts() LLVM_READONLY;\n  const Expr *IgnoreImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreImpCasts();\n  }\n\n  /// Skip past any casts which might surround this expression until reaching\n  /// a fixed point. Skips:\n  /// * CastExpr\n  /// * FullExpr\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreCasts() LLVM_READONLY;\n  const Expr *IgnoreCasts() const {\n    return const_cast<Expr *>(this)->IgnoreCasts();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * CXXBindTemporaryExpr\n  Expr *IgnoreImplicit() LLVM_READONLY;\n  const Expr *IgnoreImplicit() const {\n    return const_cast<Expr *>(this)->IgnoreImplicit();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Same as IgnoreImplicit, except that it\n  /// also skips over implicit calls to constructors and conversion functions.\n  ///\n  /// FIXME: Should IgnoreImplicit do this?\n  Expr *IgnoreImplicitAsWritten() LLVM_READONLY;\n  const Expr *IgnoreImplicitAsWritten() const {\n    return const_cast<Expr *>(this)->IgnoreImplicitAsWritten();\n  }\n\n  /// Skip past any parentheses which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ParenExpr\n  /// * UnaryOperator if `UO_Extension`\n  /// * GenericSelectionExpr if `!isResultDependent()`\n  /// * ChooseExpr if `!isConditionDependent()`\n  /// * ConstantExpr\n  Expr *IgnoreParens() LLVM_READONLY;\n  const Expr *IgnoreParens() const {\n    return const_cast<Expr *>(this)->IgnoreParens();\n  }\n\n  /// Skip past any parentheses and implicit casts which might surround this\n  /// expression until reaching a fixed point.\n  /// FIXME: IgnoreParenImpCasts really ought to be equivalent to\n  /// IgnoreParens() + IgnoreImpCasts() until reaching a fixed point. However\n  /// this is currently not the case. Instead IgnoreParenImpCasts() skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenImpCasts() LLVM_READONLY;\n  const Expr *IgnoreParenImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenImpCasts();\n  }\n\n  /// Skip past any parentheses and casts which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips\n  Expr *IgnoreParenCasts() LLVM_READONLY;\n  const Expr *IgnoreParenCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenCasts();\n  }\n\n  /// Skip conversion operators. If this Expr is a call to a conversion\n  /// operator, return the argument.\n  Expr *IgnoreConversionOperatorSingleStep() LLVM_READONLY;\n  const Expr *IgnoreConversionOperatorSingleStep() const {\n    return const_cast<Expr *>(this)->IgnoreConversionOperatorSingleStep();\n  }\n\n  /// Skip past any parentheses and lvalue casts which might surround this\n  /// expression until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips, except that only lvalue-to-rvalue\n  ///   casts are skipped\n  /// FIXME: This is intended purely as a temporary workaround for code\n  /// that hasn't yet been rewritten to do the right thing about those\n  /// casts, and may disappear along with the last internal use.\n  Expr *IgnoreParenLValueCasts() LLVM_READONLY;\n  const Expr *IgnoreParenLValueCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenLValueCasts();\n  }\n\n  /// Skip past any parenthese and casts which do not change the value\n  /// (including ptr->int casts of the same size) until reaching a fixed point.\n  /// Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which do not change the value\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) LLVM_READONLY;\n  const Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) const {\n    return const_cast<Expr *>(this)->IgnoreParenNoopCasts(Ctx);\n  }\n\n  /// Skip past any parentheses and derived-to-base casts until reaching a\n  /// fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which represent a derived-to-base cast (CK_DerivedToBase,\n  ///   CK_UncheckedDerivedToBase and CK_NoOp)\n  Expr *IgnoreParenBaseCasts() LLVM_READONLY;\n  const Expr *IgnoreParenBaseCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenBaseCasts();\n  }\n\n  /// Determine whether this expression is a default function argument.\n  ///\n  /// Default arguments are implicitly generated in the abstract syntax tree\n  /// by semantic analysis for function calls, object constructions, etc. in\n  /// C++. Default arguments are represented by \\c CXXDefaultArgExpr nodes;\n  /// this routine also looks through any implicit casts to determine whether\n  /// the expression is a default argument.\n  bool isDefaultArgument() const;\n\n  /// Determine whether the result of this expression is a\n  /// temporary object of the given class type.\n  bool isTemporaryObject(ASTContext &Ctx, const CXXRecordDecl *TempTy) const;\n\n  /// Whether this expression is an implicit reference to 'this' in C++.\n  bool isImplicitCXXThis() const;\n\n  static bool hasAnyTypeDependentArguments(ArrayRef<Expr *> Exprs);\n\n  /// For an expression of class type or pointer to class type,\n  /// return the most derived class decl the expression is known to refer to.\n  ///\n  /// If this expression is a cast, this method looks through it to find the\n  /// most derived decl that can be inferred from the expression.\n  /// This is valid because derived-to-base conversions have undefined\n  /// behavior if the object isn't dynamically of the derived type.\n  const CXXRecordDecl *getBestDynamicClassType() const;\n\n  /// Get the inner expression that determines the best dynamic class.\n  /// If this is a prvalue, we guarantee that it is of the most-derived type\n  /// for the object itself.\n  const Expr *getBestDynamicClassTypeExpr() const;\n\n  /// Walk outwards from an expression we want to bind a reference to and\n  /// find the expression whose lifetime needs to be extended. Record\n  /// the LHSs of comma expressions and adjustments needed along the path.\n  const Expr *skipRValueSubobjectAdjustments(\n      SmallVectorImpl<const Expr *> &CommaLHS,\n      SmallVectorImpl<SubobjectAdjustment> &Adjustments) const;\n  const Expr *skipRValueSubobjectAdjustments() const {\n    SmallVector<const Expr *, 8> CommaLHSs;\n    SmallVector<SubobjectAdjustment, 8> Adjustments;\n    return skipRValueSubobjectAdjustments(CommaLHSs, Adjustments);\n  }\n\n  /// Checks that the two Expr's will refer to the same value as a comparison\n  /// operand.  The caller must ensure that the values referenced by the Expr's\n  /// are not modified between E1 and E2 or the result my be invalid.\n  static bool isSameComparisonOperand(const Expr* E1, const Expr* E2);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstExprConstant &&\n           T->getStmtClass() <= lastExprConstant;\n  }\n};\n// PointerLikeTypeTraits is specialized so it can be used with a forward-decl of\n// Expr. Verify that we got it right.\nstatic_assert(llvm::PointerLikeTypeTraits<Expr *>::NumLowBitsAvailable <=\n                  llvm::detail::ConstantLog2<alignof(Expr)>::value,\n              \"PointerLikeTypeTraits<Expr*> assumes too much alignment.\");\n\nusing ConstantExprKind = Expr::ConstantExprKind;\n\n//===----------------------------------------------------------------------===//\n// Wrapper Expressions.\n//===----------------------------------------------------------------------===//\n\n/// FullExpr - Represents a \"full-expression\" node.\nclass FullExpr : public Expr {\nprotected:\n Stmt *SubExpr;\n\n FullExpr(StmtClass SC, Expr *subexpr)\n     : Expr(SC, subexpr->getType(), subexpr->getValueKind(),\n            subexpr->getObjectKind()),\n       SubExpr(subexpr) {\n   setDependence(computeDependence(this));\n }\n  FullExpr(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) {}\npublic:\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n\n  /// As with any mutator of the AST, be very careful when modifying an\n  /// existing AST to preserve its invariants.\n  void setSubExpr(Expr *E) { SubExpr = E; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstFullExprConstant &&\n           T->getStmtClass() <= lastFullExprConstant;\n  }\n};\n\n/// ConstantExpr - An expression that occurs in a constant context and\n/// optionally the result of evaluating the expression.\nclass ConstantExpr final\n    : public FullExpr,\n      private llvm::TrailingObjects<ConstantExpr, APValue, uint64_t> {\n  static_assert(std::is_same<uint64_t, llvm::APInt::WordType>::value,\n                \"ConstantExpr assumes that llvm::APInt::WordType is uint64_t \"\n                \"for tail-allocated storage\");\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\npublic:\n  /// Describes the kind of result that can be tail-allocated.\n  enum ResultStorageKind { RSK_None, RSK_Int64, RSK_APValue };\n\nprivate:\n  size_t numTrailingObjects(OverloadToken<APValue>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue;\n  }\n  size_t numTrailingObjects(OverloadToken<uint64_t>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64;\n  }\n\n  uint64_t &Int64Result() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64 &&\n           \"invalid accessor\");\n    return *getTrailingObjects<uint64_t>();\n  }\n  const uint64_t &Int64Result() const {\n    return const_cast<ConstantExpr *>(this)->Int64Result();\n  }\n  APValue &APValueResult() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue &&\n           \"invalid accessor\");\n    return *getTrailingObjects<APValue>();\n  }\n  APValue &APValueResult() const {\n    return const_cast<ConstantExpr *>(this)->APValueResult();\n  }\n\n  ConstantExpr(Expr *SubExpr, ResultStorageKind StorageKind,\n               bool IsImmediateInvocation);\n  ConstantExpr(EmptyShell Empty, ResultStorageKind StorageKind);\n\npublic:\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              const APValue &Result);\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              ResultStorageKind Storage = RSK_None,\n                              bool IsImmediateInvocation = false);\n  static ConstantExpr *CreateEmpty(const ASTContext &Context,\n                                   ResultStorageKind StorageKind);\n\n  static ResultStorageKind getStorageKind(const APValue &Value);\n  static ResultStorageKind getStorageKind(const Type *T,\n                                          const ASTContext &Context);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConstantExprClass;\n  }\n\n  void SetResult(APValue Value, const ASTContext &Context) {\n    MoveIntoResult(Value, Context);\n  }\n  void MoveIntoResult(APValue &Value, const ASTContext &Context);\n\n  APValue::ValueKind getResultAPValueKind() const {\n    return static_cast<APValue::ValueKind>(ConstantExprBits.APValueKind);\n  }\n  ResultStorageKind getResultStorageKind() const {\n    return static_cast<ResultStorageKind>(ConstantExprBits.ResultKind);\n  }\n  bool isImmediateInvocation() const {\n    return ConstantExprBits.IsImmediateInvocation;\n  }\n  bool hasAPValueResult() const {\n    return ConstantExprBits.APValueKind != APValue::None;\n  }\n  APValue getAPValueResult() const;\n  APValue &getResultAsAPValue() const { return APValueResult(); }\n  llvm::APSInt getResultAsAPSInt() const;\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Primary Expressions.\n//===----------------------------------------------------------------------===//\n\n/// OpaqueValueExpr - An expression referring to an opaque object of a\n/// fixed type and value class.  These don't correspond to concrete\n/// syntax; instead they're used to express operations (usually copy\n/// operations) on values whose source is generally obvious from\n/// context.\nclass OpaqueValueExpr : public Expr {\n  friend class ASTStmtReader;\n  Expr *SourceExpr;\n\npublic:\n  OpaqueValueExpr(SourceLocation Loc, QualType T, ExprValueKind VK,\n                  ExprObjectKind OK = OK_Ordinary, Expr *SourceExpr = nullptr)\n      : Expr(OpaqueValueExprClass, T, VK, OK), SourceExpr(SourceExpr) {\n    setIsUnique(false);\n    OpaqueValueExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Given an expression which invokes a copy constructor --- i.e.  a\n  /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups ---\n  /// find the OpaqueValueExpr that's the source of the construction.\n  static const OpaqueValueExpr *findInCopyConstruct(const Expr *expr);\n\n  explicit OpaqueValueExpr(EmptyShell Empty)\n    : Expr(OpaqueValueExprClass, Empty) {}\n\n  /// Retrieve the location of this expression.\n  SourceLocation getLocation() const { return OpaqueValueExprBits.Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getBeginLoc() : getLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getEndLoc() : getLocation();\n  }\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getExprLoc() : getLocation();\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  /// The source expression of an opaque value expression is the\n  /// expression which originally generated the value.  This is\n  /// provided as a convenience for analyses that don't wish to\n  /// precisely model the execution behavior of the program.\n  ///\n  /// The source expression is typically set when building the\n  /// expression which binds the opaque value expression in the first\n  /// place.\n  Expr *getSourceExpr() const { return SourceExpr; }\n\n  void setIsUnique(bool V) {\n    assert((!V || SourceExpr) &&\n           \"unique OVEs are expected to have source expressions\");\n    OpaqueValueExprBits.IsUnique = V;\n  }\n\n  bool isUnique() const { return OpaqueValueExprBits.IsUnique; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OpaqueValueExprClass;\n  }\n};\n\n/// A reference to a declared variable, function, enum, etc.\n/// [C99 6.5.1p2]\n///\n/// This encodes all the information about how a declaration is referenced\n/// within an expression.\n///\n/// There are several optional constructs attached to DeclRefExprs only when\n/// they apply in order to conserve memory. These are laid out past the end of\n/// the object, and flags in the DeclRefExprBitfield track whether they exist:\n///\n///   DeclRefExprBits.HasQualifier:\n///       Specifies when this declaration reference expression has a C++\n///       nested-name-specifier.\n///   DeclRefExprBits.HasFoundDecl:\n///       Specifies when this declaration reference expression has a record of\n///       a NamedDecl (different from the referenced ValueDecl) which was found\n///       during name lookup and/or overload resolution.\n///   DeclRefExprBits.HasTemplateKWAndArgsInfo:\n///       Specifies when this declaration reference expression has an explicit\n///       C++ template keyword and/or template argument list.\n///   DeclRefExprBits.RefersToEnclosingVariableOrCapture\n///       Specifies when this declaration reference expression (validly)\n///       refers to an enclosed local or a captured variable.\nclass DeclRefExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DeclRefExpr, NestedNameSpecifierLoc,\n                                    NamedDecl *, ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The declaration that we are referencing.\n  ValueDecl *D;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in D.\n  DeclarationNameLoc DNLoc;\n\n  size_t numTrailingObjects(OverloadToken<NestedNameSpecifierLoc>) const {\n    return hasQualifier();\n  }\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  /// Test whether there is a distinct FoundDecl attached to the end of\n  /// this DRE.\n  bool hasFoundDecl() const { return DeclRefExprBits.HasFoundDecl; }\n\n  DeclRefExpr(const ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n              SourceLocation TemplateKWLoc, ValueDecl *D,\n              bool RefersToEnlosingVariableOrCapture,\n              const DeclarationNameInfo &NameInfo, NamedDecl *FoundD,\n              const TemplateArgumentListInfo *TemplateArgs, QualType T,\n              ExprValueKind VK, NonOdrUseReason NOUR);\n\n  /// Construct an empty declaration reference expression.\n  explicit DeclRefExpr(EmptyShell Empty) : Expr(DeclRefExprClass, Empty) {}\n\npublic:\n  DeclRefExpr(const ASTContext &Ctx, ValueDecl *D,\n              bool RefersToEnclosingVariableOrCapture, QualType T,\n              ExprValueKind VK, SourceLocation L,\n              const DeclarationNameLoc &LocInfo = DeclarationNameLoc(),\n              NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture, SourceLocation NameLoc,\n         QualType T, ExprValueKind VK, NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture,\n         const DeclarationNameInfo &NameInfo, QualType T, ExprValueKind VK,\n         NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  /// Construct an empty declaration reference expression.\n  static DeclRefExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                  bool HasFoundDecl,\n                                  bool HasTemplateKWAndArgsInfo,\n                                  unsigned NumTemplateArgs);\n\n  ValueDecl *getDecl() { return D; }\n  const ValueDecl *getDecl() const { return D; }\n  void setDecl(ValueDecl *NewD);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDecl()->getDeclName(), getLocation(), DNLoc);\n  }\n\n  SourceLocation getLocation() const { return DeclRefExprBits.Loc; }\n  void setLocation(SourceLocation L) { DeclRefExprBits.Loc = L; }\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Determine whether this declaration reference was preceded by a\n  /// C++ nested-name-specifier, e.g., \\c N::foo.\n  bool hasQualifier() const { return DeclRefExprBits.HasQualifier; }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifier())\n      return NestedNameSpecifierLoc();\n    return *getTrailingObjects<NestedNameSpecifierLoc>();\n  }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name. Otherwise, returns NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  ///\n  /// This Decl may be different from the ValueDecl actually referred to in the\n  /// presence of using declarations, etc. It always returns non-NULL, and may\n  /// simple return the ValueDecl when appropriate.\n\n  NamedDecl *getFoundDecl() {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  /// See non-const variant.\n  const NamedDecl *getFoundDecl() const {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return DeclRefExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the name in this declaration reference\n  /// was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this declaration reference was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Returns true if this expression refers to a function that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return DeclRefExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a function that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    DeclRefExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(DeclRefExprBits.NonOdrUseReason);\n  }\n\n  /// Does this DeclRefExpr refer to an enclosing local or a captured\n  /// variable?\n  bool refersToEnclosingVariableOrCapture() const {\n    return DeclRefExprBits.RefersToEnclosingVariableOrCapture;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclRefExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Used by IntegerLiteral/FloatingLiteral to store the numeric without\n/// leaking memory.\n///\n/// For large floats/integers, APFloat/APInt will allocate memory from the heap\n/// to represent these numbers.  Unfortunately, when we use a BumpPtrAllocator\n/// to allocate IntegerLiteral/FloatingLiteral nodes the memory associated with\n/// the APFloat/APInt values will never get freed. APNumericStorage uses\n/// ASTContext's allocator for memory allocation.\nclass APNumericStorage {\n  union {\n    uint64_t VAL;    ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal;  ///< Used to store the >64 bits integer value.\n  };\n  unsigned BitWidth;\n\n  bool hasAllocation() const { return llvm::APInt::getNumWords(BitWidth) > 1; }\n\n  APNumericStorage(const APNumericStorage &) = delete;\n  void operator=(const APNumericStorage &) = delete;\n\nprotected:\n  APNumericStorage() : VAL(0), BitWidth(0) { }\n\n  llvm::APInt getIntValue() const {\n    unsigned NumWords = llvm::APInt::getNumWords(BitWidth);\n    if (NumWords > 1)\n      return llvm::APInt(BitWidth, NumWords, pVal);\n    else\n      return llvm::APInt(BitWidth, VAL);\n  }\n  void setIntValue(const ASTContext &C, const llvm::APInt &Val);\n};\n\nclass APIntStorage : private APNumericStorage {\npublic:\n  llvm::APInt getValue() const { return getIntValue(); }\n  void setValue(const ASTContext &C, const llvm::APInt &Val) {\n    setIntValue(C, Val);\n  }\n};\n\nclass APFloatStorage : private APNumericStorage {\npublic:\n  llvm::APFloat getValue(const llvm::fltSemantics &Semantics) const {\n    return llvm::APFloat(Semantics, getIntValue());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    setIntValue(C, Val.bitcastToAPInt());\n  }\n};\n\nclass IntegerLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n\n  /// Construct an empty integer literal.\n  explicit IntegerLiteral(EmptyShell Empty)\n    : Expr(IntegerLiteralClass, Empty) { }\n\npublic:\n  // type should be IntTy, LongTy, LongLongTy, UnsignedIntTy, UnsignedLongTy,\n  // or UnsignedLongLongTy\n  IntegerLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                 SourceLocation l);\n\n  /// Returns a new integer literal with value 'V' and type 'type'.\n  /// \\param type - either IntTy, LongTy, LongLongTy, UnsignedIntTy,\n  /// UnsignedLongTy, or UnsignedLongLongTy which should match the size of V\n  /// \\param V - the value that the returned integer literal contains.\n  static IntegerLiteral *Create(const ASTContext &C, const llvm::APInt &V,\n                                QualType type, SourceLocation l);\n  /// Returns a new empty integer literal.\n  static IntegerLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IntegerLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FixedPointLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n  unsigned Scale;\n\n  /// \\brief Construct an empty fixed-point literal.\n  explicit FixedPointLiteral(EmptyShell Empty)\n      : Expr(FixedPointLiteralClass, Empty) {}\n\n public:\n  FixedPointLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                    SourceLocation l, unsigned Scale);\n\n  // Store the int as is without any bit shifting.\n  static FixedPointLiteral *CreateFromRawInt(const ASTContext &C,\n                                             const llvm::APInt &V,\n                                             QualType type, SourceLocation l,\n                                             unsigned Scale);\n\n  /// Returns an empty fixed-point literal.\n  static FixedPointLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// \\brief Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  unsigned getScale() const { return Scale; }\n  void setScale(unsigned S) { Scale = S; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FixedPointLiteralClass;\n  }\n\n  std::string getValueAsString(unsigned Radix) const;\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass CharacterLiteral : public Expr {\npublic:\n  enum CharacterKind {\n    Ascii,\n    Wide,\n    UTF8,\n    UTF16,\n    UTF32\n  };\n\nprivate:\n  unsigned Value;\n  SourceLocation Loc;\npublic:\n  // type should be IntTy\n  CharacterLiteral(unsigned value, CharacterKind kind, QualType type,\n                   SourceLocation l)\n      : Expr(CharacterLiteralClass, type, VK_RValue, OK_Ordinary), Value(value),\n        Loc(l) {\n    CharacterLiteralBits.Kind = kind;\n    setDependence(ExprDependence::None);\n  }\n\n  /// Construct an empty character literal.\n  CharacterLiteral(EmptyShell Empty) : Expr(CharacterLiteralClass, Empty) { }\n\n  SourceLocation getLocation() const { return Loc; }\n  CharacterKind getKind() const {\n    return static_cast<CharacterKind>(CharacterLiteralBits.Kind);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  unsigned getValue() const { return Value; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n  void setKind(CharacterKind kind) { CharacterLiteralBits.Kind = kind; }\n  void setValue(unsigned Val) { Value = Val; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CharacterLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FloatingLiteral : public Expr, private APFloatStorage {\n  SourceLocation Loc;\n\n  FloatingLiteral(const ASTContext &C, const llvm::APFloat &V, bool isexact,\n                  QualType Type, SourceLocation L);\n\n  /// Construct an empty floating-point literal.\n  explicit FloatingLiteral(const ASTContext &C, EmptyShell Empty);\n\npublic:\n  static FloatingLiteral *Create(const ASTContext &C, const llvm::APFloat &V,\n                                 bool isexact, QualType Type, SourceLocation L);\n  static FloatingLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  llvm::APFloat getValue() const {\n    return APFloatStorage::getValue(getSemantics());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    assert(&getSemantics() == &Val.getSemantics() && \"Inconsistent semantics\");\n    APFloatStorage::setValue(C, Val);\n  }\n\n  /// Get a raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  llvm::APFloatBase::Semantics getRawSemantics() const {\n    return static_cast<llvm::APFloatBase::Semantics>(\n        FloatingLiteralBits.Semantics);\n  }\n\n  /// Set the raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  void setRawSemantics(llvm::APFloatBase::Semantics Sem) {\n    FloatingLiteralBits.Semantics = Sem;\n  }\n\n  /// Return the APFloat semantics this literal uses.\n  const llvm::fltSemantics &getSemantics() const {\n    return llvm::APFloatBase::EnumToSemantics(\n        static_cast<llvm::APFloatBase::Semantics>(\n            FloatingLiteralBits.Semantics));\n  }\n\n  /// Set the APFloat semantics this literal uses.\n  void setSemantics(const llvm::fltSemantics &Sem) {\n    FloatingLiteralBits.Semantics = llvm::APFloatBase::SemanticsToEnum(Sem);\n  }\n\n  bool isExact() const { return FloatingLiteralBits.IsExact; }\n  void setExact(bool E) { FloatingLiteralBits.IsExact = E; }\n\n  /// getValueAsApproximateDouble - This returns the value as an inaccurate\n  /// double.  Note that this may cause loss of precision, but is useful for\n  /// debugging dumps, etc.\n  double getValueAsApproximateDouble() const;\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FloatingLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// ImaginaryLiteral - We support imaginary integer and floating point literals,\n/// like \"1.0i\".  We represent these as a wrapper around FloatingLiteral and\n/// IntegerLiteral classes.  Instances of this class always have a Complex type\n/// whose element type matches the subexpression.\n///\nclass ImaginaryLiteral : public Expr {\n  Stmt *Val;\npublic:\n  ImaginaryLiteral(Expr *val, QualType Ty)\n      : Expr(ImaginaryLiteralClass, Ty, VK_RValue, OK_Ordinary), Val(val) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty imaginary literal.\n  explicit ImaginaryLiteral(EmptyShell Empty)\n    : Expr(ImaginaryLiteralClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Val->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Val->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImaginaryLiteralClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// StringLiteral - This represents a string literal expression, e.g. \"foo\"\n/// or L\"bar\" (wide strings). The actual string data can be obtained with\n/// getBytes() and is NOT null-terminated. The length of the string data is\n/// determined by calling getByteLength().\n///\n/// The C type for a string is always a ConstantArrayType. In C++, the char\n/// type is const qualified, in C it is not.\n///\n/// Note that strings in C can be formed by concatenation of multiple string\n/// literal pptokens in translation phase #6. This keeps track of the locations\n/// of each of these pieces.\n///\n/// Strings in C can also be truncated and extended by assigning into arrays,\n/// e.g. with constructs like:\n///   char X[2] = \"foobar\";\n/// In this case, getByteLength() will return 6, but the string literal will\n/// have type \"char[2]\".\nclass StringLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<StringLiteral, unsigned, SourceLocation,\n                                    char> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// StringLiteral is followed by several trailing objects. They are in order:\n  ///\n  /// * A single unsigned storing the length in characters of this string. The\n  ///   length in bytes is this length times the width of a single character.\n  ///   Always present and stored as a trailing objects because storing it in\n  ///   StringLiteral would increase the size of StringLiteral by sizeof(void *)\n  ///   due to alignment requirements. If you add some data to StringLiteral,\n  ///   consider moving it inside StringLiteral.\n  ///\n  /// * An array of getNumConcatenated() SourceLocation, one for each of the\n  ///   token this string is made of.\n  ///\n  /// * An array of getByteLength() char used to store the string data.\n\npublic:\n  enum StringKind { Ascii, Wide, UTF8, UTF16, UTF32 };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<unsigned>) const { return 1; }\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return getNumConcatenated();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<char>) const {\n    return getByteLength();\n  }\n\n  char *getStrDataAsChar() { return getTrailingObjects<char>(); }\n  const char *getStrDataAsChar() const { return getTrailingObjects<char>(); }\n\n  const uint16_t *getStrDataAsUInt16() const {\n    return reinterpret_cast<const uint16_t *>(getTrailingObjects<char>());\n  }\n\n  const uint32_t *getStrDataAsUInt32() const {\n    return reinterpret_cast<const uint32_t *>(getTrailingObjects<char>());\n  }\n\n  /// Build a string literal.\n  StringLiteral(const ASTContext &Ctx, StringRef Str, StringKind Kind,\n                bool Pascal, QualType Ty, const SourceLocation *Loc,\n                unsigned NumConcatenated);\n\n  /// Build an empty string literal.\n  StringLiteral(EmptyShell Empty, unsigned NumConcatenated, unsigned Length,\n                unsigned CharByteWidth);\n\n  /// Map a target and string kind to the appropriate character width.\n  static unsigned mapCharByteWidth(TargetInfo const &Target, StringKind SK);\n\n  /// Set one of the string literal token.\n  void setStrTokenLoc(unsigned TokNum, SourceLocation L) {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    getTrailingObjects<SourceLocation>()[TokNum] = L;\n  }\n\npublic:\n  /// This is the \"fully general\" constructor that allows representation of\n  /// strings formed from multiple concatenated tokens.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               const SourceLocation *Loc,\n                               unsigned NumConcatenated);\n\n  /// Simple constructor for string literals made from one token.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               SourceLocation Loc) {\n    return Create(Ctx, Str, Kind, Pascal, Ty, &Loc, 1);\n  }\n\n  /// Construct an empty string literal.\n  static StringLiteral *CreateEmpty(const ASTContext &Ctx,\n                                    unsigned NumConcatenated, unsigned Length,\n                                    unsigned CharByteWidth);\n\n  StringRef getString() const {\n    assert(getCharByteWidth() == 1 &&\n           \"This function is used in places that assume strings use char\");\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  /// Allow access to clients that need the byte representation, such as\n  /// ASTWriterStmt::VisitStringLiteral().\n  StringRef getBytes() const {\n    // FIXME: StringRef may not be the right type to use as a result for this.\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  void outputString(raw_ostream &OS) const;\n\n  uint32_t getCodeUnit(size_t i) const {\n    assert(i < getLength() && \"out of bounds access\");\n    switch (getCharByteWidth()) {\n    case 1:\n      return static_cast<unsigned char>(getStrDataAsChar()[i]);\n    case 2:\n      return getStrDataAsUInt16()[i];\n    case 4:\n      return getStrDataAsUInt32()[i];\n    }\n    llvm_unreachable(\"Unsupported character width!\");\n  }\n\n  unsigned getByteLength() const { return getCharByteWidth() * getLength(); }\n  unsigned getLength() const { return *getTrailingObjects<unsigned>(); }\n  unsigned getCharByteWidth() const { return StringLiteralBits.CharByteWidth; }\n\n  StringKind getKind() const {\n    return static_cast<StringKind>(StringLiteralBits.Kind);\n  }\n\n  bool isAscii() const { return getKind() == Ascii; }\n  bool isWide() const { return getKind() == Wide; }\n  bool isUTF8() const { return getKind() == UTF8; }\n  bool isUTF16() const { return getKind() == UTF16; }\n  bool isUTF32() const { return getKind() == UTF32; }\n  bool isPascal() const { return StringLiteralBits.IsPascal; }\n\n  bool containsNonAscii() const {\n    for (auto c : getString())\n      if (!isASCII(c))\n        return true;\n    return false;\n  }\n\n  bool containsNonAsciiOrNull() const {\n    for (auto c : getString())\n      if (!isASCII(c) || !c)\n        return true;\n    return false;\n  }\n\n  /// getNumConcatenated - Get the number of string literal tokens that were\n  /// concatenated in translation phase #6 to form this string literal.\n  unsigned getNumConcatenated() const {\n    return StringLiteralBits.NumConcatenated;\n  }\n\n  /// Get one of the string literal token.\n  SourceLocation getStrTokenLoc(unsigned TokNum) const {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    return getTrailingObjects<SourceLocation>()[TokNum];\n  }\n\n  /// getLocationOfByte - Return a source location that points to the specified\n  /// byte of this string literal.\n  ///\n  /// Strings are amazingly complex.  They can be formed from multiple tokens\n  /// and can have escape sequences in them in addition to the usual trigraph\n  /// and escaped newline business.  This routine handles this complexity.\n  ///\n  SourceLocation\n  getLocationOfByte(unsigned ByteNo, const SourceManager &SM,\n                    const LangOptions &Features, const TargetInfo &Target,\n                    unsigned *StartToken = nullptr,\n                    unsigned *StartTokenByteOffset = nullptr) const;\n\n  typedef const SourceLocation *tokloc_iterator;\n\n  tokloc_iterator tokloc_begin() const {\n    return getTrailingObjects<SourceLocation>();\n  }\n\n  tokloc_iterator tokloc_end() const {\n    return getTrailingObjects<SourceLocation>() + getNumConcatenated();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return *tokloc_begin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return *(tokloc_end() - 1); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StringLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// [C99 6.4.2.2] - A predefined identifier such as __func__.\nclass PredefinedExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PredefinedExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  // PredefinedExpr is optionally followed by a single trailing\n  // \"Stmt *\" for the predefined identifier. It is present if and only if\n  // hasFunctionName() is true and is always a \"StringLiteral *\".\n\npublic:\n  enum IdentKind {\n    Func,\n    Function,\n    LFunction, // Same as Function, but as wide string.\n    FuncDName,\n    FuncSig,\n    LFuncSig, // Same as FuncSig, but as as wide string\n    PrettyFunction,\n    /// The same as PrettyFunction, except that the\n    /// 'virtual' keyword is omitted for virtual member functions.\n    PrettyFunctionNoVirtual\n  };\n\nprivate:\n  PredefinedExpr(SourceLocation L, QualType FNTy, IdentKind IK,\n                 StringLiteral *SL);\n\n  explicit PredefinedExpr(EmptyShell Empty, bool HasFunctionName);\n\n  /// True if this PredefinedExpr has storage for a function name.\n  bool hasFunctionName() const { return PredefinedExprBits.HasFunctionName; }\n\n  void setFunctionName(StringLiteral *SL) {\n    assert(hasFunctionName() &&\n           \"This PredefinedExpr has no storage for a function name!\");\n    *getTrailingObjects<Stmt *>() = SL;\n  }\n\npublic:\n  /// Create a PredefinedExpr.\n  static PredefinedExpr *Create(const ASTContext &Ctx, SourceLocation L,\n                                QualType FNTy, IdentKind IK, StringLiteral *SL);\n\n  /// Create an empty PredefinedExpr.\n  static PredefinedExpr *CreateEmpty(const ASTContext &Ctx,\n                                     bool HasFunctionName);\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(PredefinedExprBits.Kind);\n  }\n\n  SourceLocation getLocation() const { return PredefinedExprBits.Loc; }\n  void setLocation(SourceLocation L) { PredefinedExprBits.Loc = L; }\n\n  StringLiteral *getFunctionName() {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  const StringLiteral *getFunctionName() const {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  static StringRef getIdentKindName(IdentKind IK);\n  StringRef getIdentKindName() const {\n    return getIdentKindName(getIdentKind());\n  }\n\n  static std::string ComputeName(IdentKind IK, const Decl *CurrentDecl);\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PredefinedExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n};\n\n/// ParenExpr - This represents a parethesized expression, e.g. \"(1)\".  This\n/// AST node is only formed if full location information is requested.\nclass ParenExpr : public Expr {\n  SourceLocation L, R;\n  Stmt *Val;\npublic:\n  ParenExpr(SourceLocation l, SourceLocation r, Expr *val)\n      : Expr(ParenExprClass, val->getType(), val->getValueKind(),\n             val->getObjectKind()),\n        L(l), R(r), Val(val) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty parenthesized expression.\n  explicit ParenExpr(EmptyShell Empty)\n    : Expr(ParenExprClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return L; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return R; }\n\n  /// Get the location of the left parentheses '('.\n  SourceLocation getLParen() const { return L; }\n  void setLParen(SourceLocation Loc) { L = Loc; }\n\n  /// Get the location of the right parentheses ')'.\n  SourceLocation getRParen() const { return R; }\n  void setRParen(SourceLocation Loc) { R = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// UnaryOperator - This represents the unary-expression's (except sizeof and\n/// alignof), the postinc/postdec operators from postfix-expression, and various\n/// extensions.\n///\n/// Notes on various nodes:\n///\n/// Real/Imag - These return the real/imag part of a complex operand.  If\n///   applied to a non-complex value, the former returns its operand and the\n///   later returns zero in the type of the operand.\n///\nclass UnaryOperator final\n    : public Expr,\n      private llvm::TrailingObjects<UnaryOperator, FPOptionsOverride> {\n  Stmt *Val;\n\n  size_t numTrailingObjects(OverloadToken<FPOptionsOverride>) const {\n    return UnaryOperatorBits.HasFPFeatures ? 1 : 0;\n  }\n\n  FPOptionsOverride &getTrailingFPFeatures() {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\n  const FPOptionsOverride &getTrailingFPFeatures() const {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\npublic:\n  typedef UnaryOperatorKind Opcode;\n\nprotected:\n  UnaryOperator(const ASTContext &Ctx, Expr *input, Opcode opc, QualType type,\n                ExprValueKind VK, ExprObjectKind OK, SourceLocation l,\n                bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  /// Build an empty unary operator.\n  explicit UnaryOperator(bool HasFPFeatures, EmptyShell Empty)\n      : Expr(UnaryOperatorClass, Empty) {\n    UnaryOperatorBits.Opc = UO_AddrOf;\n    UnaryOperatorBits.HasFPFeatures = HasFPFeatures;\n  }\n\npublic:\n  static UnaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static UnaryOperator *Create(const ASTContext &C, Expr *input, Opcode opc,\n                               QualType type, ExprValueKind VK,\n                               ExprObjectKind OK, SourceLocation l,\n                               bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(UnaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { UnaryOperatorBits.Opc = Opc; }\n\n  Expr *getSubExpr() const { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return UnaryOperatorBits.Loc; }\n  void setOperatorLoc(SourceLocation L) { UnaryOperatorBits.Loc = L; }\n\n  /// Returns true if the unary operator can cause an overflow. For instance,\n  ///   signed int i = INT_MAX; i++;\n  ///   signed char c = CHAR_MAX; c++;\n  /// Due to integer promotions, c++ is promoted to an int before the postfix\n  /// increment, and the result is an int that cannot overflow. However, i++\n  /// can overflow.\n  bool canOverflow() const { return UnaryOperatorBits.CanOverflow; }\n  void setCanOverflow(bool C) { UnaryOperatorBits.CanOverflow = C; }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\n  /// isPostfix - Return true if this is a postfix operation, like x++.\n  static bool isPostfix(Opcode Op) {\n    return Op == UO_PostInc || Op == UO_PostDec;\n  }\n\n  /// isPrefix - Return true if this is a prefix operation, like --x.\n  static bool isPrefix(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PreDec;\n  }\n\n  bool isPrefix() const { return isPrefix(getOpcode()); }\n  bool isPostfix() const { return isPostfix(getOpcode()); }\n\n  static bool isIncrementOp(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PostInc;\n  }\n  bool isIncrementOp() const {\n    return isIncrementOp(getOpcode());\n  }\n\n  static bool isDecrementOp(Opcode Op) {\n    return Op == UO_PreDec || Op == UO_PostDec;\n  }\n  bool isDecrementOp() const {\n    return isDecrementOp(getOpcode());\n  }\n\n  static bool isIncrementDecrementOp(Opcode Op) { return Op <= UO_PreDec; }\n  bool isIncrementDecrementOp() const {\n    return isIncrementDecrementOp(getOpcode());\n  }\n\n  static bool isArithmeticOp(Opcode Op) {\n    return Op >= UO_Plus && Op <= UO_LNot;\n  }\n  bool isArithmeticOp() const { return isArithmeticOp(getOpcode()); }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"sizeof\" or \"[pre]++\"\n  static StringRef getOpcodeStr(Opcode Op);\n\n  /// Retrieve the unary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO, bool Postfix);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given unary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isPostfix() ? Val->getBeginLoc() : getOperatorLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return isPostfix() ? getOperatorLoc() : Val->getEndLoc();\n  }\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryOperatorClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n\n  /// Is FPFeatures in Trailing Storage?\n  bool hasStoredFPFeatures() const { return UnaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    return getTrailingFPFeatures();\n  }\n\nprotected:\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) { getTrailingFPFeatures() = F; }\n\npublic:\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n  FPOptionsOverride getFPOptionsOverride() const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  friend TrailingObjects;\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Helper class for OffsetOfExpr.\n\n// __builtin_offsetof(type, identifier(.identifier|[expr])*)\nclass OffsetOfNode {\npublic:\n  /// The kind of offsetof node we have.\n  enum Kind {\n    /// An index into an array.\n    Array = 0x00,\n    /// A field.\n    Field = 0x01,\n    /// A field in a dependent type, known only by its name.\n    Identifier = 0x02,\n    /// An implicit indirection through a C++ base class, when the\n    /// field found is in a base class.\n    Base = 0x03\n  };\n\nprivate:\n  enum { MaskBits = 2, Mask = 0x03 };\n\n  /// The source range that covers this part of the designator.\n  SourceRange Range;\n\n  /// The data describing the designator, which comes in three\n  /// different forms, depending on the lower two bits.\n  ///   - An unsigned index into the array of Expr*'s stored after this node\n  ///     in memory, for [constant-expression] designators.\n  ///   - A FieldDecl*, for references to a known field.\n  ///   - An IdentifierInfo*, for references to a field with a given name\n  ///     when the class type is dependent.\n  ///   - A CXXBaseSpecifier*, for references that look at a field in a\n  ///     base class.\n  uintptr_t Data;\n\npublic:\n  /// Create an offsetof node that refers to an array element.\n  OffsetOfNode(SourceLocation LBracketLoc, unsigned Index,\n               SourceLocation RBracketLoc)\n      : Range(LBracketLoc, RBracketLoc), Data((Index << 2) | Array) {}\n\n  /// Create an offsetof node that refers to a field.\n  OffsetOfNode(SourceLocation DotLoc, FieldDecl *Field, SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Field) | OffsetOfNode::Field) {}\n\n  /// Create an offsetof node that refers to an identifier.\n  OffsetOfNode(SourceLocation DotLoc, IdentifierInfo *Name,\n               SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Name) | Identifier) {}\n\n  /// Create an offsetof node that refers into a C++ base class.\n  explicit OffsetOfNode(const CXXBaseSpecifier *Base)\n      : Range(), Data(reinterpret_cast<uintptr_t>(Base) | OffsetOfNode::Base) {}\n\n  /// Determine what kind of offsetof node this is.\n  Kind getKind() const { return static_cast<Kind>(Data & Mask); }\n\n  /// For an array element node, returns the index into the array\n  /// of expressions.\n  unsigned getArrayExprIndex() const {\n    assert(getKind() == Array);\n    return Data >> 2;\n  }\n\n  /// For a field offsetof node, returns the field.\n  FieldDecl *getField() const {\n    assert(getKind() == Field);\n    return reinterpret_cast<FieldDecl *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// For a field or identifier offsetof node, returns the name of\n  /// the field.\n  IdentifierInfo *getFieldName() const;\n\n  /// For a base class node, returns the base specifier.\n  CXXBaseSpecifier *getBase() const {\n    assert(getKind() == Base);\n    return reinterpret_cast<CXXBaseSpecifier *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// Retrieve the source range that covers this offsetof node.\n  ///\n  /// For an array element node, the source range contains the locations of\n  /// the square brackets. For a field or identifier node, the source range\n  /// contains the location of the period (if there is one) and the\n  /// identifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n};\n\n/// OffsetOfExpr - [C99 7.17] - This represents an expression of the form\n/// offsetof(record-type, member-designator). For example, given:\n/// @code\n/// struct S {\n///   float f;\n///   double d;\n/// };\n/// struct T {\n///   int i;\n///   struct S s[10];\n/// };\n/// @endcode\n/// we can represent and evaluate the expression @c offsetof(struct T, s[2].d).\n\nclass OffsetOfExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OffsetOfExpr, OffsetOfNode, Expr *> {\n  SourceLocation OperatorLoc, RParenLoc;\n  // Base type;\n  TypeSourceInfo *TSInfo;\n  // Number of sub-components (i.e. instances of OffsetOfNode).\n  unsigned NumComps;\n  // Number of sub-expressions (i.e. array subscript expressions).\n  unsigned NumExprs;\n\n  size_t numTrailingObjects(OverloadToken<OffsetOfNode>) const {\n    return NumComps;\n  }\n\n  OffsetOfExpr(const ASTContext &C, QualType type,\n               SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n               ArrayRef<OffsetOfNode> comps, ArrayRef<Expr*> exprs,\n               SourceLocation RParenLoc);\n\n  explicit OffsetOfExpr(unsigned numComps, unsigned numExprs)\n    : Expr(OffsetOfExprClass, EmptyShell()),\n      TSInfo(nullptr), NumComps(numComps), NumExprs(numExprs) {}\n\npublic:\n\n  static OffsetOfExpr *Create(const ASTContext &C, QualType type,\n                              SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n                              ArrayRef<OffsetOfNode> comps,\n                              ArrayRef<Expr*> exprs, SourceLocation RParenLoc);\n\n  static OffsetOfExpr *CreateEmpty(const ASTContext &C,\n                                   unsigned NumComps, unsigned NumExprs);\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n  void setOperatorLoc(SourceLocation L) { OperatorLoc = L; }\n\n  /// Return the location of the right parentheses.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation R) { RParenLoc = R; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TSInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tsi) {\n    TSInfo = tsi;\n  }\n\n  const OffsetOfNode &getComponent(unsigned Idx) const {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    return getTrailingObjects<OffsetOfNode>()[Idx];\n  }\n\n  void setComponent(unsigned Idx, OffsetOfNode ON) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<OffsetOfNode>()[Idx] = ON;\n  }\n\n  unsigned getNumComponents() const {\n    return NumComps;\n  }\n\n  Expr* getIndexExpr(unsigned Idx) {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  const Expr *getIndexExpr(unsigned Idx) const {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  void setIndexExpr(unsigned Idx, Expr* E) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<Expr *>()[Idx] = E;\n  }\n\n  unsigned getNumExpressions() const {\n    return NumExprs;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OffsetOfExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(begin, begin + NumExprs);\n  }\n  const_child_range children() const {\n    Stmt *const *begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(begin, begin + NumExprs);\n  }\n  friend TrailingObjects;\n};\n\n/// UnaryExprOrTypeTraitExpr - expression with either a type or (unevaluated)\n/// expression operand.  Used for sizeof/alignof (C99 6.5.3.4) and\n/// vec_step (OpenCL 1.1 6.11.12).\nclass UnaryExprOrTypeTraitExpr : public Expr {\n  union {\n    TypeSourceInfo *Ty;\n    Stmt *Ex;\n  } Argument;\n  SourceLocation OpLoc, RParenLoc;\n\npublic:\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, TypeSourceInfo *TInfo,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp)\n      : Expr(UnaryExprOrTypeTraitExprClass, resultType, VK_RValue, OK_Ordinary),\n        OpLoc(op), RParenLoc(rp) {\n    assert(ExprKind <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = ExprKind;\n    assert(static_cast<unsigned>(ExprKind) ==\n               UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n    Argument.Ty = TInfo;\n    setDependence(computeDependence(this));\n  }\n\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, Expr *E,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp);\n\n  /// Construct an empty sizeof/alignof expression.\n  explicit UnaryExprOrTypeTraitExpr(EmptyShell Empty)\n    : Expr(UnaryExprOrTypeTraitExprClass, Empty) { }\n\n  UnaryExprOrTypeTrait getKind() const {\n    return static_cast<UnaryExprOrTypeTrait>(UnaryExprOrTypeTraitExprBits.Kind);\n  }\n  void setKind(UnaryExprOrTypeTrait K) {\n    assert(K <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = K;\n    assert(static_cast<unsigned>(K) == UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n  }\n\n  bool isArgumentType() const { return UnaryExprOrTypeTraitExprBits.IsType; }\n  QualType getArgumentType() const {\n    return getArgumentTypeInfo()->getType();\n  }\n  TypeSourceInfo *getArgumentTypeInfo() const {\n    assert(isArgumentType() && \"calling getArgumentType() when arg is expr\");\n    return Argument.Ty;\n  }\n  Expr *getArgumentExpr() {\n    assert(!isArgumentType() && \"calling getArgumentExpr() when arg is type\");\n    return static_cast<Expr*>(Argument.Ex);\n  }\n  const Expr *getArgumentExpr() const {\n    return const_cast<UnaryExprOrTypeTraitExpr*>(this)->getArgumentExpr();\n  }\n\n  void setArgument(Expr *E) {\n    Argument.Ex = E;\n    UnaryExprOrTypeTraitExprBits.IsType = false;\n  }\n  void setArgument(TypeSourceInfo *TInfo) {\n    Argument.Ty = TInfo;\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n  }\n\n  /// Gets the argument type, or the type of the argument expression, whichever\n  /// is appropriate.\n  QualType getTypeOfArgument() const {\n    return isArgumentType() ? getArgumentType() : getArgumentExpr()->getType();\n  }\n\n  SourceLocation getOperatorLoc() const { return OpLoc; }\n  void setOperatorLoc(SourceLocation L) { OpLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryExprOrTypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children();\n  const_child_range children() const;\n};\n\n//===----------------------------------------------------------------------===//\n// Postfix Operators.\n//===----------------------------------------------------------------------===//\n\n/// ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.\nclass ArraySubscriptExpr : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\n  bool lhsIsBase() const { return getRHS()->getType()->isIntegerType(); }\n\npublic:\n  ArraySubscriptExpr(Expr *lhs, Expr *rhs, QualType t, ExprValueKind VK,\n                     ExprObjectKind OK, SourceLocation rbracketloc)\n      : Expr(ArraySubscriptExprClass, t, VK, OK) {\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = rbracketloc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array subscript expression.\n  explicit ArraySubscriptExpr(EmptyShell Shell)\n    : Expr(ArraySubscriptExprClass, Shell) { }\n\n  /// An array access can be written A[4] or 4[A] (both are equivalent).\n  /// - getBase() and getIdx() always present the normalized view: A[4].\n  ///    In this case getBase() returns \"A\" and getIdx() returns \"4\".\n  /// - getLHS() and getRHS() present the syntactic view. e.g. for\n  ///    4[A] getLHS() returns \"4\".\n  /// Note: Because vector element access is also written A[4] we must\n  /// predicate the format conversion in getBase and getIdx only on the\n  /// the type of the RHS, as it is possible for the LHS to be a vector of\n  /// integer type\n  Expr *getLHS() { return cast<Expr>(SubExprs[LHS]); }\n  const Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n\n  Expr *getRHS() { return cast<Expr>(SubExprs[RHS]); }\n  const Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  Expr *getBase() { return lhsIsBase() ? getLHS() : getRHS(); }\n  const Expr *getBase() const { return lhsIsBase() ? getLHS() : getRHS(); }\n\n  Expr *getIdx() { return lhsIsBase() ? getRHS() : getLHS(); }\n  const Expr *getIdx() const { return lhsIsBase() ? getRHS() : getLHS(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ArraySubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// MatrixSubscriptExpr - Matrix subscript expression for the MatrixType\n/// extension.\n/// MatrixSubscriptExpr can be either incomplete (only Base and RowIdx are set\n/// so far, the type is IncompleteMatrixIdx) or complete (Base, RowIdx and\n/// ColumnIdx refer to valid expressions). Incomplete matrix expressions only\n/// exist during the initial construction of the AST.\nclass MatrixSubscriptExpr : public Expr {\n  enum { BASE, ROW_IDX, COLUMN_IDX, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  MatrixSubscriptExpr(Expr *Base, Expr *RowIdx, Expr *ColumnIdx, QualType T,\n                      SourceLocation RBracketLoc)\n      : Expr(MatrixSubscriptExprClass, T, Base->getValueKind(),\n             OK_MatrixComponent) {\n    SubExprs[BASE] = Base;\n    SubExprs[ROW_IDX] = RowIdx;\n    SubExprs[COLUMN_IDX] = ColumnIdx;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = RBracketLoc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty matrix subscript expression.\n  explicit MatrixSubscriptExpr(EmptyShell Shell)\n      : Expr(MatrixSubscriptExprClass, Shell) {}\n\n  bool isIncomplete() const {\n    bool IsIncomplete = hasPlaceholderType(BuiltinType::IncompleteMatrixIdx);\n    assert((SubExprs[COLUMN_IDX] || IsIncomplete) &&\n           \"expressions without column index must be marked as incomplete\");\n    return IsIncomplete;\n  }\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  Expr *getRowIdx() { return cast<Expr>(SubExprs[ROW_IDX]); }\n  const Expr *getRowIdx() const { return cast<Expr>(SubExprs[ROW_IDX]); }\n  void setRowIdx(Expr *E) { SubExprs[ROW_IDX] = E; }\n\n  Expr *getColumnIdx() { return cast_or_null<Expr>(SubExprs[COLUMN_IDX]); }\n  const Expr *getColumnIdx() const {\n    assert(!isIncomplete() &&\n           \"cannot get the column index of an incomplete expression\");\n    return cast<Expr>(SubExprs[COLUMN_IDX]);\n  }\n  void setColumnIdx(Expr *E) { SubExprs[COLUMN_IDX] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MatrixSubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).\n/// CallExpr itself represents a normal function call, e.g., \"f(x, 2)\",\n/// while its subclasses may represent alternative syntax that (semantically)\n/// results in a function call. For example, CXXOperatorCallExpr is\n/// a subclass for overloaded operator calls that use operator syntax, e.g.,\n/// \"str1 + str2\" to resolve to a function call.\nclass CallExpr : public Expr {\n  enum { FN = 0, PREARGS_START = 1 };\n\n  /// The number of arguments in the call expression.\n  unsigned NumArgs;\n\n  /// The location of the right parenthese. This has a different meaning for\n  /// the derived classes of CallExpr.\n  SourceLocation RParenLoc;\n\n  // CallExpr store some data in trailing objects. However since CallExpr\n  // is used a base of other expression classes we cannot use\n  // llvm::TrailingObjects. Instead we manually perform the pointer arithmetic\n  // and casts.\n  //\n  // The trailing objects are in order:\n  //\n  // * A single \"Stmt *\" for the callee expression.\n  //\n  // * An array of getNumPreArgs() \"Stmt *\" for the pre-argument expressions.\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the argument expressions.\n  //\n  // * An optional of type FPOptionsOverride.\n  //\n  // Note that we store the offset in bytes from the this pointer to the start\n  // of the trailing objects. It would be perfectly possible to compute it\n  // based on the dynamic kind of the CallExpr. However 1.) we have plenty of\n  // space in the bit-fields of Stmt. 2.) It was benchmarked to be faster to\n  // compute this once and then load the offset from the bit-fields of Stmt,\n  // instead of re-computing the offset each time the trailing objects are\n  // accessed.\n\n  /// Return a pointer to the start of the trailing array of \"Stmt *\".\n  Stmt **getTrailingStmts() {\n    return reinterpret_cast<Stmt **>(reinterpret_cast<char *>(this) +\n                                     CallExprBits.OffsetToTrailingObjects);\n  }\n  Stmt *const *getTrailingStmts() const {\n    return const_cast<CallExpr *>(this)->getTrailingStmts();\n  }\n\n  /// Map a statement class to the appropriate offset in bytes from the\n  /// this pointer to the trailing objects.\n  static unsigned offsetToTrailingObjects(StmtClass SC);\n\n  unsigned getSizeOfTrailingStmts() const {\n    return (1 + getNumPreArgs() + getNumArgs()) * sizeof(Stmt *);\n  }\n\n  size_t getOffsetOfTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts();\n  }\n\npublic:\n  enum class ADLCallKind : bool { NotADL, UsesADL };\n  static constexpr ADLCallKind NotADL = ADLCallKind::NotADL;\n  static constexpr ADLCallKind UsesADL = ADLCallKind::UsesADL;\n\nprotected:\n  /// Build a call expression, assuming that appropriate storage has been\n  /// allocated for the trailing objects.\n  CallExpr(StmtClass SC, Expr *Fn, ArrayRef<Expr *> PreArgs,\n           ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n           SourceLocation RParenLoc, FPOptionsOverride FPFeatures,\n           unsigned MinNumArgs, ADLCallKind UsesADL);\n\n  /// Build an empty call expression, for deserialization.\n  CallExpr(StmtClass SC, unsigned NumPreArgs, unsigned NumArgs,\n           bool hasFPFeatures, EmptyShell Empty);\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used by the derived classes to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumPreArgs, unsigned NumArgs,\n                                        bool HasFPFeatures) {\n    return (1 + NumPreArgs + NumArgs) * sizeof(Stmt *) +\n           HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n\n  Stmt *getPreArg(unsigned I) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  const Stmt *getPreArg(unsigned I) const {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  void setPreArg(unsigned I, Stmt *PreArg) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    getTrailingStmts()[PREARGS_START + I] = PreArg;\n  }\n\n  unsigned getNumPreArgs() const { return CallExprBits.NumPreArgs; }\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + CallExprBits.OffsetToTrailingObjects +\n        getSizeOfTrailingStmts());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) +\n        CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts());\n  }\n\npublic:\n  /// Create a call expression.\n  /// \\param Fn     The callee expression,\n  /// \\param Args   The argument array,\n  /// \\param Ty     The type of the call expression (which is *not* the return\n  ///               type in general),\n  /// \\param VK     The value kind of the call expression (lvalue, rvalue, ...),\n  /// \\param RParenLoc  The location of the right parenthesis in the call\n  ///                   expression.\n  /// \\param FPFeatures Floating-point features associated with the call,\n  /// \\param MinNumArgs Specifies the minimum number of arguments. The actual\n  ///                   number of arguments will be the greater of Args.size()\n  ///                   and MinNumArgs. This is used in a few places to allocate\n  ///                   enough storage for the default arguments.\n  /// \\param UsesADL    Specifies whether the callee was found through\n  ///                   argument-dependent lookup.\n  ///\n  /// Note that you can use CreateTemporary if you need a temporary call\n  /// expression on the stack.\n  static CallExpr *Create(const ASTContext &Ctx, Expr *Fn,\n                          ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n                          SourceLocation RParenLoc,\n                          FPOptionsOverride FPFeatures, unsigned MinNumArgs = 0,\n                          ADLCallKind UsesADL = NotADL);\n\n  /// Create a temporary call expression with no arguments in the memory\n  /// pointed to by Mem. Mem must points to at least sizeof(CallExpr)\n  /// + sizeof(Stmt *) bytes of storage, aligned to alignof(CallExpr):\n  ///\n  /// \\code{.cpp}\n  ///   alignas(CallExpr) char Buffer[sizeof(CallExpr) + sizeof(Stmt *)];\n  ///   CallExpr *TheCall = CallExpr::CreateTemporary(Buffer, etc);\n  /// \\endcode\n  static CallExpr *CreateTemporary(void *Mem, Expr *Fn, QualType Ty,\n                                   ExprValueKind VK, SourceLocation RParenLoc,\n                                   ADLCallKind UsesADL = NotADL);\n\n  /// Create an empty call expression, for deserialization.\n  static CallExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs,\n                               bool HasFPFeatures, EmptyShell Empty);\n\n  Expr *getCallee() { return cast<Expr>(getTrailingStmts()[FN]); }\n  const Expr *getCallee() const { return cast<Expr>(getTrailingStmts()[FN]); }\n  void setCallee(Expr *F) { getTrailingStmts()[FN] = F; }\n\n  ADLCallKind getADLCallKind() const {\n    return static_cast<ADLCallKind>(CallExprBits.UsesADL);\n  }\n  void setADLCallKind(ADLCallKind V = UsesADL) {\n    CallExprBits.UsesADL = static_cast<bool>(V);\n  }\n  bool usesADL() const { return getADLCallKind() == UsesADL; }\n\n  bool hasStoredFPFeatures() const { return CallExprBits.HasFPFeatures; }\n\n  Decl *getCalleeDecl() { return getCallee()->getReferencedDeclOfCallee(); }\n  const Decl *getCalleeDecl() const {\n    return getCallee()->getReferencedDeclOfCallee();\n  }\n\n  /// If the callee is a FunctionDecl, return it. Otherwise return null.\n  FunctionDecl *getDirectCallee() {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n  const FunctionDecl *getDirectCallee() const {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n\n  /// getNumArgs - Return the number of actual arguments to this call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Retrieve the call arguments.\n  Expr **getArgs() {\n    return reinterpret_cast<Expr **>(getTrailingStmts() + PREARGS_START +\n                                     getNumPreArgs());\n  }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(\n        getTrailingStmts() + PREARGS_START + getNumPreArgs());\n  }\n\n  /// getArg - Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// setArg - Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  /// Reduce the number of arguments in this call expression. This is used for\n  /// example during error recovery to drop extra arguments. There is no way\n  /// to perform the opposite because: 1.) We don't track how much storage\n  /// we have for the argument array 2.) This would potentially require growing\n  /// the argument array, something we cannot support since the arguments are\n  /// stored in a trailing array.\n  void shrinkNumArgs(unsigned NewNumArgs) {\n    assert((NewNumArgs <= getNumArgs()) &&\n           \"shrinkNumArgs cannot increase the number of arguments!\");\n    NumArgs = NewNumArgs;\n  }\n\n  /// Bluntly set a new number of arguments without doing any checks whatsoever.\n  /// Only used during construction of a CallExpr in a few places in Sema.\n  /// FIXME: Find a way to remove it.\n  void setNumArgsUnsafe(unsigned NewNumArgs) { NumArgs = NewNumArgs; }\n\n  typedef ExprIterator arg_iterator;\n  typedef ConstExprIterator const_arg_iterator;\n  typedef llvm::iterator_range<arg_iterator> arg_range;\n  typedef llvm::iterator_range<const_arg_iterator> const_arg_range;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n\n  const_arg_iterator arg_begin() const {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  /// This method provides fast access to all the subexpressions of\n  /// a CallExpr without going through the slower virtual child_iterator\n  /// interface.  This provides efficient reverse iteration of the\n  /// subexpressions.  This is currently used for CFG construction.\n  ArrayRef<Stmt *> getRawSubExprs() {\n    return llvm::makeArrayRef(getTrailingStmts(),\n                              PREARGS_START + getNumPreArgs() + getNumArgs());\n  }\n\n  /// getNumCommas - Return the number of commas that must have been present in\n  /// this function call.\n  unsigned getNumCommas() const { return getNumArgs() ? getNumArgs() - 1 : 0; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPOptionsOverride in trailing storage. Used only by Serialization.\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(hasStoredFPFeatures());\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  /// getBuiltinCallee - If this is a call to a builtin, return the builtin ID\n  /// of the callee. If not, return 0.\n  unsigned getBuiltinCallee() const;\n\n  /// Returns \\c true if this is a call to a builtin which does not\n  /// evaluate side-effects within its arguments.\n  bool isUnevaluatedBuiltinCall(const ASTContext &Ctx) const;\n\n  /// getCallReturnType - Get the return type of the call expr. This is not\n  /// always the type of the expr itself, if the return type is a reference\n  /// type.\n  QualType getCallReturnType(const ASTContext &Ctx) const;\n\n  /// Returns the WarnUnusedResultAttr that is either declared on the called\n  /// function, or its return type declaration.\n  const Attr *getUnusedResultAttr(const ASTContext &Ctx) const;\n\n  /// Returns true if this call expression should warn on unused results.\n  bool hasUnusedResultAttr(const ASTContext &Ctx) const {\n    return getUnusedResultAttr(Ctx) != nullptr;\n  }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Return true if this is a call to __assume() or __builtin_assume() with\n  /// a non-value-dependent constant parameter evaluating as false.\n  bool isBuiltinAssumeFalse(const ASTContext &Ctx) const;\n\n  /// Used by Sema to implement MSVC-compatible delayed name lookup.\n  /// (Usually Exprs themselves should set dependence).\n  void markDependentForPostponedNameLookup() {\n    setDependence(getDependence() | ExprDependence::TypeValueInstantiation);\n  }\n\n  bool isCallToStdMove() const {\n    const FunctionDecl *FD = getDirectCallee();\n    return getNumArgs() == 1 && FD && FD->isInStdNamespace() &&\n           FD->getIdentifier() && FD->getIdentifier()->isStr(\"move\");\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCallExprConstant &&\n           T->getStmtClass() <= lastCallExprConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingStmts(), getTrailingStmts() + PREARGS_START +\n                                               getNumPreArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingStmts(),\n                             getTrailingStmts() + PREARGS_START +\n                                 getNumPreArgs() + getNumArgs());\n  }\n};\n\n/// Extra data stored in some MemberExpr objects.\nstruct MemberExprNameQualifier {\n  /// The nested-name-specifier that qualifies the name, including\n  /// source-location information.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The DeclAccessPair through which the MemberDecl was found due to\n  /// name qualifiers.\n  DeclAccessPair FoundDecl;\n};\n\n/// MemberExpr - [C99 6.5.2.3] Structure and Union Members.  X->F and X.F.\n///\nclass MemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<MemberExpr, MemberExprNameQualifier,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Base - the expression for the base pointer or structure references.  In\n  /// X.F, this is \"X\".\n  Stmt *Base;\n\n  /// MemberDecl - This is the decl being referenced by the field/member name.\n  /// In X.F, this is the decl referenced by F.\n  ValueDecl *MemberDecl;\n\n  /// MemberDNLoc - Provides source/type location info for the\n  /// declaration name embedded in MemberDecl.\n  DeclarationNameLoc MemberDNLoc;\n\n  /// MemberLoc - This is the location of the member name.\n  SourceLocation MemberLoc;\n\n  size_t numTrailingObjects(OverloadToken<MemberExprNameQualifier>) const {\n    return hasQualifierOrFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  bool hasQualifierOrFoundDecl() const {\n    return MemberExprBits.HasQualifierOrFoundDecl;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return MemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  MemberExpr(Expr *Base, bool IsArrow, SourceLocation OperatorLoc,\n             ValueDecl *MemberDecl, const DeclarationNameInfo &NameInfo,\n             QualType T, ExprValueKind VK, ExprObjectKind OK,\n             NonOdrUseReason NOUR);\n  MemberExpr(EmptyShell Empty)\n      : Expr(MemberExprClass, Empty), Base(), MemberDecl() {}\n\npublic:\n  static MemberExpr *Create(const ASTContext &C, Expr *Base, bool IsArrow,\n                            SourceLocation OperatorLoc,\n                            NestedNameSpecifierLoc QualifierLoc,\n                            SourceLocation TemplateKWLoc, ValueDecl *MemberDecl,\n                            DeclAccessPair FoundDecl,\n                            DeclarationNameInfo MemberNameInfo,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            QualType T, ExprValueKind VK, ExprObjectKind OK,\n                            NonOdrUseReason NOUR);\n\n  /// Create an implicit MemberExpr, with no location, qualifier, template\n  /// arguments, and so on. Suitable only for non-static member access.\n  static MemberExpr *CreateImplicit(const ASTContext &C, Expr *Base,\n                                    bool IsArrow, ValueDecl *MemberDecl,\n                                    QualType T, ExprValueKind VK,\n                                    ExprObjectKind OK) {\n    return Create(C, Base, IsArrow, SourceLocation(), NestedNameSpecifierLoc(),\n                  SourceLocation(), MemberDecl,\n                  DeclAccessPair::make(MemberDecl, MemberDecl->getAccess()),\n                  DeclarationNameInfo(), nullptr, T, VK, OK, NOUR_None);\n  }\n\n  static MemberExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                 bool HasFoundDecl,\n                                 bool HasTemplateKWAndArgsInfo,\n                                 unsigned NumTemplateArgs);\n\n  void setBase(Expr *E) { Base = E; }\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Retrieve the member declaration to which this expression refers.\n  ///\n  /// The returned declaration will be a FieldDecl or (in C++) a VarDecl (for\n  /// static data members), a CXXMethodDecl, or an EnumConstantDecl.\n  ValueDecl *getMemberDecl() const { return MemberDecl; }\n  void setMemberDecl(ValueDecl *D);\n\n  /// Retrieves the declaration found by lookup.\n  DeclAccessPair getFoundDecl() const {\n    if (!hasQualifierOrFoundDecl())\n      return DeclAccessPair::make(getMemberDecl(),\n                                  getMemberDecl()->getAccess());\n    return getTrailingObjects<MemberExprNameQualifier>()->FoundDecl;\n  }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return getQualifier() != nullptr; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name, with source-location\n  /// information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifierOrFoundDecl())\n      return NestedNameSpecifierLoc();\n    return getTrailingObjects<MemberExprNameQualifier>()->QualifierLoc;\n  }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// the member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether the member name was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Retrieve the member declaration name info.\n  DeclarationNameInfo getMemberNameInfo() const {\n    return DeclarationNameInfo(MemberDecl->getDeclName(),\n                               MemberLoc, MemberDNLoc);\n  }\n\n  SourceLocation getOperatorLoc() const { return MemberExprBits.OperatorLoc; }\n\n  bool isArrow() const { return MemberExprBits.IsArrow; }\n  void setArrow(bool A) { MemberExprBits.IsArrow = A; }\n\n  /// getMemberLoc - Return the location of the \"member\", in X->F, it is the\n  /// location of 'F'.\n  SourceLocation getMemberLoc() const { return MemberLoc; }\n  void setMemberLoc(SourceLocation L) { MemberLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  SourceLocation getExprLoc() const LLVM_READONLY { return MemberLoc; }\n\n  /// Determine whether the base of this explicit is implicit.\n  bool isImplicitAccess() const {\n    return getBase() && getBase()->isImplicitCXXThis();\n  }\n\n  /// Returns true if this member expression refers to a method that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return MemberExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a method that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    MemberExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Returns true if virtual dispatch is performed.\n  /// If the member access is fully qualified, (i.e. X::f()), virtual\n  /// dispatching is not performed. In -fapple-kext mode qualified\n  /// calls to virtual method will still go through the vtable.\n  bool performsVirtualDispatch(const LangOptions &LO) const {\n    return LO.AppleKext || !hasQualifier();\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  /// This is only meaningful if the named member is a static member.\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(MemberExprBits.NonOdrUseReason);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MemberExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// CompoundLiteralExpr - [C99 6.5.2.5]\n///\nclass CompoundLiteralExpr : public Expr {\n  /// LParenLoc - If non-null, this is the location of the left paren in a\n  /// compound literal like \"(int){4}\".  This can be null if this is a\n  /// synthesized compound expression.\n  SourceLocation LParenLoc;\n\n  /// The type as written.  This can be an incomplete array type, in\n  /// which case the actual expression type will be different.\n  /// The int part of the pair stores whether this expr is file scope.\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfoAndScope;\n  Stmt *Init;\npublic:\n  CompoundLiteralExpr(SourceLocation lparenloc, TypeSourceInfo *tinfo,\n                      QualType T, ExprValueKind VK, Expr *init, bool fileScope)\n      : Expr(CompoundLiteralExprClass, T, VK, OK_Ordinary),\n        LParenLoc(lparenloc), TInfoAndScope(tinfo, fileScope), Init(init) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty compound literal.\n  explicit CompoundLiteralExpr(EmptyShell Empty)\n    : Expr(CompoundLiteralExprClass, Empty) { }\n\n  const Expr *getInitializer() const { return cast<Expr>(Init); }\n  Expr *getInitializer() { return cast<Expr>(Init); }\n  void setInitializer(Expr *E) { Init = E; }\n\n  bool isFileScope() const { return TInfoAndScope.getInt(); }\n  void setFileScope(bool FS) { TInfoAndScope.setInt(FS); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfoAndScope.getPointer();\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tinfo) {\n    TInfoAndScope.setPointer(tinfo);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    if (LParenLoc.isInvalid())\n      return Init->getBeginLoc();\n    return LParenLoc;\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    return Init->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CompoundLiteralExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Init, &Init+1); }\n  const_child_range children() const {\n    return const_child_range(&Init, &Init + 1);\n  }\n};\n\n/// CastExpr - Base class for type casts, including both implicit\n/// casts (ImplicitCastExpr) and explicit casts that have some\n/// representation in the source code (ExplicitCastExpr's derived\n/// classes).\nclass CastExpr : public Expr {\n  Stmt *Op;\n\n  bool CastConsistency() const;\n\n  const CXXBaseSpecifier * const *path_buffer() const {\n    return const_cast<CastExpr*>(this)->path_buffer();\n  }\n  CXXBaseSpecifier **path_buffer();\n\n  friend class ASTStmtReader;\n\nprotected:\n  CastExpr(StmtClass SC, QualType ty, ExprValueKind VK, const CastKind kind,\n           Expr *op, unsigned BasePathSize, bool HasFPFeatures)\n      : Expr(SC, ty, VK, OK_Ordinary), Op(op) {\n    CastExprBits.Kind = kind;\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n    setDependence(computeDependence(this));\n    assert(CastConsistency());\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n  }\n\n  /// Construct an empty cast.\n  CastExpr(StmtClass SC, EmptyShell Empty, unsigned BasePathSize,\n           bool HasFPFeatures)\n      : Expr(SC, Empty) {\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n  }\n\n  /// Return a pointer to the trailing FPOptions.\n  /// \\pre hasStoredFPFeatures() == true\n  FPOptionsOverride *getTrailingFPFeatures();\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    return const_cast<CastExpr *>(this)->getTrailingFPFeatures();\n  }\n\npublic:\n  CastKind getCastKind() const { return (CastKind) CastExprBits.Kind; }\n  void setCastKind(CastKind K) { CastExprBits.Kind = K; }\n\n  static const char *getCastKindName(CastKind CK);\n  const char *getCastKindName() const { return getCastKindName(getCastKind()); }\n\n  Expr *getSubExpr() { return cast<Expr>(Op); }\n  const Expr *getSubExpr() const { return cast<Expr>(Op); }\n  void setSubExpr(Expr *E) { Op = E; }\n\n  /// Retrieve the cast subexpression as it was written in the source\n  /// code, looking through any implicit casts or other intermediate nodes\n  /// introduced by semantic analysis.\n  Expr *getSubExprAsWritten();\n  const Expr *getSubExprAsWritten() const {\n    return const_cast<CastExpr *>(this)->getSubExprAsWritten();\n  }\n\n  /// If this cast applies a user-defined conversion, retrieve the conversion\n  /// function that it invokes.\n  NamedDecl *getConversionFunction() const;\n\n  typedef CXXBaseSpecifier **path_iterator;\n  typedef const CXXBaseSpecifier *const *path_const_iterator;\n  bool path_empty() const { return path_size() == 0; }\n  unsigned path_size() const { return CastExprBits.BasePathSize; }\n  path_iterator path_begin() { return path_buffer(); }\n  path_iterator path_end() { return path_buffer() + path_size(); }\n  path_const_iterator path_begin() const { return path_buffer(); }\n  path_const_iterator path_end() const { return path_buffer() + path_size(); }\n\n  llvm::iterator_range<path_iterator> path() {\n    return llvm::make_range(path_begin(), path_end());\n  }\n  llvm::iterator_range<path_const_iterator> path() const {\n    return llvm::make_range(path_begin(), path_end());\n  }\n\n  const FieldDecl *getTargetUnionField() const {\n    assert(getCastKind() == CK_ToUnion);\n    return getTargetFieldForToUnionCast(getType(), getSubExpr()->getType());\n  }\n\n  bool hasStoredFPFeatures() const { return CastExprBits.HasFPFeatures; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n\n  // Get the FP features status of this operation. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  static const FieldDecl *getTargetFieldForToUnionCast(QualType unionType,\n                                                       QualType opType);\n  static const FieldDecl *getTargetFieldForToUnionCast(const RecordDecl *RD,\n                                                       QualType opType);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCastExprConstant &&\n           T->getStmtClass() <= lastCastExprConstant;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Op, &Op+1); }\n  const_child_range children() const { return const_child_range(&Op, &Op + 1); }\n};\n\n/// ImplicitCastExpr - Allows us to explicitly represent implicit type\n/// conversions, which have no direct representation in the original\n/// source code. For example: converting T[]->T*, void f()->void\n/// (*f)(), float->double, short->int, etc.\n///\n/// In C, implicit casts always produce rvalues. However, in C++, an\n/// implicit cast whose result is being bound to a reference will be\n/// an lvalue or xvalue. For example:\n///\n/// @code\n/// class Base { };\n/// class Derived : public Base { };\n/// Derived &&ref();\n/// void f(Derived d) {\n///   Base& b = d; // initializer is an ImplicitCastExpr\n///                // to an lvalue of type Base\n///   Base&& r = ref(); // initializer is an ImplicitCastExpr\n///                     // to an xvalue of type Base\n/// }\n/// @endcode\nclass ImplicitCastExpr final\n    : public CastExpr,\n      private llvm::TrailingObjects<ImplicitCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n\n  ImplicitCastExpr(QualType ty, CastKind kind, Expr *op,\n                   unsigned BasePathLength, FPOptionsOverride FPO,\n                   ExprValueKind VK)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, BasePathLength,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty implicit cast.\n  explicit ImplicitCastExpr(EmptyShell Shell, unsigned PathSize,\n                            bool HasFPFeatures)\n      : CastExpr(ImplicitCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  enum OnStack_t { OnStack };\n  ImplicitCastExpr(OnStack_t _, QualType ty, CastKind kind, Expr *op,\n                   ExprValueKind VK, FPOptionsOverride FPO)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, 0,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  bool isPartOfExplicitCast() const { return CastExprBits.PartOfExplicitCast; }\n  void setIsPartOfExplicitCast(bool PartOfExplicitCast) {\n    CastExprBits.PartOfExplicitCast = PartOfExplicitCast;\n  }\n\n  static ImplicitCastExpr *Create(const ASTContext &Context, QualType T,\n                                  CastKind Kind, Expr *Operand,\n                                  const CXXCastPath *BasePath,\n                                  ExprValueKind Cat, FPOptionsOverride FPO);\n\n  static ImplicitCastExpr *CreateEmpty(const ASTContext &Context,\n                                       unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// ExplicitCastExpr - An explicit cast written in the source\n/// code.\n///\n/// This class is effectively an abstract class, because it provides\n/// the basic representation of an explicitly-written cast without\n/// specifying which kind of cast (C cast, functional cast, static\n/// cast, etc.) was written; specific derived classes represent the\n/// particular style of cast and its location information.\n///\n/// Unlike implicit casts, explicit cast nodes have two different\n/// types: the type that was written into the source code, and the\n/// actual type of the expression as determined by semantic\n/// analysis. These types may differ slightly. For example, in C++ one\n/// can cast to a reference type, which indicates that the resulting\n/// expression will be an lvalue or xvalue. The reference type, however,\n/// will not be used as the type of the expression.\nclass ExplicitCastExpr : public CastExpr {\n  /// TInfo - Source type info for the (written) type\n  /// this expression is casting to.\n  TypeSourceInfo *TInfo;\n\nprotected:\n  ExplicitCastExpr(StmtClass SC, QualType exprTy, ExprValueKind VK,\n                   CastKind kind, Expr *op, unsigned PathSize,\n                   bool HasFPFeatures, TypeSourceInfo *writtenTy)\n      : CastExpr(SC, exprTy, VK, kind, op, PathSize, HasFPFeatures),\n        TInfo(writtenTy) {}\n\n  /// Construct an empty explicit cast.\n  ExplicitCastExpr(StmtClass SC, EmptyShell Shell, unsigned PathSize,\n                   bool HasFPFeatures)\n      : CastExpr(SC, Shell, PathSize, HasFPFeatures) {}\n\npublic:\n  /// getTypeInfoAsWritten - Returns the type source info for the type\n  /// that this expression is casting to.\n  TypeSourceInfo *getTypeInfoAsWritten() const { return TInfo; }\n  void setTypeInfoAsWritten(TypeSourceInfo *writtenTy) { TInfo = writtenTy; }\n\n  /// getTypeAsWritten - Returns the type that this expression is\n  /// casting to, as written in the source code.\n  QualType getTypeAsWritten() const { return TInfo->getType(); }\n\n  static bool classof(const Stmt *T) {\n     return T->getStmtClass() >= firstExplicitCastExprConstant &&\n            T->getStmtClass() <= lastExplicitCastExprConstant;\n  }\n};\n\n/// CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a C-style\n/// cast in C++ (C++ [expr.cast]), which uses the syntax\n/// (Type)expr. For example: @c (int)f.\nclass CStyleCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<CStyleCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  SourceLocation LPLoc; // the location of the left paren\n  SourceLocation RPLoc; // the location of the right paren\n\n  CStyleCastExpr(QualType exprTy, ExprValueKind vk, CastKind kind, Expr *op,\n                 unsigned PathSize, FPOptionsOverride FPO,\n                 TypeSourceInfo *writtenTy, SourceLocation l, SourceLocation r)\n      : ExplicitCastExpr(CStyleCastExprClass, exprTy, vk, kind, op, PathSize,\n                         FPO.requiresTrailingStorage(), writtenTy),\n        LPLoc(l), RPLoc(r) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty C-style explicit cast.\n  explicit CStyleCastExpr(EmptyShell Shell, unsigned PathSize,\n                          bool HasFPFeatures)\n      : ExplicitCastExpr(CStyleCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  static CStyleCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK, CastKind K,\n         Expr *Op, const CXXCastPath *BasePath, FPOptionsOverride FPO,\n         TypeSourceInfo *WrittenTy, SourceLocation L, SourceLocation R);\n\n  static CStyleCastExpr *CreateEmpty(const ASTContext &Context,\n                                     unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LPLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CStyleCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// A builtin binary operation expression such as \"x + y\" or \"x <= y\".\n///\n/// This expression node kind describes a builtin binary operation,\n/// such as \"x + y\" for integer values \"x\" and \"y\". The operands will\n/// already have been converted to appropriate types (e.g., by\n/// performing promotions or conversions).\n///\n/// In C++, where operators may be overloaded, a different kind of\n/// expression node (CXXOperatorCallExpr) is used to express the\n/// invocation of an overloaded operator with operator syntax. Within\n/// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is\n/// used to store an expression \"x + y\" depends on the subexpressions\n/// for x and y. If neither x or y is type-dependent, and the \"+\"\n/// operator resolves to a built-in operation, BinaryOperator will be\n/// used to express the computation (x and y may still be\n/// value-dependent). If either x or y is type-dependent, or if the\n/// \"+\" resolves to an overloaded operator, CXXOperatorCallExpr will\n/// be used to express the computation.\nclass BinaryOperator : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  typedef BinaryOperatorKind Opcode;\n\nprotected:\n  size_t offsetOfTrailingStorage() const;\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + offsetOfTrailingStorage());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) + offsetOfTrailingStorage());\n  }\n\n  /// Build a binary operator, assuming that appropriate storage has been\n  /// allocated for the trailing objects when needed.\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures);\n\n  /// Construct an empty binary operator.\n  explicit BinaryOperator(EmptyShell Empty) : Expr(BinaryOperatorClass, Empty) {\n    BinaryOperatorBits.Opc = BO_Comma;\n  }\n\npublic:\n  static BinaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static BinaryOperator *Create(const ASTContext &C, Expr *lhs, Expr *rhs,\n                                Opcode opc, QualType ResTy, ExprValueKind VK,\n                                ExprObjectKind OK, SourceLocation opLoc,\n                                FPOptionsOverride FPFeatures);\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n  SourceLocation getOperatorLoc() const { return BinaryOperatorBits.OpLoc; }\n  void setOperatorLoc(SourceLocation L) { BinaryOperatorBits.OpLoc = L; }\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(BinaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { BinaryOperatorBits.Opc = Opc; }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"<<=\".\n  static StringRef getOpcodeStr(Opcode Op);\n\n  StringRef getOpcodeStr() const { return getOpcodeStr(getOpcode()); }\n\n  /// Retrieve the binary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given binary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  /// predicates to categorize the respective opcodes.\n  static bool isPtrMemOp(Opcode Opc) {\n    return Opc == BO_PtrMemD || Opc == BO_PtrMemI;\n  }\n  bool isPtrMemOp() const { return isPtrMemOp(getOpcode()); }\n\n  static bool isMultiplicativeOp(Opcode Opc) {\n    return Opc >= BO_Mul && Opc <= BO_Rem;\n  }\n  bool isMultiplicativeOp() const { return isMultiplicativeOp(getOpcode()); }\n  static bool isAdditiveOp(Opcode Opc) { return Opc == BO_Add || Opc==BO_Sub; }\n  bool isAdditiveOp() const { return isAdditiveOp(getOpcode()); }\n  static bool isShiftOp(Opcode Opc) { return Opc == BO_Shl || Opc == BO_Shr; }\n  bool isShiftOp() const { return isShiftOp(getOpcode()); }\n\n  static bool isBitwiseOp(Opcode Opc) { return Opc >= BO_And && Opc <= BO_Or; }\n  bool isBitwiseOp() const { return isBitwiseOp(getOpcode()); }\n\n  static bool isRelationalOp(Opcode Opc) { return Opc >= BO_LT && Opc<=BO_GE; }\n  bool isRelationalOp() const { return isRelationalOp(getOpcode()); }\n\n  static bool isEqualityOp(Opcode Opc) { return Opc == BO_EQ || Opc == BO_NE; }\n  bool isEqualityOp() const { return isEqualityOp(getOpcode()); }\n\n  static bool isComparisonOp(Opcode Opc) { return Opc >= BO_Cmp && Opc<=BO_NE; }\n  bool isComparisonOp() const { return isComparisonOp(getOpcode()); }\n\n  static bool isCommaOp(Opcode Opc) { return Opc == BO_Comma; }\n  bool isCommaOp() const { return isCommaOp(getOpcode()); }\n\n  static Opcode negateComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GE;\n    case BO_GT: return BO_LE;\n    case BO_LE: return BO_GT;\n    case BO_GE: return BO_LT;\n    case BO_EQ: return BO_NE;\n    case BO_NE: return BO_EQ;\n    }\n  }\n\n  static Opcode reverseComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GT;\n    case BO_GT: return BO_LT;\n    case BO_LE: return BO_GE;\n    case BO_GE: return BO_LE;\n    case BO_EQ:\n    case BO_NE:\n      return Opc;\n    }\n  }\n\n  static bool isLogicalOp(Opcode Opc) { return Opc == BO_LAnd || Opc==BO_LOr; }\n  bool isLogicalOp() const { return isLogicalOp(getOpcode()); }\n\n  static bool isAssignmentOp(Opcode Opc) {\n    return Opc >= BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isAssignmentOp() const { return isAssignmentOp(getOpcode()); }\n\n  static bool isCompoundAssignmentOp(Opcode Opc) {\n    return Opc > BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isCompoundAssignmentOp() const {\n    return isCompoundAssignmentOp(getOpcode());\n  }\n  static Opcode getOpForCompoundAssignment(Opcode Opc) {\n    assert(isCompoundAssignmentOp(Opc));\n    if (Opc >= BO_AndAssign)\n      return Opcode(unsigned(Opc) - BO_AndAssign + BO_And);\n    else\n      return Opcode(unsigned(Opc) - BO_MulAssign + BO_Mul);\n  }\n\n  static bool isShiftAssignOp(Opcode Opc) {\n    return Opc == BO_ShlAssign || Opc == BO_ShrAssign;\n  }\n  bool isShiftAssignOp() const {\n    return isShiftAssignOp(getOpcode());\n  }\n\n  // Return true if a binary operator using the specified opcode and operands\n  // would match the 'p = (i8*)nullptr + n' idiom for casting a pointer-sized\n  // integer to a pointer.\n  static bool isNullPointerArithmeticExtension(ASTContext &Ctx, Opcode Opc,\n                                               Expr *LHS, Expr *RHS);\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstBinaryOperatorConstant &&\n           S->getStmtClass() <= lastBinaryOperatorConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n\n  /// Set and fetch the bit that shows whether FPFeatures needs to be\n  /// allocated in Trailing Storage\n  void setHasStoredFPFeatures(bool B) { BinaryOperatorBits.HasFPFeatures = B; }\n  bool hasStoredFPFeatures() const { return BinaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  // This is used in ASTImporter\n  FPOptionsOverride getFPFeatures(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\nprotected:\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures,\n                 bool dead2);\n\n  /// Construct an empty BinaryOperator, SC is CompoundAssignOperator.\n  BinaryOperator(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    BinaryOperatorBits.Opc = BO_MulAssign;\n  }\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(bool HasFPFeatures) {\n    return HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n};\n\n/// CompoundAssignOperator - For compound assignments (e.g. +=), we keep\n/// track of the type the operation is performed in.  Due to the semantics of\n/// these operators, the operands are promoted, the arithmetic performed, an\n/// implicit conversion back to the result type done, then the assignment takes\n/// place.  This captures the intermediate type which the computation is done\n/// in.\nclass CompoundAssignOperator : public BinaryOperator {\n  QualType ComputationLHSType;\n  QualType ComputationResultType;\n\n  /// Construct an empty CompoundAssignOperator.\n  explicit CompoundAssignOperator(const ASTContext &C, EmptyShell Empty,\n                                  bool hasFPFeatures)\n      : BinaryOperator(CompoundAssignOperatorClass, Empty) {}\n\nprotected:\n  CompoundAssignOperator(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc,\n                         QualType ResType, ExprValueKind VK, ExprObjectKind OK,\n                         SourceLocation OpLoc, FPOptionsOverride FPFeatures,\n                         QualType CompLHSType, QualType CompResultType)\n      : BinaryOperator(C, lhs, rhs, opc, ResType, VK, OK, OpLoc, FPFeatures,\n                       true),\n        ComputationLHSType(CompLHSType), ComputationResultType(CompResultType) {\n    assert(isCompoundAssignmentOp() &&\n           \"Only should be used for compound assignments\");\n  }\n\npublic:\n  static CompoundAssignOperator *CreateEmpty(const ASTContext &C,\n                                             bool hasFPFeatures);\n\n  static CompoundAssignOperator *\n  Create(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc, QualType ResTy,\n         ExprValueKind VK, ExprObjectKind OK, SourceLocation opLoc,\n         FPOptionsOverride FPFeatures, QualType CompLHSType = QualType(),\n         QualType CompResultType = QualType());\n\n  // The two computation types are the type the LHS is converted\n  // to for the computation and the type of the result; the two are\n  // distinct in a few cases (specifically, int+=ptr and ptr-=ptr).\n  QualType getComputationLHSType() const { return ComputationLHSType; }\n  void setComputationLHSType(QualType T) { ComputationLHSType = T; }\n\n  QualType getComputationResultType() const { return ComputationResultType; }\n  void setComputationResultType(QualType T) { ComputationResultType = T; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == CompoundAssignOperatorClass;\n  }\n};\n\ninline size_t BinaryOperator::offsetOfTrailingStorage() const {\n  assert(BinaryOperatorBits.HasFPFeatures);\n  return isa<CompoundAssignOperator>(this) ? sizeof(CompoundAssignOperator)\n                                           : sizeof(BinaryOperator);\n}\n\n/// AbstractConditionalOperator - An abstract base class for\n/// ConditionalOperator and BinaryConditionalOperator.\nclass AbstractConditionalOperator : public Expr {\n  SourceLocation QuestionLoc, ColonLoc;\n  friend class ASTStmtReader;\n\nprotected:\n  AbstractConditionalOperator(StmtClass SC, QualType T, ExprValueKind VK,\n                              ExprObjectKind OK, SourceLocation qloc,\n                              SourceLocation cloc)\n      : Expr(SC, T, VK, OK), QuestionLoc(qloc), ColonLoc(cloc) {}\n\n  AbstractConditionalOperator(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) { }\n\npublic:\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const;\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const;\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const;\n\n  SourceLocation getQuestionLoc() const { return QuestionLoc; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass ||\n           T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n};\n\n/// ConditionalOperator - The ?: ternary operator.  The GNU \"missing\n/// middle\" extension is a BinaryConditionalOperator.\nclass ConditionalOperator : public AbstractConditionalOperator {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n\n  friend class ASTStmtReader;\npublic:\n  ConditionalOperator(Expr *cond, SourceLocation QLoc, Expr *lhs,\n                      SourceLocation CLoc, Expr *rhs, QualType t,\n                      ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(ConditionalOperatorClass, t, VK, OK, QLoc,\n                                    CLoc) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit ConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(ConditionalOperatorClass, Empty) { }\n\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const { return cast<Expr>(SubExprs[LHS]); }\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const { return cast<Expr>(SubExprs[RHS]); }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCond()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// BinaryConditionalOperator - The GNU extension to the conditional\n/// operator which allows the middle operand to be omitted.\n///\n/// This is a different expression kind on the assumption that almost\n/// every client ends up needing to know that these are different.\nclass BinaryConditionalOperator : public AbstractConditionalOperator {\n  enum { COMMON, COND, LHS, RHS, NUM_SUBEXPRS };\n\n  /// - the common condition/left-hand-side expression, which will be\n  ///   evaluated as the opaque value\n  /// - the condition, expressed in terms of the opaque value\n  /// - the left-hand-side, expressed in terms of the opaque value\n  /// - the right-hand-side\n  Stmt *SubExprs[NUM_SUBEXPRS];\n  OpaqueValueExpr *OpaqueValue;\n\n  friend class ASTStmtReader;\npublic:\n  BinaryConditionalOperator(Expr *common, OpaqueValueExpr *opaqueValue,\n                            Expr *cond, Expr *lhs, Expr *rhs,\n                            SourceLocation qloc, SourceLocation cloc,\n                            QualType t, ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(BinaryConditionalOperatorClass, t, VK, OK,\n                                    qloc, cloc),\n        OpaqueValue(opaqueValue) {\n    SubExprs[COMMON] = common;\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    assert(OpaqueValue->getSourceExpr() == common && \"Wrong opaque value\");\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit BinaryConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(BinaryConditionalOperatorClass, Empty) { }\n\n  /// getCommon - Return the common expression, written to the\n  ///   left of the condition.  The opaque value will be bound to the\n  ///   result of this expression.\n  Expr *getCommon() const { return cast<Expr>(SubExprs[COMMON]); }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  /// getCond - Return the condition expression; this is defined\n  ///   in terms of the opaque value.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  /// getTrueExpr - Return the subexpression which will be\n  ///   evaluated if the condition evaluates to true;  this is defined\n  ///   in terms of the opaque value.\n  Expr *getTrueExpr() const {\n    return cast<Expr>(SubExprs[LHS]);\n  }\n\n  /// getFalseExpr - Return the subexpression which will be\n  ///   evaluated if the condnition evaluates to false; this is\n  ///   defined in terms of the opaque value.\n  Expr *getFalseExpr() const {\n    return cast<Expr>(SubExprs[RHS]);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommon()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getFalseExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n};\n\ninline Expr *AbstractConditionalOperator::getCond() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getCond();\n  return cast<BinaryConditionalOperator>(this)->getCond();\n}\n\ninline Expr *AbstractConditionalOperator::getTrueExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getTrueExpr();\n  return cast<BinaryConditionalOperator>(this)->getTrueExpr();\n}\n\ninline Expr *AbstractConditionalOperator::getFalseExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getFalseExpr();\n  return cast<BinaryConditionalOperator>(this)->getFalseExpr();\n}\n\n/// AddrLabelExpr - The GNU address of label extension, representing &&label.\nclass AddrLabelExpr : public Expr {\n  SourceLocation AmpAmpLoc, LabelLoc;\n  LabelDecl *Label;\npublic:\n  AddrLabelExpr(SourceLocation AALoc, SourceLocation LLoc, LabelDecl *L,\n                QualType t)\n      : Expr(AddrLabelExprClass, t, VK_RValue, OK_Ordinary), AmpAmpLoc(AALoc),\n        LabelLoc(LLoc), Label(L) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty address of a label expression.\n  explicit AddrLabelExpr(EmptyShell Empty)\n    : Expr(AddrLabelExprClass, Empty) { }\n\n  SourceLocation getAmpAmpLoc() const { return AmpAmpLoc; }\n  void setAmpAmpLoc(SourceLocation L) { AmpAmpLoc = L; }\n  SourceLocation getLabelLoc() const { return LabelLoc; }\n  void setLabelLoc(SourceLocation L) { LabelLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AmpAmpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return LabelLoc; }\n\n  LabelDecl *getLabel() const { return Label; }\n  void setLabel(LabelDecl *L) { Label = L; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AddrLabelExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// StmtExpr - This is the GNU Statement Expression extension: ({int X=4; X;}).\n/// The StmtExpr contains a single CompoundStmt node, which it evaluates and\n/// takes the value of the last subexpression.\n///\n/// A StmtExpr is always an r-value; values \"returned\" out of a\n/// StmtExpr will be copied.\nclass StmtExpr : public Expr {\n  Stmt *SubStmt;\n  SourceLocation LParenLoc, RParenLoc;\npublic:\n  StmtExpr(CompoundStmt *SubStmt, QualType T, SourceLocation LParenLoc,\n           SourceLocation RParenLoc, unsigned TemplateDepth)\n      : Expr(StmtExprClass, T, VK_RValue, OK_Ordinary), SubStmt(SubStmt),\n        LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this, TemplateDepth));\n    // FIXME: A templated statement expression should have an associated\n    // DeclContext so that nested declarations always have a dependent context.\n    StmtExprBits.TemplateDepth = TemplateDepth;\n  }\n\n  /// Build an empty statement expression.\n  explicit StmtExpr(EmptyShell Empty) : Expr(StmtExprClass, Empty) { }\n\n  CompoundStmt *getSubStmt() { return cast<CompoundStmt>(SubStmt); }\n  const CompoundStmt *getSubStmt() const { return cast<CompoundStmt>(SubStmt); }\n  void setSubStmt(CompoundStmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  unsigned getTemplateDepth() const { return StmtExprBits.TemplateDepth; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StmtExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt+1); }\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\n/// ShuffleVectorExpr - clang-specific builtin-in function\n/// __builtin_shufflevector.\n/// This AST node represents a operator that does a constant\n/// shuffle, similar to LLVM's shufflevector instruction. It takes\n/// two vectors and a variable number of constant indices,\n/// and returns the appropriately shuffled vector.\nclass ShuffleVectorExpr : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  // SubExprs - the list of values passed to the __builtin_shufflevector\n  // function. The first two are vectors, and the rest are constant\n  // indices.  The number of values in this list is always\n  // 2+the number of indices in the vector type.\n  Stmt **SubExprs;\n  unsigned NumExprs;\n\npublic:\n  ShuffleVectorExpr(const ASTContext &C, ArrayRef<Expr*> args, QualType Type,\n                    SourceLocation BLoc, SourceLocation RP);\n\n  /// Build an empty vector-shuffle expression.\n  explicit ShuffleVectorExpr(EmptyShell Empty)\n    : Expr(ShuffleVectorExprClass, Empty), SubExprs(nullptr) { }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ShuffleVectorExprClass;\n  }\n\n  /// getNumSubExprs - Return the size of the SubExprs array.  This includes the\n  /// constant expression, the actual arguments passed in, and the function\n  /// pointers.\n  unsigned getNumSubExprs() const { return NumExprs; }\n\n  /// Retrieve the array of expressions.\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n\n  /// getExpr - Return the Expr at the specified index.\n  Expr *getExpr(unsigned Index) {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n  const Expr *getExpr(unsigned Index) const {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n\n  void setExprs(const ASTContext &C, ArrayRef<Expr *> Exprs);\n\n  llvm::APSInt getShuffleMaskIdx(const ASTContext &Ctx, unsigned N) const {\n    assert((N < NumExprs - 2) && \"Shuffle idx out of range!\");\n    return getExpr(N+2)->EvaluateKnownConstInt(Ctx);\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+NumExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + NumExprs);\n  }\n};\n\n/// ConvertVectorExpr - Clang builtin function __builtin_convertvector\n/// This AST node provides support for converting a vector type to another\n/// vector type of the same arity.\nclass ConvertVectorExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  TypeSourceInfo *TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit ConvertVectorExpr(EmptyShell Empty) : Expr(ConvertVectorExprClass, Empty) {}\n\npublic:\n  ConvertVectorExpr(Expr *SrcExpr, TypeSourceInfo *TI, QualType DstType,\n                    ExprValueKind VK, ExprObjectKind OK,\n                    SourceLocation BuiltinLoc, SourceLocation RParenLoc)\n      : Expr(ConvertVectorExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        TInfo(TI), BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getTypeSourceInfo - Return the destination type.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *ti) {\n    TInfo = ti;\n  }\n\n  /// getBuiltinLoc - Return the location of the __builtin_convertvector token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConvertVectorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// ChooseExpr - GNU builtin-in function __builtin_choose_expr.\n/// This AST node is similar to the conditional operator (?:) in C, with\n/// the following exceptions:\n/// - the test expression must be a integer constant expression.\n/// - the expression returned acts like the chosen subexpression in every\n///   visible way: the type is the same as that of the chosen subexpression,\n///   and all predicates (whether it's an l-value, whether it's an integer\n///   constant expression, etc.) return the same result as for the chosen\n///   sub-expression.\nclass ChooseExpr : public Expr {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n  SourceLocation BuiltinLoc, RParenLoc;\n  bool CondIsTrue;\npublic:\n  ChooseExpr(SourceLocation BLoc, Expr *cond, Expr *lhs, Expr *rhs, QualType t,\n             ExprValueKind VK, ExprObjectKind OK, SourceLocation RP,\n             bool condIsTrue)\n      : Expr(ChooseExprClass, t, VK, OK), BuiltinLoc(BLoc), RParenLoc(RP),\n        CondIsTrue(condIsTrue) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty __builtin_choose_expr.\n  explicit ChooseExpr(EmptyShell Empty) : Expr(ChooseExprClass, Empty) { }\n\n  /// isConditionTrue - Return whether the condition is true (i.e. not\n  /// equal to zero).\n  bool isConditionTrue() const {\n    assert(!isConditionDependent() &&\n           \"Dependent condition isn't true or false\");\n    return CondIsTrue;\n  }\n  void setIsConditionTrue(bool isTrue) { CondIsTrue = isTrue; }\n\n  bool isConditionDependent() const {\n    return getCond()->isTypeDependent() || getCond()->isValueDependent();\n  }\n\n  /// getChosenSubExpr - Return the subexpression chosen according to the\n  /// condition.\n  Expr *getChosenSubExpr() const {\n    return isConditionTrue() ? getLHS() : getRHS();\n  }\n\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n  void setCond(Expr *E) { SubExprs[COND] = E; }\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ChooseExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// GNUNullExpr - Implements the GNU __null extension, which is a name\n/// for a null pointer constant that has integral type (e.g., int or\n/// long) and is the same size and alignment as a pointer. The __null\n/// extension is typically only used by system headers, which define\n/// NULL as __null in C++ rather than using 0 (which is an integer\n/// that may not match the size of a pointer).\nclass GNUNullExpr : public Expr {\n  /// TokenLoc - The location of the __null keyword.\n  SourceLocation TokenLoc;\n\npublic:\n  GNUNullExpr(QualType Ty, SourceLocation Loc)\n      : Expr(GNUNullExprClass, Ty, VK_RValue, OK_Ordinary), TokenLoc(Loc) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty GNU __null expression.\n  explicit GNUNullExpr(EmptyShell Empty) : Expr(GNUNullExprClass, Empty) { }\n\n  /// getTokenLocation - The location of the __null token.\n  SourceLocation getTokenLocation() const { return TokenLoc; }\n  void setTokenLocation(SourceLocation L) { TokenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TokenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TokenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GNUNullExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a call to the builtin function \\c __builtin_va_arg.\nclass VAArgExpr : public Expr {\n  Stmt *Val;\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\npublic:\n  VAArgExpr(SourceLocation BLoc, Expr *e, TypeSourceInfo *TInfo,\n            SourceLocation RPLoc, QualType t, bool IsMS)\n      : Expr(VAArgExprClass, t, VK_RValue, OK_Ordinary), Val(e),\n        TInfo(TInfo, IsMS), BuiltinLoc(BLoc), RParenLoc(RPLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty __builtin_va_arg expression.\n  explicit VAArgExpr(EmptyShell Empty)\n      : Expr(VAArgExprClass, Empty), Val(nullptr), TInfo(nullptr, false) {}\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// Returns whether this is really a Win64 ABI va_arg expression.\n  bool isMicrosoftABI() const { return TInfo.getInt(); }\n  void setIsMicrosoftABI(bool IsMS) { TInfo.setInt(IsMS); }\n\n  TypeSourceInfo *getWrittenTypeInfo() const { return TInfo.getPointer(); }\n  void setWrittenTypeInfo(TypeSourceInfo *TI) { TInfo.setPointer(TI); }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == VAArgExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// Represents a function call to one of __builtin_LINE(), __builtin_COLUMN(),\n/// __builtin_FUNCTION(), or __builtin_FILE().\nclass SourceLocExpr final : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n  DeclContext *ParentContext;\n\npublic:\n  enum IdentKind { Function, File, Line, Column };\n\n  SourceLocExpr(const ASTContext &Ctx, IdentKind Type, SourceLocation BLoc,\n                SourceLocation RParenLoc, DeclContext *Context);\n\n  /// Build an empty call expression.\n  explicit SourceLocExpr(EmptyShell Empty) : Expr(SourceLocExprClass, Empty) {}\n\n  /// Return the result of evaluating this SourceLocExpr in the specified\n  /// (and possibly null) default argument or initialization context.\n  APValue EvaluateInContext(const ASTContext &Ctx,\n                            const Expr *DefaultExpr) const;\n\n  /// Return a string representing the name of the specific builtin function.\n  StringRef getBuiltinStr() const;\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(SourceLocExprBits.Kind);\n  }\n\n  bool isStringType() const {\n    switch (getIdentKind()) {\n    case File:\n    case Function:\n      return true;\n    case Line:\n    case Column:\n      return false;\n    }\n    llvm_unreachable(\"unknown source location expression kind\");\n  }\n  bool isIntType() const LLVM_READONLY { return !isStringType(); }\n\n  /// If the SourceLocExpr has been resolved return the subexpression\n  /// representing the resolved value. Otherwise return null.\n  const DeclContext *getParentContext() const { return ParentContext; }\n  DeclContext *getParentContext() { return ParentContext; }\n\n  SourceLocation getLocation() const { return BuiltinLoc; }\n  SourceLocation getBeginLoc() const { return BuiltinLoc; }\n  SourceLocation getEndLoc() const { return RParenLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(child_iterator(), child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SourceLocExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n};\n\n/// Describes an C or C++ initializer list.\n///\n/// InitListExpr describes an initializer list, which can be used to\n/// initialize objects of different types, including\n/// struct/class/union types, arrays, and vectors. For example:\n///\n/// @code\n/// struct foo x = { 1, { 2, 3 } };\n/// @endcode\n///\n/// Prior to semantic analysis, an initializer list will represent the\n/// initializer list as written by the user, but will have the\n/// placeholder type \"void\". This initializer list is called the\n/// syntactic form of the initializer, and may contain C99 designated\n/// initializers (represented as DesignatedInitExprs), initializations\n/// of subobject members without explicit braces, and so on. Clients\n/// interested in the original syntax of the initializer list should\n/// use the syntactic form of the initializer list.\n///\n/// After semantic analysis, the initializer list will represent the\n/// semantic form of the initializer, where the initializations of all\n/// subobjects are made explicit with nested InitListExpr nodes and\n/// C99 designators have been eliminated by placing the designated\n/// initializations into the subobject they initialize. Additionally,\n/// any \"holes\" in the initialization, where no initializer has been\n/// specified for a particular subobject, will be replaced with\n/// implicitly-generated ImplicitValueInitExpr expressions that\n/// value-initialize the subobjects. Note, however, that the\n/// initializer lists may still have fewer initializers than there are\n/// elements to initialize within the object.\n///\n/// After semantic analysis has completed, given an initializer list,\n/// method isSemanticForm() returns true if and only if this is the\n/// semantic form of the initializer list (note: the same AST node\n/// may at the same time be the syntactic form).\n/// Given the semantic form of the initializer list, one can retrieve\n/// the syntactic form of that initializer list (when different)\n/// using method getSyntacticForm(); the method returns null if applied\n/// to a initializer list which is already in syntactic form.\n/// Similarly, given the syntactic form (i.e., an initializer list such\n/// that isSemanticForm() returns false), one can retrieve the semantic\n/// form using method getSemanticForm().\n/// Since many initializer lists have the same syntactic and semantic forms,\n/// getSyntacticForm() may return NULL, indicating that the current\n/// semantic initializer list also serves as its syntactic form.\nclass InitListExpr : public Expr {\n  // FIXME: Eliminate this vector in favor of ASTContext allocation\n  typedef ASTVector<Stmt *> InitExprsTy;\n  InitExprsTy InitExprs;\n  SourceLocation LBraceLoc, RBraceLoc;\n\n  /// The alternative form of the initializer list (if it exists).\n  /// The int part of the pair stores whether this initializer list is\n  /// in semantic form. If not null, the pointer points to:\n  ///   - the syntactic form, if this is in semantic form;\n  ///   - the semantic form, if this is in syntactic form.\n  llvm::PointerIntPair<InitListExpr *, 1, bool> AltForm;\n\n  /// Either:\n  ///  If this initializer list initializes an array with more elements than\n  ///  there are initializers in the list, specifies an expression to be used\n  ///  for value initialization of the rest of the elements.\n  /// Or\n  ///  If this initializer list initializes a union, specifies which\n  ///  field within the union will be initialized.\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\npublic:\n  InitListExpr(const ASTContext &C, SourceLocation lbraceloc,\n               ArrayRef<Expr*> initExprs, SourceLocation rbraceloc);\n\n  /// Build an empty initializer list.\n  explicit InitListExpr(EmptyShell Empty)\n    : Expr(InitListExprClass, Empty), AltForm(nullptr, true) { }\n\n  unsigned getNumInits() const { return InitExprs.size(); }\n\n  /// Retrieve the set of initializers.\n  Expr **getInits() { return reinterpret_cast<Expr **>(InitExprs.data()); }\n\n  /// Retrieve the set of initializers.\n  Expr * const *getInits() const {\n    return reinterpret_cast<Expr * const *>(InitExprs.data());\n  }\n\n  ArrayRef<Expr *> inits() {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  ArrayRef<Expr *> inits() const {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  const Expr *getInit(unsigned Init) const {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  Expr *getInit(unsigned Init) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  void setInit(unsigned Init, Expr *expr) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    InitExprs[Init] = expr;\n\n    if (expr)\n      setDependence(getDependence() | expr->getDependence());\n  }\n\n  /// Mark the semantic form of the InitListExpr as error when the semantic\n  /// analysis fails.\n  void markError() {\n    assert(isSemanticForm());\n    setDependence(getDependence() | ExprDependence::ErrorDependent);\n  }\n\n  /// Reserve space for some number of initializers.\n  void reserveInits(const ASTContext &C, unsigned NumInits);\n\n  /// Specify the number of initializers\n  ///\n  /// If there are more than @p NumInits initializers, the remaining\n  /// initializers will be destroyed. If there are fewer than @p\n  /// NumInits initializers, NULL expressions will be added for the\n  /// unknown initializers.\n  void resizeInits(const ASTContext &Context, unsigned NumInits);\n\n  /// Updates the initializer at index @p Init with the new\n  /// expression @p expr, and returns the old expression at that\n  /// location.\n  ///\n  /// When @p Init is out of range for this initializer list, the\n  /// initializer list will be extended with NULL expressions to\n  /// accommodate the new entry.\n  Expr *updateInit(const ASTContext &C, unsigned Init, Expr *expr);\n\n  /// If this initializer list initializes an array with more elements\n  /// than there are initializers in the list, specifies an expression to be\n  /// used for value initialization of the rest of the elements.\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n  const Expr *getArrayFiller() const {\n    return const_cast<InitListExpr *>(this)->getArrayFiller();\n  }\n  void setArrayFiller(Expr *filler);\n\n  /// Return true if this is an array initializer and its array \"filler\"\n  /// has been set.\n  bool hasArrayFiller() const { return getArrayFiller(); }\n\n  /// If this initializes a union, specifies which field in the\n  /// union to initialize.\n  ///\n  /// Typically, this field is the first named field within the\n  /// union. However, a designated initializer can specify the\n  /// initialization of a different field within the union.\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return const_cast<InitListExpr *>(this)->getInitializedFieldInUnion();\n  }\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    assert((FD == nullptr\n            || getInitializedFieldInUnion() == nullptr\n            || getInitializedFieldInUnion() == FD)\n           && \"Only one field of a union may be initialized at a time!\");\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  // Explicit InitListExpr's originate from source code (and have valid source\n  // locations). Implicit InitListExpr's are created by the semantic analyzer.\n  // FIXME: This is wrong; InitListExprs created by semantic analysis have\n  // valid source locations too!\n  bool isExplicit() const {\n    return LBraceLoc.isValid() && RBraceLoc.isValid();\n  }\n\n  // Is this an initializer for an array of characters, initialized by a string\n  // literal or an @encode?\n  bool isStringLiteralInit() const;\n\n  /// Is this a transparent initializer list (that is, an InitListExpr that is\n  /// purely syntactic, and whose semantics are that of the sole contained\n  /// initializer)?\n  bool isTransparent() const;\n\n  /// Is this the zero initializer {0} in a language which considers it\n  /// idiomatic?\n  bool isIdiomaticZeroInitializer(const LangOptions &LangOpts) const;\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation Loc) { LBraceLoc = Loc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation Loc) { RBraceLoc = Loc; }\n\n  bool isSemanticForm() const { return AltForm.getInt(); }\n  InitListExpr *getSemanticForm() const {\n    return isSemanticForm() ? nullptr : AltForm.getPointer();\n  }\n  bool isSyntacticForm() const {\n    return !AltForm.getInt() || !AltForm.getPointer();\n  }\n  InitListExpr *getSyntacticForm() const {\n    return isSemanticForm() ? AltForm.getPointer() : nullptr;\n  }\n\n  void setSyntacticForm(InitListExpr *Init) {\n    AltForm.setPointer(Init);\n    AltForm.setInt(true);\n    Init->AltForm.setPointer(this);\n    Init->AltForm.setInt(false);\n  }\n\n  bool hadArrayRangeDesignator() const {\n    return InitListExprBits.HadArrayRangeDesignator != 0;\n  }\n  void sawArrayRangeDesignator(bool ARD = true) {\n    InitListExprBits.HadArrayRangeDesignator = ARD;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == InitListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    const_child_range CCR = const_cast<const InitListExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n\n  const_child_range children() const {\n    // FIXME: This does not include the array filler expression.\n    if (InitExprs.empty())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&InitExprs[0], &InitExprs[0] + InitExprs.size());\n  }\n\n  typedef InitExprsTy::iterator iterator;\n  typedef InitExprsTy::const_iterator const_iterator;\n  typedef InitExprsTy::reverse_iterator reverse_iterator;\n  typedef InitExprsTy::const_reverse_iterator const_reverse_iterator;\n\n  iterator begin() { return InitExprs.begin(); }\n  const_iterator begin() const { return InitExprs.begin(); }\n  iterator end() { return InitExprs.end(); }\n  const_iterator end() const { return InitExprs.end(); }\n  reverse_iterator rbegin() { return InitExprs.rbegin(); }\n  const_reverse_iterator rbegin() const { return InitExprs.rbegin(); }\n  reverse_iterator rend() { return InitExprs.rend(); }\n  const_reverse_iterator rend() const { return InitExprs.rend(); }\n\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents a C99 designated initializer expression.\n///\n/// A designated initializer expression (C99 6.7.8) contains one or\n/// more designators (which can be field designators, array\n/// designators, or GNU array-range designators) followed by an\n/// expression that initializes the field or element(s) that the\n/// designators refer to. For example, given:\n///\n/// @code\n/// struct point {\n///   double x;\n///   double y;\n/// };\n/// struct point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };\n/// @endcode\n///\n/// The InitListExpr contains three DesignatedInitExprs, the first of\n/// which covers @c [2].y=1.0. This DesignatedInitExpr will have two\n/// designators, one array designator for @c [2] followed by one field\n/// designator for @c .y. The initialization expression will be 1.0.\nclass DesignatedInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DesignatedInitExpr, Stmt *> {\npublic:\n  /// Forward declaration of the Designator class.\n  class Designator;\n\nprivate:\n  /// The location of the '=' or ':' prior to the actual initializer\n  /// expression.\n  SourceLocation EqualOrColonLoc;\n\n  /// Whether this designated initializer used the GNU deprecated\n  /// syntax rather than the C99 '=' syntax.\n  unsigned GNUSyntax : 1;\n\n  /// The number of designators in this initializer expression.\n  unsigned NumDesignators : 15;\n\n  /// The number of subexpressions of this initializer expression,\n  /// which contains both the initializer and any additional\n  /// expressions used by array and array-range designators.\n  unsigned NumSubExprs : 16;\n\n  /// The designators in this designated initialization\n  /// expression.\n  Designator *Designators;\n\n  DesignatedInitExpr(const ASTContext &C, QualType Ty,\n                     llvm::ArrayRef<Designator> Designators,\n                     SourceLocation EqualOrColonLoc, bool GNUSyntax,\n                     ArrayRef<Expr *> IndexExprs, Expr *Init);\n\n  explicit DesignatedInitExpr(unsigned NumSubExprs)\n    : Expr(DesignatedInitExprClass, EmptyShell()),\n      NumDesignators(0), NumSubExprs(NumSubExprs), Designators(nullptr) { }\n\npublic:\n  /// A field designator, e.g., \".x\".\n  struct FieldDesignator {\n    /// Refers to the field that is being initialized. The low bit\n    /// of this field determines whether this is actually a pointer\n    /// to an IdentifierInfo (if 1) or a FieldDecl (if 0). When\n    /// initially constructed, a field designator will store an\n    /// IdentifierInfo*. After semantic analysis has resolved that\n    /// name, the field designator will instead store a FieldDecl*.\n    uintptr_t NameOrField;\n\n    /// The location of the '.' in the designated initializer.\n    SourceLocation DotLoc;\n\n    /// The location of the field name in the designated initializer.\n    SourceLocation FieldLoc;\n  };\n\n  /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n  struct ArrayOrRangeDesignator {\n    /// Location of the first index expression within the designated\n    /// initializer expression's list of subexpressions.\n    unsigned Index;\n    /// The location of the '[' starting the array range designator.\n    SourceLocation LBracketLoc;\n    /// The location of the ellipsis separating the start and end\n    /// indices. Only valid for GNU array-range designators.\n    SourceLocation EllipsisLoc;\n    /// The location of the ']' terminating the array range designator.\n    SourceLocation RBracketLoc;\n  };\n\n  /// Represents a single C99 designator.\n  ///\n  /// @todo This class is infuriatingly similar to clang::Designator,\n  /// but minor differences (storing indices vs. storing pointers)\n  /// keep us from reusing it. Try harder, later, to rectify these\n  /// differences.\n  class Designator {\n    /// The kind of designator this describes.\n    enum {\n      FieldDesignator,\n      ArrayDesignator,\n      ArrayRangeDesignator\n    } Kind;\n\n    union {\n      /// A field designator, e.g., \".x\".\n      struct FieldDesignator Field;\n      /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n      struct ArrayOrRangeDesignator ArrayOrRange;\n    };\n    friend class DesignatedInitExpr;\n\n  public:\n    Designator() {}\n\n    /// Initializes a field designator.\n    Designator(const IdentifierInfo *FieldName, SourceLocation DotLoc,\n               SourceLocation FieldLoc)\n      : Kind(FieldDesignator) {\n      new (&Field) DesignatedInitExpr::FieldDesignator;\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FieldName) | 0x01;\n      Field.DotLoc = DotLoc;\n      Field.FieldLoc = FieldLoc;\n    }\n\n    /// Initializes an array designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation RBracketLoc)\n      : Kind(ArrayDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = SourceLocation();\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    /// Initializes a GNU array-range designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation EllipsisLoc, SourceLocation RBracketLoc)\n      : Kind(ArrayRangeDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = EllipsisLoc;\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    bool isFieldDesignator() const { return Kind == FieldDesignator; }\n    bool isArrayDesignator() const { return Kind == ArrayDesignator; }\n    bool isArrayRangeDesignator() const { return Kind == ArrayRangeDesignator; }\n\n    IdentifierInfo *getFieldName() const;\n\n    FieldDecl *getField() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      if (Field.NameOrField & 0x01)\n        return nullptr;\n      else\n        return reinterpret_cast<FieldDecl *>(Field.NameOrField);\n    }\n\n    void setField(FieldDecl *FD) {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FD);\n    }\n\n    SourceLocation getDotLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.DotLoc;\n    }\n\n    SourceLocation getFieldLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.FieldLoc;\n    }\n\n    SourceLocation getLBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.LBracketLoc;\n    }\n\n    SourceLocation getRBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.RBracketLoc;\n    }\n\n    SourceLocation getEllipsisLoc() const {\n      assert(Kind == ArrayRangeDesignator &&\n             \"Only valid on an array-range designator\");\n      return ArrayOrRange.EllipsisLoc;\n    }\n\n    unsigned getFirstExprIndex() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.Index;\n    }\n\n    SourceLocation getBeginLoc() const LLVM_READONLY {\n      if (Kind == FieldDesignator)\n        return getDotLoc().isInvalid()? getFieldLoc() : getDotLoc();\n      else\n        return getLBracketLoc();\n    }\n    SourceLocation getEndLoc() const LLVM_READONLY {\n      return Kind == FieldDesignator ? getFieldLoc() : getRBracketLoc();\n    }\n    SourceRange getSourceRange() const LLVM_READONLY {\n      return SourceRange(getBeginLoc(), getEndLoc());\n    }\n  };\n\n  static DesignatedInitExpr *Create(const ASTContext &C,\n                                    llvm::ArrayRef<Designator> Designators,\n                                    ArrayRef<Expr*> IndexExprs,\n                                    SourceLocation EqualOrColonLoc,\n                                    bool GNUSyntax, Expr *Init);\n\n  static DesignatedInitExpr *CreateEmpty(const ASTContext &C,\n                                         unsigned NumIndexExprs);\n\n  /// Returns the number of designators in this initializer.\n  unsigned size() const { return NumDesignators; }\n\n  // Iterator access to the designators.\n  llvm::MutableArrayRef<Designator> designators() {\n    return {Designators, NumDesignators};\n  }\n\n  llvm::ArrayRef<Designator> designators() const {\n    return {Designators, NumDesignators};\n  }\n\n  Designator *getDesignator(unsigned Idx) { return &designators()[Idx]; }\n  const Designator *getDesignator(unsigned Idx) const {\n    return &designators()[Idx];\n  }\n\n  void setDesignators(const ASTContext &C, const Designator *Desigs,\n                      unsigned NumDesigs);\n\n  Expr *getArrayIndex(const Designator &D) const;\n  Expr *getArrayRangeStart(const Designator &D) const;\n  Expr *getArrayRangeEnd(const Designator &D) const;\n\n  /// Retrieve the location of the '=' that precedes the\n  /// initializer value itself, if present.\n  SourceLocation getEqualOrColonLoc() const { return EqualOrColonLoc; }\n  void setEqualOrColonLoc(SourceLocation L) { EqualOrColonLoc = L; }\n\n  /// Whether this designated initializer should result in direct-initialization\n  /// of the designated subobject (eg, '{.foo{1, 2, 3}}').\n  bool isDirectInit() const { return EqualOrColonLoc.isInvalid(); }\n\n  /// Determines whether this designated initializer used the\n  /// deprecated GNU syntax for designated initializers.\n  bool usesGNUSyntax() const { return GNUSyntax; }\n  void setGNUSyntax(bool GNU) { GNUSyntax = GNU; }\n\n  /// Retrieve the initializer value.\n  Expr *getInit() const {\n    return cast<Expr>(*const_cast<DesignatedInitExpr*>(this)->child_begin());\n  }\n\n  void setInit(Expr *init) {\n    *child_begin() = init;\n  }\n\n  /// Retrieve the total number of subexpressions in this\n  /// designated initializer expression, including the actual\n  /// initialized value and any expressions that occur within array\n  /// and array-range designators.\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr *getSubExpr(unsigned Idx) const {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    return cast<Expr>(getTrailingObjects<Stmt *>()[Idx]);\n  }\n\n  void setSubExpr(unsigned Idx, Expr *E) {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    getTrailingObjects<Stmt *>()[Idx] = E;\n  }\n\n  /// Replaces the designator at index @p Idx with the series\n  /// of designators in [First, Last).\n  void ExpandDesignator(const ASTContext &C, unsigned Idx,\n                        const Designator *First, const Designator *Last);\n\n  SourceRange getDesignatorsSourceRange() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = getTrailingObjects<Stmt *>();\n    return child_range(begin, begin + NumSubExprs);\n  }\n  const_child_range children() const {\n    Stmt * const *begin = getTrailingObjects<Stmt *>();\n    return const_child_range(begin, begin + NumSubExprs);\n  }\n\n  friend TrailingObjects;\n};\n\n/// Represents a place-holder for an object not to be initialized by\n/// anything.\n///\n/// This only makes sense when it appears as part of an updater of a\n/// DesignatedInitUpdateExpr (see below). The base expression of a DIUE\n/// initializes a big object, and the NoInitExpr's mark the spots within the\n/// big object not to be overwritten by the updater.\n///\n/// \\see DesignatedInitUpdateExpr\nclass NoInitExpr : public Expr {\npublic:\n  explicit NoInitExpr(QualType ty)\n      : Expr(NoInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit NoInitExpr(EmptyShell Empty)\n    : Expr(NoInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == NoInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n// In cases like:\n//   struct Q { int a, b, c; };\n//   Q *getQ();\n//   void foo() {\n//     struct A { Q q; } a = { *getQ(), .q.b = 3 };\n//   }\n//\n// We will have an InitListExpr for a, with type A, and then a\n// DesignatedInitUpdateExpr for \"a.q\" with type Q. The \"base\" for this DIUE\n// is the call expression *getQ(); the \"updater\" for the DIUE is \".q.b = 3\"\n//\nclass DesignatedInitUpdateExpr : public Expr {\n  // BaseAndUpdaterExprs[0] is the base expression;\n  // BaseAndUpdaterExprs[1] is an InitListExpr overwriting part of the base.\n  Stmt *BaseAndUpdaterExprs[2];\n\npublic:\n  DesignatedInitUpdateExpr(const ASTContext &C, SourceLocation lBraceLoc,\n                           Expr *baseExprs, SourceLocation rBraceLoc);\n\n  explicit DesignatedInitUpdateExpr(EmptyShell Empty)\n    : Expr(DesignatedInitUpdateExprClass, Empty) { }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitUpdateExprClass;\n  }\n\n  Expr *getBase() const { return cast<Expr>(BaseAndUpdaterExprs[0]); }\n  void setBase(Expr *Base) { BaseAndUpdaterExprs[0] = Base; }\n\n  InitListExpr *getUpdater() const {\n    return cast<InitListExpr>(BaseAndUpdaterExprs[1]);\n  }\n  void setUpdater(Expr *Updater) { BaseAndUpdaterExprs[1] = Updater; }\n\n  // Iterators\n  // children = the base and the updater\n  child_range children() {\n    return child_range(&BaseAndUpdaterExprs[0], &BaseAndUpdaterExprs[0] + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(&BaseAndUpdaterExprs[0],\n                             &BaseAndUpdaterExprs[0] + 2);\n  }\n};\n\n/// Represents a loop initializing the elements of an array.\n///\n/// The need to initialize the elements of an array occurs in a number of\n/// contexts:\n///\n///  * in the implicit copy/move constructor for a class with an array member\n///  * when a lambda-expression captures an array by value\n///  * when a decomposition declaration decomposes an array\n///\n/// There are two subexpressions: a common expression (the source array)\n/// that is evaluated once up-front, and a per-element initializer that\n/// runs once for each array element.\n///\n/// Within the per-element initializer, the common expression may be referenced\n/// via an OpaqueValueExpr, and the current index may be obtained via an\n/// ArrayInitIndexExpr.\nclass ArrayInitLoopExpr : public Expr {\n  Stmt *SubExprs[2];\n\n  explicit ArrayInitLoopExpr(EmptyShell Empty)\n      : Expr(ArrayInitLoopExprClass, Empty), SubExprs{} {}\n\npublic:\n  explicit ArrayInitLoopExpr(QualType T, Expr *CommonInit, Expr *ElementInit)\n      : Expr(ArrayInitLoopExprClass, T, VK_RValue, OK_Ordinary),\n        SubExprs{CommonInit, ElementInit} {\n    setDependence(computeDependence(this));\n  }\n\n  /// Get the common subexpression shared by all initializations (the source\n  /// array).\n  OpaqueValueExpr *getCommonExpr() const {\n    return cast<OpaqueValueExpr>(SubExprs[0]);\n  }\n\n  /// Get the initializer to use for each array element.\n  Expr *getSubExpr() const { return cast<Expr>(SubExprs[1]); }\n\n  llvm::APInt getArraySize() const {\n    return cast<ConstantArrayType>(getType()->castAsArrayTypeUnsafe())\n        ->getSize();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitLoopExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommonExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCommonExpr()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents the index of the current element of an array being\n/// initialized by an ArrayInitLoopExpr. This can only appear within the\n/// subexpression of an ArrayInitLoopExpr.\nclass ArrayInitIndexExpr : public Expr {\n  explicit ArrayInitIndexExpr(EmptyShell Empty)\n      : Expr(ArrayInitIndexExprClass, Empty) {}\n\npublic:\n  explicit ArrayInitIndexExpr(QualType T)\n      : Expr(ArrayInitIndexExprClass, T, VK_RValue, OK_Ordinary) {\n    setDependence(ExprDependence::None);\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitIndexExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n};\n\n/// Represents an implicitly-generated value initialization of\n/// an object of a given type.\n///\n/// Implicit value initializations occur within semantic initializer\n/// list expressions (InitListExpr) as placeholders for subobject\n/// initializations not explicitly specified by the user.\n///\n/// \\see InitListExpr\nclass ImplicitValueInitExpr : public Expr {\npublic:\n  explicit ImplicitValueInitExpr(QualType ty)\n      : Expr(ImplicitValueInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty implicit value initialization.\n  explicit ImplicitValueInitExpr(EmptyShell Empty)\n    : Expr(ImplicitValueInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitValueInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass ParenListExpr final\n    : public Expr,\n      private llvm::TrailingObjects<ParenListExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The location of the left and right parentheses.\n  SourceLocation LParenLoc, RParenLoc;\n\n  /// Build a paren list.\n  ParenListExpr(SourceLocation LParenLoc, ArrayRef<Expr *> Exprs,\n                SourceLocation RParenLoc);\n\n  /// Build an empty paren list.\n  ParenListExpr(EmptyShell Empty, unsigned NumExprs);\n\npublic:\n  /// Create a paren list.\n  static ParenListExpr *Create(const ASTContext &Ctx, SourceLocation LParenLoc,\n                               ArrayRef<Expr *> Exprs,\n                               SourceLocation RParenLoc);\n\n  /// Create an empty paren list.\n  static ParenListExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumExprs);\n\n  /// Return the number of expressions in this paren list.\n  unsigned getNumExprs() const { return ParenListExprBits.NumExprs; }\n\n  Expr *getExpr(unsigned Init) {\n    assert(Init < getNumExprs() && \"Initializer access out of range!\");\n    return getExprs()[Init];\n  }\n\n  const Expr *getExpr(unsigned Init) const {\n    return const_cast<ParenListExpr *>(this)->getExpr(Init);\n  }\n\n  Expr **getExprs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<Stmt *>());\n  }\n\n  ArrayRef<Expr *> exprs() {\n    return llvm::makeArrayRef(getExprs(), getNumExprs());\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getLParenLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n};\n\n/// Represents a C11 generic selection.\n///\n/// A generic selection (C11 6.5.1.1) contains an unevaluated controlling\n/// expression, followed by one or more generic associations.  Each generic\n/// association specifies a type name and an expression, or \"default\" and an\n/// expression (in which case it is known as a default generic association).\n/// The type and value of the generic selection are identical to those of its\n/// result expression, which is defined as the expression in the generic\n/// association with a type name that is compatible with the type of the\n/// controlling expression, or the expression in the default generic association\n/// if no types are compatible.  For example:\n///\n/// @code\n/// _Generic(X, double: 1, float: 2, default: 3)\n/// @endcode\n///\n/// The above expression evaluates to 1 if 1.0 is substituted for X, 2 if 1.0f\n/// or 3 if \"hello\".\n///\n/// As an extension, generic selections are allowed in C++, where the following\n/// additional semantics apply:\n///\n/// Any generic selection whose controlling expression is type-dependent or\n/// which names a dependent type in its association list is result-dependent,\n/// which means that the choice of result expression is dependent.\n/// Result-dependent generic associations are both type- and value-dependent.\nclass GenericSelectionExpr final\n    : public Expr,\n      private llvm::TrailingObjects<GenericSelectionExpr, Stmt *,\n                                    TypeSourceInfo *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The number of association expressions and the index of the result\n  /// expression in the case where the generic selection expression is not\n  /// result-dependent. The result index is equal to ResultDependentIndex\n  /// if and only if the generic selection expression is result-dependent.\n  unsigned NumAssocs, ResultIndex;\n  enum : unsigned {\n    ResultDependentIndex = std::numeric_limits<unsigned>::max(),\n    ControllingIndex = 0,\n    AssocExprStartIndex = 1\n  };\n\n  /// The location of the \"default\" and of the right parenthesis.\n  SourceLocation DefaultLoc, RParenLoc;\n\n  // GenericSelectionExpr is followed by several trailing objects.\n  // They are (in order):\n  //\n  // * A single Stmt * for the controlling expression.\n  // * An array of getNumAssocs() Stmt * for the association expressions.\n  // * An array of getNumAssocs() TypeSourceInfo *, one for each of the\n  //   association expressions.\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    // Add one to account for the controlling expression; the remainder\n    // are the associated expressions.\n    return 1 + getNumAssocs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TypeSourceInfo *>) const {\n    return getNumAssocs();\n  }\n\n  template <bool Const> class AssociationIteratorTy;\n  /// Bundle together an association expression and its TypeSourceInfo.\n  /// The Const template parameter is for the const and non-const versions\n  /// of AssociationTy.\n  template <bool Const> class AssociationTy {\n    friend class GenericSelectionExpr;\n    template <bool OtherConst> friend class AssociationIteratorTy;\n    using ExprPtrTy = std::conditional_t<Const, const Expr *, Expr *>;\n    using TSIPtrTy =\n        std::conditional_t<Const, const TypeSourceInfo *, TypeSourceInfo *>;\n    ExprPtrTy E;\n    TSIPtrTy TSI;\n    bool Selected;\n    AssociationTy(ExprPtrTy E, TSIPtrTy TSI, bool Selected)\n        : E(E), TSI(TSI), Selected(Selected) {}\n\n  public:\n    ExprPtrTy getAssociationExpr() const { return E; }\n    TSIPtrTy getTypeSourceInfo() const { return TSI; }\n    QualType getType() const { return TSI ? TSI->getType() : QualType(); }\n    bool isSelected() const { return Selected; }\n    AssociationTy *operator->() { return this; }\n    const AssociationTy *operator->() const { return this; }\n  }; // class AssociationTy\n\n  /// Iterator over const and non-const Association objects. The Association\n  /// objects are created on the fly when the iterator is dereferenced.\n  /// This abstract over how exactly the association expressions and the\n  /// corresponding TypeSourceInfo * are stored.\n  template <bool Const>\n  class AssociationIteratorTy\n      : public llvm::iterator_facade_base<\n            AssociationIteratorTy<Const>, std::input_iterator_tag,\n            AssociationTy<Const>, std::ptrdiff_t, AssociationTy<Const>,\n            AssociationTy<Const>> {\n    friend class GenericSelectionExpr;\n    // FIXME: This iterator could conceptually be a random access iterator, and\n    // it would be nice if we could strengthen the iterator category someday.\n    // However this iterator does not satisfy two requirements of forward\n    // iterators:\n    // a) reference = T& or reference = const T&\n    // b) If It1 and It2 are both dereferenceable, then It1 == It2 if and only\n    //    if *It1 and *It2 are bound to the same objects.\n    // An alternative design approach was discussed during review;\n    // store an Association object inside the iterator, and return a reference\n    // to it when dereferenced. This idea was discarded beacuse of nasty\n    // lifetime issues:\n    //    AssociationIterator It = ...;\n    //    const Association &Assoc = *It++; // Oops, Assoc is dangling.\n    using BaseTy = typename AssociationIteratorTy::iterator_facade_base;\n    using StmtPtrPtrTy =\n        std::conditional_t<Const, const Stmt *const *, Stmt **>;\n    using TSIPtrPtrTy = std::conditional_t<Const, const TypeSourceInfo *const *,\n                                           TypeSourceInfo **>;\n    StmtPtrPtrTy E; // = nullptr; FIXME: Once support for gcc 4.8 is dropped.\n    TSIPtrPtrTy TSI; // Kept in sync with E.\n    unsigned Offset = 0, SelectedOffset = 0;\n    AssociationIteratorTy(StmtPtrPtrTy E, TSIPtrPtrTy TSI, unsigned Offset,\n                          unsigned SelectedOffset)\n        : E(E), TSI(TSI), Offset(Offset), SelectedOffset(SelectedOffset) {}\n\n  public:\n    AssociationIteratorTy() : E(nullptr), TSI(nullptr) {}\n    typename BaseTy::reference operator*() const {\n      return AssociationTy<Const>(cast<Expr>(*E), *TSI,\n                                  Offset == SelectedOffset);\n    }\n    typename BaseTy::pointer operator->() const { return **this; }\n    using BaseTy::operator++;\n    AssociationIteratorTy &operator++() {\n      ++E;\n      ++TSI;\n      ++Offset;\n      return *this;\n    }\n    bool operator==(AssociationIteratorTy Other) const { return E == Other.E; }\n  }; // class AssociationIterator\n\n  /// Build a non-result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack,\n                       unsigned ResultIndex);\n\n  /// Build a result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack);\n\n  /// Build an empty generic selection expression for deserialization.\n  explicit GenericSelectionExpr(EmptyShell Empty, unsigned NumAssocs);\n\npublic:\n  /// Create a non-result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack,\n         unsigned ResultIndex);\n\n  /// Create a result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack);\n\n  /// Create an empty generic selection expression for deserialization.\n  static GenericSelectionExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumAssocs);\n\n  using Association = AssociationTy<false>;\n  using ConstAssociation = AssociationTy<true>;\n  using AssociationIterator = AssociationIteratorTy<false>;\n  using ConstAssociationIterator = AssociationIteratorTy<true>;\n  using association_range = llvm::iterator_range<AssociationIterator>;\n  using const_association_range =\n      llvm::iterator_range<ConstAssociationIterator>;\n\n  /// The number of association expressions.\n  unsigned getNumAssocs() const { return NumAssocs; }\n\n  /// The zero-based index of the result expression's generic association in\n  /// the generic selection's association list.  Defined only if the\n  /// generic selection is not result-dependent.\n  unsigned getResultIndex() const {\n    assert(!isResultDependent() &&\n           \"Generic selection is result-dependent but getResultIndex called!\");\n    return ResultIndex;\n  }\n\n  /// Whether this generic selection is result-dependent.\n  bool isResultDependent() const { return ResultIndex == ResultDependentIndex; }\n\n  /// Return the controlling expression of this generic selection expression.\n  Expr *getControllingExpr() {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n  const Expr *getControllingExpr() const {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n\n  /// Return the result expression of this controlling expression. Defined if\n  /// and only if the generic selection expression is not result-dependent.\n  Expr *getResultExpr() {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n  const Expr *getResultExpr() const {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n\n  ArrayRef<Expr *> getAssocExprs() const {\n    return {reinterpret_cast<Expr *const *>(getTrailingObjects<Stmt *>() +\n                                            AssocExprStartIndex),\n            NumAssocs};\n  }\n  ArrayRef<TypeSourceInfo *> getAssocTypeSourceInfos() const {\n    return {getTrailingObjects<TypeSourceInfo *>(), NumAssocs};\n  }\n\n  /// Return the Ith association expression with its TypeSourceInfo,\n  /// bundled together in GenericSelectionExpr::(Const)Association.\n  Association getAssociation(unsigned I) {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return Association(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n  ConstAssociation getAssociation(unsigned I) const {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return ConstAssociation(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n\n  association_range associations() {\n    AssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                  AssocExprStartIndex,\n                              getTrailingObjects<TypeSourceInfo *>(),\n                              /*Offset=*/0, ResultIndex);\n    AssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                            /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  const_association_range associations() const {\n    ConstAssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                       AssocExprStartIndex,\n                                   getTrailingObjects<TypeSourceInfo *>(),\n                                   /*Offset=*/0, ResultIndex);\n    ConstAssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                                 /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  SourceLocation getGenericLoc() const {\n    return GenericSelectionExprBits.GenericLoc;\n  }\n  SourceLocation getDefaultLoc() const { return DefaultLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getGenericLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GenericSelectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Clang Extensions\n//===----------------------------------------------------------------------===//\n\n/// ExtVectorElementExpr - This represents access to specific elements of a\n/// vector, and may occur on the left hand side or right hand side.  For example\n/// the following is legal:  \"V.xy = V.zw\" if V is a 4 element extended vector.\n///\n/// Note that the base may have either vector or pointer to vector type, just\n/// like a struct field reference.\n///\nclass ExtVectorElementExpr : public Expr {\n  Stmt *Base;\n  IdentifierInfo *Accessor;\n  SourceLocation AccessorLoc;\npublic:\n  ExtVectorElementExpr(QualType ty, ExprValueKind VK, Expr *base,\n                       IdentifierInfo &accessor, SourceLocation loc)\n      : Expr(ExtVectorElementExprClass, ty, VK,\n             (VK == VK_RValue ? OK_Ordinary : OK_VectorComponent)),\n        Base(base), Accessor(&accessor), AccessorLoc(loc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty vector element expression.\n  explicit ExtVectorElementExpr(EmptyShell Empty)\n    : Expr(ExtVectorElementExprClass, Empty) { }\n\n  const Expr *getBase() const { return cast<Expr>(Base); }\n  Expr *getBase() { return cast<Expr>(Base); }\n  void setBase(Expr *E) { Base = E; }\n\n  IdentifierInfo &getAccessor() const { return *Accessor; }\n  void setAccessor(IdentifierInfo *II) { Accessor = II; }\n\n  SourceLocation getAccessorLoc() const { return AccessorLoc; }\n  void setAccessorLoc(SourceLocation L) { AccessorLoc = L; }\n\n  /// getNumElements - Get the number of components being selected.\n  unsigned getNumElements() const;\n\n  /// containsDuplicateElements - Return true if any element access is\n  /// repeated.\n  bool containsDuplicateElements() const;\n\n  /// getEncodedElementAccess - Encode the elements accessed into an llvm\n  /// aggregate Constant of ConstantInt(s).\n  void getEncodedElementAccess(SmallVectorImpl<uint32_t> &Elts) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return AccessorLoc; }\n\n  /// isArrow - Return true if the base expression is a pointer to vector,\n  /// return false if the base expression is a vector.\n  bool isArrow() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExtVectorElementExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// BlockExpr - Adaptor class for mixing a BlockDecl with expressions.\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockExpr : public Expr {\nprotected:\n  BlockDecl *TheBlock;\npublic:\n  BlockExpr(BlockDecl *BD, QualType ty)\n      : Expr(BlockExprClass, ty, VK_RValue, OK_Ordinary), TheBlock(BD) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty block expression.\n  explicit BlockExpr(EmptyShell Empty) : Expr(BlockExprClass, Empty) { }\n\n  const BlockDecl *getBlockDecl() const { return TheBlock; }\n  BlockDecl *getBlockDecl() { return TheBlock; }\n  void setBlockDecl(BlockDecl *BD) { TheBlock = BD; }\n\n  // Convenience functions for probing the underlying BlockDecl.\n  SourceLocation getCaretLocation() const;\n  const Stmt *getBody() const;\n  Stmt *getBody();\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCaretLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody()->getEndLoc();\n  }\n\n  /// getFunctionType - Return the underlying function type for this block.\n  const FunctionProtoType *getFunctionType() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BlockExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Copy initialization expr of a __block variable and a boolean flag that\n/// indicates whether the expression can throw.\nstruct BlockVarCopyInit {\n  BlockVarCopyInit() = default;\n  BlockVarCopyInit(Expr *CopyExpr, bool CanThrow)\n      : ExprAndFlag(CopyExpr, CanThrow) {}\n  void setExprAndFlag(Expr *CopyExpr, bool CanThrow) {\n    ExprAndFlag.setPointerAndInt(CopyExpr, CanThrow);\n  }\n  Expr *getCopyExpr() const { return ExprAndFlag.getPointer(); }\n  bool canThrow() const { return ExprAndFlag.getInt(); }\n  llvm::PointerIntPair<Expr *, 1, bool> ExprAndFlag;\n};\n\n/// AsTypeExpr - Clang builtin function __builtin_astype [OpenCL 6.2.4.2]\n/// This AST node provides support for reinterpreting a type to another\n/// type of the same size.\nclass AsTypeExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit AsTypeExpr(EmptyShell Empty) : Expr(AsTypeExprClass, Empty) {}\n\npublic:\n  AsTypeExpr(Expr *SrcExpr, QualType DstType, ExprValueKind VK,\n             ExprObjectKind OK, SourceLocation BuiltinLoc,\n             SourceLocation RParenLoc)\n      : Expr(AsTypeExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getBuiltinLoc - Return the location of the __builtin_astype token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AsTypeExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// PseudoObjectExpr - An expression which accesses a pseudo-object\n/// l-value.  A pseudo-object is an abstract object, accesses to which\n/// are translated to calls.  The pseudo-object expression has a\n/// syntactic form, which shows how the expression was actually\n/// written in the source code, and a semantic form, which is a series\n/// of expressions to be executed in order which detail how the\n/// operation is actually evaluated.  Optionally, one of the semantic\n/// forms may also provide a result value for the expression.\n///\n/// If any of the semantic-form expressions is an OpaqueValueExpr,\n/// that OVE is required to have a source expression, and it is bound\n/// to the result of that source expression.  Such OVEs may appear\n/// only in subsequent semantic-form expressions and as\n/// sub-expressions of the syntactic form.\n///\n/// PseudoObjectExpr should be used only when an operation can be\n/// usefully described in terms of fairly simple rewrite rules on\n/// objects and functions that are meant to be used by end-developers.\n/// For example, under the Itanium ABI, dynamic casts are implemented\n/// as a call to a runtime function called __dynamic_cast; using this\n/// class to describe that would be inappropriate because that call is\n/// not really part of the user-visible semantics, and instead the\n/// cast is properly reflected in the AST and IR-generation has been\n/// taught to generate the call as necessary.  In contrast, an\n/// Objective-C property access is semantically defined to be\n/// equivalent to a particular message send, and this is very much\n/// part of the user model.  The name of this class encourages this\n/// modelling design.\nclass PseudoObjectExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PseudoObjectExpr, Expr *> {\n  // PseudoObjectExprBits.NumSubExprs - The number of sub-expressions.\n  // Always at least two, because the first sub-expression is the\n  // syntactic form.\n\n  // PseudoObjectExprBits.ResultIndex - The index of the\n  // sub-expression holding the result.  0 means the result is void,\n  // which is unambiguous because it's the index of the syntactic\n  // form.  Note that this is therefore 1 higher than the value passed\n  // in to Create, which is an index within the semantic forms.\n  // Note also that ASTStmtWriter assumes this encoding.\n\n  Expr **getSubExprsBuffer() { return getTrailingObjects<Expr *>(); }\n  const Expr * const *getSubExprsBuffer() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  PseudoObjectExpr(QualType type, ExprValueKind VK,\n                   Expr *syntactic, ArrayRef<Expr*> semantic,\n                   unsigned resultIndex);\n\n  PseudoObjectExpr(EmptyShell shell, unsigned numSemanticExprs);\n\n  unsigned getNumSubExprs() const {\n    return PseudoObjectExprBits.NumSubExprs;\n  }\n\npublic:\n  /// NoResult - A value for the result index indicating that there is\n  /// no semantic result.\n  enum : unsigned { NoResult = ~0U };\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, Expr *syntactic,\n                                  ArrayRef<Expr*> semantic,\n                                  unsigned resultIndex);\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, EmptyShell shell,\n                                  unsigned numSemanticExprs);\n\n  /// Return the syntactic form of this expression, i.e. the\n  /// expression it actually looks like.  Likely to be expressed in\n  /// terms of OpaqueValueExprs bound in the semantic form.\n  Expr *getSyntacticForm() { return getSubExprsBuffer()[0]; }\n  const Expr *getSyntacticForm() const { return getSubExprsBuffer()[0]; }\n\n  /// Return the index of the result-bearing expression into the semantics\n  /// expressions, or PseudoObjectExpr::NoResult if there is none.\n  unsigned getResultExprIndex() const {\n    if (PseudoObjectExprBits.ResultIndex == 0) return NoResult;\n    return PseudoObjectExprBits.ResultIndex - 1;\n  }\n\n  /// Return the result-bearing expression, or null if there is none.\n  Expr *getResultExpr() {\n    if (PseudoObjectExprBits.ResultIndex == 0)\n      return nullptr;\n    return getSubExprsBuffer()[PseudoObjectExprBits.ResultIndex];\n  }\n  const Expr *getResultExpr() const {\n    return const_cast<PseudoObjectExpr*>(this)->getResultExpr();\n  }\n\n  unsigned getNumSemanticExprs() const { return getNumSubExprs() - 1; }\n\n  typedef Expr * const *semantics_iterator;\n  typedef const Expr * const *const_semantics_iterator;\n  semantics_iterator semantics_begin() {\n    return getSubExprsBuffer() + 1;\n  }\n  const_semantics_iterator semantics_begin() const {\n    return getSubExprsBuffer() + 1;\n  }\n  semantics_iterator semantics_end() {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n  const_semantics_iterator semantics_end() const {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n\n  llvm::iterator_range<semantics_iterator> semantics() {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n  llvm::iterator_range<const_semantics_iterator> semantics() const {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n\n  Expr *getSemanticExpr(unsigned index) {\n    assert(index + 1 < getNumSubExprs());\n    return getSubExprsBuffer()[index + 1];\n  }\n  const Expr *getSemanticExpr(unsigned index) const {\n    return const_cast<PseudoObjectExpr*>(this)->getSemanticExpr(index);\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getExprLoc();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getEndLoc();\n  }\n\n  child_range children() {\n    const_child_range CCR =\n        const_cast<const PseudoObjectExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n  const_child_range children() const {\n    Stmt *const *cs = const_cast<Stmt *const *>(\n        reinterpret_cast<const Stmt *const *>(getSubExprsBuffer()));\n    return const_child_range(cs, cs + getNumSubExprs());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PseudoObjectExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n};\n\n/// AtomicExpr - Variadic atomic builtins: __atomic_exchange, __atomic_fetch_*,\n/// __atomic_load, __atomic_store, and __atomic_compare_exchange_*, for the\n/// similarly-named C++11 instructions, and __c11 variants for <stdatomic.h>,\n/// and corresponding __opencl_atomic_* for OpenCL 2.0.\n/// All of these instructions take one primary pointer, at least one memory\n/// order. The instructions for which getScopeModel returns non-null value\n/// take one synch scope.\nclass AtomicExpr : public Expr {\npublic:\n  enum AtomicOp {\n#define BUILTIN(ID, TYPE, ATTRS)\n#define ATOMIC_BUILTIN(ID, TYPE, ATTRS) AO ## ID,\n#include \"clang/Basic/Builtins.def\"\n    // Avoid trailing comma\n    BI_First = 0\n  };\n\nprivate:\n  /// Location of sub-expressions.\n  /// The location of Scope sub-expression is NumSubExprs - 1, which is\n  /// not fixed, therefore is not defined in enum.\n  enum { PTR, ORDER, VAL1, ORDER_FAIL, VAL2, WEAK, END_EXPR };\n  Stmt *SubExprs[END_EXPR + 1];\n  unsigned NumSubExprs;\n  SourceLocation BuiltinLoc, RParenLoc;\n  AtomicOp Op;\n\n  friend class ASTStmtReader;\npublic:\n  AtomicExpr(SourceLocation BLoc, ArrayRef<Expr*> args, QualType t,\n             AtomicOp op, SourceLocation RP);\n\n  /// Determine the number of arguments the specified atomic builtin\n  /// should have.\n  static unsigned getNumSubExprs(AtomicOp Op);\n\n  /// Build an empty AtomicExpr.\n  explicit AtomicExpr(EmptyShell Empty) : Expr(AtomicExprClass, Empty) { }\n\n  Expr *getPtr() const {\n    return cast<Expr>(SubExprs[PTR]);\n  }\n  Expr *getOrder() const {\n    return cast<Expr>(SubExprs[ORDER]);\n  }\n  Expr *getScope() const {\n    assert(getScopeModel() && \"No scope\");\n    return cast<Expr>(SubExprs[NumSubExprs - 1]);\n  }\n  Expr *getVal1() const {\n    if (Op == AO__c11_atomic_init || Op == AO__opencl_atomic_init)\n      return cast<Expr>(SubExprs[ORDER]);\n    assert(NumSubExprs > VAL1);\n    return cast<Expr>(SubExprs[VAL1]);\n  }\n  Expr *getOrderFail() const {\n    assert(NumSubExprs > ORDER_FAIL);\n    return cast<Expr>(SubExprs[ORDER_FAIL]);\n  }\n  Expr *getVal2() const {\n    if (Op == AO__atomic_exchange)\n      return cast<Expr>(SubExprs[ORDER_FAIL]);\n    assert(NumSubExprs > VAL2);\n    return cast<Expr>(SubExprs[VAL2]);\n  }\n  Expr *getWeak() const {\n    assert(NumSubExprs > WEAK);\n    return cast<Expr>(SubExprs[WEAK]);\n  }\n  QualType getValueType() const;\n\n  AtomicOp getOp() const { return Op; }\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n  const Expr * const *getSubExprs() const {\n    return reinterpret_cast<Expr * const *>(SubExprs);\n  }\n\n  bool isVolatile() const {\n    return getPtr()->getType()->getPointeeType().isVolatileQualified();\n  }\n\n  bool isCmpXChg() const {\n    return getOp() == AO__c11_atomic_compare_exchange_strong ||\n           getOp() == AO__c11_atomic_compare_exchange_weak ||\n           getOp() == AO__opencl_atomic_compare_exchange_strong ||\n           getOp() == AO__opencl_atomic_compare_exchange_weak ||\n           getOp() == AO__atomic_compare_exchange ||\n           getOp() == AO__atomic_compare_exchange_n;\n  }\n\n  bool isOpenCL() const {\n    return getOp() >= AO__opencl_atomic_init &&\n           getOp() <= AO__opencl_atomic_fetch_max;\n  }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AtomicExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs+NumSubExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NumSubExprs);\n  }\n\n  /// Get atomic scope model for the atomic op code.\n  /// \\return empty atomic scope model if the atomic op code does not have\n  ///   scope operand.\n  static std::unique_ptr<AtomicScopeModel> getScopeModel(AtomicOp Op) {\n    auto Kind =\n        (Op >= AO__opencl_atomic_load && Op <= AO__opencl_atomic_fetch_max)\n            ? AtomicScopeModelKind::OpenCL\n            : AtomicScopeModelKind::None;\n    return AtomicScopeModel::create(Kind);\n  }\n\n  /// Get atomic scope model.\n  /// \\return empty atomic scope model if this atomic expression does not have\n  ///   scope operand.\n  std::unique_ptr<AtomicScopeModel> getScopeModel() const {\n    return getScopeModel(getOp());\n  }\n};\n\n/// TypoExpr - Internal placeholder for expressions where typo correction\n/// still needs to be performed and/or an error diagnostic emitted.\nclass TypoExpr : public Expr {\n  // The location for the typo name.\n  SourceLocation TypoLoc;\n\npublic:\n  TypoExpr(QualType T, SourceLocation TypoLoc)\n      : Expr(TypoExprClass, T, VK_LValue, OK_Ordinary), TypoLoc(TypoLoc) {\n    assert(T->isDependentType() && \"TypoExpr given a non-dependent type\");\n    setDependence(ExprDependence::TypeValueInstantiation |\n                  ExprDependence::Error);\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TypoLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TypoLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == TypoExprClass;\n  }\n\n};\n\n/// Frontend produces RecoveryExprs on semantic errors that prevent creating\n/// other well-formed expressions. E.g. when type-checking of a binary operator\n/// fails, we cannot produce a BinaryOperator expression. Instead, we can choose\n/// to produce a recovery expression storing left and right operands.\n///\n/// RecoveryExpr does not have any semantic meaning in C++, it is only useful to\n/// preserve expressions in AST that would otherwise be dropped. It captures\n/// subexpressions of some expression that we could not construct and source\n/// range covered by the expression.\n///\n/// By default, RecoveryExpr uses dependence-bits to take advantage of existing\n/// machinery to deal with dependent code in C++, e.g. RecoveryExpr is preserved\n/// in `decltype(<broken-expr>)` as part of the `DependentDecltypeType`. In\n/// addition to that, clang does not report most errors on dependent\n/// expressions, so we get rid of bogus errors for free. However, note that\n/// unlike other dependent expressions, RecoveryExpr can be produced in\n/// non-template contexts.\n///\n/// We will preserve the type in RecoveryExpr when the type is known, e.g.\n/// preserving the return type for a broken non-overloaded function call, a\n/// overloaded call where all candidates have the same return type. In this\n/// case, the expression is not type-dependent (unless the known type is itself\n/// dependent)\n///\n/// One can also reliably suppress all bogus errors on expressions containing\n/// recovery expressions by examining results of Expr::containsErrors().\nclass RecoveryExpr final : public Expr,\n                           private llvm::TrailingObjects<RecoveryExpr, Expr *> {\npublic:\n  static RecoveryExpr *Create(ASTContext &Ctx, QualType T,\n                              SourceLocation BeginLoc, SourceLocation EndLoc,\n                              ArrayRef<Expr *> SubExprs);\n  static RecoveryExpr *CreateEmpty(ASTContext &Ctx, unsigned NumSubExprs);\n\n  ArrayRef<Expr *> subExpressions() {\n    auto *B = getTrailingObjects<Expr *>();\n    return llvm::makeArrayRef(B, B + NumExprs);\n  }\n\n  ArrayRef<const Expr *> subExpressions() const {\n    return const_cast<RecoveryExpr *>(this)->subExpressions();\n  }\n\n  child_range children() {\n    Stmt **B = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(B, B + NumExprs);\n  }\n\n  SourceLocation getBeginLoc() const { return BeginLoc; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == RecoveryExprClass;\n  }\n\nprivate:\n  RecoveryExpr(ASTContext &Ctx, QualType T, SourceLocation BeginLoc,\n               SourceLocation EndLoc, ArrayRef<Expr *> SubExprs);\n  RecoveryExpr(EmptyShell Empty, unsigned NumSubExprs)\n      : Expr(RecoveryExprClass, Empty), NumExprs(NumSubExprs) {}\n\n  size_t numTrailingObjects(OverloadToken<Stmt *>) const { return NumExprs; }\n\n  SourceLocation BeginLoc, EndLoc;\n  unsigned NumExprs;\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_AST_EXPR_H\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 27, "line": 608}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 27, "line": 608}, "message": "default constructor 'EvalResult' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "bd8789c5f10351eade7298be1d50634a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
